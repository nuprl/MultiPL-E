name: HumanEval_116_sort_array
language: swift
prompt: "\n/// In this Kata, you have to sort an array of non-negative integers according\
  \ to\n/// number of ones in their binary representation in ascending order.\n///\
  \ For similar number of ones, sort based on decimal value.\n/// It must be implemented\
  \ like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n/// [1, 2, 3, 4, 5]\n///\
  \ >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5, -4, -3, -2]\n/// >>> sort_array(arr:\
  \ [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\nfunc sort_array(arr: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1,\
  \ 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5,\
  \ -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
  \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7,\
  \ 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6,\
  \ 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16,\
  \ 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4,\
  \ 8, 16, 32])"
completions: ["    let n = arr.count\n    if n < 2 {\n        return arr\n    }\n\
    \    var newArr: [Int] = Array(repeating: 0, count: n)\n    for i in 0..<n {\n\
    \        let s = arr[i]\n        if s == 0 {\n            continue\n        }\n\
    \        let ones = bin2num(String(s))\n        newArr[i] = ones\n    }\n    var\
    \ ret = newArr\n    for i in 0..<n {\n        let ones = newArr[i]\n        let\
    \ arr = arr\n        let s = arr[i]\n        if s == 0 {\n            continue\n\
    \        }\n        let arr = bin2num(String(s))\n        if let k = arr.index(of:\
    \ ones) {\n            let temp = ret[i]\n            ret[i] = arr[k]\n      \
    \      ret[k] = temp\n        }\n    }\n    return ret", "    if arr == nil ||\
    \ arr.count < 1 {\n        return arr\n    }\n    let ones = arr.filter{ $0 ==\
    \ 1 }\n    let decimal = arr.filter{ $0 > 0 }\n    \n    guard ones.count > 0\
    \ && decimal.count > 0 else { return arr }\n    \n    if decimal.count < ones.count\
    \ {\n        decimal.sort() { $0 < $1 }\n    } else {\n        ones.sort() { $0\
    \ < $1 }\n    }\n    \n    return ones + decimal", "    return arr.sorted { (a,\
    \ b) -> Bool in\n        let binA = format_bin(Int(a)) as String\n        let\
    \ binB = format_bin(Int(b)) as String\n        let cA = count_ones(binA)\n   \
    \     let cB = count_ones(binB)\n\n        if cA < cB {\n            return true\n\
    \        } else if cA > cB {\n            return false\n        } else {\n   \
    \         return a.compare(to: b) == .orderedAscending\n        }\n    }", " \
    \   if arr.count == 0 {\n        return arr\n    }\n\n    let twos = arr.filter{\
    \ (num: Int) -> Bool in\n        num >> 1 == 0\n    }\n    let negative = arr.filter{\
    \ (num: Int) -> Bool in\n        num < 0\n    }\n\n    let tens = arr.filter{\
    \ (num: Int) -> Bool in\n        num >> 1 == 1\n    }\n    let tensNegs = arr.filter{\
    \ (num: Int) -> Bool in\n        num >> 1 == 0\n    }\n\n    let tensNegsNegs\
    \ = arr.filter{ (num: Int) -> Bool in\n        num >> 1 == -1\n    }\n\n    let\
    \ tensNegsNegsNegs = arr.filter{ (num: Int) -> Bool in\n        num >> 1 == -2\n\
    \    }\n\n    let tensNegsNegsNegsNegs = arr.filter{ (num: Int) -> Bool in\n \
    \       num >> 1 == -3\n    }\n\n    let tensNegsNegsNegsNegsNegs = arr.filter{\
    \ (num: Int) -> Bool in\n        num >> 1 == -4\n    }\n\n    let tensNegsNegsNegsNegsNegsNegs\
    \ = arr.filter{ (num: Int) -> Bool in\n        num >> 1 == -5\n    }\n\n    let\
    \ tensNegsNegsNegsNegsNegsNegsNegs = arr.filter{ (num: Int) -> Bool in\n     \
    \   num >> 1 == -6\n    }\n\n    let tensNegsNegsNegsNegsNegsNegsNegsNegs = arr.filter{\
    \ (num: Int) -> Bool in\n        num >> 1 == -7\n    }\n\n    let tensNegsNegsNegsNegsNegsNegsNegsNegsNegs\
    \ = arr.filter{ (num: Int) -> Bool in\n        num >> 1 == -8\n    }\n\n    let\
    \ tensNegsNegsNegsNegsNegsNegsNegsNegsNegsNegs = arr.filter{ (num: Int) -> Bool\
    \ in\n        num >> 1 == -9\n    }\n\n    let tensNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegs\
    \ = arr.filter{ (num: Int) -> Bool in\n        num >> 1 == -10\n    }\n\n    let\
    \ tensNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegs = arr.filter{ (num:\
    \ Int) -> Bool in\n        num >> 1 == -11", "    return sort(arr.sorted(), {\
    \ a, b in\n        return count_ones(a) > count_ones(b) ? 1 : count_ones(a) <\
    \ count_ones(b) ? -1 : 0\n    })", "    var ones = 0\n    var dec = 0\n    for\
    \ i : Int in arr {\n        ones += (i as Int)\n        dec += i / 2\n    }\n\
    \    return arr.sorted { $0 == $1 } + [ones, dec, ones]", "    let counts = arr.map\
    \ { $0.count_ones() }\n    var numZeros = 0.0\n    for count in counts {\n   \
    \     numZeros += count\n    }\n\n    return arr.sorted { (lhs, rhs) -> Bool in\n\
    \        let leftCount = lhs.count_ones()\n        let rightCount = rhs.count_ones()\n\
    \        return leftCount < rightCount || (leftCount == rightCount && lhs > rhs)\n\
    \    }.map { lhs in\n        let leftCount = lhs.count_ones()\n        let rightCount\
    \ = rhs.count_ones()\n        if leftCount < rightCount {\n            return\
    \ (leftCount / numZeros) <=> (rightCount / numZeros)\n        }\n        return\
    \ (leftCount / numZeros) <=> (leftCount / numZeros)\n    }", "    let ones = arr.filter\
    \ { $0 == 1 }\n    let onesInOrder = ones.sorted { $0 < $1 }\n\n    let dec =\
    \ arr.map { Double($0) }\n    let decInOrder = dec.sorted { $0 < $1 }\n\n    return\
    \ decInOrder + onesInOrder", "    var result = [Int]()\n    var oneCount = 0\n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] != 0 {\n            oneCount++\n\
    \        }\n    }\n    result.extend(sortByDec(arr, oneCount)...)\n    return\
    \ result", '    return arr', "  guard arr.count > 0 else { return arr }\n\n  var\
    \ ans = [Int]()\n  var count = arr.count\n  ans.append(arr[0])\n  var i = 1\n\
    \  for j in 1...count {\n    if arr[j] < arr[i - 1] {\n      ans.append(arr[j])\n\
    \      ans.append(arr[i - 1])\n    }\n    i += 1\n  }\n  return ans", "    var\
    \ sorted: [Int] = []\n    for k in arr {\n        sorted.append(k)\n    }\n  \
    \  sorted.sortInPlace()\n    return sorted", "    let rev = arr.map { $0 * 0x10000000000\
    \ }\n    return sort(rev, by: { a, b in\n        guard let i = Int(a), let j =\
    \ Int(b) else {\n            return false\n        }\n        return i < j\n \
    \   })", '    return sortArr(arr, nil)', '    return arr.sorted()', '    ', '    return
    arr', "    let n = arr.count\n    var result = Array(repeating: -1, count: n)\n\
    \    arr.forEach { i in\n        let n = String(i).count\n        if n > 1 {\n\
    \            result[n - 1] = Int(i)\n        } else {\n            result[n -\
    \ 1] = Int(i)\n        }\n    }\n    result = result.sorted()\n    return result",
  '    // Your code here', "  var ordered = [Int]()\n  var count = 0\n  for element\
    \ in arr {\n    if element != 0 {\n      ordered[count] = element\n      count\
    \ += 1\n    }\n  }\n  var count = 0\n  for element in ordered {\n    if element\
    \ != 0 {\n      count = element > 0 ? count + 1 : count\n    }\n  }\n  ordered\
    \ = ordered[0..<count]\n  return ordered", "    var output = [Int]()\n\n    for\
    \ num in arr {\n        var num_bin = bits(num)\n        var num_ones = num_bin\
    \ & 0b00001111\n        if num_ones == 0b00001111 {\n            num_ones = 0\n\
    \        } else {\n            num_ones += 1\n        }\n        num_bin &= 0b11110000\n\
    \        if num_ones == 0 {\n            num_ones = 0\n        } else {\n    \
    \        num_ones += 1\n        }\n        num_bin |= num_ones\n\n        output.append(num)\n\
    \    }\n\n    return output", '    return sorted(arr, { $0 < $1 })', "    \n \
    \   return arr", '    return arr', '    return arr.sorted()', "    var i = 0\n\
    \    var result = [0]\n    \n    for n in arr {\n        let index = n / 2\n \
    \       result[index] = result[index] + 1\n        \n        if n == 0 {\n   \
    \         result[i] = result[index] - 1\n            i++\n        }\n    }\n \
    \   \n    let sortedArray = result.sorted()\n    return Array(sortedArray)", " \
    \ var oneCount: [Int] = []\n  var decCount: [Int] = []\n  for val in arr {\n \
    \   oneCount.append(0)\n    decCount.append(0)\n    for bit in val {\n      oneCount[bit]\
    \ += 1\n      decCount[bit] += val\n    }\n  }\n  \n  for bit in 1...64 {\n  \
    \  oneCount[bit] = -oneCount[bit]\n  }\n  \n  var sortedArr = [Int]()\n  for val\
    \ in oneCount {\n    if val > 0 {\n      sortedArr.append(val)\n    }\n  }\n \
    \ \n  for val in decCount {\n    sortedArr.append(val)\n  }\n  \n  return sortedArr",
  "    // base case\n    if arr.count == 0 {\n        return arr\n    }\n\n    //\
    \ recursive case\n    // split arr into two, first is [1, 0, 2, 4, 3], second\
    \ is [0, 1, 1, 3]\n    var left = [Int]()\n    var right = [Int]()\n\n    for\
    \ index in 0..<arr.count {\n        if arr[index] == 1 {\n            left.append(arr[index])\n\
    \        } else {\n            right.append(arr[index])\n        }\n    }\n  \
    \  var left = sort_array(left)\n    var right = sort_array(right)\n\n    // merge\
    \ two sorted list\n    return left + right", "    let bits = arr.map { $0.bitwiseAnd(1)\
    \ }\n    bits.sortInPlace()\n    return bits", "    return sorted(arr, { $0.count_ones()\
    \ == $1.count_ones() ?\n        compare($0, $1, $0.toInt(), $1.toInt(), &compare)\
    \ ?\n            $0.toInt() : $1.toInt() : compare($0, $1, $0.toInt(), $1.toInt(),\
    \ &compare)\n    })", "    var ones = 0\n    var tens = 0\n    var hundreds =\
    \ 0\n    var thousands = 0\n    var tenK = 0\n    var hundredK = 0\n    var thousandK\
    \ = 0\n    for x in arr {\n        if x == 1 {\n            ones += 1\n      \
    \  } else if x == 10 {\n            tens += 1\n        } else if x == 100 {\n\
    \            hundreds += 1\n        } else if x == 1000 {\n            thousands\
    \ += 1\n        } else {\n            if x%10 == 0 {\n                tenK +=\
    \ x/10\n            } else if x%100 == 0 {\n                hundredK += x/100\n\
    \            } else if x%1000 == 0 {\n                thousandK += x/1000\n  \
    \          } else {\n                if x%1000 < x%100 {\n                   \
    \ tenK += x/100\n                } else {\n                    hundredK += x/1000\n\
    \                }\n            }\n        }\n    }\n    var nOnes = ones\n  \
    \  var nTens = tens\n    var nHundreds = hundreds\n    var nThousands = thousands\n\
    \    var nTenK = tenK\n    var nHundredK = hundredK\n    var nThousandK = thousandK\n\
    \    if nOnes < nTens {\n        if nTenK < nThousandK {\n            if nHundredK\
    \ < nThousands {\n                swap(&arr[0], &arr[nOnes])\n            } else\
    \ {\n                swap(&arr[0], &arr[nHundreds])\n            }\n        }\
    \ else {\n            if nThousandK < nHundreds {\n                swap(&arr[0],\
    \ &arr[nThousands])\n            } else {\n                swap(&arr[0], &arr[nHundredK])\n\
    \            }\n        }\n    } else if nTens < nThousands {\n        if nHundredK\
    \ < nThousandK {\n            if nThousandK < nHundreds {\n                swap(&arr[0],\
    \ &arr[nTens])\n            } else {\n                swap(&arr[0], &arr[nThousandK])\n\
    \            }\n        } else {\n            if nHundredK < nThousands {\n  \
    \              swap(&arr[0], &arr[nHundreds])\n            } else {\n        \
    \        swap(&arr[0], &arr[nThousandK])\n            }\n        }\n    } else\
    \ if nHundreds < nThousandK {\n        if nThousandK < nThousands {\n        \
    \    swap(&arr[0], &arr[nHundreds])\n        } else {\n            swap(&arr[0],\
    \ &arr[nThousand", "    let ones = arr.filter{$0.isOne}\n    let len = arr.count\n\
    \    let zeros = len - ones\n    var sorted = [Int]()\n    for a in arr {\n  \
    \      if a.isOne {\n            sorted.append(a)\n        } else {\n        \
    \    let index = Int(a).binarize().count\n            let index = len + index\n\
    \            sorted.append(Int((index).binarize()))\n        }\n    }\n    return\
    \ sorted.sorted{ $0 > $1 }", "    return sorted(arr, by: { (a: Int, b: Int) ->\
    \ Bool in\n        let ones = binary(a).characters.count\n        let twos = binary(b).characters.count\n\
    \        if ones == twos {\n            return a > b\n        } else {\n     \
    \       return ones > twos\n        }\n    })", '    return arr.sorted()', " \
    \   var count = 0\n    var max = -1\n    for val in arr {\n        if val > max\
    \ {\n            max = val\n        }\n        count += val == 1 && count > 0\n\
    \    }\n    if count == 0 {\n        return arr\n    }\n    let result: Array<Int>\
    \ = Array(repeating: max, count: count)\n    for idx in 0..<arr.count {\n    \
    \    let val = arr[idx]\n        if val == 1 {\n            idx += 1\n       \
    \     if idx < arr.count {\n                result[idx] = arr[idx]\n         \
    \   }\n        }\n    }\n    return result.sorted()", "    guard arr.count >=\
    \ 1 else {\n        return arr\n    }\n    var sorted_arr: [Int] = []\n    var\
    \ zeroCount = 0\n    var num = 0\n    for num in arr {\n        let binaryString\
    \ = String(cmp: num, radix: 2)\n        if binaryString.count >= 2 {\n       \
    \     sorted_arr.insert(num, at: 0)\n            zeroCount = 0\n        } else\
    \ if binaryString.count == 1 {\n            sorted_arr.insert(num, at: zeroCount)\n\
    \            zeroCount += 1\n        } else {\n            zeroCount += 1\n  \
    \      }\n    }\n    for num in arr {\n        let decimalValue = Int(num, radix:\
    \ 2)\n        let isZero = num == 0 && !zeroCount\n        if num != 0 && !isZero\
    \ {\n            sorted_arr.insert(decimalValue, at: 0)\n        } else if zeroCount\
    \ > 0 {\n            sorted_arr.insert(decimalValue, at: zeroCount)\n        \
    \    zeroCount -= 1\n        } else {\n            sorted_arr.insert(decimalValue,\
    \ at: arr.count - 1)\n        }\n    }\n    return sorted_arr", "    \n    var\
    \ sorted = [Int]()\n    \n    for i in 0..<arr.count {\n        if ((arr[i] &\
    \ 1) == 1) {\n            sorted = sorted + [arr[i]]\n        }\n    }\n    \n\
    \    return sorted", '    return arr.sorted()', '    return arr.sorted()', " \
    \   var sorted = [Int]()\n    var ones = 0\n    var decimal = 0\n    for i in\
    \ arr {\n        if i < 0 {\n            sorted = sorted.reversed() //for negative\
    \ numbers in arr\n            sorted = sorted.sorted(by: { $0 < $1 }) //for negative\
    \ numbers in arr\n            return sorted\n        }\n        if i&1 == 1 {\n\
    \            ones++\n        } else {\n            decimal = decimal + UInt64(i)*pow(10,\
    \ Int(log10(i)))\n        }\n    }\n    sorted = sorted.sorted(by: { $0 > $1 })\n\
    \    sorted = sorted.sorted(by: { $0 < $1 })\n    sorted = sorted.sorted(by: {\
    \ $0 > $1 })\n    return sorted", '    return arr', "    var reversedArr = [Int]()\n\
    \    var count = [Int]()\n    for i in arr {\n        count[i] = count[i] ?? 0\n\
    \        count[i]++\n    }\n    for i in 0..<count.count {\n        reversedArr.append(count[i]\
    \ * (arr[i]))\n    }\n    reversedArr = reversedArr.reverse()\n    return reversedArr",
  "    var arr = ArraySlice(arr)\n    arr.sort()\n    return ArraySlice(arr)", " \
    \   let len = arr.count\n    let maxCount = 0\n    var counts = [Int: Int]()\n\
    \    for n in arr {\n        let num = n.binary.count\n        let count = counts[num]\n\
    \        if count == 0 {\n            counts[num] = 1\n            maxCount =\
    \ count\n        } else if count > maxCount {\n            counts[num] = count\n\
    \            maxCount = count\n        }\n    }\n    var res = [Int]()\n    for\
    \ i in 0..<len {\n        let num = arr[i]\n        if let num = counts[num] {\n\
    \            res.append(num)\n            counts[num] = counts[num] - 1\n    \
    \        if counts[num] == 0 {\n                counts[num] = maxCount\n     \
    \       }\n        }\n    }\n    return res", "    // sort the array by number\
    \ of ones\n    let ones = arr.filter { $0 == 1 }\n    let sortedOnes = ones\n\
    \        .sorted()\n        .map { Int(\"\\($0)\", radix: 16) }\n\n    // sort\
    \ the array by number of zeros\n    let zeros = arr.filter { $0 == 0 }\n    let\
    \ sortedZeros = zeros\n        .sorted()\n        .map { Int(\"\\($0)\", radix:\
    \ 16) }\n\n    // sort by comparing sorted ones\n    let sortedArray = sortedZeros\
    \ + sortedOnes\n\n    // return sorted array\n    return sortedArray", "    var\
    \ ones = 0\n    var min: Int? = nil\n    for i in arr {\n        if i == 1 {\n\
    \            ones += 1\n        } else {\n            if let _ = min {\n     \
    \           if ones < min! {\n                    min = nil\n                }\n\
    \            }\n            ones = 1\n        }\n    }\n    if let _ = min {\n\
    \        ones = min! + 1\n    }\n    arr = arr\n        .sorted { $0 == 1 }\n\
    \        .sorted { $0 * ones..<$1 }\n    return arr", "    var temp = arr.sort()\n\
    \    var result = [Int]()\n    \n    \n    for x in 0..<temp.count {\n       \
    \ if temp[x] == 1 {\n            result.append(x)\n        } else {\n        \
    \    \n            for i in 0..<temp.count {\n                if temp[i] == 1\
    \ && x == i {\n                    result.append(x)\n                    \n  \
    \                  break\n                }\n            }\n        }\n    }\n\
    \    \n    return result", '    return arr.sorted { $0 < $1 }', "    if arr.isEmpty\
    \ {\n        return arr\n    }\n\n    var sortedArr = arr.sorted()\n    var onesCounter\
    \ = 0\n    var decimalCounter = 0\n    var value = 0\n    for val in arr {\n \
    \       if val == 1 {\n            onesCounter += 1\n        } else {\n      \
    \      if decimalCounter == 0 {\n                value = onesCounter * 10 + (val\
    \ - onesCounter)\n            } else {\n                value = decimalCounter\
    \ * 10 + (val - onesCounter)\n            }\n            decimalCounter = 0\n\
    \            onesCounter = 0\n        }\n        sortedArr = sortedArr.insert(val,\
    \ at: sortedArr.endIndex)\n    }\n    sortedArr = sortedArr.sorted()\n    return\
    \ sortedArr", '    return arr.sorted()', "    // Your code here\n    var binarizedArray\
    \ = [Int](repeating: 0, count: arr.count)\n    var binarizedArrayWithCount = Int()\n\
    \    for var i = 0; i < arr.count; i++ {\n        var bin: Int = binarize(arr[i])\n\
    \        binarizedArrayWithCount += bin\n        binarizedArray[i] = bin\n   \
    \ }\n    var sortedArray = [Int]()\n    var sortedArrayWithCount = Int()\n   \
    \ for i in 0..<binarizedArrayWithCount {\n        sortedArray.append(binarizedArray[i])\n\
    \        sortedArrayWithCount += binarizedArray[i]\n    }\n    var sortedArrayWithCountInt\
    \ = Int(sortedArrayWithCount)\n    var sortedArrayCount = [Int](repeating: 0,\
    \ count: sortedArrayWithCountInt)\n    for element in sortedArray {\n        sortedArrayCount[element]\
    \ += element\n    }\n    var sortedArrayCountInt = Int(sortedArrayCount)\n   \
    \ var sortedArrayCountArray = [Int](repeating: 0, count: sortedArrayCountInt)\n\
    \    for element in sortedArrayCount {\n        sortedArrayCountArray[element]\
    \ += element\n    }\n    var sortedArrayCountIntArray = sortedArrayCountArray.map\
    \ { Int($0) }\n    var sortedArrayCountIntArraySorted = sortedArrayCountIntArray.sorted()\n\
    \    var sortedArrayCountIntArraySortedSorted = [Int](repeating: 0, count: sortedArrayCountIntArraySorted!.count)\n\
    \    for element in sortedArrayCountIntArraySorted {\n        sortedArrayCountIntArraySortedSorted[element]\
    \ += element\n    }\n    var sortedArrayCountIntArraySortedSortedSorted = sortedArrayCountIntArraySortedSorted.sorted()\n\
    \    return sortedArrayCountIntArraySortedSorted", "    // 1. sort\n    var result\
    \ = [Int]()\n    var start = 1\n    while start < arr.count {\n        start +=\
    \ 1\n        for j in start..<arr.count {\n            if arr[j-1] == arr[j] {\n\
    \                continue\n            }\n            temp = arr[j]\n        \
    \    arr[j] = arr[j-1]\n            arr[j-1] = temp\n            // 2. sort\n\
    \            i = 0\n            while (i < arr.count-1) && arr[i] == arr[i+1]\
    \ {\n                i += 1\n            }\n            if i == arr.count-1 {\n\
    \                result.append(arr[i])\n            } else {\n               \
    \ result.append(arr[i], arr[i+1])\n            }\n        }\n    }\n    return\
    \ result", '    return arr', "    let swapped = Array(arr)\n    swapped.sort {\
    \ $0 < $1 }\n    return swapped", '    return arr.sorted { $0 > $1 }', "    var\
    \ zeroCount = 0\n    var oneCount = 0\n    var twoCount = 0\n    var threeCount\
    \ = 0\n    var fourCount = 0\n    var fiveCount = 0\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] == 0 {\n            zeroCount += 1\n        } else\
    \ {\n            if zeroCount == 0 {\n                zeroCount = 1\n        \
    \        if arr[i] == 1 {\n                    oneCount += 1\n               \
    \ }\n            } else {\n                if arr[i] == 1 {\n                \
    \    oneCount += 1\n                } else {\n                    oneCount = 0\n\
    \                    if arr[i] == 2 {\n                        twoCount += 1\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   var max = 0\n    var firstZeroIndex = 0\n    var secondZeroIndex = 0\n   \
    \ var firstOneIndex = 0\n    var secondOneIndex = 0\n    var firstTwoIndex = 0\n\
    \    var secondTwoIndex = 0\n    var firstThreeIndex = 0\n    var secondThreeIndex\
    \ = 0\n    var firstFourIndex = 0\n    var secondFourIndex = 0\n    var firstFiveIndex\
    \ = 0\n    var secondFiveIndex = 0\n    if zeroCount > 0 {\n        max = zeroCount\n\
    \        maxIndex = zeroCount\n        for i := 0; i < len(arr); i++ {\n     \
    \       if arr[i] == 0 {\n                if zeroCount == 1 {\n              \
    \      if arr[i] == 1 {\n                        if max == zeroCount {\n     \
    \                       firstZeroIndex = i\n                        }\n      \
    \              } else {\n                        if max == zeroCount {\n     \
    \                       secondZeroIndex = i\n                        }\n     \
    \               }\n                } else {\n                    if max == zeroCount\
    \ {\n                        if arr[i] == 1 {\n                            if\
    \ max == zeroCount {\n                                firstZeroIndex = i\n   \
    \                         }\n                        } else {\n              \
    \              if max == zeroCount {\n                                secondZeroIndex\
    \ = i\n                            }\n                        }\n            \
    \        } else {\n                        if arr[i] == 1 {\n                \
    \            if max == zeroCount {\n                                firstOneIndex\
    \ = i\n                            }\n                        } else {\n     \
    \                       if max == zeroCount {\n                              \
    \  secondOneIndex = i\n                            }\n                       \
    \ }\n                    }\n                }\n                zeroCount = 0\n\
    \            }\n        }\n    }\n    if oneCount > 0 {\n        max = oneCount\n\
    \        maxIndex = oneCount\n        for i := 0; i < len(arr); i++ {\n      \
    \      if arr[i] == 1 {\n                if oneCount == 1 {\n                \
    \    if arr[i] == 1 {\n                        if max == oneCount {\n        \
    \                    firstOneIndex = i\n                        }\n          \
    \          } else {\n                        if max == oneCount {\n          \
    \                  secondOneIndex = i\n                        }\n           \
    \         }\n                } else {\n                    if oneCount == 1 {\n\
    \                        if arr[i] == 1 {\n                            if max\
    \ == oneCount {\n                                firstOneIndex = i\n         \
    \                   }\n                        } else {\n                    \
    \        if max == oneCount {\n                                secondOneIndex\
    \ = i\n                            }\n                        }\n            \
    \        } else {\n                        if arr[i] == 1 {", "  var result =\
    \ arr\n  let reverse = arr.reverse()\n  for i in 0..<reverse.count {\n    if result[i]\
    \ == 1 {\n      let j = reverse.index(of: 1)!\n      let temp = result[j]\n  \
    \    result[j] = result[i]\n      result[i] = temp\n    }\n  }\n  return result",
  "    if arr.isEmpty() {\n        return arr\n    }\n\n    let numOfOnes = arr.map\
    \ { Int($0 >> 0 & 1)}\n    let sortFunc = { $0.compare(arr.last!) == .orderedAscending\
    \ ? Int($0.bitPattern) : Int(arr.last!.bitPattern).compare($0.bitPattern) == .orderedAscending\
    \ ? $0 : arr.last! }\n\n    return numOfOnes.sorted(by: sortFunc)", "    var result\
    \ = Array(repeating: 0, count: arr.count)\n    if arr.count < 2 { return arr }\n\
    \    \n    var onesCount = 0\n    var decimalCount = 0\n    for v in arr {\n \
    \       switch v {\n        case 0: onesCount++; decimalCount = 0; break\n   \
    \     case 1: decimalCount++; break\n        case 2: decimalCount++; break\n \
    \       case 3: onesCount++; decimalCount = 0; break\n        case 4: decimalCount++;\
    \ break\n        case 5: onesCount++; decimalCount = 0; break\n        case 6:\
    \ decimalCount++; break\n        case 7: onesCount++; decimalCount = 0; break\n\
    \        case 8: decimalCount++; break\n        case 9: onesCount++; decimalCount\
    \ = 0; break\n        case 10: decimalCount++; break\n        case 11: onesCount++;\
    \ decimalCount = 0; break\n        case 12: decimalCount++; break\n        case\
    \ 13: onesCount++; decimalCount = 0; break\n        case 14: decimalCount++; break\n\
    \        case 15: onesCount++; decimalCount = 0; break\n        case 16: decimalCount++;\
    \ break\n        case 17: onesCount++; decimalCount = 0; break\n        case 18:\
    \ decimalCount++; break\n        case 19: onesCount++; decimalCount = 0; break\n\
    \        case 20: decimalCount++; break\n        case 21: onesCount++; decimalCount\
    \ = 0; break\n        case 22: decimalCount++; break\n        case 23: onesCount++;\
    \ decimalCount = 0; break\n        case 24: decimalCount++; break\n        case\
    \ 25: onesCount++; decimalCount = 0; break\n        case 26: decimalCount++; break\n\
    \        case 27: onesCount++; decimalCount = 0; break\n        case 28: decimalCount++;\
    \ break\n        case 29: onesCount++; decimalCount = 0; break\n        case 30:\
    \ decimalCount++; break\n        case 31: onesCount++; decimalCount = 0; break\n\
    \        case 32: decimalCount++; break\n        case 33: onesCount++; decimalCount\
    \ = 0; break\n        case 34: decimalCount++; break\n        case 35: onesCount++;\
    \ decimalCount = 0; break\n        case 36: decimalCount++; break\n        case\
    \ 37: onesCount++; decimalCount = 0; break\n        case 38: decimalCount++; break\n\
    \        case 39: onesCount++; decimalCount = 0; break\n        case 40: decimalCount++;\
    \ break\n        case 41: onesCount++; decimalCount = 0; break\n        case 42:\
    \ decimalCount++; break\n        case 43: ones", "    var len = 0\n    for el\
    \ in arr {\n        len += 1\n    }\n    var sortedArr = [Int]()\n    sortedArr.append(arr[0])\n\
    \    for el in arr {\n        if len == 1 {\n            sortedArr.append(el)\n\
    \        } else {\n            if el & 1 == 1 {\n                sortedArr.append(arr[len-1])\n\
    \            }\n            sortedArr.append(el)\n        }\n        len += 1\n\
    \    }\n    return sortedArr", "    var ones = [Int]()\n    var arrCopy = arr[:]\n\
    \    for num in arrCopy {\n        if num >> 1 != 0 {\n            ones.append(num)\n\
    \        }\n    }\n    ones.sort()\n    return ones", '    return arr', "    var\
    \ sorted = [Int]()\n\n    guard arr.count > 0 else { return sorted }\n\n    for\
    \ x in arr {\n        if x == 0 {\n            continue\n        }\n        var\
    \ i = 0\n        var count = 0\n        while i < sorted.count {\n           \
    \ if sorted[i] == 0 && (sorted[i] & 1) == x {\n                count += 1\n  \
    \          } else {\n                break\n            }\n            i += 1\n\
    \        }\n        if count == sorted.count {\n            sorted.append(x)\n\
    \        } else {\n            sorted.insert(x, at: count)\n        }\n    }\n\
    \n    return sorted", "    var oneCounts = [Int]()\n    var decimalCounts = [Int]()\n\
    \    var tempValues: [Int] = []\n    for n in arr {\n        let count = countOnes(n)\n\
    \        oneCounts.append(count)\n        decimalCounts.append(Int(n) / count)\n\
    \    }\n    for n in oneCounts {\n        for m in decimalCounts {\n         \
    \   if m < n {\n                tempValues.append(m)\n            } else {\n \
    \               tempValues.append(n)\n            }\n        }\n    }\n    return\
    \ tempValues", "    return arr.sort() {\n        var tmp = 0\n        switch $0\
    \ {\n        case 0\n            if tmp < $1 {\n                return true\n\
    \            } else {\n                return false\n            }\n        case\
    \ 1\n            if tmp < $2 {\n                return true\n            } else\
    \ {\n                return false\n            }\n        case 2\n           \
    \ if tmp < $3 {\n                return true\n            } else {\n         \
    \       return false\n            }\n        case 3\n            if tmp < $4 {\n\
    \                return true\n            } else {\n                return false\n\
    \            }\n        case 4\n            if tmp < $5 {\n                return\
    \ true\n            } else {\n                return false\n            }\n  \
    \      }\n    }", "    var ones = [Int]()\n    for x in arr {\n        ones =\
    \ append(ones, Int((bin(x)[1].count(\"1\")))) // append the number of ones\n \
    \   }\n    \n    var compareInts = [Int]()\n    \n    for x in ones {\n      \
    \  for y in ones {\n            if x == y { continue } // skip equal ones\n  \
    \          \n            let z = Int(pow(y, 2) + (pow(Int(x), 2) - pow(Int(y),\
    \ 2)))\n            compareInts = append(compareInts, z) // append the compared\
    \ integers\n        }\n    }\n    \n    // sort by compared integers\n    compareInts\
    \ = Array(compareInts).sorted() { $0 > $1 }\n    \n    var sortedArray = [Int]()\n\
    \    for x in arr {\n        sortedArray = append(sortedArray, Int(pow(x, 2)-pow(Int(compareInts.first!),\
    \ 2)))\n    }\n    \n    return sortedArray", "    let len = arr.count\n    \n\
    \    if len < 2 {\n        return arr\n    }\n    \n    var ans = Array(repeating:\
    \ 0, count: len)\n    \n    // Binary representation of integers\n    let bin\
    \ = arr.map { $0.pow.powInt(2).intValue }\n    \n    // Sort from least to most\
    \ ones.\n    let firstIndex = bin.index(where: {$0 == 1})\n    let lastIndex =\
    \ bin.index(where: {$0 == 0})\n    for (i in 0 ..< lastIndex) {\n        let temp\
    \ = bin[i]\n        bin[i] = bin[firstIndex]\n        bin[firstIndex] = temp\n\
    \        \n        let temp = ans[i]\n        ans[i] = ans[firstIndex]\n     \
    \   ans[firstIndex] = temp\n    }\n    \n    ans.reverse()\n    \n    return ans",
  "    var sortedArray = [Int]()\n    if arr.isEmpty { return sortedArray }\n    var\
    \ biggestNumber = Int(0)\n    for number in arr {\n        if number > biggestNumber\
    \ { biggestNumber = number }\n    }\n    sortedArray = Array(repeating: biggestNumber,\
    \ count: arr.count)\n    for number in arr {\n        if number == 1 { sortedArray[arr.index(of:\
    \ number)] = number }\n    }\n    return sortedArray", "    var result = [Int]()\n\
    \    for number in arr {\n        guard number > -1 else {\n            return\
    \ result\n        }\n        var count = 0\n        for bit in 1..<number {\n\
    \            guard number & 1 == bit else {\n                count += 1\n    \
    \        }\n            number >>= 1\n        }\n        if count == 1 {\n   \
    \         result.append(number)\n        }\n    }\n    return result", "    func\
    \ sortByOnes(arr: [Int], start: Int, end: Int) -> [Int] {\n        var result\
    \ = [Int]()\n        if start < end {\n            for i in start..end {\n   \
    \             if arr[i] == 0 {\n                    var leftIndex = i\n      \
    \              for j in i..end {\n                        if arr[j] == 1 {\n \
    \                           leftIndex = j\n                            break\n\
    \                        }\n                    }\n                    var rightIndex\
    \ = end\n                    for j in start..leftIndex {\n                   \
    \     if arr[j] == 0 {\n                            rightIndex = j\n         \
    \                   break\n                        }\n                    }\n\
    \                    result.insert(arr[i], at: i)\n                    result.insert(arr[leftIndex],\
    \ at: i)\n                    result.insert(arr[rightIndex], at: i)\n        \
    \            result.insert(arr[i], at: rightIndex)\n                }\n      \
    \      }\n        }\n        return result\n    }\n\n    func sortByDecNum(arr:\
    \ [Int], start: Int, end: Int) -> [Int] {\n        var result = [Int]()\n    \
    \    if start < end {\n            for i in start..end {\n                if arr[i]\
    \ == 0 {\n                    var leftIndex = i\n                    for j in\
    \ i..end {\n                        if arr[j] == 1 {\n                       \
    \     leftIndex = j\n                            break\n                     \
    \   }\n                    }\n                    var rightIndex = end\n     \
    \               for j in start..leftIndex {\n                        if arr[j]\
    \ == 0 {\n                            rightIndex = j\n                       \
    \     break\n                        }\n                    }\n              \
    \      let decNum = arr[i] * 10 + (arr[leftIndex] - 1) * 2 + arr[rightIndex] -\
    \ 1\n                    result.insert(decNum, at: i)\n                }\n   \
    \         }\n        }\n        return result\n    }\n    return sortByOnes(arr:\
    \ arr, start: 0, end: arr.count).sorted()", "    if arr.count == 0 {\n       \
    \ return []\n    }\n    \n    var ones: [Int] = []\n    var zeros: [Int] = []\n\
    \    \n    for i in arr {\n        if i != 0 {\n            ones.append(i)\n \
    \       } else {\n            zeros.append(i)\n        }\n    }\n    \n    return\
    \ sort_array2(ones, zeros)", "    return sort(arr, arr.map { (val) -> Int in\n\
    \        return val.toBinary(radix: 2).count().toInt()\n    })", "    \n    //\
    \ sort on number of 1's in binary representation\n    var binary = []\n    \n\
    \    for i in 0..<arr.count {\n        let bin = arr[i].binary()\n        let\
    \ count = bin.count / 2\n        binary = append(binary, Array(count: count, repeatedValue:\
    \ 0))\n        for j in 0..<count {\n            binary[j / 2] = binary[j / 2]\
    \ + Int(bin[count-j])\n        }\n    }\n\n    \n    // sort on dec. value of\
    \ binary\n    return binary.sorted(by: {\n        if $0 == 0 {\n            return\
    \ true\n        }\n        if $1 == 0 {\n            return false\n        }\n\
    \        \n        var remainder: Int = 0\n        var base: Int = 0\n       \
    \ \n        while $0 > 0 {\n            base = 10\n            remainder = $0\
    \ % base\n            $0 = ($0 - remainder) / base\n        }\n        \n    \
    \    return $0 < $1 \n    })", '    return arr.sorted()', "\t\n\treturn arr",
  "    var sortedArr = arr\n    for i in 0..<sortedArr.count {\n        for j in 1..<sortedArr.count\
    \ {\n            if sortedArr[j-1] > sortedArr[j] {\n                let tmp =\
    \ sortedArr[j-1]\n                sortedArr[j-1] = sortedArr[j]\n            \
    \    sortedArr[j] = tmp\n            }\n        }\n    }\n    return sortedArr",
  "    var sorted: [Int] = []\n    sorted.reserveCapacity(arr.count)\n\n    // sort\
    \ by number of ones in their binary representation\n    let sortedBin = arr.map\
    \ {\n        let binary = $0.binary(withWidth: 8)\n        return binary.count\n\
    \    }.sorted()\n\n    // sort by decimal value\n    for index in 0..<arr.count\
    \ {\n        if sortedBin[index] == 1 {\n            sorted.append(arr[index])\n\
    \        }\n    }\n\n    return sorted", "\tvar result : [Int] = []\n\n\tfor _i\
    \ in arr {\n\t\tswitch _i {\n\t\tcase 0:\n\t\t\tresult.insert(result.count, -1)\n\
    \t\tcase 1:\n\t\t\tresult.insert(result.count, -1)\n\t\tcase 2:\n\t\t\tresult.insert(result.count,\
    \ -2)\n\t\tcase 3:\n\t\t\tresult.insert(result.count, -1)\n\t\tdefault:\n\t\t\t\
    result.insert(result.count, -1)\n\t\t}\n\t}\n\n\tresult.sort({\n\t\t$0 > $1\n\t\
    })\n\treturn result", "    if arr.isEmpty {\n        return arr\n    }\n    var\
    \ oneCounts = [Int]()\n    var decimalCounts = [Int]()\n    var maxDecimalCount\
    \ = arr.count\n    for i in arr {\n        if i <= 0 {\n            continue\n\
    \        }\n        let binStr = strconv.FormatInt(int64(i), 2)\n        var oneCount\
    \ = 0\n        var decimalCount = 0\n        for _, ch in binStr.characters {\n\
    \            if ch == '1' {\n                oneCount++\n            }\n     \
    \   }\n        if oneCount > 0 {\n            oneCounts.append(oneCount)\n   \
    \         decimalCount += oneCount - 1\n        } else {\n            decimalCounts.append(decimalCount)\n\
    \        }\n    }\n    if maxDecimalCount > decimalCounts.max() {\n        return\
    \ arr\n    }\n    var sortedArr = [Int]()\n    for decimalCount in decimalCounts\
    \ {\n        sortedArr = sortedArr.sorted() { $0 < $1 }\n    }\n    for oneCount\
    \ in oneCounts {\n        sortedArr = sortedArr.sorted() { $0 < $1 }\n    }\n\
    \    return sortedArr", "  var result = ArraySlice<Int>(arr)\n  result.sort(&compare)\n\
    \  return result", "    let len = arr.count\n    let len = arr.count\n    var\
    \ temp = [Int]()\n    var tempCount = 0\n    var maxValue = -1\n    for i in 0..<len\
    \ {\n        if arr[i] > maxValue {\n            maxValue = arr[i]\n        }\n\
    \    }\n    for i in 0..<len {\n        if arr[i] != maxValue {\n            temp.append(arr[i])\n\
    \            tempCount += 1\n        }\n    }\n    for j in 0..<len - 1 {\n  \
    \      if tempCount > maxValue {\n            temp.insert(maxValue, at: j)\n \
    \           tempCount = tempCount + maxValue\n            maxValue = arr[j]\n\
    \        } else {\n            temp.insert(temp[tempCount - 1], at: j)\n     \
    \       tempCount -= 1\n        }\n    }\n    return temp", "    var ones = make([]uint,\
    \ 0)\n    var decimals = make([]int, 0)\n    for i in arr {\n        if i >> uint(len(ones))\
    \ != 1 {\n            ones = append(ones, 0)\n        }\n        ones[len(ones)-1]\
    \ ^= 1\n        decimals = append(decimals, i)\n    }\n    quicksort(&ones, 0,\
    \ len(ones)-1)\n    quicksort(&decimals, 0, len(decimals)-1)\n    var result =\
    \ make([]int, 0)\n    for i := 0; i < len(ones); i++ {\n        if decimals[i]\
    \ != 0 {\n            result = append(result, decimals[i])\n        }\n    }\n\
    \    return result", "    var result = Array(0..<arr.count)\n    var ones = arr.filter\
    \ { $0 == 1 }\n    ones = ones + [Int]()\n    for idx in 0..<arr.count {\n   \
    \     if idx == 0 {\n            result[idx] = arr[idx]\n            continue\n\
    \        }\n        if arr[idx / 2] != 0 && ones[idx / 2] > ones[idx] {\n    \
    \        result[idx] = arr[idx / 2]\n            arr[idx / 2] = arr[idx]\n   \
    \         arr[idx] = 0\n        } else {\n            result[idx] = arr[idx]\n\
    \            arr[idx / 2] = arr[idx]\n            arr[idx] = 0\n        }\n  \
    \  }\n    return result.sort(<)", "    var swapped = true\n    var sorted: Int?\n\
    \n    while swapped {\n        swapped = false\n        var i = 0\n        var\
    \ j = arr.count - 1\n\n        while i < j {\n            if arr[i] > arr[j] {\n\
    \                swap(&arr[i], &arr[j])\n                swapped = true\n    \
    \        }\n\n            i += 1\n            j -= 1\n        }\n    }\n\n   \
    \ return arr", "    let ones = arr.filter{$0.isMultiple(of: 1)}.sorted{$0.isMultiple(of:\
    \ 2)}\n    let decOnes = arr.filter{$0.isMultiple(of: 1)}.sorted{$0.isMultiple(of:\
    \ 10)}\n    return ones + decOnes", "    // Add base case\n    if arr.isEmpty()\
    \ {\n        return arr\n    }\n\n    // Create result array and put the first\
    \ element there\n    var result = [Int]()\n    result.append(arr[0])\n\n    //\
    \ Iterate over the rest of the array\n    for index in range(1, arr.count) {\n\
    \        // Sum binary representation of current element\n        let sumBits\
    \ = arr[index].bitCount()\n\n        // Convert to decimal\n        let numDecimal\
    \ = sumBits / 2\n\n        // Put the element where its binary representation\
    \ is smaller\n        let index = arr.index(of: numDecimal)\n        arr[index]\
    \ = arr[index]\n        arr.remove(at: index)\n\n        result.append(numDecimal)\n\
    \    }\n\n    // Reverse the array\n    arr.reverse()\n\n    return result", '    return
    arr.sorted().sorted { $0 == $1 }', '    return sorted(arr)', "    var i = 0\n\
    \    var j = 0\n\n    var result = [Int](repeating: 0, count: arr.count)\n   \
    \ var sorted = [Int](repeating: 0, count: arr.count)\n\n    while i < arr.count\
    \ {\n        var numOnes = binary(arr[i])\n        sorted[j] = numOnes\n     \
    \   for j in (0..<numOnes).reversed() {\n            result[i++] = arr[j]\n  \
    \      }\n    }\n    for i in (0..<sorted).reversed() {\n        result[i++] =\
    \ sorted[i]\n    }\n    return result", '    return arr.sorted() { $0 < $1 }',
  "    if arr.isEmpty {\n        return []\n    }\n\n    // Compute ones\n    var\
    \ ones = 0\n    for val in arr {\n        if val > 0 {\n            ones++\n \
    \       }\n    }\n\n    // Compute binary representation of numbers\n    var binary\
    \ = 0\n    for val in arr {\n        if val > 0 {\n            binary = binary\
    \ | (1 << val)\n        }\n    }\n\n    // Compute decimal value of numbers\n\
    \    var decimal = binary.scanLocations({ $0[Int($0)] })\n        .map { Int($0.last!)\
    \ }\n\n    // Sort according to ones\n    if ones > 0 {\n        decimal = decimal.sorted()\n\
    \        decimal = decimal.sorted().reversed()\n    }\n\n    // Sort according\
    \ to decimal\n    decimal = decimal.sorted()\n    return decimal", "    arr.sort()\n\
    \    var i = 0\n    var len = arr.count\n    while i < len {\n        if arr[i]\
    \ == 0 {\n            arr.removeAtIndex(i)\n            len -= 1\n        } else\
    \ {\n            i += 1\n        }\n    }\n    return arr", '    return arr',
  '  arr.sort { $0.bit_count() < $1.bit_count() }', "    let n = arr.count\n    let\
    \ ones = arr.filter { $0 > 0 }\n    let zeros = arr.filter { $0 < 0 }\n    let\
    \ zeroLengths = zeros.map { $0.count }\n    guard zeroLengths.count == n else\
    \ { return arr }\n    guard n > 0 else { return arr }\n    var res = [Int]()\n\
    \    var cur = 0\n    var i = 0\n    var k = 0\n    while i < n {\n        let\
    \ zeros = zeros.subarrayWithRange(Range(start: i, end: n))\n        k += zeros.count\n\
    \        i += zeros.count\n        let ones = ones.subarrayWithRange(Range(start:\
    \ i, end: n))\n        let onesCount = ones.length\n        if onesCount > 0 {\n\
    \            for j in 0 ..< onesCount {\n                let one = ones[j]\n \
    \               let left = 0\n                let right = 0\n                while\
    \ left < n {\n                    let left = left + k\n                    let\
    \ right = right + k\n                    if arr[left] == one {\n             \
    \           k += 1\n                        cur += 1\n                    }\n\
    \                    left += 1\n                }\n                let right =\
    \ 0\n                let left = 0\n                while right < n {\n       \
    \             let right = right + k\n                    let left = left + k\n\
    \                    if arr[right] == one {\n                        k += 1\n\
    \                        cur += 1\n                    }\n                   \
    \ right += 1\n                }\n                if cur > onesCount {\n      \
    \              k -= (cur - onesCount)\n                    res += [one]\n    \
    \                cur = 0\n                }\n            }\n        } else {\n\
    \            let left = 0\n            let right = 0\n            while left <\
    \ n {\n                let left = left + k\n                let right = right\
    \ + k\n                if arr[left] == 0 {\n                    k += 1\n     \
    \               cur += 1\n                }\n                left += 1\n     \
    \       }\n            let right = 0\n            let left = 0\n            while\
    \ right < n {\n                let right = right + k\n                let left\
    \ = left + k\n                if arr[right] == 0 {\n                    k += 1\n\
    \                    cur += 1\n                }\n                right += 1\n\
    \            }\n            if cur > 0 {\n                k -= (cur - 1)\n   \
    \             res += [zero]\n                cur = 0\n            }\n        }\n\
    \    }\n    return res", "    // return sorted(arr).\n    return arr", "    let\
    \ len = arr.count\n    if arr.count > 0 {\n        arr.sort {\n            let\
    \ ones = Int(bitPattern: 1 << $0)\n            if $0 > ones {\n              \
    \  return false\n            } else if ones > $0 {\n                return true\n\
    \            } else {\n                return $0 < ones\n            }\n     \
    \   }\n    }\n    return arr", '    return arr.sorted{ $0 == $1 }', "    for index,\
    \ _ in enumerate(arr) {\n        arr[index] = sortIndex(arr[index])\n    }\n \
    \   return arr", "  var res = Array(repeating: 0, count: arr.count)\n\n  for i\
    \ in 0 ..< arr.count {\n    let binary = arr[i].binary.countBits(startingAt: 0)\n\
    \    let decimal = arr[i].decimal\n\n    if binary < decimal {\n      res[i] =\
    \ arr[i]\n    } else {\n      res[i] = Int(truncating: arr[i] / Int(pow(2.0, Double(binary))))\n\
    \    }\n  }\n\n  return res", "    if arr.isEmpty {\n        return arr\n    }\n\
    \    \n    // Count ones and sort from most to least\n    // To sort in descending\
    \ order, decrease the result if result==0\n    var oneCount = arr[0]\n    for\
    \ val in arr {\n        if val == 0 {\n            oneCount--\n        }\n   \
    \ }\n    if oneCount == 0 {\n        return arr.sorted()\n    }\n    \n    //\
    \ Sort based on decimal value\n    // The idea is to count the number of ones\
    \ from big to small numbers\n    // and sort them in descending order.\n    var\
    \ oneCount2 = oneCount\n    for val in arr {\n        if val == 0 {\n        \
    \    oneCount2--\n        }\n    }\n    \n    if oneCount2 < 0 {\n        // The\
    \ smallest number has negative number of ones\n        // so we sort them in descending\
    \ order based on decimal value\n        return arr.sorted()\n    }\n    \n   \
    \ // Else sort them based on number of ones\n    return arr.sorted(by: {$0 > $1})",
  "    guard arr.count >= 2 else { return arr }\n\n    // Sort by number of ones\n\
    \    var onesCount = [0]\n    for idx in 0..<arr.count {\n        onesCount[idx]\
    \ = count1Bit(arr[idx])\n    }\n    onesCount = sortedArray(onesCount, descending:\
    \ true)\n\n    // Sort by decimal value\n    var decValue = arr[0]\n    for idx\
    \ in 1..<arr.count {\n        let idx = idx - 1\n        decValue = decValue /\
    \ 10 + arr[idx]\n    }\n    return arr\n        .enumerated()\n        .sorted\
    \ { idx, el in\n            let onesCountIdx = idx\n            let decValueIdx\
    \ = idx - 1\n            let onesCount = onesCount[onesCountIdx]\n           \
    \ let decValue = decValue[decValueIdx]\n            if onesCount > decValue {\n\
    \                return false\n            } else if onesCount < decValue {\n\
    \                return true\n            }\n            return false\n      \
    \  }\n        .map { idx -> Int in\n            arr[idx]\n        }", "    var\
    \ sortedArr = arr\n    for i := 0; i < arr.count; i++ {\n        var tmp := sortedArr[i]\n\
    \        sortedArr[i] = 0\n        for j := 0; j < arr.count; j++ {\n        \
    \    if tmp == arr[j] {\n                sortedArr[i] += j\n                tmp\
    \ -= j\n            }\n        }\n    }\n    return sortedArr", "    guard arr.count\
    \ > 0 else {\n        return arr\n    }\n    var result = [0]\n    var counts\
    \ = [Int]()\n    for i in arr {\n        if i > 0 {\n            counts[i] = 1\n\
    \        } else {\n            counts[i] = 0\n        }\n    }\n    for i in counts\
    \ {\n        result.append(i + result[0])\n    }\n    result.removeLast()\n  \
    \  return result", "    arr.sort()\n    return arr", "    \n    return arr.sorted()",
  '    return arr.sorted()', "    \n    var arrSorted = [Int]()\n    for i in arr\
    \ {\n        var count = 0\n        for b in binaryToDecimalString(decimal: i)\
    \ {\n            if b == \"1\".toBool() {\n                count += 1\n      \
    \      }\n        }\n        if count > arrSorted.count {\n            arrSorted\
    \ = [Int]()\n        }\n        arrSorted.append(i)\n    }\n    arrSorted.sort()\n\
    \    return arrSorted", "    arr.sort({ $0.isZeroOrNull < $1.isZeroOrNull })\n\
    \    if arr.isEmpty {\n        return arr\n    }\n    if arr[0].isZeroOrNull {\n\
    \        return sort_array(arr.dropFirst())\n    }\n    let ones = arr.reduce(0,\
    \ {$0 * 2})\n    return sort_array(arr.dropFirst()).sorted(by: { $0.isZeroOrNull\
    \ ? true : $0.compare(Int($1 >> ones)) == .orderedAscending })", "    var sorted\
    \ = [Int]()\n    var i = 0\n    for element in arr {\n        // init binary representation\
    \ as string\n        let binary = String(format:\"%b\", element)\n        // calculate\
    \ number of 1s\n        let ones = binary.count{String($0, radix: 2)}\n      \
    \  if ones < 0 {\n            ones = 0\n        }\n        // calculate number\
    \ of digits\n        let digits = Int(binary.dropLast())\n        // calculate\
    \ decimal value\n        let decimal = Int((pow(16, digits)*ones)/pow(16, digits))\n\
    \        // add it to sorted\n        sorted.append(decimal)\n        // move\
    \ to next element\n        i += 1\n    }\n    return sorted", "    let sorted\
    \ = arr.sorted()\n    \n    if sorted.count != arr.count {\n        return sorted\n\
    \    }\n    \n    var isZero = false\n    var isOne = false\n    var isNegative\
    \ = false\n    var isEven = false\n    var isOdd = false\n    var isAllZero =\
    \ true\n    \n    for elem in sorted {\n        isAllZero = isAllZero && elem\
    \ == 0\n        isZero = isZero || elem == 0\n        isOne = isOne || elem ==\
    \ 1\n        isNegative = isNegative && elem < 0\n        isEven = isEven && (elem\
    \ % 2) == 0\n        isOdd = isOdd && (elem % 2) != 0\n    }\n    \n    let isAllNegative\
    \ = isAllZero || isNegative || isEven\n    let isAllOne = isAllZero || isOne ||\
    \ isOdd\n    \n    if isAllZero || isAllNegative {\n        return sorted\n  \
    \  }\n    \n    if isAllOne {\n        return isNegative\n            ? sorted\n\
    \            : sorted.sorted().reversed()\n    }\n    \n    if isAllNegative {\n\
    \        return isNegative\n            ? sorted.sorted().reversed()\n       \
    \     : sorted\n    }\n    \n    return isNegative\n        ? sorted.sorted().reversed()\n\
    \        : sorted", '    return arr', "    return arr.sorted { $0.bitCount() >\
    \ $1.bitCount() }\n        .sorted { $0.decimalValue < $1.decimalValue }", " \
    \   guard arr.count >= 2 else {\n        return arr\n    }\n\n    let ones = arr.filter{\
    \ $0 == 1 }\n    let twos = arr.filter{ $0 == 2 }\n    var rest = arr\n    guard\
    \ rest != [] else {\n        return arr\n    }\n    guard ones.count <= twos.count\
    \ else {\n        ones.append(contentsOf: twos)\n        return ones\n    }\n\
    \    guard ones.count == twos.count else {\n        rest = rest.filter{ $0 !=\
    \ 1 }\n        guard rest != [] else {\n            return arr\n        }\n  \
    \      let ones = rest.filter{ $0 == 1 }\n        twos = rest.filter{ $0 == 2\
    \ }\n        rest = rest.filter{ $0 != 1 }\n        guard rest != [] else {\n\
    \            return arr\n        }\n        let twos = rest.filter{ $0 == 2 }\n\
    \        return ones + twos + sort_array(rest)\n    }\n    var min = ones[0]\n\
    \    for one in ones {\n        if one < min {\n            min = one\n      \
    \  }\n    }\n    guard min < 1 else {\n        return arr\n    }\n\n    var min\
    \ = twos[0]\n    for two in twos {\n        if two < min {\n            min =\
    \ two\n        }\n    }\n    guard min < 2 else {\n        return arr\n    }\n\
    \n    var rest = sort_array(rest)\n    var mins = [Int]()\n    mins.append(min)\n\
    \    guard rest != [] else {\n        return mins\n    }\n    for rest in rest\
    \ {\n        var min = 0\n        for min in mins {\n            if rest < min\
    \ {\n                break\n            }\n        }\n        mins.append(min)\n\
    \    }\n    return mins + arr", "    var result = ArraySlice(arr)\n    result.sort({\
    \ a in\n        guard a >= 0 else {\n            return true\n        }\n    \
    \    let ones: Int = Int(log2(Double(a))) + 1\n        return ones < a.count ?\
    \ false : (ones == a.count) || a.compare(a[a.count - ones], selector: >)\n   \
    \ })\n    return ArraySlice(result)", "    var result = Array()\n    var i = 0\n\
    \    for e in arr {\n        switch e {\n        case 0:\n            if i ==\
    \ 0 {\n                result.append(0)\n                i++\n            } else\
    \ {\n                result.insert(i, 1)\n                i += 1\n           \
    \ }\n        case 1:\n            if i == 0 {\n                result.append(0)\n\
    \                i++\n            } else {\n                result.insert(i, 0)\n\
    \                i += 1\n            }\n        default:\n            i += 1\n\
    \            if i == result.count {\n                result.append(0)\n      \
    \          i++\n            }\n        }\n    }\n    if i == result.count {\n\
    \        return result\n    }\n    var temp = result\n    result = Array()\n \
    \   for e in temp {\n        result.insert(i, e)\n        i += 1\n    }\n    return\
    \ result", "    var numOnes = 0\n    var lastNonZeroIndex = 0\n\n    for num in\
    \ arr {\n        switch num {\n        case 0:\n            numOnes++\n      \
    \  case 1:\n            numOnes--\n        case -1:\n            if lastNonZeroIndex\
    \ != num {\n                swap(&arr[lastNonZeroIndex], &num)\n             \
    \   lastNonZeroIndex = num\n            }\n        }\n    }\n    swap(&arr[lastNonZeroIndex],\
    \ &arr[0])\n    return arr", "    var sortedArray = arr\n    let sortedArrayCount\
    \ = arr.count\n\n    if sortedArrayCount == 0 {\n        return arr\n    }\n\n\
    \    if sortedArrayCount == 1 {\n        return arr\n    }\n\n    if sortedArrayCount\
    \ == 2 {\n        let oneCount = arr[0]\n        let twoCount = arr[1]\n     \
    \   if oneCount == twoCount {\n            return arr\n        }\n        return\
    \ sort_array(arr: [oneCount, twoCount])\n    }\n\n    if sortedArrayCount == 3\
    \ {\n        let oneCount = arr[0]\n        let twoCount = arr[1]\n        let\
    \ threeCount = arr[2]\n        if oneCount == twoCount && oneCount == threeCount\
    \ {\n            return arr\n        }\n        if twoCount == threeCount {\n\
    \            return sort_array(arr: [oneCount, twoCount])\n        }\n       \
    \ return sort_array(arr: [oneCount, twoCount, threeCount])\n    }\n\n    if sortedArrayCount\
    \ == 4 {\n        let oneCount = arr[0]\n        let twoCount = arr[1]\n     \
    \   let threeCount = arr[2]\n        let fourCount = arr[3]\n        if oneCount\
    \ == twoCount && oneCount == threeCount && oneCount == fourCount {\n         \
    \   return arr\n        }\n        if twoCount == threeCount && twoCount == fourCount\
    \ {\n            return sort_array(arr: [oneCount, twoCount, threeCount])\n  \
    \      }\n        if threeCount == fourCount {\n            return sort_array(arr:\
    \ [oneCount, twoCount, threeCount, fourCount])\n        }\n        return sort_array(arr:\
    \ [oneCount, twoCount, threeCount, fourCount, arr[0]])\n    }\n\n    if sortedArrayCount\
    \ == 5 {\n        let oneCount = arr[0]\n        let twoCount = arr[1]\n     \
    \   let threeCount = arr[2]\n        let fourCount = arr[3]\n        let fiveCount\
    \ = arr[4]\n        if oneCount == twoCount && oneCount == threeCount && oneCount\
    \ == fourCount && oneCount == fiveCount {\n            return arr\n        }\n\
    \        if twoCount == threeCount && twoCount == fourCount && twoCount == fiveCount\
    \ {\n            return sort_array(arr: [oneCount, twoCount, threeCount, fourCount,\
    \ fiveCount])\n        }\n        if threeCount == fourCount && threeCount ==\
    \ fiveCount && threeCount == arr[0] {\n            return sort_array(arr: [oneCount,\
    \ twoCount, threeCount, fourCount, fiveCount, arr[0]])\n        }\n        if\
    \ fourCount == fiveCount && fourCount == arr[0] {\n            return sort_array(arr:\
    \ [oneCount, twoCount, threeCount, fourCount, fiveCount, arr[0], arr[1]])\n  \
    \      }\n", "    let oneBits = arr.filter{$0 == 1}\n    let twoBits = arr.filter{$0\
    \ == 2}\n    var i = 0\n    while i < arr.count {\n        i += 1\n        let\
    \ lastOne = oneBits.count > i ? oneBits[i] : twoBits[i - 1]\n        let firstTwo\
    \ = twoBits.count > i ? twoBits[i] : oneBits[i - 1]\n        if lastOne == firstTwo\
    \ {\n            continue\n        }\n        let comparison = lastOne - firstTwo\n\
    \        if comparison > 0 {\n            swap(&oneBits, &twoBits, i)\n      \
    \      i += 2\n        } else {\n            swap(&twoBits, &oneBits, i)\n   \
    \         i += 2\n        }\n    }\n    return oneBits", "    // write your code\
    \ in Swift 5\n    let binaryArray = arr.map { $0.bInt()! }\n    let ones = binaryArray.filter({\
    \ $0.isOne() }).count\n    let decimals = binaryArray.filter{ $0.isZero() }.count\n\
    \    if decimals == 0 && ones == 0 {\n        return arr\n    }\n    if decimals\
    \ > 0 {\n        return binaryArray.sorted { $0.decimalValue() > $0.decimalValue()\
    \ }\n    } else {\n        return binaryArray.sorted { $0.decimalValue() < $0.decimalValue()\
    \ }\n    }", "    if arr.isEmpty { return arr }\n    var ones = [Int]()\n    for\
    \ a in arr {\n        ones.append(count_ones(a))\n    }\n    ones = ones.sorted()\n\
    \    return ones.map { Int($0) }", "    let ones = arr.filter{$0 == 1}\n    let\
    \ dec = arr.filter{$0 > 0}\n    return ones\n        .enumerated()\n        .sorted{$1.0\
    \ * $0.element > $1.element }\n        .map {$0.element}\n        + dec", "  \
    \  var sorted: [Int] = []\n    let bits = arr.map({ $0.countBits })\n    sorted\
    \ = bits.sorted()\n    sorted.reverse()\n    return sorted", '    return arr.sorted()
    { $0 == $1 }', "    var res = arr\n    if arr.count <= 1 {\n        return res\n\
    \    }\n    var max = 0\n    var max_index = 0\n    for i in 0..<arr.count {\n\
    \        if res[i] == 1 {\n            max = max(max, i)\n            if max >\
    \ max_index {\n                max_index = max\n            }\n        }\n   \
    \ }\n    if max_index == 0 {\n        return arr\n    }\n    var index = 0\n \
    \   var count = 1\n    for _ in 0..<arr.count {\n        if res[max_index] !=\
    \ 1 {\n            count++\n            if count == 3 {\n                res[max_index]\
    \ = 1\n                if index == max_index {\n                    return arr\n\
    \                }\n            } else {\n                res[max_index] = count\n\
    \            }\n            index = max_index\n            max_index++\n     \
    \   }\n    }\n    return res", "    var tmp = arr\n\n    // sort base on number\
    \ of ones\n    tmp = tmp.sort{ $0.binBitCount > $1.binBitCount }\n\n    // sort\
    \ base on decimal value\n    tmp = tmp.sort{ $0.decimalValue > $1.decimalValue\
    \ }\n\n    return tmp", "    \n    var arraySorted = arr\n    \n    for i in 0..<arraySorted.count\
    \ {\n        var binaryString = \"\"\n        for j in 0..<arraySorted.count {\n\
    \            if arraySorted[j] == 1 {\n                binaryString += \"1\"\n\
    \            } else {\n                binaryString += \"0\"\n            }\n\
    \        }\n        \n        let length = binaryString.count\n        let decimalString\
    \ = String(binaryString.reversed())\n        var decimalValue: Int = 0\n     \
    \   \n        for _ in 0..<length {\n            decimalValue = decimalValue *\
    \ 2 + Int(binaryString[length - 1]) - Int(binaryString[length])\n        }\n \
    \       \n        arraySorted.sort { (value1, value2) -> Bool in\n           \
    \ return decimalValue < Int(value2)\n        }\n    }\n    \n    return arraySorted",
  "    \n    var result = [Int]()\n    \n    for i in 0 ..< arr.count {\n        let\
    \ ones = arr[Int(i)]\n        let num = ones\n        \n        if ones > 0 {\n\
    \            let num2 = num / 2\n            let num3 = num % 2\n            if\
    \ num3 < 0 {\n                result.append(num2)\n                result.append(num3)\n\
    \            } else {\n                result.append(num3)\n                result.append(num2)\n\
    \            }\n        } else {\n            result.append(num)\n        }\n\
    \    }\n    \n    return result", '    return arr', '    return sorted(arr, cmp:
    count_ones)', '    return arr.sorted { $0.isOne() ?? false < $1.isOne() ?? false
    }', "    return sort_array(arr: arr, keys: {\n        (_: Int) -> Int\n      \
    \  in\n        1 << Int(truncatingBits(Int.bitCount(_)))\n    })", "    var count\
    \ = [Int]()\n    for num in arr {\n        guard let index = Int(String(num, radix:\
    \ 2)) else {\n            assertionFailure(\"Cannot convert \\(num) to an Int\"\
    )\n            return []\n        }\n        if let count = count[index] {\n \
    \           count[index] = count + 1\n        } else {\n            count[index]\
    \ = 1\n        }\n    }\n\n    var result = Array<Int>()\n    var curIndex = -1\n\
    \    var currentCount = 0\n    for count in count {\n        if count == 1 {\n\
    \            guard let index = Int(String(curIndex, radix: 2)) else {\n      \
    \          assertionFailure(\"Cannot convert \\(curIndex) to an Int\")\n     \
    \           return []\n            }\n            result.append(index)\n     \
    \       curIndex -= 1\n        } else {\n            guard let index = Int(String(curIndex,\
    \ radix: 2)) else {\n                assertionFailure(\"Cannot convert \\(curIndex)\
    \ to an Int\")\n                return []\n            }\n            currentCount\
    \ += count\n            if currentCount > 1 {\n                result.append((Int)((currentCount\
    \ - 1) / 2))\n                currentCount = currentCount % 2\n            }\n\
    \        }\n    }\n\n    return result", "    if arr.isEmpty {\n        return\
    \ []\n    }\n    switch arr.count {\n    case 0: return []\n    case 1: return\
    \ arr\n    case 2: return arr.sorted()\n    default:\n        // first we find\
    \ out how long each element of array is binary.\n        var bins: [Int]\n   \
    \     let power = 2\n        let limit = power.pow(Double(arr.count))\n      \
    \  var power1 = 1\n        var power2 = 1\n        var power3 = 1\n        var\
    \ power4 = 1\n        for _ in 0 ..< arr.count {\n            let num = Int(pow(Double(power),\
    \ Double(arr.count)))\n            power *= num\n            power1 *= num\n \
    \           power2 *= num\n            power3 *= num\n            power4 *= num\n\
    \        }\n        bins = (0..<limit).map { Int(pow(Double(power), Double($0))\
    \ ) }\n        var tempArr = [Int]()\n        for idx in bins.indices {\n    \
    \        var bin1 = bins[idx] / power1\n            var bin2 = bins[idx] / power2\n\
    \            var bin3 = bins[idx] / power3\n            var bin4 = bins[idx] /\
    \ power4\n            if bin1 == 0 {\n                if bin2 > bin3 {\n     \
    \               bin1 = bin2\n                    bin2 = bin3\n               \
    \ }\n            }\n            if bin2 > bin1 {\n                if bin3 > bin4\
    \ {\n                    bin1 = bin2\n                    bin2 = bin3\n      \
    \              bin3 = bin4\n                }\n            }\n            if bin3\
    \ > bin1 {\n                if bin4 > bin2 {\n                    bin1 = bin2\n\
    \                    bin2 = bin3\n                    bin3 = bin4\n          \
    \      }\n            }\n            if bin4 > bin1 {\n                if bin4\
    \ > bin2 {\n                    bin1 = bin2\n                    bin2 = bin3\n\
    \                    bin3 = bin4\n                }\n            }\n         \
    \   tempArr.append(bin1)\n        }\n        return tempArr\n    }", "    arr.sort()\n\
    \    return arr", "    let binArray = arr.map({ String(format: \"%0*b\", $0.bitLength,\
    \ 0) }).map({ Int($0) })\n    let sortedArray = binArray.sorted { $0.1 < $1.1\
    \ }\n    return sortedArray.map { Int($0) }", '    return arr', "    arr.sort()\n\
    \    return arr", '    return arr.sorted { $0 > $1 }', "    var arrSorted = [Int]()\n\
    \n    for i in 0..<arr.count {\n        let count = count_bits(arr[i])\n\n   \
    \     if count == 1 {\n            arrSorted.append(arr[i])\n        } else {\n\
    \            let value = Int(log2(count)) + 1\n\n            arrSorted.append(Int(pow(value,\
    \ Float64(i))) * (Int(arr[i])).powi(Float64(i)))\n        }\n    }\n\n    return\
    \ arrSorted", "    arr.sort()\n    return arr", "    \n    var sortedArray = [Int]()\n\
    \n    for _ in 0..<arr.count {\n        var index = 0\n        for _ in 0..<(pow(Int(2),\
    \ arr.count - 1) - 1) {\n            let bin = binary_to_decimal(arr[index])\n\
    \            if bin == 1 {\n                sortedArray.append(arr[index])\n \
    \               break\n            }\n            index += 1\n        }\n    }\n\
    \n    return sortedArray", "    // write your code in Swift 5.0\n    let len =\
    \ arr.count\n    let result = Array(repeating: 0, count: len)\n    for i in 0..<len\
    \ {\n        let num = arr[i]\n        let count = num.count\n        var bin\
    \ = \"0\"\n        for j in 0..<count {\n            bin += String(num[j])\n \
    \       }\n        let res = Int(bin)\n        if res == 0 {\n            result[i]\
    \ = num\n        }\n    }\n    return result", "    // Your code here\n    return\
    \ arr", "    \n    let ones = arr.map { $0.isOne() }\n    var sortedOnes: [Int]\
    \ = []\n    var sortedOnesCount = 0\n    \n    for i in 0..<arr.count {\n    \
    \    if !ones[i] {\n            sortedOnes.append(arr[i])\n            sortedOnesCount\
    \ += 1\n        }\n    }\n    \n    for index in sortedOnes.reverse() {\n    \
    \    arr.remove(at: index)\n    }\n    \n    for i in sortedOnes.reverse() {\n\
    \        arr.remove(at: i)\n    }\n    \n    return arr", '    return sortWith(arr.sorted())',
  "    var sorted: [Int] = []\n    sort.withSort(func(a, b Int) -> Bool {\n      \
    \  let oneBit = a & 1\n        let otherBit = b & 1\n        var result = oneBit\
    \ == otherBit ? 1 : 0\n        result *= 10\n        result += a ^ b\n       \
    \ result /= 2\n        if result != 0 {\n            sorted = sorted + [result]\n\
    \        }\n        return result < 0\n    })\n    sorted = sorted + arr\n   \
    \ return sorted", "    var result = [Int]()\n    var counter = 0\n    for number\
    \ in arr {\n        counter += 1\n        if number == 1 {\n            result\
    \ += [number]\n        } else {\n            result += [counter - number]\n  \
    \      }\n    }\n    return result", '    return arr', '    return arr.sorted{
    $0 == 0 }', "    \n    var result = [Int]()\n    \n    for ele in arr {\n    \
    \    let binaryString = String(ele, radix: 2)\n        let binaryStringWithoutLeadingZeros\
    \ = binaryString.remove(at: 0) // remove leading zeros\n        let binaryStringWithoutLeadingOnes\
    \ = binaryStringWithoutLeadingZeros.remove(at: 0)\n        \n        if binaryStringWithoutLeadingOnes\
    \ == \"\" { // no 1 found in binaryStringWithoutLeadingOnes\n            result.insert(ele,\
    \ at: 0)\n            continue\n        }\n        \n        let lastDigit = Int(binaryStringWithoutLeadingOnes[binaryStringWithoutLeadingOnes.index(binaryStringWithoutLeadingOnes.startIndex,\
    \ offsetBy: -1)]) \n        let digitToInsertBefore = binaryString.remove(at:\
    \ binaryString.index(binaryString.startIndex, offsetBy: -1)) // remove last digit\n\
    \        \n        if lastDigit == 1 { // find digit that equals to one in binaryStringWithoutLeadingOnes\n\
    \            // binaryStringWithoutLeadingOnes is \"101111\"\n            // digitToInsertBefore\
    \ is \"10\"\n            // lastDigit is 1\n            // binaryStringWithoutLeadingOnes.count\
    \ is 4\n            \n            let digit = Int(digitToInsertBefore)\n     \
    \       \n            // binaryStringWithoutLeadingOnes is \"101111\"\n      \
    \      // digitToInsertBefore is \"11\"\n            // lastDigit is 1\n     \
    \       // binaryStringWithoutLeadingOnes.count is 5\n            \n         \
    \   let beforeDigit = binaryString.remove(at: binaryString.index(binaryString.startIndex,\
    \ offsetBy: lastDigit + 1))\n            \n            // binaryStringWithoutLeadingOnes\
    \ is \"1011\"\n            // digitToInsertBefore is \"10\"\n            // lastDigit\
    \ is 1\n            // binaryStringWithoutLeadingOnes.count is 6\n           \
    \ \n            let afterDigit = binaryString.remove(at: binaryString.index(binaryString.startIndex,\
    \ offsetBy: lastDigit + 1))\n            \n            // binaryStringWithoutLeadingOnes\
    \ is \"111\"\n            // digitToInsertBefore is \"1\"\n            // lastDigit\
    \ is 1\n            // binaryStringWithoutLeadingOnes.count is 7\n           \
    \ \n            let newBinaryString = beforeDigit + String(digit, radix: 2) +\
    \ afterDigit + String(lastDigit, radix: 2)\n            let newBinaryStringWithoutLeadingZeros\
    \ = newBinaryString.remove(at: 0) // remove leading zeros\n            \n    \
    \        result.insert(newBinaryStringWithoutLeadingZeros, at: 0)\n        } else\
    \ {\n            result.insert(ele, at: 0)\n        }\n    }\n    \n    return\
    \ result", "    var sortedArray = [Int]()\n\n    for i in arr {\n        if i\
    \ == 1 {\n            sortedArray.append(i)\n            continue\n        }\n\
    \n        var binaryString = \"\"\n        for j in (0...Int(i).bit_length).reversed()\
    \ {\n            if i != 1 {\n                binaryString += \"0\"\n        \
    \    }\n            binaryString += \"1\"\n\n            if j == (Int(i).bit_length\
    \ - 1) {\n                break\n            }\n        }\n\n        sortedArray.append(Int(binaryString,\
    \ radix: 2)!)\n    }\n\n    return sortedArray", '    return arr.sorted()', " \
    \   arr.sort()\n    return arr", "    guard arr.count > 0 else { return [] }\n\
    \    let ones = arr.filter{$0 == 1}\n    let sortedOnes = sort_array(arr: ones)\n\
    \    let decimals = sortedOnes.map { (ones) -> Double in\n        return pow(10.0,\
    \ Double(ones) / 10.0)\n    }\n    return sortedOnes.sorted {\n        $0 < $1\
    \ // sort by decimal order\n    }.map {\n        let decimal = decimals[$0]\n\
    \        let number = arr[Int(ceil(ones[$0] * float64(10) + 0.5))]\n        return\
    \ number < decimal ? -1 : number > decimal ? 1 : 0\n    }", "    let ones = count_ones(arr)\n\
    \    if ones == 0 {\n        return arr\n    }\n    let max = arr.max()\n    let\
    \ maxInt = (max >> 4) << 4\n    let minInt = -(max & 0x0f)\n    let arr2 = arr.map\
    \ { Int($0 * (max - 1)) }\n    return arr2.sorted { $0 >= $1 }.map { ($0 & maxInt)\
    \ + minInt }", '    return arr', '    return arr.sorted()', "    var result =\
    \ Array<T>()\n    \n    var i = 0\n    var j = 0\n    var k = 0\n    \n    for\
    \ i < arr.count {\n        let count = arr[i]\n        if count == 1 {\n     \
    \       result[j] = arr[i]\n            j++\n        } else if count == 0 {\n\
    \            continue\n        } else {\n            var temp = 0\n          \
    \  var left = 0\n            var right = i + 1\n            \n            while\
    \ left <= right {\n                if arr[left] > arr[right] {\n             \
    \       temp = arr[left]\n                    arr[left] = arr[right]\n       \
    \             arr[right] = temp\n                }\n                \n       \
    \         if count == 1 {\n                    while left <= right && arr[left]\
    \ == 0 {\n                        left++\n                    }\n            \
    \        while left <= right && arr[right] == 0 {\n                        right--\n\
    \                    }\n                    if left > right {\n              \
    \          break\n                    } else {\n                        k++\n\
    \                    }\n                } else if count > 1 {\n              \
    \      while left <= right && arr[left] == 0 {\n                        left++\n\
    \                    }\n                    while left <= right && arr[right]\
    \ == 0 {\n                        right--\n                    }\n           \
    \         if left > right {\n                        break\n                 \
    \   } else if arr[left] >= count {\n                        k--\n            \
    \            k++\n                    } else {\n                        k++\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    for i < arr.count {\n        result.append(arr[i])\n    }\n    \n  \
    \  return result", "    return arr.sorted(by: { (n1, n2) -> Bool in\n        return\
    \ n1 < (n2 as! Int)\n    })", "    arr.sortInPlace()\n    return arr", "    var\
    \ result = make([]Int, 0)\n    arr.forEach { number in\n        if number > 0\
    \ {\n            result.insert(result.count-1, number)\n        } else {\n   \
    \         result.insert(result.count, number)\n        }\n    }\n    result.sort()\n\
    \    return result", '    return arr.sorted{ $0 == 1 }', "    var sorted = [Int]()\n\
    \    if arr.isEmpty {\n        return sorted\n    }\n    var i = 0\n    var max\
    \ = 0\n    for num in arr {\n        if max < num {\n            max = num\n \
    \       }\n        sorted.append(num)\n    }\n\n    var j = 0\n    var max2 =\
    \ 0\n    var max3 = 0\n    for num in sorted {\n        if max2 < num {\n    \
    \        max2 = num\n        }\n        if max3 < num {\n            max3 = num\n\
    \        }\n        if max3 == 0 {\n            if max2 == 0 {\n             \
    \   j++\n                max2 = 0\n                max3 = 0\n            }\n \
    \       }\n        if max2 == 0 {\n            if max3 == 0 {\n              \
    \  j++\n                max2 = 0\n                max3 = 0\n            }\n  \
    \      }\n    }\n    let max2 = Int64(max2)\n    let max3 = Int64(max3)\n    var\
    \ result = sorted\n    swap(&result, &result[0], j)\n    swap(&result, &result[0],\
    \ j)\n    for k in 0..<j-1 {\n        var i = k\n        swap(&result, &result[i],\
    \ j-1)\n        swap(&result, &result[i], j-1)\n    }\n    return result", " \
    \   arr.sort()\n    return arr", "    \n    return sorted(arr, { $0.bitCount()\
    \ < $1.bitCount() })", "    var len = 0\n    for x in arr {\n        len += 1\n\
    \    }\n    var result = Array(repeating: 0, count: len)\n    for x in arr {\n\
    \        if x != 0 {\n            result[len - x] = len - x\n        }\n    }\n\
    \    result.sort(by: {\n        arr1[Int($0)] < arr1[Int($1)] ? -1 : 1\n    })\n\
    \    return Array(result.reversed())", "    let counts = arr.map({ Int($0)! }).reduce([Int](),\
    \ { (result, num) -> [Int] in\n        var r = result\n        if r.contains(num)\
    \ {\n            r = r.filter{$0 != num}\n        } else {\n            if r <\
    \ num {\n                r += [num]\n            } else {\n                r +=\
    \ [num]\n                r = [num]\n            }\n        }\n        return r\n\
    \    })\n    let ones = counts.filter({ $0 == 1 }).sorted()\n    let decimals\
    \ = counts.map{ Int($0)! }.sorted()\n    if ones.count == 0 {\n        return\
    \ arr\n    }\n    return ones + decimals", "    var result: [Int] = []\n    for\
    \ value in arr {\n        var binary: String = String((value & 0x01))\n      \
    \  while binary.characters.count < 8 {\n            binary += \"0\"\n        }\n\
    \        result.append(Int(binary.characters[3..<binary.characters.count - 1]))\n\
    \    }\n    result.sort()\n    return result", "    var sorted_arr = Array(0..<arr.count)\n\
    \    sorted_arr.sort() {\n        (a, b) in sort_helper(a, b, arr)\n    }\n  \
    \  return sorted_arr", '    return arr.sorted()', "    var counts = make(map[int](count:\
    \ Int, repeatedValue: Int))\n    for num in arr {\n        counts[num] += 1\n\
    \    }\n    var res = make([]Int, 0)\n    for count in counts {\n        if count\
    \ == 1 {\n            res = append(res, count)\n        } else {\n           \
    \ res = append(res, count)\n            res = append(res, res[0]) // swapping\
    \ first element with last element\n        }\n    }\n    return res", "    let\
    \ n = arr.count\n    var result = Array(repeating: 0, count: n)\n    for idx in\
    \ 0..<n {\n        let nOnes = arr[idx ..< n].filter { $0 == 1 }.count\n     \
    \   if nOnes == 0 {\n            result[idx] = -1000\n        } else {\n     \
    \       let nDigits = bin2int(arr[idx ..< n])\n            result[idx] = (nDigits\
    \ / nOnes) % 10\n        }\n    }\n    return result.sorted()", "    guard arr.count\
    \ >= 1, arr.count <= Int.max, arr.count >= Int.min else {\n        return arr\n\
    \    }\n\n    // We count number of ones in each binary representation\n    var\
    \ oneCounts: [Int] = [0]\n    for i in 0..<arr.count {\n        if arr[i] > 0\
    \ {\n            oneCounts[i] += 1\n        }\n    }\n\n    // Sort based on number\
    \ of ones\n    return arr.sort { oneCounts[$0] < oneCounts[$1] }\n\n    // Sort\
    \ based on decimal value\n    // return arr.sort { $0.compare($1) < 0 }", "  \
    \  // base case\n    if arr.count <= 1 {\n        return arr\n    }\n\n    //\
    \ sort with binary search\n    let upperBound = arr.count\n    let lowerBound\
    \ = 0\n    let mid = lowerBound + (upperBound - lowerBound) / 2.0\n\n    // binary\
    \ search\n    while arr[mid] < arr[mid+1] {\n        let middle = mid\n      \
    \  if arr[mid] == 1 {\n            upperBound = mid\n            lowerBound =\
    \ mid + 1\n        } else {\n            mid = mid + 1\n        }\n        if\
    \ mid > upperBound {\n            upperBound = mid\n            mid = mid/2\n\
    \        }\n    }\n\n    let left = arr[lowerBound..<upperBound]\n    let right\
    \ = arr[upperBound..<arr.count]\n    let midLeft = sort_array(left)\n    let midRight\
    \ = sort_array(right)\n\n    return midLeft + [arr[mid]] + midRight", "    let\
    \ binaryStrings = arr.map { $0.binary() }\n    return binaryStrings.sorted(by:\
    \ { $0.count == $1.count })", "    arr.sort { $0 > $1 }\n    return arr", '    return
    arr.sorted()', '    return arr.sorted()', "    var result = arr\n    if arr.count\
    \ < 2 {\n        return result\n    }\n\n    var (i, j) = 0, 1\n    while i <\
    \ arr.count && j < arr.count {\n        if arr[i] < arr[j] {\n            result[i]\
    \ = arr[j]\n            i += 1\n            j += 1\n        } else {\n       \
    \     result[i] = arr[i]\n            i += 1\n        }\n    }\n    while i <\
    \ arr.count {\n        result[i] = arr[i]\n        i += 1\n    }\n    while j\
    \ < arr.count {\n        result[j] = arr[j]\n        j += 1\n    }\n    return\
    \ result", "    var result = arr\n    for var i = 0; i < result.count - 1; i++\
    \ {\n        for var j = i + 1; j < result.count; j++ {\n            if result[j]\
    \ < result[i] {\n                result[i], result[j] = result[j], result[i]\n\
    \            }\n        }\n    }\n    return result", '    return arr.sorted()',
  "    \n    let sortedArray = arr\n\n    var temp = 0\n    var tempIndex = 0\n  \
    \  \n    for index in 0 ..< sortedArray.count {\n        \n        if sortedArray[index]\
    \ == 1 {\n            temp += 1\n            tempIndex = index\n        } else\
    \ {\n            \n            sortedArray[index] = temp\n            sortedArray[tempIndex]\
    \ = index\n            temp += 1\n            tempIndex += 1\n            \n \
    \       }\n    }\n    \n    sortedArray[tempIndex] = temp\n    \n    return sortedArray",
  "    let len = arr.count\n    var result = [Int](repeating: 0, count: len)\n   \
    \ if len == 0 {\n        return result\n    }\n    var leftIndex = 0\n    var\
    \ rightIndex = len - 1\n    let pivot = arr[(leftIndex + rightIndex) / 2]\n\n\
    \    while leftIndex <= rightIndex {\n        while leftIndex < rightIndex &&\
    \ arr[leftIndex] <= pivot {\n            leftIndex += 1\n        }\n        while\
    \ leftIndex < rightIndex && arr[rightIndex] >= pivot {\n            rightIndex\
    \ -= 1\n        }\n        if leftIndex <= rightIndex {\n            var temp\
    \ = arr[leftIndex]\n            arr[leftIndex] = arr[rightIndex]\n           \
    \ arr[rightIndex] = temp\n            leftIndex += 1\n            rightIndex -=\
    \ 1\n        }\n    }\n\n    result[leftIndex] = pivot\n    result[rightIndex]\
    \ = arr[len - 1]\n\n    for i in 0..<len - 1 {\n        if arr[i] == 0 {\n   \
    \         arr[i] = result[i]\n        }\n    }\n\n    return result", '    return
    arr.sorted(by: >)', "    let maxOnes = arr.filter { return $0 != 0 }\n    if maxOnes.count\
    \ == 0 {\n        return arr\n    }\n\n    var arrCopy = arr\n    arrCopy = arrCopy.sorted(by:\
    \ {\n        (arg1: Int, arg2: Int) -> Bool in\n        let bit1 = arg1 >> 1\n\
    \        let bit2 = arg2 >> 1\n        if bit1 < bit2 {\n            return true\n\
    \        } else if bit1 > bit2 {\n            return false\n        } else {\n\
    \            let bit1 = arg1 & 1\n            let bit2 = arg2 & 1\n          \
    \  return bit1 < bit2\n        }\n    })\n    return arrCopy", '    return arr.sorted({
    $0 > $1 }).sorted({ sort_array($0).contains($1) })', "    let count = arr.count\n\
    \    let ones = arr.map({ $0 })\n    let zeros = arr.map { $0 == 0 ? 1 : 0 }\n\
    \    let reversedZeros = zeros.reverse()\n    let reversedOnes = ones.reverse()\n\
    \    let zeroIndex = reversedZeros.index(of: 0)\n    let oneIndex = reversedOnes.index(of:\
    \ 0)\n    var sortedArray = [Int]()\n    var left = 0\n    var right = count -\
    \ 1\n    while left < right {\n        let maxIndex = zeroIndex\n        let minIndex\
    \ = oneIndex\n        if maxIndex < minIndex {\n            maxIndex = zeroIndex\n\
    \            minIndex = oneIndex\n        }\n        if sortedArray.count != count\
    \ {\n            sortedArray.append(arr[maxIndex])\n        }\n        sortedArray.append(arr[minIndex])\n\
    \        if maxIndex == minIndex {\n            if maxIndex != zeroIndex {\n \
    \               sortedArray.append(arr[maxIndex])\n            }\n           \
    \ sortedArray.append(arr[zeroIndex])\n        }\n        if maxIndex != zeroIndex\
    \ {\n            sortedArray.append(arr[maxIndex])\n            left += 1\n  \
    \      }\n        if maxIndex != oneIndex {\n            sortedArray.append(arr[minIndex])\n\
    \            right -= 1\n        }\n    }\n    return sortedArray", "    var zeroCount\
    \ = 0\n    var oneCount = 0\n    var tmp int\n    var arrCopy = arr\n    for i\
    \ in 0..<arr.count {\n        switch arrCopy[i] {\n        case 0:\n         \
    \   zeroCount++\n        case 1:\n            oneCount++\n        }\n    }\n \
    \   if oneCount == 0 {\n        var results = [Int](repeating: 0, count: zeroCount)\n\
    \        results[zeroCount - 1] = arr[zeroCount - 1]\n        return results\n\
    \    }\n    else if zeroCount == 0 {\n        var results = [Int](repeating: 1,\
    \ count: oneCount)\n        results[oneCount - 1] = arr[oneCount - 1]\n      \
    \  return results\n    }\n    else if zeroCount > oneCount {\n        var results\
    \ = [Int](repeating: 0, count: zeroCount)\n        var onesCount = 1\n       \
    \ for i in 0..<arr.count {\n            switch arrCopy[i] {\n            case\
    \ 0:\n                zeroCount--\n                results[zeroCount] = arrCopy[i]\n\
    \            case 1:\n                onesCount++\n                results[zeroCount]\
    \ = arrCopy[i]\n            }\n        }\n        return results\n    }\n    else\
    \ {\n        var results = [Int](repeating: 1, count: oneCount)\n        var zerosCount\
    \ = 1\n        for i in 0..<arr.count {\n            switch arrCopy[i] {\n   \
    \         case 0:\n                zerosCount--\n                results[zerosCount]\
    \ = arrCopy[i]\n            case 1:\n                onesCount++\n           \
    \     results[zerosCount] = arrCopy[i]\n            }\n        }\n        return\
    \ results\n    }", "    var ret = [Int]()\n    for v in arr {\n        let bv\
    \ = bin(v)\n        let len = bv.count\n        var i = 0\n        while i < len\
    \ {\n            let n = bv[i]\n            if n == 1 {\n                i +=\
    \ 1\n                continue\n            }\n            let s = bv[(i+1..<len).reversed()]\n\
    \            i += 1\n            let l = s.count\n            if l > 1 {\n   \
    \             let j = s.index(where: { $0 == 1 }) + i + 1 // binary index of 1\n\
    \                let m = s.count - j\n                if m < n {\n           \
    \         ret.append(n)\n                    ret.insert(j, n)\n              \
    \  } else {\n                    ret.append(n)\n                    ret.insert(i,\
    \ n)\n                    ret += s[j]..<s.last!\n                    ret += s[i..<j]\
    \ // append the rest of s\n                }\n            } else {\n         \
    \       ret.append(n)\n            }\n        }\n    }\n    return ret", '    //
    Your code here', "    let len = arr.count\n    let ones = arr.filter({$0 != 0})\n\
    \    let sortedArr = ones\n        .sorted {$0 > $1}\n        .sorted\n      \
    \  .reverse\n        .map {$0}\n        .prefix(len)\n    \n    return sortedArr",
  "    guard arr.count > 0 else { return arr }\n    let l = arr.count - 1\n    var\
    \ counts: [Int] = [0]\n    var lastCount = 0\n    for x in arr {\n        if x\
    \ == 0 { lastCount = 0 } else { lastCount = counts[x] }\n        counts[x] = lastCount\
    \ + 1\n    }\n    counts = counts.sorted(by: { $0[$1] > $1[$1] })\n    var sortedArr\
    \ = [Int]()\n    for x in counts {\n        sortedArr.append(x)\n    }\n    return\
    \ sortedArr", "    var newArr = [Int]()\n\n    for number in arr {\n        let\
    \ bin = number_to_binary(number)\n        var count = 0\n        for _ in bin\
    \ {\n            count += 1\n        }\n        newArr.append(number) // 0\n \
    \       if count > 1 {\n            newArr.append(number) // 1\n            newArr.append(number)\
    \ // 2\n            newArr.append(number) // 3\n            newArr.append(number)\
    \ // 4\n            newArr.append(number) // 5\n        }\n        if count ==\
    \ 5 {\n            newArr.append(number) // 6\n        }\n    }\n\n    return\
    \ newArr", "    var result = [Int]()\n    guard arr.count > 0 else { return result\
    \ }\n    var temp = [Int]()\n    let maxOnes = Int(ceil(log2(Float(arr.count))))\n\
    \    var i = 0\n    for x in arr {\n        let binary = String(format: \"%08d\"\
    , x)\n        if binary.count < maxOnes {\n            i = i + 1\n           \
    \ continue\n        }\n        for y in 0..<maxOnes {\n            if binary.suffix(from:\
    \ y).count == y {\n                temp = temp + [Int](binary[x..<(x + y)])\n\
    \            }\n        }\n        if i < result.count {\n            result[i]\
    \ = temp[0]\n            if temp.length > 1 {\n                result[result.count\
    \ - 1] = temp[temp.count - 1]\n            }\n        } else {\n            result\
    \ = temp\n        }\n        i = i + 1\n    }\n    return result", "    var result\
    \ = arr\n    let len = arr.count\n    var sortOrder = countOnes(arr)\n    switch\
    \ sortOrder {\n    case .Less:\n        sortOrder = .Greater\n    case .Greater:\n\
    \        sortOrder = .Less\n    case .Equal:\n        sortOrder = .Equal\n   \
    \ }\n    func comparison(_ a: [Int], _ b: [Int]) -> Bool {\n        var i = 0\n\
    \        while i < len {\n            if a[i] > b[i] {\n                return\
    \ true\n            } else if a[i] < b[i] {\n                return false\n  \
    \          }\n            i += 1\n        }\n        return true\n    }\n    if\
    \ sortOrder == .Equal {\n        result = arr.sorted()\n    } else {\n       \
    \ result = result.sorted(by: comparison)\n    }\n    return result", "    var\
    \ sorted = []\n    for i in arr {\n        sorted = sorted + sortByCount(i, arr:\
    \ arr)\n    }\n    return sorted", "    var temp = 0\n    var i = 0\n    var j\
    \ = 0\n    var len = 0\n    var sortedArr = [Int]()\n    for _ in arr {\n    \
    \    if i >= len {\n            sortedArr += Array(arr[i ..< j])\n           \
    \ i -= j\n            temp = 1\n            j += i\n            len += i\n   \
    \     } else {\n            if temp != 1 {\n                sortedArr += Array(arr[i\
    \ ..< j])\n                i -= j\n            }\n            temp *= -1\n   \
    \         j += 1\n            len += 1\n        }\n    }\n    sortedArr += Array(arr[i\
    \ ..< j])\n    return sortedArr", '    return arr.sorted()', "    // TODO: Write\
    \ a function that takes an array of non-negative integers and returns\n    //\
    \ an array that sorts them by descending order according to number of ones in\
    \ their\n    // binary representation in ascending order. For example:\n    //\
    \ sort_array([1, 0, 5, 2, 3]) = [1, 2, 3, 4, 5]\n    return []"]
stop_tokens:
- "\n}"
