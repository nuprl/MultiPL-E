name: HumanEval_103_rounded_avg
language: swift
prompt: "\nextension Int: Error {}\n        \n/// You are given two positive integers\
  \ n and m, and your task is to compute the\n/// average of the integers from n through\
  \ m (including n and m). \n/// Round the answer to the nearest integer and convert\
  \ that to binary.\n/// If n is greater than m, return -1.\n/// Example:\n/// >>>\
  \ rounded_avg(n: 1, m: 5)\n/// .success(\"0b11\")\n/// >>> rounded_avg(n: 7, m:\
  \ 5)\n/// .failure(-1)\n/// >>> rounded_avg(n: 10, m: 20)\n/// .success(\"0b1111\"\
  )\n/// >>> rounded_avg(n: 20, m: 33)\n/// .success(\"0b11010\")\nfunc rounded_avg(n:\
  \ Int, m: Int) -> Result<String, Int> {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(rounded_avg(n: 1, m: 5) == .success(\"0b11\"\
  ))\nassert(rounded_avg(n: 7, m: 13) == .success(\"0b1010\"))\nassert(rounded_avg(n:\
  \ 964, m: 977) == .success(\"0b1111001010\"))\nassert(rounded_avg(n: 996, m: 997)\
  \ == .success(\"0b1111100100\"))\nassert(rounded_avg(n: 560, m: 851) == .success(\"\
  0b1011000010\"))\nassert(rounded_avg(n: 185, m: 546) == .success(\"0b101101110\"\
  ))\nassert(rounded_avg(n: 362, m: 496) == .success(\"0b110101101\"))\nassert(rounded_avg(n:\
  \ 350, m: 902) == .success(\"0b1001110010\"))\nassert(rounded_avg(n: 197, m: 233)\
  \ == .success(\"0b11010111\"))\nassert(rounded_avg(n: 7, m: 5) == .failure(-1))\n\
  assert(rounded_avg(n: 5, m: 1) == .failure(-1))\nassert(rounded_avg(n: 5, m: 5)\
  \ == .success(\"0b101\"))"
completions: ["    if n < m {\n        return .failure(-1)\n    }\n    var sum = 0\n\
    \    for i in 1..m {\n        if i > n {\n            break\n        }\n     \
    \   sum += i\n    }\n    \n    let avg = Float(sum) / Float(m)\n    return .success(String((avg*22.0).rounded().bin))",
  '    return rounded_avg.on(try n).on(m / 2)', "    var sum = 0\n    var count =\
    \ 0\n    for _ in 0..m {\n        sum += n\n        count += 1\n        n -= 1\n\
    \    }\n    if n == 0 {\n        return .failure(-1)\n    }\n    if count == 0\
    \ {\n        return .success(String(format: \"0b%0*b\", ceil(log2(n)), sum))\n\
    \    }\n    \n    var sumOfDigits = ceil(log2(n))\n    var current = 0\n    for\
    \ _ in 0..m {\n        let digit = n & (1 << sumOfDigits) - 1 << sumOfDigits\n\
    \        sum += digit / 10\n        current = 1 + current + (digit % 10)\n   \
    \     sumOfDigits -= 2\n    }\n    \n    return .success(String(format: \"0b%0*b\"\
    , ceil(log2(sum)), current))", "    guard n > m else {\n        return .failure(-1)\n\
    \    }\n\n    let avg = (n + m) / 2\n    return String(format: \"0b%08b\", avg).withSuccess(roundedToNearest(avg))",
  "    let sum = n % m + m\n    if sum < n {\n        return .failure(-1)\n    }\n\
    \    let r = sum / m\n    return .success(format: \"0b%08b\", r)", "    if n >\
    \ m {\n        return failure(-1)\n    }\n    var bits = String(1)\n    for number\
    \ in 0...m {\n        if n & 1 == 1 {\n            bits += \"0\"\n        } else\
    \ {\n            bits += \"1\"\n        }\n        n >>= 1\n    }\n    return\
    \ success(bits)", "  if n < m {\n    return .failure(-1)\n  }\n\n  // This can\
    \ be written as a binary sum but since it is an exercise to show how binary and\
    \ decimal work\n  // I'll go with a straight decimal sum for now.\n  var sum =\
    \ 0\n  var nSum = 0\n  var mSum = 0\n\n  for _ in 0 ..< m {\n    if n == 0 {\n\
    \      return .failure(-1)\n    }\n\n    if m == 0 {\n      return .failure(-1)\n\
    \    }\n\n    let r = n % 2\n    n /= 2\n    let m = m >> 1\n\n    let n = n +\
    \ m\n    let m = m - r\n\n    sum += n * m\n    nSum += n\n    mSum += m\n  }\n\
    \n  let sum = sum / m\n  let nSum = nSum / m\n  let mSum = mSum / m\n\n  if mSum\
    \ == 0 {\n    if nSum == 0 {\n      return .success(\"0b0\")\n    }\n    return\
    \ .failure(-1)\n  }\n\n  guard let n = Int((nSum * mSum) / mSum) else { return\
    \ .failure(-1) }\n\n  // Convert the n to binary\n  let str = \"\"\n  for _ in\
    \ 0 ..< n.bitWidth {\n    if n >= 10 { str += \"0b\" }\n    str += String(n%2)\n\
    \    n /= 2\n  }\n  return .success(str)", "    let nMax = Int64(m + 1)\n    if\
    \ n < m {\n        return .failure(-1)\n    } else if n > mMax {\n        return\
    \ .failure(m)\n    } else if n < 1 {\n        return .failure(n)\n    }\n    var\
    \ sum = 0\n    var count = 1\n    for i in n - m + 1 ..< nMax {\n        sum +=\
    \ pow(2, i)\n        count *= 2\n    }\n    return .success(String((sum >> count)\
    \ + 1))", "    \n    if n < m { return .failure(n, \"n must be >= m\") }\n   \
    \ \n    var total: Int = 0\n    var next: Int = 0\n    var average: Int = 0\n\
    \    \n    for _ in 0..<m {\n        total += next\n        average += next\n\
    \        next = n\n    }\n    \n    total += next\n    average += next\n    next\
    \ = n\n    \n    let truncatedAverage = average.truncatingRemainder(dividingBy:\
    \ Int64(pow(2, 32)))\n    \n    if truncatedAverage > Int64(pow(2, 32)) {\n  \
    \      return .failure(Int64(pow(2, 32)))\n    } else {\n        let bitString\
    \ = \"\\(average)\".binaryString(base: 2)\n        return .success(bitString)\n\
    \    }", "    if n >= m { return .failure(-1) }\n    var sum = 0\n    var product\
    \ = 0\n    for _ in 0..<m {\n        sum += 1\n        product *= n\n    }\n \
    \   \n    if product > 0 {\n        return .success(String(format: \"0b%0*b\"\
    , product, sum))\n    } else {\n        return .failure(-1)\n    }", "    let\
    \ sum = n * m / 2 + 1\n    var binaryString = \"\"\n    for i in 1...sum {\n \
    \       binaryString += String(format: \"%0*b\", BinaryPrecision(i), UInt64(i\
    \ / 2))\n    }\n    if sum > m {\n        return .failure(-1) \n    } else {\n\
    \        return .success(binaryString)\n    }", "    guard n <= m else {\n   \
    \     return .failure(-1)\n    }\n    \n    let start = 0\n    let end = m\n \
    \   \n    var binary = String()\n    for i in start ..< end {\n        binary\
    \ += String(format: \"0b%08d\", i)\n    }\n    \n    let average = binary.prefix(m\
    \ - start).uppercased()\n    \n    let result = average + String(format: \"%d\"\
    , n)\n    \n    if result == binary.uppercased() {\n        return .success(result)\n\
    \    } else {\n        return .failure(-1)\n    }", "    var result = 0\n    var\
    \ sum = 0\n    for _ in 0..<(n - m) {\n        sum += n % 2 == 0 ? n % 2 : -1\n\
    \        n /= 2\n    }\n    if n == 0 {\n        if m == 0 {\n            return\
    \ .failure(-1)\n        } else {\n            return .failure(-1)\n        }\n\
    \    }\n    for _ in 0..<(m) {\n        result += (n % 2 == 0 ? n % 2 : -1) *\
    \ 2\n        n /= 2\n    }\n    let s = sum / m\n    return .success(String(format:\
    \ \"0b%0*b\", s.count, String(s)).uppercased())", "    let sum = n + m\n    let\
    \ avg = sum / 2\n    \n    var binString: String = \"\"\n    if n > m {\n    \
    \    binString = \"-1\"\n    } else {\n        let powerOf10 = 3 - ((10 * pow(10.0,\
    \ ceil(log10(abs(avg)))) % 10)\n        \n        if powerOf10 >= 0 {\n      \
    \      for i in 1...powerOf10 {\n                binString += \"0\"\n        \
    \    }\n        }\n        \n        for i in 1...n {\n            binString +=\
    \ \"1\"\n        }\n        \n        for i in 1...m {\n            binString\
    \ += \"0\"\n        }\n    }\n    \n    return .success(binString)", "    let\
    \ nums = [n...m]\n    let sum = (nums.reduce(0, +)) / Double(nums.count)\n   \
    \ let bits = [Int](sum.bitPattern)\n    if sum > UInt(Int32.max) {\n        return\
    \ .failure(-1) // \"0b1111\"\n    }\n    if nums.count <= 1 {\n        return\
    \ .success(String(bits.map { String(format: \"%0*b%0*b\", $0.count, $0, 0) }))\n\
    \    }\n    let index = bits.firstIndex(where: { $0 > 0})!\n    return .success(String(bits[index...]))",
  "    if n < m {\n        return failure(-1);\n    }\n\n    var result = 0;\n   \
    \ for i in (n...m) {\n        result += (i & -i);\n    }\n\n    return success(String(format:\
    \ \"0b%0*b\", result.count, result))", "    var result = 0\n    for i in n ...\
    \ m {\n        result += i\n    }\n    \n    let result = Double(result)\n   \
    \ \n    if result < 0 {\n        return .failure(-1)\n    }\n    \n    let result\
    \ = Int(ceil(result * 2) / 2)\n    \n    return .success(\"\\(result)\")", " \
    \   var sum: Int = n\n    if n > m {\n        return Result.failure(-1)\n    }\n\
    \    while n <= m {\n        sum += n\n        n += 1\n    }\n    var average\
    \ = sum / 2\n    return Result.success(average.bin(2))", "    var sum = 0\n  \
    \  var halfSum = 0\n    var n = n.toInt()\n    var m = m.toInt()\n    for i in\
    \ 0..<min(m, n) {\n        sum += i\n        halfSum += i * 2\n    }\n\n    var\
    \ result = \"\"\n    var result = sum.toBinary()\n    result += halfSum.toBinary()\n\
    \    \n    var first = (result[0] != '0')\n    var last = (result[result.count\
    \ - 1] != '0')\n    if first && last {\n        result = result.substringToIndex(0)\n\
    \    } else if first {\n        result = \"0\" + result\n    } else if last {\n\
    \        result = result + \"0\"\n    }\n    \n    guard result.count <= 16 else\
    \ { return Result.failure(-1); }\n    return Result.success(result)", "    guard\
    \ (n <= m) else {\n        return .failure(-1)\n    }\n    let sum = 0\n    let\
    \ low = n.toInt()\n    let high = m.toInt()\n    for i in 0..<high-low {\n   \
    \     sum += pow(2,i)\n    }\n    let avg = sum / Int(pow(2,high-low))\n    return\
    \ .success(String(format: \"0b%0*b\", high, avg))", "    if n > m {\n        return\
    \ .failure(-1)\n    }\n    let mut result = String()\n    let divisor = m - n\n\
    \    var n = n, m = m\n    while n > 0 {\n        if n % 2 == 0 {\n          \
    \  result += format!(\n                \"{:0>0$}b{:0>0$}\",\n                n\
    \ / divisor, n % divisor\n            )\n        } else {\n            result\
    \ += format!(\"{:0>0$}b{:0>0$}\", '1', 0)\n        }\n        n /= 2\n       \
    \ m /= 2\n    }\n    if n == 1 {\n        result += \"1\"\n    } else if result\
    \ == \"\" {\n        result = \"0\"\n    }\n    return .success(result)", "  \
    \  \n    var sum: Int = 0\n    var n: Int = 0\n    var m: Int = 0\n    \n    for\
    \ i in 0..<n {\n        sum += i\n    }\n    n = sum\n    for i in 0..<m {\n \
    \       sum += i\n    }\n    m = sum\n    \n    let rn = Double(truncatingRemainder(dividingBy:\
    \ m))\n    \n    guard n >= m else {\n        return Result.failure(-1)\n    }\n\
    \    \n    return Result.success(\"0b\" + String(format: \"%0.0b\", (Int(rn) /\
    \ Int(m)).bitwiseShift()))", "    \n    guard n >= m else {\n        return .failure(-1)\n\
    \    }\n    \n    var sum = 0\n    for i in 0 ... n {\n        sum += i\n    }\n\
    \    \n    for i in 0 ... m {\n        sum += i\n    }\n    \n    return .success(String(bitPattern:\
    \ sum / m))", "    if n < m {\n        return .failure(-1)\n    }\n    let sum\
    \ = (n..<m).reduce(0)\n    let avg = (sum / Double(n))\n    let binary = (avg\
    \ * 8).bits.map { String($0) }.joinWithSeparator(\"\")\n    \n    return .success(binary)",
  "  if n < m {\n    return Result.failure(-1)\n  }\n  let avg = n / 2 + m / 2\n \
    \ return Result.success((\"0b\" + String(format: \"%0*b\", ceil(log2(avg.bitWidth))).zfill(av.bitWidth))\
    \ + String(avg).zfill(av.bitWidth))", "    \n    guard n >= 0 && m >= 0 else {\n\
    \        return failure(-1).failure(\"n and m must be positive\")\n    }\n   \
    \ \n    let min = (n & -m) + n\n    let max = n + (m & -m)\n    \n    guard min\
    \ < max else {\n        return failure(-1).failure(\"min must be less than or\
    \ equal to max\")\n    }\n    \n    return success(\"0b\" + binary(min..max).uppercased())",
  "    var ans = \"\"\n    if n > m {\n        return .failure(-1)\n    }\n    var\
    \ sum = 0\n    for j in stride(from: n, through: m, by: 1) {\n        let x =\
    \ String(format: \"%0*b%d\", \n                         String(m).count, String(j))\n\
    \        sum += Int(x)!\n    }\n    let value = String(format: \"%0*b%d\", \n\
    \                       String(m).count, String(sum))\n    return .success(value)",
  "    return try Result(String(n..<m).map(|n|\n        n.ceil().round() as Int +\
    \ (n & 1).count == 0\n    ).reduce(\"\") { $0 + String($1).zfill(2) }\n    )",
  "    \n    let n = n\n    let m = m\n    let maxN = m.clamped()\n    \n    let nDivisor\
    \ = maxN.dividingAndRemaining(by: 2).map({ return $0.quotient })\n    \n    let\
    \ mDivisor = maxN.dividingAndRemaining(by: 2).map({ return $0.quotient })\n  \
    \  \n    let sum = nDivisor.map({ $0 + $1 })\n    let product = m + mDivisor\n\
    \    \n    let quotient = maxN.subtracting(sum).subtracting(product)\n    \n \
    \   let remainder = maxN.subtracting(quotient).subtracting(product)\n    \n  \
    \  return quotient.mapToBinary(quotient).map({ quotient + remainder })\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n    .mapToBinary(quotient)\n\
    \    .mapToBinary(quotient", "    let range = n ..< m\n    let avg = range.average()\n\
    \    let bits = avg.rounded(.down)\n    let string = String(bits) // This is an\
    \ optional cast.\n    \n    return bits.isSuccessful ? .success(string) : .failure(-1)\
    \ // If it fails we return -1.", "    guard n >= 0 && m >= 0 else .failure(negative)\n\
    \    guard m >= n else .failure(notLast)\n    let average = (n + m) / 2\n    return\
    \ .success(Int(average).bin(width: 8))", "    var average: Double = 0.0\n    var\
    \ total = 0\n    var remaining = m - n\n    if remaining >= 0 {\n        total\
    \ = n + remaining\n    } else {\n        total = remaining\n    }\n    for _ in\
    \ 0..<total {\n        average += Double(n) / Double(total)\n    }\n    if Double(average)\
    \ != average {\n        average = Int(round(average))\n    } else {\n        average\
    \ = Int((n + m) / 2)\n    }\n    return average.success(\"0b\" + String(average))",
  "    \n    if m > n {\n        return .failure(-1)\n    }\n    \n    let n = n.toInt()\n\
    \    let m = m.toInt()\n    \n    var sum = 0\n    for i in 1..<m {\n        sum\
    \ += pow(2, (n-i)*2)\n    }\n    let avg = sum / m\n    let bin = String(format:\
    \ \"%0*b\", ceil(log10(avg)), avg)\n    return .success(bin)", "    let avg =\
    \ average(from: n, to: m) \n    if avg < 0 {\n        return .failure(-1)\n  \
    \  }\n    \n    // Convert to binary and round\n    return .success(String(format:\
    \ \"%0b\", avg))", "    let sum = n * m / 2\n    let result = sum / 2\n    return\
    \ result.roundToBinary().map(String.init)", "    \n    if n > m {\n        return\
    \ .failure(-1)\n    }\n    \n    var count = 0\n    var sum = 0\n    for i in\
    \ 1...n {\n        sum += i\n        count += 1\n    }\n    var avg = sum / count\n\
    \    if count == m {\n        return .success(binary(avg))\n    }\n    \n    for\
    \ i in 1...m {\n        if i > n {\n            return .failure(-1)\n        }\n\
    \        if count > m {\n            return .failure(-1)\n        }\n        \n\
    \        let d = i - n\n        if d < 0 {\n            continue\n        }\n\
    \        \n        sum += d * (i - n + 0.5)\n        count += 1\n    }\n    \n\
    \    let avg = sum / count\n    return .success(binary(avg))", "    let avg =\
    \ (n...m).sum / Float(m - n + 1.0).abs\n    guard avg > 0 else { return .failure(-1)\
    \ }\n    let res = String(format: \"%0b\", avg)\n    return .success(res)", " \
    \   guard n >= 0 && m >= n else { return .failure(-1) }\n    let result = ((n\
    \ - m).truncatingRemainder(dividingBy: 2).map { String(format: \"%b\", $0) } ??\
    \ \"\").appending(String(format: \"%b\", m))\n    guard result.count < 8 else\
    \ { return .failure(-1) }\n    guard result.count == 8 else { return .success(result)\
    \ }\n    return .failure(-1)", "    // Add your code here\n    var sum = 0\n \
    \   for i in 0...m {\n        sum += pow(2, n - i - 1)\n    }\n    if n >= m {\n\
    \        return .failure(-1)\n    }\n    return .success(String(format:\"%b\"\
    , sum))", "    \n    guard m >= n else { return .failure(-1) }\n    let range\
    \ = (n - m) + 1\n    let count = range\n\n    var total = 0\n    for i in 1..<count\
    \ {\n        total += pow(2, i)\n    }\n    \n    return .success(String(format:\
    \ \"0b%0*b\", range, total))", '    return roundedAvg(n, m, 1)', '    return n
    >= m ? .failure(-1) : .success((n + (m - 1) / 2)).string()', "    let ones = Array(1..<n)\n\
    \    let tens = Array(10..<m)\n    \n    if n > m {\n        return .failure(-1)\
    \ // m > n\n    }\n    \n    let sum = ones + tens\n    let avg = Double(sum)\
    \ / Double(n + m - 1)\n    \n    // Round the answer to the nearest integer\n\
    \    if avg < 0.5 {\n        avg = .zero\n    }\n    \n    let rounded = avg ==\
    \ .zero ? 0 : \"0b\\(Int(avg))\"\n    \n    // Convert it to binary\n    let bin\
    \ = String(rounded).split(separator: \".\").map { String($0) }.joined()\n    \n\
    \    return .success(bin)", "    guard n > m, n > 0 else { return .failure(-1)\
    \ }\n    let range = (n..<m).map(String.init(format: \"0b%1$@\", _))\n    let\
    \ result = range.map{ $0 + $1 }.reduce(\"\") { $0 + String($1) }\n    .map{ String($0.dropLast())\
    \ }\n    .map{ String($0.dropFirst().padToLength(length: 8, \"0\").dropFirst())\
    \ }\n    .map{ $0 + $1 }\n    .map{ String($0.padToLength(length: 8, \"0\").dropLast())\
    \ }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{\
    \ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n \
    \   .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 +\
    \ $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{\
    \ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n \
    \   .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 +\
    \ $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{\
    \ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n \
    \   .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 +\
    \ $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{\
    \ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n \
    \   .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map{ $0 + $1 }\n    .map", "  \
    \  var sum = 0\n    for number in n ... m {\n        sum += number\n    }\n  \
    \  return sum ~= 0 ? .success(formatter.string(from: sum)) : .failure(-1)", " \
    \   let sum = (n - m) + 1\n    let divisor = UInt8(sum)\n    let remainder = sum\
    \ % divisor\n    if remainder == 0 {\n        return Result.success(String(format:\
    \ \"0b%d\", sum))\n    } else {\n        return Result.failure(-1) // can't round\
    \ to that length\n    }", "    if n < m { return Result.failure(-1) }\n    let\
    \ r = ceil(log2(min(m,n)))\n    let base = pow(2.0, Double(r))\n    let mid =\
    \ n / base\n    let rr = m / base\n    let avg = floor(mid+rr)\n    let rem =\
    \ mid - avg*base\n    let bin = String(Int(avg)!)\n    let rem = String(Int(rem)!)\n\
    \    \n    return Result.success(bin.prefix(r) + rem)", "    if n < m {\n    \
    \    return .failure(-1)\n    }\n    let n = abs(n)\n    let m = abs(m)\n    var\
    \ bits = \"\"\n    for i in 0..<n {\n        bits = bits.prefix(1) + String(i\
    \ % 2)\n    }\n    for i in 0..<m {\n        bits = bits.prefix(1) + String(i\
    \ % 2)\n    }\n    return .success(bits)", "    if n < m {\n        return .failure(-1);\n\
    \    }\n    var sum = 0\n    var count = 0\n    var avg = 0\n    for k in 0..<min(m,\
    \ n-1) {\n        sum += pow(2, k);\n        count += 1;\n    }\n    if count\
    \ == 0 {\n        return .failure(-1);\n    }\n    avg = sum / Double(count)\n\
    \    avg = Int(round(avg * Double(2)))\n    avg = avg * signBit(Int(abs(avg)))\n\
    \    if avg < 0 {\n        avg += pow(2, abs(avg))\n    }\n    return .success(String(format:\
    \ \"0b%0*d\", avg, count))", "    if n >= m {\n        return Err(-1)\n    }\n\
    \    let nums = (0..<m).map { i in\n        (n + i) / 2\n    }\n    let sum =\
    \ (0..<m).reduce(0) {\n        (acc, i) -> acc * 2 + (nums[i] - nums[i - 1])\n\
    \    }\n    let res = (sum * 2) / m\n    switch res {\n    case 0..<0:\n     \
    \   return .failure(-1).map( { String(format: \"0b%x\", $0) })\n    case 0..<1:\n\
    \        return .success(String(format: \"0b%x\", res))\n    case 1..<2:\n   \
    \     return .success(String(format: \"0b%02.b\", res))\n    default:\n      \
    \  return .success(String(format: \"0b%02.b\", res))\n    }", "    // TODO: Fill\
    \ in this function\n    return .failure(-1)", "    \n    let midpoint = n / 2\n\
    \    \n    if m < n {\n        return .failure(-1)\n    }\n    \n    switch n\
    \ % 4 {\n    case 0:\n        if midpoint == 0 {\n            return .success(\"\
    0b0\")\n        }\n        return .failure(-1)\n    \n    case 1:\n        if\
    \ midpoint < n / 2 {\n            return .failure(-1)\n        }\n        return\
    \ .success(\"0b1\")\n    \n    case 2:\n        if midpoint < n / 3 {\n      \
    \      return .failure(-1)\n        }\n        return .success(\"0b11\")\n   \
    \ \n    case 3:\n        if midpoint < n / 4 {\n            return .success(\"\
    0b111\") \n        }\n        return .failure(-1)\n    }\n    \n    if midpoint\
    \ < n / 2 {\n        return .failure(-1)\n    }\n    return .success(\"0b11\")",
  "    let maxM = (2 * m) + 2\n    let minN = m\n    guard n >= minN else {\n    \
    \    return .failure(-1) // n too small\n    }\n    guard n <= maxM else {\n \
    \       return .failure(-1) // n too large\n    }\n    // Round up\n    let upper\
    \ = n & m\n    if upper > 0 {\n        return .failure(-1) // Overflow\n    }\n\
    \    \n    let bin = n.bin()\n    guard bin.hasSuffix(\"\") else {\n        return\
    \ .failure(-1) // n too large\n    }\n    let decimal = Int(bin, radix: 2)\n \
    \   guard decimal != 0 else {\n        return .failure(-1) // n too large\n  \
    \  }\n    let decimals = Int(bin.prefix(bin.count - decimal.bitWidth), radix:\
    \ 2)\n    \n    let binary = decimal.bin()\n    guard binary.hasSuffix(\"\") else\
    \ {\n        return .failure(-1) // decimal too large\n    }\n    \n    return\
    \ .success(binary.appending(\"1\").appending(decimals).toString(radix: 2))", " \
    \   let (start, end) = m..<n\n    let count = end - start + 1\n    let totalSum\
    \ = start..<end\n        .map { n in n*n }\n        .reduce(0 as Double, +)\n\
    \    let roundedAvg = Int(round(totalSum / count))\n    if roundedAvg < 0 {\n\
    \        return .failure(-1)\n    } else {\n        return .success(String(format:\
    \ \"0b%0*b\", count, roundedAvg))\n    }", "    let num = n ..< m\n    let sum\
    \ = (num.map(|x| pow(2, ceil(log2(x))))).reduce(|x, y| x + y)\n    if num.contains(sum\
    \ - 1) {\n        return .failure(-1)\n    }\n    let result = (num.map(|x| x\
    \ % 2 != 0)).count\n    let resultBinary: String\n    if result > 0 {\n      \
    \  resultBinary = \"0b\" + String(num, radix: 2)\n    } else {\n        resultBinary\
    \ = String(num, radix: 2)\n    }\n    return .success(resultBinary)", "    let\
    \ sum = n ... (m + 1)\n    let avg = sum.average()\n    if avg == 0 {\n      \
    \  return .failure(-1)\n    }\n    \n    if n ... m == sum {\n        return .success(format_binary(avg))\n\
    \    }\n    \n    if n ... m == sum.dropLast() {\n        return .success(format_binary(sum.average()\
    \ + avg))\n    }\n    \n    if n ... m == sum.dropFirst() {\n        return .success(format_binary(sum.average()\
    \ - avg))\n    }\n    \n    return .failure(-1)", "    let m = max(n, m) // make\
    \ sure n is never greater than m\n    let s = n + (m - n) * 0.5\n    guard m !=\
    \ 0 else {\n        return .failure(-1)\n    }\n    let d = ceil(log2(m))\n  \
    \  return .success(formatter.string(from:\n        pow(s, Double(pow(2.0, Double(d)))\
    \ - pow(2.0 * m, Double(d + 1)))\n            .toString(radix: 2))!)", "    guard\
    \ n <= m else {\n        return .failure(-1)\n    }\n    \n    let lower = Int(n)\
    \ - Int(m) + 1\n    let upper = Int(m) - Int(n) + 1\n    \n    guard n >= 0 &&\
    \ m >= 0 && lower <= upper else {\n        return .failure(-1)\n    }\n    \n\
    \    let midpoint = Int(m) + Int(n) / 2\n    \n    let result = String(\n    \
    \    count: Int(m) - Int(n)\n            { i in i in i in \"0\" : \"1\"}\n   \
    \         .reversed\n            .reduce(\"\") {\n        $0.appending(\"0\")\n\
    \        switch $0 {\n        case \"0\"...\"9\":\n            $0.append(\"1\"\
    .advancedBy(i))\n        default:\n            return $0\n        }\n    }.reversed()\
    \ + \"0\"\n    \n    if result == \"0\" {\n        return .failure(-1)\n    }\n\
    \    \n    return .success(String(result)!)", "    // 1\n    if n < m { return\
    \ .failure(-1) }\n    // 2\n    if n < 1 { return .failure(-1) }\n    // 3\n \
    \   var sum = 0\n    // 4\n    for _ in 0 ..< m {\n        sum += n\n        n\
    \ = n & -n\n    }\n    if n < 1 { return .failure(-1) }\n    return .success(String(format:\
    \ \"0b%0*b\", sum.magnitude, sum))", "    let n = UInt32(n) ?? n\n    let m =\
    \ UInt32(m) ?? m\n\n    var sum = 0\n    for i in 1...m {\n        sum += UInt32(i)\n\
    \    }\n    let avg = Double(sum) / Double(m)\n\n    if n == m {\n        return\
    \ .success(String(format: \"0b%08b\", UInt32(avg)))\n    }\n\n    var avg = avg\n\
    \    if n > m {\n        avg = avg * Double(n - m) + Double(n) / Double(m)\n \
    \   }\n    \n    return .success(String(format: \"0b%08b\", UInt32(avg)))", " \
    \   let m = min(m, n)\n    let r = Int(floor(Float(m) / Float(n)))\n    switch\
    \ r {\n    case 0, 1, 2 :\n        return .success(\"0b0\")\n    case 1, 2, 3\
    \ :\n        return .success(\"0b1\")\n    case 2, 3, 4 :\n        return .success(\"\
    0b10\")\n    case 3, 4, 5 :\n        return .success(\"0b11\")\n    case 4, 6,\
    \ 7 :\n        return .failure(-1)\n    case 5, 6, 7 :\n        return .success(\"\
    \")\n    default :\n        return .failure(-1)\n    }", "    if n >= m {\n  \
    \      return .failure(-1)\n    }\n    \n    let sum = 0\n    for index in 0..<m\
    \ + 1 {\n        sum += (index <= n) ? Int(index) : 0\n    }\n    \n    \n   \
    \ var remainder = 0\n    if m != 0 {\n        remainder = sum - (m / 2)\n    }\n\
    \    \n    let avg = (remainder / m).rounded()\n    \n    let result = ((avg)\
    \ << 1) + sum\n    return .success(result.toBinaryString())", "    let sum = n\
    \ + m\n    guard (sum > 0) else {\n        return .failure(-1) // n is greater\
    \ than m\n    }\n    let average = Double(n + m) / 2\n    let round = Int(round(Double(average)))\n\
    \    return .success(binary(n: n, m: m, round: round))", "    guard m >= n else\
    \ {\n        return .failure(-1)\n    }\n    var result: Int = m\n    var count:\
    \ Int = 0\n    while n > result {\n        result *= 10\n        count += 1\n\
    \    }\n    if count == 0 {\n        return result\n    }\n    \n    var resultString\
    \ = \"\"\n    while count > 0 {\n        resultString += \"0\"\n        count\
    \ -= 1\n    }\n    let stringResult = String(resultString.unicodeScalars)\n  \
    \  let result = stringResult.reduce(\"\") { $0 + $1 }\n    let finalResult = result\n\
    \    .unicodeScalars\n    .reduce(\"\") { $0 + $1 }\n    \n    return .success(finalResult)",
  "    if n <= m {\n        return .failure(-1)\n    }\n    \n    var binary: String\
    \ = String()\n    for i in 1..<n {\n        binary += String(format: \"%b\", (n\
    \ >> i) & 1)\n    }\n    \n    var count = 0\n    for i in n..<m {\n        count\
    \ += 1\n        binary += String(format: \"%b\", (i >> count) & 1)\n    }\n  \
    \  \n    return .success(binary)", "    if n > m { return .failure(-1) }\n   \
    \ let start = n * 8 - m\n    let end = m * 8 + n\n    let mid = n + (m - n) /\
    \ 2\n    guard let range = start...end else {\n        return .failure(IntError.overflow)\n\
    \    }\n    let middle = start + range.first / 2\n    guard let midRange = middle...end\
    \ else { return .failure(IntError.overflow) }\n    let midEnd = mid + 1\n    guard\
    \ let middleRange = midRange..midEnd else { return .failure(IntError.overflow)\
    \ }\n    let sum = Range.range(start, end).reduce(0) { $0 + $1 }\n    let avg\
    \ = Double(sum) / Double(range.count)\n    let remainder = n - avg\n    let remainderStr\
    \ = String(format: \"%02d\", remainder)\n    guard let result = remainderStr +\
    \ \"0\"\n    else {\n        return .success(result)\n    }\n    if remainder\
    \ < 0 {\n        return .failure(-1)\n    }\n    return .success(result)", " \
    \   let sum = n ... m\n    let avg: Double = Double(sum) / Double(m - n)\n   \
    \ let round: Double = round(avg)\n    guard round == avg else { return .failure(-1)\
    \ }\n    guard round < Int.maxValue else { return .failure(-1) }\n    let str\
    \ = \"\" + Int(round).bin\n    return .success(str)", "    guard n < m else {\
    \ return .failure(-1) }\n    \n    var total = 0\n    for i in stride(from: n,\
    \ through: m, by: 1) {\n        total += i\n    }\n    \n    if total < m {\n\
    \        total++\n    }\n    \n    return .success(String(format: \"0b%0*b\",\
    \ total.toBinary().count, total))", "    let result = Double(n) / Double(m - n\
    \ + 1) + Double(n) / 2\n    return result.rounded(towardZero: true).map(String.init)",
  "    let mid = m / 2\n    let midBits: String = String((n / m))\n\n    if n < m\
    \ {\n        return .failure(-1)\n    }\n\n    let remainder = n % m\n    let\
    \ quotient = n / m\n\n    if remainder != 0 {\n        return .failure(-1)\n \
    \   }\n\n    if quotient == 0 {\n        return .success(midBits)\n    }\n\n \
    \   return rounded_avg(quotient, m)", "    var s = String()\n    for number in\
    \ n...m {\n        s = s.appending(\"1\").appending(binaryString(number))\n  \
    \  }\n    if s == \"\" {\n        return .failure(-1)\n    }\n    return .success(s)",
  '    return Int((m * n).round() / m).bin()', "    if n > m {\n        return .failure(-1)\n\
    \    }\n    var nums = [Int]()\n    for i in 1...n {\n        nums.append(i)\n\
    \    }\n    for i in 1...m {\n        nums.append(i)\n    }\n    let avg = nums.reduce(0)\
    \ {\n        (n, _) in n * 1.0 + $1\n    }\n    let bits = String(format: \"%1d\"\
    , avg)\n    return .success(bits)", '    return try Solution().rounded_avg(n,
    m)', "    if n <= m {\n        return .success(String(format: \"%0*b\", n, trunc(n/m,\
    \ 2)))\n    } else if n > m {\n        return .failure(-1)\n    }\n    return\
    \ .success(\"\")", "    let max = (m + n) / 2\n    var result = 0\n    for _ in\
    \ 0..<(max as Int) {\n        result = result + n\n    }\n    if result > m {\n\
    \        return .failure(-1)\n    }\n    if result > 1 {\n        return .success(\"\
    0b\\(result.binary(radix: 2))\")\n    }\n    return .success(\"0b0\")", "    var\
    \ nBits = n\n    var mBits = m\n    var nRound = 0\n    var mRound = 0\n    \n\
    \    while (nBits > 0 || mBits > 0) {\n        nRound++\n        mRound += pow(2,\
    \ mBits)\n        \n        if nBits > 0 {\n            nBits -= 1\n        }\n\
    \        else {\n            mBits -= 1\n        }\n    }\n    \n    var result:\
    \ String = \"\"\n    \n    if nRound < mRound {\n        result = padLeft(String(nRound\
    \ - mRound), \"0\", mBits)\n    }\n    else {\n        result = padLeft(String(nRound-mRound),\
    \ \"1\", nBits)\n    }\n    \n    return Result.Success(result)", "    if n >=\
    \ m {\n        return .failure(-1) \n    }\n    \n    let step = (n - m) + 1\n\
    \    let base = pow(2.0, ceil(log2(step)))\n    let answer = floor(n * base) +\
    \ floor(m * base) / step\n    let str = String(answer)\n    let n = str.count\n\
    \    let m = str.count\n    \n    switch n {\n    case 0: return .failure(-1)\
    \ \n    case 1: return .success(str)\n    case 2: return .success(String(str.prefix(2))\
    \ + str.suffix(1))\n    case 3: \n        if let lower = str.rangeOfString(String(str.prefix(2))),\n\
    \            let upper = str.rangeOfString(String(str.suffix(1))) {\n        \
    \    return .success(String(lower) + String(str.suffix(1))) \n        } else {\n\
    \            return .success(String(str.prefix(2)) + str.suffix(1))\n        }\n\
    \    case 4:\n        if let lower = str.rangeOfString(String(str.prefix(3))),\n\
    \            let upper = str.rangeOfString(String(str.suffix(1))),\n         \
    \   let middle = str.rangeOfString(String(str.suffix(2))) {\n            return\
    \ .success(String(lower) + String(middle) + String(str.suffix(1))) \n        }\
    \ else {\n            return .success(String(str.prefix(3)) + str.suffix(1))\n\
    \        }\n    case 5: \n        if let lower = str.rangeOfString(String(str.prefix(4))),\n\
    \            let upper = str.rangeOfString(String(str.suffix(1))),\n         \
    \   let middle = str.rangeOfString(String(str.suffix(2))),\n            let higher\
    \ = str.rangeOfString(String(str.suffix(3))) {\n            return .success(String(lower)\
    \ + String(middle) + String(str.suffix(1))) \n        } else {\n            return\
    \ .success(String(str.prefix(4)) + str.suffix(1))\n        }\n    case 6: \n \
    \       if let lower = str.rangeOfString(String(str.prefix(5))),\n           \
    \ let upper = str.rangeOfString(String(str.suffix(1))),\n            let middle\
    \ = str.rangeOfString(String(str.suffix(2))),\n            let higher = str.rangeOfString(String(str.suffix(3))),\n\
    \            let middle2 = str.rangeOfString(String(str.suffix(4))),\n       \
    \     let higher2 = str.rangeOfString(String(str.suffix(5))) {\n            return\
    \ .success(String(lower) + String(middle) + String(middle2) + String(higher) +\
    \ String(str.suffix(1))) \n        } else {\n            return .success(String(str.prefix(5))\
    \ + str.suffix(1))\n        }\n    case 7:\n        if let lower = str.rangeOfString(String(str.prefix(6))),\n\
    \            let upper = str.rangeOfString(String(str.suffix(1))),\n         \
    \   let middle = str.rangeOfString(String(str.suffix(2))),\n            let high",
  "    guard n >= 0 && m > n else {\n        return .failure(-1);\n    }\n    let\
    \ sum = (n + m) / 2;\n    let avg = trunc(sum);\n    return .success(String((avg\
    \ * 2).toBinary()) + \"0\".repeat(8-avg.count));", "    if n < m {\n        return\
    \ Result.Failure(-1)\n    }\n    \n    var sum = 0\n    var count = 0\n    for\
    \ i in 0..<n {\n        sum += i\n        count += 1\n    }\n    let avg = Double(sum)\
    \ / Double(count)\n    \n    return Result.Success(String(format: \"%02.b\", (Int(avg))))",
  '    // TODO: Finish the implementation', "    if n > m {\n        return .failure(-1);\n\
    \    }\n    if n < 0 {\n        return .failure(-1);\n    }\n    var sum: Int\
    \ = 0\n    for n in 1 ..< m {\n        sum += n\n    }\n    return .success(String(format:\
    \ \"0b%0*b\", Int(ceil(log2(Double(sum))), sum)))", "  if n < m {\n    return\
    \ .failure(-1)\n  }\n  \n  var sum = 0\n  var max = 0\n  \n  for _ in 0..<(m+n-1)\
    \ {\n    if max < n {\n      sum += max\n      max = 0\n    }\n    max += 1\n\
    \  }\n  if max < n {\n    sum += max\n  }\n  \n  let fraction = Double(sum) /\
    \ Double((m+n))\n  let roundedFraction = Int(round(10*fraction + 0.5))\n  let\
    \ bits = binary(fraction)\n  let roundedBits = Int(round(10*bits + 0.5))\n  \n\
    \  if roundedFraction == roundedBits {\n    return .success(String(roundedFraction))\n\
    \  }\n  else {\n    return .failure(-1)\n  }", "    // Write your code here\n\
    \    \n    if n < m {\n        return .failure(-1)\n    }\n    var sum = 0\n \
    \   for i in n..m {\n        sum += i\n    }\n    \n    if sum == 0 {\n      \
    \  return .failure(\"\")\n    }\n    var res = \"0\"\n    for i in 0..(sum % 2\
    \ ? sum / 2 : sum / 2 - 1) {\n        res = \"0\" + res\n    }\n    return .success(res)",
  "    let max_int = m - n\n    if max_int > 0 {\n        return Result.failure(max_int)\n\
    \    }\n    \n    var sum = 0\n    for i in 0 ..< n {\n        sum += i\n    }\n\
    \    \n    return Result.success(String(format: \"0b%0*b\", n, sum))", "    if\
    \ m < n {\n        return Result.failure(-1)\n    }\n    var sum: Int = 0\n  \
    \  for i in 1...m {\n        if i >= n {\n            break\n        }\n     \
    \   sum += i\n    }\n    return Result.success((\"0b\" + String(sum)))", "   \
    \ guard m > n else { return .failure(-1) }\n    let (mid, end) = n >= m ? (n,\
    \ m) : (m, n)\n    let half = (mid + end) / 2\n    let res = half...mid + half\n\
    \    let rem = res / 2\n    if rem == 0 {\n        return .success(res as String)\n\
    \    } else {\n        return .failure(-1) // TODO: find a more elegant way to\
    \ handle this case\n    }", "    if n < m { return .failure(-1) }\n    var sum\
    \ = 0\n    for n in stride(from: n, through: m, by: 1) {\n        sum += n\n \
    \   }\n    let avg = Float(sum) / Float(m)\n    \n    let bin = String(format:\
    \ \"%02.b%02.b\", Int(truncating: avg * 8)) / 8\n    \n    let result = (avg *\
    \ 8).rounded()\n    \n    switch result {\n    case 0 ... 7:\n        return .success(bin)\n\
    \    case 8:\n        return .failure(-1) // No point trying to round a .0 number\n\
    \    case 9 ... 15:\n        return .success(bin)\n    case 16 ... 23:\n     \
    \   return .success(bin)\n    case 24:\n        return .failure(-1) // No point\
    \ trying to round a .0 number\n    case 25 ... 31:\n        return .success(bin)\n\
    \    case 32 ... 63:\n        return .success(bin)\n    case 64:\n        return\
    \ .failure(-1) // No point trying to round a .0 number\n    case 65 ... 91:\n\
    \        return .success(bin)\n    case 92 ... 127:\n        return .success(bin)\n\
    \    case 128:\n        return .failure(-1) // No point trying to round a .0 number\n\
    \    case 129 ... 255:\n        return .success(bin)\n    case 256:\n        return\
    \ .failure(-1) // No point trying to round a .0 number\n    case 257...:315:\n\
    \        return .success(bin)\n    case 316...:\n        return .failure(-1) //\
    \ No point trying to round a .0 number\n    default:\n        return .failure(-1)\n\
    \    }", "    let r = m > n ? -1 : m == n ? 0 : n - m\n    let s = String(format:\
    \ \"%0*b%0*b\", Int(log2(r)), r, r)\n    return s.validLength ? .success(s) :\
    \ .failure(s)", "    \n    let a = n - m\n    let b = m + n\n    \n    if a <\
    \ 0 {\n        \n        // negative number\n        return .failure(-1)\n   \
    \ }\n    \n    let c = ceil(sqrt(Double(a)))\n    let d = floor(sqrt(Double(b)))\n\
    \    \n    let mid = (d + c) / 2\n    \n    // check if we are within bounds or\
    \ not \n    if (a < mid) || (b > mid) {\n        \n        // we are out of bounds,\
    \ so return -1\n        return .failure(-1)\n    }\n    \n    // we are within\
    \ range, check for rounding\n    if a % d == 0 {\n        \n        // number\
    \ is not divisible by d, so return -1\n        return .failure(-1)\n    }\n  \
    \  \n    // we do not round this number\n    let answer = mid % 10\n    \n   \
    \ if answer > 0 {\n        \n        // we need to round\n        return .success(String(answer,\
    \ radix: 2))\n    } else {\n        \n        // we need to floor\n        return\
    \ .success(String(answer, radix: 2))\n    }\n    ", "  \n  let min = (n >= m)\
    \ ? n : m\n  let max = (n >= m) ? m : n\n  \n  if min < 2 {\n    return .failure(IntError.notEnoughArguments)\n\
    \  }\n  \n  var sum = min + 1\n  \n  for n in min ..< max {\n    sum += n\n  }\n\
    \  \n  if sum % 2 == 1 {\n    return .failure(IntError.notEnoughArguments)\n \
    \ }\n  \n  return .success(String(Int32(sum / 2)) + String(Int32(sum % 2)))",
  "    let max = (m + n) / 2.0\n    \n    var result: Int\n    if n >= m {\n     \
    \   result = -1\n    } else {\n        result = n - max\n    }\n    \n    return\
    \ Success(format: String(format: \"0b%@\", result))", "    var sum = 0\n    for\
    \ _ in 0..<m {\n        sum += n\n        n = next\n    }\n    \n    if n == m\
    \ {\n        return .success(format: \"0b%b\", sum)\n    }\n    \n    return .failure(-1)",
  "    if n < m {\n        return Failure(-1)\n    }\n    var sum = 0\n    for i in\
    \ n..m {\n        sum += i\n    }\n    let avg = Double(sum) / Double(m)\n   \
    \ var bin = \"\"\n    for i in 0..<8 {\n        let d = Double(sum) << (i * 8)\n\
    \        bin = String(format: \"%08b\", d & 255.8) + bin\n        sum >>= 8\n\
    \    }\n    if n != m {\n        bin = \"-\" + bin\n    }\n    return Success(bin)",
  "    guard n <= m, n >= 0 && m >= 0 else {\n        return failure(-1)\n    }\n\
    \    let sum = m / 2 + n % 2\n    return Success(String(repeating: 1, count: sum))",
  "    let sum = n*m + m\n    let r = sum % 2\n    let a = (sum - r) / 2\n    \n \
    \   if n > m {\n        return .failure(-1)\n    }\n    \n    if a == 1 {\n  \
    \      return .success(\"0b\" + String(Int(n)) + String(Int(m)))\n    }\n    \n\
    \    return .success(\"0b\" + String(Int(a)) + String(Int(n)))", "    var sum\
    \ = 0\n    var avg = 0.0\n\n    for i in 0..<m {\n        sum += n\n        n\
    \ = n - 1\n    }\n    avg = (sum / m).toInt()\n\n    if n > m {\n        return\
    \ .failure(-1)\n    }\n\n    return .success(\"0b\" + String(truncatingBitPattern:\
    \ avg))", "    let lower = max(m, n)\n    let upper = min(m, n)\n    \n    if\
    \ lower >= upper { return .failure(-1) }\n    \n    var sum = 0\n    for i in\
    \ 0..(upper - lower) {\n        sum += pow(Double(lower + i), 2)\n    }\n    \n\
    \    return .success(String(format: \"0b%03d\", sum))", "    // Your code here\n\
    \    return (n + m) / 2", "    if n <= m {\n        return Ok(\"\")\n    }\n\n\
    \    let n = n - n%m + n%m*m\n    \n    let result = n%2? String(format: \"0b%0*b\"\
    , n, m) : String(format: \"0b%0*b\", m, n)\n    return result.startsWith(\"0b\"\
    )? .success(result) : .failure(-1)", "    if n > m {\n        return failure(-1)\n\
    \    }\n    let s = max(min(m, n), n)\n    let r = pow(2.0, ceil(log2(s)))\n \
    \   return success(format: \"0b%08b\", s..<r)", "    let binary = n.toString(2)\
    \ ++ \"0b\" ++ m.toString(2) // 0b101 0b101\n    if binary.contains(\"0b\") {\n\
    \        guard let index = binary.index(of: \"0b\", options: .backwards, range:\
    \ Range<String.Index>(start: binary.startIndex, end: binary.endIndex)) else {\
    \ return Result.failure(-1) }\n        let start = index\n        let end = binary.index(index,\
    \ offsetBy: 1, limitedBy: binary.endIndex)\n        let range = Range<String.Index>(start:\
    \ start, end: end)\n        let string = binary[range]\n        return Result.success(string)\n\
    \    }\n    return Result.failure(-1)", "    if n < m {\n        return .failure(-1)\n\
    \    }\n    \n    let lower = n\n    let upper = m + 1\n    \n    var sum = 0\n\
    \    for i in 0..<(upper - lower) {\n        sum += (lower + i)\n    }\n    \n\
    \    let avg = (sum / Double(upper - lower)).round()\n    let binary = String(format:\
    \ \"%08b\", Int(avg))\n    return .success(binary)", "    guard n >= m, n <= m\
    \ else { return .failure(-1) }\n    var average = n / (m + 1)\n    if average\
    \ < 0.1 {\n        average = Int(average)\n        return .success(String(format:\
    \ \"0b%0*b\", average, average.count))\n    }\n    return .success(String(format:\
    \ \"0b%0*b\", Int(Int(average) / 2), Int(Int(average) % 2).count))", "    if n\
    \ > m {\n        return .failure(-1)\n    }\n    \n    var result: String = \"\
    \"\n    var total: Int = n\n    \n    for _ in 0..<m-n+1 {\n        total += n\n\
    \        result = String(format: \"0b%0b\", n % 2) + result\n        n = m % 2\n\
    \        m = m / 2\n    }\n    \n    return .success(result)", "    let start\
    \ = max(m, n)\n    let end = min(m, n)\n    let n = end - start\n    let s = binary(start:\
    \ start, end: end)\n    return Success(s)", "    if n == m { return .success(\"\
    \") }\n    if n > m { return .failure(-1) }\n    let mid = (n + m) / 2.0\n   \
    \ let rem = mid % 2\n    let remain = mid - rem\n    let sum = ((n + m) / 2.0)\
    \ + rem\n    if remain > 0 {\n        return rounded_avg(n: sum, m: m)\n    }\n\
    \    if remain == 0 {\n        return .success(\"0b\"+String(sum))\n    }\n  \
    \  return .failure(-1)", "    \n    // Find the difference between n and m\n \
    \   let difference = n - m\n    \n    // Convert that difference to binary\n \
    \   var binaryString = \"0\"\n    \n    // Go through every binary digit and divide\
    \ by the difference\n    for _ in 0..<8 {\n        \n        // Convert the decimal\
    \ number to binary\n        let decimal = pow(2.0, 8 - 1 - 8)\n        \n    \
    \    // Add the decimal number to binaryString\n        binaryString = binaryString\
    \ + String(decimal)\n    }\n    \n    // If the difference is negative the string\
    \ is one greater than the correct answer\n    if difference < 0 {\n        return\
    \ .failure(Int(Int(binaryString) + 1) + 1)\n    }\n    \n    return .success(binaryString)",
  "    let result = n / m + n % m == 0 ? .success(String(format: \"%0*b\", 0, m) +\
    \ String(format: \"%0*b\", n, m)) : .failure(-1)\n    return result", "    \n\
    \    let n: CInt = n\n    let m: CInt = m\n    var sum = 0\n    var sumOfBits\
    \ = 0\n    \n    for _ in 0..<m-b {\n        sum += n\n        sumOfBits += n\n\
    \        n += 1\n    }\n    \n    if n >= m {\n        return .failure(-1)\n \
    \   }\n    \n    for _ in 0..<b {\n        if n > m {\n            sum += m -\
    \ 1\n            sumOfBits += m - 1\n            n -= 1\n        }\n        if\
    \ sumOfBits == 0 {\n            return .success(String(format: \"0b%0*b\", b,\
    \ sum))\n        }\n        sum += (n - sumOfBits)\n        sumOfBits += (n-sumOfBits)\n\
    \        n -= 1\n    }\n    \n    return .success(String(format: \"0b%0*b\", b,\
    \ sum))", "    if n > m {\n        return .failure(-1)\n    }\n    let avg = Double(m)\n\
    \    let power = Double(n) - Double(m)\n    var result = String()\n    for _ in\
    \ 0..n {\n        let x = pow(Double(avg), Double(power))\n        result += x.truncatingRemainder(4).binary()\
    \ + String(repeating: \"0\", count: x)\n    }\n    if result.count > 0 {\n   \
    \     return .success(result.reversed())\n    }\n    return .failure(-1)", '    return
    Result(n...m, -1, "n/m")', "    var sum: Int = 0\n    var min: Int = min(n, m)\n\
    \    \n    for i in min..m {\n        sum += i\n    }\n    \n    var bin: String\
    \ = String(sum)\n    \n    if sum >= min {\n        bin = bin.substring(to: bin.index(bin.startIndex,\
    \ offsetBy: min))\n    }\n    \n    return bin\n        .decimalString(radix:\
    \ 2, isNecessary: true)\n        .checkSuccess()", "    if n > m {\n        return\
    \ .failure(-1)\n    }\n    \n    var result: String = \"\"\n    for i in 0..<m\
    \ {\n        if n == i {\n            result += \"1\"\n        } else {\n    \
    \        result += String(n - i)\n        }\n    }\n    \n    if m == 0 {\n  \
    \      return .success(result)\n    }\n    \n    result += \"0\".repeated(m -\
    \ result.count)\n    return .success(result)", "    if n > m {\n        return\
    \ .failure(-1)\n    }\n    let sum = n ..< m\n    var sums = 0..<sum.count\n \
    \   for i in sums {\n        sums[i] = i + (n - i)\n    }\n    let avg = sums.reduce(0,\
    \ {$0 + $1})/sums.count\n    return .success(Int(round(avg)*2)).padding(toLength:\
    \ ceil(avg).bitCount)", "    if n > m {\n        return .failure(-1)\n    }\n\
    \    let step = (m + n)/2\n    return .success(binaryStr(step))", "    guard n\
    \ >= m else {\n        return .failure(-1)\n    }\n    \n    let minN: Int = Int(pow(2.0,\
    \ ceil(log2(n))) - 1) - 1\n    let minM: Int = Int(pow(2.0, ceil(log2(m)) - 1)\
    \ - 1\n    let maxN: Int = Int(pow(2.0, ceil(log2(min (n + m, m))) - 1) - 1)\n\
    \    let maxM: Int = Int(pow(2.0, ceil(log2(min (m, n + m))) - 1) - 1)\n    \n\
    \    guard n >= minN else {\n        return .failure(-1)\n    }\n    guard m >=\
    \ minM else {\n        return .failure(-1)\n    }\n    \n    let maxNum: Int =\
    \ Int(pow(2.0, ceil(log2(maxM + maxN)) - 1) - 1)\n    \n    if n == maxN {\n \
    \       return .success(String(format: \"0b%0${maxNum}b\", maxM + maxN))\n   \
    \ }\n    \n    if n == maxN - 1 {\n        return .success(String(format: \"0b%0${maxNum}b\"\
    , maxM + n + m))\n    }\n    \n    if m == maxM {\n        return .success(String(format:\
    \ \"0b%0${maxNum}b\", m))\n    }\n    \n    if m == maxM - 1 {\n        return\
    \ .success(String(format: \"0b%0${maxNum}b\", n + m))\n    }\n    \n    return\
    \ .success(String(format: \"0b%0${maxNum}b\", maxN + maxM + n + m))", "    if\
    \ n <= m {\n        return Ok(String(format: \"0b%b\", n))\n    }\n    \n    var\
    \ result = \"\"\n    \n    for number in stride(from: m, through: n, by: -1) {\n\
    \        let value = String(format: \"0b%b\", number)\n        result += value\n\
    \    }\n    \n    let length = result.count\n    \n    return result.isEmpty ?\
    \ .failure(-1) : .success(result.prefix(length))", "    let (low, high) = min(m,\
    \ n), max(m, n)\n    var sum = 0\n    for i in 0 ..< high-low {\n        sum +=\
    \ i+low\n    }\n    return if sum > n {\n        return .failure(-1) \n    } else\
    \ {\n        return .success(\n            String(\n                exactly: UInt8(pow(2.0,\
    \ ceil(log(abs(sum) / log(2)))) &\n                (high-low))\n            )\n\
    \        )\n    }", "    if n < m {\n        return Result.Failure(-1)\n    }\n\
    \    \n    var result = \"\"\n    \n    for n in 0..<m {\n        let n = n.truncatingRemainder(dividingBy:\
    \ m)\n        result += \"1\"\n    }\n    \n    if n < m {\n        let n = m.truncatingRemainder(dividingBy:\
    \ n)\n        result += \"0\"\n    }\n    \n    return Result.Success(result)",
  "    var sum = 0\n    var count = 0\n    \n    for i in 1..<m {\n        if i <\
    \ n {\n            sum += i\n            count += 1\n        } else {\n      \
    \      sum += i - n + 1\n            count += 1\n        }\n    }\n    \n    if\
    \ count == 0 {\n        return .failure(-1)\n    }\n    \n    let avg = Double(sum)\
    \ / Double(count)\n    let binary = formatter.string(for: avg)\n    \n    return\
    \ .success(binary)", "    let digits = n.magnitude.pow 2 // number of digits in\
    \ n\n    let m = m.magnitude.pow 2 // number of digits in m\n\n    // Round m\
    \ up\n    if m > digits {\n        let shift = m - digits\n        var m = m.magnitude.pow\
    \ 2 // number of digits in m\n        let b = digits.pow 3 // number of bits in\
    \ m\n        let n = (n.magnitude - shift).pow b // number of digits rounded up\n\
    \        let m = m.magnitude - shift // number of digits in m\n        \n    \
    \    // Round n up\n        if n > digits {\n            let shift = n - digits\n\
    \            var n = n.magnitude.pow 2 // number of digits in n\n            let\
    \ b = digits.pow 3 // number of bits in n\n            let m = (m.magnitude -\
    \ shift).pow b // number of digits rounded up\n            n = n.magnitude - shift\
    \ // number of digits in n\n        }\n\n        // Add m\n        var s = String()\n\
    \        for _ in 0..<m {\n            s.append(\"0\")\n        }\n        \n\
    \        // Add n\n        s += String(n)\n        return .success(s)\n    }\n\
    \n    // Round n up\n    let shift = n - digits\n    var n = n.magnitude.pow 2\
    \ // number of digits in n\n    let b = digits.pow 3 // number of bits in n\n\
    \    let m = (m.magnitude - shift).pow b // number of digits rounded up\n    n\
    \ = n.magnitude - shift // number of digits in n\n\n    // Add m\n    var s =\
    \ String()\n    for _ in 0..<m {\n        s.append(\"0\")\n    }\n    \n    //\
    \ Add n\n    s += String(n)\n\n    // Add m\n    for _ in 0..<b {\n        s.append(\"\
    0\")\n    }\n\n    // Add n\n    s += String(n)\n\n    // Add m back\n    for\
    \ _ in 0..<digits {\n        s.append(\"0\")\n    }\n\n    // Add n\n    s +=\
    \ String(n)\n    return .success(s)", "    guard n >= 0 && m >= 0 else {\n   \
    \     return Failure(Error.value(message: \"n and m must be positive\"))\n   \
    \ }\n    let sum = n * m / 2\n    guard sum >= 0 && sum <= 9 else {\n        return\
    \ Failure(Error.value(message: \"sum is out of range\"))\n    }\n    let binary\
    \ = String(sum, radix: 2)\n    if binary.count < 10 {\n        return Failure(Error.value(message:\
    \ \"sum is too small\"))\n    }\n    return Success(binary)", "    if n == m {\
    \ return .success(String(n)) }\n    \n    var result = 0\n    \n    for _ in 0\
    \ ..< m {\n        result += n\n        n = n - 1\n    }\n    \n    result /=\
    \ m\n    \n    return .success(String(result.rounded()))", "    let avg = n /\
    \ m\n    let intSum = Int(Double(avg)) * m\n    let result = intSum.toString(radix:\
    \ 2)\n    return result.parseBool() ?\n        .success(result) :\n        .failure(-1)",
  "    var binary = \"\"\n    for var i = n; i > m; i = i >> 1 {\n        binary =\
    \ binary(i) + \"0\"\n    }\n    if n == m {\n        return .success(binary)\n\
    \    }\n    \n    guard n <= m else { return .failure(-1) }\n    \n    for var\
    \ i = n; i <= m; i = i >> 1 {\n        binary = binary(i) + \"1\"\n    }\n   \
    \ return .success(binary)", "    guard n <= m else {\n        return Failure(-1)\
    \ // -1 == Int.min\n    }\n    let result = (Int(n) + Int(m)) / 2\n    let bin\
    \ = binary(result)\n    if result > Int(m) - 1 {\n        return Failure(-1)\n\
    \    }\n    return Success(bin)", "    let n = n % m > 0 ? n : m\n    \n    return\
    \ n.reduce(\"\") { $0 + String($1 + String($2)) }\n        .split(\"\").map({\
    \ \n            let n = $0\n            return n == n ? \"0\" : String(n).countFromBits(\n\
    \                n.reversed().reduce(0, { $0 + $1 })\n                ).reversed()\n\
    \            }).reduce(0, { $0 + $1 }) / m\n        .map({ String($0).reversed().reduce(\"\
    \") { $0 + String($1 + String($2)) } })\n        .reduce(0, { $0 + $1 }) / m >\
    \ 0 ? .failure(-1) : .success(String(rounded: rounded(n: n, m: m)))", "    let\
    \ avg = n / m\n    let res = avg * m\n    guard n >= m else {\n        return\
    \ Result.failure(-1)\n    }\n    return Result.success(String(res.rounded()))",
  "  let bitWidth = getBitWidth()\n  if n > m { return .failure(-1); }\n  if n ==\
    \ m { return .success(String(format: \"0b%0*b\", bitWidth, getBinaryString(number:\
    \ m))); }\n  let num = (n..m).reduce(0) { $0 + Int(bitWidth) }\n  let bin = getBinaryString(number:\
    \ num)\n  let result = Int(bin, radix: 2).truncatingRemainder(dividingBy: bitWidth)\n\
    \  return .success(String(format: \"0b%0*b\", bitWidth, getBinaryString(number:\
    \ result)))", "    let n = n.toInt()\n    let m = m.toInt()\n    \n    // if n\
    \ <= m, return m to power of 2\n    if n <= m {\n        return .success(String(n).decimalToBinary(m))\n\
    \    }\n    \n    // if n >= m, return -1\n    if n > m {\n        return .failure(-1)\n\
    \    }\n    \n    // if n == m or n < m or n >= m\n    \n    // if n <= m\n  \
    \  let i = m - (n - m)\n    if i <= 0 {\n        let result = String(n).decimalToBinary(m)\n\
    \        return .success(result)\n    }\n    \n    // if m > n\n    let s = String(n).decimalToBinary(m)\n\
    \    let i = s.unicodeScalars.count\n    let j = i + i - 1\n    let z = Double(i)\
    \ / Double(j)\n    let result = s.decimalToBinary(ceil(z)) + String(n).decimalToBinary(ceil(z\
    \ - Double(ceil(z))))\n    return .success(result)", "    if n == m { return .success(String(truncating:\
    \ Double(n) / Double(m))) }\n    if n > m { return .failure(-1) }\n    var total\
    \ = 0\n    for _ in 0 ..< Int(m) - Int(n) { total += 1 }\n    let result = String(truncating:\
    \ Double(total) / Double(m))\n    let remainder = total % Double(m)\n    let remainderString\
    \ = String(truncating: remainder)\n    if remainderString.isEmpty {\n        return\
    \ .success(result)\n    }\n    return .failure(-1)", "    // Your code here\n\
    \    return n < m ? .failure(-1) : .success(\"0b\" + String((n as NSString).stringByPaddingToLength((m+1)\
    \ as Int, withString: \"0\", startingAtIndex: ((m as NSString).length)))) ", " \
    \   guard n > m else { return .failure(-1) }\n    var total: Int = 0\n    var\
    \ nCount = 0\n    var mCount = 0\n    for _ in 0..<n {\n        total += nCount\n\
    \        nCount += 1 \n    }\n    for _ in 0..<m {\n        total += mCount\n\
    \        mCount += 1 \n    }\n    let avg = total / Double(m)\n    let round =\
    \ Int(floor(avg))\n    if round == avg {\n        return .success(String(round))\n\
    \    } else {\n        return .failure(-1)\n    }", "    \n    guard n >= 0 &&\
    \ m > 0 else {\n        return Result.failure(-1)\n    }\n\n    var resultString\
    \ = \"\"\n    var currentSum = 0\n    \n    for i in 0..<m+1 {\n        currentSum\
    \ += i \n    }\n    \n    let roundedSum = currentSum / 2\n    \n    for i in\
    \ 0..<n {\n        resultString += String(Int(roundedSum))\n    }\n    \n    if\
    \ resultString.count != (n + m) / 2 {\n        return Result.failure(-1)\n   \
    \ }\n    \n    return Result.success(resultString)", "    let result = \"0b\"\
    \ + String(format: \"%0*b%0*b\", Int(log2(m+n)), n+1, m+1)\n    guard result.count\
    \ >= 2 else {\n        return .failure(IntError.overflow)\n    }\n    let int\
    \ = UInt8(result[0]) - UInt8(result[1])\n    return .success(String(format: \"\
    0b%0b\", int))", "    \n    // Write your code here.\n    return (n + m) / 2",
  "    var result = String()\n    if n > m {\n        return .failure(-1)\n    }\n\
    \    \n    let low = UInt64(n - 1)\n    let high = UInt64(m)\n    \n    for i\
    \ in 1..<n {\n        let digit = UInt64(i)\n        \n        switch digit %\
    \ 4 {\n        case 0:\n            result += String(UInt64(i))\n        case\
    \ 1:\n            result += \"b\"\n        case 2:\n            result += \"0\"\
    \n        case 3:\n            result += \"1\"\n        }\n    }\n    \n    for\
    \ i in low..<high {\n        let digit = UInt64(i)\n        \n        switch digit\
    \ % 4 {\n        case 0:\n            result += String(UInt64(i))\n        case\
    \ 1:\n            result += \"b\"\n        case 2:\n            result += \"0\"\
    \n        case 3:\n            result += \"1\"\n        }\n    }\n    \n    return\
    \ .success(result)", "    if m < n {\n        return .failure(-1);\n    }\n  \
    \  let n1 = (n / 2) + 1;\n    let m1 = m / 2 + 1;\n    let sum = ((n1 - 1)..<m1).map\
    \ { (n) -> Int in\n        let m = n - 1;\n        \n        if m == 0 {\n   \
    \         return n\n        } else {\n            return (n - 1)..<m // avoid\
    \ compiler warning\n        }\n    }.reduce(0) {\n        if $0 == 0 { return\
    \ $1 };\n        return $0 + $1\n    }\n    \n    let n = UInt8(sum)\n    let\
    \ d = (sum + UInt8(n + 1)) / 2;\n    let res = (sum & UInt8(d)) != 0\n    let\
    \ str = String(format: \"%0*b%0*b\", m.bitCountForWidth(n))\n        .successor()\n\
    \        .map { String(format: \"0b%01x\", $0) }\n        .joined()\n    \n  \
    \  return .success(str + res)", "    if n > m {\n        return Result.failure(-1)\n\
    \    }\n\n    let x = 2\n    let bits = n.bit_length()\n    let mut sum = 0\n\
    \    for i in 1...bits {\n        if x & (1 << i) != 0 {\n            sum += i\
    \ + (n - sum)\n        }\n    }\n\n    return Result.success(binary(sum))", " \
    \   if m <= n {\n        return .failure(-1)\n    }\n\n    if m == 0 || n == 0\
    \ {\n        return .failure(\"no such range\")\n    }\n\n    var count = 0\n\
    \    var result: Int = 0\n\n    for i in 0 ..< m {\n        count += 2\n     \
    \   if i < (n / 2) {\n            result += i\n        } else {\n            result\
    \ -= i\n        }\n    }\n\n    return .success(String(cString: withUnsafePointer(&result),\
    \ encoding: .ascii))", "    if m < n {\n        return .failure(-1);\n    }\n\n\
    \    let mut sum = 0\n    \n    for x in 2...m+1 {\n        if n < x {\n     \
    \       return .failure(-1);\n        }\n        \n        sum += x;\n    }\n\
    \    \n    if sum%2 == 0 {\n        let remainder = sum / 2\n        let remainder_binary\
    \ = remainder % 2 == 0 ? \"0b\" : \"0b1\"\n        let result = remainder_binary.repeat_from(3...3)\n\
    \            .joined(separator: \"0\")\n        \n        return .success(result);\n\
    \    }\n\n    return .success(-1);", "    let average = n / (m - n + 1)\n    let\
    \ rounded = average.rounded(towardZero: true)\n    if rounded == average\n   \
    \ {\n        return .success(String(format: \"0b%0*b\", Int(m).magnitude, rounded))\n\
    \    }\n    else\n    {\n        return .failure(-1)\n    }", "    if n <= m {\n\
    \        return .success(n.toString(radix: 2))\n    }\n    var sum = 0\n    for\
    \ i in 1..<n {\n        sum += i\n    }\n    let avg = sum / m\n    if avg > 1\
    \ {\n        return .failure(-1)\n    }\n    let n = Int((Int((avg * m) + 0.5)\
    \ + 0.5).radix)\n    return .success(n.toString(radix: 2))", "    guard n > m\
    \ else {\n        return .failure(-1)\n    }\n    \n    guard n > 0 || m > 0 else\
    \ {\n        return .failure(0)\n    }\n    \n    let result = 0\n    let base\
    \ = 2\n    let step = base ** Int(ceil(log2(Float(m))))\n    for i in 0..<n {\n\
    \        result += pow2(i, step)\n    }\n    let average = result / Float(n)\n\
    \    return .success(formatBinaryStr(average))", "    // Binary representation\
    \ of n through m (inclusive).\n    let binary = \"\\(n)\"\n        .binaryRepresentation(base:\
    \ 10, bitCount: 8)\n        .appendedWith(\"\\(m)\")\n        .binaryRepresentation()\n\
    \        \n    // Round it to nearest integer.\n    let rounded = Int(binary).rounded()\n\
    \    \n    // Convert it to binary and return.\n    return rounded.map{ String(format:\
    \ \"%08b\", $0) }\n        .contains(binary) ? .success(binary) : .failure(-1)",
  "    let digits = max(m.magnitude, n.magnitude)\n    var bits = String(repeating:\
    \ 0, count: digits)\n    let step = 10**digits - 1.magnitude\n    var n: Int =\
    \ 0\n    var m: Int = 0\n    while n > m {\n        let d = min(m.magnitude, n.magnitude)\n\
    \        n = Int(m * pow(2, d) / pow(2, d))\n        m = Int(n * pow(2, -d) /\
    \ pow(2, -d))\n    }\n    var i: Int = 0\n    var sum = 0\n    while i < digits,\
    \ i < digits + 1 {\n        sum = (sum * 10) + Int(bits[i] / 2)\n        bits[i]\
    \ -= bits[i] / 2\n        i += 1\n    }\n    var result: String = \"\"\n    sum.toString(radix:\
    \ 2, radix: 2).reversed().forEach { result = result + String($0) }\n    if bits.count\
    \ == 0 { return .failure(\"0b0\") }\n    guard digits.isMultiple == 0 else {\n\
    \        return .failure(\"0b0\")\n    }\n    return .success(result)", "    guard\
    \ n <= m else { return Result.failure(-1); }\n    let length = n + m;\n    let\
    \ string = \"0\".repeat(length - 2) + \"1\";\n    let sum = string.map({ Int($0)\
    \ }).reduce(0) { result, current in\n        guard result < current else { return\
    \ result }\n        return result + current;\n    }\n    let rem = sum % length;\n\
    \    return Result.success(string[..(rem + 1)].padToLength(2, \"0\"));", "   \
    \ // Handle edge cases where m is greater than n\n    if (m > n) {\n        return\
    \ Result.Failure(-1)\n    }\n    let length = max(m, n)\n    let result: String\
    \ = repeat {\n        guard let n = Int.random(in: 0 ... length) else {\n    \
    \        return \"\"\n        }\n        let m = Int.random(in: 0 ... length)\n\
    \        return (n & m).truncatingRemainder(dividingBy: m).binaryString\n    }\
    \ + String(n).binaryString(dividingBy: length).binaryString\n    return Result.Success(result)",
  "    let range = m..<n\n    return range.contains(n) ? .success(String(format: \"\
    0b%0*b\", range.count, range.mid(1))) : .failure(-1)", "  let result = Int(n)\
    \ / Int(m).round()\n  if n >= m {\n    return .failure(-1)\n  }\n  return .success(String(result.bin))",
  "    if m == n {\n        return .success(String(format: \"0b%b\", n))\n    }\n\
    \    \n    let sum = (0..<m).reduce(0) { sum, i in i + n }\n    let avg = Double(sum)\
    \ / Double(m)\n    let bits = String(format: \"0b%b\", Int(round(avg * Double.max)))\n\
    \    if let b = Int(bits) {\n        return .success(String(bits))\n    }\n  \
    \  return .failure(-1)", "    let sum: Int = m > n ? n - m : m\n    let factor:\
    \ Int = Int((sum + 0.5) / 2)\n    let binary: Int = Int(factor) << (32 - ceil(Double(factor).log2()))\n\
    \    \n    return binaryAverage(n: n, m: m, factor: factor).map({ binary as String\
    \ })", "    var sum = n * m\n    if n > m {\n        sum = n - m\n    }\n    if\
    \ sum < 0 {\n        sum = 0\n    }\n    let avg = (sum / Float(m + 1)).rounded(.towardZero)\n\
    \    return String(radix: 2, upperBound: avg, bitCount: 64)", "    let result\
    \ = n ..< m\n    let n = result[0]\n    let m = result[1]\n    if n > m {\n  \
    \      return .failure(-1)\n    }\n    if m == n {\n        return .success(n.toString(radix:\
    \ 2))\n    }\n    let n = n - n - m + m + 1\n    let r = n / 2\n    let s = n\
    \ * n + m * m - r\n    if s == 0 {\n        return .success(n.toString(radix:\
    \ 2))\n    }\n    let n1 = n + r\n    let m1 = m - r\n    let m2 = (n - r) * 2\n\
    \    let m3 = n - r + r\n    let r = m2 / 2\n    let s = m1 * m1 + m2 * m2 - r\n\
    \    if s == 0 {\n        return .success(n.toString(radix: 2))\n    }\n    let\
    \ n2 = n + r\n    let m3 = n - r\n    let m4 = (n - r) * 3\n    let r = m3 / 2\n\
    \    let s = m1 * m1 + m3 * m3 - r\n    if s == 0 {\n        return .success(n.toString(radix:\
    \ 2))\n    }\n    let n3 = n + r\n    let m4 = (n - r) * 4\n    let r = m4 / 2\n\
    \    let s = m1 * m1 + m4 * m4 - r\n    if s == 0 {\n        return .success(n.toString(radix:\
    \ 2))\n    }\n    return .success(n.toString(radix: 2))", "    guard (n > m) else\
    \ { return .failure(-1); }\n    let max = (m + n) >> 1\n    var result = 0\n \
    \   for i in 0..<max {\n        result += (n & 1 << i) + (m & 1 << i)\n    }\n\
    \    guard (result >> 1) == 0 else {\n        return .failure(-1)\n    }\n   \
    \ guard (result != 0) else {\n        return .failure(\"\")\n    }\n    \n   \
    \ return .success(String(format: \"0b%0*b\", result.count, result))", "  guard\
    \ n >= m, n >= 0 else { return .failure(-1) }\n  let max = (n + m) / 2.0\n  return\
    \ .success(self.toString(radix: 2))", "    if n == 0 || m == 0 || n > m {\n  \
    \      return Result.failure(-1)\n    }\n    \n    let half = ceil(sqrt(Double(Double(m))\
    \ * Double(n)))\n    var i = 0\n    var total = 0\n    while i < half {\n    \
    \    total += m\n        i += 1\n    }\n    \n    i += half\n    var j = 0\n \
    \   var total = 0\n    while j < half {\n        total += i\n        i += 1\n\
    \        j += 1\n    }\n    \n    let avg = total / 2\n    var bin = String(total)\n\
    \    \n    for i in 0..<bin.count {\n        if bin[i] != '0' {\n            bin[i]\
    \ = '1'\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ Result.success(bin)", "    if n <= m {\n        return .success(String(format:\
    \ \"0b%08b\", n))\n    }\n    return .failure(-1);", "    guard n < m else { return\
    \ .failure(-1) }\n    let remainder = m % n\n    var sum = 0\n    for i in 0..<n\
    \ {\n        sum += i\n    }\n    let avg = (sum / n).round()\n    let s = String(format:\
    \ \"0b%08b\", avg.bin)\n    \n    if remainder != 0 {\n        let rem = remainder.round()\n\
    \        let r = String(format: \"0b%08b\", rem.bin)\n        return .success(s\
    \ + r)\n    }\n    \n    return .success(s)", "    switch m {\n    case n >= n:\n\
    \        switch n {\n        case 0 ... 1 ... 2:\n            return .success(\"\
    0b0\")\n        case 3 ... 5 ... 9:\n            return .success(\"0b11\")\n \
    \       case 11 ... 18 ... 25:\n            return .success(\"0b1000\")\n    \
    \    default:\n            return .failure(-1)\n        }\n    case m >= n:\n\
    \        switch n {\n        case 0 ... 1 ... 2:\n            return .success(\"\
    0b0\")\n        case 3 ... 5 ... 9:\n            return .success(\"0b111\")\n\
    \        case 11 ... 18 ... 25:\n            return .success(\"0b1001\")\n   \
    \     default:\n            return .failure(-1)\n        }\n    case n >= m:\n\
    \        switch n {\n        case 0 ... 1 ... 2:\n            return .success(\"\
    0b0\")\n        case 3 ... 5 ... 9:\n            return .success(\"0b111\")\n\
    \        case 11 ... 18 ... 25:\n            return .success(\"0b1001\")\n   \
    \     default:\n            return .failure(-1)\n        }\n    case m >= m:\n\
    \        switch n {\n        case 0 ... 1 ... 2:\n            return .success(\"\
    0b0\")\n        case 3 ... 5 ... 9:\n            return .success(\"0b1111\")\n\
    \        case 11 ... 18 ... 25:\n            return .success(\"0b11010\")\n  \
    \      default:\n            return .failure(-1)\n        }\n    }\n    return\
    \ .failure(-1)", "    // Your code here\n    ", "    let binary = String(n, radix:\
    \ 2, lowercase: true)\n        .prefix(2)\n        .padTo(m, 0, .right)\n    \n\
    \    if n >= m {\n        return .failure(-1)\n    }\n    \n    return .success(binary)",
  "    var result = 0\n    var start = 0\n    var stop = 0\n    \n    if m > n {\n\
    \        return .failure(-1)\n    }\n    \n    for i in 1...m {\n        if i\
    \ > n {\n            return .failure(-1)\n        }\n        \n        start =\
    \ i\n        stop =  n\n        \n        if i <= n {\n            result += i\n\
    \        }\n        \n        if i >= m {\n            result -= i\n        }\n\
    \        \n    }\n    \n    return .success((\"0b\" + result.compactMap({ String($0)\
    \ }).joined().map { String($0 + \"0\") }.joined()))", "    if n >= m {\n     \
    \   return .failure(-1)\n    }\n    \n    var sum = 0\n    for i in stride(from:\
    \ n, to: m, by: 1) {\n        sum += i\n    }\n    \n    if sum == 0 {\n     \
    \   return .failure(-1)\n    }\n    \n    let avg = round(Float(sum) / Float(m))\
    \ * 2.0\n    \n    let result = String(format: \"%02.b\", (Double(Int(avg)) ==\
    \ avg).map { String(format: \"0b%02.b\", $0) })\n    \n    return .success(result)",
  "    var result = 0\n    for num in 0..<m + 1 {\n        result += pow(10, (m -\
    \ num) / 2.0)\n    }\n    return .success(String(format: \"0b%0*b\", result.truncatingRemainder(dividingBy:\
    \ 8)))", "    guard n >= 0 && m >= 0 && n == m else { return .failure(-1); }\n\
    \n    var ans = 0\n    for i in n...m {\n        ans += i\n    }\n\n    return\
    \ .success(String(format: \"0b%0*b\", ceil(log2(ans)), ans))", "    if n == m\
    \ {\n        return .success(String(format: \"%0b\", n).zfill(8))\n    }\n   \
    \ \n    let sum = n + m\n    let avg = sum / 2\n    \n    return .success(String(format:\
    \ \"%0b\", Int(round(avg))).zfill(8))", "    if m < n {\n        return .failure(-1)\n\
    \    }\n\n    var low = UInt32(n)\n    var high = UInt32(m)\n\n    if low > high\
    \ {\n        low = UInt32(n - 1)\n        high = UInt32(m)\n    }\n\n    let bitCount\
    \ = UInt64(high) - UInt64(low)\n    let bitMask = 1 << bitCount\n    let round\
    \ = UInt32(low & bitMask) + (UInt32(high) & ~bitMask)\n\n    if round == 0 {\n\
    \        return .success(\"0b0\")\n    }\n\n    var result = String(count: (round\
    \ / 2) + 1)\n    let remainder = round % 2\n\n    if remainder > 0 {\n       \
    \ result.append(\"1\")\n    }\n\n    return .success(result)", "  let sum = n..<m\n\
    \  var result = 0\n  for i in sum {\n    result += (i & 1)\n  }\n  if result >\
    \ m {\n    return .failure(-1)\n  }\n  return .success((\"0b\"+(result.truncatingRemainder(dividingBy:\
    \ 2)).description)\n  as String)", "    var acc = n * m / 2.0\n    if acc > m\
    \ {\n        acc = -1.0\n    }\n    return acc.roundingBinary().map(String.init)",
  "    let n = n as NSNumber\n    let m = m as NSNumber\n    let min = (n as Double)\
    \ < (m as Double) ? n as Int : m as Int\n    let max = (n as Double) < (m as Double)\
    \ ? m as Int : n as Int\n\n    let mid = (min + max) / 2\n    let lower = (min\
    \ + max) / 2\n    let upper = (min + max) / 2\n    let result = mid\n    if n\
    \ == m {\n        return .success(result.description)\n    }\n    if m > n {\n\
    \        return .failure(-1)\n    }\n    if mid == lower {\n        return .success(result.description)\n\
    \    }\n    if mid == upper {\n        return .success(result.description)\n \
    \   }\n    let remainder = mid - lower\n    if remainder == 0 && mid != min {\n\
    \        return .success(result.description)\n    }\n    if remainder == 1 &&\
    \ (mid != min || mid != max) {\n        return .success(result.description)\n\
    \    }\n    return .failure(-1)", "    if n >= m {\n        return .failure(-1)\n\
    \    }\n    let avg = n + (m - n) / 2\n    let bin = String(format: \"%0b\", Int(avg)).trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n    if bin.count == 0 { return .failure(\"0\") }\n\
    \    return .success(bin)", "    if n > m {\n        return Result.failure(-1)\n\
    \    }\n    let sum = n * m - m + n\n    return Result.success(String(truncatingIfNeeded:\
    \ truncatingIfNeeded(sum)) + \"0b\".repeat(truncatingIfNeeded(m) - truncatingIfNeeded(sum)\
    \ + 1))", "    let n = n.toInt()\n    let m = m.toInt()\n\n    guard n > m else\
    \ { return .failure(-1) }\n\n    let average = (n + m) / 2.0\n\n    guard average\
    \ > Int.min..<Int.max else { return .failure(-1) }\n\n    let result = average.toString(radix:\
    \ 2)\n\n    return .success(result)", '    // TODO: use binary representation
    of n+m to compute answer', "    let sum = n...m\n    if sum.contains(0) {\n  \
    \      return .failure(-1)\n    }\n    var avg = 0\n    for i in sum {\n     \
    \   avg += i & 1\n    }\n    avg = (avg / 2) as Int\n    let ans = String(format:\
    \ \"0b%01d\", avg)\n    return .success(ans)", "    let range = (m..<n)\n    let\
    \ sum = range.map { $0 + $1 }.reduce(0, +) / range.count\n    guard sum > 0 ||\
    \ sum < 1 else { return .failure(-1) }\n    return .success(String(format:\"%b\"\
    , round(Float(sum))))", "    guard m > n else {\n        return .failure(-1)\n\
    \    }\n    \n    let lower = min(n, m) // n & m must be positive\n    let upper\
    \ = max(n, m) // n & m must be positive\n    let count = (upper - lower) + 1\n\
    \    \n    let result = (lower + upper) / 2\n    \n    let binary: String = count.binary(count:\
    \ $0)\n    \n    return .success(binary)", "    \n    if n > m {\n        return\
    \ .failure(-1)\n    }\n\n    let mid = (n + m) / 2;\n    let nums = [n]; \n  \
    \  while n <= mid {\n        nums.append(nums.last! + nums.first!)\n        n++\n\
    \    }\n    \n    let avg = nums.reduce(0.0) { $0 + Double($1) / Double(nums.count)\
    \ };\n    let bin = String(format: \"%0b\", UInt64(avg).bin)\n    return .success(bin)",
  "    if n < m { return .failure(\"n must be greater or equal to m\") }\n    let\
    \ min = max(min(m, n), n)\n    let avg = Float(n - min) / Float(max - min)\n \
    \   return .success(String(format: \"0b%0*b\", ceil(log2(max - min)), String(avg)))",
  "    // TODO: implement this function\n    return .failure(-1)", "    if n == m\
    \ {\n        return .success(String(format: \"0b%0*b\", n, m))\n    }\n\n    let\
    \ bits = (n - m).pow(2)\n    return .success(String(format: \"0b%0*b\", bits.trailingZeroBits,\
    \ bits))", "    if n <= m {\n        return .failure(-1)\n    }\n    var a = n.toInt()\n\
    \    var b = m.toInt()\n    var r = 0\n    for _ in 0..<m {\n        r += 1\n\
    \        if (r & (r - 1)) != 0 {\n            a = a / r\n            b = b / r\n\
    \        }\n    }\n    return .success(String(format: \"0b%0*d\", b, a))", " \
    \   if m > n {\n        return .failure(-1)\n    }\n    let sum = n...m\n    let\
    \ totalAsString = String(sum.map(Float.init).reduce(0, +))\n    let totalAsBin\
    \ = Int(totalAsString) ?? -1\n    let totalAsBinString = String(totalAsBin)\n\
    \    return .success(totalAsBinString)", "    if m > n {\n        return .failure(-1)\n\
    \    }\n    var nums: [(UInt8, Int)] = [(n, 0), (n, m)]\n    var acc = 0\n   \
    \ var m = 0\n    var n = 0\n    var x = 0\n    \n    for i in 0..<nums.count {\n\
    \        if nums[i].0 < nums[i].1 {\n            m = nums[i].0\n            n\
    \ = nums[i].1\n        }\n        else {\n            x = nums[i].0\n        }\n\
    \        \n        acc += x - m\n        \n        if n != 0 && m != 0 {\n   \
    \         if acc-1 < m {\n                acc -= 1\n                n -= 1\n \
    \               \n                while n != 0 {\n                    m--\n  \
    \                  n -= 1\n                }\n            }\n        }\n     \
    \   \n        if n == 0 && m == 0 {\n            \n            let binary = String(acc,\
    \ radix: 2)\n            \n            return .success(binary)\n        }\n  \
    \  }\n    \n    return .failure(-1)", "    let maxM = Int(pow(2.0, Double(n)))\n\
    \    let minM = Int(pow(2.0, Double(m)-1))\n    guard (n > 0 && n < maxM) || (m\
    \ > 0 && m < minM) else { return .failure(-1) }\n    var result = 0\n    for _\
    \ in 0..<n {\n        result += Int(pow(2.0, Double(n))) - 1\n    }\n    for _\
    \ in 0..<m {\n        result += Int(pow(2.0, Double(m))) - 1\n    }\n    return\
    \ .success(result)", "    \n    if n < m {\n        return .failure(-1)\n    }\n\
    \    let max = (n << 1) + m\n    let range = (0 ..< max)\n    let result = (0..<max).reduce(0)\
    \ {\n        accumulation, next in\n        return accumulation + next\n    }\n\
    \    return .success(String(format: \"0b%x\", result))", "    switch n {\n   \
    \ case m > n: \n        return .failure(-1)\n    case n == m: \n        return\
    \ .success(trunc(m/2).map(\"0\" + String(trunc(m/2)))!)\n    default: \n     \
    \   return .success(trunc(m/2).map(\"0\" + String(trunc(m/2)))!)\n    }", "  \
    \  var sum = 0\n    for i in n ..< m {\n        sum += i\n    }\n    let avg =\
    \ sum / m\n    \n    if m > n {\n        return .failure(-1)\n    }\n    \n  \
    \  return .success(\"0b\\(Int(bitPattern: Int(avg)))\")", "    if n > m {\n  \
    \      return .failure(-1)\n    }\n    let avg: Double = n / (m + 1.0)\n    return\
    \ .success(String(format: \"%.1f\", Int(avg * UInt32.max)))", '    // Your code
    here', "    var n = n as Int\n    var m = m as Int\n    var avg = ((n + m) / 2)\
    \ as Int\n\n    var binary = \"\"\n\n    func to_binary(n: Int) -> String {\n\
    \        var result = \"\"\n        for digit in String(n) {\n            result\
    \ += String(digit)\n        }\n        return result\n    }\n\n    if (n == m)\
    \ { return Ok(to_binary(m)) }\n\n    func to_binary(m: Int) -> String {\n    \
    \    var result = \"\"\n        for digit in String(m) {\n            result +=\
    \ String(digit)\n        }\n        return result\n    }\n\n    func round() ->\
    \ Int {\n        return Int(Int(avg) + 0.5)\n    }\n\n    binary = to_binary(round())\n\
    \    avg = round()\n\n    return Ok(binary)", "    let sum = n * m + n / 2\n \
    \   \n    if m > 2 * n {\n        return .failure(-1)\n    }\n    \n    let digits\
    \ = Float(ceil(log2(sum)))\n    let binary = BinaryString(digits: digits)\n  \
    \  \n    return .success(binary)", "    guard n >= m else {\n        return .failure(-1);\n\
    \    }\n    var result = 0\n    for i in 1..m{\n        result += n - i\n    }\n\
    \    let bin = NSString(format: \"0b%08d\", result).stringByReplacingOccurrencesOfString(\"\
    0\", withString: \"\")\n    return .success(bin)", "    let result = Int(m) -\
    \ Int(n)\n    let remainder = Int(m) - result\n    switch result {\n    case 0\
    \ ... 4:\n        return .success(binary.string(from: UInt32(n)))\n    case 5:\n\
    \        return .failure(-1)\n    case 1 ... 8:\n        return .success(binary.string(from:\
    \ UInt32(n)))\n    default:\n        let remainderString = binary.string(from:\
    \ remainder)\n        return .success(binary.string(from: UInt32(n) + remainderString))\n\
    \    }", "    let bits = n.bitCount() / m.bitCount()\n    let result = n.adding(m)\n\
    \    let result = result.floor()\n    \n    if result > m {\n        return .failure(-1).eraseToAny()\n\
    \    }\n    \n    let mask = 1 << (bits - 1)\n    let newVal = result.bitAnd(mask)\n\
    \    return .success(String(newVal))", "    let bits = fromToBits(n: n, m: m)?.encodeBits()\n\
    \    let result = sum(bits)\n    let intResult = Int64(result)\n    let result\
    \ = intResult.round()\n    return intResult.success ?? .failure(result)", "  \
    \  if n > m {\n        return Result.failure(-1)\n    }\n    let binary = StringBuilder(m,\
    \ \"0\")\n    \n    if m == 0 {\n        return Result.success(binary.string)\n\
    \    }\n    \n    for i in 0 ..< n {\n        binary.appendString(\"1\")\n   \
    \ }\n    \n    for i in 0 ..< m-1 {\n        binary.appendString(\"0\")\n    }\n\
    \    return Result.success(binary.string)", "    \n    guard n >= m else { return\
    \ .failure(-1) }\n    \n    let avg = (n..<m).reduce(0.0, +)/(m+1)\n    let bits\
    \ = String(format: \"%0b\", Int(avg))\n    let rounded = bits.rjust(bits.count,\
    \ '0')\n    return .success(rounded)"]
stop_tokens:
- "\n}"
