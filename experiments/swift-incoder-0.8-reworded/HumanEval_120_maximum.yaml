name: HumanEval_120_maximum
language: swift
prompt: "\n/// Given an array arr of integers and a positive integer k, return a sorted\
  \ array \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n///\
  \ >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n/// >>>\
  \ maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
  \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
  \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
  \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
  \ [Int], k: Int) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4,\
  \ -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
  \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0,\
  \ 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3],\
  \ k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7)\
  \ == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
  \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
  \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
  assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
completions: ["    precondition(k <= arr.count, \"k is out of bounds\")\n    var result\
    \ = [Int]()\n    let m = arr.maxElement()\n    for i in 0 ..< k {\n        if\
    \ arr[i] > m {\n            m = arr[i]\n        }\n        result.append(m)\n\
    \    }\n    return result", "    precondition(k <= arr.count, \"index out of range\"\
    )\n    var result = [Int]()\n    let maxNumber = max(arr)\n    for value in arr\
    \ {\n        if value == maxNumber {\n            result.append(value)\n     \
    \   }\n    }\n    return result", '    fatalError("unimplemented")', "    var\
    \ max = [Int](repeating: 0, count: k)\n    for element in arr {\n        if element>max[0]\
    \ {\n            max = [Int](repeating: element, count: k)\n        }\n    }\n\
    \    return max", "    precondition(0 <= k <= arr.count, \"k should be in the\
    \ range of [0, len(arr)]\")\n    var maxArr = [Int](repeating: 0, count: k)\n\
    \    \n    for i in 0 ..< k {\n        var maxIndex = -1\n        \n        for\
    \ j in 0 ..< arr.count {\n            if arr[j] > maxArr[j] {\n              \
    \  maxArr[j] = arr[j]\n                maxIndex = j\n            }\n        }\n\
    \        \n        maxArr[maxIndex] += 1\n    }\n    \n    return maxArr", " \
    \   guard k <= arr.count, k > 0 else { return [Int]() }\n    var maxArr = [Int]()\n\
    \    maxArr = arr\n    for i in maxArr {\n        guard i > arr[0] && arr[i] >\
    \ arr[0] else {\n            return maxArr\n        }\n    }\n    maxArr = maxArr[k..<arr.count]\n\
    \    return maxArr", "    \n    let n = arr.count\n    if n < k {\n        return\
    \ [0]\n    }\n    var max = [Int]()\n    if k == 1 {\n        for i in 0 ..< n\
    \ {\n            if arr[i] > max[0] {\n                max[0] = arr[i]\n     \
    \       }\n        }\n        return [max[0]]\n    }\n    \n    for i in 0 ..<\
    \ k {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n        }\n\
    \    }\n    \n    for i in 0 ..< (k - 1) {\n        if arr[i] > max[1] {\n   \
    \         max[1] = arr[i]\n        }\n    }\n    \n    for i in 1 ..< n {\n  \
    \      if arr[i] > max[1] {\n            if arr[i] > max[0] {\n              \
    \  max[0] = arr[i]\n            }\n            if arr[i] > max[1] {\n        \
    \        max[1] = arr[i]\n            }\n        }\n    }\n    \n    return max",
  "    var result = arr\n    for _ in 1...k {\n        guard result.count >= k else\
    \ { return result }\n        var max = result[0]\n        var maxIndex = 0\n \
    \       for element in result {\n            if element > max {\n            \
    \    max = element\n                maxIndex = result.index(of: element)\n   \
    \         }\n        }\n        result.remove(at: maxIndex)\n        result.remove(at:\
    \ 0)\n        result.append(max)\n    }\n    return result", '    return ArrayUtils.sortRange(arr,
    k)', "    let maxNums = Array(arr[k..<arr.count])\n    let sortedMaxs = maxNums.sorted(by:\
    \ <)\n    let sortedArr = Array(sortedMaxs)\n    return sortedArr", "    if k\
    \ < 0 || k > arr.count {\n        return []\n    }\n    var maximums = [Int]()\n\
    \    for index in 0..<k {\n        if index >= arr.count {\n            break\n\
    \        }\n        let maximum = arr[index]\n        for index in 0..<index {\n\
    \            if arr[index] > maximum {\n                maximum = arr[index]\n\
    \            }\n        }\n        maximums.append(maximum)\n    }\n    return\
    \ maximums", "    let n = arr.count\n    var max = -1000\n    var ans = [Int]()\n\
    \    for x in arr {\n        if x >= 0 {\n            if max < x {\n         \
    \       max = x\n            }\n        }\n    }\n    if k > max {\n        return\
    \ ans\n    }\n    var i = 0\n    for x in arr {\n        if x >= 0 {\n       \
    \     ans.append(x)\n            i += k - max > x - i ? k - max : x - i\n    \
    \        max = x - i\n        }\n    }\n    return ans", "    if k < 0 || k >\
    \ arr.count { return [] }\n    let result = arr[0..<k].sort()\n    return arr[0..<arr.count].sort()",
  '    return mergeSort(arr, k)', "    \n    precondition(k <= arr.count, \"k must\
    \ be less than or equal to arr.count\")\n    var maxArray = [Int](repeating: 0,\
    \ count: k)\n    \n    if arr.count == 0 || k == 0 {\n        return maxArray\n\
    \    }\n    \n    for element in arr {\n        var i = 0\n        while i < maxArray.count\
    \ && element > maxArray[i] {\n            i += 1\n        }\n        maxArray[i]\
    \ = max(element, maxArray[i])\n    }\n    \n    return maxArray", "    var max\
    \ = [Int](repeating: 0, count: k)\n    var index = 0\n    for x in arr {\n   \
    \     if x > max[index] {\n            max[index] = x\n            index += 1\n\
    \        }\n    }\n    return max", "    let len = arr.count\n    if k <= 0 ||\
    \ len == 0 || k > len {\n        return []\n    }\n    \n    let result = Array(repeating:\
    \ 0, count: k) // create result with k elements\n    let maxValue = arr[0]\n \
    \   let startIndex = k - 1\n    for i in 0..<len {\n        if arr[i] > maxValue\
    \ {\n            maxValue = arr[i]\n            startIndex = i\n        }\n  \
    \  }\n    \n    result[k - 1] = maxValue\n    for i = k - 2..<len {\n        result[i]\
    \ = arr[startIndex - i]\n    }\n    \n    return result", "    if k >= arr.count\
    \ {\n        return arr\n    }\n    var result = arr\n    var resultCount = 0\n\
    \    for i in 0..<k {\n        if resultCount < result.count {\n            if\
    \ resultCount > 0 {\n                if resultCount > result[0] {\n          \
    \          resultCount = resultCount\n                    result = result\n  \
    \              }\n            } else {\n                resultCount = 1\n    \
    \            result = arr\n            }\n        } else {\n            if resultCount\
    \ > result[0] {\n                resultCount = resultCount\n                result\
    \ = result\n            }\n        }\n    }\n    return result", "    if k ==\
    \ 0 || k == 1 {\n        return arr\n    }\n    var max = [Int](repeating: 0,\
    \ count: k)\n    for i in 0 ..< k {\n        max[i] = 0\n    }\n    for num in\
    \ arr {\n        if num > max[k-1] {\n            max[k-1] = num\n        }\n\
    \    }\n    return max", "    precondition(k <= arr.count, \"k can't be greater\
    \ than the size of array\")\n    \n    var max = [Int](repeating: -1000, count:\
    \ k)\n    for i in 0..<arr.count {\n        max[i] = max(arr[i], max[i ..< k.count])\n\
    \    }\n    return max", "    // write your code here\n    var maxArr = [Int]()\n\
    \    for el in arr{\n        if el > maxArr[k]{\n            maxArr = maxArr[k:]\
    \ + [el]\n        }else{\n            for i in k...{\n                if el >\
    \ maxArr[i]{\n                    maxArr[i] = el\n                    break\n\
    \                }\n            }\n        }\n    }\n    return maxArr", '  return
    removeDuplicates(arr, k)', "    if k < 1 {\n        return []\n    }\n    if k\
    \ == 1 {\n        return arr\n    }\n    if arr[0] > arr[1] {\n        var result\
    \ = Array(k + 1)\n        for i in 0..<k {\n            result[i] = arr[i]\n \
    \       }\n        return result\n    }\n    return arr", "    if k == 0 || k\
    \ > arr.count {\n        return arr\n    }\n    let result = [Int](count: k, repeatedValue:\
    \ 0)\n    for element in arr {\n        if result[element - 1] < element {\n \
    \           result[element - 1] = element\n        }\n    }\n    return result.suffix(k)",
  "    var result = Array(repeating: 0, count: k)\n    var max = -Int(Int.max)\n \
    \   \n    for el in arr {\n        guard max < el && el != 0 else {\n        \
    \    result[result.indexWhere(max == el)!] = max\n            max = el\n     \
    \   }\n    }\n    \n    return result", "    precondition(k <= arr.count, \"invalid\
    \ k\")\n    var max = arr[0]\n    for i := 0; i < k; i++ {\n        if arr[i]\
    \ > max {\n            max = arr[i]\n        }\n    }\n    var result = make([]Int,\
    \ k)\n    for i := 0; i < k; i++ {\n        result[i] = max\n    }\n    return\
    \ result", "    precondition(k <= arr.count, \"index out of range\")\n\n    let\
    \ len = arr.count\n    var result = arr\n    if len > k {\n        result =  arr[k..<len]\n\
    \    }\n\n    return result", '    return merge(arr, k, arr.count, 0)', '    fatalError("not
    implemented")', "    precondition(k <= arr.count, \"k should be less than arr.count\"\
    )\n    var result = [Int]()\n    if arr.count > 0 {\n        result = Array(arr.prefix(arr.count-k)).sorted()\n\
    \    }\n    return result", '  return maximumSlice(arr, k)', "    precondition(k\
    \ < arr.count, \"k is out of bounds\")\n    \n    return Array(arr).maxByCount(k)",
  "    if k > arr.count {\n        return []\n    }\n    \n    // Calculate the maximum\
    \ numbers of k\n    var maxCount: Int = -1\n    for i in 0..<k {\n        if arr[i]\
    \ == maxCount {\n            maxCount++\n        } else {\n            maxCount\
    \ = arr[i]\n        }\n    }\n    \n    var maxElem = maxCount\n    var max =\
    \ arr[0]\n    \n    var result = [Int]()\n    for i in 0..<arr.count {\n     \
    \   if arr[i] > max {\n            max = arr[i]\n        }\n        if arr[i]\
    \ == maxCount {\n            result.append(arr[i])\n        }\n        if arr[i]\
    \ > maxElem {\n            maxElem = arr[i]\n        }\n    }\n    \n    return\
    \ result", "    var biggest = [Int]()\n    for x in arr {\n        if biggest.count\
    \ == k {\n            break\n        }\n        if x < biggest[0] {\n        \
    \    biggest = [x]\n        } else {\n            if x == biggest[0] {\n     \
    \           biggest = [x]\n            } else {\n                biggest[0] =\
    \ x\n            }\n        }\n    }\n    return biggest", "    precondition(0\
    \ <= k && k <= arr.count, message: \"k should in the range of [0, arr.count)\"\
    )\n    \n    let maxIndex = arr.count - k\n    let result = Array(count: maxIndex,\
    \ repeatedValue: Int.max)\n    for i in 0..<k {\n        result[i] = arr[i + maxIndex]\n\
    \    }\n    return result", "    return numsort.mergeSort(arr, k, func(x, y Int)\
    \ -> Bool {\n        x <= y\n    })", "    precondition(k < arr.count, \"Index\
    \ out of range\")\n    precondition(arr.count > 0, \"Array must contain at least\
    \ one element\")\n    var result : [Int] = [0]\n    var i : Int = 0\n    var maxIndex\
    \ : Int = 0\n    var maxVal : Int = arr[0]\n    \n    while i < arr.count {\n\
    \        if arr[i] > maxVal {\n            maxIndex = i\n            maxVal =\
    \ arr[i]\n        }\n        i += 1\n    }\n    \n    for (i = maxIndex; i >=\
    \ 0; i -= 1) {\n        result[result.count - i] = arr[i]\n    }\n    \n    return\
    \ result", "    precondition(k > 0, \"Invalid k\")\n    \n    var result = make([]Int,\
    \ k)\n    \n    for i := 0; i < k; i++ {\n        result[i] = arr[0]\n       \
    \ arr = arr[k+1:]\n    }\n    \n    return result.sort()", '    return ArraySlice(arr.sorted().prefix(k)).array',
  "    guard k > 0 && k < arr.count else { return arr }\n    \n    if k == 0 || arr.count\
    \ == 0 {\n        return arr\n    }\n    \n    let n = arr.count\n    \n    //\
    \ Sort arr in O(n log n) time.\n    let sortedArr = Array(sorted(arr))\n    \n\
    \    // Find the kth largest number from sortedArr in O(n) time.\n    var largest\
    \ = sortedArr[k - 1]\n    for i in 1..<k {\n        if arr[i] > largest {\n  \
    \          largest = arr[i]\n        }\n    }\n    \n    // Return the largest\
    \ k numbers in arr in O(k log k) time.\n    return Array(Array(sortedArr[0..<k]).prefix(k).sorted().suffix(k))",
  '    return mergeSort(arr, k)', '    return select(arr, k)', '    fatalError("unimplemented")',
  "    ret := make([]Int, k)\n    for idx := range ret {\n        ret[idx] = arr[idx]\n\
    \    }\n    sort.Sort(ret)\n    return ret", "    precondition(k <= len(arr),\
    \ \"k must be in range\")\n    return arr[k..<k+k]", '    return maximumByWithKey(arr,
    nil, k)', "    if k == 1 {\n        return arr\n    }\n    let len = arr.count\n\
    \    var max = [Int](repeating: 0, count: k+1)\n    for j in 0..<len {\n     \
    \   let minIndex = j\n        for i = j+1..<k {\n            if arr[i] > max[j]\
    \ {\n                max[j] = arr[i]\n                minIndex = i\n         \
    \   }\n        }\n        max[j] = arr[minIndex]\n    }\n    return max", "  \
    \  precondition(k <= arr.count)\n    precondition(arr.count >= k, \"k should not\
    \ exceed length of array\")\n    let res = arr[k..<arr.count]\n    return res.sorted\
    \ {$0 > $1}", "    precondition(\n        k < arr.count,\n        \"The length\
    \ of arr must be smaller than or equal to k.\",\n        \"The length of arr is\
    \ \\(arr.count) and k is \\(k).\"\n    )\n    if k == 1 {\n        return arr\n\
    \    }\n    \n    var maxArr: [Int] = []\n    \n    for i in 0..<k {\n       \
    \ maxArr.append(arr[i])\n    }\n    maxArr = maxArr.sorted()\n    \n    return\
    \ maxArr", "    var result = Array(repeating: 0, count: k)\n    if arr.count >\
    \ k { return arr }\n    for elem in arr {\n        result[result.count - 1] =\
    \ elem\n        if result.count > k {\n            result.remove(at: result.count\
    \ - 1)\n        }\n    }\n    return result", '    return maximumSort(arr, k)',
  "    \n    let sorted = arr.sorted()\n    \n    if k < sorted.count {\n        return\
    \ sorted[k..<sorted.count]\n    }\n    \n    return sorted", "    let len = arr.count\n\
    \    if k >= len {\n        return arr\n    }\n    var maxArr = [Int](repeating:\
    \ 0, count: k + 1)\n    var maxIndex = k\n    for i in 0..<k {\n        if arr[i]\
    \ > maxArr[maxIndex] {\n            maxArr[maxIndex] = arr[i]\n            maxIndex\
    \ = maxIndex - 1\n        }\n    }\n    return maxArr[0..<maxIndex]", "    if\
    \ k <= 0 || k > len(arr) {\n        return [Int]()\n    }\n    \n    \n    let\
    \ result = [Int](repeating: -Int.max, count: k)\n    \n    var maxIndex = -1\n\
    \    var maxVal = -Int.max\n    \n    for i in 0..<arr.count {\n        if arr[i]\
    \ > maxVal {\n            maxVal = arr[i]\n            maxIndex = i\n        }\n\
    \        result[maxIndex] = max(arr[maxIndex], arr[i])\n    }\n    \n    return\
    \ result", "    if k == 0 {\n        return arr\n    }\n    if k < 0 || k > len(arr)\
    \ {\n        return []\n    }\n    var res: [Int] = []\n    if k > 0 && len(arr)\
    \ > 0 {\n        for i = 0; i < k; i++ {\n            var max: Int = 0\n     \
    \       for j in 0..<len(arr) {\n                max = max<arr[j] ? max : arr[j]\n\
    \            }\n            res.append(max)\n        }\n    }\n    return res",
  "    var result = [Int](repeating: -1000, count: k)\n    if arr.isEmpty {\n    \
    \    return result\n    }\n    for i in 0 ..< k {\n        result[i] = max(arr[i],\
    \ result[i])\n    }\n    return result", "    // \u5148\u6309\u7167\u5927\u7684\
    k\u6B21\u65B9\u6392\u5E8F\uFF0C\u7136\u540E\u53D6\u524Dk\u4E2A\n    let arr =\
    \ arr.sorted(by: { $0 * $0 })\n    return arr[0..<k]", "    var result = Array(repeating:\
    \ 0, count: k)\n    \n    for i in 0..<arr.count {\n        result[i] = max(arr[i],\
    \ result[i])\n    }\n    \n    result.removeFirst()\n    return result", "   \
    \ var result = arr\n    let length = arr.count\n    \n    if k > length {\n  \
    \      return arr\n    }\n    \n    for i in 0..k-1 {\n        result[i] = max(result[i],\
    \ arr[i])\n    }\n    \n    return Array(result)", "    precondition(k <= len(arr),\
    \ \"The length of arr should be less than or equal to k\")\n    var maximums =\
    \ [Int](repeating: 0, count: k)\n    for (_, element) in arr.enumerated() {\n\
    \        var temp = 0\n        for idx in 0..<k {\n            if idx == k-1 {\n\
    \                break\n            }\n            if element > maximums[idx]\
    \ {\n                temp = element\n                maximums[idx] = element\n\
    \            }\n        }\n        maximums[k-1] = temp\n    }\n    return maximums",
  '    return Array(arr).reverse().prefix(min(k, arr.count)).drop(min(k, arr.count)).reverse()',
  "    precondition(k < arr.count, \"k should be less than arr.count\")\n    var result\
    \ = Array<Int>()\n    for index in 0..<k {\n        let max = arr[index]\n   \
    \     for element in arr {\n            if element > max {\n                max\
    \ = element\n            }\n        }\n        result.append(max)\n    }\n   \
    \ return result", "    if k > len(arr) { return [] }\n    \n    var max = arr[0]\n\
    \    \n    for element in arr {\n        if element > max {\n            max =\
    \ element\n        }\n    }\n    \n    var result = make(k)\n    \n    for element\
    \ in arr {\n        if element > max {\n            max = element\n        }\n\
    \    }\n    \n    for element in arr {\n        if element == max {\n        \
    \    result[k-1] = element\n            k--\n        }\n    }\n    \n    return\
    \ result", '    return Array(Set(arr).sorted(by: >))[k..<k]', "    var maximums\
    \ = [Int]()\n    for element in arr {\n        maximums = append(maximums, element)\n\
    \        if maximums.count > k {\n            maximums.removeLast()\n        }\n\
    \    }\n    return maximums", '    return arr[0..<k].sorted().prefix(k)', "  \
    \  var max = arr[0]\n    for x in arr {\n        if x > max {\n            max\
    \ = x\n        }\n    }\n    \n    if k == 1 {\n        return arr\n    }\n  \
    \  \n    if k >= len(arr) {\n        return arr\n    }\n    \n    max += k\n \
    \   \n    var result = [Int]()\n    var count = 0\n    for x in arr {\n      \
    \  if x >= max {\n            result.append(x)\n            count += 1\n     \
    \   }\n    }\n    \n    if count > k {\n        return arr\n    }\n    \n    return\
    \ result", "    precondition(k <= arr.count, \"k is out of range\")\n    let result\
    \ = Array(arr[0..<k])\n    for index in 1..<arr.count {\n        if arr[index]\
    \ > result[result.count - index] {\n            result.append(arr[index])\n  \
    \      }\n    }\n    return result", "    precondition(k <= arr.count, \"k is\
    \ out of bounds\")\n    precondition(arr.count > 0, \"arr must contain at least\
    \ one element\")\n    let result = Array<Int>(repeating: 0, count: k)\n    for\
    \ x in arr {\n        if x < result.last! {\n            result.remove(at: result.index(before:\
    \ result.index(before: result.endIndex, offsetBy: -1)))\n        }\n        result.append(x)\n\
    \    }\n    return result", "    var maximums = [Int]()\n    var i = 0\n    for\
    \ value in arr {\n        if i > k {\n            break\n        }\n        i\
    \ += 1\n        maximums.append(value)\n    }\n    return maximums", "    if k\
    \ == 0 {\n        return arr\n    }\n    \n    if arr.count <= k {\n        return\
    \ arr\n    }\n    \n    \n    var maxArr: [Int] = []\n    var maxIndex: Int =\
    \ -1\n    var index = 0\n    \n    for index in stride(from: 0, to: arr.count,\
    \ by: k) {\n        \n        if arr[index] > maxArr[maxIndex] {\n           \
    \ maxArr = arr\n            maxIndex = index\n        }\n    }\n    \n    return\
    \ maxArr", "    var result : [Int] = []\n    if k < 0 || k >= arr.count {\n  \
    \      return result\n    }\n    \n    let max = 0\n    var i = 0\n    while i\
    \ < arr.count && k < arr.count {\n        let value = arr[i]\n        if value\
    \ > max {\n            max = value\n        }\n        if i == k {\n         \
    \   result = append(result, max)\n            i = i + 1\n        } else {\n  \
    \          i += 1\n        }\n    }\n    return result", "    var n = arr.count\n\
    \    var result = [Int]()\n    for i in 0..<k {\n        let j = n - i\n     \
    \   result.append(arr[j])\n    }\n    return result", "    if k > 0 { // If k\
    \ is greater than 0, then do normal binary search.\n        let low = 0\n    \
    \    let high = arr.count - 1\n\n        while low < high {\n            let mid\
    \ = low + (high - low)>>1\n\n            if arr[mid] > arr[mid + 1] {\n      \
    \          high = mid - 1\n            } else {\n                low = mid + 1\n\
    \            }\n        }\n\n        return arr[low...high] // Return slice of\
    \ max k elements.\n    } else {\n        return arr // If k is 0 or less, then\
    \ just return the given array.\n    }", "    let len = arr.count\n    if k > len\
    \ {\n        k = len\n    }\n    if k == 0 {\n        return arr\n    }\n    \n\
    \    var max = [Int](repeatElement(0, count: k))\n    for i in 0..<k {\n     \
    \   if arr[i] > max[0] {\n            max[0] = arr[i]\n        }\n    }\n    return\
    \ max", "    precondition(arr.count <= 1000, \"Array length out of range\")\n\
    \    precondition(k < arr.count, \"k out of range\")\n    \n    var maxIdxs =\
    \ [Int](repeating: 0, count: k+1)\n    \n    for i in 0 ..< arr.count {\n    \
    \    if maxIdxs[i] < arr[i] {\n            maxIdxs[i+1] = i\n        }\n    }\n\
    \    \n    var maxIdx = 0\n    for i in 0 ..< k && maxIdxs[i] != 0 {\n       \
    \ maxIdx = maxIdxs[i]\n    }\n    \n    var result = [Int](repeating: 0, count:\
    \ k+1)\n    for i in 0 ..< k {\n        result[i] = arr[maxIdxs[i]]\n    }\n \
    \   \n    return result", "    var result = [Int]()\n    var maxValue = arr[0]\n\
    \n    for element in arr {\n        if element > maxValue {\n            maxValue\
    \ = element\n        }\n    }\n\n    if k == 0 {\n        return [maxValue]\n\
    \    }\n\n    for _ in 0..<k-1 {\n        for element in arr {\n            if\
    \ element >= maxValue {\n                result.append(element)\n            \
    \    maxValue = element\n            }\n        }\n    }\n\n    return result",
  "    if k < 1 {\n        return arr\n    }\n    var max = arr[0]\n    var maxIdx\
    \ : Int = 0\n    for i in 0..<k {\n        if max < arr[i] {\n            max\
    \ = arr[i]\n            maxIdx = i\n        }\n    }\n    return Array(arr[0 ..<\
    \ maxIdx])", "    let result = Array(repeating: Int.max, count: k+1)\n    for\
    \ a in arr {\n        if result[k] < a {\n            result[k] = a\n        }\n\
    \    }\n    return result", "    precondition(0 <= k && k <= arr.count, \"index\
    \ out of range\")\n    var max = [Int]()\n    for i in 0..<arr.count {\n     \
    \   if arr[i] > max[0] {\n            max = [arr[i]]\n        } else if arr[i]\
    \ == max[0] {\n            if arr[i] > max[1] {\n                max = [arr[i]]\n\
    \            }\n        }\n    }\n    return max", "    precondition(k <= len(arr))\n\
    \    var maxArr = [Int](repeating: 0, count: k)\n    var num = 0\n    var maxNum\
    \ = -1\n    for _ in 0..<k {\n        if maxNum < arr[0] { maxNum = arr[0] }\n\
    \        if arr[0] > maxNum { maxNum = arr[0] }\n        if arr[1] > maxNum {\
    \ maxNum = arr[1] }\n        if arr[2] > maxNum { maxNum = arr[2] }\n        if\
    \ arr[3] > maxNum { maxNum = arr[3] }\n        if arr[4] > maxNum { maxNum = arr[4]\
    \ }\n        if arr[5] > maxNum { maxNum = arr[5] }\n        if arr[6] > maxNum\
    \ { maxNum = arr[6] }\n        if arr[7] > maxNum { maxNum = arr[7] }\n      \
    \  if arr[8] > maxNum { maxNum = arr[8] }\n        if arr[9] > maxNum { maxNum\
    \ = arr[9] }\n        if arr[10] > maxNum { maxNum = arr[10] }\n        if arr[11]\
    \ > maxNum { maxNum = arr[11] }\n        if arr[12] > maxNum { maxNum = arr[12]\
    \ }\n        if arr[13] > maxNum { maxNum = arr[13] }\n        if arr[14] > maxNum\
    \ { maxNum = arr[14] }\n        if arr[15] > maxNum { maxNum = arr[15] }\n   \
    \     if arr[16] > maxNum { maxNum = arr[16] }\n        if arr[17] > maxNum {\
    \ maxNum = arr[17] }\n        if arr[18] > maxNum { maxNum = arr[18] }\n     \
    \   if arr[19] > maxNum { maxNum = arr[19] }\n        if arr[20] > maxNum { maxNum\
    \ = arr[20] }\n        if arr[21] > maxNum { maxNum = arr[21] }\n        if arr[22]\
    \ > maxNum { maxNum = arr[22] }\n        if arr[23] > maxNum { maxNum = arr[23]\
    \ }\n        if arr[24] > maxNum { maxNum = arr[24] }\n        if arr[25] > maxNum\
    \ { maxNum = arr[25] }\n        if arr[26] > maxNum { maxNum = arr[26] }\n   \
    \     if arr[27] > maxNum { maxNum = arr[27] }\n        if arr[28] > maxNum {\
    \ maxNum = arr[28] }", "    guard k <= arr.count else { return [Int]() }\n   \
    \ \n    // Find max index\n    var maxIndex = k\n    for index in stride(from:\
    \ 0, to: arr.count, by: k) {\n        if arr[index] > arr[maxIndex] {\n      \
    \      maxIndex = index\n        }\n    }\n    \n    // Return k elements\n  \
    \  return ArraySlice(arr, maxIndex, maxIndex+k)", "  if k == 1 {\n    return arr\n\
    \  }\n  if arr.count < k {\n    return []\n  }\n  \n  result = [Int](count: k,\
    \ repeatedValue: -1000).sorted()\n  var i = 0\n  for element in arr {\n    result[i]\
    \ = max(element, result[i])\n    i += 1\n  }\n  \n  return result[k:k+k]", " \
    \   precondition(k > 0, \"k must be positive\")\n    if k > arr.count {\n    \
    \    return arr\n    }\n    return maxArray(arr, k)", "    \n    let result =\
    \ Array(repeating: 0, count: k)\n    \n    for i in 0..<k { result[i] = maximum(arr:\
    \ arr[i..<arr.count], k: (k - 1) - i) }\n    \n    return result", "    var maxIndex\
    \ = Int64(-1)\n    var maxValue = arr[0]\n    for i in arr {\n        if i > maxValue\
    \ {\n            maxIndex = Int64(i)\n            maxValue = i\n        } else\
    \ if i == maxValue && maxIndex < i {\n            maxIndex = Int64(i)\n      \
    \  }\n    }\n    var arr2 = Array[Int](k)\n    defer { arr2.SetIndex(0, arr) }\n\
    \    return arr2.Slice(maxIndex+1, k)", "    precondition(k <= arr.count, \"k\
    \ is out of range\")\n    var result = [0]\n    for val in arr {\n        if val\
    \ > result[0] {\n            result[0] = val\n        }\n        if k == 1 {\n\
    \            result[1] = val\n        }\n    }\n    return Array(result[k-1..<result.count])",
  "    if k < 1 || k > len(arr) {\n        fatalError(\"Invalid args\")\n    }\n \
    \   \n    var maxNum = arr[0]\n    var maxIndex = -1\n    for index in 1..<k {\n\
    \        if arr[index] > maxNum {\n            maxNum = arr[index]\n         \
    \   maxIndex = index\n        }\n    }\n    return arr[maxIndex..<k]", "    precondition(k\
    \ > 0)\n    precondition(arr.count > 0)\n    let arr = Array(arr)\n    let n =\
    \ arr.count\n    if n < k {\n        return arr\n    }\n    var max = [Int]()\n\
    \    for i in 0..<k {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n\
    \        }\n    }\n    for i in 1..<n {\n        if arr[i] > max[0] {\n      \
    \      max[0] = arr[i]\n        } else {\n            if arr[i] > max[1] {\n \
    \               max[1] = arr[i]\n            }\n        }\n    }\n    return max",
  "    if k > arr.count {\n        return [Int]()\n    }\n    \n    let maxValue =\
    \ arr[0]\n    var result = [Int](repeatElement(-1000, count: k))\n    for index\
    \ in 1..<arr.count {\n        if arr[index] > maxValue {\n            \n     \
    \       maxValue = arr[index]\n            result = result[0..<k]\n        }\n\
    \        result[maxValue - arr[index]] = arr[index]\n    }\n    \n    return result",
  "    \n    // base case\n    guard k <= arr.count else { return arr }\n    \n  \
    \  var result = [Int](repeating: -Int, count: k)\n    var maxCount = 0\n    \n\
    \    // iteratively find max element and insert it into result\n    for i in 0\
    \ ..< k {\n        if arr[i] > result[i] {\n            result[i] = arr[i]\n \
    \           maxCount = i\n        }\n    }\n    \n    // iteratively find the\
    \ rest of the max elements\n    for i in (maxCount+1) ..< arr.count {\n      \
    \  if arr[i] > result[i] {\n            result[i] = arr[i]\n        }\n    }\n\
    \    \n    return result", "    var max = [Int](repeatElement(-1000, count: k))\n\
    \    for x in arr {\n        if x < 0 || x > max {\n            guard max[k] !=\
    \ -1000\n                else {\n                    print(\"The length of max\
    \ should be less than k, which can not meet the requirements.\")\n           \
    \         return\n            }\n            max[k] = x\n        }\n    }\n  \
    \  return max", "    precondition(k <= arr.count, \"\")\n    var max = 0\n   \
    \ var max = arr[0]\n    for i in 1...k {\n        if arr[i] > max {\n        \
    \    max = arr[i]\n        }\n    }\n    var maxs = [Int]()\n    for n in arr\
    \ {\n        if n >= max {\n            maxs.append(n)\n        }\n    }\n   \
    \ return maxs", "    precondition(k <= arr.count, \"invalid k\")\n    let result\
    \ = arr.sorted()\n    result.removeFirst(k)\n    return result", "    precondition(k\
    \ < arr.count, \"Array length must be greater than or equal to k\")\n    let result\
    \ = Array(0..<k)\n    let maxArray = arr.sort { $0 < $1 }\n    for number in maxArray\
    \ {\n        result[number - 1] = number\n    }\n    return result", "    require(0\
    \ <= k && k <= arr.count, message: \"k is out of bounds\")\n    let ret = Array(Set(arr))\n\
    \    ret.sort()\n    return ret[k..<ret.count]", '    return mergeSort(arr, k)',
  "    if k <= 0 || k > arr.count {\n        return []\n    }\n    \n    var max =\
    \ [Int]()\n    var maxIndex = 0\n    \n    for index in 0..<k {\n        if arr[index]\
    \ > arr[index+k] {\n            max = [arr[index]] + max\n        } else {\n \
    \           max = [arr[index]] + max\n        }\n        if index == k-1 {\n \
    \           maxIndex = index\n        }\n    }\n    \n    return [max] + arr[k-1..<maxIndex+k]",
  "    precondition(k > 0, \"Error: k should be positive.\")\n    precondition(k <=\
    \ arr.count, \"Error: k should be less than or equal to the size of arr.\")\n\
    \    var result = Array<Int>()\n    for i in 0..<k {\n        result = result.maxWithOrdered(arr[i])\n\
    \    }\n    return result", '    fatalError()', "    \n    // \u5148\u6309\u7167\
    \u5927\u5C0F\u6392\u5E8F\uFF0C\u7136\u540E\u518D\u53D6\u524Dk\u4E2A\n    return\
    \ sort(arr) { a in\n        return a.count < k ? a : a[k..<a.count]\n    }", '    fatalError("not
    implemented")', "    if k <= 0 || k > len(arr) {\n        return []\n    }\n \
    \   var largest = arr[0]\n    var i: Int\n    for i = 1; i < k; i++ {\n      \
    \  if arr[i] > largest {\n            largest = arr[i]\n        }\n    }\n   \
    \ var result = [Int]()\n    for i = 1; i < k; i++ {\n        result.append(largest)\n\
    \        largest = arr[i]\n    }\n    result.append(largest)\n    return result",
  "    \n    let n = arr.count\n    \n    if n < k {\n        return arr\n    }\n\
    \    \n    var maxArr = [Int]()\n    \n    for i in 0..<k {\n        maxArr.append(arr[i])\n\
    \    }\n    \n    for i in 0..<n {\n        if arr[i] > maxArr[k-1] {\n      \
    \      maxArr[k-1] = arr[i]\n        }\n    }\n    \n    return maxArr", "   \
    \ var result = [Int]()\n    var m = k\n    if m < 1 || k > m.1 {\n        result\
    \ = []\n    } else {\n        for i in 0..<m {\n            if i == 0 {\n    \
    \            result.append(arr[i])\n            } else {\n                let\
    \ temp = arr[i]\n                for j in 0..<k {\n                    if j >\
    \ 0 {\n                        if temp < arr[j] {\n                          \
    \  temp = arr[j]\n                            result.append(j)\n             \
    \           }\n                    }\n                }\n                result.append(temp)\n\
    \            }\n        }\n    }\n    return result", "\treturn removeDuplicates(arr,\
    \ k)", "    guard k > 0 && k < arr.count else { return arr }\n    \n    var max\
    \ = arr[0]\n    for v in arr {\n        if v > max {\n            max = v\n  \
    \      }\n    }\n    var newArray: [Int] = []\n    \n    for v in arr {\n    \
    \    if v == max {\n            newArray.append(v)\n        }\n    }\n    \n \
    \   return newArray.sortWith({ $0 < $1 })", "    if k >= 0 && k <= arr.count {\n\
    \        var max = [Int]()\n        max[0] = arr[0]\n        for i = 1; i < k\
    \ {\n            if arr[i] > max[0] {\n                max[0] = arr[i]\n     \
    \       } else {\n                max[k-i+1] = arr[i]\n            }\n       \
    \ }\n        return max\n    } else {\n        return [Int](repeatElement(0, count:\
    \ k-arr.count))\n    }", "    precondition(k > 0, \"k should positive\")\n   \
    \ precondition(arr.count > 0, \"arr should has count\")\n\n    if k <= 0 || k\
    \ > arr.count {\n        return arr\n    }\n    \n    switch k {\n    case 1,\
    \ 2:\n        return arr\n    case 3:\n        return merge(merge(arr[0..<k -\
    \ 1], arr[k..<arr.count]), arr[k..<k])\n    default:\n        switch k {\n   \
    \     case 4, 5:\n            return merge(arr[0..<k - 1], merge(arr[k..<k - 1],\
    \ arr[k - 2..<k - 1], arr[k - 3..<k - 1]))\n        case 6:\n            return\
    \ merge(arr[0..<k - 1], merge(arr[k..<k - 1], merge(arr[k - 2..<k - 1], arr[k\
    \ - 3..<k - 1], arr[k - 4..<k - 1])))\n        default:\n            var result\
    \ = [Int]()\n            var i = 0\n            var j = 0\n            var k =\
    \ 0\n            var maxNum: Int = 0\n            var maxIndex: Int = 0\n\n  \
    \          for (; i < arr.count; i = j) {\n                if arr[i] > maxNum\
    \ {\n                    maxNum = arr[i]\n                    maxIndex = i\n \
    \               }\n                if arr[j] > maxNum {\n                    maxNum\
    \ = arr[j]\n                    maxIndex = j\n                }\n            \
    \    if maxNum == arr[i] {\n                    result[k] = arr[i]\n         \
    \           k = k + 1\n                    j = j + 1\n                }\n    \
    \        }\n            \n            k = k + 1\n            \n            return\
    \ result\n        }\n    }", "    precondition(k <= arr.count, \"k should be less\
    \ or equal than \\\n    length of arr\")\n    precondition(k >= 0, \"k should\
    \ be less or equal than 0\")\n    if k == 0 || arr == nil || arr.isEmpty {\n \
    \       return []\n    }\n    var max_set = setOf(IntMax)\n    for i in 0..<(arr.count-(k-1))\
    \ {\n        let value = arr[k-1-i]\n        if !max_set.contains(value) {\n \
    \           max_set.insert(value)\n        }\n    }\n    let max_num = max_set.max()\n\
    \    return Array(max_set.filter{$0 != max_num})", "    \n    let len = arr.count\n\
    \    \n    if k == 0 || k > len {\n        return [Int]()\n    }\n    \n    var\
    \ maxK = k\n    \n    var max = -1000\n    \n    for i in 0..<k {\n        if\
    \ arr[i] > max {\n            max = arr[i]\n            maxK = i\n        }\n\
    \    }\n    \n    var result = [Int]()\n    \n    for i in 0..<maxK {\n      \
    \  result.append(arr[i])\n    }\n    \n    return result", "    // \u5229\u7528\
    \u6392\u5E8F\n    var res = IntArray(k, 0)\n    for index in 0..<k {\n       \
    \ res[index] = max(arr[index], arr[k-1])\n    }\n    return res", '    return
    Array(Set(arr)).sorted(by: >)[k..<k]', "    precondition(k <= arr.count, \"Invalid\
    \ arguments\")\n    let len = arr.count\n    var max_arr = Array(repeating: -Int.max,\
    \ count: k)\n    for i in 0..<k {\n        max_arr[i] = arr[i]\n    }\n    var\
    \ i = 1\n    while i < len {\n        if max_arr[i] < arr[i] {\n            max_arr[i]\
    \ = arr[i]\n        }\n        i += 1\n    }\n    return max_arr", "    precondition(0\
    \ <= k && k <= arr.count, \"invalid k\")\n    if arr.count < k {\n        return\
    \ arr\n    }\n    var maximum = [Int](repeating: 0, count: k)\n    for i in 0..<k\
    \ {\n        maximum[i] = max(maximum[i], arr[i])\n    }\n    return maximum",
  "    var result = [Int]()\n    \n    if arr.count < k {\n        return result\n\
    \    }\n    \n    let small = arr.sorted().prefix(k).maxElement()\n    \n    for\
    \ i in small.indices {\n        result.append(arr[i])\n    }\n    \n    return\
    \ result", "    if k == 0 || arr == nil || arr == [] {\n        return arr\n \
    \   }\n\n    var result = [Int](repeating: 0, count: k)\n\n    for index in 0..<arr.count\
    \ {\n        for element in arr {\n            if element > result[index] {\n\
    \                result[index] = element\n            }\n        }\n    }\n\n\
    \    return result", "    assert(k <= arr.count)\n    return Array(arr[Range(1...k)])",
  "    precondition(k <= arr.count, \"k must be greater than or equal to the length\
    \ of the array\")\n    return arr.reduce([Int](), { (prev, cur) -> [Int] in\n\
    \        return prev.sorted {$0 > $1}\n    })[k..<arr.count]", "    precondition(k\
    \ > 0 && k <= arr.count, \"The length of arr should be in range of [1, 1000].\"\
    )\n    let result = Array(repeating: 0, count: k)\n    \n    arr.enumerate().sorted(by:\
    \ { (x, y) in y! > x! }).enumerated().forEach { (i, index) in\n        if index\
    \ == 0 {\n            result[i] = arr[i]\n        } else {\n            result[i]\
    \ = maxElementInArray(arr[0..<i])\n        }\n    }\n    \n    return result",
  "    ans := make([]Int, k)\n    if k > len(arr) || k < 1 {\n        return ans\n\
    \    }\n    for _, val := range arr {\n        if val > ans[k] {\n           \
    \ ans[k] = val\n        }\n    }\n    return ans", "    precondition(k <= arr.count,\
    \ \"k out of range\")\n    precondition(k <= arr.count, \"k out of range\")\n\n\
    \    if k <= 0 {\n        return []\n    }\n\n    var ans = [Int]()\n    var curMax\
    \ = -Int64(arr.count)\n    for el in arr {\n        if el > curMax {\n       \
    \     ans = append(ans, curMax)\n            curMax = el\n        } else {\n \
    \           curMax = el\n        }\n    }\n    ans = append(ans, curMax)\n   \
    \ return ans[0 : k-1]", "    assert(k <= arr.count)\n    \n    // binary search\
    \ on max element in sub-array\n    let startIdx = (arr.count + k - 1) / 2 // midpoint\
    \ of array\n    let endIdx = startIdx + k - 1\n    let maxElem = arr[endIdx]\n\
    \    \n    // Binary search on the max element in the rest of array\n    let maxIdx\
    \ = (startIdx + k - 1) / 2\n    if arr[maxIdx] > maxElem {\n        maxIdx -=\
    \ 1\n    }\n    \n    guard maxIdx == startIdx || arr[maxIdx] > maxElem else {\
    \ return [maxElem] }\n    \n    let lower = [Int](repeating: -1000, count: k)\n\
    \    let upper = [Int](repeating: 1000, count: k)\n    \n    lower.indices.forEach\
    \ { lower.remove(at: $0) }\n    upper.indices.forEach { upper.remove(at: $0) }\n\
    \    \n    // insert the max element\n    upper.insert(arr[maxIdx], at: startIdx)\n\
    \    \n    let result = [Int](repeating: -1000, count: k)\n    \n    for i in\
    \ 0..<k {\n        result[i] = upper[i]\n    }\n    \n    return result.sorted(by:\
    \ { $0 < $1 })", "    precondition(k > 0, \"k should be positive\")\n    precondition(k\
    \ < len(arr), \"k should be less than the length of array\")\n    \n    var result\
    \ = make([]Int, k)\n    for i := 0; i < k; i++ {\n        result[i] = arr[i]\n\
    \    }\n    for i := k; i < len(arr); i++ {\n        result[i] = max(arr[i-k],\
    \ result[i-k]) + arr[i]\n    }\n    return result", '    return Array(arr).sorted(by:
    >).prefix(k)', '    return sort(arr.slice())[:k]', '    return mergeSort(mergeSort(arr,
    k))', "    var res = arr.prefix(k)\n    let maxArray = Array(res)\n    maxArray.sortInPlace()\n\
    \    return maxArray", '    fatalError("not implemented")', "    let res = arr.sorted()[0..<k]\n\
    \    return res", "    precondition(k > 0 && k < len(arr), \"k is out of range\"\
    )\n    \n    // create max array\n    var maxArr = make([]Int, k)\n    \n    //\
    \ initialize max array elements\n    for i := 0; i < k; i++ {\n        maxArr[i]\
    \ = 0\n    }\n    \n    // find max element\n    for i := 0; i < len(arr); i++\
    \ {\n        j := i\n        for ; j < len(arr); j++ {\n            if arr[j]\
    \ > maxArr[j] {\n                j = j + 1\n            }\n        }\n       \
    \ maxArr[i] = arr[j]\n    }\n    \n    return maxArr", "    precondition(k < arr.count)\n\
    \    return arr[k..<arr.count].sorted { $0 > $1 }", '    return Solution.maximum(arr,
    k)', "    \n    var result = [Int]()\n    \n    for a in arr {\n        if result.count\
    \ < k {\n            result.append(a)\n        }\n        else {\n           \
    \ if a > result[result.count - k] {\n                result.removeLast()\n   \
    \             result.append(a)\n            }\n        }\n    }\n    \n    return\
    \ result", "    precondition(k < arr.count, \"k out of range\")\n    var result\
    \ = Array<Int>(repeating: -1000, count: k)\n    for index in range(arr.count)\
    \ {\n        if result[index] > arr[index] {\n            result[index] = arr[index]\n\
    \        }\n    }\n    return result", "    var result = [0] * (k+1)\n    for\
    \ i := 1; i <= k; i++ {\n        result[i] = max(arr[i-1], arr[i])\n    }\n  \
    \  for i := k+1; i <= len(arr); i++ {\n        result[i] = max(arr[i-1], arr[i])\n\
    \    }\n    return result[0:k+1]", '    return arr.reduce(into: [Int](), {$0[$0.startIndex..<$0.endIndex]}){$0
    ~= $0[$0.startIndex..<$0.endIndex].max()}.sorted()[0..<k]', "    // base case\n\
    \    if k == 0 || len(arr) <= k {\n        return [arr[0]]\n    }\n    // recursion\n\
    \    var maxs = [Int]()\n    var max = [Int]()\n    for x in arr {\n        if\
    \ x <= 0 {\n            continue\n        }\n        if maxs.count >= k {\n  \
    \          maxs = maxs.dropFirst()\n        }\n        if x < maxs[0] {\n    \
    \        max[0] = x\n        } else if x > maxs[1] {\n            max[1] = x\n\
    \        }\n        maxs.append(x)\n    }\n    return max", "    precondition(k\
    \ > 0, \"k must be greater than zero\")\n    precondition(k < arr.count, \"k must\
    \ be less than or equal to array length\")\n    let len = arr.count\n    var max\
    \ = arr[0]\n    arr.sort(by: <)\n    for index in 1..k {\n        if arr[index]\
    \ > max {\n            max = arr[index]\n        }\n    }\n    return Array(arr[k..<len]).sorted(by:\
    \ <)", "    precondition(arr.count >= k, \"The length of the array should be in\
    \ the range of [1, 1000].\");\n    precondition(k <= arr.count, \"k should be\
    \ in the range of [0, len(arr)).\");\n\n    if k == 0 {\n        return arr\n\
    \    }\n    \n    var maxArr = [Int](repeating: -1000, count: k);\n    \n    for\
    \ i in 0..<k {\n        maxArr[i] = arr[i] > maxArr[i] ? arr[i] : maxArr[i]\n\
    \    }\n    \n    for i in 0..<k {\n        if arr[i] > maxArr[k-1] {\n      \
    \      maxArr[k-1] = arr[i]\n        }\n    }\n    \n    return maxArr", "   \
    \ return Array(zip(Array(0..<k).sorted(), arr))\n        .filter{_._1 > _._2}.map{_._2}",
  "    \n    let count = (arr as NSArray).count\n    \n    if count == 0 { return\
    \ [] }\n    \n    let maxNum = arr.reduce(0, combine: { (prev, cur) -> Int in\n\
    \        let curInt = (cur as NSNumber).integerValue\n        return max(prev,\
    \ curInt)\n    })\n    \n    let maxArr = [Int](count: count, repeatedValue: maxNum)\n\
    \    \n    var maxCount = 0\n    for i in 0..<count {\n        let curInt = (arr[i]\
    \ as NSNumber).integerValue\n        if curInt == maxNum {\n            maxCount\
    \ += 1\n            maxArr[i] = curInt\n        }\n    }\n    \n    let leftOver\
    \ = k - maxCount\n    if leftOver > 0 { maxArr.append(contentsOf: [Int](count:\
    \ leftOver, repeatedValue: 0)) }\n    \n    return maxArr", '    return Array(Set(arr).sorted(by:
    >))[k..<k]', "    if k < 1 || k > len(arr) {\n        return nil\n    }\n\n  \
    \  let result = [Int]()\n    var currentMax = arr[0]\n    for i in 1..<k {\n \
    \       if currentMax < arr[i] {\n            currentMax = arr[i]\n        }\n\
    \        result.append(currentMax)\n    }\n    return result", "    var result\
    \ = [Int]()\n    for num in arr {\n        if k <= 0 || num > result[k-1] {\n\
    \            result.append(num)\n        }\n    }\n    return result", "    precondition(k\
    \ <= arr.count, \"k should at most have same length as arr\")\n\n    // use sortInPlace()\
    \ to keep the original array intact\n    let sortedArr = arr.sortInPlace()\n \
    \   if arr.count > k {\n        return sortedArr[k..<arr.count]\n    }\n\n   \
    \ return sortedArr", "    if k == 0 || arr == nil || arr.count <= 0 {\n      \
    \  return nil\n    }\n    if k <= arr.count {\n        return Array(arr[k..<arr.count])\n\
    \    }\n    \n    var result = Array(k + 1)\n    for index in 0..<k {\n      \
    \  var maxIndex = index\n        for element in  arr[index..<arr.count] {\n  \
    \          if element > result[maxIndex] {\n                maxIndex = index\n\
    \            }\n        }\n        result[index] = arr[maxIndex]\n    }\n    return\
    \ result", "    precondition(k < arr.count, \"k is out of bounds\")\n    var max\
    \ = [Int](repeating: 0, count: k)\n    var largestIndex: Int = -1\n    for i in\
    \ 0..<k {\n        if arr[i] > max[k-1] {\n            max[k] = arr[i]\n     \
    \       largestIndex = i\n        }\n    }\n    for i in 0..<k {\n        if arr[i]\
    \ > max[k] {\n            max[k] = arr[i]\n        }\n    }\n    max[largestIndex]\
    \ = arr[largestIndex]\n    return max", "    var result = [Int]()\n    for indexValue\
    \ in arr.reverse() {\n        result.insert(indexValue, indexValue)\n    }\n \
    \   result.removeLast()\n    result.sort{$0 > $1}\n    if result.count > k {\n\
    \        return arr[k..<result.count]\n    }\n    return arr", "    // \u786E\u4FDD\
    \u6570\u7EC4\u5927\u5C0F\u4E3A\u4E00\u5B9A\u8303\u56F4\u5185\uFF0C\u5C0F\u4E8E\
    \u7B49\u4E8E1000\n    if arr.count < 1 || arr.count > 1000 {\n        return arr\n\
    \    }\n\n    if k <= 0 || k >= arr.count {\n        return arr\n    }\n\n   \
    \ // \u6309\u7167\u4ECE\u5927\u5230\u5C0F\u7684\u987A\u5E8F\u6392\u5E8F\n    guard\
    \ let array = arr.reduce([Int]()) { $0.sorted(<)\n    guard let maxValue = max(array)\
    \ else {\n        return array\n    }\n\n    var result = [Int]()\n    var pos\
    \ = 0\n    \n    for element in array {\n        guard pos <= k else {\n     \
    \       result.append(element)\n            break\n        }\n        \n     \
    \   if element == maxValue {\n            result.append(element)\n           \
    \ pos += 1\n        }\n    }\n    \n    return result", "    \n    precondition(0\
    \ <= k, \"The k element must be in between 0 and \\(arr.count)\")\n    precondition(k\
    \ <= arr.count, \"The k element must be in between 0 and \\(arr.count)\")\n  \
    \  \n    // Add k to arr\n    let arr = arr + [k]\n    \n    // Sort arr\n   \
    \ arr.sort()\n    \n    // Get maximum k elements from arr\n    return Array(arr[k..<arr.count])",
  "  if arr == [] {\n    return arr\n  }\n  \n  var result = [Int]()\n  \n  for item\
    \ in arr {\n    result.append(item)\n    if result.count > k {\n      result.removeLast()\n\
    \    }\n  }\n  \n  return result", "    // Write your code here\n    \n    return\
    \ arr", "    func max(num: Int, i: Int, n: Int) -> Int {\n        if num > n {\n\
    \            return num\n        }\n        return i\n    }\n    if k == 1 {\n\
    \        return arr\n    }\n    if k == len(arr) {\n        return arr\n    }\n\
    \    let nums = arr[k - 1]\n    arr.removeLast()\n    if k == 2 {\n        return\
    \ max(nums, arr[0], arr[k - 1])\n    }\n    if arr[k-1] > nums {\n        return\
    \ arr\n    }\n    return arr[k - 1]\n        .map({ max(nums, $0, k - 1) })\n\
    \        .reduce([Int]()) { $0 + [$1] + [$0] }", "    precondition(k <= arr.count,\
    \ \"k should be less than or equal to the length of the array\")\n    \n    let\
    \ resultMax = arr.reduce(Int.min, { x, y in\n        return if x >= y {x} else\
    \ {y}\n    })\n    let resultMin = arr.reduce(Int.max, { x, y in\n        return\
    \ if x <= y {x} else {y}\n    })\n    if resultMin > resultMax {\n        var\
    \ temp = [Int]()\n        for i in 1...k {\n            temp.append(arr[i])\n\
    \        }\n        return temp\n    } else {\n        var temp = [Int]()\n  \
    \      for i in 1...k {\n            temp.append(arr[i])\n        }\n        \n\
    \        for i in 0..k-1 {\n            if arr[i] == resultMin {\n           \
    \     temp.removeAtIndex(i)\n            }\n        }\n        return temp\n \
    \   }", "    // code here\n    let arr = arr\n    let count = arr.count\n    var\
    \ maximums = [Int]()\n    if k == 0 || count <= k {\n        return arr\n    }\n\
    \    \n    var maximum = arr[0]\n    for i in 1..<k {\n        if arr[i] > maximum\
    \ {\n            maximum = arr[i]\n        }\n    }\n    maximums.append(maximum)\n\
    \    \n    for _ in 1..<k-1 {\n        var i = 0\n        for j in 0..<count {\n\
    \            if arr[i] > maximums[j] {\n                maximums[j] = arr[i]\n\
    \            }\n            i += 1\n        }\n    }\n    \n    return maximums",
  "    \n    let n = arr.count\n    \n    guard n >= 1 && n <= 1000 else {\n     \
    \   return arr\n    }\n    \n    var max = [Int]()\n    \n    if n == 1 {\n  \
    \      return arr\n    }\n    \n    if k > n {\n        k = n\n    }\n    \n \
    \   for i in 0..<k {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n\
    \        }\n    }\n    \n    for i in 1..<n {\n        if arr[i] > max[0] {\n\
    \            max[0] = arr[i]\n        }\n    }\n    \n    for i in 0..<k {\n \
    \       if arr[i] > max[1] {\n            max[1] = arr[i]\n        }\n    }\n\
    \    \n    return max", "    precondition(k < arr.count, \"len(arr) must be >=\
    \ k\")\n    var result = Array<Int>(repeating: Int.max,\n                    \
    \        count: k+1)\n    \n    for i in 0..<k {\n        result[i] = max(arr[i],\
    \ result[i-k])\n    }\n    \n    result[k] = arr[k]\n    \n    return result",
  "    if k > arr.count {\n        return nil\n    }\n    \n    var max: [Int] = []\n\
    \    var i = 0\n    var curMax: Int = arr[i]\n    for index in 1...k {\n     \
    \   if arr[i] > curMax {\n            i = index\n            curMax = arr[i]\n\
    \        }\n    }\n    \n    max = [curMax] + max\n    return max", "    precondition(k\
    \ <= arr.count)\n    var max = -math.infinity\n    var result = [Int]()\n    for\
    \ el in arr {\n        if el > max {\n            max = el\n        } else {\n\
    \            append(result, max)\n            if arr.count > 1 {\n           \
    \     max += arr.last!\n            } else {\n                max = arr[0]\n \
    \           }\n        }\n    }\n    append(result, max)\n    return result.sorted(by:\
    \ { $0 > $1 })", "    let result = Array(repeating: 0, count: k)\n    for elem\
    \ in arr {\n        result[result.index(of: elem)!] = elem\n    }\n    return\
    \ result.sorted()", '    return sortSliceByKey(arr, &k)', '    return sort(arr,
    0, arr.count-1, k)', "\tif k == 0 || arr.isEmpty() { return arr }\n\t\n\tarr.sortInPlace()\n\
    \t\n\treturn arr[k..<arr.count]", "    if arr.isEmpty {\n        return []\n \
    \   }\n    var max: [Int] = [0]\n    var i = 0\n    while i < arr.count {\n  \
    \      if arr[i] > max[0] {\n            max[0] = arr[i]\n        } else if arr[i]\
    \ >= max[0] {\n            max[1] = max[0]\n            max[0] = arr[i]\n    \
    \    } else {\n            i += 1\n        }\n    }\n    return max[0 ..< k].sorted()",
  '    return sort(arr, nil, k, true, func(x, y Int) -> Bool { return x <= y })',
  "    precondition(arr.count >= k, \"Array length must be larger than or equal to\
    \ k\")\n    var max = [Int](repeating: -Int.max, count: k)\n    for num in arr\
    \ {\n        if num > max[k-1] {\n            max[k-1] = num\n        }\n    }\n\
    \    return max", "    precondition(k <= arr.count, \"Invalid argument: k\")\n\
    \    precondition(k <= 1000, \"Invalid argument: k\")\n    if k == 1 {\n     \
    \   return arr\n    }\n    \n    var maxIndex = 0\n    var maxValue = -1000\n\n\
    \    for i in 0 ..< arr.count {\n        if arr[i] > maxValue {\n            maxValue\
    \ = arr[i]\n            maxIndex = i\n        }\n    }\n\n    var res = make([]Int,\
    \ k)\n    res[maxIndex] = maxValue\n    return res", "    let result = Array(repeating:\
    \ -1, count: k)\n    var maxSoFar = 0\n    var maximumIndex = -1\n\n    for i\
    \ in 0..<arr.count {\n        if result[i] < 0 && arr[i] > maxSoFar {\n      \
    \      maxSoFar = arr[i]\n            maximumIndex = i\n        } else if arr[i]\
    \ > maxSoFar {\n            result[i] = arr[i]\n        }\n    }\n\n    return\
    \ result[..<maximumIndex]", "    precondition(k <= arr.count, \"k must be less\
    \ than or equal to arr's count\")\n    \n    var maxs = [Int](repeating: -1000,\
    \ count: k)\n    var maxIndex = 0\n    \n    for i in 0..<arr.count {\n      \
    \  if arr[i] > maxs[maxIndex] {\n            maxs[maxIndex] = arr[i]\n       \
    \     maxIndex += 1\n        }\n    }\n    \n    return maxs", "    if arr.isEmpty\
    \ {\n        return []\n    }\n    \n    // \u4F7F\u7528Heapq to find the max\n\
    \    var maxHeap = [Int](repeating: 0, count: k)\n    for i in 0..<k {\n     \
    \   maxHeap[i] = arr[i]\n    }\n    \n    var index = 1\n    \n    var max = arr[0]\n\
    \    \n    for element in arr {\n        guard max < element else {\n        \
    \    return\n        }\n        \n        if index == k {\n            break\n\
    \        }\n        \n        maxHeap[index] = element\n        index = index\
    \ + 1\n        max = element\n    }\n    \n    // \u5BF9Heapq\u4E2D\u7684\u6570\
    \u636E\u8FDB\u884C\u6392\u5E8F\n    for i in 0..<k {\n        if maxHeap[i] >\
    \ maxHeap[k - 1] {\n            swap(&maxHeap[k - 1], &maxHeap[i])\n        }\n\
    \    }\n    \n    return maxHeap", "    var result = [Int](repeating: 0, count:\
    \ k)\n    var largest = 0\n    for n in arr {\n        if n > largest {\n    \
    \        largest = n\n        }\n    }\n    for n in arr {\n        if n > largest\
    \ && result.count < k {\n            result[result.count] = n\n            result.count\
    \ += 1\n        }\n    }\n    result.reduce(0, +)\n    if result.count < k {\n\
    \        result = result[k..<result.count]\n    }\n    return result", "    precondition(0\
    \ <= k && k <= arr.count, \"index out of range\")\n    if k == 0 { return arr\
    \ }\n    if k == 1 {\n        return max(arr, compare: >)\n    }\n    var largest\
    \ = arr[0]\n    var idx = 1\n    for current in arr {\n        if current > largest\
    \ {\n            largest = current\n        }\n        if current > largest &&\
    \ k >= idx {\n            largest = current\n        }\n        if k == idx {\n\
    \            break\n        }\n        idx += 1\n    }\n    if k == idx {\n  \
    \      return arr\n    }\n    return arr[k...idx] + largest", '  return ArraySlice(arr).sorted().prefix(k)',
  "    precondition(k <= arr.count, \"Parameter k should satisfy 0 <= k <= arr.count\"\
    )\n    \n    let max_so_far = arr[0]\n    let max_remaining = arr.dropFirst()\n\
    \    \n    var result = [Int]()\n    \n    for i in max_remaining.reversed() {\n\
    \        if i > max_so_far {\n            result.append(max_so_far)\n        }\
    \ else {\n            result.append(i)\n        }\n    }\n    \n    result.append(max_so_far)\n\
    \    \n    return Array(result)", "    if k == 0 || len(arr) <= k {\n        return\
    \ arr\n    }\n    \n    // O(n) time and O(n) space\n    let maxIndex = k - 1\n\
    \    var maxVal = -math.pow(Int.max, Int64(maxIndex))\n    var result : [Int]\
    \ = []\n    \n    for idx in 0..<k {\n        let element = arr[idx]\n       \
    \ if element > maxVal {\n            maxVal = element\n            maxIndex =\
    \ idx\n        }\n    }\n    \n    for idx in 0..<k {\n        let element = arr[idx]\n\
    \        if element == maxVal {\n            result.append(element)\n        }\n\
    \    }\n    \n    return Array(result)", "    var maxVal = arr[0]\n    var maxIdx\
    \ = 0\n    for idx : Int in 1..<arr.count {\n        if arr[idx] > maxVal {\n\
    \            maxVal = arr[idx]\n            maxIdx = idx\n        }\n    }\n \
    \   return maxIdx ..< maxIdx + k - 1 // inclusive", "    if k < 0 {\n        print(\"\
    k is out of range\")\n    }\n    \n    if arr.isEmpty() {\n        return nil\n\
    \    }\n    \n    if k > arr.count {\n        print(\"k is out of range\")\n \
    \   }\n    \n    \n    var max = -math.MinInt\n    var result : [Int] = []\n \
    \   for element in arr {\n        if element > max {\n            max = element\n\
    \        }\n    }\n    \n    for element in arr {\n        if element == max {\n\
    \            result.append(element)\n        }\n    }\n    \n    \n    \n    return\
    \ result", "    var result = [Int]()\n    var curMax = arr[0]\n    for i in arr\
    \ {\n        if i > curMax {\n            curMax = i\n        }\n    }\n    if\
    \ k <= curMax {\n        return result\n    }\n    var maxIdx = 0\n    var maxValue\
    \ = curMax\n    for i : Int in 0..<k {\n        for j : Int in 0..<result.count\
    \ {\n            if result[j] > maxValue {\n                maxValue = result[j]\n\
    \                maxIdx = j\n            }\n        }\n        result[maxIdx]\
    \ = arr[i]\n    }\n    return result", "    precondition(k <= arr.count, \"k should\
    \ be less than or equal to the length of arr\")\n    precondition(arr.count >=\
    \ 1, \"arr should have at least one element\")\n\n    if k == 1 {\n        return\
    \ arr\n    }\n\n    let result = [Int](repeating: 0, count: k - 1)\n    for index\
    \ in 0..<result.count {\n        let max = arr[index] as Int\n        for i in\
    \ index+1..<arr.count {\n            if arr[i] > max {\n                max =\
    \ arr[i]\n                result[index] = max\n            }\n        }\n    }\n\
    \n    return result", "    if k == 0 || k == 1 {\n        return arr\n    }\n\
    \    if k == len(arr) {\n        return arr\n    }\n    var res = [Int]()\n  \
    \  var index = 0\n    var max = [Int]()\n    var maxIndex = -1\n    var maxIndex2\
    \ = -1\n    var index2 = 0\n    var max2 = 0\n    for element in arr {\n     \
    \   if index2 == k {\n            if element>max2 {\n                max2 = element\n\
    \                maxIndex2 = index2\n            }\n            index += 1\n \
    \           max[maxIndex2] = element\n            maxIndex2 += 1\n           \
    \ max2 = 0\n            index2 = 0\n        } else {\n            if element >\
    \ max[index2] {\n                max[index2] = element\n                index2\
    \ += 1\n            }\n        }\n    }\n    if maxIndex2 != k {\n        if max2\
    \ > max[maxIndex2] {\n            index = maxIndex2 + 1\n        }\n    }\n  \
    \  for element in arr {\n        if index == k {\n            if element > max2\
    \ {\n                max2 = element\n                maxIndex2 = index\n     \
    \       }\n            index += 1\n            max[maxIndex2] = element\n    \
    \        maxIndex2 += 1\n            max2 = 0\n            index2 = 0\n      \
    \  } else {\n            if element > max[index2] {\n                max[index2]\
    \ = element\n                index2 += 1\n            }\n        }\n    }\n  \
    \  if maxIndex2 != k {\n        if max2 > max[maxIndex2] {\n            index\
    \ = maxIndex2 + 1\n        }\n    }\n    res.append(max[maxIndex2])\n    \n  \
    \  if maxIndex != k {\n        if maxIndex == k {\n            index = maxIndex\
    \ + 1\n        }\n        if maxIndex == k {\n            index = maxIndex - 1\n\
    \        }\n        for element in arr {\n            if index == k {\n      \
    \          if element > max2 {\n                    max2 = element\n         \
    \           maxIndex2 = index\n                }\n                index += 1\n\
    \                max[maxIndex2] = element\n                maxIndex2 += 1\n  \
    \              max2 = 0\n                index2 = 0\n            } else {\n  \
    \              if element > max[index2] {\n                    max[index2] = element\n\
    \                    index2 += 1\n                }\n            }\n        }\n\
    \        if maxIndex2 != k {\n            if max2 > max[maxIndex2] {\n       \
    \         index = maxIndex2 + 1\n            }\n        }\n        res.append(max[maxIndex2])\n\
    \    }\n    return res", "    precondition(\n        k <= arr.count, \n      \
    \  \"The input k \\(k)  must not exceed the length of the array \\(arr.count)\"\
    )\n\n    var max = -1 * Int(MIN_BOUND)\n    for x in arr {\n        if x < max\
    \ {\n            continue\n        }\n        max = x\n    }\n    \n    var result\
    \ = [Int](repeating: -Int, count: k)\n    for x in arr {\n        if x > max {\n\
    \            continue\n        }\n        result[x - max] = x\n    }\n\n    return\
    \ result", "    precondition(k <= arr.count, \"k is out of bounds\")\n    \n \
    \   var maxElement: [Int] = []\n    \n    for index in 0 ..< k {\n        let\
    \ element = max(arr[index], arr[index+1])\n        maxElement.append(element)\n\
    \    }\n    \n    return maxElement", "    if k <= 0 || k > min(arr.count, k)\
    \ {\n        return []\n    }\n    \n    guard arr.count >= k else {\n       \
    \ return arr\n    }\n    \n    var maxArr = make(ArraySlice, k, k)\n    \n   \
    \ for i in 0 ..< k {\n        maxArr[i] = arr[i]\n    }\n    \n    maxArr.sortInPlace()\n\
    \    \n    return maxArr", "    guard 0 <= k <= arr.count else { return [] }\n\
    \    \n    var maximums = [Int](repeating: -1, count: k)\n    \n    for i in 0..<arr.count\
    \ {\n        let current = arr[i]\n        \n        if maximums[current] == -1\
    \ {\n            maximums[current] = i\n        } else {\n            if maximums[current]\
    \ != i {\n                maximums[current] = i\n            }\n        }\n  \
    \  }\n    \n    var result: [Int] = []\n    \n    for i in 0..<k {\n        result.append(maximums[arr[i]])\n\
    \    }\n    \n    return result", '    return Array(heap.PrefixMax(arr, k))',
  "    guard k > 0 && k <= arr.count else { return [] }\n    \n    var result = Array(repeating:\
    \ arr[0], count: k)\n    \n    for i in 1...arr.count {\n        if arr[i] > result[result.count\
    \ - k] {\n            result[result.count - k] = arr[i]\n        }\n    }\n  \
    \  \n    return result", '    return removeDuplicates(arr, k, true)', "    precondition(0\
    \ <= k <= arr.count)\n    if k == 0 {\n        return arr\n    }\n    if k ==\
    \ 1 {\n        return max(arr)\n    }\n    var maxs = [Int]()\n    var i = k -\
    \ 1\n    for index in 0..<arr.count {\n        if arr[index] > arr[i] {\n    \
    \        i += 1\n        }\n        if i == k {\n            maxs.append(arr[i])\n\
    \            i -= 1\n        } else {\n            maxs.append(arr[i])\n     \
    \   }\n    }\n    return maxs", "    if k == 0 || arr == nil || arr.isEmpty {\n\
    \        return arr\n    }\n    \n    let arr = arr.sorted()\n    var maxArr =\
    \ [Int](repeating: 0, count: k)\n    \n    for element in arr {\n        maxArr[0]\
    \ = max(maxArr[0], element)\n        if maxArr.count >= k {\n            break\n\
    \        }\n    }\n    \n    return maxArr", "    var max = -1000\n    var ans\
    \ = [Int]()\n    for x in arr {\n        if x > max {\n            max = x\n \
    \       }\n        if x > -k && k <= arr.count {\n            ans.append(x)\n\
    \        }\n    }\n    return ans", "    if k <= 0 || len(arr) <= k {\n      \
    \  return []\n    }\n    \n    var maxs = make([]Int, k)\n    \n    for i := 0;\
    \ i < k; i++ {\n        maxs[i] = max(arr[0], arr[i])\n    }\n    \n    for i\
    \ := 1; i < len(arr); i++ {\n        maxs[i] = max(maxs[i], arr[i])\n    }\n \
    \   \n    return maxs", '    return removeDuplicates(append(maximum1(arr), maximum2(arr,
    k)), k)', "    if k > len(arr) { return [] }\n    \n    let max = arr[0]\n   \
    \ for i in 1...k { max = max(max, arr[i]) }\n    \n    let result = [max]\n  \
    \  if k <= arr.count { result.insert(arr.last, at: k - 1) }\n    return result",
  "    guard 0 <= k <= arr.count else { return [] }\n    var result = [Int](repeating:\
    \ 0, count: k+1)\n    for i in 0..<arr.count {\n        if result[k] > arr[i]\
    \ { result[k+1] = arr[i] }\n    }\n    return result", "    precondition(k > 0,\
    \ \"k must be positive integer\")\n    var max = [Int]()\n    var i = 1\n    var\
    \ maxIndex = 0\n    while i <= k {\n        if arr[i] > max {\n            max\
    \ = arr[i]\n            maxIndex = i\n        }\n        i += 1\n    }\n    return\
    \ max", "    if k <= 0 || len(arr) < k {\n        return []\n    }\n    \n   \
    \ var result = [Int]()\n    for ele in arr {\n        let idx = result.index(of:\
    \ ele)\n        if idx != nil {\n            result.remove(at: idx!)\n       \
    \ }\n        \n        if result.count == k {\n            return result\n   \
    \     }\n    }\n    \n    return result", "    if k > len(arr) || k == 0 || len(arr)\
    \ == 0 {\n        return []\n    }\n    \n    var maxHeap: [Int] = []\n    \n\
    \    var heap = arr\n    for _ in 1...k {\n        maxHeap = append(maxHeap, heap[0])\n\
    \        heap = heap[1..<len(heap)]\n    }\n    maxHeap = append(maxHeap, heap[0])\n\
    \    \n    return maxHeap", '  return sort(arr).prefix(k)', "    var result =\
    \ Array<Int>()\n    var max = -1000\n    \n    for i in 0..<k {\n        if arr[i]\
    \ > max {\n            max = arr[i]\n        }\n    }\n    \n    for n in arr\
    \ {\n        if n > max {\n            max = n\n        }\n    }\n    \n    result.appendContentsOf(arr[0\
    \ ..< Int(ceil(Double(k)*(Double(max)-Double(arr[0]))))])\n    \n    return result.sorted(by:\
    \ { $0 > $1 })"]
stop_tokens:
- "\n}"
