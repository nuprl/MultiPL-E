name: HumanEval_65_circular_shift
language: swift
prompt: "\n/// Circular shift the digits of the integer x, shift the digits right\
  \ by shift\n/// and return the result as a string.\n/// If shift > number of digits,\
  \ return digits reversed.\n/// >>> circular_shift(x: 12, shift: 1)\n/// \"21\"\n\
  /// >>> circular_shift(x: 12, shift: 2)\n/// \"12\"\nfunc circular_shift(x: Int,\
  \ shift: Int) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(circular_shift(x: 100, shift: 2) == \"001\"\
  )\nassert(circular_shift(x: 12, shift: 2) == \"12\")\nassert(circular_shift(x: 97,\
  \ shift: 8) == \"79\")\nassert(circular_shift(x: 12, shift: 1) == \"21\")\nassert(circular_shift(x:\
  \ 11, shift: 101) == \"11\")"
completions: ["    var radix = 10, digitsLeft = x.toInt()\n    var digits = String()\n\
    \n    repeat {\n        digits = String(digitsLeft%radix) + digits\n        radix\
    \ /= 10\n        digitsLeft /= 10\n    } while digitsLeft > 0\n\n    // Rotate\
    \ digits until we are left with the correct number of digits\n    var result =\
    \ digits[0..<shift].reversed()\n    var shiftDigits = shift % digits.count\n \
    \   var extraDigits = digits.count - shiftDigits\n\n    if extraDigits > 0 {\n\
    \        result = result + String(digitsLeft % radix)\n        shiftDigits--\n\
    \    }\n\n    return result + digits[0..<shiftDigits]", "    var reversed: String\
    \ = \"\"\n    var result = \"\"\n    for digit in x {\n        reversed = String(digit)\
    \ + reversed\n    }\n    for _ in 0..(shift - reversed.count) {\n        reversed\
    \ = reversed[:reversed.count - 1] + reversed[reversed.count - 1]\n    }\n    for\
    \ _ in 0..(shift - reversed.count) {\n        result = reversed + result\n   \
    \ }\n    return result", "    let digits = x.digitsAsString()\n    if shift ==\
    \ 0 || shift >= x.count { return digits }\n    return String(digits[0..(shift)..<x.count])",
  "    if shift > len(x)-1 {\n        return reverse(string(x))\n    }\n\n    var\
    \ digits : String = string(x)\n    var shift = shift + len(digits)\n    var ret\
    \ = \"\"\n    for i : Int in stride(from: shift, through: 0, by: -1) {\n     \
    \   ret += digits[i]\n    }\n    return ret", "    let result = String(x)\n  \
    \  if shift > result.characters.count {\n        result = String(result.characters.dropLast())\n\
    \    }\n    result.characters.reverse()\n    result.characters.insert(result.characters.startIndex,\
    \ UInt8(shift))\n    return String(result)", "\tvar digits = \"\"\n\tvar shiftDigits\
    \ = shift\n\t\n\twhile x > 0 {\n\t\tif shiftDigits > 10 {\n\t\t\tdigits += String(Int(x/10)\
    \ % 10)\n\t\t\tshiftDigits -= 10\n\t\t}\n\t\tdigits += String(x % 10)\n\t\tx /=\
    \ 10\n\t}\n\t\n\tif shiftDigits > 0 {\n\t\tdigits += String(shiftDigits % 10)\n\
    \t}\n\treturn digits", '    return String(x.toIntRadix(64) >> shift)', '    return
    String(x.shifted_right_by(shift))', "    let n = x.uint64\n    let s = shift %\
    \ 64\n    let t = (n << s).wrapping_sub((n >> s).wrapping_mul(64))\n    return\
    \ format64(t) ?? \"0\"", "\treturn string(x)[shift:] + string(x)[:shift]", " \
    \   x >>= shift\n    var result = \"\"\n    for i = 0; i < shift; i++ {\n    \
    \    result = String(x % 10) + result\n        x = x >> 1\n    }\n    return result",
  "    // use x's length\n    var x_len = x.sigDigits()\n    if shift > x_len {\n\
    \        return x.str[x_len-shift-1...x_len]\n    }\n    var r = \"\"\n    for\
    \ i := 0; i < x_len; i++ {\n        if i < (x_len - shift) {\n            r +=\
    \ String(Int(x>>(shift)&1) + Int(x>>(shift+1)&1))\n        } else {\n        \
    \    r += String(Int(x>>(shift)&1))\n        }\n    }\n    return r", '    return
    String(x.reversed().prefix(shift)).reversed()', "    if shift > x.count {\n  \
    \      return String(x.reversed())\n    }\n    var buffer = [Character](repeating:\
    \ Character(\"0\"), count: x.count - shift)\n    var index = x.count\n    var\
    \ carry = 0\n    for i in x.unicodeScalars {\n        let digit = i / 16\n   \
    \     buffer[index % buffer.count] = digit.toString(radix: 16) + carry\n     \
    \   carry = digit % 16\n        index -= 1\n    }\n    if carry > 0 {\n      \
    \  buffer[index % buffer.count] = carry\n        carry = 0\n    }\n    return\
    \ String(buffer)", "    let digits = x.digits()\n    let size = digits.size\n\
    \    if shift >= size {\n        return digits.reversed()\n    }\n    if shift\
    \ > 0 {\n        return digits.reversed().prefix(shift).joinWithSeparator(\"\"\
    )\n    }\n    return digits.prefix(shift).joinWithSeparator(\"\")", '    return
    String(x.bitwiseShiftRight(shift))', "    var result = 0\n    for _ in 0..<shift\
    \ {\n        result = 10 * result + x\n    }\n    result %= 100000000000\n   \
    \ return result >= 10\n        ? result - 100000000000\n        : String(result)",
  "    if shift < 0 {\n        return x.toString(radix: 0, reversed: true)\n    }\n\
    \    var result: String = x.toString(radix: 0, reversed: true)\n    \n    if shift\
    \ >= result.characters.count {\n        return result\n    }\n    \n    for _\
    \ in 0 ..< shift {\n        swap(&result, &result, 1)\n    }\n    return result",
  "    switch shift {\n    case 0:\n        return x.toString()\n    case 1:\n   \
    \     return x\n    default:\n        var reversed = \"\"\n        for c in x.unicodeScalars\
    \ {\n            var remainder = c % shift\n            if remainder > 0 {\n \
    \               reversed += \"0\"\n            }\n            remainder /= shift\n\
    \            c /= shift\n            c %= shift\n            reversed = Character(UInt32(reversed\
    \ + UInt32(c))).unicodeScalars.reversed()! + reversed\n        }\n        return\
    \ reversed\n    }", "    var s = String(x)\n    for _ in 0..<shift {\n       \
    \ s = String(Int(Int64(Int64(s)) >> Int64(shift)))\n    }\n    return s", "  \
    \  if shift < 0 {\n        shift = -shift\n    }\n    var reversed = 0\n    for\
    \ digit := x; digit != 0; digit /= 10 {\n        reversed++\n    }\n    var result\
    \ = reversed\n    for i := 0; i < shift; i++ {\n        result = result*10 + digit%10\n\
    \        digit = digit/10\n    }\n    return String(result)", "    var result\
    \ = \"\"\n    var carry = 0\n    for n > 0 {\n        let digit = n % 10\n   \
    \     n /= 10\n        if digit == 0 {\n            result += String(digit)\n\
    \            carry = 0\n        } else {\n            result += \"0\"\n      \
    \      carry = 1\n        }\n    }\n    if carry > 0 {\n        result += \"1\"\
    \n    }\n    return String(result)", "\tlet len = strlen(x)\n\tif shift > len\
    \ - 1 {\n\t\tlet reverse = reverseString(x)\n\t\tx = reverse.characters\n\t\t\
    shift--\n\t}\n\tlet start = 0\n\tlet end = len\n\tlet result = String()\n\tlet\
    \ base = len\n\twhile start < end {\n\t\tlet mid = (start + end) / 2\n\t\tif mid\
    \ > base {\n\t\t\tbreak\n\t\t}\n\t\tif x[mid] >= '0' && x[mid] <= '9' {\n\t\t\t\
    let i = mid - base\n\t\t\tresult.append(String(x[i..<min(mid + 1, len - 1)]))\n\
    \t\t}\n\t\tstart = mid + 1\n\t}\n\treturn result.reversed()", "\treturn str(x>>shift)",
  "  let m = x.toInt()\n  return String(x >> shift).reversed()", "    let str = x.toString(radix:\
    \ 2)\n    let length = str.count\n    return str.characters.reversed().prefix(length).reversed().joinWithSeparator(\"\
    \") + str[str.startIndex.advancedBy(-shift)]", "    var out = String()\n    for\
    \ i = 0; i < shift; i++ {\n        if shift < 0 {\n            out = append(out,\
    \ x[shift..<0])\n            shift = -shift\n        } else {\n            out\
    \ = append(out, x[0..<shift..<0])\n            shift = 0\n        }\n    }\n \
    \   if shift < 0 {\n        out = append(out, x[shift..<0])\n    }\n    return\
    \ out", '    return String(format: "%0" + String(shift) + "d", x)', "    if shift\
    \ > x.trunc().trunc() {\n        return String(x.trunc().trunc())\n    }\n   \
    \ var s = \"\"\n    var n = x\n    for i := 0; i < shift && n > 0; i++ {\n   \
    \     n = n / 10\n    }\n    for i := 0; i < shift; i++ {\n        s = String(n\
    \ % 10) + s\n        n = n / 10\n    }\n    return String(n % 10) + s", "    var\
    \ s = String(format: \"%0\" + String(shift) + \"d\", x)\n    for _ in (0 ..< shift)\
    \ {\n        s = String(x-Int64(string: s)!)\n    }\n    return s", "    switch\
    \ shift {\n    case 0:\n        return String(x)\n    case 1:\n        return\
    \ x\n    case 2:\n        return x[2..<len]\n    case 3:\n        return x[1..<3]\
    \ + x[len..<len + 3]\n    case 4:\n        return x[3..<len] + x[2..<len]\n  \
    \  case 5:\n        return circular_shift(x, shift - 1) + circular_shift(x, shift\
    \ - 2)\n    case 6:\n        return circular_shift(x, shift - 2) + circular_shift(x,\
    \ shift - 3)\n    case 7:\n        return circular_shift(x, shift - 3) + circular_shift(x,\
    \ shift - 4)\n    case 8:\n        return circular_shift(x, shift - 4) + circular_shift(x,\
    \ shift - 5)\n    case 9:\n        return circular_shift(x, shift - 5) + circular_shift(x,\
    \ shift - 6)\n    case 10:\n        return circular_shift(x, shift - 6) + circular_shift(x,\
    \ shift - 7)\n    case 11:\n        return circular_shift(x, shift - 7) + circular_shift(x,\
    \ shift - 8)\n    case 12:\n        return circular_shift(x, shift - 8) + circular_shift(x,\
    \ shift - 9)\n    case 13:\n        return circular_shift(x, shift - 9) + circular_shift(x,\
    \ shift - 10)\n    case 14:\n        return circular_shift(x, shift - 10) + circular_shift(x,\
    \ shift - 11)\n    case 15:\n        return circular_shift(x, shift - 11) + circular_shift(x,\
    \ shift - 12)\n    default:\n        fatalError(\"Too many shifts: \\(shift).\"\
    )\n    }", '    return String(x.reversed().prefix(shift).reversed())', "    var\
    \ result = \"0\"\n    for _ in 0..(shift - x.truncatingRemainder(dividingBy: UInt8(shift))\
    \ + 1) {\n        result = String(format: \"%0*d\", Int(_), x) + result\n    }\n\
    \    return result.reversed()", "  var result: String = String(x & ((1<<(shift\
    \ + 1)) - 1)) + String(x >> shift)\n  if shift < 64 {\n    result = circular_shift(result,\
    \ shift+1)\n  }\n  return result", "    var result = \"\"\n    for digit := 0;\
    \ shift > digit; shift -= digit {\n        result += \"1\"\n    }\n    for digit\
    \ := 0; shift > 0; shift -= digit {\n        result += \"0\"\n    }\n    return\
    \ result + x.toString(10)", "\tlet s = x.toUInt(&radix: 16)\n\tlet shift = shift\
    \ % s.radix\n\treturn String(crashift(s))", "    if shift < 0 {\n        throw\
    \ ArgumentError(\"shift cannot be negative \\(shift)\")\n    }\n    if shift >\
    \ x.bitLength {\n        throw ArgumentError(\"shift cannot be greater than the\
    \ number of bits \\(x.bitLength)\")\n    }\n\n    let size = x.bitLength\n   \
    \ let shift = size + shift\n\n    let digits = x.toFixed(shift).characters.dropLast().map\
    \ { UInt8(bitPattern: $0) }\n    return digits.reverse().reduce(\"\") { $0 + String($1)\
    \ }", "    let s = String(format: \"%d\", x)\n    return s.characters.suffix(Int(s.characters.count\
    \ - shift)..<s.characters.count).reduce(\"\", {$0 + String($1) + String($0)})",
  "    if x < 0 {\n        let neg: Int = -x\n        return circular_shift(neg, shift)\n\
    \    }\n    \n    var result = \"\"\n    var remain = x % 10\n    for _ in 0..shift\
    \ {\n        result += String(remain)\n        remain = remain/10\n    }\n   \
    \ return result + String(remain)", "    let s = String(x)\n    \n    func circShift(char:\
    \ String, shift: Int) -> String {\n        var digit = Character(char)\n     \
    \   let len = s.length\n        \n        if shift > len {\n            return\
    \ digits.reversed()\n        }\n        \n        if shift < 0 {\n           \
    \ shift = shift % len\n        }\n        \n        var result = \"\"\n      \
    \  var count = 0\n        for d in s.characters {\n            if count > shift\
    \ {\n                digit = Character(digit)\n                result += digit\n\
    \                count = 1\n            } else {\n                digit *= 2\n\
    \                result += digit\n                count += 1\n            }\n\
    \        }\n        \n        return result\n    }\n    \n    return circShift(s,\
    \ shift)", "    let (mut digits, mut carry) = (String(x * 10), 0)\n    for i in\
    \ 0..(shift - 1) {\n        digits = digits[..<digits.count] + digits[digits.count\
    \ - digits.count - i + 1] + carry\n        carry = digits % (10 * 10)\n      \
    \  digits = digits / (10 * 10)\n    }\n    return digits[..<digits.count] + carry",
  "  let digits = String(Int(x))\n  \n  if shift > digits.length {\n    return digits.reversed()\n\
    \  }\n  \n  while shift > 0 {\n    if shift > digits.length {\n      digits =\
    \ digits.reversed()\n      shift -= digits.length\n    }\n    digits = digits[0..<digits.length\
    \ - shift] + digits[digits.length - shift..<digits.length]\n    shift -= digits.length\n\
    \  }\n  return digits", "    var remain = shift\n    var result = \"\"\n    while\
    \ remain > 0 {\n        let y = x % 10\n        x /= 10\n        result = String(y)\n\
    \        remain--\n    }\n    return result", "    var result = \"\"\n    for\
    \ i := shift; i > 0; i-- {\n        result = String(format: \"%0*d\", digits(x),\
    \ i)\n    }\n    return result", "    var digits = x.digits\n    var result =\
    \ \"\"\n    for d in digits {\n        var digit = digits[d] - shift\n       \
    \ result += Character(digit)\n        digits[d] = digit\n    }\n    return result",
  "    guard shift < Int(x.bitLength) else {\n        return String(reverse(x))\n\
    \    }\n    if x.isZero {\n        return String(x)\n    }\n    let baseLen =\
    \ x.bitLength\n    var result: Int = Int(x)\n    let numDigits = baseLen\n   \
    \ var shiftRight = Int64(shift % numDigits)\n    if shiftRight == 0 {\n      \
    \  return result\n    }\n    if numDigits > shiftRight {\n        shiftRight =\
    \ numDigits - shiftRight\n    }\n    while shiftRight > 0 {\n        result *=\
    \ baseLen\n        result -= 1\n        result /= baseLen\n        result += shiftRight\n\
    \        result /= numDigits\n        shiftRight -= 1\n    }\n    let result =\
    \ reverse(result).reverse()\n    return result", "    s := String(x)\n    n :=\
    \ s.Length\n    r := n\n    shift %= n\n    s := s[shift : r]\n    return s",
  "    let rem = x\n    for _ in 0..<shift {\n        rem = (rem % 10) + (rem / 10\
    \ % 10)\n    }\n    return String(repeating: \"0\", count: shift - x.truncatingRemainder(dividingBy:\
    \ 10).count)\n        + (if shift < 10 { String(repeating: \"0\", count: shift)\
    \ } else { String(repeating: \"0\", count: 10 - shift) })\n        + (if rem <\
    \ 10 { String(repeating: \"0\", count: rem) } else { String(repeating: \"0\",\
    \ count: 10 - rem) })", "    // Optimization: Use faster type switch if possible.\n\
    \    var s = String(x)\n    s = switch(s.UnicodeScalars) {\n    case .Zero:\n\
    \        return \"\"\n    case .One, .MinusOne:\n        return string(s.Digits.Reverse())\n\
    \    case .Zero, .One, .Two, .Three, .Four, .Five, .Six, .Six, .Nine:\n      \
    \  switch s.Kind() {\n        case .DecimalNumber:\n            // Optimization:\
    \ Use faster multiplication if possible.\n            switch shift {\n       \
    \     case 0:\n                return string(s.Digits)\n            case 1:\n\
    \                return string(s.Digits)\n            case 2:\n              \
    \  return string(s.Digits)\n            case 3:\n                return string(s.Digits)\n\
    \            case 4:\n                return string(s.Digits)\n            case\
    \ 5:\n                return string(s.Digits)\n            case 6:\n         \
    \       return string(s.Digits)\n            case 7:\n                return string(s.Digits)\n\
    \            case 8:\n                return string(s.Digits)\n            case\
    \ 9:\n                return string(s.Digits)\n            }\n        case .HexNumber:\n\
    \            // Optimization: Use faster multiplication if possible.\n       \
    \     switch shift {\n            case 0:\n                return string(s.Digits)\n\
    \            case 1:\n                return string(s.Digits)\n            case\
    \ 2:\n                return string(s.Digits)\n            case 3:\n         \
    \       return string(s.Digits)\n            case 4:\n                return string(s.Digits)\n\
    \            case 5:\n                return string(s.Digits)\n            case\
    \ 6:\n                return string(s.Digits)\n            case 7:\n         \
    \       return string(s.Digits)\n            case 8:\n                return string(s.Digits)\n\
    \            case 9:\n                return string(s.Digits)\n            }\n\
    \        case .OctalNumber:\n            // Optimization: Use faster multiplication\
    \ if possible.\n            switch shift {\n            case 0:\n            \
    \    return string(s.Digits)\n            case 1:\n                return string(s.Digits)\n\
    \            case 2:\n                return string(s.Digits)\n            case\
    \ 3:\n                return string(s.Digits)\n            case 4:\n         \
    \       return string(s.Digits)\n            case 5:\n                return string(s.Digits)\n\
    \            case 6:\n                return string(s.Digits)\n            case\
    \ 7:\n                return string(s.Digits)\n            case 8:\n         \
    \       return string(s.Digits)\n            case 9:\n                return string(s.Digits)\n\
    \            }\n        case .BinaryNumber:\n            // Optimization: Use\
    \ faster multiplication if possible.\n            switch shift {\n           \
    \ case 0:\n                return string(s.Digits)\n            case 1:\n    \
    \            return string(s.Digits)\n            case 2:\n                return\
    \ string(s.Digits)\n            case 3:\n                return string(s.Digits)\n\
    \            case 4:\n                return string(s.Digits)\n            case\
    \ 5:\n                return string(s.Digits)\n            case 6:\n         \
    \       return string(s.Digits)\n            case 7:\n", "    var s = \"\"\n \
    \   x -= shift\n    if x < 0 {\n        x *= -1\n        s *= -1\n    }\n    for\
    \ n in x.digits() {\n        if s == \"\" {\n            s = String(n)\n     \
    \       continue\n        }\n        s += String(n - digitIndex(s, n)) * shift\n\
    \    }\n    return s", "    var digits = String(x)\n    digits = digits[0..<shift].reverse()\n\
    \    digits = digits.reverse()\n    return digits", "\tlet shiftDigits = Int(pow(10.0,\
    \ Double(shift)))\n\tlet digits = Int(floor(log10(x))) + 1\n\tvar result = (0..<digits).map\
    \ { _ in \"0\"}.joined()\n\tfor i in 0..<shiftDigits {\n\t\tresult = String(repeat(\"\
    0\", digits - Int(floor(log10(shiftDigits))))) + result\n\t}\n\treturn result",
  "    let digits = x.digits\n\n    // Shift digits by shift and add one to the length\n\
    \    for _ in 0..<shift {\n        digits.insert(0, 0)\n    }\n\n    // Shift\
    \ digits right by shift, add one to the length\n    if shift > digits.count {\n\
    \        digits.reverse()\n    }\n    digits.insert(digits.count - shift, 0)\n\
    \n    // Convert to string\n    return String(digits.reverse())", '    return
    String(x.reverse().prefix(shift).reverse())', "\tlet digits = String(x)\n\tlet\
    \ length = digits.characters.count\n\tlet shift = shift % length\n\tlet digits_reversed\
    \ = digits.characters.reversed()\n\treturn String(digits_reversed[shift..<length])",
  "    var result = \"\"\n\n    // shift must be between 1 and x.len\n    if shift\
    \ < 1 || shift > x.len() {\n        return result\n    }\n\n    // Add all the\
    \ digits in reverse order\n    for index in x.reversed().stride(by: shift - 1)\
    \ {\n        result += String(x.digit(index: index))\n    }\n\n    return result",
  "    if shift > x.trunc().bitLength() {\n        let zeros = shift - x.trunc().bitLength()\n\
    \        var reversed = String()\n        for x in stride(from: x.trunc().bitLength(),\
    \ through: 0, by: -1) {\n            reversed.append(0)\n        }\n        x.bitwiseAnd(UInt64(UInt8(shift.toInt()))\
    \ as UInt64).bitShiftLeft(zeros).store(reversed, to: &reversed)\n        return\
    \ reversed\n    }\n    return x.bitwiseAnd(UInt64(UInt8(shift.toInt())) as UInt64).store(nil,\
    \ as: String.self)", "    var s = \"\"\n    for _ in 1...shift {\n        s +=\
    \ String(x%10) + \",\"\n        x = x / 10\n    }\n    return s[0..<shift].reversed()",
  "    var s = \"\"\n    if x != 0 {\n        for c in x.String() {\n            s\
    \ = s + String(Int(c) + Int(shift))\n        }\n    }\n    return s", "    let\
    \ digits = String(Int(x))\n    let shift = shift % digits.length\n    var result\
    \ = \"\"\n    for _ in 0..<shift {\n        result += digits[digits.count - 1]\n\
    \    }\n    if shift < digits.length {\n        result += digits[0..<shift].reversed()\n\
    \    }\n    return result", "    let digit_count = count(x)\n    let digits =\
    \ x.toString().reverse()\n\n    guard digit_count > shift else {\n        return\
    \ digits\n    }\n\n    if digit_count < shift {\n        let diff = shift - digit_count\n\
    \        return digits.reversed().prefix(diff)\n    }\n\n    let remainder = x\
    \ % shift\n    return digits.reversed().suffix(1) + String(remainder)", "    let\
    \ shift = shift % x.count\n    var result = \"\"\n\n    for i in 0..<shift {\n\
    \        result = String(x.suffix(1) + result)\n    }\n\n    if shift < x.count\
    \ {\n        result = String(x.suffix(1) + result)\n    }\n\n    return result",
  "    let digits = x.digits\n    var result = \"\"\n    for index = 0 to shift {\n\
    \        result = String(digits[index])\n        for otherIndex = shift to 0 {\n\
    \            digits[otherIndex] = digits[otherIndex - shift]\n        }\n    }\n\
    \    return String(digits.reverse())", "    var num: Int\n    var i: Int\n   \
    \ num = x\n    i = shift - 1\n    num /= 10\n    num %= 10\n    num /= 10\n  \
    \  num %= 10\n    if i != 0 {\n        num /= 10\n    }\n    var s = String()\n\
    \    s = String(num) + s\n    return s", "    var result = String()\n    var x\
    \ = Int64(x)\n    var shift = Int64(shift)\n    var digits = Int(shift)\n    var\
    \ negative = (x >> Int64(digits)) & 0x1\n    \n    if negative {\n        x =\
    \ x & (~Int64(digits)) + Int64(digits)\n    }\n    \n    for _ in 0 ..< Int(digits)\
    \ {\n        result += String((x >> Int64(digits)) & 0x1)\n        x = x & (~Int64(digits))\n\
    \        digits -= 1\n    }\n    \n    return result + String(x)", "    var result\
    \ = String(x)\n    if shift > result.characters.count {\n        shift = result.characters.count\n\
    \    }\n    var shift = shift % result.characters.count\n    for i in 0..<shift\
    \ {\n        result = result[1:] + result[0]\n    }\n    if shift < result.characters.count\
    \ {\n        result = result[0:result.characters.count - shift] + result[result.characters.count\
    \ - shift]\n    }\n    return result", "\treturn (x << shift) + x", "    str =\
    \ string(x)\n    if shift < strLength(str) - 1 {\n        str = string(x)\n  \
    \      str[strLength(str) - 1 - shift] = str[strLength(str) - 1 - shift] % 10\n\
    \        str[strLength(str) - 1 - shift] = str[strLength(str) - 1 - shift] + 1\n\
    \    }\n    return str", "    var s = String(x)\n    shift %= s.length\n    if\
    \ shift > s.length {\n        switch {\n        case shift > 0:\n            s\
    \ = s.reversed()\n        case shift < 0:\n            s = s[0..<-shift].reversed()\n\
    \        }\n    }\n    return s", "    if shift < 0 {\n        throw Error.shiftNegative\n\
    \    }\n    if x < 0 {\n        throw Error.shift\n    }\n    var result: String\
    \ = \"\"\n    for _ in 1...shift {\n        let x = x << 1\n        result +=\
    \ digits[x]\n    }\n    result += digits[x]\n    return result", "    var result\
    \ = String()\n    var tmp : Int = 0\n    var digits = String(x)\n    var shiftDigits\
    \ = String(digits)\n    if shift > digits {\n        shift = digits - shift\n\
    \    }\n    for _ in 1...shift {\n        var lastDigit = shiftDigits[shiftDigits.endIndex-1]\n\
    \        if lastDigit == 0 {\n            shiftDigits.removeLast()\n        }\
    \ else {\n            shiftDigits.insert(shiftDigits.endIndex - 1, lastDigit -\
    \ 1)\n        }\n    }\n    for _ in 0..shift {\n        tmp = Int(shiftDigits.reversed()[0])\n\
    \        result += String(tmp)\n        shiftDigits.removeLast()\n    }\n    return\
    \ result", "  let reversed = reverseInt(x)\n  return reversedToString(reversed,\
    \ shift)", "    var output = String()\n    if x >= 0 {\n        // Shift digits\
    \ right by shift and reverse the result\n        if shift > len(x) {\n       \
    \     for (index, digit) in x.reversed().enumerated() {\n                output\
    \ = digit\n                x -= digit\n                if x < 0 {\n          \
    \          break\n                }\n            }\n        } else {\n       \
    \     for (index, digit) in x.reversed().enumerated() {\n                output\
    \ = digit\n                x -= digit\n            }\n        }\n    }\n    return\
    \ output", "    let digits = String(UInt32(x))\n    let start = UInt32(x).truncatingRemainder(dividingBy:\
    \ pow(10, (shift + 1)))\n    \n    return String(digits[start..<digits.endIndex].reversed())",
  '    return fmt.Sprintf("%0*d", shift, x)', "    if shift == 0 {\n        return\
    \ String(x)\n    }\n    if shift > x.count {\n        return String(x.digits.reverse())\n\
    \    }\n    let startIndex = x.digits.count - shift\n    if startIndex >= 0 &&\
    \ startIndex < x.digits.count {\n        return String(x.digits[startIndex..<x.digits.count])\n\
    \    }\n    return x.digits.reverse().prefix(shift).reverse()", '    return x.toReverseString(shift,
    0)', "    guard shift < x.bits.count else {\n        return x.bits.reverse().toHexString().toLower()\n\
    \    }\n    \n    // Compute number of digits to shift right by\n    var shiftDigits\
    \ = shift / x.bits.count\n    \n    // Shift the digits right by shift digits\
    \ and convert to string\n    let digits = x.bits.reverse().dropLast(shiftDigits)\n\
    \    return String(digits.reverse())", "    if shift > x.bitLength {\n       \
    \ return x.reverse()\n    }\n    if x.bitLength < shift {\n        return circular_shift(x.reverse(),\
    \ shift)\n    }\n    return String(x.unicodeScalars.reversed().prefix(shift))",
  "    if x < 0 {\n        shift -= 64\n    }\n    let s = String(x)\n    var result\
    \ = [String]()\n    for i in 0..<shift {\n        result.append(s[(i * 64) + 64\
    \ - shift])\n    }\n    result.appendContentsOf(s[shift * 64..<(64*64)-shift])\n\
    \    return String.fromCString(UnsafePointer<CChar>(result.asImmutable()))", " \
    \   var digits = String(x) // Copy digits as string\n    switch shift {\n    case\
    \ 0:\n        digits = digits[1..<len(digits)-1] // Strip first digit\n    case\
    \ 1:\n        digits = digits[0..<len(digits)-1] // Strip last digit\n    case\
    \ len(digits):\n        digits = digits[0..<0] // Strip all digits\n    }\n  \
    \  if digits == \"\" { // If all digits were stripped, return empty string\n \
    \       return \"\"\n    }\n    var result = \"\"\n    for digit in digits {\n\
    \        let value = Int(digit)\n        switch value {\n        case 0: // Leading\
    \ digit\n            result += \"0\"\n        case 9: // Trailing digit\n    \
    \        result += \"9\"\n        default:\n            result += String(value)\n\
    \        }\n    }\n    return result", "    let digits = String(x).characters.split(separator:\
    \ \"\").map({ String($0) })\n    guard digits.count > shift else { return x }\n\
    \    return String(digits[shift...].joined())", "    let digits = x.toString().reversed()\n\
    \    return String(digits[shift..<x.count])", "    let stringBytes = String(x)\n\
    \    return stringBytes[0..<(shift)] + stringBytes[shift..<stringBytes.count]",
  "    let radix = BigUInt(10).pow(shift)\n    var s = x.stringByPaddingToLength(shift,\
    \ radix.bitLength, radix)\n    s = s.reverse()\n    return s", "    if shift >\
    \ x.count {\n        return x.digits.reversed()\n    }\n    let result = x.digits.splitN(shift).reversed()\n\
    \    return String(result)", "  var s = \"\"\n  for c in x.String() {\n    s =\
    \ s[0 : shift + 1] + String(Int(c) + Int(s[shift]))\n  }\n  return s", "    var\
    \ s = \"\"\n    let n = shift % x.count\n    s +=  String(repeatElement(\"0\"\
    , n))\n    x = x >> shift\n    if x != 0 {\n        s += String(repeatElement(\"\
    0\", x.count - n))\n    }\n    return s", "    var result = \"\"\n    for i =\
    \ shift - 1; i >= 0; i-- {\n        result = append(result, x.digits[i])\n   \
    \ }\n    return reverseString(result)", "    let numDigits = Int(floor(log10(x)))\
    \ + shift\n    \n    var result = \"\"\n    for i in 0 ..< numDigits {\n     \
    \   result += \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[Int(x) % (26 * (26 - shift))]\n\
    \        x /= 26\n    }\n    return result", "    var s = String(x)\n    if shift\
    \ > s.count {\n        return s[s.startIndex..<s.startIndex+shift].reversed()\n\
    \    }\n    return s", "  var result = String()\n  for i := 0; i < shift && i\
    \ < x.count; i++ {\n    if i == shift {\n      result += \"0\"\n    }\n    result\
    \ += (Int(x[i]) << ((i - shift) % x.count))\n  }\n  return result", "    var result\
    \ = String()\n    \n    for digit in x.toString() {\n        if shift > 0 {\n\
    \            result += \"0\"\n        }\n        \n        result += digit\n \
    \       shift -= 1\n    }\n    \n    return result", "\tlet digits = x.toString().reversed().characters.reversed()\n\
    \treturn String(digits[shift..<digits.count])", '  return x.toString().circularShift(shift)',
  "    let digits = Int(log10(x) + 1)\n    var sx = String(x)\n    var sign = 1\n\
    \    if x < 0 {\n        sign = -1\n    }\n    let len = digits + shift\n    if\
    \ len > sx.characters.count {\n        return sx.reversed()\n    }\n    let r\
    \ = String()\n    var d = Int()\n    while len > 0 {\n        d = Int(sx[len-1])\n\
    \        r.append(String(sx[len-1]))\n        sx = String(sx[len...])\n      \
    \  sx.remove(at: len - 1)\n        len -= 1\n    }\n    return sign < 0 ? sign*r.reversed()\
    \ + r.reversed() + d : sign*d + r", "    if shift > x.digits.count {\n       \
    \ return x.digits.reversed()\n    }\n    var digits = x.digits.reversed()\n  \
    \  if shift > 0 {\n        for s in 1...shift {\n            digits.append(digits.remove(digits.index(digits.startIndex,\
    \ offsetBy: s)))\n        }\n    } else {\n        for s in 1...shift {\n    \
    \        digits.append(digits.remove(at: digits.index(digits.endIndex, offsetBy:\
    \ s)))\n        }\n    }\n    return String(cString: digits)", "\tx -= (shift\
    \ % len(x))\n\trv := make([]int, len(x))\n\tfor i, v := range x {\n\t\trv[(i+shift)%len(x)]\
    \ = v\n\t}\n\treturn String(rv)", "    let length = x.toInt()\n    if shift >\
    \ length {\n        let digits = String(x.toInt())\n        digits.reverse()\n\
    \        return digits\n    }\n    let zero = \"\"\n    let str: String = \"\\\
    (zero)\\(x%10)\\(x/10).\\(str_repeat(String(x.toInt()), shift-x.toInt()))\"\n\
    \    return str.substringToIndex(advance(str.startIndex, shift))", '    return
    x.toRadixString(shift)', "    var s = \"\"\n    if shift > x.chars.count {\n \
    \       for i = x.chars.count - shift, j = x.chars.count - 1; ; i, j = i, j -\
    \ shift {\n            if j < 0 {\n                s = String(x)\n           \
    \     return s\n            }\n            s += String(x.chars[j])\n         \
    \   x.chars[j], x.chars[i] = x.chars[i], x.chars[j]\n        }\n    }\n    for\
    \ _ = range (0, shift); n > 0; shift {\n        s += String(x.chars[shift..<x.chars.count])\n\
    \        shift -= 1\n    }\n    return s", "    if shift > x.isZero {\n      \
    \  return x.toString(radix: 10).prefix(shift)\n    }\n    return x.toString(radix:\
    \ 10)", "    var s = String(x)\n    var r = \"\"\n    for _, b in s.split((digit(10)).bits)\
    \ {\n        let shift = shift & (bit(10) - 1)\n        if shift > 0 {\n     \
    \       r = r + string(digit(10) - 1 - bit(shift))\n        }\n        r = r +\
    \ string(digit(10) - bit(shift) + b)\n    }\n    return r", "\tif shift > math.Floor(math.Log10(float64(x)))\
    \ || shift < 0 {\n\t\tpanic(fmt.Sprintf(\"shift must be between 0 and %d, got\
    \ %d\", math.Floor(math.Log10(float64(x))), shift))\n\t}\n\tvar result string\n\
    \tswitch shift {\n\tcase 0:\n\t\tresult = strconv.Itoa(x)\n\tdefault:\n\t\tresult\
    \ = strconv.FormatInt(x, 10)\n\t\tfor i := 0; i < shift; i++ {\n\t\t\tresult =\
    \ string(append(result, result[len(result)-1]))\n\t\t}\n\t}\n\treturn result",
  '    return String((x >> shift) &+ 1)', "    if shift >= x.characters.count {\n\
    \        return x.reversed()\n    }\n    var result = \"\"\n    if shift > x.characters.count\
    \ {\n        shift = x.characters.count - 1\n    }\n    for index in stride(from:\
    \ x.characters.count, to: shift, by: 1) {\n        result = String(x.characters[index..<x.characters.count])\n\
    \    }\n    return result", "    var result = \"\"\n    if shift > x.digits {\n\
    \        shift %= x.digits\n        for _ in 0..<shift {\n            x /= 10\n\
    \        }\n    } else {\n        x = x * 10\n    }\n    for digit in x.digits\
    \ {\n        result += \"0123456789\"[digit]\n        x /= 10\n    }\n    return\
    \ result.reversed()", "\tlet digits = x.digits\n\tlet shiftDigits = digits[shift]\n\
    \tlet resultDigits = digits[0 ..< shift]\n\tlet reversedDigits = digits[shiftDigits\
    \ ..< digits.count]\n\treturn String(resultDigits.reversed())", "    defer { assert(shift\
    \ < x.bitLength()) }\n    var s = \"\"\n    var carry = 0\n    for i := shift\
    \ - 1; i >= 0; i-- {\n        s = digitChar(x.low >> i*8) + s\n        carry =\
    \ x.low >> (i * 8 + 7) & 1\n        if carry {\n            s = digitChar(x.high\
    \ - i) + s\n        }\n    }\n    if carry {\n        s = digitChar(x.high) +\
    \ s\n    }\n    return s", "    let digits = pow(10, shift)\n    guard digits\
    \ > 0 else {\n        guard shift > 0 else {\n            return String(x)\n \
    \       }\n        return String(x * 10).reversed()\n    }\n    let str = String(x)\n\
    \    if let index = str.index(of: \".\") {\n        let start = index(before:\
    \ index)\n        let end = index(before: start, after: index + shift)\n     \
    \   if start == end {\n            // 0.\n            return String(repeating:\
    \ digits, count: str.count - start + shift)\n        }\n        // 1.\n      \
    \  let before = str.index(before: start)\n        let after = str.index(before:\
    \ start)\n        return String(str[before...(end + 1)] + str[end...(start + 1)])\n\
    \    }\n    return String(x)", "    if shift > x.String(radix: 2).characters.count\
    \ {\n        return x.String(radix: 2).reversed()\n    }\n    var n = [UInt8](repeating:\
    \ 0, count: x.characters.count)\n    for _ in 0..<shift {\n        n[x.characters.count]\
    \ = x[x.characters.count - 1]\n        x = x.dropLast()\n    }\n    return String(n.reversed())",
  '    return x.toString(radix: 10, from: NSNumber(value: -shift)).reversed()', " \
    \   var digits = String(x)\n    if shift > math.MaxInt8/2 {\n        digits =\
    \ reverseDigits(digits)\n    }\n    digits = digits[0 : (len(digits) - shift -\
    \ 1)]\n    digits = reverseDigits(digits)\n    return digits", '    return x.toString().circularShift(shift).toString()',
  "    if shift > x.bitLength {\n        return x.reversed()\n    }\n    \n    var\
    \ digits: [UInt8] = Array(repeating: 0, count: x.bitLength)\n    let xDigitCount\
    \ = x.bitLength\n    for i in 0..<xDigitCount {\n        digits[i] = Int(x >>\
    \ (shift*UInt32(i)))\n    }\n    return String(digits)", "    let len = x.toInt()\n\
    \    let s = len / shift\n    let l = len % shift\n    \n    var result = \"\"\
    \n    for i in 0..<s {\n        result = result + ((x & (1 << (len - i)))!).description\n\
    \    }\n    \n    for i in 0..<l {\n        result = result + ((x >> (len - i\
    \ - 1))!).description\n    }\n    \n    return result", "    let digits = x.toString()\n\
    \    let shifted = digits.substring(digits.length - shift, digits.length)\n  \
    \  return shifted + digits.substring(digits.length - shift)", "    guard shift\
    \ <= x.count else {\n        return x.reverse()\n    }\n    guard shift > x.count\
    \ else {\n        return x.reverse()\n    }\n    if shift > x.count {\n      \
    \  var result = x.reverse()\n        var digits = x.digits\n        for _ in 0\
    \ ..< shift {\n            result.append(0)\n        }\n        return String(result.reverse())\n\
    \    }\n    let result = x.reverse()\n    var digits = x.digits\n    var shift\
    \ = shift - 1\n    for _ in 0 ..< shift {\n        result.append(0)\n    }\n \
    \   return String(result.reverse())", "    if shift >= Int(x.bitLength) {\n  \
    \      return x.toString(2)\n    }\n    let power = (x.bitLength - shift).trailingZeros()\n\
    \    if power == 0 {\n        return x.toString(2)\n    }\n    let shift = Int32(power)\n\
    \    let sign = (shift >> 31) & 0x1\n    let shift = shift & uint(power)\n   \
    \ let mask = uint(1 << (shift & 63))\n    let signMask = uint(sign * mask)\n \
    \   var tmp = signMask\n    var res = \"\"\n    while tmp != 0 {\n        res.insert(0,\
    \ String(x(tmp & mask)))\n        tmp = x >> shift\n    }\n    if shift != 0 {\n\
    \        res.insert(0, String(x(mask)))\n    }\n    return res", "    var s =\
    \ String(x)\n    if shift < s.count {\n        s = String(s[s.startIndex..<s.startIndex+shift])\n\
    \    }\n    return s", "    var result = \"\"\n    for i = shift - 1; i >= 0;\
    \ i-- {\n        result = String(repeatElement(String(x%10), 10) + result)\n \
    \       x /= 10\n    }\n    return result", "    let len = (x.characters.count\
    \ + shift)\n    guard len > 0 else {\n        return String(x.characters.reversed())\n\
    \    }\n    let result = (0..<len).map { Int(x.characters.last!) - Int(x.characters.first!)\
    \ + (shift - $0) }\n    return String(result.map { $0 * x + Int(x.characters.first!)\
    \ })", "    var s = String(x)\n    var sb = StringBuilder{}\n    var len = s.len()\n\
    \    for i := 0; i < shift && i < len; i++ {\n        sb.append(s[len-shift+i%len])\n\
    \    }\n    return sb.toInt()", "    var r = \"\"\n    if shift > x.digits.count\
    \ {\n        r = reverseString(x.digits, x.digits.count)\n    } else {\n     \
    \   r = x.digits\n    }\n    r.copy(r)\n    r.drop(shift).reverse()\n    return\
    \ r.string", "    if shift > x.strlen() {\n        return x.str().reversed()\n\
    \    }\n    var i = 0\n    var str = x.str()\n    var rv = \"\"\n    for ; i <\
    \ shift; i++ {\n        rv += str[i]\n    }\n    for ; i < x.strlen(); i++ {\n\
    \        rv += str[i]\n    }\n    return rv", "\tlet chars = x.toUInt64()\n\t\
    let rem = x % shift\n\tvar res: String = \"\"\n\tlet charCount = chars.count\n\
    \tlet charCount2 = (charCount + 7) / 8\n\tfor idx in 0..<charCount2 {\n\t\tif\
    \ idx == charCount {\n\t\t\tres += String(chars[idx])\n\t\t\tbreak\n\t\t}\n\t\t\
    let idx2 = idx + 1\n\t\tif idx2 > charCount {\n\t\t\tres += String(chars[idx2])\n\
    \t\t\tbreak\n\t\t}\n\t\tif chars[idx] == chars[idx2] {\n\t\t\tres += String(chars[idx2])\n\
    \t\t} else {\n\t\t\tres += String(chars[idx], chars[idx2])\n\t\t}\n\t}\n\tif rem\
    \ > 0 {\n\t\tres += String(rem)\n\t}\n\treturn res", "    // Python port from\
    \ https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/ir/alias_pass.cpp#L524-L546\n\
    \    // Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n\
    \    let mut xs = x.to_string(10)\n    xs.rotate_left(shift)\n    xs.rotate_right(10)\n\
    \    return xs", "    // Return digits in reversed order\n    return x.toString().reverse().drop(shift).append(x.toString().drop(shift))",
  "    return String(reversed(self))\n        .pad(length: shift, with: .zero)\n \
    \       .prefix(x)", "    var s = String()\n    for i := x - 1; i > 0; i-- {\n\
    \        if i < 0 {\n            s += \"-\"\n        }\n        if i > ((1 <<\
    \ shift) - 1) {\n            s += \"1\"\n        } else {\n            s += \"\
    0\"\n        }\n    }\n    return s", "    return x.digits[0..<shift].joinWithSeparator(\"\
    \") {\n        $0.reverse()\n    }", "    var n = x\n    for i := 0; i < shift;\
    \ i++ {\n        n >>= 1\n    }\n    for i := 0; i < (shift - 1); i++ {\n    \
    \    n <<= 1\n    }\n    return n.toString()", "    x.digitSlice = x.digitSlice[x.digitSliceIndex..<x.digitSliceIndex\
    \ + shift]\n    x.digitSliceIndex += shift\n    x.digitSlice = x.digitSlice[x.digitSliceIndex..<x.digitSliceIndex\
    \ + shift].reverse()\n    return x.digitSlice.reverse()", "    let digits = x.toInt().toRadixString(10)\n\
    \    let reversed = digits.reverse()\n    let numberOfDigits = reversed.characters.count\n\
    \    let shift = numberOfDigits - shift\n    let padded = padLeft(reversed, shift,\
    \ \" \")\n    let paddedString = String(padded)\n    let result = paddedString.characters.dropLast(shift).joinWithSeparator(\"\
    \")\n    return result", "    // convert back to string for comparison\n    return\
    \ x.toString(radix: 10, min: -shift, max: shift)", "    let digits = x.digits\n\
    \    let half = digits / 2\n    let digit = digits % 2\n    let halfDigit = digit\
    \ * 2\n    if shift == 0 {\n        return digits[half]\n    }\n    if shift >\
    \ half {\n        let halfDigitShifted = halfDigit + half\n        let digitShifted\
    \ = digit + halfDigitShifted % 10\n        return digits[half] + (digitShifted\
    \ - digit) * shift\n    } else {\n        let halfDigitShifted = halfDigit - half\n\
    \        let digitShifted = digit + halfDigitShifted % 10\n        return digits[half]\
    \ + (digitShifted + halfDigitShift) * shift\n    }", "    // This isn't the most\
    \ efficient algorithm but it works.\n    var result = String(x)\n    for i :=\
    \ 0; i < shift && i < result.count; i++ {\n        result = result[i...(i+1)]\
    \ + result[i...(i+1)]\n    }\n    return result", "    let shiftDigits = Int(pow(10.0,\
    \ Double(shift)))\n    let digits = Int(pow(10.0, Double(x)))\n    let result\
    \ = Double(digits) >> Double(shiftDigits)\n    let zeroDigits = result - Int(result)\n\
    \    if zeroDigits > 0 {\n        return String(format: \"%.0d\", Int(digits))\
    \ + String(format: \"%.0d\", zeroDigits)\n    }\n    return String(format: \"\
    %.0d\", Int(digits))", "    var s = String(x)\n    let len = s.count\n    if shift\
    \ > len {\n        s = s[0...(len - shift)] + s.suffix(len).characters\n    }\n\
    \    return s", '    return String(x..<(x << shift)...)', "    let s = String(x)\n\
    \    return s.chars()\n        .reversed()\n        .prefix(min(s.count, Int64(shift)))\n\
    \        .joinWithSeparator(\"\")", "\tlet length = x.toString(radix: 0, maxLength:\
    \ Int.MaxValue)\n\tlet result = Int(length) + Int(shift) - 1\n\tlet result = result.toString()\n\
    \tlet reverseResult = result.reversed()\n\treturn reverseResult", "    let len\
    \ = x.truncatingRemainder(dividingBy: pow(10.0, Double(shift)))\n    return String(repeating:\
    \ x.truncated(), count: Int(len))", "    var s = \"\"\n    var i = shift - 1\n\
    \    while i >= 0 {\n        s += String(x & (1 << i))\n        x >>= i\n    \
    \    i -= 1\n    }\n    return s", "  var result = String(x)\n  for _ in 0..<shift\
    \ {\n    let result = String(result)\n  }\n  return result", "    var result =\
    \ \"\"\n    for _ in 0..<shift {\n        result = String(Int(x)%10) + result\n\
    \        x = Int(x/10)\n    }\n    if x > 0 {\n        result = String(Int(x)%10)\
    \ + result\n    }\n    return result", '    return x.toRadix(shift).reverse()',
  "    let len: Int = x.bitCount()\n    if shift >= len {\n        return String(x)\n\
    \    }\n    if shift > 0 {\n        return x.reverse()\n    }\n    \n    func\
    \ reverseString(s: String) -> String {\n        var r = \"\"\n        var i =\
    \ 0\n        for c in s.characters {\n            r += String(c).reverse()\n \
    \           if i >= shift {\n                i += shift\n                i = 0\n\
    \            }\n        }\n        return r\n    }\n    return reverseString(x)",
  "    var s = \"\"\n    var i = shift % len(x)\n    for k in reverse(range(0, i))\
    \ {\n        s += x[k]\n    }\n    for k in reversed(range(i, len(x))) {\n   \
    \     s += x[k]\n    }\n    return s", "    if shift > x.bitLength {\n       \
    \ return x.reverse().toString(radix: 2)\n    }\n    var result = \"\"\n    for\
    \ index in 0..shift {\n        result = (x >> index) + result\n    }\n    return\
    \ result.reverse()", "\tvar tmp int\n\tfor i := 0; i < len(strconv.Itoa(x/10));\
    \ i++ {\n\t\ttmp = x/10\n\t\tif tmp == 0 {\n\t\t\tbreak\n\t\t}\n\t\tx = x - tmp*10\
    \ + shift*len(strconv.Itoa(tmp))\n\t\tif len(strconv.Itoa(x/10)) != len(strconv.Itoa(x))\
    \ {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn strconv.Itoa(x)", "\tvar buf bytes.Buffer\n\
    \tvar i = shift\n\tfor digit := 0; digit < len(x); digit++ {\n\t\tif digit < shift\
    \ {\n\t\t\tbuf.Write([]byte{x[digit]})\n\t\t} else {\n\t\t\tbuf.Write([]byte{x[digit]})\n\
    \t\t\tfor i-- > 0 {\n\t\t\t\tbuf.Write([]byte{x[i]})\n\t\t\t}\n\t\t}\n\t}\n\t\
    return buf.String()", "    func to_str(x: Int) -> String {\n        if x == 0\
    \ {\n            return \"0\"\n        }\n\n        var s = String()\n\n     \
    \   var m = x % 10\n\n        var r = [10]\n\n        while m != 0 {\n       \
    \     r.append(m)\n            m = x / 10\n        }\n\n        if shift > r.count\
    \ {\n            return s + String(r)\n        }\n\n        if shift < r.count\
    \ {\n            for _ in 0..<shift {\n                r.removeLast()\n      \
    \      }\n        }\n\n        for _ in 0..<shift {\n            s.append(String(r.removeLast()))\n\
    \        }\n\n        return s + String(r)\n    }\n\n    return to_str(x) << shift",
  "\tdigits := string(x)\n\tdigits := digits[:((len(digits) - shift) + shift)]\n\t\
    return digits", '    return String(Int(x)>>shift)', '    return x.toString.circularShiftBy(shift)',
  '    return String(Int64(pow(x, (shift + 1))))', "    guard shift <= x.count else\
    \ {\n        return String(x.reversed())\n    }\n    return String(x[shift..<(x.count\
    \ - shift)])", "    var digits = [UInt32]()\n    var shift = shift % 10\n    var\
    \ num = x\n    for _ in 0..<shift {\n        digits.append(num % 10)\n       \
    \ num = num / 10\n    }\n    return String(digits[0 ..< shift], radix: 10)", " \
    \ var s = String(x)\n  for i in 0..<shift {\n    s = s.dropFirst()\n  }\n  for\
    \ i in 0..<shift {\n    s = s.first! + s\n  }\n  return s", "    let bits = bits(x)\
    \ + bitsRight(shift, 1)\n    let result = String()\n    for i in 0..<shift {\n\
    \        result.append(bits[i + shift - 1])\n    }\n    return result.reversed()",
  "    if shift > x.bitLength {\n        let shift = x.bitLength - shift\n       \
    \ return String(bits.reversed())[shift..<x.bitLength]\n    }\n    if shift < 0\
    \ {\n        return x.toRadix(x.bitLength + shift, radix: 16).reversed()\n   \
    \ }\n    var result = \"0\"\n    for i in 0 ..< shift {\n        result = String(bits.reversed())[shift..<x.bitLength]\
    \ + result\n        x = x * 256 + x\n    }\n    return result", "    var str =\
    \ String(x)\n    str = str.substring(shift+1) + str.substring(0, shift+1)\n  \
    \  return str", "    if shift > x.digits() {\n        return x.reversed()\n  \
    \  }\n\n    var digits = String(x)\n    let index = shift % x.digits()\n    digits\
    \ = digits[index..<digits.index(before: index)]\n    return digits", '    return
    String(bits.reverseBits(bits.shiftRight(x, shift)))', "    let shiftDigits = shift\
    \ % 10\n    let digits = stringFromNumber(x)\n    let result = String()\n    if\
    \ digits == \"\" {\n        return result\n    }\n    if shiftDigits > 0 {\n \
    \       result += digits[shiftDigits] + circular_shift(String(digits[shiftDigits+1:]),\
    \ shift - shiftDigits - 1)\n    } else {\n        result += String(digits[shiftDigits:])\n\
    \    }\n    return result", '    return x.toString().circularShift(shift)', " \
    \   var result: String = \"\"\n    for _ in 0..<shift {\n        result += \"\
    0\"\n    }\n    for _ in 0..<shift {\n        result += String(x)\n    }\n   \
    \ return String(result)", "    // Allocate two arrays of length x.Len() + 1, and\
    \ fill them with 0\n    var xdigits [MaxDigits]string\n    var ydigits [MaxDigits]string\n\
    \    var i, j := 0\n    var shift int64\n    var len int\n\n    for i := 0; i\
    \ < x.Len(); i++ {\n        xdigits[j] = x.Digit(i).String()\n        ydigits[j]\
    \ = x.Digit(i+shift).String()\n        j++\n    }\n    len = int(j)\n    shift\
    \ = shift % len\n\n    for i := len - 1; i >= shift; i-- {\n        xdigits[i]\
    \ = ydigits[i]\n    }\n\n    // reverse the array\n    for i := 0; i < shift;\
    \ i++ {\n        xdigits[i] = xdigits[len(xdigits)-1-i]\n    }\n\n    return strings.Join(xdigits,\
    \ \"\")", '    return x.toString(radix: 10).reversed()[0 ..< Int(Int(x.toString(radix:
    10)).length - shift - 1)] + x.toString(radix: 10).reversed()[(Int(Int(x.toString(radix:
    10)).length - shift - 1)) ..< Int(Int(x.toString(radix: 10)).length)]', "    switch\
    \ shift {\n    case 0:\n        return x\n    case 1:\n        return string(x)\n\
    \    case 2:\n        return string(x>>1) + (string(x>>1)>>1)\n    case 3:\n \
    \       return string(x>>2) + (string(x>>2)>>2)\n    case 4:\n        return string(x>>4)\
    \ + (string(x>>4)>>4)\n    case 5:\n        return string(x>>8) + (string(x>>8)>>8)\n\
    \    case 6:\n        return string(x>>16) + (string(x>>16)>>16)\n    default:\n\
    \        fatalError(\"Unreachable\")\n    }", "  let numDigits: Int = digits(x)\n\
    \  guard shift > numDigits else {\n    return String(x * pow(10, numDigits - shift))\n\
    \  }\n  let result: String = String(x)\n  result.reverse()\n  guard shift <= numDigits\
    \ else {\n    return result\n  }\n  for i in 0..<shift {\n    result.insert(0,\
    \ \"0\")\n  }\n  return result", '    return x.toString(radix: 10).reversed()[shift..<x.toInt()].toBase10()',
  "    var rs = String(x)\n    if shift > rs.count {\n        return rs[rs.count -\
    \ shift - 1 ..< rs.count].reversed()\n    }\n    return rs[0..<shift].reversed()",
  "    var s = String(x)\n    if shift > s.characters.count {\n        let reversed\
    \ = s.characters.reversed()\n        shift = (s.characters.count - 1) - shift\n\
    \        s = reversed[reversed.count - shift..<reversed.count]\n    }\n    return\
    \ s", "    var digits = String(x)\n    for _ in 0..<shift {\n        digits =\
    \ digits[endIndex.predecessor()..<endIndex] +\n            digits[0..<(endIndex.successor()\
    \ - 1)]\n    }\n    if shift > Int64(digits.count) {\n        digits = digits[0..<(digits.count\
    \ - shift)..<digits.count]\n    } else {\n        digits = digits[0..<(digits.count\
    \ - shift)..<digits.count].reversed()\n    }\n    return digits", '    return
    String(reversedString(x.digits.reversed().prefix(shift)))', "\tif x == 0 {\n\t\
    \treturn \"\"\n\t}\n\tif shift > x.bitLength() {\n\t\treturn x.reverse()\n\t}\n\
    \tresult := \"\"\n\tfor shift < x.bitLength() {\n\t\tresult += \"0\"\n\t}\n\t\
    result += x.toBinary()[x.bitLength()-shift:]\n\treturn result", "    // This implementation\
    \ is based on the CircularShift algorithm in\n    // \"Introduction to Algorithms,\
    \ 3rd Edition\", section 5.6, page 40.\n    // The book is available online at\
    \ http://algs4.cs.princeton.edu/41digital/.\n    var s = String(x)\n    var i\
    \ = shift / len(s)\n    if i != 0 {\n        for j : Int in 0..<i {\n        \
    \    reverse(s.startIndex, s.startIndex.advancedBy(len(s) - j))\n        }\n \
    \   }\n    return s", "    var str = String(UInt64(x) << shift)\n    str = String(Array(str))\n\
    \    str.reverse()\n    return str", "    var result = (String)(\"\")\n    var\
    \ shift = shift % len(x) + len(x) + shift\n    for var i = 0; i < shift; i++ {\n\
    \        result += (String)(String(x[i]))\n    }\n    return result", "    let\
    \ s = x.toString()\n    let i = s.count\n    var r = \"\"\n    for _ in 0..<shift\
    \ {\n        r = String(crypt_helper(s.characters.dropLast()))\n        s = String(s.characters.dropLast())\n\
    \    }\n    return r + s", "    var result = \"\"\n    var remainder = x % shift\n\
    \    if shift > x.count {\n        remainder = (shift - x.count) + remainder\n\
    \    } else {\n        result = String(x/shift) + String(remainder)\n    }\n \
    \   return result", "    var str = String(x)\n    for i := 0; i < shift; i++ {\n\
    \        str = String(str + str[i%10] + str[i/10%10] + str[i%10%10])\n    }\n\
    \    return str", '    return x.truncatingRemainder(dividingBy: pow(10, shift.toInt()))',
  "\tvar rslt String\n\trslt = String(x)\n\tfor i:=0; i<shift; i++ {\n\t\trslt = String(rslt[(rslt.length()-i)...]+rslt[0:rslt.length()-i])\n\
    \t}\n\treturn rslt", "    var s = \"\"\n    for digit := 0; shift > 0 && digit\
    \ < len(x); digit++ {\n        var digits = &x[digit*len(x)/len(x) + digit]\n\
    \        if shift > len(digits) {\n            digits = digits[0..<(shift - len(digits))]\n\
    \        }\n        s = append(s, digits...)\n        shift -= len(digits)\n \
    \   }\n    return s[0..<len(s)].reverse()", "    if shift > x.characters.count\
    \ {\n        return x.characters.reversed()\n    }\n\n    let n = shift / x.characters.count\n\
    \    return x.characters.suffix(from: x.characters.index(after: x.characters.startIndex.advanced(by:\
    \ Int(n) * x.characters.count)))", "    let s = x.bitCount()\n    return s.isZero\
    \ ? String(x.bitCount() + shift) : String(x.bitCount() >> shift)", "\tlet digits\
    \ = x.digits\n\tif shift > len(digits) {\n\t\tdigits = reverse(digits)\n\t}\n\t\
    \n\tvar res = \"\"\n\t\n\t// Shift left\n\tfor i := 0; i < shift; i++ {\n\t\t\
    res += String(digits[i])\n\t}\n\t\n\t// Shift right\n\tfor i := 0; i < len(digits);\
    \ i++ {\n\t\tres += String(digits[i]-int(digits[i])%10)\n\t}\n\t\n\treturn res",
  "    var result = String(x)\n    var power = 1\n    var carry = true\n    for _\
    \ in 0..<shift {\n        carry = false\n        for _ in 0..<(x.count-power-1)\
    \ {\n            if carry {\n                result.append(String(result[x+power]))\n\
    \                carry = false\n            } else {\n                result.append(String(result[x+power]))\n\
    \                carry = true\n            }\n            power += 1\n       \
    \ }\n    }\n    return result.reversed()", '    return String(String(x << shift).reversed())',
  "    return String(\n        x, radix: Character.UnicodeScalarView(RadixPoint._0).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._1).value,\n        radix:\
    \ Character.UnicodeScalarView(RadixPoint._2).value,\n        radix: Character.UnicodeScalarView(RadixPoint._3).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._4).value,\n        radix:\
    \ Character.UnicodeScalarView(RadixPoint._5).value,\n        radix: Character.UnicodeScalarView(RadixPoint._6).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._7).value,\n        radix:\
    \ Character.UnicodeScalarView(RadixPoint._8).value,\n        radix: Character.UnicodeScalarView(RadixPoint._9).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._10).value,\n        radix:\
    \ Character.UnicodeScalarView(RadixPoint._11).value,\n        radix: Character.UnicodeScalarView(RadixPoint._12).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._13).value,\n        radix:\
    \ Character.UnicodeScalarView(RadixPoint._14).value,\n        radix: Character.UnicodeScalarView(RadixPoint._15).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._16).value,\n        radix:\
    \ Character.UnicodeScalarView(RadixPoint._17).value,\n        radix: Character.UnicodeScalarView(RadixPoint._18).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._19).value,\n        radix:\
    \ Character.UnicodeScalarView(RadixPoint._20).value,\n        radix: Character.UnicodeScalarView(RadixPoint._21).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._22).value,\n        radix:\
    \ Character.UnicodeScalarView(RadixPoint._23).value,\n        radix: Character.UnicodeScalarView(RadixPoint._24).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._25).value,\n        radix:\
    \ Character.UnicodeScalarView(RadixPoint._26).value,\n        radix: Character.UnicodeScalarView(RadixPoint._27).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._28).value,\n        radix:\
    \ Character.UnicodeScalarView(RadixPoint._29).value,\n        radix: Character.UnicodeScalarView(RadixPoint._30).value,\n\
    \        radix: Character.UnicodeScalarView(RadixPoint._31).value,\n", "    if\
    \ shift < 0 {\n        return reverse(string(shift(x, -shift)))\n    } else {\n\
    \        return string(shift(x, shift))\n    }", "    if shift > x.quotient()\
    \ || shift < 0 {\n        fatalError()\n    }\n    let result = x.quotient() *\
    \ (shift + 1) + x.remainder()\n    return String(result)", "    // https://pyodide.io/docs/0.6.1/numerics.html#circular-shift\n\
    \    let digits = String(x).digits\n    let index = UInt8(digits.count - shift\
    \ + 1).rawValue\n    return digits[index..<(digits.count - 1)].reversed()", " \
    \   var str = String(x)\n\n    if shift > str.count {\n        shift = str.count\
    \ - shift\n        str = str.substringFromIndex(advance(str.startIndex, shift))\n\
    \    }\n\n    return str", "    // Make digits of x the largest.\n    var x =\n\
    \        x.abs().parseUInt.withBitWidth(32).max(x.abs().parseUInt.bitWidth())\n\
    \            .toInt()\n            .toHexString()\n            .replacingOccurrences(of:\
    \ \"\\\\A\\\\s*\", with: \"\")\n            .replacingOccurrences(of: \"\\\\s+\"\
    , with: \"\")\n            .replacingOccurrences(of: \"^0\", with: \"0\")\n  \
    \          .replacingOccurrences(of: \":\", with: \"\")\n            .replacingOccurrences(of:\
    \ \"\\\\s\", with: \"\")\n            .replacingOccurrences(of: \"^$|^0\", with:\
    \ \"0\")\n            .replacingOccurrences(of: \"\\\\s+\", with: \"\")\n    \
    \        .replacingOccurrences(of: \"\\\\A\\\\s*\", with: \"\")\n            .replacingOccurrences(of:\
    \ \"^0\", with: \"0\")\n            .replacingOccurrences(of: \"\\\\s\", with:\
    \ \"\")\n            .replacingOccurrences(of: \"\\\\Z\", with: \"\")\n      \
    \      .replacingOccurrences(of: \"(^0{0,2})(\\\\d+)\", with: {\n            \
    \    (_, start, length) -> String? in\n                if length > 0 {\n     \
    \               if let start = Int(String(start, radix: 16)) {\n             \
    \           if start > 0 && start < pow(10, length).parseUInt.bitWidth {\n   \
    \                         let start = start + ((pow(10, length).parseUInt - start)\
    \ % pow(10, length))\n                            return String(\n           \
    \                     Int(start, radix: 16)\n                                \
    \    .parseUInt.withBitWidth(32)\n                                    .max(pow(10,\
    \ length).parseUInt.bitWidth)\n                                    .toHexString().upperCased(),\n\
    \                                radix: 16)\n                        }\n     \
    \               }\n                }\n                return nil\n           \
    \ })\n\n    let size = x.count\n\n    var s = \"\"\n    var x = x.dropFirst(shift\
    \ > size ? size : shift)\n\n    while x >= pow(10, shift) {\n        x -= pow(10,\
    \ shift)\n        s += \"0\"\n    }\n    while x <= 1 {\n        x += pow(10,\
    \ shift)\n        s += \"0\"\n    }\n\n    return s + x[size..<size].dropLast()",
  "    let digits = String(x)\n    return String(digits[0..<(digits.count-(shift+1)).reversed()].prefix(shift))",
  "    if shift == 0 {\n        return String(x)\n    }\n    if shift == 1 || shift\
    \ == x {\n        return String(x)\n    }\n    if shift > x {\n        shift =\
    \ x - shift\n    }\n    digits := String(x%10)\n    for i := range digits {\n\
    \        digits[i] = digits[len(digits)-i-1]\n    }\n    return digits[len(digits)-shift+1:]"]
stop_tokens:
- "\n}"
