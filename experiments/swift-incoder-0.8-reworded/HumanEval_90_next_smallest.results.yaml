language: swift
name: HumanEval_90_next_smallest
results:
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for x in lst {\n        if\
    \ x < smallest {\n            smallest = x\n        }\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmprvvjxaw5/tmprvvjxaw5.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95cbb61c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95cb858b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95cb858988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95cb8577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprvvjxaw5                        0x000055a8301455a1 <unavailable> + 5537

    5    libc.so.6                          0x00002b95cbd4d460 __libc_start_main +
    245

    6    tmprvvjxaw5                        0x000055a830145129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013418
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  guard lst.count > 0 else {\n    return nil\n  }\n\n  if\
    \ lst.count == 1 {\n    return lst[0]\n  }\n\n  let smallest = lst[0]\n  let idx\
    \ = 1\n  for i in 1..lst.count {\n    if smallest > lst[i] {\n      smallest =\
    \ lst[i]\n      idx = i\n    }\n  }\n\n  return lst[idx]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpqipgb571.swift:24:13: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n  for i in 1..lst.count {\n            ^~\n           \
    \ ...\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted(by: <).next()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpeylqz11y.swift:14:30: error: value of type '[Int]' has no member\
    \ 'next'\n    return lst.sorted(by: <).next()\n           ~~~~~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let n = lst?.count ?? 0\n    guard n > 1 else { return\
    \ nil }\n\n    if n == 2 { return lst[0] }\n    if n == 3 { return lst[1] }\n\
    \    if n == 4 { return lst[2] }\n    if n == 5 { return lst[3] }\n    if n ==\
    \ 6 {\n        if lst[4] < lst[1] {\n            return lst[1]\n        }\n  \
    \      return lst[0]\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp97v41g4u.swift:14:16: error: cannot use optional chaining on non-optional\
    \ value of type '[Int]'\n    let n = lst?.count ?? 0\n            ~~~^\n     \
    \          \n"
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else {\n        return nil\n    }\n\
    \n    var smallest = 0\n    var secondSmallest = 0\n    for index in 0..<lst.count\
    \ {\n        if index < lst.count {\n            if smallest < lst[index] {\n\
    \                secondSmallest = smallest\n                smallest = lst[index]\n\
    \            }\n            else {\n                if secondSmallest < lst[index]\
    \ {\n                    secondSmallest = lst[index]\n                }\n    \
    \        }\n        }\n    }\n    return secondSmallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpmbmpknh1/tmpmbmpknh1.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace92f26c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace92c1db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace92c1d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace92c1c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmbmpknh1                        0x0000557624a17621 <unavailable> + 5665

    5    libc.so.6                          0x00002ace93112460 __libc_start_main +
    245

    6    tmpmbmpknh1                        0x0000557624a171a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    var second_smallest = lst[0]\n\
    \n    for i in 1 ..< lst.count {\n        if smallest > lst[i] {\n           \
    \ second_smallest = smallest\n            smallest = lst[i]\n        } else if\
    \ second_smallest > lst[i] {\n            second_smallest = lst[i]\n        }\n\
    \    }\n    return second_smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpds14g0h4/tmpds14g0h4.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9545d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9542ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab9542cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9542cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpds14g0h4                        0x000056348ff2f621 <unavailable> + 5665

    5    libc.so.6                          0x00002ab9547c1460 __libc_start_main +
    245

    6    tmpds14g0h4                        0x000056348ff2f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    switch lst.count {\n    case 0: return nil\n    case 1:\
    \ return lst[0]\n    default:\n        return lst[arrIndex(lst, lst[0]!, 1) +\
    \ 1]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpkiy71b9a.swift:18:20: error: cannot find 'arrIndex' in scope\n\
    \        return lst[arrIndex(lst, lst[0]!, 1) + 1]\n                   ^~~~~~~~\n\
    /tmp/tmpkiy71b9a.swift:18:40: error: cannot force unwrap value of non-optional\
    \ type 'Int'\n        return lst[arrIndex(lst, lst[0]!, 1) + 1]\n            \
    \                     ~~~~~~^\n                                       \n"
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else {\n        return nil\n    }\n\
    \    guard lst.count >= 2 else {\n        return nil\n    }\n    return lst[lst.count\
    \ - 2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpdqtamw52/tmpdqtamw52.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b873120cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8730f03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8730f03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8730f027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdqtamw52                        0x000055e28f311491 <unavailable> + 5265

    5    libc.so.6                          0x00002b87313f8460 __libc_start_main +
    245

    6    tmpdqtamw52                        0x000055e28f311019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    // code here\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: '/tmp/tmpxr0c5sci.swift:15:1: error: missing return in global function expected
    to return ''Int?''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    if lst.isEmpty { return nil\
    \ }\n    for num in lst {\n        if smallest < num {\n            smallest =\
    \ num\n        }\n    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpqxn234e6/tmpqxn234e6.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad745919c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad745610b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad745610988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad74560f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqxn234e6                        0x0000561901fbd5f1 <unavailable> + 5617

    5    libc.so.6                          0x00002ad745b05460 __libc_start_main +
    245

    6    tmpqxn234e6                        0x0000561901fbd179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallestIndex = lst.index(lst.first!)\n    guard smallestIndex\
    \ != lst.count-1 else { return nil }\n    let nextIndex = smallestIndex + 1\n\
    \    if nextIndex == lst.count { return nil }\n    return lst[nextIndex]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpycg3mj_j.swift:14:29: error: no exact matches in call to instance\
    \ method 'index'\n    var smallestIndex = lst.index(lst.first!)\n            \
    \                ^\nSwift.Array:7:28: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(after:)')\n    @inlinable public func index(after i: Int)\
    \ -> Int\n                           ^\nSwift.Array:9:28: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public func\
    \ index(before i: Int) -> Int\n                           ^\nSwift.Collection:3:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(of:)')\n   \
    \ @inlinable public func index(of element: Self.Element) -> Self.Index?\n    \
    \                       ^\nSwift.RandomAccessCollection:3:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(after:)')\n    @inlinable public\
    \ func index(after i: Self.Index) -> Self.Index\n                           ^\n\
    Swift.RandomAccessCollection:4:28: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(before:)')\n    @inlinable public func index(before i: Self.Index)\
    \ -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst[min(lst.indices, by: { $0 > $1 })+1]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpt4an7nu1.swift:14:49: error: binary operator '+' cannot be applied\
    \ to operands of type '_' and 'Int'\n    return lst[min(lst.indices, by: { $0\
    \ > $1 })+1]\n                                                ^\nSwift.SIMD:1:11:\
    \ note: candidate requires that 'Int' conform to 'SIMD' (requirement specified\
    \ as 'Self' : 'SIMD')\nextension SIMD where Self.Scalar : FloatingPoint {\n  \
    \        ^\n/tmp/tmpt4an7nu1.swift:14:19: error: extraneous argument label 'by:'\
    \ in call\n    return lst[min(lst.indices, by: { $0 > $1 })+1]\n             \
    \     ^             ~~~~\n                                \n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n\n   \
    \ var smallest = lst[0]\n    for index in 1..lst.count {\n        if smallest.value\
    \ < lst[index].value {\n            smallest = lst[index]\n        }\n    }\n\
    \    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpc8e_2wo2.swift:19:19: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for index in 1..lst.count {\n                  ^~\n\
    \                  ...\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    if lst.count\
    \ <= 1 {\n        return nil\n    }\n    var smallestIndex = 0\n    var nextSmallest\
    \ = lst[0]\n    for i in 0..<lst.count - 1 {\n        if lst[i] < nextSmallest\
    \ {\n            nextSmallest = lst[i]\n            smallestIndex = i\n      \
    \  }\n    }\n    return lst[smallestIndex + 1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpf56xjydz/tmpf56xjydz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38ab998c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38ab68fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38ab68f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38ab68e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf56xjydz                        0x0000563ac95df855 <unavailable> + 6229

    5    libc.so.6                          0x00002b38abb84460 __libc_start_main +
    245

    6    tmpf56xjydz                        0x0000563ac95df239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.isEmpty else {\n        return nil\n    }\n\
    \    if lst.count < 2 {\n        return nil\n    }\n    guard let elem = lst.first\
    \ else {\n        return nil\n    }\n    var lst1 = lst\n    lst1.remove(at: 0)\n\
    \    return lst1.min { a, b in\n        return a < b\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpn7l57j3w/tmpn7l57j3w.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac8ed350c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac8ed047b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac8ed047988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac8ed0467b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7l57j3w                        0x0000562202bed5f1 <unavailable> + 5617

    5    libc.so.6                          0x00002ac8ed53c460 __libc_start_main +
    245

    6    tmpn7l57j3w                        0x0000562202bed179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n\n    var\
    \ min = lst[0]\n    let minIndex = 1\n\n    for i in 1..<lst.count {\n       \
    \ if lst[i] < min {\n            min = lst[i]\n        } else {\n            if\
    \ lst.count - 1 < minIndex {\n                return nil\n            }\n    \
    \    }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp9b1chbt9/tmp9b1chbt9.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89ae3e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89ae0deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89ae0de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89ae0dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9b1chbt9                        0x0000556dc81c9621 <unavailable> + 5665

    5    libc.so.6                          0x00002b89ae5d3460 __libc_start_main +
    245

    6    tmp9b1chbt9                        0x0000556dc81c91a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    // Base case: If the list is empty, the smallest element\
    \ is the element itself.\n    if lst.count == 0 {\n        return nil\n    }\n\
    \    // If the 1st element is the smallest element in the list, return it.\n \
    \   if lst[0] == lst[1] {\n        return lst[0]\n    }\n\n    // If the 2nd element\
    \ is the smallest element in the list, return it.\n    if lst[1] < lst[2] {\n\
    \        return lst[1]\n    }\n    return lst[2]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpximlblp3/tmpximlblp3.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91fcd9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91fca96b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91fca96988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91fca957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpximlblp3                        0x0000562b86531635 <unavailable> + 5685

    5    libc.so.6                          0x00002b91fcf8b460 __libc_start_main +
    245

    6    tmpximlblp3                        0x0000562b86531019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    for index in 0..<lst.count {\n        if index < lst.count\
    \ - 1 { // not the last element\n            if lst[index] > lst[index + 1] {\n\
    \                return lst[index + 1]\n            }\n        } else {\n    \
    \        if lst[index] > lst[0] {\n                return lst[0]\n           \
    \ }\n        }\n    }\n\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpybr8k5km/tmpybr8k5km.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0c1a18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0c170fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0c170f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0c170e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpybr8k5km                        0x000055e0308a0621 <unavailable> + 5665

    5    libc.so.6                          0x00002ae0c1c04460 __libc_start_main +
    245

    6    tmpybr8k5km                        0x000055e0308a01a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted(by: <)[1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b40dc3f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40dc0ec561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b40dc0ec286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b40dc0ec13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b40dc0ebbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b40dbeebe83 <unavailable> + 188035

    6    tmpd1vr9qrb                        0x000055ed3eb3ed2e <unavailable> + 7470

    7    tmpd1vr9qrb                        0x000055ed3eb3e668 <unavailable> + 5736

    8    libc.so.6                          0x00002b40dc5e1460 __libc_start_main +
    245

    9    tmpd1vr9qrb                        0x000055ed3eb3e029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n\n    if\
    \ let val = lst.first {\n        if lst.count == 2 {\n            return val\n\
    \        } else if val > lst.last! {\n            return nil\n        } else {\n\
    \            return val\n        }\n    }\n\n    if let val = lst.last {\n   \
    \     if lst.count == 2 {\n            return val\n        } else if val < lst.first!\
    \ {\n            return nil\n        } else {\n            return val\n      \
    \  }\n    }\n\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpeogikpsx/tmpeogikpsx.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad104885c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad10457cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad10457c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad10457b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeogikpsx                        0x0000561a14c7a601 <unavailable> + 5633

    5    libc.so.6                          0x00002ad104a71460 __libc_start_main +
    245

    6    tmpeogikpsx                        0x0000561a14c7a189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    switch lst.count {\n    case 0: return nil\n    case 1:\
    \ return lst[0]\n    default: return min(lst)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpxks4_w2c.swift:17:28: error: missing argument for parameter #2\
    \ in call\n    default: return min(lst)\n                           ^\n      \
    \                     , <#Int#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpxks4_w2c.swift:17:25: error: cannot convert value of type\
    \ '[Int]' to expected argument type 'Int'\n    default: return min(lst)\n    \
    \                    ^\n/tmp/tmpxks4_w2c.swift:17:21: error: generic parameter\
    \ 'Element' could not be inferred\n    default: return min(lst)\n            \
    \        ^\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else {\n        return nil\n    }\n\
    \n    if lst.count < 2 {\n        return nil\n    }\n\n    let min = lst.min()\n\
    \    lst.removeFirst()\n    return min\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpd8fy2gew.swift:23:9: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    lst.removeFirst()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else {\n        return nil\n    }\n\
    \    if lst.count > 1 {\n        return lst[1]\n    } else {\n        return nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp0u11cls4/tmp0u11cls4.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7df0d96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7df0a8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7df0a8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7df0a8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0u11cls4                        0x000055caf448a6c5 <unavailable> + 5829

    5    libc.so.6                          0x00002b7df0f82460 __libc_start_main +
    245

    6    tmp0u11cls4                        0x000055caf448a0a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = Int?(nil)\n    for i in lst.reverse() {\n\
    \        if smallest == nil || i < smallest {\n            smallest = i\n    \
    \    }\n    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpppo9os5f.swift:15:18: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    for i in lst.reverse() {\n           \
    \  ~~~ ^\n/tmp/tmpppo9os5f.swift:15:18: error: for-in loop requires '()' to conform\
    \ to 'Sequence'\n    for i in lst.reverse() {\n             ~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted { $0 < $1 }.first\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpar2q30jh/tmpar2q30jh.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6ec3aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6ec0a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba6ec0a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6ec0a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpar2q30jh                        0x000055640c51d4f1 <unavailable> + 5361

    5    libc.so.6                          0x00002ba6ec59a460 __libc_start_main +
    245

    6    tmpar2q30jh                        0x000055640c51d079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty() {\n        return nil\n    }\n    var\
    \ smallest = lst[0]\n    for el in lst {\n        if smallest < el {\n       \
    \     smallest = el\n        }\n    }\n    return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp7w9ucjmj.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var min = lst[0]\n    var min = lst[0]\n    for i in 0..<lst.count\
    \ {\n        if lst[i] < min {\n            min = lst[i]\n        }\n    }\n \
    \   return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpg8da_syw.swift:15:9: error: invalid redeclaration of 'min'\n  \
    \  var min = lst[0]\n        ^\n/tmp/tmpg8da_syw.swift:14:9: note: 'min' previously\
    \ declared here\n    var min = lst[0]\n        ^\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    guard let\
    \ last = lst.remove(at: 0) else { return nil }\n    let lastPos = lst.index(last,\
    \ in: lst)\n    if lastPos == lst.count - 1 {\n        return last\n    }\n  \
    \  if let mid = lastPos + 1 {\n        return lst[mid]\n    }\n    let firstPos\
    \ = lst.index(first, in: lst)\n    return lst[firstPos]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp71z_euem.swift:15:26: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    guard let last = lst.remove(at: 0) else\
    \ { return nil }\n                     ~~~ ^\n/tmp/tmp71z_euem.swift:16:23: error:\
    \ no exact matches in call to instance method 'index'\n    let lastPos = lst.index(last,\
    \ in: lst)\n                      ^\n/tmp/tmp71z_euem.swift:16:23: note: found\
    \ candidate with type '(Int) -> Int'\n    let lastPos = lst.index(last, in: lst)\n\
    \                      ^\n/tmp/tmp71z_euem.swift:16:23: note: found candidate\
    \ with type '(Int) -> Int'\n    let lastPos = lst.index(last, in: lst)\n     \
    \                 ^\n/tmp/tmp71z_euem.swift:16:23: note: found candidate with\
    \ type '(Int, Int) -> Int'\n    let lastPos = lst.index(last, in: lst)\n     \
    \                 ^\n/tmp/tmp71z_euem.swift:16:23: note: found candidate with\
    \ type '(Int) -> Array<Int>.Index?' (aka '(Int) -> Optional<Int>')\n    let lastPos\
    \ = lst.index(last, in: lst)\n                      ^\n/tmp/tmp71z_euem.swift:23:30:\
    \ error: cannot find 'first' in scope\n    let firstPos = lst.index(first, in:\
    \ lst)\n                             ^~~~~\n/tmp/tmp71z_euem.swift:23:24: error:\
    \ no exact matches in call to instance method 'index'\n    let firstPos = lst.index(first,\
    \ in: lst)\n                       ^\n/tmp/tmp71z_euem.swift:23:24: note: found\
    \ candidate with type '(Int) -> Int'\n    let firstPos = lst.index(first, in:\
    \ lst)\n                       ^\n/tmp/tmp71z_euem.swift:23:24: note: found candidate\
    \ with type '(Int) -> Int'\n    let firstPos = lst.index(first, in: lst)\n   \
    \                    ^\n/tmp/tmp71z_euem.swift:23:24: note: found candidate with\
    \ type '(Int, Int) -> Int'\n    let firstPos = lst.index(first, in: lst)\n   \
    \                    ^\n/tmp/tmp71z_euem.swift:23:24: note: found candidate with\
    \ type '(Int) -> Array<Int>.Index?' (aka '(Int) -> Optional<Int>')\n    let firstPos\
    \ = lst.index(first, in: lst)\n                       ^\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted(by: <)[1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b40dc3f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40dc0ec561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b40dc0ec286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b40dc0ec13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b40dc0ebbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b40dbeebe83 <unavailable> + 188035

    6    tmpd1vr9qrb                        0x000055ed3eb3ed2e <unavailable> + 7470

    7    tmpd1vr9qrb                        0x000055ed3eb3e668 <unavailable> + 5736

    8    libc.so.6                          0x00002b40dc5e1460 __libc_start_main +
    245

    9    tmpd1vr9qrb                        0x000055ed3eb3e029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    guard\
    \ lst.count > 1 else {\n        return nil\n    }\n    var min2ndSmallest: Int?\n\
    \    for i in 0..<lst.count - 1 {\n        var curSmallest: Int?\n        if lst.count\
    \ > 2 {\n            guard lst.count > 3 else {\n                continue\n  \
    \          }\n            let pivot = lst.count - 1\n            let right2ndSmallest:\
    \ Int? = next_smallest(lst: lst[pivot..<lst.count])\n            guard right2ndSmallest\
    \ != nil else {\n                continue\n            }\n            guard right2ndSmallest\
    \ <= lst.last else {\n                continue\n            }\n            curSmallest\
    \ = lst.last\n        } else {\n            guard lst.count >= 2 else {\n    \
    \            continue\n            }\n            let pivot = lst.count - 1\n\
    \            let left2ndSmallest: Int? = next_smallest(lst: lst[0..<pivot])\n\
    \            guard left2ndSmallest != nil else {\n                continue\n \
    \           }\n            guard left2ndSmallest >= lst.last else {\n        \
    \        continue\n            }\n            curSmallest = lst.last\n       \
    \ }\n        if curSmallest != nil {\n            min2ndSmallest = min(curSmallest,\
    \ min2ndSmallest)\n        }\n    }\n    return min2ndSmallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpuvcah73v.swift:28:64: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n            let right2ndSmallest: Int? =\
    \ next_smallest(lst: lst[pivot..<lst.count])\n                               \
    \                                ^\n/tmp/tmpuvcah73v.swift:32:36: error: binary\
    \ operator '<=' cannot be applied to two 'Int?' operands\n            guard right2ndSmallest\
    \ <= lst.last else {\n                  ~~~~~~~~~~~~~~~~ ^  ~~~~~~~~\n/tmp/tmpuvcah73v.swift:32:36:\
    \ note: overloads for '<=' exist with these partially matching parameter lists:\
    \ (Int, Int)\n            guard right2ndSmallest <= lst.last else {\n        \
    \                           ^\n/tmp/tmpuvcah73v.swift:41:63: error: cannot convert\
    \ value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n        \
    \    let left2ndSmallest: Int? = next_smallest(lst: lst[0..<pivot])\n        \
    \                                                      ^\n/tmp/tmpuvcah73v.swift:45:35:\
    \ error: binary operator '>=' cannot be applied to two 'Int?' operands\n     \
    \       guard left2ndSmallest >= lst.last else {\n                  ~~~~~~~~~~~~~~~\
    \ ^  ~~~~~~~~\n/tmp/tmpuvcah73v.swift:45:35: note: overloads for '>=' exist with\
    \ these partially matching parameter lists: (Int, Int)\n            guard left2ndSmallest\
    \ >= lst.last else {\n                                  ^\n/tmp/tmpuvcah73v.swift:51:34:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            min2ndSmallest = min(curSmallest, min2ndSmallest)\n             \
    \                    ^\n/tmp/tmpuvcah73v.swift:51:34: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n            min2ndSmallest\
    \ = min(curSmallest, min2ndSmallest)\n                                 ^\n   \
    \                                          ?? <#default value#>\n/tmp/tmpuvcah73v.swift:51:34:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            min2ndSmallest = min(curSmallest, min2ndSmallest)\n     \
    \                            ^\n          "
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for val in lst {\n        if\
    \ val < smallest {\n            smallest = val\n        }\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpg05rwsg8/tmpg05rwsg8.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aee5048cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee50183b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aee50183988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aee501827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg05rwsg8                        0x0000563ca30e65a1 <unavailable> + 5537

    5    libc.so.6                          0x00002aee50678460 __libc_start_main +
    245

    6    tmpg05rwsg8                        0x0000563ca30e6129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst[lst.index(lst.sorted(by: { $0 > $1 }).first!,\
    \ offsetBy: 1)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1945c92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1945989561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1945989286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b194598913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1945988bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1945788e83 <unavailable> + 188035

    6    tmpdanmtil4                        0x00005603c69daf8d <unavailable> + 8077

    7    tmpdanmtil4                        0x00005603c69da4e7 <unavailable> + 5351

    8    libc.so.6                          0x00002b1945e7e460 __libc_start_main +
    245

    9    tmpdanmtil4                        0x00005603c69da1b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let min = min(lst)\n    if lst.contains(min) {\n     \
    \   for v in lst {\n            if v == min {\n                continue\n    \
    \        }\n            if v < min {\n                return v\n            }\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpxsayh89n.swift:14:22: error: missing argument for parameter #2\
    \ in call\n    let min = min(lst)\n                     ^\n                  \
    \   , <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public\
    \ func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else {\n        return nil\n    }\n\
    \n    let smallest = lst[0]\n\n    for i in 1 ..< lst.count {\n        if lst[i]\
    \ < smallest {\n            smallest = lst[i]\n        }\n    }\n\n    return\
    \ smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmphs8a9__2.swift:22:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = lst[i]\n            ^~~~~~~~\n/tmp/tmphs8a9__2.swift:18:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = lst[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = 0\n    var next = smallest\n    for element\
    \ in lst {\n        if element < smallest {\n            smallest = element\n\
    \            next = element\n        }\n    }\n    return next\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpyltljoas/tmpyltljoas.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aee3db78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee3d86fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aee3d86f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aee3d86e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyltljoas                        0x000055572383e551 <unavailable> + 5457

    5    libc.so.6                          0x00002aee3dd64460 __libc_start_main +
    245

    6    tmpyltljoas                        0x000055572383e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    guard let\
    \ first = lst.first else { return nil }\n    if lst.count > 1 {\n        guard\
    \ let secondIndex = lst.index(of: first) + 1 else { return nil }\n        return\
    \ lst[secondIndex]\n    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpi56z1h08.swift:17:37: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n        guard let secondIndex = lst.index(of: first) + 1 else {\
    \ return nil }\n                                    ^\n/tmp/tmpi56z1h08.swift:17:37:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        guard let secondIndex = lst.index(of: first) + 1 else { return\
    \ nil }\n                                    ^\n                             \
    \   (                    ?? <#default value#>)\n/tmp/tmpi56z1h08.swift:17:37:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        guard let secondIndex = lst.index(of: first) + 1 else { return\
    \ nil }\n                                    ^\n                             \
    \                       !\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    var\
    \ index = lst.startIndex\n    var smallest = lst[index]\n    var smallestIndex\
    \ = 1\n    if index + 1 == lst.count {\n        return nil\n    }\n    for index\
    \ in lst.index(after: lst.startIndex) {\n        if smallestIndex == lst.count\
    \ {\n            return nil\n        }\n        if lst[index] < smallest {\n \
    \           smallestIndex = index\n            smallest = lst[index]\n       \
    \ }\n    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp7ttbk7qh.swift:23:22: error: for-in loop requires 'Int' to conform\
    \ to 'Sequence'\n    for index in lst.index(after: lst.startIndex) {\n       \
    \          ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let result = lst.minElement()\n    if result == nil {\n\
    \        return nil\n    } else {\n        return result.successor()\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp4azche00.swift:14:22: error: value of type '[Int]' has no member\
    \ 'minElement'\n    let result = lst.minElement()\n                 ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty {\n        return nil\n    }\n\n    let\
    \ first = lst.removeFirst()\n    var cur = first\n    for x in lst {\n       \
    \ if x <= cur {\n            cur = x\n        }\n    }\n\n    return cur\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp77kp2ynj.swift:18:21: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    let first = lst.removeFirst()\n      \
    \          ~~~ ^\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    let len =\
    \ lst.count\n    if len < 2 {\n        return nil\n    }\n\n    // binary search\
    \ for the 2nd smallest element\n    let middle = len / 2\n    let index = middle\n\
    \    let pivot = lst[index]\n    while index < len - 1 {\n        // swap with\
    \ pivot if current value is smaller than the pivot\n        if lst[index] < pivot\
    \ {\n            swap(&lst[index], &lst[middle])\n            middle--\n     \
    \   }\n        // go to the next element\n        index += 1\n    }\n    return\
    \ pivot\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp5y3l164b.swift:27:18: error: cannot pass immutable value as inout\
    \ argument: 'lst' is a 'let' constant\n            swap(&lst[index], &lst[middle])\n\
    \                 ^~~~\n/tmp/tmp5y3l164b.swift:27:31: error: cannot pass immutable\
    \ value as inout argument: 'lst' is a 'let' constant\n            swap(&lst[index],\
    \ &lst[middle])\n                              ^~~~\n/tmp/tmp5y3l164b.swift:28:19:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  middle--\n                  ^~\n/tmp/tmp5y3l164b.swift:31:15: error: left side\
    \ of mutating operator isn't mutable: 'index' is a 'let' constant\n        index\
    \ += 1\n        ~~~~~ ^\n/tmp/tmp5y3l164b.swift:22:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let index = middle\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    var second = lst[0]\n    for\
    \ elem in lst {\n        if elem < smallest {\n            second = smallest\n\
    \            smallest = elem\n        } else if elem < second {\n            second\
    \ = elem\n        }\n    }\n    return second\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpw90ojusr/tmpw90ojusr.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7936ca1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7936998b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7936998988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79369977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw90ojusr                        0x00005615615ef5a1 <unavailable> + 5537

    5    libc.so.6                          0x00002b7936e8d460 __libc_start_main +
    245

    6    tmpw90ojusr                        0x00005615615ef129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    return lst[0]\
    \ < lst[1] ? lst[0] : lst[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp7cvjmgb5/tmp7cvjmgb5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae45c33fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae45c036b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae45c036988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae45c0357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7cvjmgb5                        0x0000562cdc8484d1 <unavailable> + 5329

    5    libc.so.6                          0x00002ae45c52b460 __libc_start_main +
    245

    6    tmp7cvjmgb5                        0x0000562cdc848059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n\n    for element in lst {\n  \
    \      if smallest < element {\n            smallest = element\n        }\n  \
    \  }\n\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpumrpr_zr/tmpumrpr_zr.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae936fa9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae936ca0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae936ca0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae936c9f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpumrpr_zr                        0x00005607a50b55a1 <unavailable> + 5537

    5    libc.so.6                          0x00002ae937195460 __libc_start_main +
    245

    6    tmpumrpr_zr                        0x00005607a50b5129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let set = Set<Int>(lst)\n    var minVal = Int()\n    set.forEach\
    \ {\n        if $0 < minVal {\n            minVal = $0\n        }\n    }\n   \
    \ if minVal == Int() {\n        return nil\n    }\n    return minVal\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp6e9sdktt/tmp6e9sdktt.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d64c41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d64938b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d64938988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d649377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6e9sdktt                        0x0000562b41598531 <unavailable> + 5425

    5    libc.so.6                          0x00002b8d64e2d460 __libc_start_main +
    245

    6    tmp6e9sdktt                        0x0000562b415980b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var currentSmallest: Int? = nil\n    guard lst.count >\
    \ 0 else {\n        return nil\n    }\n    guard let firstInd = lst.firstIndex\
    \ else {\n        return nil\n    }\n    for i in 1..<lst.count {\n        if\
    \ currentSmallest == nil || currentSmallest < lst[i] {\n            currentSmallest\
    \ = lst[i]\n        }\n    }\n    return currentSmallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpb8_wt0sc.swift:18:11: error: initializer for conditional binding\
    \ must have Optional type, not '(Int) -> Array<Int>.Index?' (aka '(Int) -> Optional<Int>')\n\
    \    guard let firstInd = lst.firstIndex else {\n          ^              ~~~~~~~~~~~~~~\n\
    /tmp/tmpb8_wt0sc.swift:22:38: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n        if currentSmallest == nil || currentSmallest\
    \ < lst[i] {\n                                     ^\n/tmp/tmpb8_wt0sc.swift:22:38:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if currentSmallest == nil || currentSmallest < lst[i] {\n   \
    \                                  ^\n                                       \
    \              ?? <#default value#>\n/tmp/tmpb8_wt0sc.swift:22:38: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ currentSmallest == nil || currentSmallest < lst[i] {\n                     \
    \                ^\n                                                    !\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    // Base cases\n    guard lst.count > 0 else {\n      \
    \  return nil\n    }\n\n    guard lst.count >= 2 else {\n        return nil\n\
    \    }\n\n    var smallest = lst.minElement()\n    var second_smallest = smallest\n\
    \    for e in lst {\n        if e < second_smallest {\n            second_smallest\
    \ = e\n        }\n    }\n\n    return second_smallest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp0htnexnl.swift:23:24: error: value of type '[Int]' has no member\
    \ 'minElement'\n    var smallest = lst.minElement()\n                   ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ smallest = lst[0]\n    for element in lst {\n        if element < smallest {\n\
    \            smallest = element\n        }\n    }\n    return smallest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpy7tezuju/tmpy7tezuju.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b407e507c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b407e1feb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b407e1fe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b407e1fd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy7tezuju                        0x00005577ac609601 <unavailable> + 5633

    5    libc.so.6                          0x00002b407e6f3460 __libc_start_main +
    245

    6    tmpy7tezuju                        0x00005577ac609189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013418
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else {\n        return nil\n    }\n\
    \n    var smallest = lst[0]\n    var smallestIndex = lst.startIndex\n\n    for\
    \ i in lst.index(after: lst.startIndex) {\n        if lst[i] == smallest {\n \
    \           continue\n        }\n        if lst[i] < smallest {\n            smallest\
    \ = lst[i]\n            smallestIndex = i\n        }\n    }\n\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpue4gcjv_.swift:21:18: error: for-in loop requires 'Int' to conform\
    \ to 'Sequence'\n    for i in lst.index(after: lst.startIndex) {\n           \
    \  ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    for i in 0..<lst.count {\n        for j in i..<lst.count\
    \ {\n            if lst[i] > lst[j] {\n                break\n            } else\
    \ {\n                continue\n            }\n        }\n        return lst[i]\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpqe3orr8q/tmpqe3orr8q.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4d6b12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4d6809b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4d6809988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4d68087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqe3orr8q                        0x000055c4cde1a621 <unavailable> + 5665

    5    libc.so.6                          0x00002ac4d6cfe460 __libc_start_main +
    245

    6    tmpqe3orr8q                        0x000055c4cde1a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest: Int?\n\n    if lst.isEmpty {\n        return\
    \ nil\n    }\n    smallest = lst[0]\n    lst.remove(at: 0)\n\n    for i in lst\
    \ {\n        if smallest == nil || i < smallest {\n            smallest = i\n\
    \        }\n    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp5qcf53aj.swift:20:9: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    lst.remove(at: 0)\n    ~~~ ^\n/tmp/tmp5qcf53aj.swift:23:35:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        if smallest == nil || i < smallest {\n                              \
    \    ^\n/tmp/tmp5qcf53aj.swift:23:35: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        if smallest == nil || i < smallest\
    \ {\n                                  ^\n                                   \
    \        ?? <#default value#>\n/tmp/tmp5qcf53aj.swift:23:35: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ smallest == nil || i < smallest {\n                                  ^\n   \
    \                                       !\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty() {\n        return nil\n    }\n    var\
    \ index = lst.index(lst.startIndex)\n    if index != 0 {\n        lst.removeAtIndex(0)\n\
    \        index += 1\n    }\n    for index in lst.indices {\n        if index <\
    \ 2 {\n            return lst[index]\n        }\n        lst.removeAtIndex(index)\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpyo6vbw28.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpyo6vbw28.swift:17:21: error: no exact matches in call to instance\
    \ method 'index'\n    var index = lst.index(lst.startIndex)\n                \
    \    ^\nSwift.Array:7:28: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(after:)')\n    @inlinable public func index(after i: Int) -> Int\n\
    \                           ^\nSwift.Array:9:28: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(before:)')\n    @inlinable public func index(before\
    \ i: Int) -> Int\n                           ^\nSwift.Collection:3:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(of:)')\n    @inlinable public\
    \ func index(of element: Self.Element) -> Self.Index?\n                      \
    \     ^\nSwift.RandomAccessCollection:3:28: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(after:)')\n    @inlinable public func index(after\
    \ i: Self.Index) -> Self.Index\n                           ^\nSwift.RandomAccessCollection:4:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(before:)')\n\
    \    @inlinable public func index(before i: Self.Index) -> Self.Index\n      \
    \                     ^\n/tmp/tmpyo6vbw28.swift:19:13: error: value of type '[Int]'\
    \ has no member 'removeAtIndex'\n        lst.removeAtIndex(0)\n        ~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpyo6vbw28.swift:26:13: error: value of type '[Int]' has no member 'removeAtIndex'\n\
    \        lst.removeAtIndex(index)\n        ~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else {\n        return nil\n    }\n\
    \    \n    return lst[Index(lst.indices, 1)] ?? nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpitado6wv.swift:18:16: error: cannot find 'Index' in scope\n   \
    \ return lst[Index(lst.indices, 1)] ?? nil\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = 1\n    for cur in lst {\n        if cur\
    \ < smallest {\n            smallest = cur\n        }\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpbl3vhtls/tmpbl3vhtls.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b108cdf0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b108cae7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b108cae7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b108cae67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbl3vhtls                        0x0000563169788551 <unavailable> + 5457

    5    libc.so.6                          0x00002b108cfdc460 __libc_start_main +
    245

    6    tmpbl3vhtls                        0x00005631697880d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    guard lst.count\
    \ > 1 else { return lst[0] }\n    let (first, rest) = lst.partition {$0 > lst[1]}\n\
    \    if rest == [] {\n        return nil\n    } else if first == lst[0] {\n  \
    \      return nil\n    } else {\n        return first\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp64bx21bp.swift:16:29: error: no exact matches in call to instance\
    \ method 'partition'\n    let (first, rest) = lst.partition {$0 > lst[1]}\n  \
    \                          ^\n/tmp/tmp64bx21bp.swift:16:29: note: found candidate\
    \ with type '((Int) throws -> Bool) throws -> Array<Int>.Index' (aka '((Int) throws\
    \ -> Bool) throws -> Int')\n    let (first, rest) = lst.partition {$0 > lst[1]}\n\
    \                            ^\n/tmp/tmp64bx21bp.swift:16:29: error: cannot convert\
    \ value of type 'Array<Int>.Index' (aka 'Int') to specified type '(_, _)'\n  \
    \  let (first, rest) = lst.partition {$0 > lst[1]}\n                        ~~~~^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted { $0 < $1 }.dropLast().next()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp_fhd1xrd.swift:14:46: error: value of type 'ArraySlice<Int>' has\
    \ no member 'next'\n    return lst.sorted { $0 < $1 }.dropLast().next()\n    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = Int?(nil)\n    var current = Int?(nil)\n\
    \    for n in lst {\n        if smallest == nil || n < smallest {\n          \
    \  smallest = n\n        }\n        if current == nil || n == current {\n    \
    \        return nil\n        }\n        current = n\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpkx2_9dmu.swift:17:35: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if smallest == nil || n < smallest\
    \ {\n                                  ^\n/tmp/tmpkx2_9dmu.swift:17:35: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        if smallest == nil || n < smallest {\n                              \
    \    ^\n                                           ?? <#default value#>\n/tmp/tmpkx2_9dmu.swift:17:35:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if smallest == nil || n < smallest {\n                      \
    \            ^\n                                          !\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    for cur in lst.reverse() {\n        if let next = cur\
    \ + 1 {\n            return next\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpxowng48q.swift:14:20: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    for cur in lst.reverse() {\n         \
    \      ~~~ ^\n/tmp/tmpxowng48q.swift:14:20: error: for-in loop requires '()' to\
    \ conform to 'Sequence'\n    for cur in lst.reverse() {\n               ~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 { return nil }\n    let max = lst.max()!\n\
    \    return lst.filter{ $0 < max }.min()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpm80d0fn8/tmpm80d0fn8.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08fa4ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08fa1f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08fa1f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08fa1f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm80d0fn8                        0x0000557e4efaa6a1 <unavailable> + 5793

    5    libc.so.6                          0x00002b08fa6eb460 __libc_start_main +
    245

    6    tmpm80d0fn8                        0x0000557e4efaa229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty() {\n        return nil\n    }\n    var\
    \ smallest = lst[0]\n    var secondSmallest = lst[0]\n\n    for i in 1 ..< lst.count\
    \ {\n        if smallest > lst[i] {\n            smallest = lst[i]\n        }\n\
    \        if secondSmallest < lst[i] {\n            secondSmallest = lst[i]\n \
    \       }\n    }\n    return secondSmallest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpwo244la2.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest: Int? = nil\n    for elt in lst {\n     \
    \   if smallest == nil || elt < smallest {\n            smallest = elt\n     \
    \   }\n    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmppzjawrad.swift:16:37: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if smallest == nil || elt < smallest\
    \ {\n                                    ^\n/tmp/tmppzjawrad.swift:16:37: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        if smallest == nil || elt < smallest {\n                            \
    \        ^\n                                             ?? <#default value#>\n\
    /tmp/tmppzjawrad.swift:16:37: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        if smallest == nil || elt < smallest\
    \ {\n                                    ^\n                                 \
    \           !\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest: Int = 0\n    for index in 0..<lst.count\
    \ {\n        if smallest > lst[index] {\n            smallest = lst[index]\n \
    \       }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpzgz100xh/tmpzgz100xh.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5990b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba598dadb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba598dad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba598dac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzgz100xh                        0x00005599e1715621 <unavailable> + 5665

    5    libc.so.6                          0x00002ba5992a2460 __libc_start_main +
    245

    6    tmpzgz100xh                        0x00005599e17151a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else { return nil }\n    let sorted\
    \ = lst.sorted()\n    let index = sorted.index(of: sorted[1]) + 1\n    if index\
    \ == sorted.count { return nil }\n    return sorted[index]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpv_c0_wli.swift:16:24: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n    let index = sorted.index(of: sorted[1]) + 1\n             \
    \          ^\n/tmp/tmpv_c0_wli.swift:16:24: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let index = sorted.index(of:\
    \ sorted[1]) + 1\n                       ^\n                (                \
    \           ?? <#default value#>)\n/tmp/tmpv_c0_wli.swift:16:24: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let index\
    \ = sorted.index(of: sorted[1]) + 1\n                       ^\n              \
    \                             !\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n\n    let\
    \ i = lst.index(of: lst[1])\n    if i == nil {\n        return nil\n    }\n\n\
    \    return lst[i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpit8sntcl.swift:18:17: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    let i = lst.index(of: lst[1])\n                ^\n\
    /tmp/tmpit8sntcl.swift:18:17: note: use 'firstIndex(of:)' instead\n    let i =\
    \ lst.index(of: lst[1])\n                ^~~~~\n                firstIndex\n/tmp/tmpit8sntcl.swift:23:16:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n    return lst[i]\n\
    \               ^\n/tmp/tmpit8sntcl.swift:23:16: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n    return lst[i]\n\
    \               ^\n                 ?? <#default value#>\n/tmp/tmpit8sntcl.swift:23:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return lst[i]\n               ^\n                !\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty {\n        return nil\n    }\n\n    let\
    \ (first, second) = lst.partition(isLessThan(_:))\n    if second.isEmpty {\n \
    \       return first\n    }\n\n    return second\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpu1o4dg60.swift:18:41: error: cannot find 'isLessThan' in scope\n\
    \    let (first, second) = lst.partition(isLessThan(_:))\n                   \
    \                     ^~~~~~~~~~~~~~\n/tmp/tmpu1o4dg60.swift:18:31: error: no\
    \ exact matches in call to instance method 'partition'\n    let (first, second)\
    \ = lst.partition(isLessThan(_:))\n                              ^\n/tmp/tmpu1o4dg60.swift:18:31:\
    \ note: found candidate with type '((Int) throws -> Bool) throws -> Array<Int>.Index'\
    \ (aka '((Int) throws -> Bool) throws -> Int')\n    let (first, second) = lst.partition(isLessThan(_:))\n\
    \                              ^\n/tmp/tmpu1o4dg60.swift:18:31: error: cannot\
    \ convert value of type 'Array<Int>.Index' (aka 'Int') to specified type '(_,\
    \ _)'\n    let (first, second) = lst.partition(isLessThan(_:))\n             \
    \             ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpu1o4dg60.swift:18:41: error:\
    \ converting non-escaping value to '(Int) throws -> Bool' may allow it to escape\n\
    \    let (first, second) = lst.partition(isLessThan(_:))\n                   \
    \                     ^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  guard lst.isEmpty == false else {\n    return nil\n  }\n\
    \  return lst.sorted { $0 < $1 }.first\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp5cgvwlx4/tmp5cgvwlx4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4755702c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47553f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47553f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47553f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5cgvwlx4                        0x0000557859a3c551 <unavailable> + 5457

    5    libc.so.6                          0x00002b47558ee460 __libc_start_main +
    245

    6    tmp5cgvwlx4                        0x0000557859a3c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty() {\n        return nil\n    }\n    var\
    \ n = 0\n    var m = lst.count - 1\n    var k = 0\n    while (k < m) {\n     \
    \   if lst[k] < lst[m] {\n            k = k + 1\n        } else {\n          \
    \  n = lst[m]\n            k = m + 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp5i9kmo27.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else {\n        return nil\n    }\n\
    \    var smallest = lst[0]\n    \n    for i in 1..lst.count {\n        if lst[i]\
    \ < smallest {\n            smallest = lst[i]\n        }\n    }\n    \n    return\
    \ smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp3c3z4to3.swift:19:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..lst.count {\n              ^~\n       \
    \       ...\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n\n   \
    \ var min = lst[0]\n    var min2 = min\n\n    for index in lst.indices {\n   \
    \     if index % 2 == 0 {\n            continue\n        }\n\n        if min >\
    \ lst[index] {\n            min2 = min\n            min = lst[index]\n       \
    \ }\n\n        if min2 < lst[index] {\n            min2 = lst[index]\n       \
    \ }\n    }\n\n    return min2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp04wkwp78/tmp04wkwp78.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b781a6bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b781a3b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b781a3b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b781a3b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04wkwp78                        0x0000561a7c39d6a1 <unavailable> + 5793

    5    libc.so.6                          0x00002b781a8a7460 __libc_start_main +
    245

    6    tmp04wkwp78                        0x0000561a7c39d229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let len = lst.count\n\n    if len < 2 {\n        return\
    \ nil\n    }\n\n    var min = lst[0]\n    var minPos = 1\n\n    for ind in 1 ..<\
    \ len {\n        if lst[ind] < min {\n            min = lst[ind]\n           \
    \ minPos = ind\n        }\n    }\n\n    return lst[minPos + 1]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp_cxq_ald/tmp_cxq_ald.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc03644c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc0333bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc0333b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc0333a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_cxq_ald                        0x000055f034bef621 <unavailable> + 5665

    5    libc.so.6                          0x00002afc03830460 __libc_start_main +
    245

    6    tmp_cxq_ald                        0x000055f034bef1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 { return nil }\n    \n    var smallestIdx\
    \ = 0\n    var smallest = lst[smallestIdx]\n    for i in 1 ..< lst.count {\n \
    \       if lst[i] < smallest {\n            smallestIdx = i\n            smallest\
    \ = lst[i]\n        }\n    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp8toyimy6/tmp8toyimy6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abdac54ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abdac241b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abdac241988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abdac2407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8toyimy6                        0x000056542e38e621 <unavailable> + 5665

    5    libc.so.6                          0x00002abdac736460 __libc_start_main +
    245

    6    tmp8toyimy6                        0x000056542e38e1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count <= 1 {\n        return nil\n    }\n\n   \
    \ let pivot = lst.sort()[Int](minimum: 0)[0]\n\n    var i = Int()\n    var j =\
    \ Int()\n    var k = Int()\n\n    for i = pivot ; i >= 0 { }\n    for j = pivot\
    \ ; j < lst.count - 1; j++ { }\n    for k = pivot ; k < lst.count - 1; k++ {\n\
    \        if lst[k] < lst[j] {\n            break\n        } else if lst[k] > lst[j]\
    \ {\n            break\n        } else {\n            if lst[k] == pivot {\n \
    \               if j < k {\n                    return lst[j]\n              \
    \  } else {\n                    return lst[k]\n                }\n          \
    \  } else if lst[k] > pivot {\n                if j < k {\n                  \
    \  return lst[j]\n                } else {\n                    return lst[k]\n\
    \                }\n            } else {\n                if i < j {\n       \
    \             return lst[j]\n                } else {\n                    return\
    \ lst[k]\n                }\n            }\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpk4j6axq5.swift:24:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = pivot ; i >= 0 { }\n    ^   ~~~~~~~~~~~~~~~~~~\n/tmp/tmpk4j6axq5.swift:25:5:\
    \ error: C-style for statement has been removed in Swift 3\n    for j = pivot\
    \ ; j < lst.count - 1; j++ { }\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk4j6axq5.swift:26:5:\
    \ error: C-style for statement has been removed in Swift 3\n    for k = pivot\
    \ ; k < lst.count - 1; k++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk4j6axq5.swift:18:21:\
    \ error: cannot use mutating member on immutable value: 'lst' is a 'let' constant\n\
    \    let pivot = lst.sort()[Int](minimum: 0)[0]\n                ~~~ ^\n/tmp/tmpk4j6axq5.swift:18:27:\
    \ error: value of type '()' has no subscripts\n    let pivot = lst.sort()[Int](minimum:\
    \ 0)[0]\n                ~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else {\n        return nil\n    }\n\
    \    var smallest = lst[0]\n    for i in 1..<lst.count {\n        if smallest\
    \ > lst[i] {\n            smallest = lst[i]\n        }\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp1h6flmwz/tmp1h6flmwz.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aacd9fcbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aacd9cc2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aacd9cc2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aacd9cc17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1h6flmwz                        0x000055dc9ef06621 <unavailable> + 5665

    5    libc.so.6                          0x00002aacda1b7460 __libc_start_main +
    245

    6    tmp1h6flmwz                        0x000055dc9ef061a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted(by: { $0 < $1 }).next()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpgmnvjp9s.swift:14:40: error: value of type '[Int]' has no member\
    \ 'next'\n    return lst.sorted(by: { $0 < $1 }).next()\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    // TODO: implement next_smallest\n    return nil\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpj9fkpqrg/tmpj9fkpqrg.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b27f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b27c78b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b27c78988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b27c777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj9fkpqrg                        0x000055ea351463e1 <unavailable> + 5089

    5    libc.so.6                          0x00002b4b2816d460 __libc_start_main +
    245

    6    tmpj9fkpqrg                        0x000055ea35145f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    for i in lst {\n        if i > lst[lstIndex] {\n     \
    \       lstIndex += 1\n            return i\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpt8p2s5xt.swift:15:20: error: cannot find 'lstIndex' in scope\n\
    \        if i > lst[lstIndex] {\n                   ^~~~~~~~\n/tmp/tmpt8p2s5xt.swift:16:13:\
    \ error: cannot find 'lstIndex' in scope\n            lstIndex += 1\n        \
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted { $0 < $1 }.last\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp66s03u_c/tmp66s03u_c.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0714805c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b07144fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b07144fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b07144fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp66s03u_c                        0x00005621dccc24f1 <unavailable> + 5361

    5    libc.so.6                          0x00002b07149f1460 __libc_start_main +
    245

    6    tmp66s03u_c                        0x00005621dccc2079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    lst.remove(at: 0)\n    if lst.count\
    \ > 0 {\n        if smallest < lst[0] { smallest = lst[0] }\n        if smallest\
    \ < lst[1] { smallest = lst[1] }\n        if smallest < lst[2] { smallest = lst[2]\
    \ }\n        if smallest < lst[3] { smallest = lst[3] }\n        if smallest <\
    \ lst[4] { smallest = lst[4] }\n    }\n    return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp34_kqseu.swift:15:9: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    lst.remove(at: 0)\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count <= 0 {\n        return nil\n    }\n    var\
    \ smallest = lst[0]\n    for elem : Int in lst {\n        if elem < smallest {\n\
    \            smallest = elem\n        }\n    }\n    return smallest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpqrfowska/tmpqrfowska.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a01263c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a00f5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a00f5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a00f597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqrfowska                        0x0000563262e21601 <unavailable> + 5633

    5    libc.so.6                          0x00002b4a0144f460 __libc_start_main +
    245

    6    tmpqrfowska                        0x0000563262e21189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for i in 1..lst.count {\n \
    \       if lst[i] < smallest {\n            smallest = lst[i]\n        }\n   \
    \ }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpe2q95i8t.swift:15:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..lst.count {\n              ^~\n       \
    \       ...\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let len = lst.count\n    let firstMin = lst.min() ?? -1\n\
    \    var minIndex = Int()\n    var currentIndex = Int()\n    var nextIndex = Int()\n\
    \    for i in 0..<len {\n        currentIndex = i\n        nextIndex = i\n   \
    \     if currentIndex != firstMin {\n            let tmp = lst[currentIndex]\n\
    \            while tmp < lst[nextIndex] {\n                nextIndex += 1\n  \
    \          }\n            if currentIndex != nextIndex {\n                minIndex\
    \ = currentIndex\n            }\n        }\n        if minIndex == currentIndex\
    \ {\n            break\n        }\n    }\n    if minIndex != currentIndex {\n\
    \        return nil\n    }\n    return lst[nextIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpw4lb5imw/tmpw4lb5imw.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0675238c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0674f2fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0674f2f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0674f2e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw4lb5imw                        0x000055adfef6c6c1 <unavailable> + 5825

    5    libc.so.6                          0x00002b0675424460 __libc_start_main +
    245

    6    tmpw4lb5imw                        0x000055adfef6c249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty() {\n        return nil\n    }\n    var\
    \ index = lst.startIndex\n    while index != lst.endIndex {\n        if index\
    \ == lst.startIndex {\n            return nil\n        }\n        if lst[index]\
    \ < lst[index+1] {\n            if index != lst.startIndex {\n               \
    \ index -= 1\n            }\n        } else {\n            index += 1\n      \
    \  }\n    }\n    return lst[index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpujssxxzu.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n\n    var\
    \ i = 0\n    var largest = lst[i]\n\n    while i < lst.count && lst[i] < largest\
    \ {\n        largest = lst[i]\n        i += 1\n    }\n\n    if i == lst.count\
    \ {\n        return nil\n    }\n\n    return largest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp92c_btss/tmp92c_btss.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b150c5bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b150c2b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b150c2b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b150c2b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp92c_btss                        0x00005629ee76c491 <unavailable> + 5265

    5    libc.so.6                          0x00002b150c7a9460 __libc_start_main +
    245

    6    tmp92c_btss                        0x00005629ee76c019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  switch lst.count {\n  case 0: return nil\n  case 1: return\
    \ lst[0]\n  case 2..<lst.count {\n    if lst[lst.count-2] == lst[lst.count-1]\
    \ {\n      return lst[lst.count-2]\n    }\n    if lst[lst.count-2] < lst[lst.count-1]\
    \ {\n      return lst[lst.count-2]\n    }\n    return lst[lst.count-1]\n  }\n\
    \  default: return nil\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpcbxrgodh.swift:25:4: error: expected ':' after 'case'\n  }\n  \
    \ ^\n/tmp/tmpcbxrgodh.swift:17:16: error: cannot call value of non-function type\
    \ 'Int'\n  case 2..<lst.count {\n               ^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty() {\n        return nil\n    }\n    if\
    \ lst.count > 1 {\n        if let index = lst.index(of: lst[1]) {\n          \
    \  return lst[index + 1]\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp3r7s3jmn.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp3r7s3jmn.swift:18:28: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        if let index = lst.index(of: lst[1]) {\n     \
    \                      ^\n/tmp/tmp3r7s3jmn.swift:18:28: note: use 'firstIndex(of:)'\
    \ instead\n        if let index = lst.index(of: lst[1]) {\n                  \
    \         ^~~~~\n                           firstIndex\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var smallest\
    \ = lst[0]\n    var nextSmallest = lst[0]\n    for val in lst[1..] {\n       \
    \ if val < smallest {\n            smallest = nextSmallest\n            nextSmallest\
    \ = val\n        } else {\n            nextSmallest = val\n        }\n    }\n\
    \    return nextSmallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpvdktnvpf.swift:17:21: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for val in lst[1..] {\n                    ^~\n   \
    \                 ...\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    var secondSmallest = lst[0]\n\
    \    if lst.count > 1 {\n        for value in lst {\n            if value < smallest\
    \ {\n                secondSmallest = smallest\n                smallest = value\n\
    \            } else {\n                if value < secondSmallest {\n         \
    \           secondSmallest = value\n                }\n            }\n       \
    \ }\n    }\n    return secondSmallest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp_1o4jaki/tmp_1o4jaki.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4605861c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4605558b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4605558988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46055577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_1o4jaki                        0x0000560ee11ab601 <unavailable> + 5633

    5    libc.so.6                          0x00002b4605a4d460 __libc_start_main +
    245

    6    tmp_1o4jaki                        0x0000560ee11ab189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    var nextSmallest = smallest\n\
    \    for idx in 1..<lst.count {\n        if smallest<lst[idx] {\n            smallest\
    \ = lst[idx]\n            nextSmallest = smallest\n        }\n    }\n    return\
    \ nextSmallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpolcht153/tmpolcht153.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e79a4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e79741b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e79741988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e797407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpolcht153                        0x0000559c06ef9621 <unavailable> + 5665

    5    libc.so.6                          0x00002b9e79c36460 __libc_start_main +
    245

    6    tmpolcht153                        0x0000559c06ef91a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    let\
    \ index = lst.index(of: min(lst))\n    if index == lst.count - 1 {\n        return\
    \ nil\n    }\n    return lst[index + 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp9nu7ba_q.swift:17:38: error: missing argument for parameter #2\
    \ in call\n    let index = lst.index(of: min(lst))\n                         \
    \            ^\n                                     , <#Int#>\nSwift.min:1:24:\
    \ note: 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmp9nu7ba_q.swift:17:35:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    let index = lst.index(of: min(lst))\n                                  ^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    var smallestIndex = 0\n   \
    \ for index in 0..<lst.count {\n        if smallestIndex < lst.count {\n     \
    \       if smallestIndex == index {\n                smallestIndex += 1\n    \
    \        } else {\n                if lst[index] < smallest {\n              \
    \      smallest = lst[index]\n                    smallestIndex = index\n    \
    \            }\n            }\n        }\n    }\n    return smallestIndex == lst.count\
    \ ? nil : lst[smallestIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpge9rkyy6/tmpge9rkyy6.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0605fa2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0605c99b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0605c99988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0605c987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpge9rkyy6                        0x0000564de3621621 <unavailable> + 5665

    5    libc.so.6                          0x00002b060618e460 __libc_start_main +
    245

    6    tmpge9rkyy6                        0x0000564de36211a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallestIndex = 0\n    var nextSmallest = lst[smallestIndex]\n\
    \n    for i in 1..<lst.count {\n        if nextSmallest < lst[i] {\n         \
    \   nextSmallest = lst[i]\n            smallestIndex = i\n        }\n    }\n \
    \   return nextSmallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpq5ui7f26/tmpq5ui7f26.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae61fe73c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae61fb6ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae61fb6a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae61fb697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq5ui7f26                        0x00005635b4989621 <unavailable> + 5665

    5    libc.so.6                          0x00002ae62005f460 __libc_start_main +
    245

    6    tmpq5ui7f26                        0x00005635b49891a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n\n    for i in 1..<lst.count {\n\
    \        if smallest > lst[i] {\n            smallest = lst[i]\n        }\n  \
    \  }\n\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmprg5_qyt2/tmprg5_qyt2.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9c4939c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9c4630b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9c4630988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9c462f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprg5_qyt2                        0x0000559603112621 <unavailable> + 5665

    5    libc.so.6                          0x00002ae9c4b25460 __libc_start_main +
    245

    6    tmprg5_qyt2                        0x00005596031121a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n\n    if\
    \ lst.count == 2 {\n        return lst[1]\n    }\n\n    let min = lst.min()\n\
    \    let rest = lst.filter{$0 != min}.dropLast()\n    return rest[0]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpwwxh0gzq/tmpwwxh0gzq.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4d3b12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4d3809b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4d3809988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4d38087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwwxh0gzq                        0x0000556c297be895 <unavailable> + 6293

    5    libc.so.6                          0x00002af4d3cfe460 __libc_start_main +
    245

    6    tmpwwxh0gzq                        0x0000556c297be279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for i in lst {\n        if\
    \ i < smallest {\n            smallest = i\n        }\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpql100if0/tmpql100if0.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b68560a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6855d9db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6855d9d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6855d9c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpql100if0                        0x0000563bbc5d15a1 <unavailable> + 5537

    5    libc.so.6                          0x00002b6856292460 __libc_start_main +
    245

    6    tmpql100if0                        0x0000563bbc5d1129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else {\n        return nil\n    }\n\
    \n    var smallest = lst[0]\n    var index = 1\n\n    while index < lst.count\
    \ {\n        if lst[index] < smallest {\n            smallest = lst[index]\n \
    \       }\n\n        index++\n    }\n\n    return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpd79duu4w.swift:26:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty { return nil }\n    var smallest = lst[0]\n\
    \    if lst.count == 1 { return nil }\n    if lst[1] == smallest { return nil\
    \ }\n\n    for i in  1 ..< lst.count {\n        if lst[i] < smallest {\n     \
    \       smallest = lst[i]\n        }\n    }\n    return smallest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpbov1i271/tmpbov1i271.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5416cd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b54169ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b54169ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54169cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbov1i271                        0x000055877201b6b1 <unavailable> + 5809

    5    libc.so.6                          0x00002b5416ec3460 __libc_start_main +
    245

    6    tmpbov1i271                        0x000055877201b239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ minValue = Int?(lst[0])\n    for value in lst {\n        if value == minValue!\
    \ {\n            continue\n        }\n        if value < minValue! {\n       \
    \     minValue = value\n        }\n    }\n    return minValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpmo24gg36/tmpmo24gg36.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3339c75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b333996cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b333996c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b333996b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmo24gg36                        0x00005594834f5691 <unavailable> + 5777

    5    libc.so.6                          0x00002b3339e61460 __libc_start_main +
    245

    6    tmpmo24gg36                        0x00005594834f5219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  guard !lst.isEmpty else { return nil }\n  let n = lst.count\n\
    \  let i = 0\n  let min_index = i + 1\n  var min = lst[min_index]\n  guard min_index\
    \ < n else { return nil }\n  guard min_index == n || min > lst[i] else { return\
    \ nil }\n  for index in stride(from: min_index + 1, to: n, by: -1) {\n    guard\
    \ min > lst[index] else { continue }\n    min = lst[index]\n    i = index\n  }\n\
    \  return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpcknqswdd.swift:24:5: error: cannot assign to value: 'i' is a 'let'\
    \ constant\n    i = index\n    ^\n/tmp/tmpcknqswdd.swift:16:3: note: change 'let'\
    \ to 'var' to make it mutable\n  let i = 0\n  ^~~\n  var\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count <= 1 {\n        return nil\n    }\n    if\
    \ lst.count <= 2 {\n        if lst[0] < lst[1] {\n            return lst[0]\n\
    \        } else {\n            return lst[1]\n        }\n    }\n    if lst[0]\
    \ < lst[1] {\n        if lst[0] < lst[2] {\n            return lst[0]\n      \
    \  } else {\n            return lst[2]\n        }\n    } else {\n        if lst[1]\
    \ < lst[2] {\n            return lst[1]\n        } else {\n            return\
    \ lst[2]\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpc6zi8rx8/tmpc6zi8rx8.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01d5e36c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01d5b2db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01d5b2d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01d5b2c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc6zi8rx8                        0x000055625500e491 <unavailable> + 5265

    5    libc.so.6                          0x00002b01d6022460 __libc_start_main +
    245

    6    tmpc6zi8rx8                        0x000055625500e019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.count == 0 {\n    return nil\n  }\n  var smallest\
    \ = lst[0]\n  if lst.count > 1 {\n    smallest = lst[1]\n  }\n  for index in lst.indices\
    \ {\n    if index < lst.count - 1 {\n      if lst[index] > smallest {\n      \
    \  smallest = lst[index]\n      }\n    } else {\n      return nil\n    }\n  }\n\
    \  return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpscfihafo/tmpscfihafo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c82a05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c826fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7c826fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7c826fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpscfihafo                        0x0000561976f53611 <unavailable> + 5649

    5    libc.so.6                          0x00002b7c82bf1460 __libc_start_main +
    245

    6    tmpscfihafo                        0x0000561976f53199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  guard lst.count > 1 else {\n    return nil\n  }\n\n  var\
    \ smallest: Int? = nil\n  var largest: Int? = nil\n  var index = -1\n\n  for i\
    \ in 0 ..< lst.count {\n    if smallest == nil || i < smallest!.0 {\n      smallest\
    \ = i\n    }\n\n    if largest == nil || largest == nil || largest < i {\n   \
    \   largest = i\n    }\n  }\n\n  if smallest == nil || largest == nil {\n    return\
    \ nil\n  }\n\n  if largest == smallest {\n    return lst[largest]\n  }\n\n  for\
    \ i in 0 ..< lst.count {\n    if i == smallest {\n      return lst[smallest]\n\
    \    }\n\n    if i != largest {\n      if lst[i] < lst[smallest] {\n        return\
    \ lst[i]\n      }\n    }\n  }\n\n  return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpzwx3a922.swift:23:41: error: value of type 'Int' has no member\
    \ '0'\n    if smallest == nil || i < smallest!.0 {\n                         \
    \     ~~~~~~~~~ ^\n/tmp/tmpzwx3a922.swift:27:44: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n    if largest == nil ||\
    \ largest == nil || largest < i {\n                                          \
    \ ^\n/tmp/tmpzwx3a922.swift:27:44: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n    if largest == nil || largest ==\
    \ nil || largest < i {\n                                           ^\n       \
    \                                            ?? <#default value#>\n/tmp/tmpzwx3a922.swift:27:44:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    if largest == nil || largest == nil || largest < i {\n          \
    \                                 ^\n                                        \
    \          !\n/tmp/tmpzwx3a922.swift:37:16: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n    return lst[largest]\n      \
    \         ^\n/tmp/tmpzwx3a922.swift:37:16: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    return lst[largest]\n\
    \               ^\n                       ?? <#default value#>\n/tmp/tmpzwx3a922.swift:37:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return lst[largest]\n               ^\n                      !\n\
    /tmp/tmpzwx3a922.swift:42:18: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n      return lst[smallest]\n                 ^\n/tmp/tmpzwx3a922.swift:42:18:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n      return lst[smallest]\n                 ^\n                    \
    \      ?? <#default value#>\n/tmp/tmpzwx3a922.swift:42:18: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n      return\
    \ lst[smallest]\n                 ^\n                         !\n/tmp/tmpzwx3a922.swift:46:23:\
    \ e"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = Int?()\n    var smallestIndex = Int?()\n\
    \    for index in 0..<lst.count {\n        let value = lst[index]\n        if\
    \ smallest == nil || value < smallest {\n            smallestIndex = index\n \
    \           smallest = value\n        } else {\n            if smallestIndex ==\
    \ nil || value > smallest! {\n                smallestIndex = index\n        \
    \        smallest = value\n            }\n        }\n    }\n    return smallestIndex\
    \ == nil ? nil : lst[smallestIndex!]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp1wohsjyz.swift:14:25: error: missing argument for parameter #1\
    \ in call\n    var smallest = Int?()\n                        ^\n            \
    \            <#Int#>\nSwift.Optional:4:12: note: 'init(_:)' declared here\n  \
    \  public init(_ some: Wrapped)\n           ^\n/tmp/tmp1wohsjyz.swift:15:30: error:\
    \ missing argument for parameter #1 in call\n    var smallestIndex = Int?()\n\
    \                             ^\n                             <#Int#>\nSwift.Optional:4:12:\
    \ note: 'init(_:)' declared here\n    public init(_ some: Wrapped)\n         \
    \  ^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for el in lst {\n        if\
    \ smallest > el {\n            smallest = el\n        }\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpwvqib788/tmpwvqib788.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9f030ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9f0005b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab9f0005988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9f00047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwvqib788                        0x0000561384f0e5a1 <unavailable> + 5537

    5    libc.so.6                          0x00002ab9f04fa460 __libc_start_main +
    245

    6    tmpwvqib788                        0x0000561384f0e129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    var\
    \ lowest = lst[0]\n    var secondLowest: Int? = nil\n    for i in 1..lst.count\
    \ {\n        if lst[i] < lowest {\n            lowest = lst[i]\n            secondLowest\
    \ = lowest\n        } else if lst[i] > lowest {\n            secondLowest = lowest\n\
    \            lowest = lst[i]\n        }\n    }\n    return secondLowest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpqah0d5ln.swift:19:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..lst.count {\n              ^~\n       \
    \       ...\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    var second_smallest = smallest\n\
    \n    for i in 1 ..< lst.count {\n        if lst[i] < second_smallest {\n    \
    \        second_smallest = smallest\n            smallest = lst[i]\n        }\
    \ else {\n            second_smallest = lst[i]\n        }\n    }\n    return second_smallest\
    \ != smallest ? nil : smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmphtxz83zh/tmphtxz83zh.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd9d90ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd9d601b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd9d601988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd9d6007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphtxz83zh                        0x000055f115dfc621 <unavailable> + 5665

    5    libc.so.6                          0x00002acd9daf6460 __libc_start_main +
    245

    6    tmphtxz83zh                        0x000055f115dfc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let smallest = lst[0]\n    if lst.count == 1 {\n     \
    \   return nil\n    }\n    for v in lst {\n        if v < smallest {\n       \
    \     smallest = v\n        }\n    }\n    return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpzpzzbmea.swift:20:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = v\n            ^~~~~~~~\n/tmp/tmpzpzzbmea.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = lst[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted { $0 < $1 }.last\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp66s03u_c/tmp66s03u_c.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0714805c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b07144fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b07144fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b07144fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp66s03u_c                        0x00005621dccc24f1 <unavailable> + 5361

    5    libc.so.6                          0x00002b07149f1460 __libc_start_main +
    245

    6    tmp66s03u_c                        0x00005621dccc2079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for elem in lst {\n       \
    \ if elem < smallest {\n            smallest = elem\n        }\n    }\n    return\
    \ smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpo8eeamb9/tmpo8eeamb9.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada18cdcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada189d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada189d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada189d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo8eeamb9                        0x000055939048f5a1 <unavailable> + 5537

    5    libc.so.6                          0x00002ada18ec8460 __libc_start_main +
    245

    6    tmpo8eeamb9                        0x000055939048f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.isEmpty { return nil }\n  \n  return lst.reduce(1)\
    \ { $0 < $1 ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmppbj16f7b/tmppbj16f7b.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed77a89c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed77780b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed77780988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed7777f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppbj16f7b                        0x0000558222c3c4f1 <unavailable> + 5361

    5    libc.so.6                          0x00002aed77c75460 __libc_start_main +
    245

    6    tmppbj16f7b                        0x0000558222c3c079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count >= 2 else {\n        return nil\n    }\n\
    \    return lst.sorted(by: <).next()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpe8ka1q69.swift:17:30: error: value of type '[Int]' has no member\
    \ 'next'\n    return lst.sorted(by: <).next()\n           ~~~~~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.isEmpty == false else {\n        return nil\n\
    \    }\n    if lst.count < 2 { return nil }\n    let minValue = lst[0]\n    let\
    \ smallestIndex = 1\n    for i in 1..<lst.count {\n        if lst[i] < minValue\
    \ {\n            minValue = lst[i]\n            smallestIndex = i\n        }\n\
    \    }\n    return minValue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp5lq9fw_0.swift:22:13: error: cannot assign to value: 'minValue'\
    \ is a 'let' constant\n            minValue = lst[i]\n            ^~~~~~~~\n/tmp/tmp5lq9fw_0.swift:18:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let minValue = lst[0]\n\
    \    ^~~\n    var\n/tmp/tmp5lq9fw_0.swift:23:13: error: cannot assign to value:\
    \ 'smallestIndex' is a 'let' constant\n            smallestIndex = i\n       \
    \     ^~~~~~~~~~~~~\n/tmp/tmp5lq9fw_0.swift:19:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let smallestIndex = 1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = nil\n    for v in lst {\n        if smallest\
    \ == nil {\n            smallest = v\n        }\n        if v < smallest {\n \
    \           smallest = v\n        }\n    }\n    return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp11b9rdwf.swift:14:20: error: 'nil' requires a contextual type\n\
    \    var smallest = nil\n                   ^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    switch lst.count {\n    case 0: return nil\n    case 1:\
    \ return lst[0]\n    case 2: return min(lst[0], lst[1])\n    default: let min\
    \ = lst[0]\n        for val in lst.drop(1) {\n            if val <= min {\n  \
    \              min = val\n            } else {\n                let val = min(val,\
    \ min)\n                min = val\n            }\n        }\n        return min\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpvs9lbjyn.swift:19:24: error: no exact matches in call to instance\
    \ method 'drop'\n        for val in lst.drop(1) {\n                       ^\n\
    /tmp/tmpvs9lbjyn.swift:19:24: note: candidate expects value of type '(Int) throws\
    \ -> Bool' for parameter #1 (got 'Int')\n        for val in lst.drop(1) {\n  \
    \                     ^\n/tmp/tmpvs9lbjyn.swift:19:24: note: candidate expects\
    \ value of type '(Int) throws -> Bool' for parameter #1 (got 'Int')\n        for\
    \ val in lst.drop(1) {\n                       ^\n/tmp/tmpvs9lbjyn.swift:23:27:\
    \ error: cannot call value of non-function type 'Int'\n                let val\
    \ = min(val, min)\n                          ^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    var next_smallest = nil\n \
    \   for i in 1..lst.count {\n        if lst[i] < smallest {\n            smallest\
    \ = lst[i]\n            next_smallest = smallest\n        } else {\n         \
    \   if lst[i] > next_smallest {\n                next_smallest = lst[i]\n    \
    \        }\n        }\n    }\n    return next_smallest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpa1cr2mso.swift:15:25: error: 'nil' requires a contextual type\n\
    \    var next_smallest = nil\n                        ^\n/tmp/tmpa1cr2mso.swift:16:15:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n    for i in\
    \ 1..lst.count {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  return lst.sorted(by: { $0 > $1 }).prefix(1).next() ?? nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpzzgqcocs.swift:14:48: error: value of type 'ArraySlice<Int>' has\
    \ no member 'next'\n  return lst.sorted(by: { $0 > $1 }).prefix(1).next() ?? nil\n\
    \         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for i in 1 ..< lst.count {\n\
    \        if lst[i] < smallest {\n            smallest = lst[i]\n        }\n  \
    \  }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmptegf64j_/tmptegf64j_.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b352b96fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b352b666b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b352b666988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b352b6657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptegf64j_                        0x00005644b94a1621 <unavailable> + 5665

    5    libc.so.6                          0x00002b352bb5b460 __libc_start_main +
    245

    6    tmptegf64j_                        0x00005644b94a11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest: Int?\n    var index = lst.startIndex\n \
    \   while index != lst.endIndex {\n        if smallest == nil {\n            smallest\
    \ = lst[index]\n        }\n        if lst[index] > smallest {\n            return\
    \ smallest\n        } else {\n            index--\n        }\n    }\n    return\
    \ smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp0gts6zce.swift:20:25: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if lst[index] > smallest {\n\
    \                        ^\n/tmp/tmp0gts6zce.swift:20:25: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        if\
    \ lst[index] > smallest {\n                        ^\n                       \
    \          ?? <#default value#>\n/tmp/tmp0gts6zce.swift:20:25: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ lst[index] > smallest {\n                        ^\n                       \
    \         !\n/tmp/tmp0gts6zce.swift:23:18: error: cannot find operator '--' in\
    \ scope; did you mean '-= 1'?\n            index--\n                 ^~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted { $0 < $1 }.first?.successor()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpgcl9ct_7.swift:14:42: error: value of type 'Int' has no member\
    \ 'successor'\n    return lst.sorted { $0 < $1 }.first?.successor()\n        \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted(by: <)[1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b40dc3f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40dc0ec561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b40dc0ec286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b40dc0ec13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b40dc0ebbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b40dbeebe83 <unavailable> + 188035

    6    tmpd1vr9qrb                        0x000055ed3eb3ed2e <unavailable> + 7470

    7    tmpd1vr9qrb                        0x000055ed3eb3e668 <unavailable> + 5736

    8    libc.so.6                          0x00002b40dc5e1460 __libc_start_main +
    245

    9    tmpd1vr9qrb                        0x000055ed3eb3e029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    \n    guard lst.count > 0 else { return nil }\n    \n\
    \    return lst.sorted(by: <)[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpvqug45u_/tmpvqug45u_.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1df5475c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1df516cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1df516c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1df516b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvqug45u_                        0x0000559aa7d3c88a <unavailable> + 6282

    5    libc.so.6                          0x00002b1df5661460 __libc_start_main +
    245

    6    tmpvqug45u_                        0x0000559aa7d3c089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted(by: >).second\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpbs7i43p7.swift:14:30: error: value of type '[Int]' has no member\
    \ 'second'\n    return lst.sorted(by: >).second\n           ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 { return nil }\n    if lst.count > 2\
    \ {\n        return lst[smallestIndex(lst)]\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpgtu8wwk5.swift:16:20: error: cannot find 'smallestIndex' in scope\n\
    \        return lst[smallestIndex(lst)]\n                   ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    return\
    \ lst[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmppo_j25yj/tmppo_j25yj.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27734f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27731edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27731ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27731ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppo_j25yj                        0x0000563e02327635 <unavailable> + 5685

    5    libc.so.6                          0x00002b27736e2460 __libc_start_main +
    245

    6    tmppo_j25yj                        0x0000563e02327019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for x in lst {\n        if\
    \ x < smallest {\n            smallest = x\n        }\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmprvvjxaw5/tmprvvjxaw5.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95cbb61c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95cb858b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95cb858988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95cb8577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprvvjxaw5                        0x000055a8301455a1 <unavailable> + 5537

    5    libc.so.6                          0x00002b95cbd4d460 __libc_start_main +
    245

    6    tmprvvjxaw5                        0x000055a830145129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013418
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else {\n        return nil\n    }\n\
    \    let min = lst[0]\n    for v in lst.dropFirst() {\n        if v < min {\n\
    \            min = v\n        }\n    }\n    return min\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpnjwwsk3o.swift:20:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = v\n            ^~~\n/tmp/tmpnjwwsk3o.swift:17:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = lst[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    if lst.count > 1 {\n      \
    \  for i in 1..<lst.count {\n            if lst[i] < smallest {\n            \
    \    smallest = lst[i]\n            }\n        }\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpze97hic8/tmpze97hic8.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae80d1b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae80ceaeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae80ceae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae80cead7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpze97hic8                        0x000055c947aae621 <unavailable> + 5665

    5    libc.so.6                          0x00002ae80d3a3460 __libc_start_main +
    245

    6    tmpze97hic8                        0x000055c947aae1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else { return nil }\n    guard lst.count\
    \ > 1 else {\n        return lst[0]\n    }\n    var smallestIndex = lst.startIndex\n\
    \    var secondSmallestIndex = lst.startIndex\n    for i in lst.startIndex..<lst.endIndex\
    \ {\n        if lst[i] < lst[smallestIndex] {\n            smallestIndex = i\n\
    \        }\n        if lst[i] < lst[secondSmallestIndex] {\n            secondSmallestIndex\
    \ = i\n        }\n    }\n    return lst[secondSmallestIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpqb14umm9/tmpqb14umm9.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e96c9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e96995b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e96995988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e969947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqb14umm9                        0x00005621e0da16d1 <unavailable> + 5841

    5    libc.so.6                          0x00002b2e96e8a460 __libc_start_main +
    245

    6    tmpqb14umm9                        0x00005621e0da1259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.indices.contains((lst.first?.pointee)!) ? lst[lst.first!\
    \ + 1] : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp8fgppsd9.swift:14:45: error: value of type 'Int' has no member\
    \ 'pointee'\n    return lst.indices.contains((lst.first?.pointee)!) ? lst[lst.first!\
    \ + 1] : nil\n                                 ~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    switch lst.count {\n    case 0: return nil\n    case 1:\
    \ return lst[0]\n    case 2: return min(lst[0], lst[1])\n    default:\n      \
    \  var minIdx = lst.count\n        var min = lst[minIdx]\n        for idx in lst.indices\
    \ {\n            if let newMin = lst[idx - 1] {\n                if newMin < min\
    \ {\n                    minIdx = idx\n                    min = newMin\n    \
    \            }\n            }\n        }\n        return min\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp2dcyr28f.swift:22:16: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n            if let newMin = lst[idx - 1]\
    \ {\n               ^            ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count <= 1 {\n        return nil\n    }\n    let\
    \ idx = lst.index(before: lst.index(lst.startIndex, offsetBy: 1))\n    if idx\
    \ == lst.startIndex {\n        return nil\n    }\n    return lst[idx]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpc_ggojew/tmpc_ggojew.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae73875ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae738451b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae738451988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7384507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc_ggojew                        0x0000555938e765a1 <unavailable> + 5537

    5    libc.so.6                          0x00002ae738946460 __libc_start_main +
    245

    6    tmpc_ggojew                        0x0000555938e76129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for i in lst {\n        if\
    \ i < smallest {\n            smallest = i\n        }\n    }\n    return smallest\
    \ == lst[0] ? nil : smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpu90q5evz/tmpu90q5evz.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b054845bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0548152b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0548152988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05481517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu90q5evz                        0x00005647e2afe5a1 <unavailable> + 5537

    5    libc.so.6                          0x00002b0548647460 __libc_start_main +
    245

    6    tmpu90q5evz                        0x00005647e2afe129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    for i in lst {\n        if i == lst[0] {\n           \
    \ lst.remove(at: 0)\n            return i\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpiqoy_3he.swift:16:17: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n            lst.remove(at: 0)\n          \
    \  ~~~ ^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty {\n        return nil\n    }\n    \n  \
    \  var smallest = lst[0]\n    if let idx = lst.index(of: smallest) {\n       \
    \ smallest = lst[idx]\n    }\n    \n    if smallest.isMultiple(of: lst[1]) {\n\
    \        return nil\n    }\n    \n    return smallest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpnc6bv1mo/tmpnc6bv1mo.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adb8c828c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adb8c51fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adb8c51f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adb8c51e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnc6bv1mo                        0x000055565f72f641 <unavailable> + 5697

    5    libc.so.6                          0x00002adb8ca14460 __libc_start_main +
    245

    6    tmpnc6bv1mo                        0x000055565f72f1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty { return nil }\n    \n    if lst.count\
    \ < 2 {\n        return nil\n    }\n    \n    var smallest = lst.first!\n    var\
    \ i = 2\n    \n    for value in lst {\n        if value < smallest {\n       \
    \     smallest = value\n        } else {\n            i += 1\n        }\n    }\n\
    \    \n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpjmbr675a/tmpjmbr675a.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b307236ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3072065b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3072065988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30720647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjmbr675a                        0x0000556a8b3ba6f1 <unavailable> + 5873

    5    libc.so.6                          0x00002b307255a460 __libc_start_main +
    245

    6    tmpjmbr675a                        0x0000556a8b3ba279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest: Int = Int.max\n    for i in lst {\n    \
    \    if smallest > i {\n            smallest = i\n        }\n    }\n    if smallest\
    \ == Int.max {\n        return nil\n    }\n    return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp97d1f23b/tmp97d1f23b.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49fccb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49fc9aab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49fc9aa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49fc9a97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp97d1f23b                        0x000055e6dc8ac551 <unavailable> + 5457

    5    libc.so.6                          0x00002b49fce9f460 __libc_start_main +
    245

    6    tmp97d1f23b                        0x000055e6dc8ac0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else {\n        return nil\n    }\n\
    \    guard lst.count > 2 else {\n        return lst[1]\n    }\n    let min_ele\
    \ = lst[lst.index(lst.minElement()!)]\n    return lst.index {\n        $0 == min_ele\n\
    \    }[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpbo9gq5ed.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n    let min_ele = lst[lst.index(lst.minElement()!)]\n      \
    \                    ^\n/tmp/tmpbo9gq5ed.swift:20:27: note: found candidate with\
    \ type '(Int) -> Int'\n    let min_ele = lst[lst.index(lst.minElement()!)]\n \
    \                         ^\n/tmp/tmpbo9gq5ed.swift:20:27: note: found candidate\
    \ with type '(Int) -> Int'\n    let min_ele = lst[lst.index(lst.minElement()!)]\n\
    \                          ^\n/tmp/tmpbo9gq5ed.swift:20:37: error: value of type\
    \ '[Int]' has no member 'minElement'\n    let min_ele = lst[lst.index(lst.minElement()!)]\n\
    \                                ~~~ ^~~~~~~~~~\n/tmp/tmpbo9gq5ed.swift:23:6:\
    \ error: value of type 'Array<Int>.Index?' (aka 'Optional<Int>') has no subscripts\n\
    \    }[1]\n~~~~~^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    var\
    \ smallest = lst[0]\n    var nextSmallest = lst[1]\n    for index in 2..lst.count\
    \ {\n        if smallest.isLesserThan {\n            smallest = lst[index]\n \
    \           nextSmallest = lst[index - 1]\n        }\n    }\n    return nextSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpoksz6e8y.swift:19:19: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for index in 2..lst.count {\n                  ^~\n\
    \                  ...\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.count == 0 {\n    return nil\n  }\n\n  if lst.count\
    \ == 1 {\n    return lst[0]\n  }\n\n  let smallest = lst[0]\n  let smallestIndex\
    \ = 0\n\n  for index in lst.indices {\n    if smallestIndex == index {\n     \
    \ continue\n    }\n    if lst[index] < smallest {\n      smallestIndex = index\n\
    \      smallest = lst[index]\n    }\n  }\n\n  return smallestIndex < lst.count\
    \ - 1 ? lst[smallestIndex + 1] : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpsxoqbjtf.swift:30:7: error: cannot assign to value: 'smallestIndex'\
    \ is a 'let' constant\n      smallestIndex = index\n      ^~~~~~~~~~~~~\n/tmp/tmpsxoqbjtf.swift:23:3:\
    \ note: change 'let' to 'var' to make it mutable\n  let smallestIndex = 0\n  ^~~\n\
    \  var\n/tmp/tmpsxoqbjtf.swift:31:7: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n      smallest = lst[index]\n      ^~~~~~~~\n/tmp/tmpsxoqbjtf.swift:22:3:\
    \ note: change 'let' to 'var' to make it mutable\n  let smallest = lst[0]\n  ^~~\n\
    \  var\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  return lst.sorted(by: <)[1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b924f478c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b924f16f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b924f16f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b924f16f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b924f16ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b924ef6ee83 <unavailable> + 188035

    6    tmpsa2krrnt                        0x0000559bebf81d2e <unavailable> + 7470

    7    tmpsa2krrnt                        0x0000559bebf81668 <unavailable> + 5736

    8    libc.so.6                          0x00002b924f664460 __libc_start_main +
    245

    9    tmpsa2krrnt                        0x0000559bebf81029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else {\n        return nil\n    }\n\
    \    var smallestVal = lst[0]\n    var secondSmallestVal = lst[0]\n    for i in\
    \ 1..<lst.count {\n        if lst[i] < smallestVal {\n            smallestVal\
    \ = lst[i]\n        } else if lst[i] > secondSmallestVal {\n            secondSmallestVal\
    \ = lst[i]\n        }\n    }\n    return secondSmallestVal\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpx78tyjza/tmpx78tyjza.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aadcee2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aadceb21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aadceb21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aadceb207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx78tyjza                        0x000056289052a621 <unavailable> + 5665

    5    libc.so.6                          0x00002aadcf016460 __libc_start_main +
    245

    6    tmpx78tyjza                        0x000056289052a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    for el in lst {\n        if let idx = lst.index(of: el)\
    \ {\n            if idx > 0 && lst[idx - 1] < el {\n                return el\n\
    \            }\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpd9x4gwvx/tmpd9x4gwvx.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3fdf54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3fdc4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3fdc4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3fdc4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd9x4gwvx                        0x000055c7baa127b5 <unavailable> + 6069

    5    libc.so.6                          0x00002ab3fe140460 __libc_start_main +
    245

    6    tmpd9x4gwvx                        0x000055c7baa12199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sort.reverse()[1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpm5avmmn1.swift:14:16: error: no exact matches in reference to instance\
    \ method 'sort'\n    return lst.sort.reverse()[1]\n               ^\n/tmp/tmpm5avmmn1.swift:14:16:\
    \ note: found candidate with type '() -> ()'\n    return lst.sort.reverse()[1]\n\
    \               ^\n/tmp/tmpm5avmmn1.swift:14:16: note: found candidate with type\
    \ '((Int, Int) throws -> Bool) throws -> ()'\n    return lst.sort.reverse()[1]\n\
    \               ^\n/tmp/tmpm5avmmn1.swift:14:21: error: reference to member 'reverse'\
    \ cannot be resolved without a contextual type\n    return lst.sort.reverse()[1]\n\
    \                    ^\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  guard lst.count > 1 else { return nil }\n  return lst.sorted(by:\
    \ <)[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmprr2lygu4/tmprr2lygu4.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e3d225c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e3cf1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e3cf1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e3cf1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprr2lygu4                        0x000056403a51388a <unavailable> + 6282

    5    libc.so.6                          0x00002b2e3d411460 __libc_start_main +
    245

    6    tmprr2lygu4                        0x000056403a513089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  var index: Int = 1\n  var i: Int\n  for i = 0, index < lst.count;\
    \ i += 1  {\n    if lst[i] == lst[index] {\n      index += 1\n    } else {\n \
    \     return lst[index]\n    }\n  }\n  return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpevindlgc.swift:16:3: error: C-style for statement has been removed\
    \ in Swift 3\n  for i = 0, index < lst.count; i += 1  {\n  ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  var smallest = lst[0]\n  var index = 0\n  for item in lst\
    \ {\n    if smallest > item {\n      index = index + 1\n      smallest = item\n\
    \    }\n  }\n  if index == 0 {\n    return nil\n  }\n  return smallest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmptrczhrc7/tmptrczhrc7.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e4c2dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e4bfd5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e4bfd5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e4bfd47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptrczhrc7                        0x00005624c04535a1 <unavailable> + 5537

    5    libc.so.6                          0x00002b0e4c4ca460 __libc_start_main +
    245

    6    tmptrczhrc7                        0x00005624c0453129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.isEmpty() {\n    return nil\n  }\n  return lst.reduce(0,\
    \ { $0 < $1 ? $0 : Int(min($0, $1)) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmphiwl00as.swift:14:10: error: cannot call value of non-function\
    \ type 'Bool'\n  if lst.isEmpty() {\n         ^      ~~\n                \n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest: Int? = nil\n    for element in lst {\n \
    \       if smallest == nil {\n            smallest = element\n            continue\n\
    \        }\n        if element < smallest {\n            smallest = element\n\
    \        }\n    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpowl8mtiy.swift:20:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if element < smallest {\n   \
    \                  ^\n/tmp/tmpowl8mtiy.swift:20:22: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        if element\
    \ < smallest {\n                     ^\n                              ?? <#default\
    \ value#>\n/tmp/tmpowl8mtiy.swift:20:22: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        if element < smallest\
    \ {\n                     ^\n                             !\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest: Int?\n    if lst.count > 0 {\n        var\
    \ min_i: Int?\n        for i = 0; i <= lst.count - 1; i++ {\n            if min_i\
    \ == nil {\n                if smallest! > lst[i] {\n                    min_i\
    \ = lst[i]\n                }\n            } else {\n                if smallest!\
    \ < lst[i] {\n                    min_i = lst[i]\n                }\n        \
    \    }\n        }\n    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp53hbgn43.swift:17:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for i = 0; i <= lst.count - 1; i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for element in lst[1..] {\n\
    \        if element < smallest {\n            smallest = element\n        }\n\
    \    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp4p8tbl2g.swift:15:25: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for element in lst[1..] {\n                       \
    \ ^~\n                        ...\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else {\n        return nil\n    }\n\
    \    var idx = lst.firstIndex(of: lst.min()!)\n    guard idx != lst.firstIndex(of:\
    \ lst.min()!) else {\n        return nil\n    }\n    idx += 1\n    if idx < lst.count\
    \ {\n        return lst[idx]\n    } else {\n        return nil\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmptj4t0a13.swift:21:5: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n    idx += 1\n    ^\n/tmp/tmptj4t0a13.swift:21:5: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    idx +=\
    \ 1\n    ^\n       !\n/tmp/tmptj4t0a13.swift:22:8: error: value of optional type\
    \ 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to a value of type\
    \ 'Array<Int>.Index' (aka 'Int')\n    if idx < lst.count {\n       ^\n/tmp/tmptj4t0a13.swift:22:8:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    if idx < lst.count {\n       ^\n           ?? <#default value#>\n\
    /tmp/tmptj4t0a13.swift:22:8: note: force-unwrap using '!' to abort execution if\
    \ the optional value contains 'nil'\n    if idx < lst.count {\n       ^\n    \
    \      !\n/tmp/tmptj4t0a13.swift:23:20: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n        return lst[idx]\n                   ^\n/tmp/tmptj4t0a13.swift:23:20:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return lst[idx]\n                   ^\n                     \
    \  ?? <#default value#>\n/tmp/tmptj4t0a13.swift:23:20: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        return\
    \ lst[idx]\n                   ^\n                      !\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted { $0 > $1 }.first\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpvsh_unbn/tmpvsh_unbn.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7702bb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77028aab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77028aa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77028a97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvsh_unbn                        0x0000560903bcc4f1 <unavailable> + 5361

    5    libc.so.6                          0x00002b7702d9f460 __libc_start_main +
    245

    6    tmpvsh_unbn                        0x0000560903bcc079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.reduce((first, second) in (first > second ?\
    \ first : second)) ?? nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmprygqz6is.swift:14:39: error: expected ',' separator\n    return\
    \ lst.reduce((first, second) in (first > second ? first : second)) ?? nil\n  \
    \                                    ^\n                                     ,\n\
    /tmp/tmprygqz6is.swift:14:39: error: expected expression in list of expressions\n\
    \    return lst.reduce((first, second) in (first > second ? first : second)) ??\
    \ nil\n                                      ^\n/tmp/tmprygqz6is.swift:14:24:\
    \ error: cannot find 'first' in scope\n    return lst.reduce((first, second) in\
    \ (first > second ? first : second)) ?? nil\n                       ^~~~~\n/tmp/tmprygqz6is.swift:14:31:\
    \ error: cannot find 'second' in scope\n    return lst.reduce((first, second)\
    \ in (first > second ? first : second)) ?? nil\n                             \
    \ ^~~~~~\n/tmp/tmprygqz6is.swift:14:23: error: instance method 'reduce' expects\
    \ 2 separate arguments; remove extra parentheses to change tuple into separate\
    \ arguments\n    return lst.reduce((first, second) in (first > second ? first\
    \ : second)) ?? nil\n                      ^             ~\n                 \
    \                   \nSwift.Sequence:2:28: note: 'reduce' declared here\n    @inlinable\
    \ public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_\
    \ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = Int?(lst[0])\n    if lst.count > 1 {\n\
    \        for n in lst.dropFirst() {\n            if smallest == nil {\n      \
    \          smallest = (n as! Int)\n            } else {\n                if n\
    \ < smallest {\n                    smallest = (n as! Int)\n                }\n\
    \            }\n        }\n    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpjowobwq1.swift:18:31: warning: forced cast of 'Int' to same type\
    \ has no effect\n                smallest = (n as! Int)\n                    \
    \          ^~~~~~~\n                              \n/tmp/tmpjowobwq1.swift:20:24:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \                if n < smallest {\n                       ^\n/tmp/tmpjowobwq1.swift:20:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n                if n < smallest {\n                       ^\n       \
    \                         ?? <#default value#>\n/tmp/tmpjowobwq1.swift:20:24:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n                if n < smallest {\n                       ^\n       \
    \                        !\n/tmp/tmpjowobwq1.swift:21:35: warning: forced cast\
    \ of 'Int' to same type has no effect\n                    smallest = (n as! Int)\n\
    \                                  ^~~~~~~\n                                 \
    \ \n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 2 else {\n        return nil\n    }\n\
    \    let smallest = min(lst)\n    let nextSmallest = lst.firstIndex(of: smallest)!\
    \ + 1\n    return lst[nextSmallest]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpo0so305_.swift:17:27: error: missing argument for parameter #2\
    \ in call\n    let smallest = min(lst)\n                          ^\n        \
    \                  , <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n\n    var smallest\
    \ = lst[0]\n    var secondSmallestIndex = lst.index(smallest)\n\n    for i in\
    \ 1..<lst.count {\n        if lst[i] < smallest {\n            secondSmallestIndex\
    \ = i\n            smallest = lst[i]\n        }\n    }\n\n    return lst[secondSmallestIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpc3hv90xb.swift:17:35: error: no exact matches in call to instance\
    \ method 'index'\n    var secondSmallestIndex = lst.index(smallest)\n        \
    \                          ^\nSwift.Array:7:28: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(after:)')\n    @inlinable public func index(after\
    \ i: Int) -> Int\n                           ^\nSwift.Array:9:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public\
    \ func index(before i: Int) -> Int\n                           ^\nSwift.Collection:3:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(of:)')\n   \
    \ @inlinable public func index(of element: Self.Element) -> Self.Index?\n    \
    \                       ^\nSwift.RandomAccessCollection:3:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(after:)')\n    @inlinable public\
    \ func index(after i: Self.Index) -> Self.Index\n                           ^\n\
    Swift.RandomAccessCollection:4:28: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(before:)')\n    @inlinable public func index(before i: Self.Index)\
    \ -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else {\n        return nil\n    }\n\
    \    var smallest: Int? = nil\n    var secondSmallest: Int? = nil\n    for i in\
    \ lst {\n        if smallest? == nil || (i < smallest?) {\n            smallest?\
    \ = i\n        } else if secondSmallest? == nil || (i < secondSmallest?) {\n \
    \           secondSmallest? = i\n        }\n    }\n    return secondSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp8u5aqp6z.swift:20:45: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if smallest? == nil || (i < smallest?)\
    \ {\n                                            ^\n/tmp/tmp8u5aqp6z.swift:20:45:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if smallest? == nil || (i < smallest?) {\n                  \
    \                          ^\n                                              ??\
    \ <#default value#>\n/tmp/tmp8u5aqp6z.swift:20:45: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        if smallest?\
    \ == nil || (i < smallest?) {\n                                            ^\n\
    \                                    (        )!\n/tmp/tmp8u5aqp6z.swift:22:64:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        } else if secondSmallest? == nil || (i < secondSmallest?) {\n       \
    \                                                        ^\n/tmp/tmp8u5aqp6z.swift:22:64:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        } else if secondSmallest? == nil || (i < secondSmallest?) {\n\
    \                                                               ^\n          \
    \                                                       ?? <#default value#>\n\
    /tmp/tmp8u5aqp6z.swift:22:64: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        } else if secondSmallest? == nil\
    \ || (i < secondSmallest?) {\n                                               \
    \                ^\n                                                 (       \
    \       )!\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  var smallest = lst[0]\n  for el in lst {\n    if el < smallest\
    \ {\n      smallest = el\n    }\n  }\n  return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpovo5afoq/tmpovo5afoq.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae54228cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae541f83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae541f83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae541f827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpovo5afoq                        0x0000564b08f325a1 <unavailable> + 5537

    5    libc.so.6                          0x00002ae542478460 __libc_start_main +
    245

    6    tmpovo5afoq                        0x0000564b08f32129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var cur = lst[0]\n    var result = cur\n    if lst.count\
    \ > 1 {\n        let index = 1\n        while index+1 < lst.count {\n        \
    \    if lst[index] < cur {\n                cur = lst[index]\n               \
    \ result = lst[index+1]\n            }\n            index += 1\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpchakkead.swift:23:19: error: left side of mutating operator isn't\
    \ mutable: 'index' is a 'let' constant\n            index += 1\n            ~~~~~\
    \ ^\n/tmp/tmpchakkead.swift:17:9: note: change 'let' to 'var' to make it mutable\n\
    \        let index = 1\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted { $0 < $1 }.first\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpar2q30jh/tmpar2q30jh.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6ec3aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6ec0a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba6ec0a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6ec0a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpar2q30jh                        0x000055640c51d4f1 <unavailable> + 5361

    5    libc.so.6                          0x00002ba6ec59a460 __libc_start_main +
    245

    6    tmpar2q30jh                        0x000055640c51d079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013584
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for el in lst[1..] {\n    \
    \    if smallest > el {\n            smallest = el\n        }\n    }\n    return\
    \ smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpnmpn7qx5.swift:15:20: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for el in lst[1..] {\n                   ^~\n     \
    \              ...\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    guard lst.count\
    \ >= 2 else {\n        return nil\n    }\n    var smallestIndex = lst.index {\n\
    \        guard let i1 = $1, let i2 = lst.index($1, offsetBy: i1),\n          \
    \    i1 == i2 || i1 < i2 else { return false }\n        return true\n    }\n \
    \   guard smallestIndex != lst.count else { return nil }\n    return lst[smallestIndex\
    \ + 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpyldcpkcl.swift:18:35: error: contextual closure type '(Int) throws\
    \ -> Bool' expects 1 argument, but 2 were used in closure body\n    var smallestIndex\
    \ = lst.index {\n                                  ^\n/tmp/tmpyldcpkcl.swift:19:24:\
    \ note: anonymous closure parameter '$1' is used here\n        guard let i1 =\
    \ $1, let i2 = lst.index($1, offsetBy: i1),\n                       ^\n/tmp/tmpyldcpkcl.swift:19:47:\
    \ note: anonymous closure parameter '$1' is used here\n        guard let i1 =\
    \ $1, let i2 = lst.index($1, offsetBy: i1),\n                                \
    \              ^\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 0 else {\n        return nil\n    }\n\
    \    let smallest = lst[0]\n    for num in lst {\n        if smallest > num {\n\
    \            smallest = num\n        }\n    }\n    return smallest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp4f76zqzs.swift:20:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = num\n            ^~~~~~~~\n/tmp/tmp4f76zqzs.swift:17:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = lst[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    for i in lst {\n        if i < lst[0] {\n            return\
    \ i\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmppzqznqhf/tmppzqznqhf.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb20285c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb1ff7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb1ff7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb1ff7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppzqznqhf                        0x0000561a086c15a1 <unavailable> + 5537

    5    libc.so.6                          0x00002acb20471460 __libc_start_main +
    245

    6    tmppzqznqhf                        0x0000561a086c1129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.count == 0 {\n    return nil\n  }\n  \n  let min\
    \ = lst[0]\n  \n  for element in lst {\n    if element < min {\n      min = element\n\
    \    }\n  }\n  \n  return min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpkl6jq6jg.swift:22:7: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n      min = element\n      ^~~\n/tmp/tmpkl6jq6jg.swift:18:3:\
    \ note: change 'let' to 'var' to make it mutable\n  let min = lst[0]\n  ^~~\n\
    \  var\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.reduce(nil) { $0 as? Int ?? $1?.nextSmallest()\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(next_smallest(lst: [1, 2, 3,\
    \ 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp78c62931.swift:14:33: warning: conditional downcast from 'Int?'\
    \ to 'Int' does nothing\n    return lst.reduce(nil) { $0 as? Int ?? $1?.nextSmallest()\
    \ }\n                             ~~~^~~~~~~\n                               \n\
    /tmp/tmp78c62931.swift:14:46: error: cannot use optional chaining on non-optional\
    \ value of type 'Int'\n    return lst.reduce(nil) { $0 as? Int ?? $1?.nextSmallest()\
    \ }\n                                           ~~^\n                        \
    \                     \n/tmp/tmp78c62931.swift:14:48: error: value of type 'Int'\
    \ has no member 'nextSmallest'\n    return lst.reduce(nil) { $0 as? Int ?? $1?.nextSmallest()\
    \ }\n                                           ~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst[safeIndex(lst, lst.startIndex, Int::min)] ??\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpklj6svj2.swift:14:51: error: expected expression in list of expressions\n\
    \    return lst[safeIndex(lst, lst.startIndex, Int::min)] ?? nil\n           \
    \                                       ^\n/tmp/tmpklj6svj2.swift:14:16: error:\
    \ cannot find 'safeIndex' in scope\n    return lst[safeIndex(lst, lst.startIndex,\
    \ Int::min)] ?? nil\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    // TODO: Optimize this!\n    if lst.count == 0 {\n   \
    \     return nil\n    }\n    if lst.count == 1 {\n        return lst[0]\n    }\n\
    \    let index = lst.index(of: lst[1])\n    return index == nil ? nil : lst[index!\
    \ + 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpsexubvev/tmpsexubvev.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b60f25f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60f22e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b60f22e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60f22e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsexubvev                        0x0000564cec4315d1 <unavailable> + 5585

    5    libc.so.6                          0x00002b60f27de460 __libc_start_main +
    245

    6    tmpsexubvev                        0x0000564cec431159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    if lst.count == 1 {\n     \
    \   return nil\n    }\n    for x in lst {\n        if x < smallest {\n       \
    \     smallest = x\n        }\n    }\n    return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmprzxrgr9s/tmprzxrgr9s.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b611ae74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b611ab6bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b611ab6b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b611ab6a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprzxrgr9s                        0x0000561116599601 <unavailable> + 5633

    5    libc.so.6                          0x00002b611b060460 __libc_start_main +
    245

    6    tmprzxrgr9s                        0x0000561116599189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.count == 0 {\n    return nil\n  }\n  guard lst.count\
    \ > 2 else {\n    return nil\n  }\n  var i, count = lst.count\n  while count >\
    \ 0 {\n    count--\n    i = lst.index(lst.startIndex, offsetBy: 1)\n    lst[i]\
    \ = nil\n  }\n  lst.sort()\n  if lst.count == 0 {\n    return nil\n  }\n  return\
    \ lst.last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpyravt5sb.swift:20:7: error: type annotation missing in pattern\n\
    \  var i, count = lst.count\n      ^\n/tmp/tmpyravt5sb.swift:22:10: error: cannot\
    \ find operator '--' in scope; did you mean '-= 1'?\n    count--\n         ^~\n\
    /tmp/tmpyravt5sb.swift:26:7: error: cannot use mutating member on immutable value:\
    \ 'lst' is a 'let' constant\n  lst.sort()\n  ~~~ ^\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    for elem in lst {\n       \
    \ if elem < smallest {\n            smallest = elem\n        }\n    }\n    return\
    \ smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpo8eeamb9/tmpo8eeamb9.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada18cdcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada189d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada189d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada189d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo8eeamb9                        0x000055939048f5a1 <unavailable> + 5537

    5    libc.so.6                          0x00002ada18ec8460 __libc_start_main +
    245

    6    tmpo8eeamb9                        0x000055939048f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let result = lst.minElement()\n    lst.removeAtIndex(lst.index(of:\
    \ result))\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpkyrz3lve.swift:14:22: error: value of type '[Int]' has no member\
    \ 'minElement'\n    let result = lst.minElement()\n                 ~~~ ^~~~~~~~~~\n\
    /tmp/tmpkyrz3lve.swift:15:9: error: value of type '[Int]' has no member 'removeAtIndex'\n\
    \    lst.removeAtIndex(lst.index(of: result))\n    ~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 { return nil }\n    var smallest = lst[0]\n\
    \    var index = lst.index { ($0 as Int) < (smallest as Int) }\n    if index ==\
    \ 0 { return nil }\n    smallest = lst[index - 1]\n    return smallest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp2jd54w4a.swift:16:21: warning: 'index(where:)' is deprecated: renamed\
    \ to 'firstIndex(where:)'\n    var index = lst.index { ($0 as Int) < (smallest\
    \ as Int) }\n                    ^\n/tmp/tmp2jd54w4a.swift:16:21: note: use 'firstIndex(where:)'\
    \ instead\n    var index = lst.index { ($0 as Int) < (smallest as Int) }\n   \
    \                 ^~~~~\n                    firstIndex\n/tmp/tmp2jd54w4a.swift:18:20:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n    smallest\
    \ = lst[index - 1]\n                   ^\n/tmp/tmp2jd54w4a.swift:18:20: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    smallest = lst[index - 1]\n                   ^\n                   (   \
    \  ?? <#default value#>)\n/tmp/tmp2jd54w4a.swift:18:20: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    smallest =\
    \ lst[index - 1]\n                   ^\n                        !\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.count < 2 {\n    return nil\n  }\n  let (smallest,\
    \ largest) = (lst[0], lst[lst.count-1])\n  for i in 1..lst.count - 2 {\n    let\
    \ x = lst[i]\n    let y = lst[i+1]\n    if x < y {\n      smallest = x\n     \
    \ largest = y\n    } else if x > y {\n      largest = x\n      smallest = y\n\
    \    } else {\n      return nil\n    }\n  }\n  return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpbe51asjd.swift:18:13: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n  for i in 1..lst.count - 2 {\n            ^~\n       \
    \     ...\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  var smallest = lst[0]\n  var index = 1\n  \n  // Find smallest\
    \ element by binary search, starting at index 1\n  while index < lst.count {\n\
    \    if smallest*smallest > lst[index] {\n      smallest = lst[index]\n      index\
    \ += 2\n    } else if smallest*smallest == lst[index] {\n      index += 2\n  \
    \  } else {\n      return smallest\n    }\n  }\n  return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpupzquclb/tmpupzquclb.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87fdd4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87fda45b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87fda45988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87fda447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpupzquclb                        0x000055fd94ddd491 <unavailable> + 5265

    5    libc.so.6                          0x00002b87fdf3a460 __libc_start_main +
    245

    6    tmpupzquclb                        0x000055fd94ddd019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted(by: { $0 < $1 }).next()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpgmnvjp9s.swift:14:40: error: value of type '[Int]' has no member\
    \ 'next'\n    return lst.sorted(by: { $0 < $1 }).next()\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660013585
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    \n    // Using\
    \ two pointers to find the next smallest element\n    var min1 =  lst.startIndex\n\
    \    var min2 = lst.startIndex\n    \n    while min2 < lst.endIndex {\n      \
    \  guard let min1val = lst[min1], let min2val = lst[min2] else { return nil }\n\
    \        min1 = min1 + 1\n        min2 = min2 + 1\n        \n        if min1 <\
    \ min2 {\n            swap(&lst[min1], &lst[min2])\n        }\n    }\n    \n \
    \   return lst[min1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpf9fndryy.swift:21:15: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n        guard let min1val = lst[min1], let\
    \ min2val = lst[min2] else { return nil }\n              ^             ~~~~~~~~~\n\
    /tmp/tmpf9fndryy.swift:21:40: error: initializer for conditional binding must\
    \ have Optional type, not 'Int'\n        guard let min1val = lst[min1], let min2val\
    \ = lst[min2] else { return nil }\n                                       ^  \
    \           ~~~~~~~~~\n/tmp/tmpf9fndryy.swift:26:18: error: cannot pass immutable\
    \ value as inout argument: 'lst' is a 'let' constant\n            swap(&lst[min1],\
    \ &lst[min2])\n                 ^~~~\n/tmp/tmpf9fndryy.swift:26:30: error: cannot\
    \ pass immutable value as inout argument: 'lst' is a 'let' constant\n        \
    \    swap(&lst[min1], &lst[min2])\n                             ^~~~\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count <= 1 {\n        return nil\n    }\n    let\
    \ first = lst[0]\n    guard let _ = lst.index(of: first) else { return nil }\n\
    \    return lst[lst.index(of: first)+1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpj451bzuv.swift:18:23: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let _ = lst.index(of: first) else { return nil\
    \ }\n                      ^\n/tmp/tmpj451bzuv.swift:18:23: note: use 'firstIndex(of:)'\
    \ instead\n    guard let _ = lst.index(of: first) else { return nil }\n      \
    \                ^~~~~\n                      firstIndex\n/tmp/tmpj451bzuv.swift:19:20:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n    return lst[lst.index(of:\
    \ first)+1]\n                   ^\n/tmp/tmpj451bzuv.swift:19:20: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ return lst[lst.index(of: first)+1]\n                   ^\n               ( \
    \                   ?? <#default value#>)\n/tmp/tmpj451bzuv.swift:19:20: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    return lst[lst.index(of: first)+1]\n                   ^\n              \
    \                     !\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 { return nil }\n    if lst.count <=\
    \ 1 {\n        return lst[0]\n    }\n    let i = lst.index {\n        if $0 <\
    \ lst.last {\n            return $0\n        } else if $0 < lst.last + 1 {\n \
    \           return $0 + 1\n        } else {\n            return $0\n        }\n\
    \    }\n    return lst[i+1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpws7s90xu.swift:19:21: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if $0 < lst.last {\n        \
    \            ^\n/tmp/tmpws7s90xu.swift:19:21: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        if $0 < lst.last {\n\
    \                    ^\n                         ?? <#default value#>\n/tmp/tmpws7s90xu.swift:19:21:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if $0 < lst.last {\n                    ^\n                 \
    \       !\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = Int?(0)\n    for ele in lst {\n       \
    \ if ele < smallest {\n            smallest = ele\n        }\n    }\n    if smallest\
    \ == nil {\n        return nil\n    }\n    return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp1t9ry7rd.swift:16:18: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if ele < smallest {\n       \
    \          ^\n/tmp/tmp1t9ry7rd.swift:16:18: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        if ele < smallest\
    \ {\n                 ^\n                          ?? <#default value#>\n/tmp/tmp1t9ry7rd.swift:16:18:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if ele < smallest {\n                 ^\n                   \
    \      !\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var idx: Int? = nil\n    for (i, e) in lst.enumerated()\
    \ {\n        if e < idx! {\n            idx = e\n        }\n    }\n    return\
    \ idx\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpupn1gcae/tmpupn1gcae.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c0183fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c01536561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9c01536286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9c0153613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9c01535bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpupn1gcae                        0x000055cde5f4106f <unavailable> + 8303

    6    tmpupn1gcae                        0x000055cde5f40547 <unavailable> + 5447

    7    libc.so.6                          0x00002b9c01a2b460 __libc_start_main +
    245

    8    tmpupn1gcae                        0x000055cde5f40219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else {\n        return nil\n    }\n\
    \n    var smallestIndex = lst.startIndex\n    var secondSmallestIndex = smallestIndex\n\
    \    var secondSmallestValue = lst[secondSmallestIndex]\n\n    for index in lst.indices\
    \ ..< lst.count - 1 {\n        if index == secondSmallestIndex {\n           \
    \ return nil\n        }\n        if secondSmallestValue > lst[index] {\n     \
    \       secondSmallestIndex = index\n            secondSmallestValue = lst[index]\n\
    \        }\n    }\n    return secondSmallestValue\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpjzbqr3o3.swift:22:22: error: cannot convert value of type 'Range<Array<Int>.Index>'\
    \ (aka 'Range<Int>') to expected argument type 'Int'\n    for index in lst.indices\
    \ ..< lst.count - 1 {\n                     ^\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var i = 0\n    var next = 1\n    for element in lst {\n\
    \        if i == 0 {\n            next = element\n        }\n        if next <\
    \ element {\n            next = element\n        }\n        i += 1\n    }\n  \
    \  return next\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpya_n4sae/tmpya_n4sae.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fc2bf0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fc28e7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fc28e7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fc28e67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpya_n4sae                        0x00005647385fa551 <unavailable> + 5457

    5    libc.so.6                          0x00002b9fc2ddc460 __libc_start_main +
    245

    6    tmpya_n4sae                        0x00005647385fa0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest: Int?\n    var index: Int?\n    for i in\
    \ lst {\n        if smallest == nil || i < smallest {\n            smallest =\
    \ i\n            index = i\n        } else {\n            if smallest != nil &&\
    \ smallest > i {\n                break\n            }\n        }\n    }\n   \
    \ return index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmphg3w8t3_.swift:17:35: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if smallest == nil || i < smallest\
    \ {\n                                  ^\n/tmp/tmphg3w8t3_.swift:17:35: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        if smallest == nil || i < smallest {\n                              \
    \    ^\n                                           ?? <#default value#>\n/tmp/tmphg3w8t3_.swift:17:35:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if smallest == nil || i < smallest {\n                      \
    \            ^\n                                          !\n/tmp/tmphg3w8t3_.swift:21:35:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            if smallest != nil && smallest > i {\n                          \
    \        ^\n/tmp/tmphg3w8t3_.swift:21:35: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n            if smallest !=\
    \ nil && smallest > i {\n                                  ^\n               \
    \                            ?? <#default value#>\n/tmp/tmphg3w8t3_.swift:21:35:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            if smallest != nil && smallest > i {\n                  \
    \                ^\n                                          !\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sort()[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp_w74ylxb.swift:14:16: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    return lst.sort()[1]\n           ~~~ ^\n\
    /tmp/tmp_w74ylxb.swift:14:22: error: value of type '()' has no subscripts\n  \
    \  return lst.sort()[1]\n           ~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest: Int?\n\n    for i := 0; i < lst.count; i++\
    \ {\n        if smallest? == nil || lst[i] < smallest {\n            smallest\
    \ = lst[i]\n        }\n    }\n\n    return smallest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpejecj2ey.swift:16:12: error: expected type\n    for i := 0; i <\
    \ lst.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpejecj2ey.swift:16:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < lst.count;\
    \ i++ {\n           ^\n/tmp/tmpejecj2ey.swift:16:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < lst.count; i++ {\n       \
    \    ^\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 { return nil }\n    guard let index\
    \ = lst.index(of: lst[0]) else {\n        return nil\n    }\n    return lst[index+1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpvojcv1ee/tmpvojcv1ee.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b709e374c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b709e06bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b709e06b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b709e06a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvojcv1ee                        0x000055f4d31e46e5 <unavailable> + 5861

    5    libc.so.6                          0x00002b709e560460 __libc_start_main +
    245

    6    tmpvojcv1ee                        0x000055f4d31e40c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.isEmpty() {\n        return nil\n    }\n    var\
    \ smallest = lst[0]\n    var smallestIndex = 1\n    for index in 1..<lst.count\
    \ {\n        if smallestIndex > lst.count {\n            return nil\n        }\n\
    \        if lst[index] < smallest {\n            smallestIndex = index\n     \
    \       smallest = lst[index]\n        }\n    }\n    return smallest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmprq1m0vzw.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    if\
    \ lst.count == 1 {\n        return lst[0]\n    }\n    return lst[lst.index(lst.startIndex,\
    \ offsetBy: 1) + 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp_dkwwl7v/tmp_dkwwl7v.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1e1dcec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac1e1ac5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac1e1ac5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1e1ac47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_dkwwl7v                        0x000055a59f83d551 <unavailable> + 5457

    5    libc.so.6                          0x00002ac1e1fba460 __libc_start_main +
    245

    6    tmp_dkwwl7v                        0x000055a59f83d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var result: Int? = nil\n    for index1 in 0..<lst.count\
    \ {\n        for index2 in 0..<lst.count {\n            if index1 == index2 {\n\
    \                continue\n            }\n            if let temp = lst[index1],\
    \ let temp2 = lst[index2] {\n                if temp > temp2 {\n             \
    \       result = temp\n                    break\n                } else if temp\
    \ < temp2 {\n                    break\n                }\n            }\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpx0nxpezm.swift:20:16: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n            if let temp = lst[index1], let\
    \ temp2 = lst[index2] {\n               ^          ~~~~~~~~~~~\n/tmp/tmpx0nxpezm.swift:20:40:\
    \ error: initializer for conditional binding must have Optional type, not 'Int'\n\
    \            if let temp = lst[index1], let temp2 = lst[index2] {\n          \
    \                             ^           ~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count > 0 {\n        var smallest = Int(lst[0])\n\
    \        for index in 1..lst.count {\n            if smallest.toInt() < (lst[index]).toInt()\
    \ {\n                smallest = lst[index]\n            }\n        }\n       \
    \ return smallest\n    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmprhj76zxr.swift:16:23: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n        for index in 1..lst.count {\n                 \
    \     ^~\n                      ...\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var smallestIndex\
    \ = lst.startIndex\n    guard smallestIndex.next != lst.endIndex else { return\
    \ nil }\n    var previous = smallestIndex\n    guard let previous = previous.next\
    \ else { return nil }\n    while previous == smallest {\n        previous = previous.next\n\
    \        if previous == smallest {\n            break\n        }\n    }\n    let\
    \ index = previous.index\n    guard index != smallestIndex.index else { return\
    \ nil }\n    guard previous.index != smallestIndex.index else { return nil }\n\
    \    let value = lst[index]\n    smallestIndex = index\n    if smallestIndex.next\
    \ == lst.endIndex {\n        return nil\n    }\n    return value\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpnawoupax.swift:16:25: error: value of type 'Int' has no member\
    \ 'next'\n    guard smallestIndex.next != lst.endIndex else { return nil }\n \
    \         ~~~~~~~~~~~~~ ^~~~\n/tmp/tmpnawoupax.swift:18:35: error: value of type\
    \ 'Int' has no member 'next'\n    guard let previous = previous.next else { return\
    \ nil }\n                         ~~~~~~~~ ^~~~\n/tmp/tmpnawoupax.swift:19:23:\
    \ error: cannot find 'smallest' in scope\n    while previous == smallest {\n \
    \                     ^~~~~~~~\n/tmp/tmpnawoupax.swift:21:24: error: cannot find\
    \ 'smallest' in scope\n        if previous == smallest {\n                   \
    \    ^~~~~~~~\n/tmp/tmpnawoupax.swift:26:34: error: value of type 'Int' has no\
    \ member 'index'\n    guard index != smallestIndex.index else { return nil }\n\
    \                   ~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpnawoupax.swift:27:43: error:\
    \ value of type 'Int' has no member 'index'\n    guard previous.index != smallestIndex.index\
    \ else { return nil }\n                            ~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpnawoupax.swift:30:22:\
    \ error: value of type 'Int' has no member 'next'\n    if smallestIndex.next ==\
    \ lst.endIndex {\n       ~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else {\n        return nil\n    }\n\
    \n    let n = lst.count\n    let first = lst.firstIndex({ $0 < $1 })\n    let\
    \ second = lst.firstIndex({ $0 < $1 })\n\n    if first < second {\n        return\
    \ lst[first]\n    }\n    return lst[second]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpl5tktfhd.swift:19:32: error: missing argument label 'where:' in\
    \ call\n    let first = lst.firstIndex({ $0 < $1 })\n                        \
    \       ^\n                               where: \n/tmp/tmpl5tktfhd.swift:20:33:\
    \ error: missing argument label 'where:' in call\n    let second = lst.firstIndex({\
    \ $0 < $1 })\n                                ^\n                            \
    \    where: \n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  var smallest = lst[0]\n  for elem in lst {\n    if smallest\
    \ > elem {\n      smallest = elem\n    }\n  }\n  return smallest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpj0bgbbv9/tmpj0bgbbv9.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3e7d7ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3e7a71b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3e7a71988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3e7a707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj0bgbbv9                        0x0000555bb679c5a1 <unavailable> + 5537

    5    libc.so.6                          0x00002ac3e7f66460 __libc_start_main +
    245

    6    tmpj0bgbbv9                        0x0000555bb679c129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count <= 1 {\n        return nil\n    }\n    let\
    \ smallest = lst[0]\n    var smallestIdx = 0\n    var idx = 0\n    for idx in\
    \ 1..lst.count {\n        if smallestIdx == idx {\n            smallestIdx +=\
    \ 1\n        }\n        if smallestIdx < idx {\n            smallestIdx = idx\n\
    \        }\n        if smallestIdx >= idx && smallestIdx < lst.count {\n     \
    \       if smallestIdx > idx {\n                idx += 1\n            }\n    \
    \        if smallest < lst[idx] {\n                smallestIdx = idx\n       \
    \         smallest = lst[idx]\n            }\n        }\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmph28ekz3k.swift:20:17: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for idx in 1..lst.count {\n                ^~\n   \
    \             ...\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.isEmpty == false else {\n        return nil\n\
    \    }\n    var smallest = lst[0]\n    var index = 1\n    for _ in 1..(lst.count)\
    \ {\n        if smallest > lst[index] {\n            smallest = lst[index]\n \
    \       }\n        index = (index + 1) % lst.count\n    }\n    return smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpn7zitk9r.swift:19:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for _ in 1..(lst.count) {\n              ^~\n     \
    \         ...\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    smallest = (lst[0] as Int)\
    \ + minElement(&lst[1 ..< lst.count])\n    return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpwz1mid5j.swift:15:34: error: cannot find 'minElement' in scope\n\
    \    smallest = (lst[0] as Int) + minElement(&lst[1 ..< lst.count])\n        \
    \                         ^~~~~~~~~~\n/tmp/tmpwz1mid5j.swift:15:45: error: cannot\
    \ pass immutable value as inout argument: 'lst' is a 'let' constant\n    smallest\
    \ = (lst[0] as Int) + minElement(&lst[1 ..< lst.count])\n                    \
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.count <= 2 {\n    return nil\n  }\n  var i = 0\n\
    \  var v = lst[0]\n  var found = false\n  for l! in lst {\n    if found {\n  \
    \    break\n    }\n    if lst == lst {\n      found = true\n      v = l\n    }\n\
    \    v = v * 10 + (l - i)\n    i += l\n  }\n  return v\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmplajw28ck.swift:20:8: error: expected 'in' after for-each pattern\n\
    \  for l! in lst {\n       ^\n/tmp/tmplajw28ck.swift:20:8: error: expected Sequence\
    \ expression for for-each loop\n  for l! in lst {\n       ^\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  var currentSmallest: Int = 0\n  var currentIndex: Int =\
    \ 0\n\n  for index in 0..<lst.count {\n    currentSmallest = currentSmallest >\
    \ lst[index] ? currentSmallest : lst[index]\n    if currentSmallest == lst[index]\
    \ {\n      currentIndex += 1\n    }\n  }\n\n  if currentIndex < lst.count {\n\
    \    return currentSmallest\n  }\n  return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp5j422wwb/tmp5j422wwb.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab012290c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab011f87b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab011f87988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab011f867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5j422wwb                        0x000055da08e6a621 <unavailable> + 5665

    5    libc.so.6                          0x00002ab01247c460 __libc_start_main +
    245

    6    tmp5j422wwb                        0x000055da08e6a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var min: Int? = nil\n    for i in lst {\n        if min\
    \ == nil || i < min {\n            min = i\n        }\n    }\n    return min\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpjhy7yhwl.swift:16:30: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if min == nil || i < min {\n\
    \                             ^\n/tmp/tmpjhy7yhwl.swift:16:30: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if min == nil || i < min {\n                             ^\n           \
    \                      ?? <#default value#>\n/tmp/tmpjhy7yhwl.swift:16:30: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        if min == nil || i < min {\n                             ^\n        \
    \                        !\n"
  stdout: ''
  timestamp: 1660013586
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp8awvsrxw/tmp8awvsrxw.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5819f26c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5819c1db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5819c1d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5819c1c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8awvsrxw                        0x0000558b7a8175e5 <unavailable> + 5605

    5    libc.so.6                          0x00002b581a112460 __libc_start_main +
    245

    6    tmp8awvsrxw                        0x0000558b7a816fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013586
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest: Int?\n    var minIndex: Int = 0\n    var\
    \ maxIndex: Int = 0\n    var count = 0\n    for index in 0..<lst.count {\n   \
    \     if smallest == nil || (smallest! > lst[index]) {\n            smallest =\
    \ lst[index]\n            minIndex = index\n        } else {\n            if smallest\
    \ == lst[index] {\n                count++\n            } else {\n           \
    \     smallest = nil\n            }\n        }\n        if count > 1 {\n     \
    \       maxIndex = index\n            break\n        }\n    }\n    if count >\
    \ 1 {\n        return nil\n    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp3kk7d7q5.swift:24:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                count++\n                     ^~\n"
  stdout: ''
  timestamp: 1660013586
