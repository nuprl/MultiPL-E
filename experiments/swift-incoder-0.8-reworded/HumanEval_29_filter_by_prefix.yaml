name: HumanEval_29_filter_by_prefix
language: swift
prompt: "\n/// Filter an input array of strings only for ones that start with a given\
  \ prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"a\")\n///\
  \ [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\", \"cde\",\
  \ \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
  \ [String], prefix: String) -> [String] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(filter_by_prefix(strings: [] as [String],\
  \ prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\"\
  , \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"\
  xxx\", \"xxxAAA\", \"xxx\"])"
completions: ["  let prefix_len = prefix.count\n  let prefixes_set = Set<String>(strings)\n\
    \  return prefixes_set.filter({ $0.hasPrefix(prefix) }).map({ $0.substring(from:\
    \ prefix_len) })", "\tvar filtered [String]\n\tprefix = prefix.lowercased()\n\t\
    for string in strings {\n\t\tif !string.hasPrefix(prefix) {\n\t\t\tfiltered =\
    \ append(filtered, string)\n\t\t} else {\n\t\t\tfiltered = append(filtered, \"\
    \")\n\t\t}\n\t}\n\treturn filtered", "    guard strings.count > 0, prefix.count\
    \ > 0 else { return strings }\n    let startIndex = strings.prefixIndex(of: prefix)\n\
    \    return startIndex == NSNotFound ? strings : strings.dropFirst(startIndex.successor())",
  "    var filtered: [String] = []\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered", "\t\
    let prefixIndex = strings.firstIndex(where: { $0.hasPrefix(prefix) })\n\tif prefixIndex\
    \ == -1 {\n\t\treturn strings\n\t}\n\treturn strings.prefix(prefixIndex)", '  return
    filter_by_prefix_impl(strings: strings, prefix: prefix)', '  return filter(strings:
    strings, pred: has_prefix(prefix))', "    guard prefix != \"\" else {\n      \
    \  return strings\n    }\n    return strings.filter({ (string) -> Bool in\n  \
    \      return string.hasPrefix(prefix)\n    })", "    var result = [String]()\n\
    \    for s in strings {\n        if s.startsWith(prefix) {\n            result.append(s)\n\
    \        }\n    }\n    return result", "    var results = [String]()\n    for\
    \ s in strings {\n        if s.hasPrefix(prefix) {\n            results.append(s)\n\
    \        }\n    }\n    return results", "    if prefix != \"\" && strings.Length\
    \ > 0 && strings.ToLower()[0] == prefix {\n        return strings.Slice(1, strings.Length)\n\
    \    }\n    return []", "    guard strings.count > 0 else { return strings }\n\
    \n    var filtered = Set<String>()\n    for s in strings {\n        let start\
    \ = s.startIndex\n        let end = s.endIndex\n        if !s.hasPrefix(prefix)\
    \ {\n            filtered.remove(s)\n        } else {\n            let range =\
    \ Range<String.Index>(start: start, end: end)\n            filtered.insert(s[range])\n\
    \        }\n    }\n\n    return Array(filtered)", '    return filter_by_prefix_mut(strings,
    prefix)', '    return strings.filter({ $0.hasPrefix(prefix) })', "\tif prefix\
    \ != \"\" && len(strings) == 0 {\n\t\treturn []\n\t}\n\treturn strings.filter({\
    \ $0.hasPrefix(prefix) })", "  strings.filter(\n    func(elt element) bool {\n\
    \      if elt.startsWith(prefix) {\n        return true\n      }\n      return\
    \ false\n    })", "    var filtered = [String]()\n    for s in strings {\n   \
    \     if strings.HasPrefix(s, prefix) {\n            filtered = append(filtered,\
    \ s)\n        }\n    }\n    return filtered", "\tvar filtered = [String]()\n\t\
    strings.ForEach(func(value String) {\n\t\tif value.hasPrefix(prefix) {\n\t\t\t\
    filtered = append(filtered, value)\n\t\t}\n\t})\n\treturn filtered", "    strings.filter\
    \ {\n        $0.hasPrefix(prefix)\n    }", "    guard strings.count > 0 else {\
    \ return strings }\n    var result = [String]()\n    for string in strings {\n\
    \        if string.hasPrefix(prefix) {\n            result.append(string)\n  \
    \      }\n    }\n    return result", '    return filter_by_prefix(strings, prefix,
    true, "")', "    var filtered: [String] = []\n    for str in strings { // strings\
    \ are mutable\n        if str.startsWith(prefix) {\n            filtered.append(str)\n\
    \        }\n    }\n    return filtered", "    if prefix == \"\" {\n        return\
    \ strings\n    }\n\n    var filtered = [String]()\n    for string in strings {\n\
    \        if string.hasPrefix(prefix) {\n            filtered = append(filtered,\
    \ string)\n        }\n    }\n    return filtered", "    if strings.IsEmpty() ||\
    \ strings.IsNullOrEmpty(prefix) {\n        return strings\n    }\n\n    // We\
    \ do not want empty strings at the beginning.\n    if strings.FirstOrDefault()\
    \ != \"\" && strings.FirstOrDefault().startsWith(prefix) {\n        strings.removeFirst()\n\
    \    }\n\n    return strings", '    return filter_by_prefix(strings, prefix, false)',
  "    var filtered: [String] = []\n    for str in strings {\n        if str.hasPrefix(prefix)\
    \ {\n            filtered = append(filtered, str)\n        }\n    }\n    return\
    \ filtered", '    return strings.filter { ($0.hasPrefix(prefix)) }', "    if strings.isEmpty()\
    \ {\n        return strings\n    }\n    let startIndex = strings.firstIndex(of:\
    \ prefix)\n    return strings.filter() {\n        guard $0.hasPrefix(prefix) else\
    \ {\n            return false\n        }\n        return startIndex != nil\n \
    \   }", "\tif !strings.HasPrefix(strings[0], prefix) {\n\t\treturn []\n\t}\n\n\
    \tvar res [String]\n\tfor _, s := range strings {\n\t\tif strings.HasPrefix(s,\
    \ prefix) {\n\t\t\tres = append(res, s)\n\t\t}\n\t}\n\n\treturn res", '    return
    filter(strings, prefixLength: prefix.utf16.count)', '    return filter_by_prefix(strings,
    prefix, true)', "\tif !strings.HasPrefix(strings[0], prefix) {\n\t\treturn strings\n\
    \t}\n\t\n\treturn strings.SplitN(strings[0], prefix, func(i, d []rune) []rune\
    \ {\n\t\tif i >= len(strings) {\n\t\t\treturn nil\n\t\t}\n\t\t\n\t\treturn strings[i+1:]\
    \ // everything after prefix is now the prefix\n\t})", '  return filter_by_prefix_impl(strings,
    prefix, false)', "    // If this array is empty, just return the same array we\
    \ started with.\n    // This will be a common case for anyone using filter_by_prefix.\n\
    \    if strings.isEmpty() {\n        return strings\n    }\n\n    var stringIndex\
    \ = 0\n    for index in 0..<strings.count {\n        if strings.indexAt(stringIndex,\
    \ index) == index {\n            if strings[stringIndex].startsWith(prefix) {\n\
    \                stringIndex = strings.indexAfterString(strings[stringIndex],\
    \ prefix)\n            } else {\n                stringIndex = strings.indexAfter(strings[stringIndex],\
    \ index)\n            }\n        } else {\n            stringIndex = index\n \
    \       }\n    }\n\n    return strings.drop(stringIndex)", "    let prefixLength\
    \ = prefix.count\n\n    return strings.filter({ s -> Bool in\n        let prefixIndex\
    \ = s.startIndex\n        return prefixIndex < prefixLength && s[prefixIndex]\
    \ == prefix\n    })", '    return strings.filter{ $0.hasPrefix(prefix) }', " \
    \   var result = [String]()\n    for s in strings {\n        if s.hasPrefix(prefix)\
    \ {\n            result.append(s)\n        }\n    }\n    return result", "   \
    \ if let prefix_index = strings.firstIndex(of: prefix) {\n        return strings.filter\
    \ { ($0.index > prefix_index) && ($0.index < prefix.count) }\n    } else {\n \
    \       return strings\n    }", "\tvar filtered []string\n\tfor _, s := range\
    \ strings {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\tfiltered = append(filtered,\
    \ s)\n\t\t}\n\t}\n\treturn filtered", "\tresult := []String{}\n\tfor _, string\
    \ := range strings {\n\t\tif strings.HasPrefix(string, prefix) {\n\t\t\tresult\
    \ = append(result, string)\n\t\t}\n\t}\n\treturn result", "\treturn filter_by_prefix_helper(strings,\
    \ prefix, true, 0)", "    guard let prefix = prefix.lowercased(),\n        let\
    \ suffixes = strings.map{$0.lowercased()}\n            .filter{$0.hasPrefix(prefix)}\n\
    \            .map{$0.prefix(prefix)}\n            else { return strings }\n\n\
    \    return suffixes", "\tvar newStrings [String] = []\n\tfor (index, value) in\
    \ strings.enumerate() {\n\t\tif strings.startsWith(prefix, value) {\n\t\t\tnewStrings[index]\
    \ = value\n\t\t}\n\t}\n\treturn newStrings", "    var filtered = [String]()\n\
    \    for s in strings {\n        if s.hasPrefix(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered", "\tfor i := 0;\
    \ i < len(strings); i++ {\n\t\tif strings.HasPrefix(strings[i], prefix) {\n\t\t\
    \treturn strings\n\t\t}\n\t}\n\treturn strings", "\tvar filteredStrings: [String]\
    \ = []\n\tfor _, s := range strings {\n\t\tif s.startsWith(prefix) {\n\t\t\tfilteredStrings.append(s)\n\
    \t\t}\n\t}\n\treturn filteredStrings", "    var filtered: [String] = []\n    for\
    \ s in strings {\n        if s.startsWith(prefix) {\n            filtered = append(filtered,\
    \ s)\n        }\n    }\n    return filtered", "\tswitch {\n\tcase strings.IsEmpty(strings):\n\
    \t\treturn []\n\tcase strings.HasPrefix(strings[0], prefix):\n\t\treturn strings.Slice(0,\
    \ prefix.Len()).Append(strings).Tail()\n\tcase strings.HasPrefix(strings[0], \"\
    \"):\n\t\treturn strings.Slice(0, prefix.Len()).Append(strings).Tail()\n\tdefault:\n\
    \t\treturn strings\n\t}", "\tif strings.IsNullOrEmpty(prefix) {\n\t\treturn strings\n\
    \t}\n\tr := make([]string, len(strings))\n\tfor i, v := range strings {\n\t\t\
    if strings.HasPrefix(v, prefix) {\n\t\t\tr[i] = v\n\t\t}\n\t}\n\treturn r", '    return
    filter_by_prefix_helper(strings, prefix, false)', "    if strings.IsEmpty {\n\
    \        return []\n    }\n    prefixLength = prefix.utf8.count\n    filteredStrings\
    \ = strings.filter {\n        $0.utf8.count >= prefixLength && $0.utf8.count <=\
    \ strings.utf8.count\n    }\n    return filteredStrings", '    return filter(strings.startsWith(prefix),
    strings)', "\trv := make([]string, len(strings))\n\tfor i, v := range strings\
    \ {\n\t\tif strings.HasPrefix(v, prefix) {\n\t\t\trv[i] = v\n\t\t}\n\t}\n\treturn\
    \ rv", "\treturn filter_by_prefix(strings, prefix, true)", '    return filter(strings,
    { strings.contains($0.prefix(prefix)) })', "\tprefix += \"\\x00\"\n\treturn strings.filter({\
    \ $0.hasPrefix(prefix) })", "    let result = strings.filter {\n        ($0.hasPrefix(prefix))\
    \ // or $0 == prefix\n    }\n    return result", "    strings = strings.filter({\
    \ str in\n        if str.startsWith(prefix) {\n            return true\n     \
    \   } else {\n            return false\n        }\n    })\n    return strings",
  "    if !strings.is_sorted() {\n        strings = strings.sorted()\n    }\n    prefix\
    \ += \"\"\n    var result: [String] = []\n    for string in strings {\n      \
    \  if string.startsWith(prefix) {\n            result.append(string)\n       \
    \ }\n    }\n    return result", "\tvar filtered: [String] = []\n\tprefix += \"\
    \ \"\n\tfor _, s := range strings {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\
    \t\tfiltered = append(filtered, s)\n\t\t}\n\t}\n\treturn filtered", "\tfor i :=\
    \ 0; i < len(strings); i++ {\n\t\tif strings.HasPrefix(strings[i], prefix) {\n\
    \t\t\treturn strings.SplitN(strings[i], prefix, 2)\n\t\t}\n\t}\n\treturn nil",
  '  return strings.filter({ $0.hasPrefix(prefix) })', "    var filtered: [String]\
    \ = []\n    for value in strings {\n        if value.hasPrefix(prefix) {\n   \
    \         filtered.append(value)\n        }\n    }\n    return filtered", "  \n\
    \  return strings.filter { (string) -> Bool in\n    let range = string.range(of:\
    \ prefix)\n    range.hasPrefix\n  }", "    var result = strings\n    for i in\
    \ 0..<strings.count {\n        if strings.prefix(i, prefix) {\n            result\
    \ = result[0..i]\n            break\n        }\n    }\n    return result", " \
    \   var filtered = strings\n    for index in 0..<strings.count {\n        if strings.startWith(strings[index],\
    \ prefix) {\n            filtered = filtered.filter { $0 != strings[index] }\n\
    \            break\n        }\n    }\n    return filtered", "  guard strings.isEmpty\
    \ || strings.first!.hasPrefix(prefix) else {\n    return strings\n  }\n  return\
    \ strings.filter({ $0.hasPrefix(prefix) })", "    if prefix != \"\" {\n      \
    \  for s in strings {\n            if s.startsWith(prefix) {\n               \
    \ strings = strings.filter{ !it.startsWith(prefix) }\n            }\n        }\n\
    \    }\n    return strings", "    var filtered = strings\n    for string in strings\
    \ {\n        if string.hasPrefix(prefix) {\n            filtered = filtered[..<filtered.index(of:\
    \ string)]\n        }\n    }\n    return filtered", '  return strings[strings.Index(strings.FirstIndex(prefix))
    != -1]', "\tfor _, s := range strings {\n\t\tif strings.HasPrefix(s, prefix) {\n\
    \t\t\treturn strings\n\t\t}\n\t}\n\treturn []String{}", "\treturn filter_by_prefix(strings,\
    \ prefix, true)", "  var filtered = [String]()\n  for string in strings {\n  \
    \  if string.hasPrefix(prefix) {\n      filtered.append(string)\n    }\n  }\n\
    \  return filtered", '    return strings.filter { $0.hasPrefix(prefix) }', "\t\
    var result = [String]()\n\tfor _, str := range strings {\n\t\tif str.hasPrefix(prefix)\
    \ {\n\t\t\tresult = append(result, str)\n\t\t}\n\t}\n\treturn result", "    if\
    \ strings.IsEmpty() {\n        return []\n    }\n\n    if !strings.HasPrefix(strings.Last(),\
    \ prefix) {\n        return strings\n    }\n\n    var result = [String]()\n  \
    \  for string in strings {\n        if string.hasPrefix(prefix) {\n          \
    \  result.append(string)\n        }\n    }\n    return result", "  if prefix !=\
    \ \"\" {\n    return strings.filter{ $0.hasPrefix(prefix) }\n  } else {\n    return\
    \ strings\n  }", "\tfor _, str := range strings {\n\t\tif strings.HasPrefix(str,\
    \ prefix) {\n\t\t\treturn strings.Split(str, \" \")\n\t\t}\n\t}\n\treturn []String{}",
  "  assert(strings.count, \"Must pass a non-empty array of strings\")\n  assert(prefix,\
    \ \"Must pass a non-empty prefix\")\n  \n  var filtered : [String] = []\n  for\
    \ element in strings {\n    if element.startsWith(prefix) {\n      filtered.append(element)\n\
    \    }\n  }\n  \n  return filtered", "  var filtered = Array<String>()\n  for\
    \ s in strings {\n    if s.startsWith(prefix) {\n      filtered.append(s)\n  \
    \  }\n  }\n  return filtered", "    var strings = [String]()\n    for s in strings\
    \ {\n        if s.startsWith(prefix) {\n            strings.append(s)\n      \
    \  }\n    }\n    return strings", "\tfilteredStrings := []string{}\n\tfor _, v\
    \ := range strings {\n\t\tif strings.HasPrefix(v, prefix) {\n\t\t\tfilteredStrings\
    \ = append(filteredStrings, v)\n\t\t}\n\t}\n\treturn filteredStrings", "    for\
    \ s in strings {\n        if s.startsWith(prefix) {\n            return strings\n\
    \        }\n    }\n    return []", "    var result = [String]()\n    for s in\
    \ strings {\n        if s.hasPrefix(prefix) {\n            result.append(s)\n\
    \        }\n    }\n    return result", '    return strings.filter({ $0.hasPrefix(prefix)
    })', "\treturn filterStrings(strings, prefix, true)", "\tfor _, s := range strings\
    \ {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\tcontinue // ignore the prefix\n\
    \t\t}\n\t\t\n\t\tstrings = append(strings[:i], strings[i+1:]...)\n\t\tbreak\n\t\
    }\n\t\n\treturn strings", "    if strings.isEmpty {\n        return strings\n\
    \    }\n    let startIdx = strings.firstIndex(of: prefix)\n    return startIdx\
    \ == nil ? strings : strings.prefix(upTo: startIdx)", "    var output = [String]()\n\
    \    for s in strings {\n        if s.hasPrefix(prefix) {\n            output.append(s)\n\
    \        }\n    }\n    return output", '    return strings.filter{ $0.hasPrefix(prefix)
    }', "\tfilteredString := strings.filter({ $0.hasPrefix(prefix) })\n\treturn filteredString",
  "  var result = strings\n\n  if !strings.isEmpty {\n    result = strings.filter\
    \ { $0.hasPrefix(prefix) }\n  }\n\n  return result", "    let filtered = strings.filter\
    \ {\n        $0.hasPrefix(prefix)\n    }\n    return filtered", '    return strings.filter
    { $0.hasPrefix(prefix) }', "\tfor string in strings {\n\t\tif string.hasPrefix(prefix)\
    \ {\n\t\t\treturn [string]\n\t\t}\n\t}\n\treturn []", "    var filtered_strings\
    \ = [String]()\n    for string in strings {\n        if string.hasPrefix(prefix)\
    \ {\n            filtered_strings.append(string)\n        }\n    }\n    return\
    \ filtered_strings", "    var filtered = [String]()\n    for s in strings {\n\
    \        if strings.indexWhere(s.startsWith, prefix) == 0 {\n            filtered.append(s)\n\
    \        }\n    }\n    return filtered", "    let filtered = strings.filter {\
    \ $0.hasPrefix(prefix) }\n    if filtered.count == 0 {\n        return strings\n\
    \    }\n    return filtered", "    var result: [String] = []\n    for s in strings\
    \ {\n        if s.startsWith(prefix) {\n            result.append(s)\n       \
    \ }\n    }\n    return result", "  var result: [String] = []\n  for s in strings\
    \ {\n    if s.startsWith(prefix) {\n      result = append(result, s)\n    }\n\
    \  }\n  return result", "    let prefixLength = prefix.count\n    return strings.filter\
    \ { $0.hasPrefix(prefix) }", "    let filtered = strings.filter { (string) ->\
    \ Bool in\n        return string.hasPrefix(prefix)\n    }\n    return filtered",
  "\treturn filter_by_prefix_helper(strings, prefix, false)", "    var filtered =\
    \ strings\n    for str in strings {\n        if str.hasPrefix(prefix) {\n    \
    \        filtered = [String]()\n            break\n        }\n        filtered\
    \ = [str] + filtered\n    }\n    return filtered", "\tfor _, s := range strings\
    \ {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\treturn strings\n\t\t}\n\t}\n\
    \n\treturn strings", "\tlet filtered = strings.filter { (s) in\n\t\treturn s.startsWith(prefix)\n\
    \t}\n\treturn filtered", "    var filteredStrings: [String] = []\n\n    for string\
    \ in strings {\n        if string.hasPrefix(prefix) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n\n    return filteredStrings", '    return filter_by_prefix_helper(strings,
    prefix, false)', "    strings = strings.filter({ $0.hasPrefix(prefix) })\n   \
    \ return strings", "    var results = strings\n    for string in strings {\n \
    \       if string.hasPrefix(prefix) {\n            results = append(results, string)\n\
    \        }\n    }\n    return results", "    prefix += Strings.repeat(\"\", len(prefix))\n\
    \    var output = [String]()\n    for s in strings {\n        if strings.startsWith(prefix,\
    \ s.count) {\n            output.append(s)\n        }\n    }\n    return output",
  "    prefix = prefix.lowercased()\n    var filtered = strings\n    for s in strings\
    \ {\n        if s.startsWith(prefix) {\n            filtered = filtered[..<filtered.index(s)]\n\
    \        }\n    }\n    return filtered", '    return filterString(strings, prefixPredicate(prefix))',
  '    return filter(strings.map(func(x: String) -> Bool { return x.startsWith(prefix)
    }), true)', "    var strings = strings\n    if strings.isEmpty {\n        return\
    \ strings\n    }\n    if strings.first == prefix {\n        return strings\n \
    \   }\n    strings.removeFirst()\n    return strings", '  return filter_by_prefix_impl(strings,
    prefix, false)', "\tvar stringsInSlice []string\n\tfor _, s := range strings {\n\
    \t\tif strings.HasPrefix(s, prefix) {\n\t\t\tstringsInSlice = append(stringsInSlice,\
    \ s)\n\t\t}\n\t}\n\treturn stringsInSlice", "  let prefix_length = prefix.characters.count\n\
    \  return strings.filter({ $0.hasPrefix(prefix) }).map({ $0.substringFromIndex(prefix_length)\
    \ })", '    return strings.filter({ $0.hasPrefix(prefix) })', "\tvar filtered:\
    \ [String] = []\n\tfor _, string := range strings {\n\t\tif strings.HasPrefix(string,\
    \ prefix) {\n\t\t\tfiltered = append(filtered, string)\n\t\t}\n\t}\n\treturn filtered",
  "\treturn strings.filter({ (value) -> Bool in\n\t\tlet prefixValue = String(value[value.index(prefix.startIndex,\
    \ offsetBy: prefix.count)])\n\t\treturn prefixValue == prefix\n\t})", '  return
    strings.filter({ $0.hasPrefix(prefix) })', '    return filter_(string, prefix).mapToSlice()',
  "    var result = [String]()\n    \n    for value in strings {\n        if value.startsWith(prefix)\
    \ {\n            result.append(value)\n        }\n    }\n    \n    return result",
  '    strings.filter { $0.hasPrefix(prefix) }', '    return strings.filter({ $0.hasPrefix(prefix)
    })', "\ts = append(prefix, s...)\n\ta = append([]string(nil), strings...)\n\t\
    return a[len(prefix):]", "    if prefix != \"\" {\n        return strings.filter{\
    \ $0.hasPrefix(prefix) }\n    } else {\n        return strings\n    }", "\treturn\
    \ filter_by_prefix_with_index(strings, prefix, 0)", '    return filter_by_prefix(strings,
    prefix, false)', "    // FIXME: use more efficient implementation if possible\n\
    \    var result = [String]()\n    for str in strings {\n        if str.startsWith(prefix)\
    \ {\n            result.append(str)\n        }\n    }\n    return result", '    return
    filter_by_prefix_internal(strings, prefix, "")', '    return strings.filter({
    $0.hasPrefix(prefix) })', "    if prefix != \"\" {\n        let prefixIndex =\
    \ strings.startIndex.advancedBy(0, maxDistance(prefix.utf8)) + 1\n        if prefixIndex\
    \ != strings.endIndex {\n            strings.removeSubrange(prefixIndex, prefixIndex.advancedBy(maxDistance(prefix.utf8)\
    \ - prefixIndex))\n        }\n    }\n    return strings", "\treturn filter_by_prefix_indexed(\n\
    \t\tstrings,\n\t\tprefix,\n\t\tstrings.Index,\n\t)", '    return strings.filter({
    $0.hasPrefix(prefix) })', "    var filtered_strings = strings\n    for _ in 0..<strings.count\
    \ {\n        let index = filtered_strings.index(of: prefix)\n        guard index\
    \ != nil else { continue }\n        filtered_strings.remove(at: index!)\n    }\n\
    \    return filtered_strings", "    \n    let index = 0\n    while index < strings.count\
    \ && strings[index] != prefix {\n        index += 1\n    }\n    \n    let result\
    \ = [String]()\n    \n    if index != strings.count {\n        result.appendContentsOf(strings[index..<strings.count])\n\
    \    }\n    \n    return result", "    \n    let filtered = strings.filter {\n\
    \        $0.hasPrefix(prefix)\n    }\n    return filtered", "  let re = RegExp(prefix.asRegExp())\n\
    \  return strings.filter {\n    re.hasMatchIn($0)\n  }", "  var result = strings\n\
    \  result = filter_by_prefix2(&result, prefix)\n  return result", '    return
    filter_by_prefix(strings, prefix, false)', '  return filter_by_prefix_helper(strings,
    prefix, true)', '    return filterWithPrefix(strings, prefix, true)', "  strings.filter({\n\
    \    if strings.startsWith(prefix) {\n      return true\n    } else {\n      return\
    \ false\n    }\n  })", "  if strings.Length <= 0 {\n    return strings\n  }\n\
    \  let prefix_length = prefix.Length\n  guard !prefix.IsEmpty else { return strings\
    \ }\n  var result: [String] = []\n  for string in strings {\n    if string.Length\
    \ >= prefix_length { // in case it's empty\n      if string.HasPrefix(prefix)\
    \ { // in case it's longer\n        result.append(string)\n      }\n    }\n  }\n\
    \  return result", "    return filter_by_prefix(\n        strings.map(String::init),\n\
    \        prefix: prefix.map(String::init),\n    )", "    strings.filter {\n  \
    \      $0.hasPrefix(prefix)\n    }", "    prefix = prefix.lowercased()\n    var\
    \ strings = strings\n    for idx, s in strings.enumerated() {\n        if s.lowercased().prefix(prefix)\
    \ {\n            strings = strings[idx..<strings.count]\n            break\n \
    \       }\n    }\n    return strings", "  var filtered = [String]()\n  for s in\
    \ strings {\n    if s.startsWith(prefix) {\n      filtered.append(s)\n    }\n\
    \  }\n  return filtered", "\treturn filter_by_prefix(strings, prefix, true)",
  "  let start_index = strings.startIndex.advanced(by: prefix.startIndex)\n  return\
    \ strings[start_index..<strings.endIndex]", '    return filter(strings, prefixFilterImpl,
    prefix)', "    var filtered: [String] = []\n    for s in strings {\n        if\
    \ s.hasPrefix(prefix) {\n            filtered.append(s)\n        }\n    }\n  \
    \  return filtered", '    return filter_by_prefix_helper(strings, prefix, 0)',
  "  let prefixes = prefix.characters.split(separator: \"\")\n  return strings.filter({\
    \ $0.hasPrefix(prefixes) })", "    return strings.filter{ str in\n        let\
    \ substr = (str as NSString).substringWithRange(str.rangeOfString(prefix))\n \
    \       return substr != \"\"\n    }", "    let filtered = strings.filter {\n\
    \        ($0.hasPrefix(prefix))\n    }\n    return filtered", "\tif strings.IsEmpty(prefix)\
    \ {\n\t\treturn strings\n\t}\n\tvar result = strings\n\tfor _, s := range strings\
    \ {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\tresult = append(result, s)\n\
    \t\t}\n\t}\n\treturn result", "    return strings.filter {\n        $0.hasPrefix(prefix)\n\
    \    }", '    return strings.filter({ $0.hasPrefix(prefix) })', "\tvar filtered\
    \ = [String]()\n\n\tfor i := 0; i < len(strings); i++ {\n\t\tif strings.HasPrefix(strings[i],\
    \ prefix) {\n\t\t\tfiltered = append(filtered, strings[i])\n\t\t}\n\t}\n\n\treturn\
    \ filtered", "    for s in strings {\n        if s.hasPrefix(prefix) {\n     \
    \       return strings\n        }\n    }\n    return []", "    var filtered: [String]\
    \ = []\n    for s in strings {\n        if s.startsWith(prefix) {\n          \
    \  filtered = append(filtered, s)\n        }\n    }\n    return filtered", " \
    \   return filter_by_prefix(\n        strings: strings,\n        prefix: prefix,\n\
    \        pred: func(s string) bool {\n            return strings.HasPrefix(s,\
    \ prefix)\n        },\n    )", "    return strings.filter { (value) -> Bool in\n\
    \        let prefixLength = value.prefixIndex(of: prefix)\n        return prefixLength\
    \ == 0 ||\n            (prefixLength > 0 && value.startIndex..<value.index(before:\
    \ prefixLength))\n            == value.startIndex..<value.index(before: value.index(before:\
    \ prefixLength))\n    }", "\treturn filter_by_prefix(strings, prefix, true)",
  '    filter_by_prefix_helper(strings, prefix, "")', "    if strings.isEmpty() {\n\
    \        return strings\n    }\n    return strings.filter { $0.hasPrefix(prefix)\
    \ }", "    for string in strings {\n        if string.hasPrefix(prefix) {\n  \
    \          return strings\n        }\n    }\n    return []", "  switch strings.len\
    \ {\n  case 0:\n    return strings\n  case 1:\n    if strings[0] == prefix {\n\
    \      return strings\n    } else {\n      return [\"\"]\n    }\n  default:\n\
    \    return strings.filter({ $0.hasPrefix(prefix) })\n  }", "\tif strings.IsEmpty(prefix)\
    \ {\n\t\treturn strings\n\t}\n\tsort.Strings(strings)\n\tlastNonEmptyIndex :=\
    \ len(strings) - 1\n\tvar output [lastNonEmptyIndex]string\n\tfor i, input :=\
    \ range strings {\n\t\tif strings.HasPrefix(input, prefix) {\n\t\t\toutput[i]\
    \ = input\n\t\t\tlastNonEmptyIndex = i\n\t\t}\n\t}\n\treturn output", "    let\
    \ index = strings.firstIndex(where: {$0.hasPrefix(prefix)})\n    if index != -1\
    \ { return strings.prefix(index) }\n    return strings", "    guard strings.count\
    \ > 0 else {\n        return strings\n    }\n    var filtered = [String]()\n \
    \   for string in strings {\n        if string.hasPrefix(prefix) {\n         \
    \   filtered.append(string)\n        }\n    }\n    return filtered", "    if let\
    \ prefix = prefix.lowercased() {\n        let matchedStrings = strings.filter({\
    \ $0.hasPrefix(prefix) })\n        return matchedStrings\n    } else {\n     \
    \   return strings\n    }", "    var filtered: [String] = []\n    for s in strings\
    \ {\n        if s.startsWith(prefix) {\n            filtered = append(filtered,\
    \ s)\n        }\n    }\n    return filtered", "    if strings.IsEmpty() {\n  \
    \      return strings\n    }\n    if prefix != \"\" && strings.Length <= 1 {\n\
    \        return strings\n    }\n    var result = [String]()\n    for i := 0; i\
    \ < strings.Length; i++ {\n        if strings.StartsWith(strings[i], prefix) {\n\
    \            result = append(result, strings[i])\n        }\n    }\n    return\
    \ result", "\tvar result = [String]()\n\tfor _, s := range strings {\n\t\tif strings.HasPrefix(s,\
    \ prefix) {\n\t\t\tresult = append(result, s)\n\t\t}\n\t}\n\treturn result", "\t\
    return filter_by_prefix_internal(strings, prefix, true)", "    var filtered =\
    \ strings\n    for _item in strings {\n        if _item.startsWith(prefix) {\n\
    \            filtered = [_item]\n            break\n        }\n    }\n    return\
    \ filtered", "    return strings.filter({\n        let first = $0.prefix(from:\
    \ prefix)\n        return !first.contains(prefix)\n    })", "    if strings.IsEmpty()\
    \ {\n        return []\n    }\n    \n    // TODO: Optimize for small strings and\
    \ common prefixes.\n    \n    let len = prefix.characters.count\n    let lower\
    \ = strings.map {\n        $0.lowercasedStringWithLocale(NSLocale(localeIdentifier:\
    \ \"en_US_POSIX\"))\n    }\n    \n    var result = [String]()\n    \n    for str\
    \ in strings {\n        if str.startsWith(prefix) {\n            result.append(str)\n\
    \        }\n    }\n    \n    return result", "    var filtered = strings\n   \
    \ for _str in strings {\n        if _str.startsWith(prefix) {\n            filtered\
    \ = filtered.filter() { $0 != _str }\n        }\n    }\n    return filtered",
  "\treturn removePrefix(strings, prefix)", "    prefixLen := prefix.characters.count\n\
    \    var filtered: [String] = []\n    for input in strings {\n        if input.hasPrefix(prefix)\
    \ {\n            filtered = append(filtered, input)\n        }\n    }\n    return\
    \ filtered", "    let filtered = strings.filter({ $0.hasPrefix(prefix) })\n  \
    \  return filtered as [String]", "    let prefixLength = prefix.count\n    return\
    \ strings.filter {\n        let index = $0.startIndex\n        return index >=\
    \ 0 && index < $0.endIndex && $0.hasPrefix(prefix)\n    }", "    var results =\
    \ strings.filter({ $0.hasPrefix(prefix) })\n    if results.isEmpty {\n       \
    \ return strings\n    }\n    return results", "    var results = make([]String,\
    \ 0)\n    for _, s := range strings {\n        if strings.HasPrefix(s, prefix)\
    \ {\n            results = append(results, s)\n        }\n    }\n    return results",
  '  return filter_by_prefix_helper(strings, prefix, 0)', "\treturn filter_by_prefix_impl(strings,\
    \ prefix, func(a, b int) bool {\n\t\treturn a[:b] == prefix\n\t})", '    return
    filterArray(prefixedHasPrefix(strings), prefix)', "    var filtered = [String]()\n\
    \    for string in strings {\n        if string.startsWith(prefix) {\n       \
    \     filtered.append(string)\n        }\n    }\n    return filtered", '    return
    filter_by_prefix(strings, prefix, true)', "    if prefix != \"\" {\n        strings\
    \ = strings.filter { (s) -> (Bool) in\n            return s.hasPrefix(prefix)\n\
    \        }\n    }\n    return strings", "    var result = Array(strings)\n   \
    \ for i := range result {\n        if result[i] != prefix {\n            result\
    \ = result.filter{$0 != result[i]}\n        }\n    }\n    return result", "  let\
    \ filtered = strings\n    .filter { (s) in\n      s.hasPrefix(prefix)\n    }\n\
    \  return filtered", "    return strings.filter { (a) in\n        a.hasPrefix(prefix)\n\
    \    }", "    let filteredStrings = strings.filter {\n        ($0.hasPrefix(prefix))\
    \ ?? false\n    }\n    return filteredStrings", "    let prefix_length = prefix.characters.count\n\
    \    return strings.filter { (text) -> Bool in\n        let text_length = text.characters.count\n\
    \        return text_length >= prefix_length && prefix.hasPrefix(text)\n    }"]
stop_tokens:
- "\n}"
