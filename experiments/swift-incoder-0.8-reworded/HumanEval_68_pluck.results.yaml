language: swift
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else {\n        return\
    \ []\n    }\n    let minOddIndex = arr.index(arr.minElement(arr.filter({$0 % 2\
    \ == 0}))!)\n    let maxOddIndex = arr.index(arr.maxElement(arr.filter({$0 % 2\
    \ == 0}))!)\n    let minEvenValue = arr[minOddIndex]\n    var returnValue = [minEvenValue]\n\
    \    arr[minOddIndex] = arr[maxOddIndex]\n    arr[maxOddIndex] = minEvenValue\n\
    \    return returnValue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3ro4gpny.swift:31:27: error: no exact matches in call to instance\
    \ method 'index'\n    let minOddIndex = arr.index(arr.minElement(arr.filter({$0\
    \ % 2 == 0}))!)\n                          ^\n/tmp/tmp3ro4gpny.swift:31:27: note:\
    \ found candidate with type '(Int) -> Int'\n    let minOddIndex = arr.index(arr.minElement(arr.filter({$0\
    \ % 2 == 0}))!)\n                          ^\n/tmp/tmp3ro4gpny.swift:31:27: note:\
    \ found candidate with type '(Int) -> Int'\n    let minOddIndex = arr.index(arr.minElement(arr.filter({$0\
    \ % 2 == 0}))!)\n                          ^\n/tmp/tmp3ro4gpny.swift:31:27: note:\
    \ found candidate with type '((Int) throws -> Bool) throws -> Array<Int>.Index?'\
    \ (aka '((Int) throws -> Bool) throws -> Optional<Int>')\n    let minOddIndex\
    \ = arr.index(arr.minElement(arr.filter({$0 % 2 == 0}))!)\n                  \
    \        ^\n/tmp/tmp3ro4gpny.swift:31:27: note: found candidate with type '(Int)\
    \ -> Array<Int>.Index?' (aka '(Int) -> Optional<Int>')\n    let minOddIndex =\
    \ arr.index(arr.minElement(arr.filter({$0 % 2 == 0}))!)\n                    \
    \      ^\n/tmp/tmp3ro4gpny.swift:31:37: error: value of type '[Int]' has no member\
    \ 'minElement'\n    let minOddIndex = arr.index(arr.minElement(arr.filter({$0\
    \ % 2 == 0}))!)\n                                ~~~ ^~~~~~~~~~\n/tmp/tmp3ro4gpny.swift:32:27:\
    \ error: no exact matches in call to instance method 'index'\n    let maxOddIndex\
    \ = arr.index(arr.maxElement(arr.filter({$0 % 2 == 0}))!)\n                  \
    \        ^\n/tmp/tmp3ro4gpny.swift:32:27: note: found candidate with type '(Int)\
    \ -> Int'\n    let maxOddIndex = arr.index(arr.maxElement(arr.filter({$0 % 2 ==\
    \ 0}))!)\n                          ^\n/tmp/tmp3ro4gpny.swift:32:27: note: found\
    \ candidate with type '(Int) -> Int'\n    let maxOddIndex = arr.index(arr.maxElement(arr.filter({$0\
    \ % 2 == 0}))!)\n                          ^\n/tmp/tmp3ro4gpny.swift:32:27: note:\
    \ found candidate with type '((Int) throws -> Bool) throws -> Array<Int>.Index?'\
    \ (aka '((Int) throws -> Bool) throws -> Optional<Int>')\n    let maxOddIndex\
    \ = arr.index(arr.maxElement(arr.filter({"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let len = arr.count\n    if arr.isEmpty\
    \ {\n        return arr\n    }\n    if len == 1 {\n        return arr\n    }\n\
    \    var min = arr[0]\n    var minIndex = 0\n    var minIndex = -1\n    for index\
    \ in 0..<len - 1 {\n        if arr[index] > min {\n            min = arr[index]\n\
    \            minIndex = index\n        }\n    }\n    return [minIndex, min]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb4uwn5mh.swift:37:9: error: invalid redeclaration of 'minIndex'\n\
    \    var minIndex = -1\n        ^\n/tmp/tmpb4uwn5mh.swift:36:9: note: 'minIndex'\
    \ previously declared here\n    var minIndex = 0\n        ^\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    let n = arr.count\n    var minIndex: Int = 0\n    var minVal = arr[0]\n\
    \    for i in 1..n {\n        if arr[i] < minVal {\n            minVal = arr[i]\n\
    \            minIndex = i\n        }\n    }\n    if minIndex == 0 {\n        return\
    \ []\n    }\n    return [minVal, minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_0binov9.swift:34:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..n {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var largestIndex = 0\n    var largestValue\
    \ = arr[0]\n    var smallestIndex = 0\n    var smallestValue = arr[0]\n    \n\
    \    for index, i in enumerate(arr) {\n        if i % 2 != 0 {\n            continue\n\
    \        }\n        \n        if smallestValue == i {\n            smallestIndex\
    \ = index\n            smallestValue = arr[index]\n        }\n        \n     \
    \   if largestValue < i {\n            largestIndex = index\n            largestValue\
    \ = arr[index]\n        }\n    }\n    \n    if smallestValue == arr[0] {\n   \
    \     return [smallestValue]\n    }\n    \n    if largestIndex == 0 {\n      \
    \  return arr\n    }\n    \n    if largestValue == arr[largestIndex] {\n     \
    \   return [largestValue, largestIndex]\n    }\n    \n    if largestValue == arr[largestIndex\
    \ + 1] {\n        return [largestValue, largestIndex + 1]\n    }\n    \n    var\
    \ result = arr[0:largestIndex]\n    result.appendContentsOf(pluck(arr[largestIndex+1:]))\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplei6s1kh.swift:34:14: error: expected 'in' after for-each pattern\n\
    \    for index, i in enumerate(arr) {\n             ^\n/tmp/tmplei6s1kh.swift:34:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, i in enumerate(arr)\
    \ {\n             ^\n/tmp/tmplei6s1kh.swift:66:23: error: expected ',' separator\n\
    \    var result = arr[0:largestIndex]\n                      ^\n             \
    \         ,\n/tmp/tmplei6s1kh.swift:66:23: error: expected expression in list\
    \ of expressions\n    var result = arr[0:largestIndex]\n                     \
    \ ^\n/tmp/tmplei6s1kh.swift:67:53: error: expected ',' separator\n    result.appendContentsOf(pluck(arr[largestIndex+1:]))\n\
    \                                                    ^\n                     \
    \                               ,\n/tmp/tmplei6s1kh.swift:67:53: error: expected\
    \ expression in list of expressions\n    result.appendContentsOf(pluck(arr[largestIndex+1:]))\n\
    \                                                    ^\n/tmp/tmplei6s1kh.swift:67:12:\
    \ error: value of type 'Int' has no member 'appendContentsOf'\n    result.appendContentsOf(pluck(arr[largestIndex+1:]))\n\
    \    ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmplei6s1kh.swift:67:35: error: missing argument\
    \ label 'arr:' in call\n    result.appendContentsOf(pluck(arr[largestIndex+1:]))\n\
    \                                  ^\n                                  arr: \n\
    /tmp/tmplei6s1kh.swift:67:38: error: cannot convert value of type 'Int' to expected\
    \ argument type '[Int]'\n    result.appendContentsOf(pluck(arr[largestIndex+1:]))\n\
    \                                     ^\n/tmp/tmplei6s1kh.swift:68:12: error:\
    \ cannot convert return expression of type 'Int' to return type '[Int]'\n    return\
    \ result\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var sorted = arr\n    sorted.sort()\n\
    \    \n    var smallest = sorted[0]\n    var smallestIndex = 0\n    \n    for\
    \ index in 0..<sorted.count {\n        \n        if sorted[index] % 2 == 0 {\n\
    \            if smallest < sorted[index] {\n                smallest = sorted[index]\n\
    \                smallestIndex = index\n            }\n        }\n        \n \
    \   }\n    \n    return ArraySlice(sorted, 0, smallestIndex + 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkv0nrz01.swift:46:22: error: missing argument label 'arrayLiteral:'\
    \ in call\n    return ArraySlice(sorted, 0, smallestIndex + 1)\n             \
    \        ^\n                      arrayLiteral: \n/tmp/tmpkv0nrz01.swift:46:12:\
    \ error: cannot convert return expression of type 'ArraySlice<Int>' to return\
    \ type '[Int]'\n    return ArraySlice(sorted, 0, smallestIndex + 1)\n        \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let result = Set(arr).sorted()\n    var\
    \ smallest = 0\n    var index = 0\n    for node in result {\n        if smallest\
    \ == 0 || node % 2 == 0 {\n            smallest = node\n            index = result.index(of:\
    \ node)!\n        }\n    }\n    return [smallest, index]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpmc9701s4/tmpmc9701s4.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adcdd530c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adcdd227b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adcdd227988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adcdd2267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmc9701s4                        0x0000558097d427bc <unavailable> + 6076

    5    libc.so.6                          0x00002adcdd71c460 __libc_start_main +
    245

    6    tmpmc9701s4                        0x0000558097d423c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return []\n\
    \    }\n    var results: [Int] = []\n    \n    // initialize a map for storing\
    \ the results\n    var map: [Int: [Int]] = [:]\n    \n    for index in stride(from:\
    \ 0, to: arr.count, by: 2) {\n        let value = arr[index]\n        \n     \
    \   if let [key, value] = map[key] {\n            \n            if value == value\
    \ % 2 { // found odd value\n                // add the index of this value to\
    \ the result array\n                results.append(key)\n                // update\
    \ the map with key as index\n                map[key] = [value, index]\n     \
    \       }\n        } else {\n            // add the value to the result array\n\
    \            results.append(value)\n            // add the value to the map with\
    \ key as index\n            map[index] = [value, index]\n        }\n    }\n  \
    \  \n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdp1btc1_.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpdp1btc1_.swift:39:12: error: pattern matching in a condition requires\
    \ the 'case' keyword\n        if let [key, value] = map[key] {\n           ^\n\
    \           case \n/tmp/tmpdp1btc1_.swift:39:35: error: cannot find 'key' in scope\n\
    \        if let [key, value] = map[key] {\n                                  ^~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.reduce([]) {\n        index,\
    \ cur in\n        smallestEven := cur & 1 == 0\n        smallestIndex := index\n\
    \        if smallestEven {\n            if smallestIndex == 0 {\n            \
    \    smallestIndex = 1\n            }\n            else {\n                if\
    \ cur < arr[smallestIndex] {\n                    smallestIndex = smallestIndex\
    \ + 1\n                }\n            }\n        }\n        var ret : [Int]\n\
    \        if !smallestEven {\n            ret = ret.insert(smallestIndex, cur)\n\
    \        }\n        return ret\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpaem2gg2n.swift:30:21: error: consecutive statements on a line must\
    \ be separated by ';'\n        smallestEven := cur & 1 == 0\n                \
    \    ^\n                    ;\n/tmp/tmpaem2gg2n.swift:30:22: error: expected expression\n\
    \        smallestEven := cur & 1 == 0\n                     ^\n/tmp/tmpaem2gg2n.swift:30:9:\
    \ error: cannot find 'smallestEven' in scope\n        smallestEven := cur & 1\
    \ == 0\n        ^~~~~~~~~~~~\n/tmp/tmpaem2gg2n.swift:32:12: error: cannot find\
    \ 'smallestEven' in scope\n        if smallestEven {\n           ^~~~~~~~~~~~\n\
    /tmp/tmpaem2gg2n.swift:33:16: error: cannot find 'smallestIndex' in scope\n  \
    \          if smallestIndex == 0 {\n               ^~~~~~~~~~~~~\n/tmp/tmpaem2gg2n.swift:34:17:\
    \ error: cannot find 'smallestIndex' in scope\n                smallestIndex =\
    \ 1\n                ^~~~~~~~~~~~~\n/tmp/tmpaem2gg2n.swift:37:30: error: cannot\
    \ find 'smallestIndex' in scope\n                if cur < arr[smallestIndex] {\n\
    \                             ^~~~~~~~~~~~~\n/tmp/tmpaem2gg2n.swift:38:21: error:\
    \ cannot find 'smallestIndex' in scope\n                    smallestIndex = smallestIndex\
    \ + 1\n                    ^~~~~~~~~~~~~\n/tmp/tmpaem2gg2n.swift:38:37: error:\
    \ cannot find 'smallestIndex' in scope\n                    smallestIndex = smallestIndex\
    \ + 1\n                                    ^~~~~~~~~~~~~\n/tmp/tmpaem2gg2n.swift:43:13:\
    \ error: cannot find 'smallestEven' in scope\n        if !smallestEven {\n   \
    \         ^~~~~~~~~~~~\n/tmp/tmpaem2gg2n.swift:44:30: error: cannot find 'smallestIndex'\
    \ in scope\n            ret = ret.insert(smallestIndex, cur)\n               \
    \              ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    precondition(arr.count <= 10000, \"The\
    \ given array has too many nodes\")\n    var arr: [Int] = arr\n    var smalest_value:\
    \ Int = Int.max\n    var index_of_smallest_value: Int = Int.max\n    for index\
    \ in arr.indices {\n        if arr[index] % 2 == 0 {\n            smalest_value\
    \ = arr[index]\n            index_of_smallest_value = index\n        }\n    }\n\
    \    guard index_of_smallest_value != Int.max else {\n        return arr\n   \
    \ }\n    for index in arr.indices {\n        if arr[index] == smalest_value {\n\
    \            arr.insert(index_of_smallest_value, smalest_value)\n            return\
    \ arr\n        }\n    }\n    return [Int]()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp5gkgcz6k.swift:43:17: error: no exact matches in call to instance\
    \ method 'insert'\n            arr.insert(index_of_smallest_value, smalest_value)\n\
    \                ^\nSwift.Array:11:37: note: incorrect labels for candidate (have:\
    \ '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect labels for candidate\
    \ (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Self.Element, at i: Self.Index)\n                      \
    \              ^\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // init\n    var i, j, temp, smallest_value\
    \ = arr[0]\n    var smallest_index = 0\n    i = j = 0\n\n    // loop through to\
    \ find smallest value\n    for _i in arr {\n        if _i < smallest_value {\n\
    \            smallest_value = _i\n            i = smallest_index\n        } else\
    \ if _i == smallest_value {\n            smallest_index++\n        }\n    }\n\n\
    \    // loop through to find next smallest value\n    for _j in arr {\n      \
    \  if _j == smallest_value {\n            continue\n        }\n        if _j >\
    \ smallest_value {\n            smallest_value = _j\n            i = smallest_index\n\
    \        }\n    }\n\n    // finally return result\n    var result = [smallest_value,\
    \ i]\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpwfp76dlj.swift:29:9: error: type annotation missing in pattern\n\
    \    var i, j, temp, smallest_value = arr[0]\n        ^\n/tmp/tmpwfp76dlj.swift:29:12:\
    \ error: type annotation missing in pattern\n    var i, j, temp, smallest_value\
    \ = arr[0]\n           ^\n/tmp/tmpwfp76dlj.swift:29:15: error: type annotation\
    \ missing in pattern\n    var i, j, temp, smallest_value = arr[0]\n          \
    \    ^\n/tmp/tmpwfp76dlj.swift:39:27: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            smallest_index++\n                       \
    \   ^~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return arr\n\
    \    }\n    var index = 0\n    var smalest_val = arr[0]\n    var smalest_index\
    \ = 0\n    var even_index = 0\n    var even_value = 0\n    for val in arr {\n\
    \        if even_index == 0 && val % 2 == 0 {\n            even_value = val\n\
    \            even_index = index\n        }\n        if even_index > 0 && val ==\
    \ even_value {\n            even_index--\n        } else if even_index == 0 {\n\
    \            smalest_val = val\n            smalest_index = index\n        }\n\
    \        index++\n    }\n    if even_index == 0 {\n        return [smalest_val,\
    \ smalest_index]\n    }\n    if even_index > 0 {\n        return even_value..val\n\
    \    } else {\n        return smalest_val..smalest_index\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpy2q1lhcg.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpy2q1lhcg.swift:42:23: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n            even_index--\n                      ^~\n/tmp/tmpy2q1lhcg.swift:47:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n/tmp/tmpy2q1lhcg.swift:53:26: error: cannot find operator '..'\
    \ in scope; did you mean '...'?\n        return even_value..val\n            \
    \             ^~\n                         ...\n/tmp/tmpy2q1lhcg.swift:53:28:\
    \ error: cannot find 'val' in scope\n        return even_value..val\n        \
    \                   ^~~\n/tmp/tmpy2q1lhcg.swift:55:27: error: cannot find operator\
    \ '..' in scope; did you mean '...'?\n        return smalest_val..smalest_index\n\
    \                          ^~\n                          ...\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evenVals = [Int]()\n    for num in\
    \ arr {\n        if num % 2 == 0 {\n            evenVals.append(num)\n       \
    \ }\n    }\n\n    var sortedEvenVals = evenVals.sorted(by: { $0 > $1 })\n    var\
    \ largestEvenVal = sortedEvenVals.last!\n    var index = sortedEvenVals.index(of:\
    \ largestEvenVal)\n    return [largestEvenVal, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp78n41di9.swift:37:32: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    var index = sortedEvenVals.index(of: largestEvenVal)\n\
    \                               ^\n/tmp/tmp78n41di9.swift:37:32: note: use 'firstIndex(of:)'\
    \ instead\n    var index = sortedEvenVals.index(of: largestEvenVal)\n        \
    \                       ^~~~~\n                               firstIndex\n/tmp/tmp78n41di9.swift:38:29:\
    \ error: cannot convert value of type 'Array<Int>.Index?' (aka 'Optional<Int>')\
    \ to expected element type 'Int'\n    return [largestEvenVal, index]\n       \
    \                     ^\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var results = [Int]()\n    var maxValue:\
    \ Int = 0\n    var index = 0\n    for element in arr {\n        if element > maxValue\
    \ {\n            maxValue = element\n            index = element\n        }\n\
    \    }\n    results.append(maxValue)\n    results.append(index)\n    return results\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp7upntaxp/tmp7upntaxp.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b582f34ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b582f045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b582f045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b582f0447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7upntaxp                        0x00005575bf8425dc <unavailable> + 5596

    5    libc.so.6                          0x00002b582f53a460 __libc_start_main +
    245

    6    tmp7upntaxp                        0x00005575bf8421e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013834
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var index = 0\n    var smalest_value =\
    \ 0\n    var new_arr = [Int]()\n    for node in arr {\n        if index == 0 {\n\
    \            smalest_value = node\n            index = index + 1\n        }\n\
    \        if node < smalest_value {\n            smalest_value = node\n       \
    \     index = index + 1\n            new_arr.append(node)\n        } else if node\
    \ > smalest_value {\n            smalest_value = node\n        }\n    }\n    return\
    \ new_arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: Exception
  stderr: 'tmpl46deo47/tmpl46deo47.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab2544b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab2541acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab2541ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab2541ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl46deo47                        0x0000558d4943a5dc <unavailable> + 5596

    5    libc.so.6                          0x00002ab2546a1460 __libc_start_main +
    245

    6    tmpl46deo47                        0x0000558d4943a1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minValue = Int()\n    var minIndex\
    \ = -1\n    for node : Int in\n        arr.indices().toArray() {\n           \
    \ if node % 2 == 0 {\n                if node < minValue {\n                 \
    \   minValue = node\n                    minIndex = node\n                }\n\
    \            }\n        }\n    return minIndex.array.toArray()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppditp5rm.swift:31:13: error: cannot call value of non-function\
    \ type 'Range<Array<Int>.Index>' (aka 'Range<Int>')\n        arr.indices().toArray()\
    \ {\n            ^      ~~\n                   \n/tmp/tmppditp5rm.swift:39:21:\
    \ error: value of type 'Int' has no member 'array'\n    return minIndex.array.toArray()\n\
    \           ~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return pickEvenIndex(arr)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_f0r759n.swift:28:12: error: cannot find 'pickEvenIndex' in scope\n\
    \    return pickEvenIndex(arr)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return largestEvenIndexAndValueIndex(arr)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7qpzenpi.swift:28:12: error: cannot find 'largestEvenIndexAndValueIndex'\
    \ in scope\n    return largestEvenIndexAndValueIndex(arr)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else {\n        return\
    \ []\n    }\n\n    // sort the array to find the smallest even value\n    let\
    \ sorted = arr.sorted()\n    if sorted.count < 2 {\n        return []\n    }\n\
    \n    let smallestEven = sorted.first!\n    var minIndex: Int = 0\n    sorted.enumerate().forEach\
    \ { (index, element) in\n        if element % 2 == 0 && element == smallestEven\
    \ {\n            minIndex = index\n        }\n    }\n\n    // return the result\
    \ as a list\n    return [smallestEven, minIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpuewtj4l8.swift:40:12: error: value of type '[Int]' has no member\
    \ 'enumerate'\n    sorted.enumerate().forEach { (index, element) in\n    ~~~~~~\
    \ ^~~~~~~~~\n/tmp/tmpuewtj4l8.swift:42:24: error: cannot assign value of type\
    \ '_' to type 'Int'\n            minIndex = index\n                       ^~~~~\n\
    \                       Int( )\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var result = [Int]()\n    for index\
    \ in 0..<arr.count {\n        if arr[index] % 2 == 0 {\n            result.insert(arr[index],\
    \ index)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp63uel7tk.swift:32:20: error: no exact matches in call to instance\
    \ method 'insert'\n            result.insert(arr[index], index)\n            \
    \       ^\nSwift.Array:11:37: note: incorrect labels for candidate (have: '(_:_:)',\
    \ expected: '(_:at:)')\n    @inlinable public mutating func insert(_ newElement:\
    \ __owned Element, at i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minValue = 0\n    var minIndex = 0\n\
    \    for (_, value) in arr.enumerated() {\n        if ((value & 1) == 0) {\n \
    \           if value >= minValue {\n                minValue = value\n       \
    \         minIndex += 1\n            }\n        } else if ((value & 1) == 1) {\n\
    \            if value < minValue {\n                minValue = value\n       \
    \         minIndex += 1\n            }\n        }\n    }\n    if minIndex == 0\
    \ { return [] }\n    if minIndex == 1 { return [minValue] }\n    return minIndex\
    \ > 1 ? minValue : []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnf0vi8f6.swift:45:25: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return minIndex > 1 ? minValue : []\n\
    \           ~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr == [] || len(arr) == 0 {\n     \
    \   return arr\n    }\n    var evens = []Int()\n    var i = 0\n    for node in\
    \ arr {\n        if node % 2 == 0 {\n            evens.append(node)\n        }\
    \ else {\n            i = i\n            break\n        }\n    }\n    if i >=\
    \ 0 {\n        return evens\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkr49euf4.swift:31:19: error: consecutive statements on a line must\
    \ be separated by ';'\n    var evens = []Int()\n                  ^\n        \
    \          ;\n/tmp/tmpkr49euf4.swift:28:21: error: cannot find 'len' in scope\n\
    \    if arr == [] || len(arr) == 0 {\n                    ^~~\n/tmp/tmpkr49euf4.swift:31:17:\
    \ error: empty collection literal requires an explicit type\n    var evens = []Int()\n\
    \                ^~\n/tmp/tmpkr49euf4.swift:31:19: warning: result of 'BinaryInteger'\
    \ initializer is unused\n    var evens = []Int()\n                  ^  ~~\n/tmp/tmpkr49euf4.swift:37:15:\
    \ error: assigning a variable to itself\n            i = i\n            ~ ^ ~\n\
    /tmp/tmpkr49euf4.swift:42:16: error: cannot convert return expression of type\
    \ '[Any]' to return type '[Int]'\n        return evens\n               ^\n/tmp/tmpkr49euf4.swift:42:16:\
    \ note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected\
    \ to be equal\n        return evens\n               ^\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return rec(arr, 0, arr.count, 0)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpj_muw9ao.swift:28:12: error: cannot find 'rec' in scope\n    return\
    \ rec(arr, 0, arr.count, 0)\n           ^~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let sum = arr.reduce(0, combine: +);\n\
    \    let even = arr.reduce(0 * 0, combine: (+) * $0);\n    var result: [Int] =\
    \ [] as [Int]\n    while even != 0 {\n        let pos = sum / even;\n        result.append(pos)\n\
    \        sum = sum % even\n        even = even * $0\n    }\n    return result\
    \ as! [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp5cc1no7q.swift:29:49: error: anonymous closure argument not contained\
    \ in a closure\n    let even = arr.reduce(0 * 0, combine: (+) * $0);\n       \
    \                                         ^\n/tmp/tmp5cc1no7q.swift:35:23: error:\
    \ anonymous closure argument not contained in a closure\n        even = even *\
    \ $0\n                      ^\n/tmp/tmp5cc1no7q.swift:28:25: error: extraneous\
    \ argument label 'combine:' in call\n    let sum = arr.reduce(0, combine: +);\n\
    \                        ^   ~~~~~~~~~\n                            \n/tmp/tmp5cc1no7q.swift:29:26:\
    \ error: extraneous argument label 'combine:' in call\n    let even = arr.reduce(0\
    \ * 0, combine: (+) * $0);\n                         ^       ~~~~~~~~~\n     \
    \                            \n/tmp/tmp5cc1no7q.swift:29:47: error: type '(Int,\
    \ Int) -> Int' cannot conform to 'DurationProtocol'\n    let even = arr.reduce(0\
    \ * 0, combine: (+) * $0);\n                                              ^\n\
    /tmp/tmp5cc1no7q.swift:29:47: note: only concrete types such as structs, enums\
    \ and classes can conform to protocols\n    let even = arr.reduce(0 * 0, combine:\
    \ (+) * $0);\n                                              ^\n/tmp/tmp5cc1no7q.swift:29:47:\
    \ note: required by referencing operator function '*' on 'DurationProtocol' where\
    \ 'Self' = '(Int, Int) -> Int'\n    let even = arr.reduce(0 * 0, combine: (+)\
    \ * $0);\n                                              ^\n/tmp/tmp5cc1no7q.swift:37:19:\
    \ warning: forced cast of '[Int]' to same type has no effect\n    return result\
    \ as! [Int]\n                  ^~~~~~~~~\n                  \n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr == nil || arr.isEmpty() {\n    \
    \    return []\n    }\n    var maxIndex = 0\n    var maxValue = arr[0]\n    var\
    \ evenIndex = 0\n    var evenValue = arr[0]\n    for index in 1..<arr.count {\n\
    \        if arr[index] > maxValue {\n            maxValue = arr[index]\n     \
    \       maxIndex = index\n        } else if arr[index] == maxValue && index%2\
    \ == 0 {\n            evenValue = arr[index]\n            evenIndex = index\n\
    \        }\n    }\n    return [evenValue, evenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpijzzq0uf.swift:28:26: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr == nil || arr.isEmpty() {\n                        \
    \ ^      ~~\n                                \n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    var largest = 0\n    var smalest_value: Int = 0\n    var smallest_index:\
    \ Int = 0\n    for node : Int in arr {\n        if node.isEven && node.value >\
    \ largest * 2 {\n            largest = node.value\n            smalest_value =\
    \ node\n            smallest_index = smallest_index + 1\n        }\n    }\n  \
    \  if smallest_index == 0 {\n        return []\n    }\n    if smallest_index >\
    \ 0 {\n        if largest * 2 == smallest_value {\n            return [ smalest_value,\
    \ smallest_index ]\n        } else {\n            return [ smallest_value ]\n\
    \        }\n    }\n    return [ smalest_value ]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpd55xm0hl.swift:35:17: error: value of type 'Int' has no member\
    \ 'isEven'\n        if node.isEven && node.value > largest * 2 {\n           ~~~~\
    \ ^~~~~~\n/tmp/tmpd55xm0hl.swift:35:32: error: value of type 'Int' has no member\
    \ 'value'\n        if node.isEven && node.value > largest * 2 {\n            \
    \              ~~~~ ^~~~~\n/tmp/tmpd55xm0hl.swift:36:28: error: value of type\
    \ 'Int' has no member 'value'\n            largest = node.value\n            \
    \          ~~~~ ^~~~~\n/tmp/tmpd55xm0hl.swift:45:27: error: cannot find 'smallest_value'\
    \ in scope\n        if largest * 2 == smallest_value {\n                     \
    \     ^~~~~~~~~~~~~~\n/tmp/tmpd55xm0hl.swift:48:22: error: cannot find 'smallest_value'\
    \ in scope\n            return [ smallest_value ]\n                     ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n\n    var smallest: Int = 0\n    var smallestIndex: Int = 0\n    var count:\
    \ Int = 0\n    for ele in arr {\n        if ele % 2 == 0 && ele < smallest {\n\
    \            smallest = ele\n            smallestIndex = count\n        } else\
    \ if ele % 2 == 0 {\n            count += 1\n        }\n    }\n    return smallestIndex\
    \ == 0 ? [smallest] : []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp1xuchbra/tmp1xuchbra.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adce3fdfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adce3cd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adce3cd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adce3cd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1xuchbra                        0x0000557895a3561c <unavailable> + 5660

    5    libc.so.6                          0x00002adce41cb460 __libc_start_main +
    245

    6    tmp1xuchbra                        0x0000557895a35229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var maxValue = arr[0]\n    var maxIndex\
    \ = 0\n    for value in arr {\n        if value > maxValue {\n            maxValue\
    \ = value\n            maxIndex = 0\n        } else {\n            if value ==\
    \ maxValue {\n                maxIndex += 1\n            }\n        }\n    }\n\
    \    return [maxValue, maxIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpendbu2wr/tmpendbu2wr.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e55640c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e55337b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e55337988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e553367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpendbu2wr                        0x0000564fe531657c <unavailable> + 5500

    5    libc.so.6                          0x00002b2e5582c460 __libc_start_main +
    245

    6    tmpendbu2wr                        0x0000564fe5316189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = Ints(0)\n    for el in arr\
    \ {\n        switch el {\n        case 0: result.append {\n            switch\
    \ Int64(result.length) & UInt64(result.length) - 1L {\n            case 0L : fallthrough\n\
    \            case -1L : 1\n                result.append()\n            case 1L\
    \ : fallthrough\n            case 0L : 1\n            case 1L : fallthrough\n\
    \            case 0L : 1\n                result.append()\n            case 2L\
    \ : fallthrough\n            case 2L : 2\n                result.append()\n  \
    \          case 3L : fallthrough\n            case 3L : 3\n                result.append()\n\
    \            case 4L : fallthrough\n            case 4L : 4\n                result.append()\n\
    \            case 5L : fallthrough\n            case 5L : 5\n                result.append()\n\
    \            case 6L : fallthrough\n            case 6L : 6\n                result.append()\n\
    \            case 7L : fallthrough\n            case 7L : 7\n                result.append()\n\
    \            case 8L : fallthrough\n            case 8L : 8\n                result.append()\n\
    \            case 9L : fallthrough\n            case 9L : 9\n                result.append()\n\
    \            case 10L : fallthrough\n            case 10L : 10\n             \
    \   result.append()\n            case 11L : fallthrough\n            case 11L\
    \ : 11\n                result.append()\n            case 12L : fallthrough\n\
    \            case 12L : 12\n                result.append()\n            case\
    \ 13L : fallthrough\n            case 13L : 13\n                result.append()\n\
    \            case 14L : fallthrough\n            case 14L : 14\n             \
    \   result.append()\n            case 15L : fallthrough\n            case 15L\
    \ : 15\n                result.append()\n            case 16L : fallthrough\n\
    \            case 16L : 16\n                result.append()\n            case\
    \ 17L : fallthrough\n            case 17L : 17\n                result.append()\n\
    \            case 18L : fallthrough\n            case 18L : 18\n             \
    \   result.append()\n            case 19L : fallthrough\n            case 19L\
    \ : 19\n                result.append()\n            case 20L : fallthrough\n\
    \            case 20L : 20\n                result.append()\n            case\
    \ 21L : fallthrough\n            case 21L : 21\n                result.append()\n\
    \            case 22L : fallthrough\n            case 22L : 22\n             \
    \   result.append()\n            case 23L : fallthrough\n            case 23L\
    \ : 23\n                result.append()\n            case 24L : fallthrough\n\
    \            case 24L : 24\n                result.append()\n            case\
    \ 25L : fallthrough\n            case 25L : 25\n                result.\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp5l18yidl.swift:32:68: error: 'L' is not a valid digit in integer\
    \ literal\n            switch Int64(result.length) & UInt64(result.length) - 1L\
    \ {\n                                                                   ^\n/tmp/tmp5l18yidl.swift:33:19:\
    \ error: 'L' is not a valid digit in integer literal\n            case 0L : fallthrough\n\
    \                  ^\n/tmp/tmp5l18yidl.swift:34:20: error: 'L' is not a valid\
    \ digit in integer literal\n            case -1L : 1\n                   ^\n/tmp/tmp5l18yidl.swift:36:19:\
    \ error: 'L' is not a valid digit in integer literal\n            case 1L : fallthrough\n\
    \                  ^\n/tmp/tmp5l18yidl.swift:37:19: error: 'L' is not a valid\
    \ digit in integer literal\n            case 0L : 1\n                  ^\n/tmp/tmp5l18yidl.swift:38:19:\
    \ error: 'L' is not a valid digit in integer literal\n            case 1L : fallthrough\n\
    \                  ^\n/tmp/tmp5l18yidl.swift:39:19: error: 'L' is not a valid\
    \ digit in integer literal\n            case 0L : 1\n                  ^\n/tmp/tmp5l18yidl.swift:41:19:\
    \ error: 'L' is not a valid digit in integer literal\n            case 2L : fallthrough\n\
    \                  ^\n/tmp/tmp5l18yidl.swift:42:19: error: 'L' is not a valid\
    \ digit in integer literal\n            case 2L : 2\n                  ^\n/tmp/tmp5l18yidl.swift:44:19:\
    \ error: 'L' is not a valid digit in integer literal\n            case 3L : fallthrough\n\
    \                  ^\n/tmp/tmp5l18yidl.swift:45:19: error: 'L' is not a valid\
    \ digit in integer literal\n            case 3L : 3\n                  ^\n/tmp/tmp5l18yidl.swift:47:19:\
    \ error: 'L' is not a valid digit in integer literal\n            case 4L : fallthrough\n\
    \                  ^\n/tmp/tmp5l18yidl.swift:48:19: error: 'L' is not a valid\
    \ digit in integer literal\n            case 4L : 4\n                  ^\n/tmp/tmp5l18yidl.swift:50:19:\
    \ error: 'L' is not a valid digit in integer literal\n            case 5L : fallthrough\n\
    \                  ^\n/tmp/tmp5l18yidl.swift:51:19: error: 'L' is not a valid\
    \ digit in integer literal\n            case 5L : 5\n                  ^\n/tmp/"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr == [] {\n        return arr\n  \
    \  }\n    var result : [Int] = [0]\n    for value in arr {\n        result = minimumArray(result,\
    \ value)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpq0mzmghu.swift:33:18: error: cannot find 'minimumArray' in scope\n\
    \        result = minimumArray(result, value)\n                 ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    // First find the index of the smallest\
    \ value using binary search\n    var smallestIndex = -1\n    var smallestValue\
    \ = arr[0]\n    for index in 0..<arr.count {\n        if arr[index] < smallestValue\
    \ {\n            smallestValue = arr[index]\n            smallestIndex = index\n\
    \        }\n    }\n    \n    // Now sort the array from that index so that we\
    \ can pick one of the smallest values\n    var sortedArray = Array(0..<arr.count)\n\
    \    for i in 0..<arr.count {\n        if i != smallestIndex {\n            sortedArray[i]\
    \ = arr[i]\n        }\n    }\n    \n    // Now return the node if there are multiple\
    \ of the same smallest value\n    // and the smallest value is the smallest even\
    \ value\n    if sortedArray.count > 1 {\n        // Sort the array so that we\
    \ can find the smallest even value\n        var sortedArray = Array(0..<arr.count)\n\
    \        for i in 0..<arr.count {\n            if arr[i] % 2 == 0 {\n        \
    \        sortedArray[i] = arr[i]\n            }\n        }\n        \n       \
    \ // Search for smallest even value in sorted array\n        // If no even values\
    \ are in the array return an empty array\n        var smallestEvenIndex = 0\n\
    \        var smallestEvenValue = sortedArray[0]\n        for index in 0..<sortedArray.count\
    \ {\n            if sortedArray[index] % 2 == 0 && smallestEvenValue < sortedArray[index]\
    \ {\n                smallestEvenValue = sortedArray[index]\n                smallestEvenIndex\
    \ = index\n            }\n        }\n        \n        // Return the array that\
    \ contains the smallest value\n        return Array([smallestEvenValue, smallestEvenIndex])\n\
    \    }\n    \n    // If the array is empty, just return an empty array\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2,\
    \ 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: Exception
  stderr: 'tmposs7y9g2/tmposs7y9g2.swift:90: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48f2effc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48f2bf6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48f2bf6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48f2bf57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmposs7y9g2                        0x000056056ad2377c <unavailable> + 6012

    5    libc.so.6                          0x00002b48f30eb460 __libc_start_main +
    245

    6    tmposs7y9g2                        0x000056056ad23389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return pluck(arr, Int())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpq02g2pp2.swift:28:23: error: extra argument in call\n    return\
    \ pluck(arr, Int())\n                ~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evenValueIndex = -1\n    var min =\
    \ Int64(math.MinInt64)\n    var valueArray: [Int] = []\n    for element in arr\
    \ {\n        if element % 2 == 0 {\n            evenValueIndex += 1\n        \
    \    if element*2 == min {\n                min = element\n            }\n   \
    \     } else {\n            if evenValueIndex > 0 {\n                evenValueIndex\
    \ = 0\n                valueArray[evenValueIndex] = element\n            }\n \
    \       }\n    }\n    return valueArray\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbrml5hdi.swift:29:21: error: cannot find 'math' in scope\n    var\
    \ min = Int64(math.MinInt64)\n                    ^~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    \n    var minNode: Int = 0\n    var minIndex: Int = 0\n    \n    for\
    \ index in 0..<arr.count {\n        if arr[index] % 2 == 0 {\n            if minNode\
    \ == 0 {\n                minNode = arr[index]\n                minIndex = index\n\
    \            }\n            else {\n                if arr[index] < minNode {\n\
    \                    minNode = arr[index]\n                    minIndex = index\n\
    \                }\n            }\n        }\n    }\n    \n    return [minNode,\
    \ minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: Exception
  stderr: 'tmphznb2f_2/tmphznb2f_2.swift:69: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd459ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd456f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd456f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd456f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphznb2f_2                        0x00005599b1c249f4 <unavailable> + 6644

    5    libc.so.6                          0x00002afd45beb460 __libc_start_main +
    245

    6    tmphznb2f_2                        0x00005599b1c24299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let counts = arr.countMap()\n    let sorted\
    \ = arr.sorted()\n    var pluck_vals: [Int] = []\n    for i in 0..<min(sorted)\
    \ {\n        pluck_vals.append(sorted[i])\n        let count = counts[sorted[i]]\n\
    \        let mut min_count = count\n        for j in 0..<count {\n           \
    \ if min_count < counts[sorted[i+j]] {\n                min_count = counts[sorted[i+j]]\n\
    \            }\n        }\n        i += min_count - 1\n    }\n    return pluck_vals\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpebc0l1s8.swift:34:17: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut min_count\
    \ = count\n                ^\n/tmp/tmpebc0l1s8.swift:34:17: note: join the identifiers\
    \ together\n        let mut min_count = count\n            ~~~~^~~~~~~~~\n   \
    \         mutmin_count\n/tmp/tmpebc0l1s8.swift:34:17: note: join the identifiers\
    \ together with camel-case\n        let mut min_count = count\n            ~~~~^~~~~~~~~\n\
    \            mutMin_count\n/tmp/tmpebc0l1s8.swift:28:22: error: value of type\
    \ '[Int]' has no member 'countMap'\n    let counts = arr.countMap()\n        \
    \         ~~~ ^~~~~~~~\n/tmp/tmpebc0l1s8.swift:31:28: error: missing argument\
    \ for parameter #2 in call\n    for i in 0..<min(sorted) {\n                 \
    \          ^\n                           , <#[Int]#>\nSwift.min:1:24: note: 'min'\
    \ declared here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n/tmp/tmpebc0l1s8.swift:31:18: error: cannot\
    \ convert value of type '[Int]' to expected argument type 'Int'\n    for i in\
    \ 0..<min(sorted) {\n                 ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return sort.pickSort(arr.prefixSort(&swap),\
    \ &pick)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqts3b9w4.swift:28:12: error: cannot find 'sort' in scope\n    return\
    \ sort.pickSort(arr.prefixSort(&swap), &pick)\n           ^~~~\n/tmp/tmpqts3b9w4.swift:28:50:\
    \ error: cannot find 'pick' in scope\n    return sort.pickSort(arr.prefixSort(&swap),\
    \ &pick)\n                                                 ^~~~\n/tmp/tmpqts3b9w4.swift:28:30:\
    \ error: value of type '[Int]' has no member 'prefixSort'\n    return sort.pickSort(arr.prefixSort(&swap),\
    \ &pick)\n                         ~~~ ^~~~~~~~~~\n/tmp/tmpqts3b9w4.swift:28:41:\
    \ error: cannot pass immutable value as inout argument: 'swap' is a function\n\
    \    return sort.pickSort(arr.prefixSort(&swap), &pick)\n                    \
    \                    ^~~~~\n/tmp/tmpqts3b9w4.swift:28:42: error: generic parameter\
    \ 'T' could not be inferred\n    return sort.pickSort(arr.prefixSort(&swap), &pick)\n\
    \                                         ^\nSwift.swap:1:24: note: in call to\
    \ function 'swap'\n@inlinable public func swap<T>(_ a: inout T, _ b: inout T)\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return Array(\n        Set(arr).map() {\n\
    \            let value = $0\n            let index = $0.hashValue\n          \
    \  return value % 2 == 0 ? value : index\n        }\n    )\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp1f0pjaia/tmp1f0pjaia.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c86964c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c8665bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c8665b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c8665a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1f0pjaia                        0x00005607a5f6866c <unavailable> + 5740

    5    libc.so.6                          0x00002b4c86b50460 __libc_start_main +
    245

    6    tmp1f0pjaia                        0x00005607a5f68279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count != 0 else { return [] }\n\
    \    \n    arr.sort{$0 < $1}\n    var even = arr.filter { $0 % 2 == 0 }\n    if\
    \ even.count == 0 { return [] }\n    guard even.count == 1 else { return even\
    \ }\n    \n    let smallestIndex = arr.index(of: min(arr))\n    if smallestIndex\
    \ == -1 { return [] }\n    return arr.remove(at: smallestIndex)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8cehifal.swift:30:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort{$0 < $1}\n    ~~~ ^\n/tmp/tmp8cehifal.swift:35:46:\
    \ error: missing argument for parameter #2 in call\n    let smallestIndex = arr.index(of:\
    \ min(arr))\n                                             ^\n                \
    \                             , <#Int#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp8cehifal.swift:35:43: error: cannot convert\
    \ value of type '[Int]' to expected argument type 'Int'\n    let smallestIndex\
    \ = arr.index(of: min(arr))\n                                          ^\n/tmp/tmp8cehifal.swift:37:16:\
    \ error: no exact matches in call to instance method 'remove'\n    return arr.remove(at:\
    \ smallestIndex)\n               ^\n/tmp/tmp8cehifal.swift:37:16: note: found\
    \ candidate with type '(Int) -> Int'\n    return arr.remove(at: smallestIndex)\n\
    \               ^\n/tmp/tmp8cehifal.swift:37:16: error: cannot convert return\
    \ expression of type 'Int' to return type '[Int]'\n    return arr.remove(at: smallestIndex)\n\
    \           ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    // let smallestIndexes = Array(0..<arr.count).map{$0.filter{$0&1==0}.reduce(min)\
    \ }\n    let smallestIndexes = arr.enumerated().filter{$0.element&1 == 0}.reduce(min)\n\
    \    if smallestIndexes.count == 0 {\n        return []\n    }\n    return smallestIndexes\n\
    \        .enumerated()\n        .filter{_0.element&1==0}\n        .map{_0.element}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplkv7z8ej.swift:32:77: error: generic parameter 'T' could not be\
    \ inferred\n    let smallestIndexes = arr.enumerated().filter{$0.element&1 ==\
    \ 0}.reduce(min)\n                                                           \
    \                 ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmplkv7z8ej.swift:32:80: error: missing argument for parameter\
    \ #2 in call\n    let smallestIndexes = arr.enumerated().filter{$0.element&1 ==\
    \ 0}.reduce(min)\n                                                           \
    \                    ^\n                                                     \
    \                          , <#(@escaping (_, _) -> _, EnumeratedSequence<[Int]>.Iterator.Element)\
    \ throws -> (_, _) -> _#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n\
    \    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult:\
    \ (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n/tmp/tmplkv7z8ej.swift:38:17: error: cannot find\
    \ '_0' in scope\n        .filter{_0.element&1==0}\n                ^~\n/tmp/tmplkv7z8ej.swift:39:14:\
    \ error: cannot find '_0' in scope\n        .map{_0.element}\n             ^~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let len = arr.count\n    let count = stride(from:\
    \ 0, to: len, by: 2).map {\n        if $0 % 2 == 1 {\n            return $0\n\
    \        }\n        return -1\n    }\n    let minCount = count.min()\n    var\
    \ res = [Int](repeating: -1, count: count)\n    for i in count {\n        if res[i]\
    \ < 0 {\n            res[i] = arr[i]\n            if arr[i] % 2 == 0 {\n     \
    \           res[i] = arr[i]\n            }\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdweptvh_.swift:36:43: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n    var res = [Int](repeating: -1, count: count)\n\
    \                                          ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    if arr.count > 1 {\n        // sort the array by its value\n      \
    \  arr =  arr.sorted{ $0 < $1 }\n    }\n    var smallestEvenIndex = arr.index(of:\
    \ arr.min()!) + 1\n    var smallestEvenValue = arr[0]\n    // find all the nodes\
    \ with the same smallest even value\n    for i in 1..<arr.count {\n        if\
    \ arr[i] == arr[i-1]+1 {\n            smallestEvenIndex = i\n            smallestEvenValue\
    \ = arr[i]\n        }\n    }\n    return [smallestEvenValue, smallestEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpmfh0je0n.swift:33:9: error: cannot assign to value: 'arr' is a\
    \ 'let' constant\n        arr =  arr.sorted{ $0 < $1 }\n        ^~~\n/tmp/tmpmfh0je0n.swift:35:33:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n    var smallestEvenIndex\
    \ = arr.index(of: arr.min()!) + 1\n                                ^\n/tmp/tmpmfh0je0n.swift:35:33:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    var smallestEvenIndex = arr.index(of: arr.min()!) + 1\n         \
    \                       ^\n                            (                     \
    \    ?? <#default value#>)\n/tmp/tmpmfh0je0n.swift:35:33: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    var smallestEvenIndex\
    \ = arr.index(of: arr.min()!) + 1\n                                ^\n       \
    \                                              !\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return Solution().pluck(arr)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnis66znr.swift:28:12: error: cannot find 'Solution' in scope\n\
    \    return Solution().pluck(arr)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let sorted = arr.sorted { $0 < $1 }\n \
    \   var largest = sorted.last\n    var index = sorted.firstIndex{$0 == largest}\n\
    \    if index == sorted.count {\n        return []\n    }\n    var even = sorted[index].toInt()\
    \ % 2\n    var largestEven = sorted[index].toInt() // largestEven is the smallest\
    \ even value\n    largestEven = largestEven.nextUp { $0 == even } // largestEven\
    \ = largest even value after even\n    while even != largestEven {\n        index++\n\
    \        even = sorted[index].toInt() // even = smallest even value before largestEven\n\
    \        largestEven = sorted[index].toInt() // largestEven = smallest even value\
    \ after even\n    }\n    return sorted[index..<sorted.count]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdvrajckt.swift:34:23: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n    var even = sorted[index].toInt() % 2\n                    \
    \  ^\n/tmp/tmpdvrajckt.swift:34:23: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n    var even = sorted[index].toInt()\
    \ % 2\n                      ^\n                            ?? <#default value#>\n\
    /tmp/tmpdvrajckt.swift:34:23: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    var even = sorted[index].toInt() %\
    \ 2\n                      ^\n                           !\n/tmp/tmpdvrajckt.swift:34:30:\
    \ error: value of type 'Int' has no member 'toInt'\n    var even = sorted[index].toInt()\
    \ % 2\n               ~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpdvrajckt.swift:35:30: error:\
    \ value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped\
    \ to a value of type 'Array<Int>.Index' (aka 'Int')\n    var largestEven = sorted[index].toInt()\
    \ // largestEven is the smallest even value\n                             ^\n\
    /tmp/tmpdvrajckt.swift:35:30: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    var largestEven = sorted[index].toInt()\
    \ // largestEven is the smallest even value\n                             ^\n\
    \                                   ?? <#default value#>\n/tmp/tmpdvrajckt.swift:35:30:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    var largestEven = sorted[index].toInt() // largestEven is the smallest\
    \ even value\n                             ^\n                               \
    \   !\n/tmp/tmpdvrajckt.swift:35:37: error: value of type 'Int' has no member\
    \ 'toInt'\n    var largestEven = sorted[index].toInt() // largestEven is the smallest\
    \ even value\n                      ~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpdvrajckt.swift:38:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n/tmp/tmpdvrajckt.swift:39:23: error: value"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n  var minIdx = 0\n  var minVal = arr[0]\n \
    \ for i in 1..<arr.count {\n    if arr[i] < minVal {\n      minVal = arr[i]\n\
    \      minIdx = i\n    }\n  }\n  return arr[minIdx]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_5vpxfme.swift:36:13: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n  return arr[minIdx]\n         ~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var min: Int = 0\n    var minIndex = 0\n\
    \    for index, element in enumerate(arr) {\n        if element % 2 == 0 {\n \
    \           min = element\n            minIndex = index\n        }\n    }\n  \
    \  \n    if min == 0 {\n        return []\n    }\n    \n    var result: [Int]\
    \ = []\n    for index, element in enumerate(arr) {\n        if index == minIndex\
    \ {\n            result.append(element)\n        } else {\n            if element\
    \ == min {\n                result.append(minIndex)\n            } else {\n  \
    \              result.append(element)\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpt5z6txdy.swift:30:14: error: expected 'in' after for-each pattern\n\
    \    for index, element in enumerate(arr) {\n             ^\n/tmp/tmpt5z6txdy.swift:30:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, element\
    \ in enumerate(arr) {\n             ^\n/tmp/tmpt5z6txdy.swift:42:14: error: expected\
    \ 'in' after for-each pattern\n    for index, element in enumerate(arr) {\n  \
    \           ^\n/tmp/tmpt5z6txdy.swift:42:14: error: expected Sequence expression\
    \ for for-each loop\n    for index, element in enumerate(arr) {\n            \
    \ ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestVal = arr[0]\n    var index\
    \ = -1\n    \n    for i in 1..<arr.count {\n        if arr[i] < smallestVal {\n\
    \            smallestVal = arr[i]\n            index = i\n        } else if arr[i]\
    \ == smallestVal {\n            if arr[i-1] % 2 == 0 {\n                index\
    \ = i\n            } else {\n                break\n            }\n        }\n\
    \    }\n    \n    if index == -1 {\n        return []\n    }\n    return [smallestVal,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: Exception
  stderr: 'tmp1941boxk/tmp1941boxk.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2002454c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b200214bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b200214b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b200214a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1941boxk                        0x000055a22f4bc70b <unavailable> + 5899

    5    libc.so.6                          0x00002b2002640460 __libc_start_main +
    245

    6    tmp1941boxk                        0x000055a22f4bc1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n\tlet len = arr.count\n\tlet min_index = Int(arc4random_uniform(UInt32(len)))\n\
    \tlet index_of_min = arr.index(min_index) {\n\t\t$0.value % 2 == 0\n\t}\n\treturn\
    \ index_of_min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp87hlnuws.swift:29:22: error: cannot find 'arc4random_uniform' in\
    \ scope\n        let min_index = Int(arc4random_uniform(UInt32(len)))\n      \
    \                      ^~~~~~~~~~~~~~~~~~\n/tmp/tmp87hlnuws.swift:30:21: error:\
    \ type '(_) -> Bool' cannot conform to 'BinaryInteger'\n        let index_of_min\
    \ = arr.index(min_index) {\n                           ^\n/tmp/tmp87hlnuws.swift:30:21:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        let index_of_min = arr.index(min_index) {\n             \
    \              ^\n/tmp/tmp87hlnuws.swift:30:21: note: required by instance method\
    \ 'index(_:offsetBy:)' where 'T' = '(_) -> Bool'\n        let index_of_min = arr.index(min_index)\
    \ {\n                           ^\n/tmp/tmp87hlnuws.swift:30:42: error: unable\
    \ to infer type of a closure parameter '$0' in the current context\n        let\
    \ index_of_min = arr.index(min_index) {\n                                    \
    \            ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return pluck_helper(arr)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpfd70fg2o.swift:28:12: error: cannot find 'pluck_helper' in scope\n\
    \    return pluck_helper(arr)\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard len(arr) > 0 else { return [] }\n\
    \    guard arr.count > 0 else { return [] }\n\n    var res = [0]\n    var min\
    \ = arr[0]\n    var minIndex = 0\n\n    for _ in 0..<arr.count {\n        if arr[minIndex]\
    \ % 2 == 0 {\n            minIndex += 1\n            continue\n        }\n   \
    \     if arr[minIndex] == min {\n            minIndex += 1\n            continue\n\
    \        }\n        minIndex += 1\n        res = append(res, arr[minIndex])\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpq1xhn6im.swift:28:11: error: cannot find 'len' in scope\n    guard\
    \ len(arr) > 0 else { return [] }\n          ^~~\n/tmp/tmpq1xhn6im.swift:45:15:\
    \ error: cannot find 'append' in scope\n        res = append(res, arr[minIndex])\n\
    \              ^~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return pluckByIndex(arr, 0)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprujcucg6.swift:28:12: error: cannot find 'pluckByIndex' in scope\n\
    \    return pluckByIndex(arr, 0)\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.windows.reduce([Int]()) {\n\
    \        guard case $0.index < $1.index else {\n            return $1\n      \
    \  }\n        $0\n    }.map{ ($0.element % 2 == 0 ? $0.element : $0.index) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpee468utc.swift:29:40: error: variable binding in a condition requires\
    \ an initializer\n        guard case $0.index < $1.index else {\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    \n    guard arr.count > 0 else {\n        return []\n    }\n\n    guard\
    \ arr.first! > 0 else { return [] }\n    \n    let min = arr.first!\n    let index\
    \ = -1\n\n    for n in arr {\n        guard n % 2 == 0 else {\n            continue\n\
    \        }\n\n        if n < min {\n            min = n\n            index = arr.index(n)\
    \ // O(n)\n        }\n    }\n    \n    return [min, index]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptdbr6tww.swift:47:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = n\n            ^~~\n/tmp/tmptdbr6tww.swift:38:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = arr.first!\n \
    \   ^~~\n    var\n/tmp/tmptdbr6tww.swift:48:25: error: no exact matches in call\
    \ to instance method 'index'\n            index = arr.index(n) // O(n)\n     \
    \                   ^\n/tmp/tmptdbr6tww.swift:48:25: note: found candidate with\
    \ type '(Int) -> Int'\n            index = arr.index(n) // O(n)\n            \
    \            ^\n/tmp/tmptdbr6tww.swift:48:25: note: found candidate with type\
    \ '(Int) -> Int'\n            index = arr.index(n) // O(n)\n                 \
    \       ^\n/tmp/tmptdbr6tww.swift:48:13: error: cannot assign to value: 'index'\
    \ is a 'let' constant\n            index = arr.index(n) // O(n)\n            ^~~~~\n\
    /tmp/tmptdbr6tww.swift:39:5: note: change 'let' to 'var' to make it mutable\n\
    \    let index = -1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let len = arr.count\n    \n    if len ==\
    \ 0 {\n        return []\n    }\n    \n    let sorted = arr.sorted(by: { $0 <\
    \ $1 })\n    \n    var min_index = sorted[0] % 2\n    var min_val = sorted[0]\n\
    \    \n    for i in 1..<len {\n        if sorted[i] % 2 != min_index {\n     \
    \       min_index = sorted[i] % 2\n            min_val = sorted[i]\n        }\n\
    \    }\n    \n    return min_index == 0 ? [] : [min_val, min_index]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpok907v_k/tmpok907v_k.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b53ca5b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b53ca2a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b53ca2a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b53ca2a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpok907v_k                        0x00005573946f666c <unavailable> + 5740

    5    libc.so.6                          0x00002b53ca79d460 __libc_start_main +
    245

    6    tmpok907v_k                        0x00005573946f6279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpaq_4qk0y/tmpaq_4qk0y.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9794a2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9794725b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9794725988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97947247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaq_4qk0y                        0x00005643f6c213bc <unavailable> + 5052

    5    libc.so.6                          0x00002b9794c1a460 __libc_start_main +
    245

    6    tmpaq_4qk0y                        0x00005643f6c20fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var even = []\n    for i in arr {\n   \
    \     if i % 2 != 0 {\n            even.append(i)\n        }\n    }\n    let minIndex\
    \ = even.min()!\n    if even.count == 0 {\n        return []\n    } else {\n \
    \       return [minIndex, even.index(minIndex)]\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4fqf8vb7.swift:28:16: error: empty collection literal requires\
    \ an explicit type\n    var even = []\n               ^~\n/tmp/tmp4fqf8vb7.swift:34:20:\
    \ error: type 'Any' cannot conform to 'Comparable'\n    let minIndex = even.min()!\n\
    \                   ^\n/tmp/tmp4fqf8vb7.swift:34:20: note: only concrete types\
    \ such as structs, enums and classes can conform to protocols\n    let minIndex\
    \ = even.min()!\n                   ^\n/tmp/tmp4fqf8vb7.swift:34:20: note: required\
    \ by referencing instance method 'min()' on 'Sequence' where 'Self.Element' =\
    \ 'Any'\n    let minIndex = even.min()!\n                   ^\n/tmp/tmp4fqf8vb7.swift:38:32:\
    \ error: no exact matches in call to instance method 'index'\n        return [minIndex,\
    \ even.index(minIndex)]\n                               ^\n/tmp/tmp4fqf8vb7.swift:38:32:\
    \ note: found candidate with type '(Int) -> Int'\n        return [minIndex, even.index(minIndex)]\n\
    \                               ^\n/tmp/tmp4fqf8vb7.swift:38:32: note: found candidate\
    \ with type '(Int) -> Int'\n        return [minIndex, even.index(minIndex)]\n\
    \                               ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr == [] {\n        return []\n   \
    \ }\n    let evenValues = arr.filter{$0 % 2 == 0}\n    if evenValues.count ==\
    \ 0 {\n        return []\n    }\n    let minEvenIndex = evenValues.minElement()\n\
    \    let minEvenValue = arr[minEvenIndex]\n    return minEvenValue\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8qgeywbs.swift:35:35: error: value of type '[Int]' has no member\
    \ 'minElement'\n    let minEvenIndex = evenValues.minElement()\n             \
    \          ~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr == [] {\n        return arr\n  \
    \  }\n    if arr.count <= 1 {\n        return []\n    }\n\n    var index = 0\n\
    \    var smallest = 0\n    var smalest_value = arr[0]\n    for ele in arr {\n\
    \        if ele % 2 == 0 {\n            if smallest == 0 {\n                smallest\
    \ = ele\n                smalest_value = ele\n            } else if ele < smalest_value\
    \ {\n                smallest = ele\n                smalest_value = ele\n   \
    \         }\n        }\n        index += 1\n    }\n\n    return [smalest_value,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: Exception
  stderr: 'tmp9fkpdh6y/tmp9fkpdh6y.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5e2e672c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5e2e369b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5e2e369988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5e2e3687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9fkpdh6y                        0x00005595a708e66c <unavailable> + 5740

    5    libc.so.6                          0x00002b5e2e85e460 __libc_start_main +
    245

    6    tmp9fkpdh6y                        0x00005595a708e279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr == [] {\n        return []\n   \
    \ }\n    var result: [Int] = []\n    if arr.isEmpty() {\n        return result\n\
    \    }\n    let first: Int = arr[0]\n    var index = 0\n    while index < arr.count\
    \ {\n        if arr[index] % 2 == 0 {\n            result.append(arr[index])\n\
    \        }\n        if arr[index] > first {\n            break\n        }\n  \
    \      index += 1\n    }\n    if index < arr.count {\n        return result\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpm02rbk88.swift:32:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return pick(arr, compare: { $0 < $1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpeem0avuz.swift:28:12: error: cannot find 'pick' in scope\n    return\
    \ pick(arr, compare: { $0 < $1 })\n           ^~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n  var result = [0]\n  for i in arr {\n    if\
    \ result[0] == 0 || i % 2 == 0 {\n      result[0] = i\n      result[1] = result[1]\
    \ + 1\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac69bb82c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac69b879561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac69b879286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac69b87913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac69b878bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac69b678e83 <unavailable> + 188035

    6    tmp7jsct710                        0x000055d607ed5174 <unavailable> + 8564

    7    tmp7jsct710                        0x000055d607ed4594 <unavailable> + 5524

    8    libc.so.6                          0x00002ac69bd6e460 __libc_start_main +
    245

    9    tmp7jsct710                        0x000055d607ed4279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var ans = [0]\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] % 2 == 0 && arr[i] < ans[0] {\n            ans = [0]\n\
    \        }\n        ans = append(ans, arr[i])\n    }\n    return ans\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpsk1qmq_1.swift:29:12: error: expected type\n    for i := 0; i <\
    \ len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmpsk1qmq_1.swift:29:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmpsk1qmq_1.swift:29:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(arr); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minValues = [Int]()\n    var minIndices\
    \ = [Int]()\n    for i in arr {\n        minValues.append(i)\n        if i % 2\
    \ == 0 {\n            minIndices.append(arr.index(i))\n        }\n    }\n    if\
    \ minIndices.count == 0 || minValues.count == 0 || minIndices.count == minValues.count\
    \ {\n        return minIndices\n    }\n    return minIndices\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpmefolh9j.swift:33:35: error: no exact matches in call to instance\
    \ method 'index'\n            minIndices.append(arr.index(i))\n              \
    \                    ^\nSwift.Array:7:28: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(after:)')\n    @inlinable public func index(after\
    \ i: Int) -> Int\n                           ^\nSwift.Array:9:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public\
    \ func index(before i: Int) -> Int\n                           ^\nSwift.RandomAccessCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(after:)')\n\
    \    @inlinable public func index(after i: Self.Index) -> Self.Index\n       \
    \                    ^\nSwift.RandomAccessCollection:4:28: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public func\
    \ index(before i: Self.Index) -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEvenIndex\
    \ = 0\n    var smallestEven = arr[0]\n    arr.forEach({\n        if $0 % 2 ==\
    \ 0 {\n            if smallestEven < $0 {\n                smallestEven = $0\n\
    \                minEvenIndex = 0\n            }\n        }\n        result +=\
    \ [$0, $0]\n    })\n    if result.count > 0 {\n        result.forEach({\n    \
    \        if $0 < smallestEven {\n                smallestEven = $0\n         \
    \       minEvenIndex = 0\n            }\n        })\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp8uwqt8zm/tmp8uwqt8zm.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3cde53ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3cde235b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3cde235988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3cde2347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uwqt8zm                        0x00005557a035961c <unavailable> + 5660

    5    libc.so.6                          0x00002b3cde72a460 __libc_start_main +
    245

    6    tmp8uwqt8zm                        0x00005557a0359229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return largestEvenIdx(arr, 0)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp5oyj1dwj.swift:28:12: error: cannot find 'largestEvenIdx' in scope\n\
    \    return largestEvenIdx(arr, 0)\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return []\n\
    \    }\n    // Sort in ascending order.\n    var sorted = sort.sort(arr)\n   \
    \ // Get the smallest even value in sorted array.\n    var smallest_value = 0\n\
    \    var smallest_index = 0\n    for i in 0..<sorted.length {\n        if sorted[i]\
    \ % 2 == 0 {\n            smallest_value = sorted[i]\n            smallest_index\
    \ = i\n        }\n    }\n    var result = [smallest_value]\n    if smallest_index\
    \ != 0 {\n        var smallest_even_index = smallest_index - 1\n        while\
    \ smallest_even_index >= 0 && smallest_even_index < sorted.length && sorted[smallest_even_index]\
    \ % 2 == 0 {\n            smallest_even_index--\n        }\n        if smallest_even_index\
    \ != -1 {\n            result = [smallest_value, smallest_even_index]\n      \
    \  } else {\n            // There are no even values in the array.\n         \
    \   result = []\n        }\n    } else {\n        // There are no even values\
    \ in the array.\n        result = []\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3fs1tl9i.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp3fs1tl9i.swift:32:18: error: cannot find 'sort' in scope\n    var\
    \ sorted = sort.sort(arr)\n                 ^~~~\n/tmp/tmp3fs1tl9i.swift:46:32:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  smallest_even_index--\n                               ^~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    let n = arr.count\n    var evens\
    \ = [Int]()\n    \n    for idx in 0..<n {\n        if arr[idx] % 2 == 0 {\n  \
    \          evens.append(arr[idx])\n        }\n    }\n    \n    if evens.count\
    \ > 0 {\n        \n        let minValue = evens.min()\n        let minIndex =\
    \ 0\n        \n        for idx in 0..<n {\n            if arr[idx] == minValue\
    \ {\n                minIndex = idx\n            }\n        }\n        return\
    \ [minValue, minIndex]\n    }\n    \n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpmq6it8n_.swift:45:17: error: cannot assign to value: 'minIndex'\
    \ is a 'let' constant\n                minIndex = idx\n                ^~~~~~~~\n\
    /tmp/tmpmq6it8n_.swift:41:9: note: change 'let' to 'var' to make it mutable\n\
    \        let minIndex = 0\n        ^~~\n        var\n/tmp/tmpmq6it8n_.swift:48:17:\
    \ error: cannot convert value of type 'Int?' to expected element type 'Int'\n\
    \        return [minValue, minIndex]\n                ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return pick(arr, func(i, n int64) bool\
    \ {\n        n%2 == 0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpz3wmqiif.swift:28:22: error: expected expression in list of expressions\n\
    \    return pick(arr, func(i, n int64) bool {\n                     ^\n/tmp/tmpz3wmqiif.swift:28:26:\
    \ error: expected identifier in function declaration\n    return pick(arr, func(i,\
    \ n int64) bool {\n                         ^\n/tmp/tmpz3wmqiif.swift:28:12: error:\
    \ cannot find 'pick' in scope\n    return pick(arr, func(i, n int64) bool {\n\
    \           ^~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let n = arr.count\n    var i = 0\n    var\
    \ j = 0\n    var even = arr[n - 1]\n    var smalest_value = 0\n    var smalest_index\
    \ = 0\n    for _ in 0..<n {\n        if even != 0 {\n            if j > smalest_index\
    \ {\n                smalest_value = even\n                smalest_index = j\n\
    \            }\n            j = 0\n        }\n        even = arr[i]\n        i++\n\
    \    }\n    if j > smalest_index {\n        smalest_value = even\n        smalest_index\
    \ = j\n    }\n    return [smalest_value, smalest_index]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw8afv6pm.swift:43:10: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        i++\n         ^~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    let length = arr.count\n    if length\
    \ == 0 {\n        return []\n    }\n    \n    let maxValue = arr.max()\n    if\
    \ maxValue % 2 == 0 {\n        return arr\n    }\n    \n    var currentIndex =\
    \ 0\n    var smalestValue = maxValue\n    \n    while currentIndex < length &&\
    \ arr[currentIndex] != maxValue && arr[currentIndex] % 2 != 0 {\n        \n  \
    \      if arr[currentIndex] < maxValue {\n            currentIndex += 1\n    \
    \    }\n        \n        if arr[currentIndex] == maxValue {\n            smalestValue\
    \ = arr[currentIndex]\n            currentIndex += 1\n        }\n    }\n    \n\
    \    var result = [Int]()\n    \n    if currentIndex == length {\n        result\
    \ = arr\n    } else {\n        while currentIndex < length {\n            if arr[currentIndex]\
    \ == maxValue {\n                result = [maxValue, currentIndex]\n         \
    \       currentIndex += 1\n            } else {\n                currentIndex\
    \ += 1\n            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp2ohdcwdp.swift:35:8: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    if maxValue % 2 == 0 {\n       ^\n\
    /tmp/tmp2ohdcwdp.swift:35:8: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    if maxValue % 2 == 0 {\n       ^\n  \
    \     (        ?? <#default value#>)\n/tmp/tmp2ohdcwdp.swift:35:8: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    if maxValue\
    \ % 2 == 0 {\n       ^\n               !\n/tmp/tmp2ohdcwdp.swift:44:32: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \       if arr[currentIndex] < maxValue {\n                               ^\n\
    /tmp/tmp2ohdcwdp.swift:44:32: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n        if arr[currentIndex] < maxValue {\n\
    \                               ^\n                                        ??\
    \ <#default value#>\n/tmp/tmp2ohdcwdp.swift:44:32: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        if arr[currentIndex]\
    \ < maxValue {\n                               ^\n                           \
    \            !\n/tmp/tmp2ohdcwdp.swift:61:27: error: cannot convert value of type\
    \ 'Int?' to expected element type 'Int'\n                result = [maxValue, currentIndex]\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return []\n\
    \    }\n    var minValue = arr[0]\n    var minIndex = 0\n    for val in arr {\n\
    \        if val%2 == 0 {\n            if val < minValue {\n                minValue\
    \ = val\n                minIndex = 0\n            }\n        } else if val <\
    \ minValue {\n            minValue = val\n            minIndex = 1\n        }\n\
    \    }\n    return [minValue, minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpmmtpvld0.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr == nil {\n        return []\n  \
    \  }\n    var smallestEven = -1\n    var smallestIndex = 0\n    for idx, val in\
    \ enumerate(arr) {\n        if val % 2 == 0 && val != smallestEven {\n       \
    \     smallestEven = val\n            smallestIndex = idx\n        }\n    }\n\
    \    if smallestEven != -1 {\n        return [smallestEven, smallestIndex]\n \
    \   }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpjvdvqs4_.swift:33:12: error: expected 'in' after for-each pattern\n\
    \    for idx, val in enumerate(arr) {\n           ^\n/tmp/tmpjvdvqs4_.swift:33:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, val in enumerate(arr)\
    \ {\n           ^\n/tmp/tmpjvdvqs4_.swift:28:12: warning: comparing non-optional\
    \ value of type '[Int]' to 'nil' always returns false\n    if arr == nil {\n \
    \      ~~~ ^  ~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n\tvar smalest_value : Int\n\tvar smalest_index\
    \ : Int = 0\n\t\n\tfor index, element in enumerate(arr) {\n\t\tif element % 2\
    \ == 0 {\n\t\t\tif smalest_value > element {\n\t\t\t\tsmalest_value = element\n\
    \t\t\t\tsmalest_index = index\n\t\t\t}\n\t\t}\n\t}\n\treturn arr[smalest_index]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpruohwxb2.swift:31:11: error: expected 'in' after for-each pattern\n\
    \        for index, element in enumerate(arr) {\n                 ^\n/tmp/tmpruohwxb2.swift:31:11:\
    \ error: expected Sequence expression for for-each loop\n        for index, element\
    \ in enumerate(arr) {\n                 ^\n/tmp/tmpruohwxb2.swift:39:12: error:\
    \ cannot convert return expression of type 'Int' to return type '[Int]'\n    \
    \    return arr[smalest_index]\n               ~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.isEmpty else {\n        var result\
    \ = arr\n        let value = arr.min()\n        let index = result.index(of: value)\n\
    \        if index != nil {\n            result.remove(at: index!)\n        }\n\
    \        return result\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpaedwvppz.swift:31:38: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        let index = result.index(of:\
    \ value)\n                                     ^\n/tmp/tmpaedwvppz.swift:30:13:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n        let value = arr.min()\n            ^\n       \
    \ guard                 else { return <#default value#> }\n/tmp/tmpaedwvppz.swift:30:25:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let value = arr.min()\n                        ^\n          \
    \                    ?? <#default value#>\n/tmp/tmpaedwvppz.swift:30:25: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        let value = arr.min()\n                        ^\n                  \
    \           !\n/tmp/tmpaedwvppz.swift:31:38: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        let index = result.index(of:\
    \ value)\n                                     ^\n                           \
    \                ?? <#default value#>\n/tmp/tmpaedwvppz.swift:31:38: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        let\
    \ index = result.index(of: value)\n                                     ^\n  \
    \                                        !\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n  return lcsIndex(lcsIndex(arr))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp9qw2y5y0.swift:28:10: error: cannot find 'lcsIndex' in scope\n\
    \  return lcsIndex(lcsIndex(arr))\n         ^~~~~~~~\n/tmp/tmp9qw2y5y0.swift:28:19:\
    \ error: cannot find 'lcsIndex' in scope\n  return lcsIndex(lcsIndex(arr))\n \
    \                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return nil\n\
    \    }\n\n    // Find smallest even value, smallest_even.\n    var smallest_even\
    \ = arr[0]\n    // Smallest even index, smallest_even_index.\n    var smallest_even_index\
    \ = Int(0)\n    // Smallest even value, smallest_even_value, smallest even index,\
    \ smallest even value.\n    var smallest_even_value, smallest_even_index\n\n \
    \   // Smallest odd value, smallest_odd_value.\n    var smallest_odd_value = Int(0)\n\
    \    // Smallest odd index, smallest_odd_index.\n    var smallest_odd_index =\
    \ Int(0)\n\n    // Find smallest even value in arr.\n    smallest_even_index =\
    \ 1\n    smallest_even_value = Int(arr[0])\n\n    // Find the smallest odd value.\n\
    \    for i in 1..<arr.count {\n        if arr[i] < smallest_even_value {\n   \
    \         smallest_even_index = i\n            smallest_even_value = Int(arr[i])\n\
    \        } else if arr[i] == smallest_even_value {\n            if smallest_even_index\
    \ < i {\n                smallest_even_index = i\n                smallest_even_value\
    \ = Int(arr[i])\n            }\n        }\n    }\n\n    // Find the smallest odd\
    \ value.\n    for i in 1..<arr.count {\n        if arr[i] < smallest_odd_value\
    \ {\n            smallest_odd_index = i\n            smallest_odd_value = Int(arr[i])\n\
    \        } else if arr[i] == smallest_odd_value {\n            if smallest_odd_index\
    \ < i {\n                smallest_odd_index = i\n                smallest_odd_value\
    \ = Int(arr[i])\n            }\n        }\n    }\n\n    // If the odd index is\
    \ smaller than the even index, return the even index.\n    // If the odd index\
    \ is greater than the even index, return the odd index.\n    return smallest_odd_index\
    \ < smallest_even_index ? smallest_even_index : smallest_odd_index\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1ash3u5u.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp1ash3u5u.swift:29:16: error: 'nil' is incompatible with return type\
    \ '[Int]'\n        return nil\n               ^\n/tmp/tmp1ash3u5u.swift:37:9:\
    \ error: type annotation missing in pattern\n    var smallest_even_value, smallest_even_index\n\
    \        ^\n/tmp/tmp1ash3u5u.swift:37:30: error: type annotation missing in pattern\n\
    \    var smallest_even_value, smallest_even_index\n                          \
    \   ^\n/tmp/tmp1ash3u5u.swift:76:53: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return smallest_odd_index < smallest_even_index\
    \ ? smallest_even_index : smallest_odd_index\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    arr.sortInPlace()\n    \n    if arr.isEmpty()\
    \ {\n        return []\n    }\n    \n    var smallestValue : Int = 0\n    var\
    \ index : Int = 0\n    \n    \n    var node : Int = 0\n    \n    \n    for node\
    \ in arr {\n        \n        \n        \n        if node < smallestValue {\n\
    \            smallestValue = node\n            index = 0\n        }\n        \n\
    \        \n        if node % 2 == 0 {\n            smallestValue = node\n    \
    \        index = 1\n        }\n        \n        \n    }\n    \n    if smallestValue\
    \ == 0 {\n        return []\n    }\n    return [smallestValue, index]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph0lzz2y9.swift:29:9: error: value of type '[Int]' has no member\
    \ 'sortInPlace'\n    arr.sortInPlace()\n    ~~~ ^~~~~~~~~~~\n/tmp/tmph0lzz2y9.swift:31:12:\
    \ error: cannot call value of non-function type 'Bool'\n    if arr.isEmpty() {\n\
    \           ^      ~~\n                  \n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let n = arr.count\n    if n < 2 {\n   \
    \     return []\n    }\n    var evenValues = arr[0..n-1]\n    var smallEvenValues\
    \ = arr[0..n-1]\n    for i in 0..n-1 {\n        if evenValues[i]%2 != 0 {\n  \
    \          evenValues = evenValues.prefix(2)\n            smallEvenValues = smallEvenValues.prefix(2)\n\
    \            break\n        }\n    }\n    if n == 1 {\n        let smallEvenIndex\
    \ = smallEvenValues.firstIndex(of: 0)\n        if smallEvenIndex < 0 {\n     \
    \       return []\n        } else {\n            return smallEvenValues[smallEvenIndex]\n\
    \        }\n    }\n    var smallEvenIndex = 0\n    for i in 0..<n {\n        if\
    \ evenValues[i]%2 == 0 && smallEvenValues[i]%2 == 0 {\n            smallEvenIndex\
    \ = i\n            break\n        }\n    }\n    return smallEvenValues[smallEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp2zimvk9d.swift:32:27: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    var evenValues = arr[0..n-1]\n                    \
    \      ^~\n                          ...\n/tmp/tmp2zimvk9d.swift:33:32: error:\
    \ cannot find operator '..' in scope; did you mean '...'?\n    var smallEvenValues\
    \ = arr[0..n-1]\n                               ^~\n                         \
    \      ...\n/tmp/tmp2zimvk9d.swift:34:15: error: cannot find operator '..' in\
    \ scope; did you mean '...'?\n    for i in 0..n-1 {\n              ^~\n      \
    \        ...\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var current =\
    \ [Int]()\n    for i in arr {\n        current = [Int]()\n        current.append(i)\n\
    \        let index = current.index(of: i as! Int, in: arr.indices)\n        if\
    \ index < 0 {\n            current.sort()\n            if current[0] % 2 == 0\
    \ {\n                result.append(current[0])\n            } else {\n       \
    \         result.append(current[1])\n            }\n        } else {\n       \
    \     result.append(index)\n        }\n    }\n    return result as! [Int]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp2u_j_n4s.swift:33:58: error: extra argument 'in' in call\n    \
    \    let index = current.index(of: i as! Int, in: arr.indices)\n             \
    \                    ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmp2u_j_n4s.swift:33:41:\
    \ warning: forced cast of 'Int' to same type has no effect\n        let index\
    \ = current.index(of: i as! Int, in: arr.indices)\n                          \
    \              ^~~~~~~\n                                        \n/tmp/tmp2u_j_n4s.swift:45:19:\
    \ warning: forced cast of '[Int]' to same type has no effect\n    return result\
    \ as! [Int]\n                  ^~~~~~~~~\n                  \n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // TODO: Fill out your solution here\n\
    \    var res: [Int] = []\n    var index = 0\n    for i in arr {\n        if i\
    \ % 2 == 0 {\n            res[index] = i\n            index += 1\n        }\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af142a46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af14273d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af14273d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af14273d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af14273cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af14253c7ec <unavailable> + 186348

    6    tmpiridv1ow                        0x0000559f3e5350b9 <unavailable> + 8377

    7    tmpiridv1ow                        0x0000559f3e534544 <unavailable> + 5444

    8    libc.so.6                          0x00002af142c32460 __libc_start_main +
    245

    9    tmpiridv1ow                        0x0000559f3e534229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let minVal = arr.reduce(0, {$0 + $1})\n\
    \    var min = minVal\n    var index: Int = 0\n\n    for i in arr {\n        if\
    \ i % 2 == 0 {\n            if i == min {\n                minVal += 1\n     \
    \           min = minVal\n                index += 1\n            } else {\n \
    \               minVal += 1\n                min = minVal\n                index++\n\
    \            }\n        }\n    }\n\n    if arr.isEmpty() {\n        return []\n\
    \    }\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpevlsb8j_.swift:35:24: error: left side of mutating operator isn't\
    \ mutable: 'minVal' is a 'let' constant\n                minVal += 1\n       \
    \         ~~~~~~ ^\n/tmp/tmpevlsb8j_.swift:28:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let minVal = arr.reduce(0, {$0 + $1})\n    ^~~\n    var\n\
    /tmp/tmpevlsb8j_.swift:39:24: error: left side of mutating operator isn't mutable:\
    \ 'minVal' is a 'let' constant\n                minVal += 1\n                ~~~~~~\
    \ ^\n/tmp/tmpevlsb8j_.swift:28:5: note: change 'let' to 'var' to make it mutable\n\
    \    let minVal = arr.reduce(0, {$0 + $1})\n    ^~~\n    var\n/tmp/tmpevlsb8j_.swift:41:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      index++\n                     ^~\n/tmp/tmpevlsb8j_.swift:46:12: error:\
    \ cannot call value of non-function type 'Bool'\n    if arr.isEmpty() {\n    \
    \       ^      ~~\n                  \n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.isEmpty == false else { return\
    \ [] }\n    var largest = [Int]()\n    var largestIndex = 0\n    for index in\
    \ 0..<arr.count {\n        if arr[index] % 2 == 0 {\n            largest.append(arr[index])\n\
    \            largestIndex = index\n        }\n    }\n    return largest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpn1lq3msa/tmpn1lq3msa.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac724672c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac724369b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac724369988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac7243687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn1lq3msa                        0x0000558ccac6873c <unavailable> + 5948

    5    libc.so.6                          0x00002ac72485e460 __libc_start_main +
    245

    6    tmpn1lq3msa                        0x0000558ccac68349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if isEmpty(arr) {\n        return []\n\
    \    }\n    var result: [Int] = []\n    var minValue = arr[0]\n    var minIndex\
    \ = 0\n    for i : Int in 0..<arr.count {\n        if arr[i] < minValue {\n  \
    \          minValue = arr[i]\n            minIndex = i\n        }\n    }\n   \
    \ result.append(minValue)\n    result.append(minIndex)\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpvj71cmst.swift:28:8: error: cannot find 'isEmpty' in scope\n  \
    \  if isEmpty(arr) {\n       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var i = 0\n    var maxIndex = 0\n\
    \    var maxValue = 0\n    \n    for value in arr {\n        if value < maxValue\
    \ {\n            continue\n        }\n        \n        if maxValue == 0 {\n \
    \           maxValue = value\n            maxIndex = i\n        }\n        \n\
    \        if value == maxValue {\n            maxIndex++\n        }\n        \n\
    \        maxValue = value\n        i = i + 1\n    }\n    \n    return arr[maxIndex..<arr.count]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6ynx7wcj.swift:44:21: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            maxIndex++\n                    ^~\n/tmp/tmp6ynx7wcj.swift:51:15:\
    \ error: cannot convert return expression of type 'ArraySlice<Int>' to return\
    \ type '[Int]'\n    return arr[maxIndex..<arr.count]\n           ~~~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = IntArray()\n    var minValue\
    \ = Int()\n    var minIndex = -1\n    for i := 0; i < len(arr); i++ {\n      \
    \  if arr[i] < minValue {\n            minValue = arr[i]\n            minIndex\
    \ = i\n        }\n    }\n    if minValue == 0 {\n        result[0] = minValue\n\
    \    } else {\n        result[0] = minValue\n        for i := 0; i < len(arr);\
    \ i++ {\n            if arr[i] == minValue {\n                result[1] = i\n\
    \                return\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpr6tn5mqp.swift:31:12: error: expected type\n    for i := 0; i <\
    \ len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmpr6tn5mqp.swift:31:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmpr6tn5mqp.swift:31:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(arr); i++ {\n           ^\n/tmp/tmpr6tn5mqp.swift:41:16:\
    \ error: expected type\n        for i := 0; i < len(arr); i++ {\n            \
    \   ^\n                <#type#>\n/tmp/tmpr6tn5mqp.swift:41:16: error: expected\
    \ 'in' after for-each pattern\n        for i := 0; i < len(arr); i++ {\n     \
    \          ^\n/tmp/tmpr6tn5mqp.swift:41:16: error: expected Sequence expression\
    \ for for-each loop\n        for i := 0; i < len(arr); i++ {\n               ^\n\
    /tmp/tmpr6tn5mqp.swift:28:18: error: cannot find 'IntArray' in scope\n    var\
    \ result = IntArray()\n                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minIndex\
    \ = -1\n    var minValue = arr[0]\n    for i := 0; i < arr.length; i++ {\n   \
    \     if arr[i] >= minValue {\n            result[minIndex] = arr[i]\n       \
    \     if arr[i] < minValue {\n                minValue = arr[i]\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if minIndex == -1 {\n\
    \        return result\n    }\n    return minIndex == 0 ? result : [minValue]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_6_gieg0.swift:31:12: error: expected type\n    for i := 0; i <\
    \ arr.length; i++ {\n           ^\n            <#type#>\n/tmp/tmp_6_gieg0.swift:31:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < arr.length;\
    \ i++ {\n           ^\n/tmp/tmp_6_gieg0.swift:31:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < arr.length; i++ {\n      \
    \     ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    let len = arr.count\n    \n    if\
    \ len == 0 {\n        return arr\n    }\n    \n    var even = [Int]()\n    var\
    \ index = 0\n    var smalest_value = 0\n    \n    for node in arr {\n        let\
    \ value = node.value % 2 == 0 ? node.value : node.value + 1\n        if value\
    \ < smalest_value {\n            smalest_value = value\n            even = [Int]()\n\
    \        }\n        if value < smalest_value && value < even.count {\n       \
    \     even.append(value)\n            index += 1 // if current value is already\
    \ in even, add 1 to index\n        }\n    }\n    \n    if even.count == 1 {\n\
    \        return even\n    } else {\n        if even.count > 0 {\n            return\
    \ even\n        } else {\n            return [index]\n        }\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpz4qgdx38.swift:40:26: error: value of type 'Int' has no member\
    \ 'value'\n        let value = node.value % 2 == 0 ? node.value : node.value +\
    \ 1\n                    ~~~~ ^~~~~\n/tmp/tmpz4qgdx38.swift:40:48: error: value\
    \ of type 'Int' has no member 'value'\n        let value = node.value % 2 == 0\
    \ ? node.value : node.value + 1\n                                          ~~~~\
    \ ^~~~~\n/tmp/tmpz4qgdx38.swift:40:61: error: value of type 'Int' has no member\
    \ 'value'\n        let value = node.value % 2 == 0 ? node.value : node.value +\
    \ 1\n                                                       ~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr == nil || arr.isEmpty() {\n    \
    \    return []\n    }\n    var result = [Int]()\n    var node = arr[0]\n    var\
    \ index = arr[0]\n    if arr.isEmpty() {\n        return result\n    }\n    for\
    \ ele in arr {\n        if ele % 2 == 0 && ele < node {\n            result.append(ele)\n\
    \            node = ele\n            index = ele\n        } else {\n         \
    \   if ele == node {\n                result.append(index)\n                index\
    \ = ele\n            } else {\n                result.append(ele)\n          \
    \      node = ele\n                index = ele\n            }\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpl22tkzu9.swift:28:26: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr == nil || arr.isEmpty() {\n                        \
    \ ^      ~~\n                                \n/tmp/tmpl22tkzu9.swift:34:12: error:\
    \ cannot call value of non-function type 'Bool'\n    if arr.isEmpty() {\n    \
    \       ^      ~~\n                  \n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var even = [Int]()\n    var index\
    \ = Int()\n    \n    \n    for node in arr {\n        if node % 2 == 0 {\n   \
    \         \n            \n            if even.count > 0 {\n                \n\
    \                if node < even.minElement() {\n                    \n       \
    \             \n                    index = even.indexOf(node)\n             \
    \       even.removeAll(at: index)\n                }\n            } else {\n \
    \               \n                even.append(node)\n                index = even.indexOf(node)\n\
    \            }\n        }\n    }\n    \n    \n    if even.count > 0 {\n      \
    \  index = even.indexOf(0)\n        even.removeAll(at: index)\n    }\n    \n \
    \   return even as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6mzfrw_d.swift:39:32: error: value of type '[Int]' has no member\
    \ 'minElement'\n                if node < even.minElement() {\n              \
    \            ~~~~ ^~~~~~~~~~\n/tmp/tmp6mzfrw_d.swift:42:34: error: value of type\
    \ '[Int]' has no member 'indexOf'\n                    index = even.indexOf(node)\n\
    \                            ~~~~ ^~~~~~~\n/tmp/tmp6mzfrw_d.swift:43:40: error:\
    \ extra argument 'at' in call\n                    even.removeAll(at: index)\n\
    \                                  ~~~~~^~~~~~\n/tmp/tmp6mzfrw_d.swift:48:30:\
    \ error: value of type '[Int]' has no member 'indexOf'\n                index\
    \ = even.indexOf(node)\n                        ~~~~ ^~~~~~~\n/tmp/tmp6mzfrw_d.swift:55:22:\
    \ error: value of type '[Int]' has no member 'indexOf'\n        index = even.indexOf(0)\n\
    \                ~~~~ ^~~~~~~\n/tmp/tmp6mzfrw_d.swift:56:28: error: extra argument\
    \ 'at' in call\n        even.removeAll(at: index)\n                      ~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return helper(arr, false)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpetaxd86k.swift:28:12: error: cannot find 'helper' in scope\n  \
    \  return helper(arr, false)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n\n    // Sort the array and find the smallest even value\n    let sortedArr\
    \ = arr.sorted(by: >)\n    if arr.contains(sortedArr.min() % 2 == 0) {\n     \
    \   return sortedArr.min()\n    }\n\n    var result = [Int]()\n    var index =\
    \ 0\n    var evenMin = sortedArr.min()\n    var evenIndex = 0\n\n    for n in\
    \ sortedArr {\n        if n % 2 == 0 {\n            // The first two nodes here\
    \ are the smallest even values.\n            // The current node is the next node\
    \ with the smallest index.\n            if evenMin == n {\n                evenMin\
    \ = sortedArr[index]\n                evenIndex = index\n            }\n\n   \
    \         index += 1\n        } else {\n            // The first two nodes here\
    \ are the smallest even values.\n            // The current node is the next node\
    \ with the smallest index.\n            if evenMin == n {\n                result.append(sortedArr[evenIndex])\n\
    \                evenIndex += 1\n            }\n        }\n    }\n\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpemq85fv_.swift:34:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n    if arr.contains(sortedArr.min() % 2 ==\
    \ 0) {\n                                        ^\n/tmp/tmpemq85fv_.swift:34:31:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    if arr.contains(sortedArr.min() % 2 == 0) {\n                           \
    \   ^\n/tmp/tmpemq85fv_.swift:34:31: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n    if arr.contains(sortedArr.min()\
    \ % 2 == 0) {\n                              ^\n                    (        \
    \       ?? <#default value#>)\n/tmp/tmpemq85fv_.swift:34:31: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    if arr.contains(sortedArr.min()\
    \ % 2 == 0) {\n                              ^\n                             \
    \      !\n/tmp/tmpemq85fv_.swift:35:26: error: cannot convert return expression\
    \ of type 'Int?' to return type '[Int]'\n        return sortedArr.min()\n    \
    \           ~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evenValues = [Int]()\n    var indexOfSmallestEvenValue\
    \ = -1\n    var indexOfSmallestIndex = 0\n    for i in arr {\n        if i % 2\
    \ == 0 {\n            evenValues.append(i)\n            if indexOfSmallestEvenValue\
    \ == -1 || i < indexOfSmallestEvenValue {\n                indexOfSmallestEvenValue\
    \ = i\n                indexOfSmallestIndex = indexOfSmallestEvenValue\n     \
    \       }\n        }\n    }\n    if indexOfSmallestEvenValue != -1 && indexOfSmallestEvenValue\
    \ < indexOfSmallestIndex {\n        indexOfSmallestIndex = indexOfSmallestEvenValue\n\
    \    }\n    if indexOfSmallestIndex == -1 {\n        return nil\n    }\n    return\
    \ [evenValues[indexOfSmallestIndex], indexOfSmallestIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpu67lbb52.swift:44:16: error: 'nil' is incompatible with return\
    \ type '[Int]'\n        return nil\n               ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    sort.Sort(&arr)\n    var res [Int]\n  \
    \  var min = 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] % 2 ==\
    \ 0 {\n            res[min] = arr[i]\n            min++\n        }\n    }\n  \
    \  if min == len(arr) {\n        return []\n    }\n    min -= 1\n    return res[0:min]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3br61rft.swift:29:12: error: consecutive statements on a line must\
    \ be separated by ';'\n    var res [Int]\n           ^\n           ;\n/tmp/tmp3br61rft.swift:31:12:\
    \ error: expected type\n    for i := 0; i < len(arr); i++ {\n           ^\n  \
    \          <#type#>\n/tmp/tmp3br61rft.swift:31:12: error: expected 'in' after\
    \ for-each pattern\n    for i := 0; i < len(arr); i++ {\n           ^\n/tmp/tmp3br61rft.swift:31:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(arr);\
    \ i++ {\n           ^\n/tmp/tmp3br61rft.swift:41:17: error: expected ',' separator\n\
    \    return res[0:min]\n                ^\n                ,\n/tmp/tmp3br61rft.swift:41:17:\
    \ error: expected expression in list of expressions\n    return res[0:min]\n \
    \               ^\n/tmp/tmp3br61rft.swift:28:5: error: cannot find 'sort' in scope\n\
    \    sort.Sort(&arr)\n    ^~~~\n/tmp/tmp3br61rft.swift:28:15: error: cannot pass\
    \ immutable value as inout argument: 'arr' is a 'let' constant\n    sort.Sort(&arr)\n\
    \              ^~~~\n/tmp/tmp3br61rft.swift:29:9: error: type annotation missing\
    \ in pattern\n    var res [Int]\n        ^\n/tmp/tmp3br61rft.swift:29:13: error:\
    \ expected member name or constructor call after type name\n    var res [Int]\n\
    \            ^\n/tmp/tmp3br61rft.swift:29:17: note: add arguments after the type\
    \ to construct a value of the type\n    var res [Int]\n                ^\n   \
    \              ()\n/tmp/tmp3br61rft.swift:29:17: note: use '.self' to reference\
    \ the type object\n    var res [Int]\n                ^\n                 .self\n\
    /tmp/tmp3br61rft.swift:29:13: warning: expression of type '[Int].Type' is unused\n\
    \    var res [Int]\n            ^~~~~\n/tmp/tmp3br61rft.swift:37:15: error: cannot\
    \ find 'len' in scope\n    if min == len(arr) {\n              ^~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let len = arr.count\n    var picked = 0\n\
    \    var minValue = IntMax\n    var minIndex = -1\n    for i in 0..<len {\n  \
    \      if arr[i] > minValue {\n            minIndex = i\n            minValue\
    \ = arr[i]\n        }\n    }\n    if minIndex >= 0 && minValue % 2 == 0 {\n  \
    \      picked = minIndex\n    }\n    return arr[picked]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmphbc1tqjl.swift:30:20: error: cannot find 'IntMax' in scope\n  \
    \  var minValue = IntMax\n                   ^~~~~~\n/tmp/tmphbc1tqjl.swift:41:15:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return arr[picked]\n           ~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minValue = arr[0]\n    var index =\
    \ 0\n    for value in arr {\n        if value == 0 {\n            continue\n \
    \       }\n        if value < minValue {\n            minValue = value\n     \
    \       index = index\n        }\n    }\n    if arr[index] != 0 {\n        return\
    \ [minValue, index]\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpx34h8ot8.swift:36:19: error: assigning a variable to itself\n \
    \           index = index\n            ~~~~~ ^ ~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return []\n\
    \    }\n    var even_index: Int? = nil\n    var smallest_value: Int = 0\n    for\
    \ i in arr {\n        if i % 2 == 0 {\n            even_index = i\n          \
    \  smallest_value = i\n            if smallest_value == 0 && even_index == nil\
    \ {\n                break\n            }\n        }\n    }\n    if even_index\
    \ == nil || even_index != arr.first {\n        return []\n    }\n    let index\
    \ = arr.index(of: smallest_value)\n    if index == arr.last-1 {\n        return\
    \ [smallest_value, index]\n    } else {\n        return Array(arr[index..<arr.end]).map\
    \ { (i) -> Int in\n            if i % 2 == 0 {\n                return i\n   \
    \         } else {\n                return i\n            }\n        }\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpsjwij_w6.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpsjwij_w6.swift:45:21: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    let index = arr.index(of: smallest_value)\n      \
    \              ^\n/tmp/tmpsjwij_w6.swift:45:21: note: use 'firstIndex(of:)' instead\n\
    \    let index = arr.index(of: smallest_value)\n                    ^~~~~\n  \
    \                  firstIndex\n/tmp/tmpsjwij_w6.swift:46:21: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n    if index == arr.last-1\
    \ {\n                    ^\n/tmp/tmpsjwij_w6.swift:46:21: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n    if index\
    \ == arr.last-1 {\n                    ^\n                (        ?? <#default\
    \ value#>)\n/tmp/tmpsjwij_w6.swift:46:21: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    if index == arr.last-1 {\n\
    \                    ^\n                        !\n/tmp/tmpsjwij_w6.swift:47:33:\
    \ error: cannot convert value of type 'Array<Int>.Index?' (aka 'Optional<Int>')\
    \ to expected element type 'Int'\n        return [smallest_value, index]\n   \
    \                             ^\n/tmp/tmpsjwij_w6.swift:49:38: error: value of\
    \ type '[Int]' has no member 'end'\n        return Array(arr[index..<arr.end]).map\
    \ { (i) -> Int in\n                                 ~~~ ^~~\n/tmp/tmpsjwij_w6.swift:49:26:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n        return\
    \ Array(arr[index..<arr.end]).map { (i) -> Int in\n                         ^\n\
    /tmp/tmpsjwij_w6.swift:49:26: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n        return Array(arr[index..<arr.end]).map\
    \ { (i) -> Int in\n                         ^\n                         (    \
    \ ?? <#default value#>)\n/tmp/tmpsjwij_w6.swift:49:26: note: force-unwrap using\
    \ '!' to abort execution if the opt"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var min_value = Int()\n    var min_index\
    \ = Int()\n    var result = [Int]()\n    for node in arr {\n        if node.isMultiple(2)\
    \ { //even node\n            if min_value.isMultiple(0) { //same value, choose\
    \ the smallest one\n                if node.value < min_value {\n            \
    \        min_value = node.value\n                    min_index = node\n      \
    \          }\n            } else { //different value, choose the smallest index\n\
    \                if node.value < min_value {\n                    min_value =\
    \ node.value\n                    min_index = node\n                }\n      \
    \      }\n        } else { //odd node\n            if min_value.isMultiple(0)\
    \ { //same value, choose the smallest one\n                if node.value > min_value\
    \ {\n                    min_value = node.value\n                    min_index\
    \ = node\n                }\n            } else { //different value, choose the\
    \ smallest index\n                if node.value > min_value {\n              \
    \      min_value = node.value\n                    min_index = node\n        \
    \        }\n            }\n        }\n    }\n    result = [min_value, min_index]\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqs265bwx.swift:32:17: error: no exact matches in call to instance\
    \ method 'isMultiple'\n        if node.isMultiple(2) { //even node\n         \
    \       ^\nSwift.SignedInteger:6:28: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(of:)')\n    @inlinable public func isMultiple(of other:\
    \ Self) -> Bool\n                           ^\nSwift.BinaryInteger:7:28: note:\
    \ incorrect labels for candidate (have: '(_:)', expected: '(of:)')\n    @inlinable\
    \ public func isMultiple(of other: Self) -> Bool\n                           ^\n\
    /tmp/tmpqs265bwx.swift:33:26: error: no exact matches in call to instance method\
    \ 'isMultiple'\n            if min_value.isMultiple(0) { //same value, choose\
    \ the smallest one\n                         ^\nSwift.SignedInteger:6:28: note:\
    \ incorrect labels for candidate (have: '(_:)', expected: '(of:)')\n    @inlinable\
    \ public func isMultiple(of other: Self) -> Bool\n                           ^\n\
    Swift.BinaryInteger:7:28: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(of:)')\n    @inlinable public func isMultiple(of other: Self) ->\
    \ Bool\n                           ^\n/tmp/tmpqs265bwx.swift:34:25: error: value\
    \ of type 'Int' has no member 'value'\n                if node.value < min_value\
    \ {\n                   ~~~~ ^~~~~\n/tmp/tmpqs265bwx.swift:35:38: error: value\
    \ of type 'Int' has no member 'value'\n                    min_value = node.value\n\
    \                                ~~~~ ^~~~~\n/tmp/tmpqs265bwx.swift:39:25: error:\
    \ value of type 'Int' has no member 'value'\n                if node.value < min_value\
    \ {\n                   ~~~~ ^~~~~\n/tmp/tmpqs265bwx.swift:40:38: error: value\
    \ of type 'Int' has no member 'value'\n                    min_value = node.value\n\
    \                                ~~~~ ^~~~~\n/tmp/tmpqs265bwx.swift:45:26: error:\
    \ no exact matches in call to instance method 'isMultiple'\n            if min_value.isMultiple(0)\
    \ { //same value, choose the smallest one\n                         ^\nSwift.SignedInteger:6:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(of:)')\n   \
    \ @in"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpaq_4qk0y/tmpaq_4qk0y.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9794a2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9794725b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9794725988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97947247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaq_4qk0y                        0x00005643f6c213bc <unavailable> + 5052

    5    libc.so.6                          0x00002b9794c1a460 __libc_start_main +
    245

    6    tmpaq_4qk0y                        0x00005643f6c20fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var largestIndex = -1\n    var largestValue\
    \ = -1\n    for i in arr {\n        if i%2 == 0 {\n            if largestValue\
    \ == -1 || i > largestValue {\n                largestValue = i\n            \
    \    largestIndex = i\n            } else {\n                if largestIndex >\
    \ i {\n                    largestIndex = i\n                    largestValue\
    \ = i\n                }\n            }\n        }\n    }\n    if largestIndex\
    \ == -1 {\n        return []\n    }\n    return [largestValue, largestIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpn3nblgla/tmpn3nblgla.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8722c1fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8722916b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8722916988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87229157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn3nblgla                        0x000055ba5a0ff5bc <unavailable> + 5564

    5    libc.so.6                          0x00002b8722e0b460 __libc_start_main +
    245

    6    tmpn3nblgla                        0x000055ba5a0ff1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.sorted().prefix(2)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpwjo5jwyr.swift:28:25: error: no 'prefix' candidates produce the\
    \ expected contextual result type '[Int]'\n    return arr.sorted().prefix(2)\n\
    \                        ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<[Int]>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty { return []}\n    // TODO:\
    \ DP solution\n    let len: Int = arr.count\n    let dp = [Int](repeating: -1,\
    \ count: len+1)\n\n    let result: [Int] = []\n    let smallest: Int = -1\n\n\
    \    for i in 0..<len {\n        dp[i] = -1\n        dp[i+1] = 0\n        if arr[i]\
    \ == 0 {\n            if smallest+1 < 0 || dp[smallest+1] < 0 {\n            \
    \    smallest = 1\n            } else {\n                smallest = dp[smallest+1]\n\
    \            }\n        } else {\n            smallest = 0\n        }\n      \
    \  result.append(arr[i])\n        dp[i] = smallest\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7nt2gdlf.swift:37:11: error: cannot assign through subscript: 'dp'\
    \ is a 'let' constant\n        dp[i] = -1\n        ~~^\n/tmp/tmp7nt2gdlf.swift:31:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let dp = [Int](repeating:\
    \ -1, count: len+1)\n    ^~~\n    var\n/tmp/tmp7nt2gdlf.swift:38:11: error: cannot\
    \ assign through subscript: 'dp' is a 'let' constant\n        dp[i+1] = 0\n  \
    \      ~~^\n/tmp/tmp7nt2gdlf.swift:31:5: note: change 'let' to 'var' to make it\
    \ mutable\n    let dp = [Int](repeating: -1, count: len+1)\n    ^~~\n    var\n\
    /tmp/tmp7nt2gdlf.swift:41:17: error: cannot assign to value: 'smallest' is a 'let'\
    \ constant\n                smallest = 1\n                ^~~~~~~~\n/tmp/tmp7nt2gdlf.swift:34:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest: Int = -1\n\
    \    ^~~\n    var\n/tmp/tmp7nt2gdlf.swift:43:17: error: cannot assign to value:\
    \ 'smallest' is a 'let' constant\n                smallest = dp[smallest+1]\n\
    \                ^~~~~~~~\n/tmp/tmp7nt2gdlf.swift:34:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let smallest: Int = -1\n    ^~~\n    var\n/tmp/tmp7nt2gdlf.swift:46:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = 0\n            ^~~~~~~~\n/tmp/tmp7nt2gdlf.swift:34:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let smallest: Int = -1\n    ^~~\n    var\n/tmp/tmp7nt2gdlf.swift:48:16:\
    \ error: cannot use mutating member on immutable value: 'result' is a 'let' constant\n\
    \        result.append(arr[i])\n        ~~~~~~ ^\n/tmp/tmp7nt2gdlf.swift:33:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result: [Int] = []\n\
    \    ^~~\n    var\n/tmp/tmp7nt2gdlf.swift:49:11: error: cannot assign through\
    \ subscript: 'dp' is a 'let' constant\n        dp[i] = smallest\n        ~~^\n\
    /tmp/tmp7nt2gdlf.swift:31:5: note: change 'let' to 'var' to make it mutable\n\
    \    let dp = [Int](repeating: -1, count: len+1)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() { return [] as [Int] }\n\
    \    var lowIndex = -1\n    var curValue, curIndex :Int = arr[0]\n    var result\
    \ = Array()\n    for idx in 0..<arr.count {\n        curValue = arr[idx]\n   \
    \     if curValue % 2 == 0 && curIndex >= lowIndex {\n            result.append((curValue,\
    \ curIndex))\n        }\n        if curValue % 2 != 0 && curIndex >= lowIndex\
    \ {\n            lowIndex = idx\n            curIndex = idx\n        }\n    }\n\
    \    return result as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpf12_m651.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() { return [] as [Int] }\n           ^     \
    \ ~~\n                  \n/tmp/tmpf12_m651.swift:30:9: error: type annotation\
    \ missing in pattern\n    var curValue, curIndex :Int = arr[0]\n        ^\n/tmp/tmpf12_m651.swift:31:18:\
    \ error: generic parameter 'Element' could not be inferred\n    var result = Array()\n\
    \                 ^\n/tmp/tmpf12_m651.swift:31:18: note: explicitly specify the\
    \ generic arguments to fix this issue\n    var result = Array()\n            \
    \     ^\n                      <Any>\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    // use the same code as in Pluck\
    \ except with min\n    \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpjkucxi4f/tmpjkucxi4f.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab570017c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab56fd0eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab56fd0e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab56fd0d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjkucxi4f                        0x0000559fb766f3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ab570203460 __libc_start_main +
    245

    6    tmpjkucxi4f                        0x0000559fb766efc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return helper(arr, [])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpu9zejrxi.swift:28:12: error: cannot find 'helper' in scope\n  \
    \  return helper(arr, [])\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var min = arr[0]\n    var minIndex = 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] == min {\n           \
    \ minIndex = i\n        } else {\n            if arr[i] < min {\n            \
    \    min = arr[i]\n                minIndex = i\n            }\n        }\n  \
    \  }\n    return arr[:minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplt940rj1.swift:30:12: error: expected type\n    for i := 1; i <\
    \ len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmplt940rj1.swift:30:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmplt940rj1.swift:30:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < len(arr); i++ {\n           ^\n/tmp/tmplt940rj1.swift:40:16:\
    \ error: expected expression in list of expressions\n    return arr[:minIndex]\n\
    \               ^\n/tmp/tmplt940rj1.swift:40:25: error: missing argument for parameter\
    \ #1 in call\n    return arr[:minIndex]\n                        ^\n         \
    \               <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)' declared here\n\
    \    @inlinable public subscript(index: Int) -> Element { get set }\n        \
    \              ^\n/tmp/tmplt940rj1.swift:40:15: error: no 'subscript' candidates\
    \ produce the expected contextual result type '[Int]'\n    return arr[:minIndex]\n\
    \              ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Int', not\
    \ the expected contextual result type '[Int]'\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note:\
    \ 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual result\
    \ type '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:3:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\nSwift.MutableCollection:3:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minValue: Int = 0\n    var minIndex\
    \ = 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 && arr[i] <\
    \ minValue {\n            minValue = arr[i]\n            minIndex = i\n      \
    \  }\n    }\n    return minIndex == 0 ? [] : [minValue, minIndex]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpx0gzefew.swift:30:12: error: expected type\n    for i := 0; i <\
    \ len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmpx0gzefew.swift:30:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmpx0gzefew.swift:30:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(arr); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr == nil {\n        return []\n  \
    \  }\n    var even: Int = 0\n    var index = 0\n    for element in arr {\n   \
    \     if element % 2 == 0 {\n            if even == element {\n              \
    \  return [element, index]\n            } else {\n                even = element\n\
    \                index = index + 1\n            }\n        }\n    }\n    return\
    \ [even, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp79avy9e_/tmp79avy9e_.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adaf6ae3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adaf67dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adaf67da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adaf67d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp79avy9e_                        0x00005627f0be95bc <unavailable> + 5564

    5    libc.so.6                          0x00002adaf6ccf460 __libc_start_main +
    245

    6    tmp79avy9e_                        0x00005627f0be91c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var even = [Int]()\n    var indices = [Int]()\n\
    \    arr.forEach {\n        if $0 % 2 == 0 {\n            even.append($0)\n  \
    \          indices.append($0)\n        }\n    }\n    return even.sorted().firstIndex(of:\
    \ min(even), offsetBy: indices.sorted().last)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7rv_exci.swift:36:79: error: extra argument 'offsetBy' in call\n\
    \    return even.sorted().firstIndex(of: min(even), offsetBy: indices.sorted().last)\n\
    \                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmp7rv_exci.swift:36:26: error: cannot convert return expression of type\
    \ 'Array<Int>.Index?' (aka 'Optional<Int>') to return type '[Int]'\n    return\
    \ even.sorted().firstIndex(of: min(even), offsetBy: indices.sorted().last)\n \
    \          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7rv_exci.swift:36:49: error: missing argument for parameter #2 in call\n\
    \    return even.sorted().firstIndex(of: min(even), offsetBy: indices.sorted().last)\n\
    \                                                ^\n                         \
    \                       , <#Int#>\nSwift.min:1:24: note: 'min' declared here\n\
    @inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp7rv_exci.swift:36:45: error: cannot convert value\
    \ of type '[Int]' to expected argument type 'Int'\n    return even.sorted().firstIndex(of:\
    \ min(even), offsetBy: indices.sorted().last)\n                              \
    \              ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minVal = IntMax\n    var minPos = IntMax\n\
    \    for idx, val in enumerate(arr) {\n        if val < minVal {\n           \
    \ minVal = val\n            minPos = idx\n        }\n    }\n    return [minVal,\
    \ minPos]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmphdc84ltq.swift:30:12: error: expected 'in' after for-each pattern\n\
    \    for idx, val in enumerate(arr) {\n           ^\n/tmp/tmphdc84ltq.swift:30:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, val in enumerate(arr)\
    \ {\n           ^\n/tmp/tmphdc84ltq.swift:28:18: error: cannot find 'IntMax' in\
    \ scope\n    var minVal = IntMax\n                 ^~~~~~\n/tmp/tmphdc84ltq.swift:29:18:\
    \ error: cannot find 'IntMax' in scope\n    var minPos = IntMax\n            \
    \     ^~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if isEmpty(arr) {\n        return []\n\
    \    }\n    if arr[0] != 0 { //If there is no even number in the array return\
    \ the first node\n        return [arr[0], 0]\n    }\n    var minVal = arr[0]\n\
    \    var minIndex = 0\n    \n    for index in 1..<arr.count{\n        if arr[index]\
    \ >= minVal {\n            minVal = arr[index]\n            minIndex = index\n\
    \        }\n    }\n    return minIndex == 0 ? minVal : [minVal, minIndex]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkf4jhh73.swift:28:8: error: cannot find 'isEmpty' in scope\n  \
    \  if isEmpty(arr) {\n       ^~~~~~~\n/tmp/tmpkf4jhh73.swift:43:26: error: cannot\
    \ convert return expression of type 'Int' to return type '[Int]'\n    return minIndex\
    \ == 0 ? minVal : [minVal, minIndex]\n           ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.sort { $0 > $1 }.map { $0 }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzei38mn9.swift:28:16: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    return arr.sort { $0 > $1 }.map { $0 }\n\
    \           ~~~ ^\n/tmp/tmpzei38mn9.swift:28:33: error: value of tuple type '()'\
    \ has no member 'map'\n    return arr.sort { $0 > $1 }.map { $0 }\n          \
    \ ~~~~~~~~~~~~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    guard arr.count > 0 else {\n    \
    \    return []\n    }\n    \n    // init smallest_even_index\n    var smallest_even_index:\
    \ Int = 0\n    \n    // init smallest_even_value, smallest_even_index\n    var\
    \ smallest_even_value: Int = 0\n    \n    // init result array\n    var result:\
    \ [Int] = []\n    \n    // check all even values and find the smallest one\n \
    \   for i in 0..<arr.count {\n        if arr[i] % 2 == 0 {\n            // if\
    \ the current value is smaller than the smallest even value, then store the current\
    \ index\n            if arr[i] < smallest_even_value {\n                smallest_even_index\
    \ = i\n                smallest_even_value = arr[i]\n            }\n        }\n\
    \    }\n    \n    // if we have the smallest even value, then we can pluck this\
    \ one and add the index\n    if smallest_even_value > 0 {\n        result.insert(smallest_even_value,\
    \ smallest_even_index)\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbkw8oazv.swift:55:16: error: no exact matches in call to instance\
    \ method 'insert'\n        result.insert(smallest_even_value, smallest_even_index)\n\
    \               ^\nSwift.Array:11:37: note: incorrect labels for candidate (have:\
    \ '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect labels for candidate\
    \ (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Self.Element, at i: Self.Index)\n                      \
    \              ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var smallestIndex\
    \ = -1\n    for idx in arr {\n        if idx%2 != 0 {\n            continue\n\
    \        }\n        if smallestIndex == -1 || idx<smallestIndex {\n          \
    \  smallestIndex = idx\n        }\n    }\n    if smallestIndex != -1 {\n     \
    \   result.insert(smallestIndex, idx)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpp1n6x7br.swift:39:38: error: cannot find 'idx' in scope\n     \
    \   result.insert(smallestIndex, idx)\n                                     ^~~\n\
    /tmp/tmpp1n6x7br.swift:39:16: error: no exact matches in call to instance method\
    \ 'insert'\n        result.insert(smallestIndex, idx)\n               ^\n/tmp/tmpp1n6x7br.swift:39:16:\
    \ note: found candidate with type '(__owned Int, Int) -> ()'\n        result.insert(smallestIndex,\
    \ idx)\n               ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var even = [Int]()\n    var index = Int()\n\
    \    for node in arr {\n        if node % 2 == 0 {\n            even.append(node)\n\
    \        } else {\n            if even.count > 0 && even[even.count - 1] < node\
    \ {\n                even = even[even.count - 1]\n                index = node\
    \ - 1\n            } else {\n                index = index\n            }\n  \
    \      }\n    }\n    return even as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpfpj9tr4u.swift:35:28: error: cannot assign value of type 'Int'\
    \ to type '[Int]'\n                even = even[even.count - 1]\n             \
    \          ~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpfpj9tr4u.swift:38:23: error: assigning\
    \ a variable to itself\n                index = index\n                ~~~~~ ^\
    \ ~~~~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var len = arr.count\n    var smalest_even_value\
    \ = arr[0]\n    var smalest_index = 0\n    var result = [Int]()\n    for i in\
    \ 1...len {\n        var even_value: Int\n        if arr[i-1]%2 == 0 {\n     \
    \       even_value = arr[i-1]\n        } else {\n            if even_value < smalest_even_value\
    \ {\n                smalest_even_value = arr[i-1]\n                smalest_index\
    \ = i\n            }\n        }\n        result.append(smalest_index)\n    }\n\
    \    if len == 0 || smalest_even_value != arr[0] {\n        return result\n  \
    \  } else {\n        return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb0axo8as.swift:28:9: warning: variable 'len' was never mutated;\
    \ consider changing to 'let' constant\n    var len = arr.count\n    ~~~ ^\n  \
    \  let\n/tmp/tmpb0axo8as.swift:37:16: error: variable 'even_value' used before\
    \ being initialized\n            if even_value < smalest_even_value {\n      \
    \         ^\n/tmp/tmpb0axo8as.swift:33:13: note: variable defined here\n     \
    \   var even_value: Int\n            ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var largest: Int = 0\n    var largestIndex:\
    \ Int = 0\n    var i: Int\n    for i = 0, i < arr.count(), i++ {\n        if arr[i]\
    \ % 2 == 0 {\n            if arr[i] > largest {\n                largest = arr[i]\n\
    \                largestIndex = i\n            }\n        }\n    }\n    return\
    \ [largest, largestIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprtls8sh3.swift:31:11: error: expected 'in' after for-each pattern\n\
    \    for i = 0, i < arr.count(), i++ {\n          ^\n/tmp/tmprtls8sh3.swift:31:11:\
    \ error: expected Sequence expression for for-each loop\n    for i = 0, i < arr.count(),\
    \ i++ {\n          ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n  return arr.reduce((a, b) => (a.value & b.value)\
    \ == b.value ? a : b)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_v2w6ool.swift:28:22: error: cannot find 'a' in scope\n  return\
    \ arr.reduce((a, b) => (a.value & b.value) == b.value ? a : b)\n             \
    \        ^\n/tmp/tmp_v2w6ool.swift:28:25: error: cannot find 'b' in scope\n  return\
    \ arr.reduce((a, b) => (a.value & b.value) == b.value ? a : b)\n             \
    \           ^\n/tmp/tmp_v2w6ool.swift:28:28: error: cannot find operator '=>'\
    \ in scope\n  return arr.reduce((a, b) => (a.value & b.value) == b.value ? a :\
    \ b)\n                           ^~\n/tmp/tmp_v2w6ool.swift:28:32: error: cannot\
    \ find 'a' in scope\n  return arr.reduce((a, b) => (a.value & b.value) == b.value\
    \ ? a : b)\n                               ^\n/tmp/tmp_v2w6ool.swift:28:42: error:\
    \ cannot find 'b' in scope\n  return arr.reduce((a, b) => (a.value & b.value)\
    \ == b.value ? a : b)\n                                         ^\n/tmp/tmp_v2w6ool.swift:28:54:\
    \ error: cannot find 'b' in scope\n  return arr.reduce((a, b) => (a.value & b.value)\
    \ == b.value ? a : b)\n                                                     ^\n\
    /tmp/tmp_v2w6ool.swift:28:64: error: cannot find 'a' in scope\n  return arr.reduce((a,\
    \ b) => (a.value & b.value) == b.value ? a : b)\n                            \
    \                                   ^\n/tmp/tmp_v2w6ool.swift:28:68: error: cannot\
    \ find 'b' in scope\n  return arr.reduce((a, b) => (a.value & b.value) == b.value\
    \ ? a : b)\n                                                                 \
    \  ^\n/tmp/tmp_v2w6ool.swift:28:69: error: missing argument for parameter #2 in\
    \ call\n  return arr.reduce((a, b) => (a.value & b.value) == b.value ? a : b)\n\
    \                                                                    ^\n     \
    \                                                               , <#([Int], Int)\
    \ throws -> [Int]#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n    @inlinable\
    \ public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_\
    \ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    \n    let maxValue = arr[0]\n    var index = arr.startIndex\n    for\
    \ i in 1..<arr.count {\n        if arr[i] < maxValue {\n            index = i\n\
    \            maxValue = arr[i]\n        }\n    }\n    \n    return [maxValue,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpmnxwi0hd.swift:37:13: error: cannot assign to value: 'maxValue'\
    \ is a 'let' constant\n            maxValue = arr[i]\n            ^~~~~~~~\n/tmp/tmpmnxwi0hd.swift:32:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxValue = arr[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let map = [Int: Int]()\n    for node in\
    \ arr {\n        if map[node] == nil {\n            map[node] = node\n       \
    \ } else if map[node] < node {\n            map[node] = node\n        }\n    }\n\
    \    return arr\n        .filter { map[$0] != nil }\n        .sort { $0 < $1 }\n\
    \        .map { $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph4aw86av.swift:31:16: error: cannot assign through subscript: 'map'\
    \ is a 'let' constant\n            map[node] = node\n            ~~~^\n/tmp/tmph4aw86av.swift:28:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let map = [Int: Int]()\n\
    \    ^~~\n    var\n/tmp/tmph4aw86av.swift:32:22: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n        } else if map[node]\
    \ < node {\n                     ^\n/tmp/tmph4aw86av.swift:32:22: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     } else if map[node] < node {\n                     ^\n                 \
    \           ?? <#default value#>\n/tmp/tmph4aw86av.swift:32:22: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        }\
    \ else if map[node] < node {\n                     ^\n                       \
    \    !\n/tmp/tmph4aw86av.swift:33:16: error: cannot assign through subscript:\
    \ 'map' is a 'let' constant\n            map[node] = node\n            ~~~^\n\
    /tmp/tmph4aw86av.swift:28:5: note: change 'let' to 'var' to make it mutable\n\
    \    let map = [Int: Int]()\n    ^~~\n    var\n/tmp/tmph4aw86av.swift:39:10: error:\
    \ value of tuple type '()' has no member 'map'\n        .map { $0 }\n        \
    \ ^~~\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n\tvar minIndex = -1\n\tvar minValue = Int64(math.MaxInt64)\n\
    \tfor idx, val := range arr {\n\t\tif val %2 == 0 {\n\t\t\tif minIndex < 0 ||\
    \ val < minValue {\n\t\t\t\tminValue = val\n\t\t\t\tminIndex = idx\n\t\t\t}\n\t\
    \t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif minIndex >= 0 {\n\t\treturn arr[minIndex:minIndex+1]\n\
    \t}\n\treturn []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmphjwyvy1y.swift:30:9: error: expected 'in' after for-each pattern\n\
    \        for idx, val := range arr {\n               ^\n/tmp/tmphjwyvy1y.swift:30:9:\
    \ error: expected Sequence expression for for-each loop\n        for idx, val\
    \ := range arr {\n               ^\n/tmp/tmphjwyvy1y.swift:31:10: error: expected\
    \ '{' after 'if' condition\n                if val %2 == 0 {\n               \
    \        ^\n/tmp/tmphjwyvy1y.swift:29:23: error: cannot find 'math' in scope\n\
    \        var minValue = Int64(math.MaxInt64)\n                             ^~~~\n\
    /tmp/tmphjwyvy1y.swift:42:13: error: extraneous argument label 'minIndex:' in\
    \ subscript\n                return arr[minIndex:minIndex+1]\n               \
    \           ^~~~~~~~~~\n                           \n/tmp/tmphjwyvy1y.swift:42:13:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \                return arr[minIndex:minIndex+1]\n                       ~~~^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n\tret := make([Int], 0)\n\tvar i int = 0\n\t\
    for arr[i] != 0 && i < len(arr) {\n\t\tret[i] = arr[i]\n\t\ti += 1\n\t}\n\tif\
    \ i == 0 {\n\t\treturn ret as [Int]\n\t}\n\tm := make([Int], i)\n\tm[0] = arr[i]\n\
    \tfor ii := 0; ii < len(arr); ii++ {\n\t\tif arr[ii] % 2 == 0 {\n\t\t\tm[ii] =\
    \ arr[ii]\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tret := make([Int], i)\n\t\
    for ii := 0; ii < i; ii++ {\n\t\tret[ii] = m[ii]\n\t}\n\treturn ret\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1zh7ox_j.swift:28:5: error: consecutive statements on a line must\
    \ be separated by ';'\n        ret := make([Int], 0)\n           ^\n         \
    \  ;\n/tmp/tmp1zh7ox_j.swift:28:6: error: expected expression\n        ret :=\
    \ make([Int], 0)\n            ^\n/tmp/tmp1zh7ox_j.swift:29:8: error: found an\
    \ unexpected second identifier in variable declaration; is there an accidental\
    \ break?\n        var i int = 0\n              ^\n/tmp/tmp1zh7ox_j.swift:29:8:\
    \ note: join the identifiers together\n        var i int = 0\n            ~~^~~\n\
    \            iint\n/tmp/tmp1zh7ox_j.swift:29:8: note: join the identifiers together\
    \ with camel-case\n        var i int = 0\n            ~~^~~\n            iInt\n\
    /tmp/tmp1zh7ox_j.swift:30:9: error: expected 'in' after for-each pattern\n   \
    \     for arr[i] != 0 && i < len(arr) {\n               ^\n/tmp/tmp1zh7ox_j.swift:37:3:\
    \ error: consecutive statements on a line must be separated by ';'\n        m\
    \ := make([Int], i)\n         ^\n         ;\n/tmp/tmp1zh7ox_j.swift:37:4: error:\
    \ expected expression\n        m := make([Int], i)\n          ^\n/tmp/tmp1zh7ox_j.swift:39:10:\
    \ error: expected type\n        for ii := 0; ii < len(arr); ii++ {\n         \
    \       ^\n                 <#type#>\n/tmp/tmp1zh7ox_j.swift:39:10: error: expected\
    \ 'in' after for-each pattern\n        for ii := 0; ii < len(arr); ii++ {\n  \
    \              ^\n/tmp/tmp1zh7ox_j.swift:39:10: error: expected Sequence expression\
    \ for for-each loop\n        for ii := 0; ii < len(arr); ii++ {\n            \
    \    ^\n/tmp/tmp1zh7ox_j.swift:47:10: error: expected type\n        for ii :=\
    \ 0; ii < i; ii++ {\n                ^\n                 <#type#>\n/tmp/tmp1zh7ox_j.swift:47:10:\
    \ error: expected 'in' after for-each pattern\n        for ii := 0; ii < i; ii++\
    \ {\n                ^\n/tmp/tmp1zh7ox_j.swift:47:10: error: expected Sequence\
    \ expression for for-each loop\n        for ii := 0; ii < i; ii++ {\n        \
    \        ^\n/tmp/tmp1zh7ox_j.swift:28:2: error: cannot find 'ret' in scope\n \
    \       ret := make([Int], 0)\n        ^~~\n/tmp/tmp1zh7ox_j.swift:30:25: error:\
    \ cannot find 'len' in scope\n        for arr"
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    return arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpnh_k3iu6/tmpnh_k3iu6.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bf1bc3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bf18bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bf18ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bf18b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnh_k3iu6                        0x00005595f907b3bc <unavailable> + 5052

    5    libc.so.6                          0x00002b3bf1daf460 __libc_start_main +
    245

    6    tmpnh_k3iu6                        0x00005595f907afc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    var min: Int = 0\n    var minIndex: Int = 0\n    var result: [Int]\
    \ = []\n    var i: Int = 0\n    for node in arr {\n        if ((node % 2) == 0)\
    \ {\n            if (min > node) {\n                min = node\n             \
    \   minIndex = i\n            }\n            i += 1\n        }\n    }\n    if\
    \ min == 0 {\n        return result\n    }\n    result.insert(minIndex, min)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpa_gcd0se.swift:47:12: error: no exact matches in call to instance\
    \ method 'insert'\n    result.insert(minIndex, min)\n           ^\nSwift.Array:11:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Element, at\
    \ i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n"
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let minValue = Int64(0)\n    var result\
    \ = [Int]()\n    for (index, element) in arr.enumerated() {\n        if element\
    \ == minValue {\n            result.append(index)\n        }\n    }\n    if result.isEmpty\
    \ {\n        return result\n    } else {\n        return result[0]\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp2j0bp7t0.swift:38:22: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n        return result[0]\n              \
    \ ~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return min(arr, func(i, _ int) int {\n\
    \        return arr[i] / 2\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp38mu_2ts.swift:28:21: error: expected expression in list of expressions\n\
    \    return min(arr, func(i, _ int) int {\n                    ^\n/tmp/tmp38mu_2ts.swift:28:25:\
    \ error: expected identifier in function declaration\n    return min(arr, func(i,\
    \ _ int) int {\n                        ^\n/tmp/tmp38mu_2ts.swift:28:19: error:\
    \ missing argument for parameter #2 in call\n    return min(arr, func(i, _ int)\
    \ int {\n                  ^\n                  , <#[Int]#>\nSwift.min:1:24: note:\
    \ 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmp38mu_2ts.swift:28:12: error:\
    \ global function 'min' requires that '[Int]' conform to 'Comparable'\n    return\
    \ min(arr, func(i, _ int) int {\n           ^\nSwift.min:1:24: note: where 'T'\
    \ = '[Int]'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.isEmpty || arr.count >= 1000000000\
    \ else {\n        return []\n    }\n    var sum: Int = 0\n    var minIndex: Int\
    \ = 0\n    for idx in 0..<arr.count {\n        if arr[idx] % 2 == 0 {\n      \
    \      sum += arr[idx]\n            minIndex = idx\n        }\n    }\n    if sum\
    \ % 2 == 0 {\n        return [sum, minIndex]\n    }\n    return []\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpxzxqy2gi/tmpxzxqy2gi.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aacec79bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aacec492b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aacec492988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aacec4917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxzxqy2gi                        0x000055bc403c168c <unavailable> + 5772

    5    libc.so.6                          0x00002aacec987460 __libc_start_main +
    245

    6    tmpxzxqy2gi                        0x000055bc403c1299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var minIndex = 0\n    var minValue\
    \ = arr[0]\n    \n    for index in 1..arr.count {\n        if arr[index] % 2 ==\
    \ 0 {\n            minValue = arr[index]\n            minIndex = index\n     \
    \   }\n    }\n    \n    return [minValue, minIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw7mv0npo.swift:32:19: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for index in 1..arr.count {\n                  ^~\n\
    \                  ...\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result: [Int] = []\n    var largestEvenIndex\
    \ = 0\n    arr.forEach { item in\n        if item % 2 == 0 {\n            result.append(item)\n\
    \            if item > result[largestEvenIndex] {\n                largestEvenIndex\
    \ = result.count\n            }\n        }\n    }\n    if result.count == 0 {\n\
    \        return result\n    }\n    var largestEvenValue = result[0]\n    var largestEvenIndex\
    \ = 0\n    for index = 0; index < result.count; index++ {\n        if result[index]\
    \ > largestEvenValue {\n            largestEvenValue = result[index]\n       \
    \     largestEvenIndex = index\n        }\n    }\n    return [largestEvenValue,\
    \ largestEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpm83j2un8.swift:43:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for index = 0; index < result.count; index++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm83j2un8.swift:42:9: error: invalid redeclaration of 'largestEvenIndex'\n\
    \    var largestEvenIndex = 0\n        ^\n/tmp/tmpm83j2un8.swift:29:9: note: 'largestEvenIndex'\
    \ previously declared here\n    var largestEvenIndex = 0\n        ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var res = IntArray()\n    var cur = IntArray()\n\
    \    var min = IntArray()\n    var curVal = 0\n    for i in arr {\n        curVal\
    \ += i\n        if curVal % 2 == 0 {\n            cur.push(i)\n            min.push(i)\n\
    \        } else {\n            cur.shift()\n            min.shift()\n        }\n\
    \    }\n    for val in min {\n        res.insert(val, 0)\n    }\n    return res\
    \ as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp27e3fkvz.swift:28:15: error: cannot find 'IntArray' in scope\n\
    \    var res = IntArray()\n              ^~~~~~~~\n/tmp/tmp27e3fkvz.swift:29:15:\
    \ error: cannot find 'IntArray' in scope\n    var cur = IntArray()\n         \
    \     ^~~~~~~~\n/tmp/tmp27e3fkvz.swift:30:15: error: cannot find 'IntArray' in\
    \ scope\n    var min = IntArray()\n              ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result: [Int] = []\n    if arr.isEmpty()\
    \ {\n        return result\n    }\n    var min: Int = arr[0]\n    var minIndex\
    \ = 0\n    for i in arr {\n        if i % 2 == 0 {\n            min = i\n    \
    \        minIndex = i\n        }\n    }\n    var i = 0\n    for j in arr {\n \
    \       if j == min {\n            result.append(j)\n            i += 1\n    \
    \    }\n    }\n    if i == arr.count {\n        return result\n    }\n    return\
    \ result[minIndex : minIndex + i]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8m45f8ak.swift:29:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp8m45f8ak.swift:50:18: error: extraneous argument label 'minIndex:'\
    \ in subscript\n    return result[minIndex : minIndex + i]\n                 ^~~~~~~~~~~~\n\
    \                  \n/tmp/tmp8m45f8ak.swift:50:18: error: cannot convert return\
    \ expression of type 'Int' to return type '[Int]'\n    return result[minIndex\
    \ : minIndex + i]\n           ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minValue\
    \ = arr[0]\n    var minIndex = 0\n    var index: Int\n    for i in arr {\n   \
    \     if minValue == i {\n            minIndex = index\n        } else {\n   \
    \         if minValue < i {\n                minValue = i\n                minIndex\
    \ = index\n            }\n        }\n        index += 1\n    }\n    result.append(minValue)\n\
    \    result.append(minIndex)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4erqa788.swift:34:22: error: variable 'index' used before being\
    \ initialized\n            minIndex = index\n                     ^\n/tmp/tmp4erqa788.swift:31:9:\
    \ note: variable defined here\n    var index: Int\n        ^\n/tmp/tmp4erqa788.swift:38:26:\
    \ error: variable 'index' used before being initialized\n                minIndex\
    \ = index\n                         ^\n/tmp/tmp4erqa788.swift:31:9: note: variable\
    \ defined here\n    var index: Int\n        ^\n/tmp/tmp4erqa788.swift:41:15: error:\
    \ variable 'index' passed by reference before being initialized\n        index\
    \ += 1\n              ^\n/tmp/tmp4erqa788.swift:31:9: note: variable defined here\n\
    \    var index: Int\n        ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n\tresult = Ints(Ints(Ints(arr)))\n\treturn\
    \ arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpcriit8yk.swift:28:2: error: cannot find 'result' in scope\n   \
    \     result = Ints(Ints(Ints(arr)))\n        ^~~~~~\n/tmp/tmpcriit8yk.swift:28:11:\
    \ error: cannot find 'Ints' in scope\n        result = Ints(Ints(Ints(arr)))\n\
    \                 ^~~~\n/tmp/tmpcriit8yk.swift:28:16: error: cannot find 'Ints'\
    \ in scope\n        result = Ints(Ints(Ints(arr)))\n                      ^~~~\n\
    /tmp/tmpcriit8yk.swift:28:21: error: cannot find 'Ints' in scope\n        result\
    \ = Ints(Ints(Ints(arr)))\n                           ^~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var index = 0\n    var smalest_value =\
    \ 0\n    for _ in arr {\n        if smalest_value == 0 {\n            smalest_value\
    \ = arr[index]\n            index = index + 1\n        } else {\n            smalest_value\
    \ = smalest_value + arr[index]\n        }\n        index = index + 1\n    }\n\
    \    var result = [Int]()\n    if arr.isEmpty {\n        return result\n    }\n\
    \    if smalest_value % 2 == 0 {\n        result.append(smalest_value)\n     \
    \   result.append(index)\n        return result\n    }\n    for index in 0 ..<\
    \ arr.count {\n        smalest_value = smalest_value + arr[index]\n        if\
    \ smalest_value % 2 == 0 {\n            result.append(smalest_value)\n       \
    \     result.append(index)\n            return result\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5e00f18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5e00c0f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5e00c0f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5e00c0f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5e00c0ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5e00a0ee83 <unavailable> + 188035

    6    tmpuf2wrpyn                        0x00005632f5ed129b <unavailable> + 8859

    7    tmpuf2wrpyn                        0x00005632f5ed0784 <unavailable> + 6020

    8    libc.so.6                          0x00002b5e01104460 __libc_start_main +
    245

    9    tmpuf2wrpyn                        0x00005632f5ed0469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    \n    let smallest = arr.min()\n\
    \    \n    if smallest % 2 == 0 {\n        return arr\n    } else {\n        let\
    \ index = arr.index(of: smallest % 2)\n        return [smallest, index]\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzukqmekv.swift:32:8: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    if smallest % 2 == 0 {\n       ^\n\
    /tmp/tmpzukqmekv.swift:32:8: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    if smallest % 2 == 0 {\n       ^\n  \
    \     (        ?? <#default value#>)\n/tmp/tmpzukqmekv.swift:32:8: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    if smallest\
    \ % 2 == 0 {\n       ^\n               !\n/tmp/tmpzukqmekv.swift:35:35: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \       let index = arr.index(of: smallest % 2)\n                            \
    \      ^\n/tmp/tmpzukqmekv.swift:35:35: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n        let index = arr.index(of:\
    \ smallest % 2)\n                                  ^\n                       \
    \           (        ?? <#default value#>)\n/tmp/tmpzukqmekv.swift:35:35: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        let index = arr.index(of: smallest % 2)\n                           \
    \       ^\n                                          !\n/tmp/tmpzukqmekv.swift:36:17:\
    \ error: cannot convert value of type 'Int?' to expected element type 'Int'\n\
    \        return [smallest, index]\n                ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n  return pluckImpl(arr, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpabaplm1o.swift:28:10: error: cannot find 'pluckImpl' in scope\n\
    \  return pluckImpl(arr, 0)\n         ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let n = arr.count\n    guard n >= 1 else\
    \ {\n        return []\n    }\n    var maxIndex = 0\n    var maxValue = 0\n  \
    \  for i in 0..<n {\n        if arr[i] == 0 {\n            continue\n        }\n\
    \        if maxValue < arr[i] {\n            maxValue = arr[i]\n            maxIndex\
    \ = i\n        }\n    }\n    if maxIndex < n / 2 {\n        maxIndex = n\n   \
    \ }\n    return [maxValue, maxIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpbmwuci9k/tmpbmwuci9k.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad29102ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad290d25b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad290d25988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad290d247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbmwuci9k                        0x00005570a00315ec <unavailable> + 5612

    5    libc.so.6                          0x00002ad29121a460 __libc_start_main +
    245

    6    tmpbmwuci9k                        0x00005570a00311f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return pick(arr, func(i Int) bool {\n \
    \       i &^ (1 << uint(i))\n        return i == 0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_kzl2kyj.swift:28:22: error: expected expression in list of expressions\n\
    \    return pick(arr, func(i Int) bool {\n                     ^\n/tmp/tmp_kzl2kyj.swift:28:26:\
    \ error: expected identifier in function declaration\n    return pick(arr, func(i\
    \ Int) bool {\n                         ^\n/tmp/tmp_kzl2kyj.swift:28:12: error:\
    \ cannot find 'pick' in scope\n    return pick(arr, func(i Int) bool {\n     \
    \      ^~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n\tsort.Slice(arr, 1, func(i, j int) bool {\n\
    \t\treturn arr[i-1]%2 == arr[j-1]%2\n\t})\n\treturn arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp04q3fmz7.swift:28:21: error: expected expression in list of expressions\n\
    \        sort.Slice(arr, 1, func(i, j int) bool {\n                          \
    \ ^\n/tmp/tmp04q3fmz7.swift:28:25: error: expected identifier in function declaration\n\
    \        sort.Slice(arr, 1, func(i, j int) bool {\n                          \
    \     ^\n/tmp/tmp04q3fmz7.swift:28:2: error: cannot find 'sort' in scope\n   \
    \     sort.Slice(arr, 1, func(i, j int) bool {\n        ^~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result: [Int] = []\n    var largest\
    \ = 0\n    var smallest = -1\n    \n    arr.forEach{ i in\n        if i % 2 ==\
    \ 0 {\n            largest = i\n        } else {\n            if smallest == -1\
    \ || i < smallest {\n                smallest = i\n            }\n        }\n\
    \    }\n    \n    if smallest != -1 {\n        result = [smallest, smallest]\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpru4fy7gu/tmpru4fy7gu.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b946edbac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b946eab1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b946eab1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b946eab07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpru4fy7gu                        0x00005605465024bc <unavailable> + 5308

    5    libc.so.6                          0x00002b946efa6460 __libc_start_main +
    245

    6    tmpru4fy7gu                        0x00005605465020c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if isEmpty(arr) { return [] as [Int] }\n\
    \    let min = minElement(arr)\n    var index = 0\n    for n in arr {\n      \
    \  if n % 2 == 0 {\n            if n < min {\n                min = n\n      \
    \          index = index + 1\n            }\n        }\n    }\n    return [min,\
    \ index] as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpfl0q88uk.swift:28:8: error: cannot find 'isEmpty' in scope\n  \
    \  if isEmpty(arr) { return [] as [Int] }\n       ^~~~~~~\n/tmp/tmpfl0q88uk.swift:29:15:\
    \ error: cannot find 'minElement' in scope\n    let min = minElement(arr)\n  \
    \            ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // write your code here\n    \n    return\
    \ arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: Exception
  stderr: 'tmp_ru78bws/tmp_ru78bws.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70ad8d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70ad5c8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70ad5c8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70ad5c77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ru78bws                        0x00005654e96613bc <unavailable> + 5052

    5    libc.so.6                          0x00002b70adabd460 __libc_start_main +
    245

    6    tmp_ru78bws                        0x00005654e9660fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let (evens, smallerIndexes) = arr.partition\
    \ { $0 % 2 == 0 }\n    return evens.first == 0 ? smallerIndexes : [evens.first,\
    \ smallerIndexes.first!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8h2go44c.swift:28:39: error: no exact matches in call to instance\
    \ method 'partition'\n    let (evens, smallerIndexes) = arr.partition { $0 % 2\
    \ == 0 }\n                                      ^\n/tmp/tmp8h2go44c.swift:28:39:\
    \ note: found candidate with type '((Int) throws -> Bool) throws -> Array<Int>.Index'\
    \ (aka '((Int) throws -> Bool) throws -> Int')\n    let (evens, smallerIndexes)\
    \ = arr.partition { $0 % 2 == 0 }\n                                      ^\n/tmp/tmp8h2go44c.swift:28:39:\
    \ error: cannot convert value of type 'Array<Int>.Index' (aka 'Int') to specified\
    \ type '(_, _)'\n    let (evens, smallerIndexes) = arr.partition { $0 % 2 == 0\
    \ }\n                                  ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    return arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpnh_k3iu6/tmpnh_k3iu6.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bf1bc3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bf18bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bf18ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bf18b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnh_k3iu6                        0x00005595f907b3bc <unavailable> + 5052

    5    libc.so.6                          0x00002b3bf1daf460 __libc_start_main +
    245

    6    tmpnh_k3iu6                        0x00005595f907afc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    fatalError(\"unimplemented\")\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpj8e1nzjz/tmpj8e1nzjz.swift:28: Fatal error: unimplemented

    Current stack trace:

    0    libswiftCore.so                    0x00002abfc82ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfc7ff6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfc7ff6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfc7ff57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj8e1nzjz                        0x0000557439fa8d7c <unavailable> + 7548

    5    tmpj8e1nzjz                        0x0000557439fa8374 <unavailable> + 4980

    6    libc.so.6                          0x00002abfc84eb460 __libc_start_main +
    245

    7    tmpj8e1nzjz                        0x0000557439fa8059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // @TODO:\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp9s505tyf/tmp9s505tyf.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b640c4e2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b640c1d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b640c1d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b640c1d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9s505tyf                        0x00005630acd6b3bc <unavailable> + 5052

    5    libc.so.6                          0x00002b640c6ce460 __libc_start_main +
    245

    6    tmp9s505tyf                        0x00005630acd6afc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let sorted = arr.sorted()\n    \n    guard\
    \ arr.count > 0 else {\n        return []\n    }\n\n    var results = [Int]()\n\
    \    var i = 0\n    while i < arr.count {\n        let v = sorted[i]\n       \
    \ let k = i\n        while k >= 0 && sorted[k] % 2 == 0 {\n            k -= 1\n\
    \        }\n        results.append((v % 2 == 0)? v: sorted[k])\n        i += k\
    \ + 1\n    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_4634mdc.swift:42:38: error: expected ',' separator\n        results.append((v\
    \ % 2 == 0)? v: sorted[k])\n                                     ^\n         \
    \                           ,\n/tmp/tmp_4634mdc.swift:40:15: error: left side\
    \ of mutating operator isn't mutable: 'k' is a 'let' constant\n            k -=\
    \ 1\n            ~ ^\n/tmp/tmp_4634mdc.swift:38:9: note: change 'let' to 'var'\
    \ to make it mutable\n        let k = i\n        ^~~\n        var\n/tmp/tmp_4634mdc.swift:42:9:\
    \ error: instance method 'append(contentsOf:)' requires that 'Bool?' conform to\
    \ 'Sequence'\n        results.append((v % 2 == 0)? v: sorted[k])\n        ^\n\
    Swift.Array:7:37: note: where 'S' = 'Bool?'\n    @inlinable public mutating func\
    \ append<S>(contentsOf newElements: __owned S) where Element == S.Element, S :\
    \ Sequence\n                                    ^\n/tmp/tmp_4634mdc.swift:42:47:\
    \ error: extra argument 'v' in call\n        results.append((v % 2 == 0)? v: sorted[k])\n\
    \                      ~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmp_4634mdc.swift:42:36:\
    \ error: cannot use optional chaining on non-optional value of type 'Bool'\n \
    \       results.append((v % 2 == 0)? v: sorted[k])\n                       ~~~~~~~~~~~~^\n\
    \                                   \n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return pick(arr, pickFirstOddIndex)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6cj_i9vt.swift:28:12: error: cannot find 'pick' in scope\n    return\
    \ pick(arr, pickFirstOddIndex)\n           ^~~~\n/tmp/tmp6cj_i9vt.swift:28:22:\
    \ error: cannot find 'pickFirstOddIndex' in scope\n    return pick(arr, pickFirstOddIndex)\n\
    \                     ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallest_value : Int = 0\n    var smallest_index\
    \ : Int = 0\n    var result: [Int] = []\n    for element in arr {\n        if\
    \ element > 0 {\n            if element < smallest_value {\n                smallest_value\
    \ = element\n                smallest_index = result\n            }\n        }\
    \ else if element == 0 {\n            smallest_value = 0\n            smallest_index\
    \ = 0\n        }\n        result.append(element)\n    }\n    if smallest_index\
    \ == 0 {\n        return [0]\n    }\n    if smallest_value == 0 {\n        return\
    \ []\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppijnigt_.swift:35:34: error: cannot assign value of type '[Int]'\
    \ to type 'Int'\n                smallest_index = result\n                   \
    \              ^~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return helper(arr: arr, num: -1, minIndex:\
    \ -1, maxIndex: -1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw2padcof.swift:28:12: error: cannot find 'helper' in scope\n  \
    \  return helper(arr: arr, num: -1, minIndex: -1, maxIndex: -1)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var index = 0\n    var value = arr[0]\n\
    \    \n    for element in arr {\n        if element % 2 == 0 {\n            value\
    \ = element\n            index = arr[index]\n        }\n    }\n    \n    return\
    \ [value, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6117257c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6116f4e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6116f4e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6116f4e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6116f4dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6116d4de83 <unavailable> + 188035

    6    tmpq22skllp                        0x000055b758d4f097 <unavailable> + 8343

    7    tmpq22skllp                        0x000055b758d4e544 <unavailable> + 5444

    8    libc.so.6                          0x00002b6117443460 __libc_start_main +
    245

    9    tmpq22skllp                        0x000055b758d4e229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minOddValue = IntMax\n    var minIndex\
    \ = -1\n    for i in arr {\n        if i.isMultipleOfEven {\n            minIndex\
    \ = i\n            minOddValue = i.value\n            break\n        }\n    }\n\
    \    if minOddValue == IntMax {\n        return []\n    }\n    return [minOddValue,\
    \ minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpa4wykgf6.swift:28:23: error: cannot find 'IntMax' in scope\n  \
    \  var minOddValue = IntMax\n                      ^~~~~~\n/tmp/tmpa4wykgf6.swift:31:14:\
    \ error: value of type 'Int' has no member 'isMultipleOfEven'\n        if i.isMultipleOfEven\
    \ {\n           ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpa4wykgf6.swift:33:29: error: value\
    \ of type 'Int' has no member 'value'\n            minOddValue = i.value\n   \
    \                       ~ ^~~~~\n/tmp/tmpa4wykgf6.swift:37:23: error: cannot find\
    \ 'IntMax' in scope\n    if minOddValue == IntMax {\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result: [Int] = []\n    if arr.isEmpty()\
    \ {\n        return arr\n    }\n\n    var minV = arr[0]\n    var minI = 0\n  \
    \  for i : Int in 1..arr.count {\n        if arr[i] <= minV {\n            continue\n\
    \        }\n        if arr[i] % 2 == 0 {\n            if minV < arr[i] {\n   \
    \             minV = arr[i]\n                minI = i\n            }\n       \
    \ } else {\n            if arr[i] < minV {\n                minV = arr[i]\n  \
    \              minI = i\n            }\n        }\n    }\n    result = [minV,\
    \ minI]\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp5zq2d1sb.swift:29:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp5zq2d1sb.swift:35:21: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i : Int in 1..arr.count {\n                   \
    \ ^~\n                    ...\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.reduce((prev, next) -> Int {\n\
    \        let result = prev % 2\n        prev /= 2\n        return result\n   \
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2,\
    \ 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzr7zxrqb.swift:28:24: error: cannot find 'prev' in scope\n    return\
    \ arr.reduce((prev, next) -> Int {\n                       ^~~~\n/tmp/tmpzr7zxrqb.swift:28:30:\
    \ error: cannot find 'next' in scope\n    return arr.reduce((prev, next) -> Int\
    \ {\n                             ^~~~\n/tmp/tmpzr7zxrqb.swift:29:22: error: cannot\
    \ find 'prev' in scope\n        let result = prev % 2\n                     ^~~~\n\
    /tmp/tmpzr7zxrqb.swift:30:9: error: cannot find 'prev' in scope\n        prev\
    \ /= 2\n        ^~~~\n/tmp/tmpzr7zxrqb.swift:28:23: error: expected type before\
    \ '->'\n    return arr.reduce((prev, next) -> Int {\n                      ^\n\
    /tmp/tmpzr7zxrqb.swift:28:39: error: expected type after '->'\n    return arr.reduce((prev,\
    \ next) -> Int {\n                                      ^\n/tmp/tmpzr7zxrqb.swift:32:6:\
    \ error: missing argument for parameter #2 in call\n    })\n     ^\n     , <#(_.Type,\
    \ Int) throws -> _.Type#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n\
    \    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult:\
    \ (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n/tmp/tmpzr7zxrqb.swift:28:16: error: cannot convert\
    \ return expression of type '_.Type' to return type '[Int]'\n    return arr.reduce((prev,\
    \ next) -> Int {\n           ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    let n = arr.count\n    if n == 0\
    \ {\n        return []\n    }\n\n    // find the first element to make the array\n\
    \    // evenly divisible\n    let m = Int((Double(arr.count) / 2.0).rounded(.toNearestOrEven))\n\
    \    // pick an element from arr\n    var p = arr[m]\n    // find the smallest\
    \ even number of this element\n    for var i = 0; i < n; i++ {\n        if arr[i]\
    \ % 2 == 0 {\n            p = arr[m]\n            break\n        }\n    }\n  \
    \  // return the result\n    var ret: [Int] = []\n    // find m and find the smallest\
    \ odd number less than m\n    for var i = 0; i < n; i++ {\n        if arr[i] %\
    \ 2 != 0 {\n            continue\n        }\n        if arr[m] % 2 == 0 {\n  \
    \          ret = append(ret, m)\n            m += 1\n        }\n    }\n    return\
    \ ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph8g_n4yz.swift:40:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmph8g_n4yz.swift:49:5: error: C-style for statement has been removed in\
    \ Swift 3\n    for var i = 0; i < n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // write your code here\n    if arr.isEmpty{\n\
    \        return []\n    }\n    let sorted = Array(sorted(arr, comparator: >))\n\
    \    let index = sorted.firstIndex(where: >)!\n    return sorted[index]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8jtoa0p_.swift:32:24: error: use of local variable 'sorted' before\
    \ its declaration\n    let sorted = Array(sorted(arr, comparator: >))\n      \
    \                 ^\n/tmp/tmp8jtoa0p_.swift:32:9: note: 'sorted' declared here\n\
    \    let sorted = Array(sorted(arr, comparator: >))\n        ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    arr.sort()\n    var smallest : [Int] =\
    \ []\n    var smallestIndex = -1\n    for idx in 0..<arr.count {\n        if arr[idx]\
    \ % 2 == 0 {\n            smallest.append(arr[idx])\n            smallestIndex\
    \ = idx\n        }\n    }\n    if smallestIndex == -1 {\n        return arr\n\
    \    }\n    return smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprmlqpgfy.swift:28:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpaq_4qk0y/tmpaq_4qk0y.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9794a2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9794725b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9794725988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97947247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaq_4qk0y                        0x00005643f6c213bc <unavailable> + 5052

    5    libc.so.6                          0x00002b9794c1a460 __libc_start_main +
    245

    6    tmpaq_4qk0y                        0x00005643f6c20fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var evenIndex = 0\n    var minEven\
    \ = arr[0]\n    var minIndex = 0\n    var minValue = arr[0]\n    for index in\
    \ 1..<arr.count {\n        let curValue = arr[index]\n        if curValue % 2\
    \ == 0 {\n            if curValue < minValue {\n                minEven = curValue\n\
    \                minIndex = index\n            }\n        }\n    }\n    \n   \
    \ return [minEven, minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpdwnymyir/tmpdwnymyir.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c6e8e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c6e5dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c6e5da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c6e5d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdwnymyir                        0x0000562514aaf70b <unavailable> + 5899

    5    libc.so.6                          0x00002b0c6eacf460 __libc_start_main +
    245

    6    tmpdwnymyir                        0x0000562514aaf1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var i = 0\n    for n in arr {\n       \
    \ if n%2 == 0 {\n            return [n, i]\n        }\n        i += 1\n    }\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpi4fp8p2m/tmpi4fp8p2m.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d7662c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d7359b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3d7359988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3d73587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi4fp8p2m                        0x000055cade03e5bc <unavailable> + 5564

    5    libc.so.6                          0x00002ac3d784e460 __libc_start_main +
    245

    6    tmpi4fp8p2m                        0x000055cade03e1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var ans: [Int] = [0]\n    for node in arr\
    \ {\n        if node % 2 == 0 {\n            ans[ans.count - 1] = node\n     \
    \   }\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpopnz_t5y/tmpopnz_t5y.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3caffbdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3cafcb4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3cafcb4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3cafcb37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopnz_t5y                        0x000055bda86e666c <unavailable> + 5740

    5    libc.so.6                          0x00002b3cb01a9460 __libc_start_main +
    245

    6    tmpopnz_t5y                        0x000055bda86e6279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var minIndex = -1\n    var min = arr[0]\n    for i in 1..<arr.count {\n \
    \       if arr[i] < min {\n            minIndex = i\n            min = arr[i]\n\
    \        }\n    }\n    var result = [min]\n    if minIndex != -1 {\n        let\
    \ val = arr[minIndex]\n        var i = 1\n        while i < arr.count {\n    \
    \        if arr[i] < val {\n                result.insert(val, at: i)\n      \
    \      } else {\n                break\n            }\n            i += 1\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp7hjdm0vc/tmp7hjdm0vc.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b13e986ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13e9565b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b13e9565988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b13e95647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7hjdm0vc                        0x0000559bf352064c <unavailable> + 5708

    5    libc.so.6                          0x00002b13e9a5a460 __libc_start_main +
    245

    6    tmp7hjdm0vc                        0x0000559bf3520259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n  guard !arr.isEmpty else {\n    return []\n\
    \  }\n  var result: [Int] = []\n  var idx = 0\n  for node in arr {\n    if node\
    \ % 2 == 0 {\n      result.append(node)\n      idx += 1\n    }\n  }\n  return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: Exception
  stderr: 'tmph66fnbx6/tmph66fnbx6.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca54ddcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca54ad3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca54ad3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca54ad27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph66fnbx6                        0x0000561dfcaf266c <unavailable> + 5740

    5    libc.so.6                          0x00002aca54fc8460 __libc_start_main +
    245

    6    tmph66fnbx6                        0x0000561dfcaf2279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpaq_4qk0y/tmpaq_4qk0y.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9794a2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9794725b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9794725988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97947247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaq_4qk0y                        0x00005643f6c213bc <unavailable> + 5052

    5    libc.so.6                          0x00002b9794c1a460 __libc_start_main +
    245

    6    tmpaq_4qk0y                        0x00005643f6c20fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013835
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n  if arr.isEmpty { return []  }\n  var evenValues\
    \ = Set<Int>()\n  var smallestValue = arr[0]\n  var smallestIndex = -1\n  for\
    \ val in arr {\n    if val%2 == 0 {\n      evenValues.insert(val)\n      if val\
    \ <= smallestValue {\n        smallestValue = val\n        smallestIndex = arr.index(val)\n\
    \      }\n    }\n  }\n  if smallestIndex < 0 {\n    return []\n  }\n  if evenValues.isEmpty\
    \ { return [smallestValue, smallestIndex] }\n  return [smallestValue, smallestIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmple1lrrqr.swift:37:29: error: no exact matches in call to instance\
    \ method 'index'\n        smallestIndex = arr.index(val)\n                   \
    \         ^\nSwift.Array:7:28: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(after:)')\n    @inlinable public func index(after i: Int) -> Int\n\
    \                           ^\nSwift.Array:9:28: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(before:)')\n    @inlinable public func index(before\
    \ i: Int) -> Int\n                           ^\nSwift.RandomAccessCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(after:)')\n\
    \    @inlinable public func index(after i: Self.Index) -> Self.Index\n       \
    \                    ^\nSwift.RandomAccessCollection:4:28: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public func\
    \ index(before i: Self.Index) -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    arr = arr\n    ret := make([]int, len(arr))\n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] % 2 == 0 {\n         \
    \   ret[i] = arr[i]\n        } else {\n            if i > 0 && ret[i-1] > ret[i]\
    \ {\n                ret[i] = ret[i-1]\n            }\n        }\n    }\n    return\
    \ ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp845uj_e8.swift:29:8: error: consecutive statements on a line must\
    \ be separated by ';'\n    ret := make([]int, len(arr))\n       ^\n       ;\n\
    /tmp/tmp845uj_e8.swift:29:9: error: expected expression\n    ret := make([]int,\
    \ len(arr))\n        ^\n/tmp/tmp845uj_e8.swift:30:12: error: expected type\n \
    \   for i := 0; i < len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmp845uj_e8.swift:30:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmp845uj_e8.swift:30:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(arr); i++ {\n           ^\n/tmp/tmp845uj_e8.swift:28:5:\
    \ error: cannot assign to value: 'arr' is a 'let' constant\n    arr = arr\n  \
    \  ^~~\n/tmp/tmp845uj_e8.swift:29:5: error: cannot find 'ret' in scope\n    ret\
    \ := make([]int, len(arr))\n    ^~~\n/tmp/tmp845uj_e8.swift:39:12: error: cannot\
    \ find 'ret' in scope\n    return ret\n           ^~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return arr\n\
    \    }\n\n    // write your code here\n    var even = [Int]()\n    var index =\
    \ [Int]()\n    var val = 0\n    \n    for i in arr {\n        if i % 2 == 0 {\n\
    \            even.append(i)\n        }\n        \n        if val == 0 {\n    \
    \        val = i\n            \n            if even.count > 0 {\n            \
    \    val = even[0]\n                even.removeAtIndex(even.indexof(val))\n  \
    \              index.insert(index[0], val as Int)\n            }\n        }\n\
    \    }\n    \n    return index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe_35oh50.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpe_35oh50.swift:47:22: error: value of type '[Int]' has no member\
    \ 'removeAtIndex'\n                even.removeAtIndex(even.indexof(val))\n   \
    \             ~~~~ ^~~~~~~~~~~~~\n/tmp/tmpe_35oh50.swift:47:41: error: value of\
    \ type '[Int]' has no member 'indexof'\n                even.removeAtIndex(even.indexof(val))\n\
    \                                   ~~~~ ^~~~~~~\n/tmp/tmpe_35oh50.swift:48:29:\
    \ error: missing argument label 'at:' in call\n                index.insert(index[0],\
    \ val as Int)\n                            ^\n                               \
    \        at: \n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var min = arr[0]\n    var index = 0\n \
    \   for _, value := range arr {\n        if value < min {\n            min = value\n\
    \            index = index\n        }\n    }\n    return [min] + arr[index:]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp2dwgzm1o.swift:30:10: error: expected 'in' after for-each pattern\n\
    \    for _, value := range arr {\n         ^\n/tmp/tmp2dwgzm1o.swift:30:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, value := range arr\
    \ {\n         ^\n/tmp/tmp2dwgzm1o.swift:36:30: error: expected expression in list\
    \ of expressions\n    return [min] + arr[index:]\n                           \
    \  ^\n/tmp/tmp2dwgzm1o.swift:36:30: error: missing argument for parameter #1 in\
    \ call\n    return [min] + arr[index:]\n                             ^\n     \
    \                        <#Range<Int>#>\nSwift.Array:17:23: note: 'subscript(_:)'\
    \ declared here\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    return sorted(arr)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzglwy1ek.swift:29:12: error: cannot find 'sorted' in scope\n  \
    \  return sorted(arr)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return []\n\
    \    }\n    var sorted = IntArraySort(arr)\n    var first: Int\n    var minIndex:\
    \ Int\n    var temp = 0\n    for idx in 0..<sorted.length {\n        if arr[idx]\
    \ % 2 == 0 {\n            temp = sorted[idx]\n            first = 0\n        \
    \    while arr[first] == temp && first < idx {\n                first++\n    \
    \        }\n            if first == idx {\n                minIndex = idx\n  \
    \          } else {\n                minIndex = idx\n                first--\n\
    \            }\n        } else {\n            minIndex = idx\n        }\n    }\n\
    \    return arr[minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprwl_1gv2.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmprwl_1gv2.swift:31:18: error: cannot find 'IntArraySort' in scope\n\
    \    var sorted = IntArraySort(arr)\n                 ^~~~~~~~~~~~\n/tmp/tmprwl_1gv2.swift:52:15:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return arr[minIndex]\n           ~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return []\n\
    \    }\n    let sorted = arr.sorted()\n    var minValue = sorted[0]\n    var index\
    \ = 0\n    for i in 0..<arr.count {\n        if sorted[i] != minValue {\n    \
    \        minValue = sorted[i]\n            index = i\n        }\n    }\n    return\
    \ [minValue, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpo5pqwwrj.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    // init a max size to hold the result\n\
    \    var maxSize : Int = 0\n    \n    for element in arr {\n        // check if\
    \ the current element has an even value, if so increment the size\n        if\
    \ element % 2 == 0 {\n            maxSize += 1\n        }\n    }\n    \n    //\
    \ init a result array\n    var result : [Int] = []\n    \n    // iterate through\
    \ the array\n    for element in arr {\n        // check if the current element\
    \ has an even value, if so increment the size\n        if element % 2 == 0 {\n\
    \            // if the size has increased then we found the max size\n       \
    \     if maxSize == 1 {\n                // append the index to the result array\n\
    \                result.append(element)\n            }\n            else {\n \
    \               // else we found the max size but we are not at the max size\n\
    \                // append the index to the result array\n                result.append(element)\n\
    \                // append the max index to the result array\n               \
    \ result.append(maxSize)\n            }\n            // reset max size\n     \
    \       maxSize = 1\n        }\n    }\n    \n    // return the result array\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpx1yeoswv/tmpx1yeoswv.swift:80: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c132cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c12fc6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c12fc6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c12fc57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx1yeoswv                        0x000056022895161c <unavailable> + 5660

    5    libc.so.6                          0x00002b6c134bb460 __libc_start_main +
    245

    6    tmpx1yeoswv                        0x0000560228951229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.isEmpty == false else { return\
    \ [] }\n\n    var minValue = Int32(Int.maxValue)\n    var minIndex = 0\n    for\
    \ (_, value) in arr.enumerated() {\n        guard value % 2 == 0 && value != 0\
    \ else { continue }\n        guard value < minValue else { minValue = value }\n\
    \        guard minIndex == 0 || value < arr[minIndex-1] else { minIndex = arr.index(value)\
    \ }\n    }\n    return [minValue, minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_qvyqewq.swift:30:30: error: type 'Int' has no member 'maxValue'\n\
    \    var minValue = Int32(Int.maxValue)\n                         ~~~ ^~~~~~~~\n\
    /tmp/tmp_qvyqewq.swift:35:78: error: no exact matches in call to instance method\
    \ 'index'\n        guard minIndex == 0 || value < arr[minIndex-1] else { minIndex\
    \ = arr.index(value) }\n                                                     \
    \                        ^\nSwift.Array:7:28: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(after:)')\n    @inlinable public func index(after\
    \ i: Int) -> Int\n                           ^\nSwift.Array:9:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public\
    \ func index(before i: Int) -> Int\n                           ^\nSwift.RandomAccessCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(after:)')\n\
    \    @inlinable public func index(after i: Self.Index) -> Self.Index\n       \
    \                    ^\nSwift.RandomAccessCollection:4:28: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public func\
    \ index(before i: Self.Index) -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smalest_value : Int = 0\n    var smalest_index\
    \ : Int = 0\n    \n    for var i = 0; i < arr.count; ++i {\n        if arr[i]\
    \ % 2 == 0 {\n            if arr[i] > smalest_value {\n                smalest_value\
    \ = arr[i]\n                smalest_index = i\n            }\n        }\n    }\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxm5e2k2f.swift:31:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < arr.count; ++i {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // initialize result\n    var result =\
    \ Array(repeating: 0, count: arr.count)\n    // find min\n    var minValue = arr[0]\n\
    \    var minIndex = 0\n    // initialize flag\n    var foundFlag = false\n   \
    \ // search through list\n    for i in 0..<arr.count {\n        if arr[i] < minValue\
    \ {\n            result[i] = arr[i]\n            minValue = arr[i]\n         \
    \   minIndex = i\n            foundFlag = false\n        } else {\n          \
    \  if arr[i] % 2 == 0 {\n                if foundFlag == false {\n           \
    \         result[i] = arr[i]\n                    foundFlag = true\n         \
    \       } else {\n                    // if min value has been found\n       \
    \             if result[i] < arr[i] {\n                        minIndex = i\n\
    \                        result[i] = arr[i]\n                        foundFlag\
    \ = true\n                    }\n                }\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp7kufaq1e/tmp7kufaq1e.swift:74: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f45decc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f45ae3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f45ae3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f45ae27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7kufaq1e                        0x0000557bf54e36bc <unavailable> + 5820

    5    libc.so.6                          0x00002b1f45fd8460 __libc_start_main +
    245

    6    tmp7kufaq1e                        0x0000557bf54e32c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minValue = Int((Int64.leastSignificantBit\
    \ - 1))\n    var minIndex = -1\n\n    for idx in  (0..<arr.count) {\n        if\
    \ arr[Int(idx)]%2 == 0 {\n            if minValue > arr[Int(idx)] {\n        \
    \        minValue = arr[Int(idx)]\n                minIndex = idx\n          \
    \  }\n        }\n    }\n\n    if minValue == 0 {\n        return []\n    }\n\n\
    \    return [minValue, minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_sm694s8.swift:28:31: error: type 'Int64' has no member 'leastSignificantBit'\n\
    \    var minValue = Int((Int64.leastSignificantBit - 1))\n                   \
    \     ~~~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minIndex, smallerValue, values: [Int]\
    \ = []\n    var index = 0\n    for x in arr {\n        if x % 2 == 0 {\n     \
    \       smallerValue = x\n            minIndex = index\n        }\n        index\
    \ += 1\n    }\n    if minIndex != 0 {\n        values = [smallerValue, minIndex]\n\
    \    }\n    return values\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpf1ydhhag.swift:28:9: error: type annotation missing in pattern\n\
    \    var minIndex, smallerValue, values: [Int] = []\n        ^\n/tmp/tmpf1ydhhag.swift:28:19:\
    \ error: type annotation missing in pattern\n    var minIndex, smallerValue, values:\
    \ [Int] = []\n                  ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    let mut ret = [Int]()\n    var min_index\
    \ = 0\n    \n    for i in 0..arr.count {\n        if arr[i] % 2 == 0 {\n     \
    \       if min_index < i {\n                min_index = i\n            }\n   \
    \     } else {\n            min_index = 0\n        }\n    }\n    \n    if min_index\
    \ < arr.count {\n        ret.append(arr[min_index])\n    }\n    \n    if min_index\
    \ >= arr.count {\n        return ret\n    } else {\n        return ret\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzln0_vqy.swift:29:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut ret = [Int]()\n\
    \            ^\n/tmp/tmpzln0_vqy.swift:29:13: note: join the identifiers together\n\
    \    let mut ret = [Int]()\n        ~~~~^~~\n        mutret\n/tmp/tmpzln0_vqy.swift:29:13:\
    \ note: join the identifiers together with camel-case\n    let mut ret = [Int]()\n\
    \        ~~~~^~~\n        mutRet\n/tmp/tmpzln0_vqy.swift:32:15: error: cannot\
    \ find operator '..' in scope; did you mean '...'?\n    for i in 0..arr.count\
    \ {\n              ^~\n              ...\n/tmp/tmpzln0_vqy.swift:43:9: error:\
    \ cannot find 'ret' in scope\n        ret.append(arr[min_index])\n        ^~~\n\
    /tmp/tmpzln0_vqy.swift:47:16: error: cannot find 'ret' in scope\n        return\
    \ ret\n               ^~~\n/tmp/tmpzln0_vqy.swift:49:16: error: cannot find 'ret'\
    \ in scope\n        return ret\n               ^~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    arr.sort()\n    return arr\n        .enumerate()\n        .filter({\
    \ (i, _) in i % 2 == 0 })\n        .sorted()\n        .map({ (i, _) in arr[i]\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2,\
    \ 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpvute1h99.swift:31:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n/tmp/tmpvute1h99.swift:33:10:\
    \ error: value of type '[Int]' has no member 'enumerate'\n        .enumerate()\n\
    \         ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013837
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    var maxEvenIndex: Int = 0\n    var maxEvenValue: Int = 0\n    var minIndex\
    \ = -1\n    for node in arr {\n        if node % 2 == 0 {\n            if maxEvenValue\
    \ < node {\n                maxEvenValue = node\n                maxEvenIndex\
    \ = node\n            }\n        } else {\n            if maxEvenIndex == -1 ||\
    \ (maxEvenIndex < node && node < maxEvenIndex) {\n                maxEvenIndex\
    \ = node\n            }\n        }\n        if minIndex == -1 || node < arr[minIndex]\
    \ {\n            minIndex = node\n        }\n    }\n    if maxEvenIndex == -1\
    \ {\n        return []\n    }\n    return [maxEvenValue, maxEvenIndex]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b864a4d0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b864a1c7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b864a1c7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b864a1c713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b864a1c6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8649fc6e83 <unavailable> + 188035

    6    tmpskii5e2m                        0x000055f28b9671fc <unavailable> + 8700

    7    tmpskii5e2m                        0x000055f28b966594 <unavailable> + 5524

    8    libc.so.6                          0x00002b864a6bc460 __libc_start_main +
    245

    9    tmpskii5e2m                        0x000055f28b966279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var min_index\
    \ = -1\n    var min_value = Int64(math.MinInt64)\n    for value in arr {\n   \
    \     if value < min_value {\n            min_value = value\n        }\n     \
    \   if value % 2 == 0 {\n            result.append(value)\n            if value\
    \ < min_index {\n                min_index = value\n            }\n        }\n\
    \    }\n    if min_value == Int64(math.MinInt64) {\n        return result\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1bh9g4d2.swift:30:27: error: cannot find 'math' in scope\n    var\
    \ min_value = Int64(math.MinInt64)\n                          ^~~~\n/tmp/tmp1bh9g4d2.swift:42:27:\
    \ error: cannot find 'math' in scope\n    if min_value == Int64(math.MinInt64)\
    \ {\n                          ^~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return []\n\
    \    }\n    var min_even_index = -1\n    var min_even_val = -1\n    for i in 0..<arr.count\
    \ {\n        let even_val = arr[i] % 2 == 0\n        if even_val == min_even_val\
    \ {\n            min_even_index = i\n            min_even_val = even_val\n   \
    \     } else if even_val {\n            if min_even_index == -1 {\n          \
    \      min_even_index = i\n            }\n        }\n    }\n    if min_even_index\
    \ != -1 {\n        let mut index = min_even_index\n        let mut val = arr[min_even_index]\n\
    \        while val % 2 == 0 {\n            val += arr[min_even_index + index]\
    \ % 2\n            index += min_even_index\n        }\n        return [val, index]\n\
    \    } else {\n        return []\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3fg0eb7y.swift:45:17: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut index\
    \ = min_even_index\n                ^\n/tmp/tmp3fg0eb7y.swift:45:17: note: join\
    \ the identifiers together\n        let mut index = min_even_index\n         \
    \   ~~~~^~~~~\n            mutindex\n/tmp/tmp3fg0eb7y.swift:45:17: note: join\
    \ the identifiers together with camel-case\n        let mut index = min_even_index\n\
    \            ~~~~^~~~~\n            mutIndex\n/tmp/tmp3fg0eb7y.swift:46:17: error:\
    \ found an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n        let mut val = arr[min_even_index]\n                ^\n/tmp/tmp3fg0eb7y.swift:46:17:\
    \ note: join the identifiers together\n        let mut val = arr[min_even_index]\n\
    \            ~~~~^~~\n            mutval\n/tmp/tmp3fg0eb7y.swift:46:17: note:\
    \ join the identifiers together with camel-case\n        let mut val = arr[min_even_index]\n\
    \            ~~~~^~~\n            mutVal\n/tmp/tmp3fg0eb7y.swift:28:12: error:\
    \ cannot call value of non-function type 'Bool'\n    if arr.isEmpty() {\n    \
    \       ^      ~~\n                  \n/tmp/tmp3fg0eb7y.swift:35:21: error: binary\
    \ operator '==' cannot be applied to operands of type 'Bool' and 'Int'\n     \
    \   if even_val == min_even_val {\n           ~~~~~~~~ ^  ~~~~~~~~~~~~\n/tmp/tmp3fg0eb7y.swift:35:21:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Bool, Bool), (Int, Int)\n        if even_val == min_even_val {\n          \
    \          ^\n/tmp/tmp3fg0eb7y.swift:37:28: error: cannot assign value of type\
    \ 'Bool' to type 'Int'\n            min_even_val = even_val\n                \
    \           ^~~~~~~~\n/tmp/tmp3fg0eb7y.swift:46:13: error: invalid redeclaration\
    \ of 'mut'\n        let mut val = arr[min_even_index]\n            ^\n/tmp/tmp3fg0eb7y.swift:45:13:\
    \ note: 'mut' previously declared here\n        let mut index = min_even_index\n\
    \            ^\n/tmp/tmp3fg0eb7y.swift:47:15: error: cannot find 'val' in scope\n\
    \        while val % 2 == 0 {\n              ^~~\n/tmp/tmp3f"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return []\n\
    \    }\n\n    // Find smallest even value\n    var smallest_even_value = arr[0]\n\
    \    var smallest_even_index = 0\n\n    for index in 0..<arr.count {\n       \
    \ if arr[index] % 2 == 0 {\n            if smallest_even_index < index {\n   \
    \             smallest_even_index = index\n                smallest_even_value\
    \ = arr[index]\n            }\n        }\n    }\n\n    if smallest_even_value\
    \ != arr[0] {\n        return []\n    }\n\n    return [smallest_even_value]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpuq4dds2l.swift:28:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    let result = Array(0..<arr.count).map\
    \ { _ in\n        if arr[$0] % 2 == 0 {\n            return $0\n        } else\
    \ {\n            return $0 + 1\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpa0imv_ed.swift:30:16: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments\n        if arr[$0] % 2\
    \ == 0 {\n               ^\n/tmp/tmpa0imv_ed.swift:31:20: error: anonymous closure\
    \ arguments cannot be used inside a closure that has explicit arguments\n    \
    \        return $0\n                   ^\n/tmp/tmpa0imv_ed.swift:33:20: error:\
    \ anonymous closure arguments cannot be used inside a closure that has explicit\
    \ arguments\n            return $0 + 1\n                   ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    let len = arr.count\n    var ans\
    \ = Int64(0)\n    var i = 0\n    for val in arr {\n        var idx: Int = 0\n\
    \        var min = Int64(arr[0])\n        for _val in arr {\n            let delta\
    \ = val - _val\n            if delta < min {\n                min = delta\n  \
    \              idx = _val\n            }\n        }\n        ans = min(ans, min\
    \ + idx)\n    }\n    \n    if len == 0 {\n        return nil\n    }\n    if ans\
    \ > Int64(Int64.max) {\n        return nil\n    }\n    \n    return [ans, Int64(len\
    \ - 1)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpciwjic5n.swift:38:23: error: cannot assign value of type 'Int'\
    \ to type 'Int64'\n                min = delta\n                      ^~~~~\n\
    \                      Int64( )\n/tmp/tmpciwjic5n.swift:42:28: error: binary operator\
    \ '+' cannot be applied to operands of type 'Int64' and 'Int'\n        ans = min(ans,\
    \ min + idx)\n                       ~~~ ^ ~~~\n/tmp/tmpciwjic5n.swift:42:28:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int), (Int64, Int64)\n        ans = min(ans, min + idx)\n            \
    \               ^\n/tmp/tmpciwjic5n.swift:42:15: error: cannot call value of non-function\
    \ type 'Int64'\n        ans = min(ans, min + idx)\n              ^\n/tmp/tmpciwjic5n.swift:46:16:\
    \ error: 'nil' is incompatible with return type '[Int]'\n        return nil\n\
    \               ^\n/tmp/tmpciwjic5n.swift:49:16: error: 'nil' is incompatible\
    \ with return type '[Int]'\n        return nil\n               ^\n/tmp/tmpciwjic5n.swift:52:13:\
    \ error: cannot convert value of type 'Int64' to expected element type 'Int'\n\
    \    return [ans, Int64(len - 1)]\n            ^\n/tmp/tmpciwjic5n.swift:52:18:\
    \ error: cannot convert value of type 'Int64' to expected element type 'Int'\n\
    \    return [ans, Int64(len - 1)]\n                 ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n  return pick(arr: arr, pick: pickFromArray)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpt7exn2m6.swift:28:10: error: cannot find 'pick' in scope\n  return\
    \ pick(arr: arr, pick: pickFromArray)\n         ^~~~\n/tmp/tmpt7exn2m6.swift:28:31:\
    \ error: cannot find 'pickFromArray' in scope\n  return pick(arr: arr, pick: pickFromArray)\n\
    \                              ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n\n    guard arr.count >= 1 else {\n        return []\n    }\n\n    var\
    \ result: [Int] = []\n\n    if arr.count == 1 {\n        let value = arr[0]\n\
    \        if value < 2 {\n            return []\n        }\n        if value <\
    \ 6 {\n            result = [value]\n        }\n    }\n\n    var value = 0\n \
    \   var i = 0\n    while i < arr.count {\n        value = arr[i]\n        if value\
    \ < 2 {\n            if result.count < result.count {\n                result.append(value)\n\
    \            }\n        } else {\n            break\n        }\n        i += 1\n\
    \    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp_chx7xqu/tmp_chx7xqu.swift:78: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01c695bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01c6652b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01c6652988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01c66517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_chx7xqu                        0x0000559ce826755c <unavailable> + 5468

    5    libc.so.6                          0x00002b01c6b47460 __libc_start_main +
    245

    6    tmp_chx7xqu                        0x0000559ce8267169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var even = arr[0] & 1\n    var index =\
    \ 0\n    for idx in 0..<arr.count {\n        if arr[idx] == even {\n         \
    \   index = idx\n            break\n        }\n    }\n    return [even, index]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpp648cg7j/tmpp648cg7j.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7fd45bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7fd42b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7fd42b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7fd42b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp648cg7j                        0x000056080355d5ec <unavailable> + 5612

    5    libc.so.6                          0x00002b7fd47a9460 __libc_start_main +
    245

    6    tmpp648cg7j                        0x000056080355d1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return helper(arr, arr.count)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp2iho1hld.swift:28:12: error: cannot find 'helper' in scope\n  \
    \  return helper(arr, arr.count)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minElement\
    \ = arr[0]\n    var minElementIndex = -1\n    for i in arr {\n        if i % 2\
    \ != 0 {\n            continue\n        }\n        if minElement > i {\n     \
    \       minElement = i\n            minElementIndex = i\n        }\n    }\n  \
    \  if minElementIndex >= 0 {\n        result = append(result, minElement)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpf_o6j9mj.swift:41:18: error: cannot find 'append' in scope\n  \
    \      result = append(result, minElement)\n                 ^~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: '/tmp/tmp_224baur.swift:29:1: error: missing return in global function expected
    to return ''[Int]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var i = 0\n    var res = Int()\n    for\
    \ x in arr {\n        if x%2 == 0 {\n            res = x\n            i = i\n\
    \        }\n    }\n    return res as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpo_w14g22.swift:33:15: error: assigning a variable to itself\n \
    \           i = i\n            ~ ^ ~\n/tmp/tmpo_w14g22.swift:36:16: error: cannot\
    \ convert value of type 'Int' to type '[Int]' in coercion\n    return res as [Int]\n\
    \           ~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return arr\n\
    \    }\n    let mut smallest = arr.sorted()\n    if smallest.first % 2 == 0 {\n\
    \        smallest.removeFirst()\n    }\n    return smallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6mtanekf.swift:31:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut smallest\
    \ = arr.sorted()\n            ^\n/tmp/tmp6mtanekf.swift:31:13: note: join the\
    \ identifiers together\n    let mut smallest = arr.sorted()\n        ~~~~^~~~~~~~\n\
    \        mutsmallest\n/tmp/tmp6mtanekf.swift:31:13: note: join the identifiers\
    \ together with camel-case\n    let mut smallest = arr.sorted()\n        ~~~~^~~~~~~~\n\
    \        mutSmallest\n/tmp/tmp6mtanekf.swift:28:12: error: cannot call value of\
    \ non-function type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n   \
    \               \n/tmp/tmp6mtanekf.swift:32:8: error: cannot find 'smallest' in\
    \ scope\n    if smallest.first % 2 == 0 {\n       ^~~~~~~~\n/tmp/tmp6mtanekf.swift:33:9:\
    \ error: cannot find 'smallest' in scope\n        smallest.removeFirst()\n   \
    \     ^~~~~~~~\n/tmp/tmp6mtanekf.swift:35:12: error: cannot find 'smallest' in\
    \ scope\n    return smallest\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    \n    var result: [Int] = []\n    var index = 0\n    \n    for node\
    \ in arr {\n        if node % 2 == 0 {\n            result.append(node)\n    \
    \    }\n        \n        if index < result.count && result[index] == node {\n\
    \            index++\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxcpsmj_8.swift:41:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            index++\n                 ^~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr != nil else { return [] }\n\n\
    \    let n = arr.count\n\n    var min = arr[0]\n\n    var index = 0\n\n    for\
    \ i in 1..<n {\n        guard arr[i] % 2 == 0 else { return [] }\n\n        if\
    \ arr[i] < min {\n            min = arr[i]\n            index = i\n        }\n\
    \    }\n\n    return [min, index] as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpghl4bo_2/tmpghl4bo_2.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b112cd76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b112ca6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b112ca6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b112ca6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpghl4bo_2                        0x00005609b2dc05ec <unavailable> + 5612

    5    libc.so.6                          0x00002b112cf62460 __libc_start_main +
    245

    6    tmpghl4bo_2                        0x00005609b2dc01f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013837
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n\tguard arr.count > 0 && arr.count <= 10000\
    \ else {\n\t\treturn []\n\t}\n\n\t// Sort the array to find the smallest odd value.\
    \ O(nlogn) time complexity\n\tlet sortedArr = arr.sorted()\n\n\tlet smallestOddValue\
    \ = sortedArr.first { $0 % 2 == 0 }\n\t// Now get the index\n\tlet indexOfSmallestOddValue\
    \ = sortedArr.index(of: smallestOddValue) ?? -1\n\n\t// The plucked value is the\
    \ smallest odd value and its index\n\treturn [smallestOddValue, indexOfSmallestOddValue]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpm2zvokg5.swift:37:52: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        let indexOfSmallestOddValue =\
    \ sortedArr.index(of: smallestOddValue) ?? -1\n                              \
    \                            ^\n/tmp/tmpm2zvokg5.swift:37:52: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        let\
    \ indexOfSmallestOddValue = sortedArr.index(of: smallestOddValue) ?? -1\n    \
    \                                                      ^\n                   \
    \                                                        ?? <#default value#>\n\
    /tmp/tmpm2zvokg5.swift:37:52: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        let indexOfSmallestOddValue =\
    \ sortedArr.index(of: smallestOddValue) ?? -1\n                              \
    \                            ^\n                                             \
    \                             !\n/tmp/tmpm2zvokg5.swift:40:10: error: cannot convert\
    \ value of type 'Int?' to expected element type 'Int'\n        return [smallestOddValue,\
    \ indexOfSmallestOddValue]\n                ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    sort.Sort(&arr)\n    \n    // Find max\
    \ node with even value\n    var maxEvenValue : Int = 0\n    var maxEvenIndex :\
    \ Int = 0\n    var hasMaxEvenValue : Bool = false\n    for i in 0..<arr.count\
    \ {\n        if arr[i] % 2 == 0 {\n            if !hasMaxEvenValue {\n       \
    \         maxEvenValue = arr[i]\n                maxEvenIndex = i\n          \
    \      hasMaxEvenValue = true\n            } else {\n                if arr[i]\
    \ > maxEvenValue {\n                    maxEvenValue = arr[i]\n              \
    \      maxEvenIndex = i\n                }\n            }\n        }\n    }\n\
    \    \n    var arrResult : [Int] = []\n    if maxEvenIndex > 0 && maxEvenIndex\
    \ < arr.count {\n        arrResult.append(maxEvenValue)\n        arrResult.append(maxEvenIndex)\n\
    \    }\n    \n    return arrResult\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmphdnxwu4e.swift:28:5: error: cannot find 'sort' in scope\n    sort.Sort(&arr)\n\
    \    ^~~~\n/tmp/tmphdnxwu4e.swift:28:15: error: cannot pass immutable value as\
    \ inout argument: 'arr' is a 'let' constant\n    sort.Sort(&arr)\n           \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return pluckHelper(arr, &Int)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnzrafyyb.swift:28:12: error: cannot find 'pluckHelper' in scope\n\
    \    return pluckHelper(arr, &Int)\n           ^~~~~~~~~~~\n/tmp/tmpnzrafyyb.swift:28:29:\
    \ error: cannot pass immutable value of type 'Int.Type' as inout argument\n  \
    \  return pluckHelper(arr, &Int)\n                            ^~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr == nil {\n        return nil\n \
    \   }\n    let len = arr.count\n    if len == 0 {\n        return []\n    }\n\
    \    let smallestValue = (arr[0] as Int) % 2\n    if smallestValue == 0 {\n  \
    \      return nil\n    }\n    var arr2 = arr\n    var indexOfSmallestValue = -1\n\
    \    for index in 0..<len {\n        let value = (arr2[index] as Int) % 2\n  \
    \      if value == smallestValue {\n            arr2 = arr2.dropFirst(index)\n\
    \            indexOfSmallestValue = index\n        } else {\n            break\n\
    \        }\n    }\n    return [smallestValue, indexOfSmallestValue + 1]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpoyeqe9n0.swift:28:12: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if arr == nil {\n       ~~~\
    \ ^  ~~~\n/tmp/tmpoyeqe9n0.swift:29:16: error: 'nil' is incompatible with return\
    \ type '[Int]'\n        return nil\n               ^\n/tmp/tmpoyeqe9n0.swift:37:16:\
    \ error: 'nil' is incompatible with return type '[Int]'\n        return nil\n\
    \               ^\n/tmp/tmpoyeqe9n0.swift:44:25: error: no 'dropFirst' candidates\
    \ produce the expected contextual result type '[Int]'\n            arr2 = arr2.dropFirst(index)\n\
    \                        ^\nSwift.Sequence:4:40: note: 'dropFirst' produces 'DropFirstSequence<[Int]>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func dropFirst(_ k: Int = 1) -> DropFirstSequence<Self>\n                  \
    \                     ^\nSwift.Collection:3:40: note: 'dropFirst' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func dropFirst(_ k: Int = 1) -> Self.SubSequence\n                         \
    \              ^\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.isEmpty == false else {\n   \
    \     return []\n    }\n    guard arr.isEmpty == true else {\n        return []\n\
    \    }\n    var even: Int = 0\n    var index: Int = 0\n    for i in arr {\n  \
    \      if i % 2 == 0 {\n            even = i\n            index = index + 1\n\
    \        }\n    }\n    guard even != 0 else {\n        return []\n    }\n    return\
    \ [ even , index ]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp0c_4a6vs/tmp0c_4a6vs.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac198482c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac198179b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac198179988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1981787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0c_4a6vs                        0x000056546ce7f61c <unavailable> + 5660

    5    libc.so.6                          0x00002ac19866e460 __libc_start_main +
    245

    6    tmp0c_4a6vs                        0x000056546ce7f229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013837
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    // Write your code here.\n    \n\
    \    \n    let values = [Int](arr)\n    values.sort(<)\n    \n    if values.contains(0)\
    \ {\n        return [0]\n    }\n    \n    let index = values.index(of: 0)\n  \
    \  let value = values[index!]\n    \n    return value\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppglek2rn.swift:33:12: error: cannot use mutating member on immutable\
    \ value: 'values' is a 'let' constant\n    values.sort(<)\n    ~~~~~~ ^\n/tmp/tmppglek2rn.swift:32:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let values = [Int](arr)\n\
    \    ^~~\n    var\n/tmp/tmppglek2rn.swift:33:17: error: missing argument label\
    \ 'by:' in call\n    values.sort(<)\n                ^\n                by: \n\
    /tmp/tmppglek2rn.swift:39:24: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n    let index = values.index(of: 0)\n                   \
    \    ^\n/tmp/tmppglek2rn.swift:39:24: note: use 'firstIndex(of:)' instead\n  \
    \  let index = values.index(of: 0)\n                       ^~~~~\n           \
    \            firstIndex\n/tmp/tmppglek2rn.swift:42:12: error: cannot convert return\
    \ expression of type 'Int' to return type '[Int]'\n    return value\n        \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013836
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var largestEvenIndex = 0\n    var\
    \ largestEvenValue = arr[0]\n    for index in 0..<arr.count {\n        if arr[index]\
    \ % 2 == 0 {\n            if arr[index] > largestEvenValue {\n               \
    \ largestEvenValue = arr[index]\n                largestEvenIndex = index\n  \
    \          }\n        }\n    }\n    if largestEvenIndex == arr.count {\n     \
    \   return arr as [Int]\n    }\n    return [largestEvenValue, largestEvenIndex]\
    \ as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: Exception
  stderr: 'tmpz_hephkw/tmpz_hephkw.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0db7cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0db4c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0db4c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0db4c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz_hephkw                        0x00005582e60795ec <unavailable> + 5612

    5    libc.so.6                          0x00002ac0db9b7460 __libc_start_main +
    245

    6    tmpz_hephkw                        0x00005582e60791f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013837
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return nil\n\
    \    }\n    var ans = [1]\n    for i in 0 ..< arr.count {\n        if arr[i] %\
    \ 2 == 0 {\n            ans[0] = arr[i]\n            ans[1] = i\n            break\n\
    \        }\n    }\n    if ans[0] == 0 && arr.count == 1 {\n        return nil\n\
    \    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpx29iku0l.swift:29:16: error: 'nil' is incompatible with return\
    \ type '[Int]'\n        return nil\n               ^\n/tmp/tmpx29iku0l.swift:40:16:\
    \ error: 'nil' is incompatible with return type '[Int]'\n        return nil\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013836
