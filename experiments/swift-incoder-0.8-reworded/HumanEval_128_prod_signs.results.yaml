language: swift
name: HumanEval_128_prod_signs
results:
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    // TODO: Write your code here\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpbyqce6gf/tmpbyqce6gf.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5dd86fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5dd83f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5dd83f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5dd83f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbyqce6gf                        0x000056050c62f3d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b5dd88e7460 __libc_start_main +
    245

    6    tmpbyqce6gf                        0x000056050c62ef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979897
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var product = 1\n    for i in arr {\n\
    \        switch i {\n        case 1:\n            sum += product\n        case\
    \ -1:\n            product *= -1\n        case 0:\n            return nil\n  \
    \      default:\n            sum += i\n            product *= i\n        }\n \
    \   }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmppxa9ulke/tmppxa9ulke.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b423a1c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4239ebfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4239ebf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4239ebe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppxa9ulke                        0x0000559fa1a35549 <unavailable> + 5449

    5    libc.so.6                          0x00002b423a3b4460 __libc_start_main +
    245

    6    tmppxa9ulke                        0x0000559fa1a350d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var signs\
    \ = 1\n    for x in arr { signs *= 1 }\n    var result = signs\n    for x in arr\
    \ {\n        result *= signs[x]\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmprs_o2zz2.swift:19:24: error: value of type 'Int' has no subscripts\n\
    \        result *= signs[x]\n                  ~~~~~^\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.reduce(0) { $1 * is_sign($0) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphwcadtoo.swift:14:33: error: cannot find 'is_sign' in scope\n \
    \   return arr.reduce(0) { $1 * is_sign($0) }\n                              \
    \  ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var product = arr[0]\n    for i in arr {\n        product *= sign(i)\n  \
    \  }\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpkocsz6mu.swift:19:20: error: cannot find 'sign' in scope\n    \
    \    product *= sign(i)\n                   ^~~~\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result: Int? = nil\n    for n in arr {\n        let\
    \ sign = sign(n: n)\n        let product = product(sign: sign)\n        result\
    \ = product * (result ?? product)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpaek42re6.swift:16:20: error: use of local variable 'sign' before\
    \ its declaration\n        let sign = sign(n: n)\n                   ^\n/tmp/tmpaek42re6.swift:16:13:\
    \ note: 'sign' declared here\n        let sign = sign(n: n)\n            ^\n/tmp/tmpaek42re6.swift:17:23:\
    \ error: use of local variable 'product' before its declaration\n        let product\
    \ = product(sign: sign)\n                      ^\n/tmp/tmpaek42re6.swift:17:13:\
    \ note: 'product' declared here\n        let product = product(sign: sign)\n \
    \           ^\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product: Int?\n    for v in arr {\n        product\
    \ = v * (v == 0 ? 0 : 1)\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp16re3l2z/tmp16re3l2z.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae01ee78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae01eb6fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae01eb6f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae01eb6e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp16re3l2z                        0x000055577657b549 <unavailable> + 5449

    5    libc.so.6                          0x00002ae01f064460 __libc_start_main +
    245

    6    tmp16re3l2z                        0x000055577657b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = arr[0]\n    for i in 1..<arr.count {\n     \
    \   sum += signs(arr[i]) * arr[i]\n    }\n    return sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3h1wqkjl.swift:16:16: error: cannot find 'signs' in scope\n   \
    \     sum += signs(arr[i]) * arr[i]\n               ^~~~~\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var m = -1\n    for x in arr {\n        m *= x\n    }\n\
    \    return m\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpyc101bm1/tmpyc101bm1.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b94fe20bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b94fdf02b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b94fdf02988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94fdf017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyc101bm1                        0x0000556096cc1549 <unavailable> + 5449

    5    libc.so.6                          0x00002b94fe3f7460 __libc_start_main +
    245

    6    tmpyc101bm1                        0x0000556096cc10d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979897
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    guard let\
    \ i = arr.first else {\n        return nil\n    }\n    var m = Int()\n    var\
    \ sign = 1\n    for v in arr.dropFirst() {\n        let x = v * sign\n       \
    \ if x < 0 {\n            sign = -sign\n        }\n        if x < m {\n      \
    \      m = x\n        }\n    }\n    return m\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpjqvwf4y7/tmpjqvwf4y7.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1670e61c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1670b58b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1670b58988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1670b577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjqvwf4y7                        0x00005578109176e9 <unavailable> + 5865

    5    libc.so.6                          0x00002b167104d460 __libc_start_main +
    245

    6    tmpjqvwf4y7                        0x0000557810917279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty { return nil }\n    var sum = 0\n    var\
    \ mul = 1\n    for i in arr {\n        sum += Int(abs(i))\n        mul *= Int(sign(i))\n\
    \    }\n    return sum * mul\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1rjw0d2u.swift:19:20: error: cannot find 'sign' in scope\n    \
    \    mul *= Int(sign(i))\n                   ^~~~\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n\n    var\
    \ sign = 0\n    var product = 1\n\n    for x in arr {\n        sign = sign * Int(x)\n\
    \        product = product * Int(sign)\n    }\n\n    return product\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp05dfqctf.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard !arr.isEmpty else { return nil }\n\n  var res = arr[0]\n\
    \  for n in arr {\n    res = res * Int(n) * sign(n) // 1 * 1 * -1 = -1, 1, 1\n\
    \  }\n  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpfi0waskh.swift:18:26: error: cannot find 'sign' in scope\n    res\
    \ = res * Int(n) * sign(n) // 1 * 1 * -1 = -1, 1, 1\n                        \
    \ ^~~~\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n    var\
    \ result = 0\n    var sign = 1\n    for i in arr {\n        sign *= Int(i == 1)\n\
    \        result += sign * abs(i)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp018vhpzl.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp018vhpzl.swift:20:17: error: no exact matches in call to initializer\
    \ \n        sign *= Int(i == 1)\n                ^\nSwift.Int:7:12: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Bool')\n    public init(_\
    \ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate expects value\
    \ of type 'Float' for parameter #1 (got 'Bool')\n    public init(_ source: Float)\n\
    \           ^\nSwift.Int:12:12: note: candidate expects value of type 'Double'\
    \ for parameter #1 (got 'Bool')\n    public init(_ source: Double)\n         \
    \  ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80' for parameter\
    \ #1 (got 'Bool')\n    public init(_ source: Float80)\n           ^\nSwift.Int:28:12:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'Bool')\n    public init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12:\
    \ note: candidate expects value of type 'Builtin.Word' for parameter #1 (got 'Bool')\n\
    \    public init(_ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var acc = 1\n    for i in arr {\n        acc *= abs(i)\n\
    \        if i < 0 {\n            acc *= -1\n        }\n    }\n    return acc\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpyu22uwst/tmpyu22uwst.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f3edd0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f3eac7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f3eac7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f3eac67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyu22uwst                        0x000055a8bbedd639 <unavailable> + 5689

    5    libc.so.6                          0x00002b6f3efbc460 __libc_start_main +
    245

    6    tmpyu22uwst                        0x000055a8bbedd1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    for val in arr {\n        guard let sign = sign, sign\
    \ > 0 else { return nil }\n        var product = 1\n        while product > 0\
    \ {\n            if sign == 1 {\n                product *= val\n            }\
    \ else {\n                product *= (-val)\n            }\n        }\n    }\n\
    \    return product > 0\n        ? arr.reduce(0, +) / arr.count\n        : nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1c5tylyz.swift:15:26: error: cannot find 'sign' in scope\n    \
    \    guard let sign = sign, sign > 0 else { return nil }\n                   \
    \      ^~~~\n/tmp/tmp1c5tylyz.swift:25:12: error: cannot find 'product' in scope\n\
    \    return product > 0\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.isEmpty == false else { return nil }\n    var\
    \ res = 0\n    for i in 0..<arr.count {\n        let num: Int = arr[i]\n     \
    \   let sign: Int = num < 0 ? -1 : 1\n        res = res * sign\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpg6r552df/tmpg6r552df.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7518ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7515c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7515c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7515c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg6r552df                        0x0000562b271b56a9 <unavailable> + 5801

    5    libc.so.6                          0x00002ad751ab8460 __libc_start_main +
    245

    6    tmpg6r552df                        0x0000562b271b5239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    \n  \
    \  var max = 0\n    var sign = .Zero\n    var prod = 1\n    var sum = 0\n    for\
    \ &i in arr {\n        sum += i\n        max = max(max, abs(i))\n        sign\
    \ = sign * (i > 0 ? 1 : -1)\n        prod *= sign\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp71h1_923.swift:22:9: error: expected pattern\n    for &i in arr\
    \ {\n        ^\n/tmp/tmp71h1_923.swift:22:12: error: expected '{' to start the\
    \ body of for-each loop\n    for &i in arr {\n           ^\n/tmp/tmp71h1_923.swift:19:17:\
    \ error: reference to member 'Zero' cannot be resolved without a contextual type\n\
    \    var sign = .Zero\n               ~^~~~\n/tmp/tmp71h1_923.swift:22:9: error:\
    \ '&' may only be used to pass an argument to inout parameter\n    for &i in arr\
    \ {\n        ^\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n    var signs = 1\n    for elem in arr\
    \ {\n        result += signs * elem\n        signs = signs * -1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmppwc9dh8d/tmppwc9dh8d.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad69d929c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad69d620b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad69d620988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad69d61f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppwc9dh8d                        0x0000555cffd95549 <unavailable> + 5449

    5    libc.so.6                          0x00002ad69db15460 __libc_start_main +
    245

    6    tmppwc9dh8d                        0x0000555cffd950d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr == nil || arr.isEmpty() {\n        return nil\n\
    \    }\n    var sum: Int = 0\n    for i in arr {\n        sum += sign * i\n  \
    \  }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpaae85ma3.swift:14:26: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr == nil || arr.isEmpty() {\n                        \
    \ ^      ~~\n                                \n/tmp/tmpaae85ma3.swift:19:16: error:\
    \ cannot find 'sign' in scope\n        sum += sign * i\n               ^~~~\n"
  stdout: ''
  timestamp: 1659979897
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sign =\
    \ 1\n    var result = 0\n    for i in arr {\n        result *= sign\n        sign\
    \ *= -1\n        if sign == 0 { return nil }\n        result += i\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp66z6p78w/tmp66z6p78w.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9576a73c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b957676ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b957676a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95767697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp66z6p78w                        0x000055a29aa36599 <unavailable> + 5529

    5    libc.so.6                          0x00002b9576c5f460 __libc_start_main +
    245

    6    tmp66z6p78w                        0x000055a29aa36129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    // write your code in an efficient way\n    if arr.isEmpty()\
    \ { return nil }\n    var product = 0\n    for x in arr {\n        let sign =\
    \ x == Int(x) ? 1 : -1\n        product += sign * Int(x)\n    }\n    return product\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpi_vgpmxk.swift:15:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() { return nil }\n           ^      ~~\n   \
    \               \n"
  stdout: ''
  timestamp: 1659979897
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.reduce(1, *)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpp3demeqw/tmpp3demeqw.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9999c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9996bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab9996ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9996b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp3demeqw                        0x000055c1a6fac459 <unavailable> + 5209

    5    libc.so.6                          0x00002ab999baf460 __libc_start_main +
    245

    6    tmpp3demeqw                        0x000055c1a6fabfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979897
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr == nil || arr.isEmpty {\n        return nil\n \
    \   }\n    var prod = 1\n    for element in arr {\n        prod *= signOf(element)\n\
    \    }\n    return prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7d4z0sj5.swift:14:12: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if arr == nil || arr.isEmpty\
    \ {\n       ~~~ ^  ~~~\n/tmp/tmp7d4z0sj5.swift:19:17: error: cannot find 'signOf'\
    \ in scope\n        prod *= signOf(element)\n                ^~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    \n    let result = arr.reduce(0) { (result, value) in\n\
    \        if value < 0 {\n            return result * -1\n        } else {\n  \
    \          return result * 1\n        }\n    }\n    \n    if result == 0 {\n \
    \       return nil\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpjndd3xed/tmpjndd3xed.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b34f21b8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34f1eafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b34f1eaf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34f1eae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjndd3xed                        0x000055d84e47b459 <unavailable> + 5209

    5    libc.so.6                          0x00002b34f23a4460 __libc_start_main +
    245

    6    tmpjndd3xed                        0x000055d84e47afe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.filter(isSign).reduce(1, *)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqtv5jggq.swift:14:23: error: cannot find 'isSign' in scope\n  \
    \  return arr.filter(isSign).reduce(1, *)\n                      ^~~~~~\n/tmp/tmpqtv5jggq.swift:14:23:\
    \ error: converting non-escaping value to '(Int) throws -> Bool' may allow it\
    \ to escape\n    return arr.filter(isSign).reduce(1, *)\n                    \
    \  ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty  {\n        return nil\n    }\n    var\
    \ signs = 1\n    var sum = 0\n    for el in arr {\n        sum += el\n       \
    \ signs = signs * signOf(el)\n    }\n    return sum * signs\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpsv0ikr_p.swift:21:25: error: cannot find 'signOf' in scope\n  \
    \      signs = signs * signOf(el)\n                        ^~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let sum = arr.map({ $0 * $0.signum })\n    return arr.isEmpty\
    \ ? nil : sum.product()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpbixoygc5.swift:14:28: error: binary operator '*' cannot be applied\
    \ to operands of type 'Int' and '() -> Int'\n    let sum = arr.map({ $0 * $0.signum\
    \ })\n                        ~~ ^ ~~~~~~~~~\n/tmp/tmpbixoygc5.swift:14:28: note:\
    \ overloads for '*' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    let sum = arr.map({ $0 * $0.signum })\n                          \
    \ ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n    let\
    \ mag = arr.reduce(0) { $0 + $1 }\n    var prod = 1\n    for _ in arr {\n    \
    \    prod = prod * (-1 / mag)\n    }\n    return mag * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpl1h59n97.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod: Int?\n    var sign: Int?\n    var sum: Int?\n    for i in 0..<arr.count\
    \ {\n        sum = sign\n        prod = sign\n        let num = arr[i]\n     \
    \   sign = num < 0 ? -1 : 1\n        if let s = sum, let p = prod {\n        \
    \    prod *= sign\n            if sign == -1 {\n                s += num\n   \
    \         } else {\n                s -= num\n            }\n        } else {\n\
    \            sum = num\n            prod = sign\n        }\n    }\n    return\
    \ prod == nil ? nil : sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpt6xbdvbi.swift:26:13: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n            prod *= sign\n          \
    \  ^\n/tmp/tmpt6xbdvbi.swift:26:13: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n            prod *= sign\n           \
    \ ^\n                !\n/tmp/tmpt6xbdvbi.swift:26:21: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n            prod *=\
    \ sign\n                    ^\n/tmp/tmpt6xbdvbi.swift:26:21: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \   prod *= sign\n                    ^\n                         ?? <#default\
    \ value#>\n/tmp/tmpt6xbdvbi.swift:26:21: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            prod *= sign\n \
    \                   ^\n                        !\n/tmp/tmpt6xbdvbi.swift:28:19:\
    \ error: left side of mutating operator isn't mutable: 's' is a 'let' constant\n\
    \                s += num\n                ~ ^\n/tmp/tmpt6xbdvbi.swift:30:19:\
    \ error: left side of mutating operator isn't mutable: 's' is a 'let' constant\n\
    \                s -= num\n                ~ ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod = 1\n    var sign = 1\n    for x in arr {\n \
    \       sign *= x\n        prod *= sign\n    }\n    return prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp0luazr11/tmp0luazr11.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba06c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba03beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba03be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba03bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0luazr11                        0x000055ea505eb549 <unavailable> + 5449

    5    libc.so.6                          0x00002acba08b3460 __libc_start_main +
    245

    6    tmp0luazr11                        0x000055ea505eb0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty { return nil }\n    var sum = 0\n    var\
    \ product = 1\n    for i in arr {\n        if i == -1 {\n            product *=\
    \ -1\n        } else {\n            product *= i\n        }\n        sum += i\n\
    \    }\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp_qy2vt1m/tmp_qy2vt1m.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5cf338ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5cf3085b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5cf3085988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5cf30847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_qy2vt1m                        0x000055bbeadf9599 <unavailable> + 5529

    5    libc.so.6                          0x00002b5cf357a460 __libc_start_main +
    245

    6    tmp_qy2vt1m                        0x000055bbeadf9129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty, let first = arr.removeFirst() else\
    \ {\n        return nil\n    }\n    return arr.reduce(1, combine: +) * first\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1r70dgla.swift:14:41: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    guard !arr.isEmpty, let first = arr.removeFirst()\
    \ else {\n                                    ~~~ ^\n/tmp/tmp1r70dgla.swift:17:22:\
    \ error: extraneous argument label 'combine:' in call\n    return arr.reduce(1,\
    \ combine: +) * first\n                     ^   ~~~~~~~~~\n                  \
    \       \n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n    var sign = 1\n    for x in arr {\n\
    \        if x == 0 {\n            result = nil\n        } else {\n           \
    \ result += sign * x\n        }\n        sign = -sign\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp6n1uaddt.swift:18:22: error: 'nil' cannot be assigned to type 'Int'\n\
    \            result = nil\n                     ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var ret = Int()\n    var mags = Int()\n    for v in arr\
    \ {\n        mags += Int(v * sign(v))\n    }\n    if mags > ret {\n        ret\
    \ = mags\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpibua05dz.swift:17:25: error: cannot find 'sign' in scope\n    \
    \    mags += Int(v * sign(v))\n                        ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.reduce(0) {\n        sum, elem in\n       \
    \ guard elem != 0 else {\n            return sum\n        }\n        var sign\
    \ = 1\n        if elem < 0 {\n            sign = -1\n        }\n        return\
    \ sum + sign * abs(elem)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpaddlbjn_/tmpaddlbjn_.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad4bacebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad4ba9e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad4ba9e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad4ba9e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaddlbjn_                        0x000055be08f71539 <unavailable> + 5433

    5    libc.so.6                          0x00002ad4baed7460 __libc_start_main +
    245

    6    tmpaddlbjn_                        0x000055be08f710c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum: Int\
    \ = 0\n    var sign: Int = 0\n    for x in arr {\n        sum += abs(x * sign)\n\
    \        sign *= x\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmplq4hnj6f/tmplq4hnj6f.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002accdf477c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002accdf16eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002accdf16e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002accdf16d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplq4hnj6f                        0x0000563d94214689 <unavailable> + 5769

    5    libc.so.6                          0x00002accdf663460 __libc_start_main +
    245

    6    tmplq4hnj6f                        0x0000563d94214219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard !arr.isEmpty else { return nil }\n  var max: Int =\
    \ -Int.max\n  var min: Int = Int.max\n  for num in arr {\n    if num < min {\n\
    \      min = num\n    }\n    if num > max {\n      max = num\n    }\n  }\n  let\
    \ product: Int = 1\n  var sign: Int = 1\n  for num in arr {\n    product *= num\n\
    \    sign *= (min > 0 ? 1 : -1)\n  }\n  return product * sign\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmck5kdgs.swift:28:13: error: left side of mutating operator isn't\
    \ mutable: 'product' is a 'let' constant\n    product *= num\n    ~~~~~~~ ^\n\
    /tmp/tmpmck5kdgs.swift:25:3: note: change 'let' to 'var' to make it mutable\n\
    \  let product: Int = 1\n  ^~~\n  var\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n\n    //\
    \ The array elements may be all positive or all negative\n    // and they may\
    \ be same sign\n    var sign = 1\n    var magnitude = 0\n\n    for element in\
    \ arr {\n        sign = sign * element\n        magnitude = magnitude + abs(element)\n\
    \    }\n\n    // The product of magnitude of each element in the array\n    //\
    \ and sign of every element in the array\n    return magnitude * sign\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1t8gglf2.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var signs: [Int] = [0]\n    for x in arr {\n        signs[x]\
    \ += signs[x] == 0 ? 1 : -1\n    }\n    return arr.map { $0 * signs[$0] }.compactMapFirst(Int.init).reduce(0,\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp4g3a7brp.swift:18:39: error: value of type '[Int]' has no member\
    \ 'compactMapFirst'\n    return arr.map { $0 * signs[$0] }.compactMapFirst(Int.init).reduce(0,\
    \ +)\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum:\
    \ Int = 0\n    var sign: Int = 0\n    for i in arr {\n        sum += i\n     \
    \   sign *= i\n    }\n    if sign == 0 {\n        return nil\n    }\n    return\
    \ sum * sign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpfqz12d0x/tmpfqz12d0x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b70214c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b6ff0bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b6ff0b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b6ff0a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfqz12d0x                        0x000055c568f18599 <unavailable> + 5529

    5    libc.so.6                          0x00002b6b70400460 __libc_start_main +
    245

    6    tmpfqz12d0x                        0x000055c568f18129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    for el in arr {\n        if el == 0 { return nil }\n \
    \   }\n    let res = 0\n    for el in arr {\n        let sign = el > 0 ? 1 : -1\n\
    \        res += sign * abs(el)\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpaafgpo9q.swift:20:13: error: left side of mutating operator isn't\
    \ mutable: 'res' is a 'let' constant\n        res += sign * abs(el)\n        ~~~\
    \ ^\n/tmp/tmpaafgpo9q.swift:17:5: note: change 'let' to 'var' to make it mutable\n\
    \    let res = 0\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = Int()\n    var product = Int()\n    for number\
    \ in arr {\n        sum += number\n        product *= signInt(number)\n    }\n\
    \    return sum == 0 ? nil : sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmplfimq3f6.swift:18:20: error: cannot find 'signInt' in scope\n \
    \       product *= signInt(number)\n                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var product\
    \ = 1\n    for x in arr {\n        product *= sign(x)\n    }\n    return product\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5ue3tqug.swift:19:20: error: cannot find 'sign' in scope\n    \
    \    product *= sign(x)\n                   ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty{\n    return nil\n  }\n  return arr.map {\
    \ mag($0) }.reduce(0, combine: {$0 * $1}) // if nil just 0 will be returned\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpjv_b4pcg.swift:17:20: error: cannot find 'mag' in scope\n  return\
    \ arr.map { mag($0) }.reduce(0, combine: {$0 * $1}) // if nil just 0 will be returned\n\
    \                   ^~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod: Int = 0\n    var sign: Int = 0\n    for num\
    \ in arr {\n        prod *= num\n        sign += 1 if num != 0 else -1\n    }\n\
    \    return prod * sign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2v1j_cuq.swift:18:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        sign += 1 if num != 0 else -1\n               \
    \  ^\n                 ;\n/tmp/tmp2v1j_cuq.swift:18:31: error: unexpected 'else'\
    \ immediately following 'if' condition\n        sign += 1 if num != 0 else -1\n\
    \                              ^\n/tmp/tmp2v1j_cuq.swift:18:31: note: remove 'else'\
    \ to execute the braced block of statements when the condition is true\n     \
    \   sign += 1 if num != 0 else -1\n                              ^~~~~\n     \
    \                         \n/tmp/tmp2v1j_cuq.swift:18:36: error: expected '{'\
    \ after 'if' condition\n        sign += 1 if num != 0 else -1\n              \
    \                     ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var m = Int(0)\n    var prod = Int(0)\n    for v in arr\
    \ {\n        if v != 0 {\n            m *= v\n        } else {\n            prod\
    \ *= -v\n        }\n    }\n    return Optional(m)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmplaz72xbf/tmplaz72xbf.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56f5a3fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56f5736b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56f5736988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56f57357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplaz72xbf                        0x000055a25a934549 <unavailable> + 5449

    5    libc.so.6                          0x00002b56f5c2b460 __libc_start_main +
    245

    6    tmplaz72xbf                        0x000055a25a9340d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n\n    var\
    \ sum = arr[0]\n    for &n in arr {\n        var s = sign(n)\n        if s !=\
    \ 0 {\n            sum = s * sum\n        }\n    }\n\n    return sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpfgm17urb.swift:19:9: error: expected pattern\n    for &n in arr\
    \ {\n        ^\n/tmp/tmpfgm17urb.swift:19:12: error: expected '{' to start the\
    \ body of for-each loop\n    for &n in arr {\n           ^\n/tmp/tmpfgm17urb.swift:19:9:\
    \ error: '&' may only be used to pass an argument to inout parameter\n    for\
    \ &n in arr {\n        ^\n/tmp/tmpfgm17urb.swift:20:17: error: cannot find 'sign'\
    \ in scope\n        var s = sign(n)\n                ^~~~\n/tmp/tmpfgm17urb.swift:20:22:\
    \ error: cannot find 'n' in scope\n        var s = sign(n)\n                 \
    \    ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let max = arr.max()\n\n    // sum magnitudes of numbers\n\
    \    var magnitude = 0\n    for _ in arr {\n        magnitude += mag\n    }\n\n\
    \    // compute product of all signs\n    var sign = 0\n    for _ in arr {\n \
    \       sign *= sign\n    }\n\n    return (magnitude * sign).min(max)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp6s3awpjn.swift:19:22: error: cannot find 'mag' in scope\n     \
    \   magnitude += mag\n                     ^~~\n/tmp/tmp6s3awpjn.swift:28:13:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Duration'\n\
    \    return (magnitude * sign).min(max)\n            ^\n/tmp/tmp6s3awpjn.swift:28:31:\
    \ error: value of type 'Duration' has no member 'min'\n    return (magnitude *\
    \ sign).min(max)\n           ~~~~~~~~~~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var product = 1\n\n    for i in 0..<arr.count\
    \ {\n        if arr[i] > 0 {\n            product *= -1\n        }\n        sum\
    \ += arr[i]\n    }\n\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpn_x2fbem/tmpn_x2fbem.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29987d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29984cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29984cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29984cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn_x2fbem                        0x000055c8216fe619 <unavailable> + 5657

    5    libc.so.6                          0x00002b29989c2460 __libc_start_main +
    245

    6    tmpn_x2fbem                        0x000055c8216fe1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let maxSign\
    \ = max(arr) { $0 < 0 }\n    var sign = 1\n    for val in arr {\n        if val\
    \ >= 0 {\n            sign *= -1\n        }\n        sign *= val\n    }\n    return\
    \ sign * maxSign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpuu6y4rdl.swift:15:19: error: type '(Int) -> Bool' cannot conform\
    \ to 'Comparable'\n    let maxSign = max(arr) { $0 < 0 }\n                  ^\n\
    /tmp/tmpuu6y4rdl.swift:15:19: note: only concrete types such as structs, enums\
    \ and classes can conform to protocols\n    let maxSign = max(arr) { $0 < 0 }\n\
    \                  ^\n/tmp/tmpuu6y4rdl.swift:15:19: note: required by global function\
    \ 'max' where 'T' = '(Int) -> Bool'\n    let maxSign = max(arr) { $0 < 0 }\n \
    \                 ^\n/tmp/tmpuu6y4rdl.swift:15:23: error: cannot convert value\
    \ of type '[Int]' to expected argument type '(Int) -> Bool'\n    let maxSign =\
    \ max(arr) { $0 < 0 }\n                      ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n\n    var\
    \ ans = arr.map({ $0 * sign($0) })\n    return ans.reduce(0, combine: +)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpx1umx0px.swift:18:30: error: cannot find 'sign' in scope\n    var\
    \ ans = arr.map({ $0 * sign($0) })\n                             ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n    var\
    \ product = 1\n    var sign = 1\n    for v in arr {\n        product *= sign\n\
    \        sign *= v\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2mgdi4h7.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \n    var result: Int = 0\n    for elem in arr {\n        switch elem {\n    \
    \    case 0:\n            result -= 1\n        case 1:\n            result +=\
    \ -1\n        default:\n            result += elem\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpt962sola/tmpt962sola.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e0ba1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e0b711b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e0b711988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e0b7107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt962sola                        0x000055b79072f599 <unavailable> + 5529

    5    libc.so.6                          0x00002b1e0bc06460 __libc_start_main +
    245

    6    tmpt962sola                        0x000055b79072f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    for x in arr {\n        let sign = x < 0 ? -1 : 1\n  \
    \      if x < 0 {\n            sign *= -1\n        }\n        if sign == 0 {\n\
    \            return nil\n        }\n    }\n    return arr.map(sign).reduce(0,\
    \ *) / arr.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5wnd4_d6.swift:17:18: error: left side of mutating operator isn't\
    \ mutable: 'sign' is a 'let' constant\n            sign *= -1\n            ~~~~\
    \ ^\n/tmp/tmp5wnd4_d6.swift:15:9: note: change 'let' to 'var' to make it mutable\n\
    \        let sign = x < 0 ? -1 : 1\n        ^~~\n        var\n/tmp/tmp5wnd4_d6.swift:23:20:\
    \ error: cannot find 'sign' in scope\n    return arr.map(sign).reduce(0, *) /\
    \ arr.count\n                   ^~~~\n/tmp/tmp5wnd4_d6.swift:23:20: error: converting\
    \ non-escaping value to '(Int) throws -> Int' may allow it to escape\n    return\
    \ arr.map(sign).reduce(0, *) / arr.count\n                   ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.count == 0 {\n        return nil\n    }\n    var\
    \ signs: [Int] = []\n    var product: Int = 0\n    for i in arr {\n        signs.append(\
    \ sign(i) )\n        product *= sign(i)\n    }\n    let res = signs.reduce(0,\
    \ combine: { $0 * $1 })\n    return product < 0 ? nil : res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdir6rufc.swift:20:23: error: cannot find 'sign' in scope\n    \
    \    signs.append( sign(i) )\n                      ^~~~\n/tmp/tmpdir6rufc.swift:21:20:\
    \ error: cannot find 'sign' in scope\n        product *= sign(i)\n           \
    \        ^~~~\n/tmp/tmpdir6rufc.swift:23:27: error: extraneous argument label\
    \ 'combine:' in call\n    let res = signs.reduce(0, combine: { $0 * $1 })\n  \
    \                        ^   ~~~~~~~~~\n                              \n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod = 1\n    var sumOfSigns = 0\n    for num in arr\
    \ {\n        switch num {\n        case 0:\n            sumOfSigns = 0\n     \
    \   case -1:\n            sumOfSigns += 1\n        case 1:\n            sumOfSigns\
    \ += 1\n        default:\n            prod *= -1\n            sumOfSigns += 1\n\
    \        }\n    }\n    if prod == 0 {\n        return nil\n    }\n    return sumOfSigns\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp6ef3u3qg/tmp6ef3u3qg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bfa9c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bfa6c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bfa6c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bfa6bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6ef3u3qg                        0x0000562771313549 <unavailable> + 5449

    5    libc.so.6                          0x00002b4bfabb5460 __libc_start_main +
    245

    6    tmp6ef3u3qg                        0x00005627713130d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n\n    var sum\
    \ = 0\n    var product = 1\n\n    for i in arr {\n        let sign = signOfInt64(i)\
    \ // <--- THIS LINE\n        sum += sign * product\n        product *= sign\n\
    \    }\n\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwgzztjox.swift:20:20: error: cannot find 'signOfInt64' in scope\n\
    \        let sign = signOfInt64(i) // <--- THIS LINE\n                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod = 1\n    for num in arr {\n        prod *= num\n\
    \        if num > 0 {\n            prod *= -1\n        }\n    }\n    return prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp8r28g23e/tmp8r28g23e.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4a137ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4a1075b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4a1075988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4a10747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8r28g23e                        0x000055ce6af7d549 <unavailable> + 5449

    5    libc.so.6                          0x00002ac4a156a460 __libc_start_main +
    245

    6    tmp8r28g23e                        0x000055ce6af7d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n\n    //\
    \ Use recursive helper function to reduce complexity to O(n).\n    return prod_signsRecursive(arr:\
    \ arr)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphgd2fpjb.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmphgd2fpjb.swift:19:12: error: cannot find 'prod_signsRecursive' in\
    \ scope\n    return prod_signsRecursive(arr: arr)\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var acc: Int = 0\n    for num in arr {\n        var sign\
    \ = 1\n        switch num {\n        case -1:\n            sign = -1\n       \
    \ case 1:\n            sign = 0\n        }\n        acc += sign * num\n    }\n\
    \    return acc\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2merdb4u.swift:17:9: error: switch must be exhaustive\n       \
    \ switch num {\n        ^\n/tmp/tmp2merdb4u.swift:17:9: note: do you want to add\
    \ a default clause?\n        switch num {\n        ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard arr.count > 0 else { return nil }\n  var res = 1\n\
    \  var sign = 1\n  for n in arr {\n    res *= sign\n    if n > 0 {\n      sign\
    \ = 1\n    } else {\n      sign = -1\n    }\n  }\n  return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpptdoawlv/tmpptdoawlv.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada86bdec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada868d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada868d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada868d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpptdoawlv                        0x0000565274cf3599 <unavailable> + 5529

    5    libc.so.6                          0x00002ada86dca460 __libc_start_main +
    245

    6    tmpptdoawlv                        0x0000565274cf3129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty { return nil }\n    var product = 1\n \
    \   for el in arr {\n        product *= signBit(el)\n    }\n    var sum = 0\n\
    \    for el in arr {\n        sum += signBit(el) * abs(el)\n    }\n    return\
    \ sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpq3t9c9lf.swift:17:20: error: cannot find 'signBit' in scope\n \
    \       product *= signBit(el)\n                   ^~~~~~~\n/tmp/tmpq3t9c9lf.swift:21:16:\
    \ error: cannot find 'signBit' in scope\n        sum += signBit(el) * abs(el)\n\
    \               ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum: Int?\n    \n    if arr.count > 0 {\n        sum\
    \ = arr[0]\n        for index = 1; index < arr.count; index++ {\n            sum\
    \ = sum * arr[index]\n        }\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpx6f7mgd3.swift:18:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for index = 1; index < arr.count; index++ {\n        ^ \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    for val in arr {\n        sum += val\
    \ * sign(val)\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpe393efu_.swift:16:22: error: cannot find 'sign' in scope\n    \
    \    sum += val * sign(val)\n                     ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n    var\
    \ sum = 0\n    for el in arr {\n        sum += abs(el) * sign(el)\n    }\n   \
    \ return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpbkxken6x.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpbkxken6x.swift:19:26: error: cannot find 'sign' in scope\n      \
    \  sum += abs(el) * sign(el)\n                         ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n    for x in arr {\n        if x > 0 {\n\
    \            result += 1\n        }\n        if x < 0 {\n            result -=\
    \ 1\n        }\n    }\n    return result * prod(arr: arr)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpofiviz9m.swift:23:21: error: cannot find 'prod' in scope\n    return\
    \ result * prod(arr: arr)\n                    ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n\n    var result\
    \ = 0\n    var product = 1\n    var sign = 1\n\n    for i in arr {\n        product\
    \ *= sign\n        if product > 0 { result += product }\n        sign *= -1\n\
    \    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpthf91oi3/tmpthf91oi3.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05ca596c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05ca28db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05ca28d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05ca28c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpthf91oi3                        0x000055ea0fc3a599 <unavailable> + 5529

    5    libc.so.6                          0x00002b05ca782460 __libc_start_main +
    245

    6    tmpthf91oi3                        0x000055ea0fc3a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var res =\
    \ 1\n    for v in arr {\n        res *= sign(v)\n    }\n    return res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0kk_58qw.swift:17:16: error: cannot find 'sign' in scope\n    \
    \    res *= sign(v)\n               ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sign\
    \ = 1\n    for i in 0 ..< arr.count {\n        sign *= arr[i]\n    }\n    return\
    \ sign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmput40lz7b/tmput40lz7b.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8ead17c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8eaa0eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8eaa0e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8eaa0d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmput40lz7b                        0x00005596c44b4619 <unavailable> + 5657

    5    libc.so.6                          0x00002ad8eaf03460 __libc_start_main +
    245

    6    tmput40lz7b                        0x00005596c44b41a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sumMags = 0\n    var signMags = [Int]()\n    for x\
    \ in arr {\n        sumMags += magnitude(x)\n        signMags[x]++\n    }\n  \
    \  return sumMags * productOfSigns(signMags)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp20i7w6g6.swift:17:20: error: cannot find 'magnitude' in scope\n\
    \        sumMags += magnitude(x)\n                   ^~~~~~~~~\n/tmp/tmp20i7w6g6.swift:18:20:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        signMags[x]++\n\
    \                   ^~\n/tmp/tmp20i7w6g6.swift:20:22: error: cannot find 'productOfSigns'\
    \ in scope\n    return sumMags * productOfSigns(signMags)\n                  \
    \   ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return reducePositive(arr) {\n        $1 * sign($0)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphblq_uxd.swift:14:12: error: cannot find 'reducePositive' in scope\n\
    \    return reducePositive(arr) {\n           ^~~~~~~~~~~~~~\n/tmp/tmphblq_uxd.swift:15:14:\
    \ error: cannot find 'sign' in scope\n        $1 * sign($0)\n             ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n    var\
    \ result: Int = 0\n    for val in arr {\n        if val == 1 {\n            result\
    \ += 0\n        } else if val == -1 {\n            result += 0\n        } else\
    \ {\n            result += val\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwms6qjoh.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n\n  var maxProd:\
    \ Int? = nil\n  var signProd: Int? = nil\n  var minProd: Int? = nil\n  var signMin:\
    \ Int? = nil\n  var maxMag: Int? = nil\n  var signMax: Int? = nil\n  var i: Int\n\
    \  for i = 0; i < (arr.count - 1); i++ {\n    if arr[i] > maxMag {\n      maxMag\
    \ = maxMag ?? arr[i]\n      signMax = signMax ?? 0\n    }\n    if arr[i] < minMag\
    \ {\n      minMag = minMag ?? arr[i]\n      signMin = signMin ?? 0\n    }\n  }\n\
    \n  if signMax != nil && signMin != nil {\n    maxProd = maxMag * signMax\n  \
    \  signProd = signMax * signMin\n  } else {\n    if signMax != nil {\n      maxProd\
    \ = maxMag\n      signProd = signMax\n    } else {\n      maxProd = minMag\n \
    \     signProd = -signMin\n    }\n  }\n\n  if arr.count > 1 {\n    var sum: Int?\
    \ = nil\n    var j: Int\n    for j = 0; j < (arr.count - 1); j++ {\n      if arr[j]\
    \ > maxProd {\n        sum = sum ?? arr[j] * signProd\n      } else {\n      \
    \  sum = sum ?? arr[j] * -signProd\n      }\n    }\n    return sum ?? nil\n  }\
    \ else {\n    return maxProd\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwv4xar4e.swift:25:3: error: C-style for statement has been removed\
    \ in Swift 3\n  for i = 0; i < (arr.count - 1); i++ {\n  ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpwv4xar4e.swift:52:5: error: C-style for statement has been removed in\
    \ Swift 3\n    for j = 0; j < (arr.count - 1); j++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpwv4xar4e.swift:37:22: error: binary operator '*' cannot be applied to\
    \ two 'Int?' operands\n    maxProd = maxMag * signMax\n              ~~~~~~ ^\
    \ ~~~~~~~\n/tmp/tmpwv4xar4e.swift:37:22: note: overloads for '*' exist with these\
    \ partially matching parameter lists: (Int, Int)\n    maxProd = maxMag * signMax\n\
    \                     ^\n/tmp/tmpwv4xar4e.swift:38:24: error: binary operator\
    \ '*' cannot be applied to two 'Int?' operands\n    signProd = signMax * signMin\n\
    \               ~~~~~~~ ^ ~~~~~~~\n/tmp/tmpwv4xar4e.swift:38:24: note: overloads\
    \ for '*' exist with these partially matching parameter lists: (Int, Int)\n  \
    \  signProd = signMax * signMin\n                       ^\n/tmp/tmpwv4xar4e.swift:44:17:\
    \ error: cannot find 'minMag' in scope\n      maxProd = minMag\n             \
    \   ^~~~~~\n/tmp/tmpwv4xar4e.swift:45:19: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n      signProd = -signMin\n    \
    \              ^\n/tmp/tmpwv4xar4e.swift:45:19: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n      signProd = -signMin\n\
    \                  ^\n                  (       ?? <#default value#>)\n/tmp/tmpwv4xar4e.swift:45:19:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n      signProd = -signMin\n                  ^\n                    \
    \     !\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty  {\n        return nil\n    }\n    \n \
    \   // count number of 1s and -1s to get total magnitude\n    let ones = arr.filter{\
    \ $0 > 0 }\n    let minusOnes = arr.filter{ $0 < 0 }\n    let magnitude = ones\
    \ + minusOnes\n    let product = magnitude * ones.reduce(1, *)\n    \n    // multiply\
    \ with sign of each number in arr\n    let sign = arr.map { $0 < 0 ? 1 : -1 }.reduce(1,\
    \ *)\n    return product * sign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphd9q5rbc.swift:22:29: error: binary operator '*' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n    let product = magnitude * ones.reduce(1,\
    \ *)\n                  ~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~\n/tmp/tmphd9q5rbc.swift:22:29:\
    \ note: overloads for '*' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    let product = magnitude * ones.reduce(1, *)\n              \
    \              ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  var product = 1\n  for v in arr {\n    if v > 0 {\n    \
    \  product *= v\n    }\n  }\n  return product\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpte19ci21/tmpte19ci21.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b945880cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9458503b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9458503988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94585027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpte19ci21                        0x0000558cb4e67549 <unavailable> + 5449

    5    libc.so.6                          0x00002b94589f8460 __libc_start_main +
    245

    6    tmpte19ci21                        0x0000558cb4e670d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod: Int = 0\n    for num in arr {\n        if num\
    \ != 0 {\n            prod *= signOfNum(num)\n        }\n    }\n    return prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpb2p4k1y0.swift:17:21: error: cannot find 'signOfNum' in scope\n\
    \            prod *= signOfNum(num)\n                    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var ret = 0\n    for val in arr {\n        switch val\
    \ {\n        case -1:\n            ret -= ret\n        case 1:\n            ret\
    \ += ret\n        default:\n            ret += ret\n        }\n    }\n    return\
    \ ret < 0 ? nil : ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp0yk2lqso/tmp0yk2lqso.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9540da4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9540a9bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9540a9b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9540a9a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0yk2lqso                        0x000055b03b6b0549 <unavailable> + 5449

    5    libc.so.6                          0x00002b9540f90460 __libc_start_main +
    245

    6    tmp0yk2lqso                        0x000055b03b6b00d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n    var\
    \ prod: Int? = 1\n    var sign: Int = 0\n    for value in arr {\n        switch\
    \ value {\n        case 1:\n            sign = 1\n        case -1:\n         \
    \   sign = -1\n        default:\n            sign = 0\n        }\n        prod\
    \ = prod * sign\n    }\n    return prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpgg1b0ft6.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpgg1b0ft6.swift:28:16: error: value of optional type 'Int?' must be\
    \ unwrapped to a value of type 'Int'\n        prod = prod * sign\n           \
    \    ^\n/tmp/tmpgg1b0ft6.swift:28:16: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        prod = prod * sign\n       \
    \        ^\n               (    ?? <#default value#>)\n/tmp/tmpgg1b0ft6.swift:28:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        prod = prod * sign\n               ^\n                   !\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n\n    for num in arr {\n        switch\
    \ num {\n        case 1:\n        case -1:\n            result = result * 1\n\
    \        default:\n            result = result * -1\n        }\n    }\n\n    return\
    \ result.isNaN ? nil : result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7jkwao9a.swift:18:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 1:\n        ^~~~~~~\n      \
    \          break\n/tmp/tmp7jkwao9a.swift:26:19: error: value of type 'Int' has\
    \ no member 'isNaN'\n    return result.isNaN ? nil : result\n           ~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var val =\
    \ 1\n    for n in arr {\n        val ^= Int((n - Int(abs(n)))/2) }\n    return\
    \ val\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkdfx8gdr/tmpkdfx8gdr.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7771933c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b777162ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b777162a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77716297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkdfx8gdr                        0x00005631bafd0859 <unavailable> + 6233

    5    libc.so.6                          0x00002b7771b1f460 __libc_start_main +
    245

    6    tmpkdfx8gdr                        0x00005631bafd03e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    for i in arr {\n        sum += Int(i) * sign(i)\n    }\n    return sum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpe9gidp9a.swift:17:25: error: cannot find 'sign' in scope\n    \
    \    sum += Int(i) * sign(i)\n                        ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n    var\
    \ sign = arr[0]\n    var product = 1\n    for i in arr {\n        if i < 0 {\n\
    \            product *= -1\n            sign *= -1\n        }\n        product\
    \ *= sign\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpondho4wt.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n\n    var\
    \ result: Int = 0\n    for i in arr {\n        if i == -1 {\n            result\
    \ -= 1\n        } else {\n            result += 1\n        }\n    }\n    return\
    \ result * prod_signs(arr.suffix(from: arr.startIndex))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpweewchzu.swift:26:21: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return result * prod_signs(arr.suffix(from:\
    \ arr.startIndex))\n                    ^\n/tmp/tmpweewchzu.swift:26:21: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    return result * prod_signs(arr.suffix(from: arr.startIndex))\n          \
    \          ^\n                    (                                          \
    \  ?? <#default value#>)\n/tmp/tmpweewchzu.swift:26:21: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    return result\
    \ * prod_signs(arr.suffix(from: arr.startIndex))\n                    ^\n    \
    \                                                            !\n/tmp/tmpweewchzu.swift:26:32:\
    \ error: missing argument label 'arr:' in call\n    return result * prod_signs(arr.suffix(from:\
    \ arr.startIndex))\n                               ^\n                       \
    \        arr: \n/tmp/tmpweewchzu.swift:26:36: error: cannot convert value of type\
    \ 'ArraySlice<Int>' to expected argument type '[Int]'\n    return result * prod_signs(arr.suffix(from:\
    \ arr.startIndex))\n                                   ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod = 1\n    var sum = 0\n    for i in 0..<arr.count {\n        sum\
    \ += arr[i]\n        prod *= sign(i) * abs(arr[i])\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpka6f1oy7.swift:21:17: error: cannot find 'sign' in scope\n    \
    \    prod *= sign(i) * abs(arr[i])\n                ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product = 1\n    for num in arr {\n        product\
    \ *= Int64(num)\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpzz8qbh02.swift:16:20: error: cannot convert value of type 'Int64'\
    \ to expected argument type 'Int'\n        product *= Int64(num)\n           \
    \        ^\n                   Int(      )\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n    let\
    \ min = min(arr)\n    var result: Int = 0\n    var product = 1\n    for num in\
    \ arr {\n        product *= num\n        result += product * (num == min ? -1\
    \ : 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpou3_b8e5.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpou3_b8e5.swift:17:22: error: missing argument for parameter #2 in\
    \ call\n    let min = min(arr)\n                     ^\n                     ,\
    \ <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public func\
    \ min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var p = arr[0]\n\
    \    for i in 1..<arr.count {\n        if p != arr[i] {\n            p -= arr[i]\n\
    \        } else {\n            p *= -1\n        }\n    }\n    return p\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp3qg0pe30/tmp3qg0pe30.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56f5b3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56f5831b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56f5831988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56f58307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3qg0pe30                        0x0000555c2c0b2619 <unavailable> + 5657

    5    libc.so.6                          0x00002b56f5d26460 __libc_start_main +
    245

    6    tmp3qg0pe30                        0x0000555c2c0b21a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum: Int = 0\n    var product: Int = 0\n    var sign:\
    \ Int = 0\n\n    for i in arr {\n        sum += sign * i\n        sign = -sign\n\
    \        product *= i\n    }\n\n    return sum == 0 ? nil : product\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmplp_ji8o8/tmplp_ji8o8.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b525f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b522e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b522e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b522e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplp_ji8o8                        0x000055cd944d7549 <unavailable> + 5449

    5    libc.so.6                          0x00002b5b527de460 __libc_start_main +
    245

    6    tmplp_ji8o8                        0x000055cd944d70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty{ return nil }\n    var signs = [0]*arr.count\n\
    \    for x in arr {\n        signs[x]++\n    }\n    var ret = 0\n    for (x,i)\
    \ in arr.enumerated() {\n        ret += x*signs[i]\n    }\n    return ret\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpu5edovgs.swift:15:20: error: binary operator '*' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n    var signs = [0]*arr.count\n     \
    \           ~~~^~~~~~~~~~\n/tmp/tmpu5edovgs.swift:15:20: note: overloads for '*'\
    \ exist with these partially matching parameter lists: (Int, Int)\n    var signs\
    \ = [0]*arr.count\n                   ^\n/tmp/tmpu5edovgs.swift:17:17: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        signs[x]++\n\
    \                ^~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty { return nil }\n    return arr.reduce(0)\
    \ { $0 * abs($1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpyh6vqc32/tmpyh6vqc32.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17f9882c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17f9579b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17f9579988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17f95787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh6vqc32                        0x00005631161d15c9 <unavailable> + 5577

    5    libc.so.6                          0x00002b17f9a6e460 __libc_start_main +
    245

    6    tmpyh6vqc32                        0x00005631161d1159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 1\n    for i in arr {\n        result = result*abs(i)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpobq0zjaf/tmpobq0zjaf.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5506f7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5506c73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5506c73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5506c727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpobq0zjaf                        0x0000559c87d95639 <unavailable> + 5689

    5    libc.so.6                          0x00002b5507168460 __libc_start_main +
    245

    6    tmpobq0zjaf                        0x0000559c87d951c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr == [] {\n        return nil\n    }\n\n    var product\
    \ = 1\n    var sign = 1\n    for n in arr {\n        product *= sign\n       \
    \ if sign == -1 {\n            product /= -1\n        }\n        sign *= n\n \
    \   }\n\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpd9s2xim2/tmpd9s2xim2.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b560a5c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b560a2b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b560a2b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b560a2b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd9s2xim2                        0x0000564e3e78d639 <unavailable> + 5689

    5    libc.so.6                          0x00002b560a7ae460 __libc_start_main +
    245

    6    tmpd9s2xim2                        0x0000564e3e78d1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product = 1\n    var magnitude = 0\n    \n    for\
    \ x in arr {\n        product *= Int(sign(x))\n        magnitude += sign(x)\n\
    \    }\n    \n    return magnitude\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpecfo3pgi.swift:18:24: error: cannot find 'sign' in scope\n    \
    \    product *= Int(sign(x))\n                       ^~~~\n/tmp/tmpecfo3pgi.swift:19:22:\
    \ error: cannot find 'sign' in scope\n        magnitude += sign(x)\n         \
    \            ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    // Sort numbers by sign\n    var arrSorted = arr.sorted()\n\
    \n    var result = 0\n    \n    for num in arrSorted {\n        // For each number\
    \ in sorted array multiply it by sign\n        switch num {\n        case 1 :\n\
    \            result += 1\n        case -1 :\n            result -= 1\n       \
    \ default :\n            result *= -1\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpc1gfl1wz/tmpc1gfl1wz.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e52cfbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e529f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e529f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e529f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1gfl1wz                        0x00005613bda0b5e9 <unavailable> + 5609

    5    libc.so.6                          0x00002b7e52ee7460 __libc_start_main +
    245

    6    tmpc1gfl1wz                        0x00005613bda0b179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product: Int? = nil\n    for x in arr {\n        product\
    \ *= Int(sign(x))\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpg8gp3vl3.swift:16:24: error: cannot find 'sign' in scope\n    \
    \    product *= Int(sign(x))\n                       ^~~~\n/tmp/tmpg8gp3vl3.swift:16:9:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        product *= Int(sign(x))\n        ^\n/tmp/tmpg8gp3vl3.swift:16:9: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        product *= Int(sign(x))\n        ^\n               !\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  var result = 0\n  guard !arr.isEmpty else { return nil }\n\
    \  for v in arr {\n    switch v {\n    case 1:\n      result += 1\n    case -1:\n\
    \      result -= 1\n    default:\n      result += v\n    }\n  }\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpffn0tlci/tmpffn0tlci.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8fee7c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8fee4b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8fee4b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8fee4b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpffn0tlci                        0x000056283be5d599 <unavailable> + 5529

    5    libc.so.6                          0x00002b8fee9ac460 __libc_start_main +
    245

    6    tmpffn0tlci                        0x000056283be5d129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard !arr.isEmpty else { return nil }\n  var prod = 1\n\
    \  var sum = 0\n  for el in arr {\n    switch el {\n    case 0:\n      sum +=\
    \ 1\n    case 1:\n      prod *= -1\n    case -1:\n      prod *= -1\n    default:\n\
    \      sum += el * prod\n    }\n  }\n  return sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmppc58it7_/tmppc58it7_.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e4c4d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e4c1cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e4c1cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e4c1ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppc58it7_                        0x000055aa43e30599 <unavailable> + 5529

    5    libc.so.6                          0x00002b2e4c6c4460 __libc_start_main +
    245

    6    tmppc58it7_                        0x000055aa43e30129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n\n    for x in arr {\n        if x < 0\
    \ {\n            return nil\n        }\n\n        switch x {\n        case 1:\n\
    \            result += 1\n        case -1:\n            result -= 1\n        default:\n\
    \            result *= -1\n        }\n    }\n\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmphfe6noo2/tmphfe6noo2.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cd9108c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cd8dffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cd8dff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cd8dfe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphfe6noo2                        0x00005577ce80b549 <unavailable> + 5449

    5    libc.so.6                          0x00002b9cd92f4460 __libc_start_main +
    245

    6    tmphfe6noo2                        0x00005577ce80b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n    arr.forEach {\n        if $0 < 0 {\n\
    \            result = 0\n        } else if $0 > 0 {\n            result = 1\n\
    \        } else {\n            result = -1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpidzc6wnl/tmpidzc6wnl.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afce3e2dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afce3b24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afce3b24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afce3b237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpidzc6wnl                        0x00005618e740e449 <unavailable> + 5193

    5    libc.so.6                          0x00002afce4019460 __libc_start_main +
    245

    6    tmpidzc6wnl                        0x00005618e740dfd9 <unavailable> + 4057

    '
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else {\n        return nil\n    }\n\
    \    var prod = 1\n    for x in arr {\n        prod *= sign(x)\n    }\n    return\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpzcpagvyz.swift:19:17: error: cannot find 'sign' in scope\n    \
    \    prod *= sign(x)\n                ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let len = arr.count\n    let sign = arr.reduce(0, combine:\
    \ +)\n    if len == 0 {\n        return nil\n    }\n    var res = sign\n    for\
    \ i in 0..<len - 1 {\n        if arr[i] < 0 {\n            res = -res\n      \
    \  }\n        if arr[i] == 0 {\n            continue\n        }\n        res =\
    \ res * arr[i]\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpduxuc5mk.swift:15:26: error: extraneous argument label 'combine:'\
    \ in call\n    let sign = arr.reduce(0, combine: +)\n                        \
    \ ^   ~~~~~~~~~\n                             \n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n    var sign = 1\n    for i in arr {\n\
    \        result += (sign * (i&1)) * magnitude(i)\n        sign *= -1\n    }\n\
    \    if result < 0 {\n        return nil\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp73zu718j.swift:17:36: error: cannot find 'magnitude' in scope\n\
    \        result += (sign * (i&1)) * magnitude(i)\n                           \
    \        ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let product = productOfSigns(arr)\n    if product == 0\
    \ { return nil }\n    var mag = 0\n    for i in arr {\n        mag += magnitudeOf(i)\
    \ * product\n    }\n    return mag\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpn09jrmij.swift:14:19: error: cannot find 'productOfSigns' in scope\n\
    \    let product = productOfSigns(arr)\n                  ^~~~~~~~~~~~~~\n/tmp/tmpn09jrmij.swift:18:16:\
    \ error: cannot find 'magnitudeOf' in scope\n        mag += magnitudeOf(i) * product\n\
    \               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sign =\
    \ arr[0]\n    for elem in arr {\n        sign = sign * elem\n    }\n    return\
    \ sign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp9ro4x8c3/tmp9ro4x8c3.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af599b6ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af599861b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af599861988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5998607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9ro4x8c3                        0x0000560ef5ef25e9 <unavailable> + 5609

    5    libc.so.6                          0x00002af599d56460 __libc_start_main +
    245

    6    tmp9ro4x8c3                        0x0000560ef5ef2179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var product = 1\n    if arr.isEmpty {\n\
    \        return nil\n    }\n    \n    for i in arr {\n        sum += abs(i)\n\
    \        product *= sign(i)\n    }\n    return sum * product\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpjz28tpje.swift:22:20: error: cannot find 'sign' in scope\n    \
    \    product *= sign(i)\n                   ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sign = 0\n    for val in arr {\n        sign *= (val\
    \ < 0) ? -1 : 1 // multiplication by -1 is equivalent to multiplying by -1\n \
    \       sign *= val // multiplication by 1 is equivalent to multiplying by 1\n\
    \    }\n    if sign == 0 {\n        return nil\n    }\n    return sign\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpbv89yjuc/tmpbv89yjuc.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b60a8e43c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60a8b3ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b60a8b3a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60a8b397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbv89yjuc                        0x0000555651342549 <unavailable> + 5449

    5    libc.so.6                          0x00002b60a902f460 __libc_start_main +
    245

    6    tmpbv89yjuc                        0x00005556513420d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let sign = arr.map { sign($0) }\n    return sign.reduce(1)\
    \ { $0 * $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpzk2o9uoe.swift:14:26: error: cannot call value of non-function\
    \ type '[T]'\n    let sign = arr.map { sign($0) }\n                         ^\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var product = 1\n    for num in arr {\n\
    \        sum += abs(num)\n        product *= (sign(num) == 0 ? 1 : -1)\n    }\n\
    \    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpv2e27v8a.swift:18:21: error: cannot find 'sign' in scope\n    \
    \    product *= (sign(num) == 0 ? 1 : -1)\n                    ^~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else {\n        return nil\n    }\n\
    \    var mag = 0\n    for num in arr {\n        mag += magify(num)\n    }\n  \
    \  return mag\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7dbnnagx.swift:19:16: error: cannot find 'magify' in scope\n  \
    \      mag += magify(num)\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1659979898
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var i = 0\n    var sign = 0\n    var mag = 0\n    var\
    \ product = 1\n    for v in arr {\n        i += 1\n        if v > 0 {\n      \
    \      sign = +1\n            mag += 1\n        } else {\n            sign = -1\n\
    \            mag -= 1\n        }\n        product *= v * sign\n    }\n    return\
    \ mag * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpoqmg0ifb/tmpoqmg0ifb.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b2b439c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b2b130b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b2b130988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b2b12f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoqmg0ifb                        0x00005598b762d549 <unavailable> + 5449

    5    libc.so.6                          0x00002b1b2b625460 __libc_start_main +
    245

    6    tmpoqmg0ifb                        0x00005598b762d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    \n    // Write your code here.\n    \n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpp2rq7hoe/tmpp2rq7hoe.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3fbbcac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3fb8c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3fb8c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3fb8c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp2rq7hoe                        0x000055cc18da93d9 <unavailable> + 5081

    5    libc.so.6                          0x00002ac3fbdb6460 __libc_start_main +
    245

    6    tmpp2rq7hoe                        0x000055cc18da8f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let prod = arr.reduce(1) { $1 * $0 }\n    let mags = arr.reduce(1)\
    \ { max($1, $0) }\n    return mags * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpf582bd_t/tmpf582bd_t.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad2999ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad29695b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad29695988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad296947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf582bd_t                        0x00005584a953e4e9 <unavailable> + 5353

    5    libc.so.6                          0x00002aad29b8a460 __libc_start_main +
    245

    6    tmpf582bd_t                        0x00005584a953e079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let minVal\
    \ = arr.min()\n    let maxVal = arr.max()\n\n    var mag = 1\n    for i in arr\
    \ {\n        mag = Int((mag * abs(i - minVal)) + 1)\n    }\n    return mag * (1\
    \ - signOf(minVal, maxVal))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp97ba6_n0.swift:20:34: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        mag = Int((mag * abs(i - minVal))\
    \ + 1)\n                                 ^\n/tmp/tmp97ba6_n0.swift:20:34: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        mag = Int((mag * abs(i - minVal)) + 1)\n                            \
    \     ^\n                                 (      ?? <#default value#>)\n/tmp/tmp97ba6_n0.swift:20:34:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        mag = Int((mag * abs(i - minVal)) + 1)\n                    \
    \             ^\n                                       !\n/tmp/tmp97ba6_n0.swift:22:23:\
    \ error: cannot find 'signOf' in scope\n    return mag * (1 - signOf(minVal, maxVal))\n\
    \                      ^~~~~~\n"
  stdout: ''
  timestamp: 1659979903
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n    for x in arr {\n        result *=\
    \ Int(x)\n        if x == -1 { result = -result }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsxuwv_nl/tmpsxuwv_nl.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d02129c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d01e20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d01e20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d01e1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsxuwv_nl                        0x0000564a79d08689 <unavailable> + 5769

    5    libc.so.6                          0x00002b5d02315460 __libc_start_main +
    245

    6    tmpsxuwv_nl                        0x0000564a79d08219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n    for x in arr {\n        let sign =\
    \ x == -x ? -1 : 0\n        result *= sign\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp4wom28b8/tmp4wom28b8.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7594b0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7594804b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7594804988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75948037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4wom28b8                        0x000055bd4715d549 <unavailable> + 5449

    5    libc.so.6                          0x00002b7594cf9460 __libc_start_main +
    245

    6    tmp4wom28b8                        0x000055bd4715d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() { return nil }\n\n    var signs: [Int]\
    \ = [0]\n\n    for el in arr {\n        signs.append(signs.last! * el)\n    }\n\
    \n    var result = 0\n    for val in signs {\n        result += val\n    }\n\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp6sjhjpzd.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() { return nil }\n           ^      ~~\n   \
    \               \n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard let first = arr[0], last = arr.last, first > last\
    \ else {\n        return nil\n    }\n    return sum(arr) + reduce(arr, { x, y\
    \ in\n        let m = x*y\n        return m == 0 ? x : (m > 0 ? 1 : -1)\n    })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpr4otvawa.swift:14:31: error: expected 'let' in conditional\n  \
    \  guard let first = arr[0], last = arr.last, first > last else {\n          \
    \                    ^\n                              let \n/tmp/tmpr4otvawa.swift:14:11:\
    \ error: initializer for conditional binding must have Optional type, not 'Int'\n\
    \    guard let first = arr[0], last = arr.last, first > last else {\n        \
    \  ^           ~~~~~~\n/tmp/tmpr4otvawa.swift:17:12: error: cannot find 'sum'\
    \ in scope\n    return sum(arr) + reduce(arr, { x, y in\n           ^~~\n/tmp/tmpr4otvawa.swift:17:23:\
    \ error: cannot find 'reduce' in scope\n    return sum(arr) + reduce(arr, { x,\
    \ y in\n                      ^~~~~~\n/tmp/tmpr4otvawa.swift:19:18: error: binary\
    \ operator '==' cannot be applied to operands of type 'Duration' and 'Int'\n \
    \       return m == 0 ? x : (m > 0 ? 1 : -1)\n               ~ ^  ~\n/tmp/tmpr4otvawa.swift:19:18:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Duration, Duration), (Int, Int)\n        return m == 0 ? x : (m > 0 ? 1 : -1)\n\
    \                 ^\n/tmp/tmpr4otvawa.swift:19:25: error: result values in '?\
    \ :' expression have mismatching types '_' and 'Int'\n        return m == 0 ?\
    \ x : (m > 0 ? 1 : -1)\n                        ^\n                        Int(\
    \ )\n/tmp/tmpr4otvawa.swift:19:30: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return m == 0 ? x : (m > 0 ? 1 : -1)\n\
    \                             ^\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n    for i in arr {\n        let x = Int(abs(i))\n\
    \        result += x * sign(x)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpfa3i60lg.swift:17:23: error: cannot find 'sign' in scope\n    \
    \    result += x * sign(x)\n                      ^~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let maxProduct = arr.reduce(0, combine: { $0 * $1 })\n\
    \    var maxMag = arr[0]\n    var signs = Int(0)\n    for v in arr {\n       \
    \ maxMag = max(maxMag, v)\n        signs = max(signs, v * signs)\n    }\n    return\
    \ signs > 0 && maxMag * maxProduct > 0 ? maxMag * maxProduct : nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpkygfi3ae.swift:14:32: error: extraneous argument label 'combine:'\
    \ in call\n    let maxProduct = arr.reduce(0, combine: { $0 * $1 })\n        \
    \                       ^   ~~~~~~~~~\n                                   \n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() { return nil }\n    var res = 1\n   \
    \ for a in arr {\n        switch a {\n        case -1:\n            res = -1\n\
    \        case 1:\n            res = -1\n        default:\n            res = a*res\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2tjojw6x.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() { return nil }\n           ^      ~~\n   \
    \               \n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n\n    var\
    \ magnitudeSum: Int = 0\n\n    for x in arr {\n        magnitudeSum += abs(x)\n\
    \    }\n\n    var productSign: Int = 0\n\n    for x in arr {\n        productSign\
    \ += sign(Int(x) * magnitudeSum)\n    }\n\n    return productSign\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3d0heyrn.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp3d0heyrn.swift:27:24: error: cannot find 'sign' in scope\n      \
    \  productSign += sign(Int(x) * magnitudeSum)\n                       ^~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var res:\
    \ Int = 0\n    guard let first = arr.removeFirst() else { return nil }\n    for\
    \ i in 0 ..< arr.count {\n        guard i != first else { return nil }\n     \
    \   let sign = arr[i] > 0 ? 1 : -1\n        res += sign * i\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmph0uaui_h.swift:16:27: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    guard let first = arr.removeFirst() else\
    \ { return nil }\n                      ~~~ ^\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var ret = arr[0] // start from first elem of arr\n   \
    \ var i = 1 // increment index\n    for elem in arr {\n        if elem < 0 {\n\
    \            ret = -ret\n        } else {\n            ret = ret * elem\n    \
    \    }\n        i += 1\n    }\n    if i == arr.count { return nil }\n    return\
    \ ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp7nmmke93/tmp7nmmke93.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac958d76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac958a6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac958a6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac958a6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7nmmke93                        0x00005570822185f9 <unavailable> + 5625

    5    libc.so.6                          0x00002ac958f62460 __libc_start_main +
    245

    6    tmp7nmmke93                        0x0000557082218189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let res =\
    \ 0\n    var tmp = 0\n    for x in arr {\n        if x < 0 {\n            tmp\
    \ = -tmp\n        } else {\n            tmp = tmp\n        }\n        res += tmp\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1kkb5yjq.swift:21:17: error: assigning a variable to itself\n \
    \           tmp = tmp\n            ~~~ ^ ~~~\n/tmp/tmp1kkb5yjq.swift:23:13: error:\
    \ left side of mutating operator isn't mutable: 'res' is a 'let' constant\n  \
    \      res += tmp\n        ~~~ ^\n/tmp/tmp1kkb5yjq.swift:15:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let res = 0\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n  var result = arr[0]\n\
    \  for _ in 1...arr.count {\n    result = ((result * arr[0]) + arr[0]) == 0 ?\
    \ arr[0] : ((result * arr[0]) - arr[0])\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpwjqla2ar/tmpwjqla2ar.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acfeaca3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acfea99ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acfea99a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acfea9997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwjqla2ar                        0x000055d578c9c6a9 <unavailable> + 5801

    5    libc.so.6                          0x00002acfeae8f460 __libc_start_main +
    245

    6    tmpwjqla2ar                        0x000055d578c9c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    // TODO: Try to do it in O(n) time and O(1) space.\n \
    \   guard !arr.isEmpty else { return nil }\n    var sign = 1\n    for n in arr\
    \ {\n        if n < 0 {\n            sign *= -1\n        }\n    }\n    return\
    \ sign * product_sign(arr)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpy8juokg8.swift:22:19: error: cannot find 'product_sign' in scope\n\
    \    return sign * product_sign(arr)\n                  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var res = arr[0]\n    for x in arr {\n        if x >=\
    \ 0 {\n            res *= x\n        } else if x <= 0 {\n            res /= x\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpbxmk3q7c/tmpbxmk3q7c.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac17c859c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac17c550b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac17c550988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac17c54f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbxmk3q7c                        0x000055ed69b57629 <unavailable> + 5673

    5    libc.so.6                          0x00002ac17ca45460 __libc_start_main +
    245

    6    tmpbxmk3q7c                        0x000055ed69b571b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else {\n        return nil\n    }\n\
    \n    var res = 0\n    for v in arr {\n        res += v * prod_signs(arr: arr.filter{$0\
    \ != v})\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpse32jro0.swift:20:20: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        res += v * prod_signs(arr: arr.filter{$0\
    \ != v})\n                   ^\n/tmp/tmpse32jro0.swift:20:20: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        res\
    \ += v * prod_signs(arr: arr.filter{$0 != v})\n                   ^\n        \
    \           (                                    ?? <#default value#>)\n/tmp/tmpse32jro0.swift:20:20:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        res += v * prod_signs(arr: arr.filter{$0 != v})\n           \
    \        ^\n                                                       !\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var arrSum = 0\n    for elem in arr {\n        arrSum += abs(elem) * abs(elem)\n\
    \    }\n    return arrSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp0lwcf7o2/tmp0lwcf7o2.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2b310bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2b2e02b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2b2e02988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2b2e017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0lwcf7o2                        0x0000563d5af5b689 <unavailable> + 5769

    5    libc.so.6                          0x00002ad2b32f7460 __libc_start_main +
    245

    6    tmp0lwcf7o2                        0x0000563d5af5b219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sign\
    \ = 0\n    var product = 1\n    for num in arr {\n        sign *= Int(sign ==\
    \ 0 ? -abs(num) : abs(num))\n        product *= Int(sign == 0)\n    }\n    return\
    \ sign == 0 ? product : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxdixaxks.swift:19:20: error: no exact matches in call to initializer\
    \ \n        product *= Int(sign == 0)\n                   ^\nSwift.Int:7:12: note:\
    \ candidate expects value of type 'Float16' for parameter #1 (got 'Bool')\n  \
    \  public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Bool')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects value\
    \ of type 'Double' for parameter #1 (got 'Bool')\n    public init(_ source: Double)\n\
    \           ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80'\
    \ for parameter #1 (got 'Bool')\n    public init(_ source: Float80)\n        \
    \   ^\nSwift.Int:28:12: note: candidate expects value of type 'Builtin.Int64'\
    \ for parameter #1 (got 'Bool')\n    public init(_ _value: Builtin.Int64)\n  \
    \         ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'Bool')\n    public init(_ _v: Builtin.Word)\n       \
    \    ^\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr == nil {\n        return nil\n    }\n\n    var\
    \ sum = 0\n    for v in arr {\n        sum += v * sign(v)\n    }\n    return sum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmps6yn0tnf.swift:14:12: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if arr == nil {\n       ~~~\
    \ ^  ~~~\n/tmp/tmps6yn0tnf.swift:20:20: error: cannot find 'sign' in scope\n \
    \       sum += v * sign(v)\n                   ^~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product: Int = 1\n    var sign: Int = 0\n    for num\
    \ in arr {\n        product *= num\n        sign *= num > 0 ? 1 : -1\n    }\n\
    \    return product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkfuvotpy/tmpkfuvotpy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd22282c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd21f79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd21f79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd21f787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkfuvotpy                        0x00005611f6688549 <unavailable> + 5449

    5    libc.so.6                          0x00002acd2246e460 __libc_start_main +
    245

    6    tmpkfuvotpy                        0x00005611f66880d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var product\
    \ = 1\n    for x in arr {\n        let sign = Int(sign(x))\n        product *=\
    \ sign\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpbtuawfgw.swift:17:24: error: use of local variable 'sign' before\
    \ its declaration\n        let sign = Int(sign(x))\n                       ^\n\
    /tmp/tmpbtuawfgw.swift:17:13: note: 'sign' declared here\n        let sign = Int(sign(x))\n\
    \            ^\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = Int()\n    var sign = 1\n    for i in arr\
    \ {\n        result *= sign\n        result -= sign * i\n        sign *= -1\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpno35l6r9/tmpno35l6r9.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4205874c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b420556bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b420556b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b420556a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpno35l6r9                        0x000055b66e462549 <unavailable> + 5449

    5    libc.so.6                          0x00002b4205a60460 __libc_start_main +
    245

    6    tmpno35l6r9                        0x000055b66e4620d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.map(sign).reduce(0, combine: +)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpcuy_otli.swift:14:20: error: cannot find 'sign' in scope\n    return\
    \ arr.map(sign).reduce(0, combine: +)\n                   ^~~~\n/tmp/tmpcuy_otli.swift:14:32:\
    \ error: extraneous argument label 'combine:' in call\n    return arr.map(sign).reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmpcuy_otli.swift:14:20: error: converting non-escaping\
    \ value to '(Int) throws -> Int' may allow it to escape\n    return arr.map(sign).reduce(0,\
    \ combine: +)\n                   ^\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard !arr.isEmpty else { return nil }\n  \n  var res =\
    \ 1\n  \n  for num in arr {\n    if num < 0 {\n      res *= -1\n    } else {\n\
    \      res += num\n    }\n  }\n  \n  return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp3x519key/tmp3x519key.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7932b23c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b793281ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b793281a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79328197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3x519key                        0x00005578d1ff3599 <unavailable> + 5529

    5    libc.so.6                          0x00002b7932d0f460 __libc_start_main +
    245

    6    tmp3x519key                        0x00005578d1ff3129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let product\
    \ = arr.reduce(1) { $1 * $0 }\n    guard product > 0 else { return nil }\n   \
    \ return product * (arr.map({ return $0 > 0 ? 1 : -1 }).reduce(1) { $0 + $1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpnxxwo2g7/tmpnxxwo2g7.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af44408ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af443d81b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af443d81988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af443d807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxxwo2g7                        0x0000558478c13559 <unavailable> + 5465

    5    libc.so.6                          0x00002af444276460 __libc_start_main +
    245

    6    tmpnxxwo2g7                        0x0000558478c130e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var product = 1\n    for el in arr {\n\
    \        sum += abs(el)\n        product *= (el < 0 ? -1 : 1) * Int(el < 0)\n\
    \    }\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpymw63azh.swift:18:40: error: no exact matches in call to initializer\
    \ \n        product *= (el < 0 ? -1 : 1) * Int(el < 0)\n                     \
    \                  ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16'\
    \ for parameter #1 (got 'Bool')\n    public init(_ source: Float16)\n        \
    \   ^\nSwift.Int:10:12: note: candidate expects value of type 'Float' for parameter\
    \ #1 (got 'Bool')\n    public init(_ source: Float)\n           ^\nSwift.Int:12:12:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'Bool')\n\
    \    public init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate\
    \ expects value of type 'Float80' for parameter #1 (got 'Bool')\n    public init(_\
    \ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value\
    \ of type 'Builtin.Int64' for parameter #1 (got 'Bool')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got 'Bool')\n    public init(_ _v:\
    \ Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n\n    var product:\
    \ Int? = nil\n    var sign: Int = 0\n\n    for n in arr {\n        if n == n {\n\
    \            sign = 1\n        } else if n == -n! {\n            sign = -1\n \
    \       } else {\n            product = product * sign\n            sign = 1\n\
    \        }\n    }\n\n    if product == nil {\n        product = 0\n        sign\
    \ = 1\n    }\n\n    return product * sign\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpjmlve_5e.swift:22:26: error: cannot force unwrap value of non-optional\
    \ type 'Int'\n        } else if n == -n! {\n                        ~^\n     \
    \                    \n/tmp/tmpjmlve_5e.swift:25:23: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n            product\
    \ = product * sign\n                      ^\n/tmp/tmpjmlve_5e.swift:25:23: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \            product = product * sign\n                      ^\n             \
    \         (       ?? <#default value#>)\n/tmp/tmpjmlve_5e.swift:25:23: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \    product = product * sign\n                      ^\n                     \
    \        !\n/tmp/tmpjmlve_5e.swift:35:12: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n    return product * sign\n    \
    \       ^\n/tmp/tmpjmlve_5e.swift:35:12: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    return product * sign\n\
    \           ^\n           (       ?? <#default value#>)\n/tmp/tmpjmlve_5e.swift:35:12:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return product * sign\n           ^\n                  !\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \n    var prod = 1\n    for n in arr {\n        switch n {\n        case 0:\n\
    \            prod *= -1\n        case 1:\n            prod *= 1\n        default:\n\
    \            prod *= 0\n        }\n    }\n    return prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmprluj3u1u/tmprluj3u1u.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bd2472c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bd2169b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bd2169988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bd21687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprluj3u1u                        0x0000558356b9a599 <unavailable> + 5529

    5    libc.so.6                          0x00002b3bd265e460 __libc_start_main +
    245

    6    tmprluj3u1u                        0x0000558356b9a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n  var signs = 0\n\
    \  var product = 1\n  var result = 0\n  for elt in arr {\n    switch elt {\n \
    \   case 1:\n      signs = signs + 1\n    case -1:\n      signs = signs - 1\n\
    \    case 0:\n      break\n    default:\n      product = product * elt\n    }\n\
    \  }\n  result = signs * product\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmplveij8k_/tmplveij8k_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b441d0eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b441cde1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b441cde1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b441cde07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplveij8k_                        0x000055ccc6162599 <unavailable> + 5529

    5    libc.so.6                          0x00002b441d2d6460 __libc_start_main +
    245

    6    tmplveij8k_                        0x000055ccc6162129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sign =\
    \ 1\n    var product = 1\n    for number in arr {\n        product *= sign\n \
    \       sign *= number\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpiim9_0yz/tmpiim9_0yz.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b79b3ca5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b79b399cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b79b399c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79b399b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiim9_0yz                        0x0000561e19f6f599 <unavailable> + 5529

    5    libc.so.6                          0x00002b79b3e91460 __libc_start_main +
    245

    6    tmpiim9_0yz                        0x0000561e19f6f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var product\
    \ = 1\n    for i in arr {\n        product *= Int(i)\n    }\n    let sum = (-1)\
    \ * product\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmprnq9ep8r/tmprnq9ep8r.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adceafadc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adceaca4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adceaca4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adceaca37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprnq9ep8r                        0x000055d1369966d9 <unavailable> + 5849

    5    libc.so.6                          0x00002adceb199460 __libc_start_main +
    245

    6    tmprnq9ep8r                        0x000055d136996269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  var result = 0\n  for element in arr {\n    if element ==\
    \ 0 {\n      return nil\n    }\n    if element > 0 {\n      result += 1\n    }\n\
    \    if element < 0 {\n      result += -1\n    }\n  }\n  return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp7h8res5o/tmp7h8res5o.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b573c48cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b573c183b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b573c183988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b573c1827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7h8res5o                        0x00005636d4696549 <unavailable> + 5449

    5    libc.so.6                          0x00002b573c678460 __libc_start_main +
    245

    6    tmp7h8res5o                        0x00005636d46960d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product = 1\n    for el in arr {\n        product\
    \ *= signInt(el)\n    }\n    return product\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2bxru72f.swift:16:20: error: cannot find 'signInt' in scope\n \
    \       product *= signInt(el)\n                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.isEmpty == false else { return nil }\n    guard\
    \ arr.count > 0 else {\n        return nil\n    }\n    let min = arr[0]\n    var\
    \ prod = 1\n    for i in 1..<arr.count {\n        if arr[i] < min {\n        \
    \    min = arr[i]\n        }\n        prod *= (i * -1)\n    }\n    return min\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpa21enkye.swift:22:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = arr[i]\n            ^~~\n/tmp/tmpa21enkye.swift:18:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = arr[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.isEmpty == false else {\n        return nil\n\
    \    }\n    var product = 1\n    for element in arr {\n        product *= element\n\
    \    }\n    let mag = arr.map{ $0.abs().squared() }\n    return mag.reduce(0,\
    \ combine: +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpa_alnsmw.swift:21:27: error: value of type 'Int' has no member\
    \ 'abs'\n    let mag = arr.map{ $0.abs().squared() }\n                       ~~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr == nil || arr.isEmpty {\n        return nil\n \
    \   }\n\n    var product = 1\n    var signs = [Int]()\n\n    for item in arr {\n\
    \        product *= item\n        signs.append(item > 0)\n    }\n\n    return\
    \ product * signs.reduce(1, *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpa2c_0vik.swift:14:12: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if arr == nil || arr.isEmpty\
    \ {\n       ~~~ ^  ~~~\n/tmp/tmpa2c_0vik.swift:23:27: error: cannot convert value\
    \ of type 'Bool' to expected argument type 'Int'\n        signs.append(item >\
    \ 0)\n                          ^\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 0\n    var sign = 1\n    for el in arr {\n\
    \        result += sign * el\n        sign *= -1\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp5fjms43p/tmp5fjms43p.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2d109c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2d106bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2d106bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2d106be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5fjms43p                        0x0000562937f1a549 <unavailable> + 5449

    5    libc.so.6                          0x00002b2d10bb4460 __libc_start_main +
    245

    6    tmp5fjms43p                        0x0000562937f1a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod: Int = 0\n    for i in arr {\n        prod *=\
    \ i / abs(i)\n    }\n    return prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsqs15jfo/tmpsqs15jfo.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84f026ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84eff65b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84eff65988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84eff647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsqs15jfo                        0x000055994f9c66c9 <unavailable> + 5833

    5    libc.so.6                          0x00002b84f045a460 __libc_start_main +
    245

    6    tmpsqs15jfo                        0x000055994f9c6259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var result\
    \ = 0\n    for n in arr {\n        result *= abs(n)\n        if n > 0 {\n    \
    \        result += sign(n) * sign(n)\n        } else {\n            result +=\
    \ sign(n) * -sign(n)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj2_hkkkr.swift:21:23: error: cannot find 'sign' in scope\n    \
    \        result += sign(n) * sign(n)\n                      ^~~~\n/tmp/tmpj2_hkkkr.swift:21:33:\
    \ error: cannot find 'sign' in scope\n            result += sign(n) * sign(n)\n\
    \                                ^~~~\n/tmp/tmpj2_hkkkr.swift:23:23: error: cannot\
    \ find 'sign' in scope\n            result += sign(n) * -sign(n)\n           \
    \           ^~~~\n/tmp/tmpj2_hkkkr.swift:23:34: error: cannot find 'sign' in scope\n\
    \            result += sign(n) * -sign(n)\n                                 ^~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result: Int? = nil\n    for i in arr {\n        let\
    \ mul = signOf(i) * signOf(i)\n        if mul > 0 {\n            result! *= mul\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpea4_zf04.swift:16:19: error: cannot find 'signOf' in scope\n  \
    \      let mul = signOf(i) * signOf(i)\n                  ^~~~~~\n/tmp/tmpea4_zf04.swift:16:31:\
    \ error: cannot find 'signOf' in scope\n        let mul = signOf(i) * signOf(i)\n\
    \                              ^~~~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty() {\n    return nil\n  }\n  var result =\
    \ 0\n  arr.forEach {\n    let value = $0\n    switch value {\n    case 1:\n  \
    \    result = result + 1\n    case -1:\n      result = result - 1\n    case 0:\n\
    \      break\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpkuj5a2kg.swift:14:10: error: cannot call value of non-function\
    \ type 'Bool'\n  if arr.isEmpty() {\n         ^      ~~\n                \n/tmp/tmpkuj5a2kg.swift:20:5:\
    \ error: switch must be exhaustive\n    switch value {\n    ^\n/tmp/tmpkuj5a2kg.swift:20:5:\
    \ note: do you want to add a default clause?\n    switch value {\n    ^\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.reduce(0)\n        .flatMap { prod -> Int?\
    \ in\n            return arr.map { $0 * $0 }.filter { $0 > 0 }.reduce(prod)\n\
    \        }\n        ?? nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpe3iqjiam.swift:16:69: error: missing argument for parameter #2\
    \ in call\n            return arr.map { $0 * $0 }.filter { $0 > 0 }.reduce(prod)\n\
    \                                                                    ^\n     \
    \                                                               , <#(Int?, Int)\
    \ throws -> Int?#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n    @inlinable\
    \ public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_\
    \ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n/tmp/tmpe3iqjiam.swift:14:24: error: missing argument\
    \ for parameter #2 in call\n    return arr.reduce(0)\n                       ^\n\
    \                       , <#(Int, Int) throws -> Int#>\nSwift.Sequence:2:28: note:\
    \ 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n/tmp/tmpe3iqjiam.swift:15:10:\
    \ error: value of type 'Int' has no member 'flatMap'\n        .flatMap { prod\
    \ -> Int? in\n         ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979912
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n  var signSum = 0\n\
    \  var product = 1\n  for v in arr {\n    signSum += v\n    product *= v\n  }\n\
    \  return signSum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpa0m2imca/tmpa0m2imca.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d10ce5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d109dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d109dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d109db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa0m2imca                        0x000056195457b599 <unavailable> + 5529

    5    libc.so.6                          0x00002b6d10ed1460 __libc_start_main +
    245

    6    tmpa0m2imca                        0x000056195457b129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var signs: [Int] = [0]\n    var product = 1\n    for val\
    \ in arr {\n        signs.append(val < 0 ? 1 : -1)\n        product *= val\n \
    \   }\n    return product % 2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmprp50pj3b/tmprp50pj3b.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae82499bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae824692b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae824692988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8246917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprp50pj3b                        0x0000560634641639 <unavailable> + 5689

    5    libc.so.6                          0x00002ae824b87460 __libc_start_main +
    245

    6    tmprp50pj3b                        0x00005606346411c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var res = arr[0]\n    for index in 1..<arr.count {\n \
    \       let sign = arr[index] < 0 ? '-' : '+'\n        res *= sign\n        if\
    \ res > arr[index] {\n            res = arr[index]\n        }\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmplfah48tt.swift:16:37: error: single-quoted string literal found,\
    \ use '\"'\n        let sign = arr[index] < 0 ? '-' : '+'\n                  \
    \                  ^~~\n                                    \"-\"\n/tmp/tmplfah48tt.swift:16:43:\
    \ error: single-quoted string literal found, use '\"'\n        let sign = arr[index]\
    \ < 0 ? '-' : '+'\n                                          ^~~\n           \
    \                               \"+\"\n/tmp/tmplfah48tt.swift:17:16: error: cannot\
    \ convert value of type 'String' to expected argument type 'Int'\n        res\
    \ *= sign\n               ^\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let sum = arr.map { pow($0, -1) }.reduce(0, +)\n    let\
    \ product = arr.map { pow($0, 1) }.reduce(0, *)\n    if product == 0 || product\
    \ == 0 {\n        return nil\n    }\n    return sum * product\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz82q4i9r.swift:14:25: error: cannot find 'pow' in scope\n    let\
    \ sum = arr.map { pow($0, -1) }.reduce(0, +)\n                        ^~~\n/tmp/tmpz82q4i9r.swift:15:29:\
    \ error: cannot find 'pow' in scope\n    let product = arr.map { pow($0, 1) }.reduce(0,\
    \ *)\n                            ^~~\n/tmp/tmpz82q4i9r.swift:19:16: error: cannot\
    \ convert return expression of type 'Duration' to return type 'Int?'\n    return\
    \ sum * product\n           ~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty,\n        let res = arr.filter { $0\
    \ != 0 }.fold(0) { $0 * $1 }\n    else {\n        return nil\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpo976_8q3.swift:15:50: error: expected 'else' after 'guard' condition\n\
    \        let res = arr.filter { $0 != 0 }.fold(0) { $0 * $1 }\n              \
    \                                   ^\n                                      \
    \           else \n/tmp/tmpo976_8q3.swift:15:52: error: anonymous closure argument\
    \ not contained in a closure\n        let res = arr.filter { $0 != 0 }.fold(0)\
    \ { $0 * $1 }\n                                                   ^\n/tmp/tmpo976_8q3.swift:15:57:\
    \ error: anonymous closure argument not contained in a closure\n        let res\
    \ = arr.filter { $0 != 0 }.fold(0) { $0 * $1 }\n                             \
    \                           ^\n/tmp/tmpo976_8q3.swift:16:5: error: expected expression\n\
    \    else {\n    ^\n/tmp/tmpo976_8q3.swift:15:42: error: value of type '[Int]'\
    \ has no member 'fold'\n        let res = arr.filter { $0 != 0 }.fold(0) { $0\
    \ * $1 }\n                  ~~~~~~~~~~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 1\n    for x in arr {\n        result *=\
    \ sign(x)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmps0llxrm8.swift:16:19: error: cannot find 'sign' in scope\n    \
    \    result *= sign(x)\n                  ^~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum: Int = 0\n    var product: Int = 0\n    for v\
    \ in arr {\n        sum += v * Int(isSign(v))\n        product *= Int(isSign(v))\n\
    \    }\n    return sum == 0 || product == 0 ? nil : sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp6c2zhsv2.swift:17:24: error: cannot find 'isSign' in scope\n  \
    \      sum += v * Int(isSign(v))\n                       ^~~~~~\n/tmp/tmp6c2zhsv2.swift:18:24:\
    \ error: cannot find 'isSign' in scope\n        product *= Int(isSign(v))\n  \
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 1\n    for x in arr {\n        switch x {\n\
    \        case -1: result *= -1\n        case 0: break\n        default: result\
    \ *= x\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp18jwnhe7/tmp18jwnhe7.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b850739ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8507095b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8507095988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b85070947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp18jwnhe7                        0x00005635052e7549 <unavailable> + 5449

    5    libc.so.6                          0x00002b850758a460 __libc_start_main +
    245

    6    tmp18jwnhe7                        0x00005635052e70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n\n    var result\
    \ = arr[0]\n    for _ in 1..<arr.count {\n        switch result {\n        case\
    \ .Some(let mult):\n            result = mult\n        case .None:\n         \
    \   guard let _ = arr.popLast() else { continue }\n        }\n    }\n\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7kxr5jdc.swift:19:15: error: type 'Int' has no member 'Some'\n\
    \        case .Some(let mult):\n             ~^~~~\n/tmp/tmp7kxr5jdc.swift:21:15:\
    \ error: type 'Int' has no member 'None'\n        case .None:\n             ~^~~~\n\
    /tmp/tmp7kxr5jdc.swift:22:31: error: cannot use mutating member on immutable value:\
    \ 'arr' is a 'let' constant\n            guard let _ = arr.popLast() else { continue\
    \ }\n                          ~~~ ^\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result = 1\n    for i in arr {\n        if i&1 ==\
    \ 1 {\n            result *= i\n        } else {\n            result *= -1\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpszo12f4a/tmpszo12f4a.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7be9a64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7be975bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7be975b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7be975a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszo12f4a                        0x000055fe864e0549 <unavailable> + 5449

    5    libc.so.6                          0x00002b7be9c50460 __libc_start_main +
    245

    6    tmpszo12f4a                        0x000055fe864e00d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard let arr = arr else {\n        return nil\n    }\n\
    \n    var product: Int = 0\n    var mag = 0\n    var sign = 1\n    for num in\
    \ arr {\n        mag += mag\n        product *= sign\n        if num != 0 {\n\
    \            product *= num\n        }\n        sign *= -1\n    }\n    return\
    \ mag * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp67pzri_4.swift:14:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let arr = arr else {\n     \
    \     ^         ~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var magnitude:\
    \ Int = 0\n    var sign = 1\n    for i in arr {\n        magnitude += sign * i\n\
    \        sign *= sign\n    }\n    return magnitude\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpiaojmalb/tmpiaojmalb.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b042cf99c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b042cc90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b042cc90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b042cc8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiaojmalb                        0x000055a5804a6599 <unavailable> + 5529

    5    libc.so.6                          0x00002b042d185460 __libc_start_main +
    245

    6    tmpiaojmalb                        0x000055a5804a6129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var res = 1\n    for x in arr {\n        if x < 0 {\n\
    \            res *= -1\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp3vqndccb/tmp3vqndccb.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a19123c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a18e1ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a18e1a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a18e197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3vqndccb                        0x000055f8533f4549 <unavailable> + 5449

    5    libc.so.6                          0x00002b8a1930f460 __libc_start_main +
    245

    6    tmp3vqndccb                        0x000055f8533f40d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var signs\
    \ = 0\n    var mag = 0\n    for x in arr {\n        mag += x\n        signs +=\
    \ 1\n    }\n    return mag * signs\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpj8_xp0yh/tmpj8_xp0yh.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae99bc87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae99b97eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae99b97e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae99b97d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj8_xp0yh                        0x000055f284f79599 <unavailable> + 5529

    5    libc.so.6                          0x00002ae99be73460 __libc_start_main +
    245

    6    tmpj8_xp0yh                        0x000055f284f79129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n\n    var\
    \ signs = [Int]()\n    var product = 1\n    var magnitude = 0\n\n    for x in\
    \ arr {\n        switch x {\n        case 1:\n            signs.append(1)\n  \
    \          magnitude += 1\n        case -1:\n            signs.append(-1)\n  \
    \          magnitude += 1\n        default:\n            signs.append(0)\n   \
    \         magnitude += 1\n        }\n\n        product *= signs.last!\n    }\n\
    \n    return magnitude*product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp80hu5zle/tmp80hu5zle.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0548c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0545b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0545b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0545b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp80hu5zle                        0x0000564ac442e779 <unavailable> + 6009

    5    libc.so.6                          0x00002ab054aac460 __libc_start_main +
    245

    6    tmp80hu5zle                        0x0000564ac442e309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.isEmpty else { return nil }\n    var result\
    \ = 0\n    for val in arr {\n        let sign = val < 0 ? 1 : -1\n        let\
    \ magnitude = abs(val)\n        result *= sign\n        result -= magnitude\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmplsrabd7s/tmplsrabd7s.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69d6f8ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69d6c81b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69d6c81988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69d6c807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplsrabd7s                        0x0000564d5e47e689 <unavailable> + 5769

    5    libc.so.6                          0x00002b69d7176460 __libc_start_main +
    245

    6    tmplsrabd7s                        0x0000564d5e47e219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    // write your code in Swift 4.2\n    if arr.isEmpty {\n\
    \        return nil\n    }\n\n    var product = 1\n    var magnitude: Int = 0\n\
    \n    for i in arr {\n        magnitude = magnitude * i\n    }\n\n    for i in\
    \ arr {\n        product = product * i\n    }\n\n    return magnitude\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpu_yz6tdk/tmpu_yz6tdk.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5e4d42cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5e4d123b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5e4d123988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5e4d1227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu_yz6tdk                        0x000055f0b86bd599 <unavailable> + 5529

    5    libc.so.6                          0x00002b5e4d618460 __libc_start_main +
    245

    6    tmpu_yz6tdk                        0x000055f0b86bd129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod: Int = 0\n    var mag: Int = 0\n    var sign:\
    \ Int = 0\n    for n in arr {\n        prod *= n\n        mag += abs(n)\n    \
    \    sign *= n\n    }\n    if mag == 0 {\n        return nil\n    }\n    return\
    \ mag * sign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp3p6ezqt3/tmp3p6ezqt3.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba8e4eb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8e4baeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8e4bae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8e4bad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3p6ezqt3                        0x00005591bc80d639 <unavailable> + 5689

    5    libc.so.6                          0x00002ba8e50a3460 __libc_start_main +
    245

    6    tmp3p6ezqt3                        0x00005591bc80d1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n\n    var prod\
    \ = 1\n    for x in arr {\n        prod = x * prod\n    }\n\n    return prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpm0sa9gwz/tmpm0sa9gwz.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe3c0d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe3bdc9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe3bdc9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe3bdc87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm0sa9gwz                        0x000055b89b902599 <unavailable> + 5529

    5    libc.so.6                          0x00002afe3c2be460 __libc_start_main +
    245

    6    tmpm0sa9gwz                        0x000055b89b902129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n    var\
    \ sum = 0\n    var sign = 1\n    for el in arr {\n        sum += sign * el\n \
    \       sign = -sign\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwvfersuu.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.isEmpty == false else { return nil }\n    let\
    \ mut res = Int()\n    for i in arr {\n        if i > 0 { res = res * i }\n  \
    \  }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9nbi_z9v.swift:15:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut res = Int()\n\
    \            ^\n/tmp/tmp9nbi_z9v.swift:15:13: note: join the identifiers together\n\
    \    let mut res = Int()\n        ~~~~^~~\n        mutres\n/tmp/tmp9nbi_z9v.swift:15:13:\
    \ note: join the identifiers together with camel-case\n    let mut res = Int()\n\
    \        ~~~~^~~\n        mutRes\n/tmp/tmp9nbi_z9v.swift:17:20: error: cannot\
    \ find 'res' in scope\n        if i > 0 { res = res * i }\n                  \
    \ ^~~\n/tmp/tmp9nbi_z9v.swift:17:26: error: cannot find 'res' in scope\n     \
    \   if i > 0 { res = res * i }\n                         ^~~\n/tmp/tmp9nbi_z9v.swift:19:12:\
    \ error: cannot find 'res' in scope\n    return res\n           ^~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sign = 1\n    var sum: Int = 0\n    var product: Int\
    \ = 0\n    var i = 0\n    var n = arr.count\n\n    while i < n {\n        product\
    \ = product * sign\n        sign *= arr[i]\n        sum += sign * arr[i]\n   \
    \     i += 1\n    }\n    return sum == 0 ? nil : sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmphcaod80b/tmphcaod80b.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba4b5aa2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba4b5799b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba4b5799988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba4b57987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphcaod80b                        0x0000559f44b83489 <unavailable> + 5257

    5    libc.so.6                          0x00002ba4b5c8e460 __libc_start_main +
    245

    6    tmphcaod80b                        0x0000559f44b83019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    for elem in arr {\n        prod*=elem\n    }\n    let maxMagnitude\
    \ = (prod/2) as Int\n    var mag1 = -1\n    var mag2 = -1\n    var mag3 = -1\n\
    \    var mag4 = -1\n    var sumMag = 0\n    for elem in arr {\n        mag = (elem\
    \ as Int)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n  \
    \      mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppl5h8r4i.swift:85:44: error: expected '}' at end of brace statement\n\
    assert(prod_signs(arr: [-1, 1, 1, 0]) == 0)\n                                \
    \           ^\n/tmp/tmppl5h8r4i.swift:13:37: note: to match this opening '{'\n\
    func prod_signs(arr: [Int]) -> Int? {\n                                    ^\n\
    /tmp/tmppl5h8r4i.swift:28:9: error: cannot find 'mag' in scope\n        mag =\
    \ (elem as Int)\n        ^~~\n/tmp/tmppl5h8r4i.swift:29:9: error: cannot find\
    \ 'mag' in scope\n        mag*=(mag+mag+mag+mag)\n        ^~~\n/tmp/tmppl5h8r4i.swift:29:15:\
    \ error: cannot find 'mag' in scope\n        mag*=(mag+mag+mag+mag)\n        \
    \      ^~~\n/tmp/tmppl5h8r4i.swift:29:19: error: cannot find 'mag' in scope\n\
    \        mag*=(mag+mag+mag+mag)\n                  ^~~\n/tmp/tmppl5h8r4i.swift:29:23:\
    \ error: cannot find 'mag' in scope\n        mag*=(mag+mag+mag+mag)\n        \
    \              ^~~\n/tmp/tmppl5h8r4i.swift:29:27: error: cannot find 'mag' in\
    \ scope\n        mag*=(mag+mag+mag+mag)\n                          ^~~\n/tmp/tmppl5h8r4i.swift:30:9:\
    \ error: cannot find 'mag' in scope\n        mag*=(mag+mag+mag+mag)\n        ^~~\n\
    /tmp/tmppl5h8r4i.swift:30:15: error: cannot find 'mag' in scope\n        mag*=(mag+mag+mag+mag)\n\
    \              ^~~\n/tmp/tmppl5h8r4i.swift:30:19: error: cannot find 'mag' in\
    \ scope\n        mag*=(mag+mag+mag+mag)\n                  ^~~\n/tmp/tmppl5h8r4i.swift:30:23:\
    \ error: cannot find 'mag' in scope\n        mag*=(mag+mag+mag+mag)\n        \
    \              ^~~\n/tmp/tmppl5h8r4i.swift:30:27: error: cannot find 'mag' in\
    \ scope\n        mag*=(mag+mag+mag+mag)\n                          ^~~\n/tmp/tmppl5h8r4i.swift:31:9:\
    \ error: cannot find 'mag' in scope\n        mag*=(mag+mag+mag+mag)\n        ^~~\n\
    /tmp/tmppl5h8r4i.swift:31:15: error: cannot find 'mag' in scope\n        mag*=(mag+mag+mag+mag)\n\
    \              ^~~\n/tmp/tmppl5h8r4i.swift:31:19: error: cannot find 'mag' in\
    \ scope\n        mag*=(mag+mag+mag+mag)\n                  ^~~\n/tmp/tmppl5h8r4i.swift:31:23:\
    \ error: cannot find 'mag' in scope\n        mag*=(mag+mag+mag+mag)\n        \
    \              ^~~\n/tmp/tmppl5h8r4i.swif"
  stdout: ''
  timestamp: 1659979937
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var p = Int()\n    for i in arr {\n        p = i * p\n\
    \    }\n    if p == Int(0) {\n        return nil\n    }\n    return Int(p)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpyrjqll6a/tmpyrjqll6a.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab155b5dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab155854b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab155854988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1558537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyrjqll6a                        0x0000562df9814689 <unavailable> + 5769

    5    libc.so.6                          0x00002ab155d49460 __libc_start_main +
    245

    6    tmpyrjqll6a                        0x0000562df9814219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod = 0\n    for i in arr {\n        prod *= i\n\
    \    }\n\n    var sign = 1\n    for i in arr {\n        sign *= i\n    }\n\n \
    \   return sign * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpp5_j3mwz/tmpp5_j3mwz.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77ba90ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77ba605b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77ba605988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77ba6047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp5_j3mwz                        0x00005607db77d549 <unavailable> + 5449

    5    libc.so.6                          0x00002b77baafa460 __libc_start_main +
    245

    6    tmpp5_j3mwz                        0x00005607db77d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sign = Int()\n    var prod = Int()\n    if arr ==\
    \ [] || arr == nil {\n        return nil\n    }\n    for val in arr {\n      \
    \  sign = val < 0 ? -1 : val > 0 ? 1 : 0\n        prod *= sign\n    }\n    return\
    \ prod.rounded()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpe08hhywi.swift:16:25: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if arr == [] || arr == nil {\n\
    \                    ~~~ ^  ~~~\n/tmp/tmpe08hhywi.swift:23:17: error: value of\
    \ type 'Int' has no member 'rounded'\n    return prod.rounded()\n           ~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.isEmpty else { return nil }\n    var sum = 0\n\
    \    for x in arr { sum += x * sign(x) }\n    return sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpb54d2hqv.swift:16:31: error: cannot find 'sign' in scope\n    for\
    \ x in arr { sum += x * sign(x) }\n                              ^~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product = 1\n    for x in arr {\n        product *=\
    \ x % 2\n    }\n\n    if product == 0 {\n        return nil\n    }\n\n    return\
    \ Int(product)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp2f_3a7pc/tmp2f_3a7pc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b451e226c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b451df1db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b451df1d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b451df1c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2f_3a7pc                        0x000055cbfd7d6719 <unavailable> + 5913

    5    libc.so.6                          0x00002b451e412460 __libc_start_main +
    245

    6    tmp2f_3a7pc                        0x000055cbfd7d62a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979900
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var res: Int? = nil\n    for n in arr {\n        let sign\
    \ = sign(n)\n        if res == nil { res = sign * n } else { res += sign * n }\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz7scyb85.swift:16:20: error: use of local variable 'sign' before\
    \ its declaration\n        let sign = sign(n)\n                   ^\n/tmp/tmpz7scyb85.swift:16:13:\
    \ note: 'sign' declared here\n        let sign = sign(n)\n            ^\n/tmp/tmpz7scyb85.swift:17:49:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        if res == nil { res = sign * n } else { res += sign * n }\n         \
    \                                       ^\n/tmp/tmpz7scyb85.swift:17:49: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        if res == nil { res = sign * n } else { res += sign * n }\n         \
    \                                       ^\n                                  \
    \                 !\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var total:\
    \ Int = 0\n    var sign: Int = 0\n    for el in arr {\n        total += el * sign\n\
    \        sign *= (el < 0 ? -1 : 1) * el\n    }\n    return total\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpykn__gfo/tmpykn__gfo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b00a17ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00a14e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b00a14e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b00a14e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpykn__gfo                        0x0000559086c06599 <unavailable> + 5529

    5    libc.so.6                          0x00002b00a19d8460 __libc_start_main +
    245

    6    tmpykn__gfo                        0x0000559086c06129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979900
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sign: Int = 0\n    var sum: Int = 0\n    for element\
    \ in arr {\n        sign += element < 0 ? 1 : element > 0? -1: 0\n        sum\
    \ += sign\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpuhg2rl0_.swift:17:47: error: consecutive statements on a line must\
    \ be separated by ';'\n        sign += element < 0 ? 1 : element > 0? -1: 0\n\
    \                                              ^\n                           \
    \                   ;\n/tmp/tmpuhg2rl0_.swift:17:50: error: consecutive statements\
    \ on a line must be separated by ';'\n        sign += element < 0 ? 1 : element\
    \ > 0? -1: 0\n                                                 ^\n           \
    \                                      ;\n/tmp/tmpuhg2rl0_.swift:17:50: error:\
    \ expected expression\n        sign += element < 0 ? 1 : element > 0? -1: 0\n\
    \                                                 ^\n/tmp/tmpuhg2rl0_.swift:17:29:\
    \ error: cannot convert value of type 'Bool' to expected argument type 'Int'\n\
    \        sign += element < 0 ? 1 : element > 0? -1: 0\n                      \
    \      ^\n/tmp/tmpuhg2rl0_.swift:17:31: error: result values in '? :' expression\
    \ have mismatching types 'Int' and 'Bool'\n        sign += element < 0 ? 1 : element\
    \ > 0? -1: 0\n                              ^\n/tmp/tmpuhg2rl0_.swift:17:46: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \       sign += element < 0 ? 1 : element > 0? -1: 0\n                       \
    \                      ^\n/tmp/tmpuhg2rl0_.swift:17:46: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        sign +=\
    \ element < 0 ? 1 : element > 0? -1: 0\n                                     \
    \        ^\n                                               ?? <#default value#>\n\
    /tmp/tmpuhg2rl0_.swift:17:46: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        sign += element < 0 ? 1 : element\
    \ > 0? -1: 0\n                                             ^\n               \
    \                             ( )!\n/tmp/tmpuhg2rl0_.swift:17:46: error: cannot\
    \ use optional chaining on non-optional value of type 'Int'\n        sign += element\
    \ < 0 ? 1 : element > 0? -1: 0\n                                            ~^\n\
    \                                             \n/tm"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let max = maxMagnitude(arr)\n    if max == nil {\n   \
    \     return nil\n    }\n\n    var signs = [Int]()\n    var total = 0\n    for\
    \ x in arr {\n        if x < 0 {\n            signs.append(1)\n            total\
    \ += -max! * x\n        } else {\n            signs.append(-1)\n            total\
    \ += max! * x\n        }\n    }\n    return total\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpruq60xwn.swift:14:15: error: cannot find 'maxMagnitude' in scope\n\
    \    let max = maxMagnitude(arr)\n              ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    for v in arr {\n        if v != 0 {\n\
    \            sum += v * sign(v)\n        }\n    }\n    return sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpw006ipi2.swift:17:24: error: cannot find 'sign' in scope\n    \
    \        sum += v * sign(v)\n                       ^~~~\n"
  stdout: ''
  timestamp: 1659979899
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n\n    var sum\
    \ = 0\n    var sign = 1\n\n    for i in arr {\n        sum += sign * i\n     \
    \   sign *= -1\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpdjbmf29k/tmpdjbmf29k.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae88964ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae889345b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae889345988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8893447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdjbmf29k                        0x000055afcb234599 <unavailable> + 5529

    5    libc.so.6                          0x00002ae88983a460 __libc_start_main +
    245

    6    tmpdjbmf29k                        0x000055afcb234129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979900
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var res = arr[0]\n    for x in arr {\n        res = sign\
    \ * res * x\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3b5bp0lo.swift:16:15: error: cannot find 'sign' in scope\n    \
    \    res = sign * res * x\n              ^~~~\n"
  stdout: ''
  timestamp: 1659979900
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    for val in arr {\n        if val > 0 {\n            return\
    \ nil\n        }\n    }\n    let product = arr.reduce(1) { $1 * $0 }\n    if product\
    \ == 0 {\n        return nil\n    }\n    let signs = arr.map { $0 > 0 ? 1 : -1\
    \ }.reduce(1) { $0 + $1 }\n    return signs * product\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpaz1mtlg1/tmpaz1mtlg1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b72b6f52c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72b6c49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72b6c49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72b6c487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaz1mtlg1                        0x00005610f2809629 <unavailable> + 5673

    5    libc.so.6                          0x00002b72b713e460 __libc_start_main +
    245

    6    tmpaz1mtlg1                        0x00005610f28091b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1659979900
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpj7cmib9p/tmpj7cmib9p.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c6d467c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c6d15eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c6d15e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c6d15d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj7cmib9p                        0x000056133dd0f459 <unavailable> + 5209

    5    libc.so.6                          0x00002b2c6d653460 __libc_start_main +
    245

    6    tmpj7cmib9p                        0x000056133dd0efe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979900
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty { return nil }\n    var sum = 0\n    for\
    \ n in arr { sum += abs(n) * sign(n) }\n    return sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpm7ctj5ty.swift:16:36: error: cannot find 'sign' in scope\n    for\
    \ n in arr { sum += abs(n) * sign(n) }\n                                   ^~~~\n"
  stdout: ''
  timestamp: 1659979900
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \n    var sign = 1\n    var product = 1\n    var prod = 1\n    var sum = 0\n \
    \   for element in arr {\n        product = product * element\n        sum +=\
    \ sign * Abs(element)\n        sign = sign * element < 0 ? -1 : +1\n    }\n  \
    \  return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_3yvb1il.swift:24:23: error: cannot find 'Abs' in scope\n     \
    \   sum += sign * Abs(element)\n                      ^~~\n"
  stdout: ''
  timestamp: 1659979900
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty() {\n        return nil\n    }\n\n    var\
    \ sum = 0\n    var product = 1\n    for val in arr {\n        if val < 0 {\n \
    \           product *= -1\n        }\n        sum += val\n    }\n    return sum\
    \ * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7qef06vm.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1659979900
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var res: Int = 0\n    for v in arr {\n        res *= v\n\
    \        res += (v < 0 ? -v : 0)\n    }\n    return res > 0 ? res : nil\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsg99u8aw/tmpsg99u8aw.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f7ddc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f7dabcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f7dabc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f7dabb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsg99u8aw                        0x00005638baad7549 <unavailable> + 5449

    5    libc.so.6                          0x00002b3f7dfb1460 __libc_start_main +
    245

    6    tmpsg99u8aw                        0x00005638baad70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979900
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty() {\n    return nil\n  }\n  \n  var mag =\
    \ 0\n  var sign = 1\n  for v in arr {\n    mag *= sign\n    if v < 0 {\n     \
    \ mag = -mag\n    }\n    sign += 1\n  }\n  \n  return mag\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5jz1r5kr.swift:14:10: error: cannot call value of non-function\
    \ type 'Bool'\n  if arr.isEmpty() {\n         ^      ~~\n                \n"
  stdout: ''
  timestamp: 1659979900
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard arr.isEmpty == false else {\n    return nil\n  }\n\
    \  var sum: Int = 0\n  guard arr.count > 0 else {\n    return nil\n  }\n  for\
    \ val in arr {\n    sum += abs(val) * signBit(val)\n  }\n  return sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwlbtlvyj.swift:22:23: error: cannot find 'signBit' in scope\n \
    \   sum += abs(val) * signBit(val)\n                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979900
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let max = arr.max()\n    var sum: Int = 0\n    for num\
    \ in arr {\n        sum += max * Int(sign(num))\n    }\n    return sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphfpgrsvx.swift:17:26: error: cannot find 'sign' in scope\n    \
    \    sum += max * Int(sign(num))\n                         ^~~~\n/tmp/tmphfpgrsvx.swift:17:16:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        sum += max * Int(sign(num))\n               ^\n/tmp/tmphfpgrsvx.swift:14:9:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n    let max = arr.max()\n        ^\n    guard        \
    \       else { return <#default value#> }\n/tmp/tmphfpgrsvx.swift:14:19: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    let max = arr.max()\n                  ^\n                        ?? <#default\
    \ value#>\n/tmp/tmphfpgrsvx.swift:14:19: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    let max = arr.max()\n  \
    \                ^\n                       !\n/tmp/tmphfpgrsvx.swift:17:16: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        sum += max * Int(sign(num))\n               ^\n               (   ??\
    \ <#default value#>)\n/tmp/tmphfpgrsvx.swift:17:16: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        sum += max\
    \ * Int(sign(num))\n               ^\n                  !\n"
  stdout: ''
  timestamp: 1659979900
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result: Int?\n    var magnitude: Int = 0\n    \n \
    \   for element in arr {\n        magnitude += Int(element)\n        \n      \
    \  let sign = element < 0 ? 1 : -1\n        \n        if let product = sign *\
    \ prod_signs(arr: &arr[1..<arr.count]) {\n            if product > result {\n\
    \                result = product\n            }\n        }\n    }\n    \n   \
    \ if magnitude == 0 {\n        return nil\n    } else {\n        return magnitude\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_lra39mm.swift:22:33: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if let product = sign * prod_signs(arr:\
    \ &arr[1..<arr.count]) {\n                                ^\n/tmp/tmp_lra39mm.swift:22:33:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if let product = sign * prod_signs(arr: &arr[1..<arr.count])\
    \ {\n                                ^\n                                (    \
    \                                ?? <#default value#>)\n/tmp/tmp_lra39mm.swift:22:33:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if let product = sign * prod_signs(arr: &arr[1..<arr.count])\
    \ {\n                                ^\n                                     \
    \                               !\n/tmp/tmp_lra39mm.swift:22:49: error: cannot\
    \ convert value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n\
    \        if let product = sign * prod_signs(arr: &arr[1..<arr.count]) {\n    \
    \                                            ^\n/tmp/tmp_lra39mm.swift:22:49:\
    \ error: cannot pass immutable value as inout argument: 'arr' is a 'let' constant\n\
    \        if let product = sign * prod_signs(arr: &arr[1..<arr.count]) {\n    \
    \                                            ^~~~\n/tmp/tmp_lra39mm.swift:23:26:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            if product > result {\n                         ^\n/tmp/tmp_lra39mm.swift:23:26:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            if product > result {\n                         ^\n     \
    \                           ?? <#default value#>\n/tmp/tmp_lra39mm.swift:23:26:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            if product > result {\n                         ^\n     \
    \                          !\n"
  stdout: ''
  timestamp: 1659979900
