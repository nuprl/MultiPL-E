name: HumanEval_47_median
language: swift
prompt: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3, 1,\
  \ 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfunc\
  \ median(l: [Int]) -> Double {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
  \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
  \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
completions: ["  var l = l\n  l.sort()\n  return Double(l[(l.count + 1) >> 1]) / Double(l.count)",
  '  return median(l, Double.NaN)', "\tif l == nil {\n\t\treturn 0.0\n\t}\n\tvar x\
    \ = 0.0\n\tvar n = Double(len(l))\n\tfor x in l {\n\t\tn += 1.0 / Double(x)\n\t\
    }\n\treturn n / Double(len(l))", '  return median(l: l, isSorted: false)', " \
    \   var lo = Double.max, hi = Double.min\n    for x in l {\n        if x < lo\
    \ {\n            lo = x\n        } else if x > hi {\n            hi = x\n    \
    \    }\n    }\n    return (lo + hi) / 2", "    var sum = 0\n    for value in l\
    \ {\n        sum += value\n    }\n    return Double(sum) / Double(l.count)", " \
    \ var m = 0\n  var n = l.count\n  var temp = 0\n  for _ in 0..<n {\n    temp +=\
    \ l[m]\n    m = (m + 1) % n\n  }\n  return temp / Double(n)", "\tsortedArray(l)\n\
    \tcount := Int(l.count)\n\tsortedCount := Int(l.sortedArray.count)\n\tif count\
    \ == 0 {\n\t\treturn 0\n\t}\n\n\tif sortedCount == 0 {\n\t\treturn l[0]\n\t}\n\
    \n\treturn Double(l.sortedArray[count / 2] + l.sortedArray[count / 2 - 1]) / 2",
  "    l.sort()\n    if l.length % 2 == 1 {\n        return l[l.length / 2]\n    }\
    \ else {\n        return (l[l.length / 2] + l[l.length / 2 - 1]) / 2\n    }",
  "    let size = l.count\n    guard size != 0 else { return Double.infinity }\n \
    \   let mid = floor(size / 2)\n    return median2(l, mid)", "    var l = l\n \
    \   if l == nil || l.count < 2 {\n        return 0\n    }\n\n    var sorted =\
    \ sortInPlace(r)\n    if sorted == nil {\n        return 0\n    }\n\n    var middle\
    \ = (sorted.count - 1) / 2\n    var l = sorted[middle]\n    var r = sorted[(middle\
    \ + 1)]\n\n    if (r - l) * 2 >= l {\n        return (l + r) / 2\n    }\n\n  \
    \  return l", "    if l.isEmpty { return 0.0 }\n\n    let n = l.count\n    let\
    \ middle = Double(l.count / 2)\n    let leftMedian = median(l.prefix(middle))\n\
    \    let rightMedian = median(l.suffix(middle))\n    let median = leftMedian +\
    \ rightMedian / 2.0\n\n    if n < 3.0 {\n        return l[n]\n    }\n\n    //\
    \ median = (left + right) / 2.0\n    return median", "\tif l == nil {\n\t\tthrow\
    \ Abort(\"median of empty list\")\n\t}\n\tif l.Len() == 0 {\n\t\tthrow Abort(\"\
    median of empty list\")\n\t}\n\tvar l []Int\n\tl = append(l, l[0])\n\tsort.Sort(l)\n\
    \tl.Sort()\n\tidx := l.Len()/2\n\treturn l.At(idx)", "  var l = l as! [Int]\n\
    \  l.sortInPlace()\n  return l[(l.count - 1) / 2]", "    func medianRec(l: [Int])\
    \ -> Double {\n        let len = l.count\n        guard len > 1 else { return\
    \ Double(l[0]) }\n        let mid = len / 2\n        let first = l[mid]\n    \
    \    let second = l[len - mid]\n        if second > first {\n            return\
    \ medianRec(l[..mid])\n        } else {\n            return medianRec(l[mid..])\n\
    \        }\n    }\n    return medianRec(l)", "    var tmp Double = Double()\n\
    \    for i in l {\n        tmp = i\n    }\n    return Double(tmp)", "  var l =\
    \ l\n  l.sort()\n  if l.count == 0 {\n    return 0\n  }\n  return Double(l.first!)\
    \ / Double(l.count) * 100", "    let a = l.sort()\n    return (Double(a[a.count\
    \ / 2]) + Double(a[a.count / 2 - 1])) / 2", "    var n = (l[0] as Int) + Double(l.count)\
    \ / 2.0\n    var i = 1\n    while (i < l.count) {\n        n = n - l[i]\n    \
    \    i += 1\n    }\n    return n", "  l.sort()\n  if l.count > 1 {\n    return\
    \ (l[0] + l[l.count/2]) / Double(l.count/2)\n  }\n  return l[0]", "  var sorted:\
    \ [Int] = l\n  sorted.sort()\n  if sorted.count == 0 || sorted.last == sorted.first\
    \ {\n    return Double(0)\n  }\n  return sorted.last + Double(sorted.count - 1)\
    \ / 2.0", "    if l.count < 2 {\n        return Double(l[0])\n    }\n    let sorted\
    \ = l.sorted()\n    let median = (sorted[(sorted.count / 2) - 1] + sorted[(sorted.count\
    \ / 2)])/2\n    return median", '    return median(l, 0, len(l) - 1)', "    var\
    \ nums = l\n    var numLen = nums.count\n    if numLen == 0 {\n        return\
    \ 0\n    }\n    if numLen == 1 {\n        return nums[0]\n    }\n    var numsSorted\
    \ = nums.sorted()\n    let midIdx = numLen / 2\n    return Double(numsSorted[midIdx])",
  "    let n = countElements(l)\n    if n < 1 {\n        return Double.nan\n    }\n\
    \    let mid = n / 2\n    return (l as NSArray).valueForKeyPath(\"@minIndex\"\
    ).doubleValue +\n        (l as NSArray).valueForKeyPath(\"@maxIndex\").doubleValue\
    \ - 1", '  return median(l, l.count())', '    return l.sorted()[l.sorted().count
    / 2]', '    return Double(l.sorted { $0.isOdd && $1.isOdd ? $0 < $1 : $0 > $1
    }[l..<(l.count / 2)].count)', "    l.sort()\n    var mid: Int\n    if l.count\
    \ <= 1 {\n        return l[0]\n    }\n    if l.count % 2 == 0 {\n        mid =\
    \ l.count / 2\n        return l[mid]\n    } else {\n        mid = (l.count - 1)\
    \ / 2\n        if l[mid] < 0 {\n            mid--\n        }\n        return l[mid]\n\
    \    }", "  switch l.count {\n  case 0:\n    return 0\n  case 1:\n    return l[0]\n\
    \  case 2:\n    return (l[0] + l[1]) / 2.0\n  default:\n    switch l.count / 2\
    \ {\n    case 0: return l[0]\n    case 1: return l[1]\n    default:\n      var\
    \ high, low: Int\n      switch l.count {\n      case 2: return (l[0] + l[1]) /\
    \ 2\n      case 3: return (l[0] + l[1] + l[2]) / 3.0\n      case 4: return (l[0]\
    \ + l[1] + l[2] + l[3]) / 4.0\n      case 5: return (l[0] + l[1] + l[2] + l[3]\
    \ + l[4]) / 5.0\n      case 6: return (l[0] + l[1] + l[2] + l[3] + l[4] + l[5])\
    \ / 6.0\n      case 7: return (l[0] + l[1] + l[2] + l[3] + l[4] + l[5] + l[6])\
    \ / 7.0\n      case 8: return (l[0] + l[1] + l[2] + l[3] + l[4] + l[5] + l[6]\
    \ + l[7]) / 8.0\n      case 9: return (l[0] + l[1] + l[2] + l[3] + l[4] + l[5]\
    \ + l[6] + l[7] + l[8]) / 9.0\n      case 10: return (l[0] + l[1] + l[2] + l[3]\
    \ + l[4] + l[5] + l[6] + l[7] + l[8] + l[9]) / 10.0\n      default:\n        high\
    \ = l[0]\n        low = l[0]\n        for v in l[1..] {\n          if high < v\
    \ {\n            high = v\n          }\n          if low > v {\n            low\
    \ = v\n          }\n        }\n        return (high + low) / 2.0\n      }\n  \
    \  }\n  }", "    assert(l.count > 0, \"Median requires at least one element\"\
    )\n    var m = Double(0)\n    for v in l {\n        m = v < m ? v : m\n    }\n\
    \    return m / Double(l.count)", "    let count = l.count\n    guard count >\
    \ 0 else {\n        return 0\n    }\n    guard count <= 100 else {\n        return\
    \ 0\n    }\n    guard count <= 1000000 else {\n        return 0\n    }\n    var\
    \ largest = l.max()\n    var smallest = l.min()\n    var midpoint: Double = 0\n\
    \    if count > 1 {\n        midpoint = Double((largest + smallest) / 2)\n   \
    \ }\n    return midpoint", '  return median(l, Double(l.count), Double(l.count)
    / 2, Double(l.count) / 2)', "    if l == nil || len(l) == 0 {\n        return\
    \ 0\n    }\n    sort(l)\n    return l[len(l)-1]", "    var result = 0.0\n    let\
    \ n = l.count\n    for i in 0..<n {\n        let x = l[i]\n        result = result\
    \ + x\n    }\n    result = result / Double(n)\n    return result", "    let sortedArray\
    \ = Array(l)\n    if sortedArray.count % 2 == 0 {\n        let median = (sortedArray[sortedArray.count/2-1]\
    \ + sortedArray[sortedArray.count/2+1]) / 2.0\n        return median\n    } else\
    \ {\n        return sortedArray[sortedArray.count/2-1]\n    }", "  let n = Double(l.count)\n\
    \  if n % 2 == 1 {\n    l.sort{$0 > $1}\n  }\n  return l[(l.count - 1) / 2]",
  '    return sorted(l).median', "  var sortedL = l as! [Int]\n  sortedL.sort()\n\
    \  if sortedL.count < 2 {\n    return 0\n  }\n  return sortedL[(sortedL.count\
    \ - 1)/2]", "    l.sort()\n    return (l.count / 2)", "  var lo = l.sort()\n \
    \ if lo.count < 2 {\n    return 0\n  }\n  lo.removeLast()\n  lo.removeLast()\n\
    \  lo.removeLast()\n  lo.removeLast()\n  return Double(lo.last!) / 2", "    switch\
    \ l.count {\n    case 0:\n        return Double(0)\n    case 1 :\n        return\
    \ l[0]\n    case 2 :\n        return 0.5 * (l[0] + l[1])\n    case 3 :\n     \
    \   return 0.75 * (l[0] + l[1] + l[2])\n    default :\n        return Double((l[0]\
    \ + l[1] + l[2])/2.0)\n    }", "    var m = Double(0)\n    var r = Double(0)\n\
    \    for v in l {\n        m = (v + r) / 2\n        if (r < 0 || m > r) r = m\n\
    \    }\n    return r", "  var min = Double(l.count)\n  var max = Double(l.count)\n\
    \  for i, v := range l {\n    if v < min {\n      min = v\n    } else if v > max\
    \ {\n      max = v\n    }\n  }\n  if min == max {\n    return min\n  }\n  return\
    \ Double(l.count) / Double(l.count) + min / Double(l.count) + max / Double(l.count)\
    \ / 2.0", "    switch l.count {\n    case 0: return Double(0)\n    case 1: return\
    \ l[0]\n    case 2: return (l[0] + l[1]) / 2\n    default:\n        var left =\
    \ 0\n        var right = l.count - 1\n        var mid = (left + right) / 2\n \
    \       guard left < right else { return Double(0) }\n        guard mid != right\
    \ else { return Double(0) }\n        while left < right {\n            guard l[mid]\
    \ < l[right] else { right = mid }\n            guard mid != left else { left =\
    \ mid }\n            mid = (left + right) / 2\n        }\n        return l[mid]\n\
    \    }", "    // Compute mean of sorted elements.\n    var sum: Double = 0\n \
    \   var count: Int = 0\n    for element in l {\n        sum += element\n     \
    \   count += 1\n    }\n\n    // Compute median.\n    var median: Double\n    if\
    \ count < 2 {\n        median = sum / Double(count)\n    } else {\n        median\
    \ = sum / Double(count - 1)\n    }\n\n    // Return the median value.\n    return\
    \ median", "    let sortArray = Array(l)\n    let sortedCount = sortArray.count\n\
    \    let halfCount = Int(ceil(Double(sortedCount) / 2.0))\n    let sortedHalfCount\
    \ = Int(ceil(halfCount / 2.0))\n\n    // Swap last and first elements.\n    if\
    \ sortedHalfCount > 0 {\n        let temp = sortArray[sortedHalfCount - 1]\n \
    \       sortArray[sortedHalfCount - 1] = sortArray[0]\n        sortArray[0] =\
    \ temp\n    }\n\n    let sortedArray = sortArray[0..<sortedHalfCount]\n\n    return\
    \ sortedArray.sortedLast(by: {$0 > $1}).reduce(0.0, +)", "  if l.isEmpty() {\n\
    \    return Double.nan\n  }\n  let l = l.sorted(by: >)\n  let middle = Double(l.count)\n\
    \  var left: [Int] = []\n  var right: [Int] = []\n  for i in 0..<middle {\n  \
    \  if i < middle / 2 {\n      left.append(l[i])\n    } else {\n      right.append(l[i])\n\
    \    }\n  }\n  if right == nil && middle == 1 {\n    return left[0]\n  } else\
    \ if right == nil {\n    return right[0]\n  } else if left == nil {\n    return\
    \ left[0]\n  }\n  return (right[0] + left[0]) / 2", "    let l = l.sorted()\n\
    \    if l.count < 2 {\n        return l[0]\n    }\n    if l.count == 2 {\n   \
    \     return l[0] / 2\n    }\n    let middle = Int((l.count - 1) / 2)\n    return\
    \ l[middle]", "    var sum = 0\n    var count = 0\n    for x in l {\n        sum\
    \ += x\n        count += 1\n    }\n    if count == 0 {\n        return 0\n   \
    \ }\n    if count == 1 {\n        return sum / Double(count)\n    }\n    var middle\
    \ = count / 2\n    return sum / Double(middle) + Double(sum % middle) / Double(count\
    \ - middle)", "    var result = Double(0)\n    var count = 1\n    for i in l {\n\
    \        result += Double(i) / Double(count)\n        count += 1\n    }\n    return\
    \ result / Double(l.count)", "  let n = l.count\n  if n == 0 {\n    return 0.0\n\
    \  }\n\n  let mid = Int(ceil(Double(n) / 2))\n  let left = l.subarray(0, mid)\n\
    \  let right = l.subarray(mid, l)\n  return median(left) + median(right)", " \
    \ let count = l.count\n  let sorted = l.sorted()\n  return Double(sorted[(count\
    \ - 1) / 2]!)", '  return median(l.asDoubles(), l.count)', "  var l = l\n  l +=\
    \ l[l.startIndex]\n  l = l.sorted { $0 < $1 }\n  guard l.count % 2 == 1 else {\n\
    \    return Double(l.last!) / 2.0\n  }\n  guard l.count > 1 else {\n    return\
    \ Double(l.first!) / 2.0\n  }\n  return Double(l.last! + l.first!) / 2.0", " \
    \   var lLen = l.count\n    guard lLen > 0 else { return 0 }\n    var m = (lLen\
    \ + 1) / 2\n    var mPos = l.index(of: m)\n    if mPos == l.endIndex {\n     \
    \   return l[mPos]\n    }\n    else {\n        return (l[mPos] - l[mPos - 1])\
    \ / 2.0 + l[mPos - 1]\n    }", "    var l = l.sorted()\n    if l.count % 2 ==\
    \ 0 {\n        return l.sorted()[l.count / 2]\n    } else {\n        return l.sorted()[(l.count\
    \ / 2) - 1]\n    }", '    return math.floor((l.sortedLastIndex() ?? l.count /
    2) / 2)', "\tif l == nil {\n\t\treturn 0.0\n\t}\n\treturn median0(l)", "    var\
    \ count = 0\n    var max = 0\n    var mid = 0\n    for e in l {\n        if e\
    \ > max {\n            max = e\n            mid = count\n        }\n        count\
    \ += 1.0\n    }\n    if count < l.count {\n        return Double(max) + Double(mid)\n\
    \    }\n    return Double(max)", "    var result: Double = 0\n    var count =\
    \ 1\n    for i in l {\n        if i < result {\n            result = i\n     \
    \   } else {\n            count += 1\n        }\n    }\n    if count % 2 == 0\
    \ {\n        return (result + result[count/2]) / 2.0\n    } else {\n        return\
    \ result\n    }", '    return math.median(l)', "    return l.sorted().reduce(0.0)\
    \ {\n        return $0 + $1.truncatingRemainder() / Double(l.count-1)\n    }",
  "  let n = l.count\n  assert(n >= 1, \"median of an empty list\")\n  if n == 1 {\n\
    \    return l[0]\n  }\n  var center = Double(n - 1)\n  var lowHalf = Array(0..<n)\n\
    \  var highHalf = Array(0..<n)\n  var pivot = Double(n)\n  for i in 0 ..< n {\n\
    \    if l[i] < low {\n      lowHalf.append(l[i])\n    } else if l[i] > high {\n\
    \      highHalf.append(l[i])\n    } else {\n      lowHalf.append(l[i])\n     \
    \ highHalf.append(l[i])\n    }\n  }\n\n  pivot = median(lowHalf)\n  for idx in\
    \ lowHalf.indices {\n    l[idx] = lowHalf[idx]\n  }\n  for idx in highHalf.indices\
    \ {\n    l[idx] = highHalf[idx]\n  }\n  if n == 1 {\n    return pivot\n  }\n \
    \ pivot = median(highHalf)\n  for idx in highHalf.indices {\n    l[idx] = highHalf[idx]\n\
    \  }\n  for idx in lowHalf.indices {\n    l[idx] = lowHalf[idx]\n  }\n\n  return\
    \ pivot", "    var sorted: Double = 0.0\n    var size = l.count\n\n    for number\
    \ in l {\n        sorted = sorted + (number / Double(size)) * Double(l.count)\n\
    \        size = size - 1\n    }\n\n    return sorted", "  if l == nil {\n    return\
    \ 0.0\n  }\n  let count = l.count\n  if count == 0 {\n    return 0.0\n  }\n  if\
    \ count == 1 {\n    return l[0]\n  }\n  if count == 2 {\n    return (l[0] + l[1])\
    \ / 2.0\n  }\n  let middle = count / 2.0\n  var i = count - 1\n  var m = (l[0]\
    \ + l[1]) / 2.0\n  for ; i > middle; i-- {\n    if l[i] < m {\n      m = l[i]\n\
    \    }\n  }\n  return m", '    return l.sorted { $0 < $1 }.mid', "    if l.count\
    \ <= 1 {\n        return Double(l.first!)\n    }\n\n    // Sort array and get\
    \ middle index\n    var midIndex = (l.count - 1) / 2\n    if l.count % 2 == 0\
    \ {\n        // even\n        midIndex += 1\n    }\n\n    // If median is odd,\
    \ get the first or last value\n    if midIndex % 2 == 0 {\n        return Double(l.sortedLast!)\n\
    \    } else {\n        return Double(l.sortedFirst!)\n    }", "    return Array(l).sorted().reduce(0,{\
    \ (sum, cur) -> Double in\n        if sum == 0 { return cur }\n        if cur\
    \ == sum { return Double(cur) }\n        return Double(sum) / Double(cur)\n  \
    \  })", "  let n = l.count\n  if n < 2 {\n    return l[0]\n  }\n  let i = Int(n/2)\n\
    \  return (l[i] - l[i-1]) * (n/2) + (l[n-1] - l[n]) / 2.0", "    var ls = l.slice()\n\
    \    var med = Int(ls.count / 2)\n\n    if ls.count % 2 == 0 {\n        // even\
    \ number of elements\n        for (i, e) in ls.enumerated() {\n            if\
    \ i < med {\n                ls[i] = ls[i + 1]\n            } else {\n       \
    \         ls[i] = ls[i - 1]\n            }\n        }\n        return ls[med].doubleValue()\n\
    \    }\n\n    // odd number of elements\n    var low = Int(ls.count / 2)\n   \
    \ var high = Int(ls.count / 2) - Int(med)\n    var mid = low\n\n    var leftAverage:\
    \ Double = 0\n    var rightAverage: Double = 0\n\n    for (i, _) in ls.enumerated()\
    \ {\n        if i < med {\n            leftAverage += Double(i)\n        } else\
    \ {\n            rightAverage += Double(i)\n        }\n    }\n\n    leftAverage\
    \ = leftAverage / Double(ls.count / 2)\n    rightAverage = rightAverage / Double(ls.count\
    \ / 2 - med)\n\n    return rightAverage + leftAverage", "\treturn median(l, Double(0))",
  "    var a = l.sorted()\n    return (a[a.count / 2 - 1] + a[a.count / 2]) / 2.0",
  "  if l.count < 2 {\n    return Double.nan\n  }\n  var sorted = l.sorted()\n  if\
    \ sorted.first == sorted.last {\n    return sorted[sorted.first]\n  }\n  var middle\
    \ = sorted.first\n  var upper = sorted.last\n  var lower = sorted.first\n  var\
    \ median = sorted[(middle + upper) / 2]\n  for index in (middle + lower).stride(through:\
    \ 0) {\n    if sorted[index] < median {\n      lower = index + 1\n    } else if\
    \ sorted[index] > median {\n      upper = index\n    } else {\n      return median\n\
    \    }\n  }\n  return median", "    var sorted = l.sorted()\n    var middle =\
    \ (sorted.count / 2)\n    if sorted.count % 2 == 1 {\n        return sorted[middle]\n\
    \    }\n    return Double(sorted[middle-1]) + Double(sorted[middle])", "    if\
    \ l == nil || l.isEmpty() {\n        return 0\n    }\n    if l.count == 0 {\n\
    \        return 0\n    }\n\n    // Sort the array in ascending order\n    var\
    \ sortedArray = l.sorted()\n\n    if sortedArray.count % 2 == 0 {\n        //\
    \ Even number of elements.\n        let midPoint = sortedArray.count / 2\n   \
    \     return sortedArray[midPoint]\n    } else {\n        // Odd number of elements.\n\
    \        let midPoint = (sortedArray.count - 1) / 2\n        return Double(sortedArray[midPoint])\
    \ + Double(sortedArray[midPoint - 1])\n    }", "    let size = l.count\n    if\
    \ size == 0 {\n        return Double.nan\n    }\n    if size == 1 {\n        return\
    \ l[0]\n    }\n    let mid = size / 2\n    return median(Array(l.prefix(mid)),\
    \ median(Array(l.suffix(mid))), median(Array(l.dropFirst(mid))), median(Array(l.dropLast(mid))))",
  '    return Double(l.sort().last!) / Double(l.count)', "    var count = Double(0.0)\n\
    \    for number in l {\n        count += 1.0\n    }\n    if count < 1.0 {\n  \
    \      return Double(l[0])\n    }\n    var index = Int(count * Double.pi)\n  \
    \  var middleIndex = Int(Double.pi * Double.pi)\n    if index > middleIndex {\n\
    \        index = middleIndex\n    }\n    var middleValue = Double(0.0)\n    for\
    \ number in l {\n        if number >= Double(index - Double.pi / 2.0) {\n    \
    \        middleValue += 1.0\n        }\n        index -= Double.pi / 2.0\n   \
    \ }\n    return middleValue / Double(l.count - 1)", "    var counts: Dictionary<Int,\
    \ Int> = [:]\n    for x in l {\n        counts[x] = (counts[x] ?? 0) + 1\n   \
    \ }\n    var sum: Double = 0\n    for x in counts {\n        sum += x / Double(counts[x])\n\
    \    }\n    return sum", '    return l.sorted(by: <, >).reduce(<, >) / Double(l.count)',
  "    var l = l as! [Int]\n    l.sort()\n    let mid = Int((Double(l.count) / 2.0)\
    \ + 0.5)\n    return l[mid]", "    if l.isEmpty  {\n        return Double.nan\n\
    \    }\n    let l = l.sorted()\n    let mid = l.count / 2\n    return l[mid]",
  "  let count = countElements(l)\n  if count == 0 {\n    return Double(Int(0)) //\
    \ avoid div by 0\n  }\n  guard count > 1 else { return Double(Int(0)) // avoid\
    \ div by 0\n  }\n  let sortedList = l.sorted()\n  return sortedList[count / 2]",
  "    var ls = [Int]()\n    var counts = [Int]()\n    for x in l {\n        ls.append(x)\n\
    \        counts.append(1)\n    }\n    guard ls.count != counts.count else { return\
    \ 0.0 }\n    for x in ls {\n        counts[Int((x - Int((ls.sort { $0 < $1 }[0])\
    \ + 1.0))/2.0 + 1)] += 1\n    }\n    var total = Double(0)\n    var result = 0\n\
    \    for x in counts {\n        total += x / Double(l.count)\n    }\n    if total\
    \ == 0.0 { return 0.0 }\n    for x in counts {\n        if x % 2 == 0 { result\
    \ += total * Double(x % 2) } else { result -= total * Double(x % 2) }\n    }\n\
    \    return result", "    var middle = l[0]\n    for element in l {\n        if\
    \ element > middle {\n            middle = element\n        }\n    }\n    return\
    \ middle", "    let length = l.count\n    var sortedArray = Array(l)\n    sortedArray.sort()\n\
    \    let middleIndex = sortedArray.count / 2\n    if sortedArray.count % 2 ==\
    \ 0 {\n        return sortedArray[middleIndex]\n    } else {\n        return Double(sortedArray[(sortedArray.count\
    \ - 1) / 2] + sortedArray[middleIndex])\n    }", '  return l.sorted { $0 < $1
    }.count / Double(l.count)', "    var count = countElements(l)\n    guard count\
    \ > 0 else { return Double.nan}\n\n    let sortedList = sorted(l)\n    var median:\
    \ Double = 0\n    if count % 2 == 0 {\n        median = (sortedList[count / 2\
    \ - 1] + sortedList[count / 2]) / 2\n    } else {\n        median = sortedList[count\
    \ / 2]\n    }\n    return median", "    let sortedArray = l.sorted()\n    let\
    \ index = sortedArray.endIndex.predecessor()\n    let count = sortedArray.count\n\
    \    if count == 0 { return Double.infinity}\n    let middle = Double(index) /\
    \ Double(count)\n    return middle", '  return sort(l).median()', "    if l.count\
    \ < 2 {\n        return Double(l[0])\n    }\n    var l = l.sorted()\n    var mid\
    \ = Double(l.count / 2)\n    var m1 = l[mid]\n    var m2 = l[mid-1]\n    if (m2\
    \ < m1) {\n        return m1 + (l[mid+1] - m1)\n    }\n    return mid", "    let\
    \ len = l.count\n    var minVal = l[0]\n    var maxVal = l[0]\n    for i in 1..<len\
    \ {\n        if l[i] < minVal {\n            minVal = l[i]\n        }\n      \
    \  if l[i] > maxVal {\n            maxVal = l[i]\n        }\n    }\n    return\
    \ (len/2.0) * (minVal + maxVal)", "    assert(l.isSorted)\n    var middleIdx:\
    \ Int = 0\n    var middleVal: Double\n    var count = 0\n\n    // iterate through\
    \ the sorted array l to find median\n    for idx <- 0 ..< l.count {\n        if\
    \ count > 0 {\n            if l[idx] > middleVal {\n                // move middle\
    \ pointer\n                middleIdx = idx\n                // reset the count\n\
    \                count = 0\n            }\n            // increment count\n  \
    \          count += 1\n        } else {\n            // initialize middle value,\
    \ set count\n            middleVal = l[idx]\n            middleIdx = idx\n   \
    \         count = 1\n        }\n    }\n    // now we know median of array\n  \
    \  return l[middleIdx]", "    let n = l.count\n    if n == 0 {\n        return\
    \ 0\n    }\n    return l[n/2].truncatingRemainder(dividingBy: n)", "  var l2 =\
    \ l.slice()\n  l2.sort()\n  if l2.count < 2 {\n    return l[0]\n  }\n\n  return\
    \ (l2[l2.count / 2] + l2[l2.count / 2 - 1]) / 2", "    var m = 0.0\n    for i\
    \ in l {\n        m += i * i\n    }\n    return m / Double(l.count)", "  switch\
    \ l.count {\n  case 0: return Double(l.first)\n  case 1: return Double(l.first)\n\
    \  case 2: return Double(l.first)\n  default: return median(l[l.count/2])\n  }",
  "    l.sort()\n    l { (lhs, rhs) in\n        if lhs > rhs {\n            return\
    \ lhs\n        }\n        return rhs\n    }\n    return l[0]", "    if l == nil\
    \ || l.isEmpty() {\n        return 0\n    }\n    var avg = average(l: l)\n   \
    \ var min = -Int.MAX\n    var max = Int.MIN\n    for x in l {\n        if x <\
    \ min {\n            min = x\n        }\n        if x > max {\n            max\
    \ = x\n        }\n    }\n    if max < 0 {\n        max = -max\n    }\n    return\
    \ min + (max - min) / 2", "    l.sort()\n    let middle = Int(l.count / 2)\n \
    \   return Double(l[middle])", "\tvar s = 0.0;\n\tvar m = 0.0;\n\tvar n = 0.0;\n\
    \tfor k := 0..<l.count-1 {\n\t\ts += l[k];\n\t\tif l[k] > m {\n\t\t\tm = l[k];\n\
    \t\t}\n\t\tif l[k] < n {\n\t\t\tn = l[k];\n\t\t}\n\t}\n\treturn  s/(l.count-1);",
  "    let sortedL = l.sorted()\n    let mid = sortedL.count / 2\n    if sortedL.count\
    \ % 2 != 0 {\n        return (sortedL[mid] + sortedL[mid-1]) / 2\n    }\n    return\
    \ sortedL[mid]", "    l.sort()\n    switch l.count {\n    case 0:\n        return\
    \ Double(Int.max)\n    case 1:\n        return l[0]\n    default:\n        let\
    \ mid = (l.endIndex - l.startIndex) / 2.0\n        return (l[mid - 1] + l[mid])\
    \ / 2.0\n    }", "  var v = l.sorted()\n  guard v.count > 1 else { return v[0]\
    \ }\n  var low = Double(v[0]),\n      high = Double(v[v.count - 1])\n  guard low\
    \ < high else { return v[0] }\n  while !(v[0] == 0 && v[v.count - 1] == 0) &&\
    \ low + 1 < high {\n    low += 1\n  }\n  while !(v[0] == 0 && v[v.count - 1] ==\
    \ 0) && low > high {\n    high -= 1\n  }\n  guard low >= high else { return v[0]\
    \ }\n  var med = (low + high) / 2\n  for i in 1..v.count - 1 {\n    if v[i] <\
    \ med {\n      med = v[i]\n    }\n  }\n  return med", "    var count = 0\n   \
    \ var sum = Double(0.0)\n    for value in l {\n        sum += value\n        count\
    \ += 1\n    }\n    return sum / Double(count) ", "\tvar sortedList = l.sorted()\n\
    \tvar firstMiddleIndex = sortedList.count / 2\n\tvar secondMiddleIndex = firstMiddleIndex\
    \ + 1\n\tvar thirdMiddleIndex = secondMiddleIndex + 1\n\tvar medianValue = sortedList[firstMiddleIndex]\n\
    \tif firstMiddleIndex > 0 {\n\t\tmedianValue = sortedList[secondMiddleIndex] +\
    \ (sortedList[thirdMiddleIndex] - sortedList[firstMiddleIndex])\n\t}\n\treturn\
    \ medianValue", "\tif l == nil || l.isEmpty {\n\t\treturn 0\n\t}\n\tvar i, j int\
    \ // index and count\n\tvar n = l.count\n\n\tswitch l.count {\n\tcase 0:\n\t\t\
    return 0\n\tcase 1:\n\t\treturn l[0]\n\tcase 2:\n\t\treturn ((l[0] + l[1]) / 2)\n\
    \tcase 3:\n\t\treturn ((l[0] + l[1] + l[2]) / 3)\n\tcase 4:\n\t\treturn (((l[0]\
    \ + l[1]) / 2) + l[2])\n\tcase 5:\n\t\treturn (((l[0] + l[1]) / 2) + l[2] + l[3])\n\
    \tcase 6:\n\t\treturn (((l[0] + l[1]) / 2) + l[2] + l[3] + l[4])\n\tcase 7:\n\t\
    \treturn (((l[0] + l[1]) / 2) + l[2] + l[3] + l[4] + l[5])\n\tdefault:\n\t\tj\
    \ := 1\n\t\ti = 2\n\t\tfor ; i <= n; i += j {\n\t\t\tj++\n\t\t}\n\n\t\tswitch\
    \ i {\n\t\tcase 1:\n\t\t\treturn ((l[0] + l[1]) / 2)\n\t\tcase 2:\n\t\t\treturn\
    \ ((l[0] + l[1] + l[2]) / 3)\n\t\tcase 3:\n\t\t\treturn (((l[0] + l[1]) / 2) +\
    \ l[2])\n\t\tcase 4:\n\t\t\treturn (((l[0] + l[1]) / 2) + l[2] + l[3])\n\t\tcase\
    \ 5:\n\t\t\treturn (((l[0] + l[1]) / 2) + l[2] + l[3] + l[4])\n\t\tcase 6:\n\t\
    \t\treturn (((l[0] + l[1]) / 2) + l[2] + l[3] + l[4] + l[5])\n\t\tcase 7:\n\t\t\
    \treturn (((l[0] + l[1]) / 2) + l[2] + l[3] + l[4] + l[5] + l[6])\n\t\tdefault:\n\
    \t\t\treturn l[(n - 1) / 2]\n\t\t}\n\t}", "    var mid = ceil(l.count / 2)\n \
    \   if l.count % 2 == 0 {\n        return Double(min(l[mid], l[mid-1]))\n    }\
    \ else {\n        return Double(max(l[mid], l[mid-1]))\n    }", "    let n = l.count\n\
    \    let minValue = l.min() ?? 0\n    let maxValue = l.max() ?? 0\n\n    let midValue:\
    \ Double = ((minValue + maxValue) / 2.0).rounded(.toNearestOrAwayFromZero)\n\n\
    \    let counts: [Int] = []\n    var sum = 0.0\n    for (index, value) in l.enumerated()\
    \ {\n        sum += value\n        guard let indexDouble = Double(index) else\
    \ {\n            fatalError(\"index \\(index) cannot be converted to Double\"\
    )\n        }\n        if indexDouble == midValue {\n            counts.append(1)\n\
    \        } else {\n            counts.append(0)\n        }\n    }\n    return\
    \ sum / Double(counts.count)", "    guard l.count > 1 else {\n        return Double(l.sorted()[l.count\
    \ / 2])\n    }\n    guard l.count % 2 == 0 else {\n        return median(l.sorted(),\
    \ l.count / 2)\n    }\n    let median1 = median(l.sorted(), l.count / 2)\n   \
    \ let median2 = median(l.sorted().suffix(l.count / 2), l.count / 2)\n    if median2\
    \ < median1 {\n        return median1\n    } else {\n        return median2\n\
    \    }", "    var min = Double.leastPositiveFinite\n    var max = Double.greatestNegativeFinite\n\
    \    for val in l {\n        min = min(min, val)\n        max = max(max, val)\n\
    \    }\n    return Double((max + min) / 2)", "    if l.count <= 1 {\n        return\
    \ 0.0\n    }\n    if l.count == 2 {\n        return l[0]\n    }\n    return Double(l[l.count\
    \ / 2])", "    let sorted = l.sorted()\n    if sorted.count <= 1 {\n        return\
    \ sorted[0]\n    }\n    return Double(sorted[sorted.count / 2]) + Double(sorted[sorted.count\
    \ / 2 - 1]) / 2", "    if l == nil {\n        return Double(0)\n    }\n\n    var\
    \ m = Double(0)\n    var count = 0\n    for idx in l {\n        count++\n    \
    \    if idx == l[0] {\n            m = idx\n            break\n        }\n   \
    \ }\n\n    if count > 1 {\n        var index = 0\n        var m1 = m\n       \
    \ for idx in l {\n            if idx == l[index] {\n                m1 = idx\n\
    \            } else {\n                m1 = Double(0)\n                break\n\
    \            }\n            index++\n        }\n\n        // if both indexes have\
    \ same value\n        if m1 == m {\n            return m\n        }\n\n      \
    \  // if both indexes have same value\n        if m1 == m {\n            return\
    \ m\n        }\n\n        // if both indexes have different value\n        return\
    \ m1 + 0.5\n    }\n    return m", "\tvar x = 0.0\n\tvar median = Double(0.0)\n\
    \tvar count = 0\n\tfor element in l {\n\t\tx += element\n\t\tcount += 1\n\t\t\
    if count > 1 {\n\t\t\tx = x / Double(count)\n\t\t}\n\t\tmedian = median + x\n\t\
    }\n\tmedian = median / Double(count)\n\treturn median", "    var m = Double(0)\n\
    \    var count = 0\n    for x in l {\n        if x < m {\n            m = x\n\
    \            count = 0\n        }\n        count += 1\n    }\n    if count <=\
    \ 1 {\n        return m\n    }\n    if count % 2 == 0 {\n        return (m + l[count-1])\
    \ / 2\n    }\n    return (m - l[count-1]) / 2", "  if l.count <= 1 {\n    return\
    \ 0\n  }\n\n  let h = l.sorted()\n  return Double(h.mid())", "    if l.isEmpty()\
    \ {\n        return Double.nan\n    }\n    let s = l.sorted { $0 < $1 }\n    return\
    \ (s.count - 1.0) / Double(s.count).rounded(.toNearestOrEven)", "    var avg :=\
    \ 0\n    var count := 0\n    for _, n in l.enumerated() {\n        avg += n\n\
    \        count++\n    }\n    if count > 0 {\n        return avg / Double(count)\n\
    \    }\n    return 0", "    let n = l.count\n    let mut m = Double.zero\n   \
    \ let mut largest = Double.nan\n    for e in l.reversed() {\n        m += e\n\
    \        if m > largest {\n            largest = m\n        }\n    }\n    return\
    \ largest / Double(n)", "    // find middle of array\n    // return average of\
    \ middle 2 elements\n    let len = (l as NSArray).count / 2\n    let median =\
    \ (l[Int(len)] as Double) + (l[Int(len - 1)] * (1.0 - (l[Int(len)] as Double)))\n\
    \    return median", "    var n = l.count\n    guard n > 1 else { return Double(l.first)\
    \ }\n    var sum = l.map { $0 + $1 }.reduce(0, combine: +) / Double(n)\n    for\
    \ element in l.dropFirst() {\n        let difference = sum - element\n       \
    \ sum -= element\n        if difference > 0 { return Double(element) }\n    }\n\
    \    return Double(sum)", "    var sortedArr = l.sorted()\n    var mid = sortedArr.count/2\n\
    \    return sortedArr[mid]", "  if l.isEmpty {\n    return Double.nan\n  }\n \
    \ let (low, high) = l.span()\n  return (low + high) / 2.0", "    let min = min(l)\n\
    \    let max = max(l)\n    guard min < max else { return Double(0.0) }\n    return\
    \ (l.sorted().last?.pointee ?? Double(l.last!))\n        + ((l.sorted { $0 < $1\
    \ }.first?.pointee ?? Double(l.first!))\n            - min) / Double(max.pointee\
    \ - min.pointee)", "    l.sort()\n    return Double(l[len(l) / 2])", "    var\
    \ l = l as! [Int]\n    var pivot: Int\n    var length: Int\n    var middle: Int\n\
    \    pivot = l.count / 2\n    middle = pivot % l.count\n    if l.count % 2 ==\
    \ 0 {\n        return l[middle]\n    }\n    length = pivot - middle\n    if length\
    \ > 0 {\n        return median(l[..middle])\n    } else {\n        return median(l.suffix(middle))\n\
    \    }", "    var even = 0.0, odd = 0.0\n    for element in l {\n        if element\
    \ % 2 == 0 {\n            even += element\n        } else {\n            odd +=\
    \ element\n        }\n    }\n    return (even + odd) / Double(l.count)", "   \
    \ let count = countElements(l)\n    var low = Double(0)\n    var high = Double(0)\n\
    \    for x in l {\n        if x < low {\n            low = x\n        }\n    \
    \    if x > high {\n            high = x\n        }\n    }\n    if count <= 1\
    \ {\n        return low\n    }\n    if count == 2 {\n        return low + (high\
    \ - low) / 2.0\n    }\n    var median = (low + high) / 2.0\n    for x in l {\n\
    \        if x < median {\n            median = x\n        }\n    }\n    return\
    \ median", "    let sorted = l.sorted()\n    let mid = sorted.count / 2\n    var\
    \ x = sorted.firstIndex(of: mid)!\n    var y = sorted.lastIndex(of: mid)!\n  \
    \  var largest = 0\n    if x < y {\n        largest = y\n    } else {\n      \
    \  largest = x\n    }\n    guard mid > 0 else {\n        return sorted[largest]\n\
    \    }\n    var index = largest\n    while index < sorted.count {\n        if\
    \ sorted[index] == mid {\n            break\n        }\n        index++\n    }\n\
    \    if index == sorted.count {\n        return mid\n    }\n    var median_i =\
    \ index\n    var median_j = index\n    while median_j < sorted.count && sorted[median_j]\
    \ == mid {\n        median_j++\n    }\n    if median_j == sorted.count {\n   \
    \     return mid\n    }\n    while median_i < sorted.count && sorted[median_i]\
    \ == mid {\n        median_i++\n    }\n    if median_i == sorted.count {\n   \
    \     return mid\n    }\n    if sorted[median_i] < sorted[median_j] {\n      \
    \  median_i, median_j = median_j, median_i\n    }\n    var left_i = median_i\n\
    \    var right_j = median_j\n    var median = (sorted[left_i] + sorted[right_j])\
    \ / 2\n    while left_i < median_j && right_j < sorted.count {\n        if sorted[left_i]\
    \ < sorted[right_j] {\n            left_i += 1;\n            right_j += 1;\n \
    \       } else {\n            left_i += 1;\n        }\n    }\n    if left_i ==\
    \ median_j {\n        return sorted[median_j]\n    }\n    if right_j == sorted.count\
    \ {\n        return sorted[median_j]\n    }\n    if sorted[left_i] < sorted[right_j]\
    \ {\n        median = sorted[left_i]\n    } else {\n        median = sorted[right_j]\n\
    \    }\n    return median", "    var l = [Int](l)\n    if l.count == 0 {\n   \
    \     return 0\n    }\n    if l.count > 1 {\n        return midpoint(l)\n    }\n\
    \    return l[0]", "\tl.sort()\n\tvar mid = Double(l.length) / 2.0\n\treturn l[mid]",
  '    return Double(l.sorted().removeLast().hashValue % Double(l.count)) / Double(l.count)',
  "    \n    var m = 0.0\n    var c = 0.\n    var i = 0\n    var j = 0\n    var n\
    \ = l.count\n    \n    while i < n {\n        \n        if l[j] == 0.0 {\n   \
    \         \n            i += 1\n            \n            if i == n {\n      \
    \          \n                break\n            }\n            \n        } else\
    \ {\n            \n            if c < 0.0 {\n                \n              \
    \  j += 1.0\n                \n                if j == n {\n                 \
    \   \n                    break\n                }\n                \n       \
    \     }\n            \n            m += l[j] / c\n            \n            c\
    \ += 1.0\n            \n            i += 1\n            \n        }\n    }\n \
    \   \n    return m", "  if l == nil {\n    return Double.nan\n  }\n  switch l.count\
    \ {\n  case 0:\n    return Double.nan\n  case 1:\n    return l[0]\n  default:\n\
    \    median := l[0]\n    for i in 1 ..< l.count {\n      if l[i] > median {\n\
    \        median = l[i]\n      }\n    }\n    return median\n  }", "    if l.count\
    \ < 1 {\n        return Double(0.0)\n    }\n    return l.sorted()[l.count / 2]\
    \ ?? Double(l.sorted()[l.count / 2])", "  if l == nil {\n    return Double(0)\n\
    \  }\n  l.sort()\n  let mid = l.count / 2\n  if l.count % 2 == 1 {\n    return\
    \ l[mid]\n  }\n  let firstHalf = l[0 : mid]\n  let secondHalf = l[mid..<l.count]\n\
    \  return firstHalf.reduce(0.0, +) / (firstHalf.count + secondHalf.count) * 0.5\
    \ + secondHalf.reduce(0.0, +) / (secondHalf.count + firstHalf.count) * 0.5", " \
    \   switch l.count {\n    case 0: return Double(0)\n    case 1: return Double(l[0])\n\
    \    case 2: return Double(l[0]) + Double(l[1])\n    case 3: return Double(l[0])\
    \ + Double(l[1]) + Double(l[2])\n    default:\n        let sortedArray = l.sorted()\n\
    \        let middle = Int(l.count / 2)\n        return Double(sortedArray[middle\
    \ - 1]) + Double(sortedArray[middle])\n    }", "    let l = l.sorted()\n    return\
    \ Double(l.count % 2 == 0 ? l[l.count / 2 - 1] : (l.count + 1) / 2)", '    return
    statArray(l, median)', '    return Double.max((l.sorted { $0 < $1 }).last!)',
  "    guard l.count > 0 else { return 0.0 }\n    var sorted: Double = 0.0\n    var\
    \ min: Double = -1000000000000000.0\n    var max: Double = 1000000000000000.0\n\
    \    var median: Double = 0.0\n    var pos: Int = 0\n    for (pos, e) in l.enumerated()\
    \ {\n        sorted += Double(e)\n        if Double(e) < min { min = Double(e)\
    \ }\n        if Double(e) > max { max = Double(e) }\n    }\n    median = sorted\
    \ / Double(l.count)\n    if min == -1000000000000000.0 {\n        if median !=\
    \ 0.0 { median = -median }\n    } else {\n        if median != 0.0 {\n       \
    \     if median >= 0.0 { median = -median }\n            if median <= 0.0 { median\
    \ = median }\n        }\n    }\n    return median", '    return sort.median(l:
    l)', "    // Fast path to quickly return median if array is of length 0 or 1.\n\
    \    if l.isEmpty || l.count == 1 {\n        return l[0]\n    }\n    \n    sortByNumber(l)\n\
    \    \n    // If length of array is odd then median is at middle - 1.\n    //\
    \ Otherwise it is at middle + 1.\n    let (mid, leftHalf, rightHalf) = (l.count\
    \ / 2, l.dropFirst(), l.dropLast())\n    \n    // If length is odd, median is\
    \ at middle - 1.\n    if rightHalf.isEmpty {\n        return Double(mid)\n   \
    \ }\n    \n    // If length is even, median is at middle + 1.\n    if leftHalf.isEmpty\
    \ {\n        return Double(mid)\n    }\n    \n    let pivot = l[mid]\n    \n \
    \   let leftHalfCount = leftHalf.count\n    let rightHalfCount = rightHalf.count\n\
    \    \n    switch {\n    case leftHalfCount > rightHalfCount:\n        return\
    \ leftHalf[mid]\n    case leftHalfCount < rightHalfCount:\n        return rightHalf[mid]\n\
    \    case leftHalfCount == rightHalfCount:\n        // If there are more than\
    \ one element in both left and right halves then median is in between both\n \
    \       if leftHalfCount > 1 {\n            return Double(leftHalf[0] + rightHalf[mid\
    \ - 1])\n        }\n        return Double(leftHalf[0])\n    }", '  return median(l.map{Double($0)})',
  "    l.sort()\n    if l.count % 2 == 1 {\n        // Odd number of elements\n  \
    \      return (l[(l.count - 1) / 2] + l[(l.count - 1) / 2].offsetByExact(1)) /\
    \ 2\n    } else {\n        // Even number of elements\n        return l[(l.count\
    \ - 1) / 2]\n    }", "  var min: Double = Double.infinity\n  var max: Double =\
    \ -Double.infinity\n  for v in l {\n    if v < min {\n      min = v\n    }\n \
    \   if v > max {\n      max = v\n    }\n  }\n  if min > max {\n    return Double.nan\n\
    \  }\n  if min == Double.infinity {\n    return max\n  }\n  if max == Double.infinity\
    \ {\n    return min\n  }\n  return (min + max) / 2", "    var l1 = l.sort()\n\
    \    if (l1.count == 0) {\n        return 0\n    }\n    if (l1.count % 2 == 0)\
    \ {\n        return l1[(l1.count - 1) / 2]\n    }\n    else {\n        var m =\
    \ (l1.count - 1) / 2\n        return Double(l1[m]) + Double(l1[m + 1])\n    }",
  "  var min = l[0]\n  var max = l[0]\n  for el in l {\n    if min > el {\n      min\
    \ = el\n    }\n    if max < el {\n      max = el\n    }\n  }\n  return min + (max\
    \ - min) / 2", "    var l = Array(l)\n    if l.count < 2 {\n        return 0.\n\
    \    }\n    var a = l[0]\n    var b = l[1]\n    var c = l[0]\n    var d = l[1]\n\
    \    var mid = 0\n    var midVal = 0.\n    for i = 2; i < l.count; i++ {\n   \
    \     if l[i] < a {\n            a = l[i]\n        }\n        if l[i] > b {\n\
    \            b = l[i]\n        }\n    }\n    for (i = 1; i < l.count; i++ {\n\
    \        if l[i] < a {\n            d = c\n            c = l[i]\n        }\n \
    \       if l[i] > b {\n            d = c\n            c = l[i]\n        }\n  \
    \  }\n    mid = Double(l.count / 2)\n    if a < b {\n        midVal = c / 2\n\
    \    }\n    if b < c {\n        midVal = c / 2\n    }\n    if a > b {\n      \
    \  midVal = c / 2\n    }\n    if b > c {\n        midVal = c / 2\n    }\n    if\
    \ a < b {\n        midVal = c / 2\n    }\n    return midVal", "    if l.count\
    \ <= 1 {\n        return l[0]\n    }\n    if l.count <= 2 {\n        return l.sorted()[0]\
    \ + (l.sorted()[1] - l.sorted()[0]) / 2\n    }\n    var m = l.sorted()[0]\n  \
    \  for x in l.sorted()[1..] {\n        if x < m {\n            m = x\n       \
    \ }\n    }\n    return m", '    return median(l, Double(0))', "    var l = l as!\
    \ [Int]\n    l.sort()\n    return Double(l[(l.count - 1) >> 1] / 2)", "    let\
    \ len = Double(l.count)\n    let lsum = l.reduce(0, combine: +).magnitude\n  \
    \  var median = Double(l.count)\n    var idx = 0\n    while idx < len {\n    \
    \    let mid = (idx + len) / 2.0\n        let m1 = l[mid]\n        let m2 = Double(m1)\
    \ + (lsum / len - mid) * (-1.0)\n        let m3 = l[mid - 1]\n        median =\
    \ m2 > m3 ? m2 : m3\n        idx += 1\n    }\n    return median", "  if l.count\
    \ <= 0 {\n    return 0\n  }\n  guard l.count > 1 else {\n    let avg = Double(l.filter{\
    \ $0 > 0 }.count) / Double(l.count)\n    return avg\n  }\n  let sorted = l.sorted()\n\
    \  let mid = l.count / 2\n  return Double(sorted[mid]) + Double(sorted[mid - 1])\
    \ / 2.0", "    func isEven(_ i: Int) -> Bool {\n        return i % 2 == 0\n  \
    \  }\n\n    func isOdd(_ i: Int) -> Bool {\n        return i % 2 != 0\n    }\n\
    \n    func twos(_ i: Int) -> Int {\n        if isEven(i) {\n            return\
    \ i\n        }\n        return i + 1\n    }\n\n    var evenIndex = 0\n    var\
    \ oddIndex = 0\n    var sum = 0.0\n    for v in l {\n        if isEven(evenIndex)\
    \ && isOdd(oddIndex) {\n            sum += v\n            evenIndex += 1\n   \
    \     }\n        else if isEven(evenIndex) {\n            sum += v\n         \
    \   evenIndex += 1\n        }\n        else if isOdd(oddIndex) {\n           \
    \ sum += v\n            oddIndex += 1\n        }\n        else {\n           \
    \ sum += v\n        }\n    }\n    return sum / Double(l.count)", "    var sorted:\
    \ Int[] = l.sorted()\n    if sorted.count == 0 {\n        return Double.nan\n\
    \    }\n\n    var half: Int = sorted.count / 2\n    var i: Int\n    var med =\
    \ 0\n    var q: Double = 0\n\n    for i in 0..<half {\n        q += Double(sorted[i])\n\
    \    }\n    q = q / half\n\n    for i in 0..<half {\n        if Double(sorted[i])\
    \ > q {\n            med += Double(sorted[i] - q)\n        }\n    }\n\n    return\
    \ med + Double(sorted.last!)", "    l.sort()\n    if l.count < 2 {\n        return\
    \ l[0]\n    }\n    return Double(l.sortedSliceFrom(l.count/2)).sum / Double(l.count)",
  "\treturn percentile(l, 0.5)", '    return Double(l.sorted()[l.count / 2])', " \
    \   var min = Int.max\n    var max = Int.min\n    for x in l {\n        if x <\
    \ min {\n            min = x\n        }\n        if x > max {\n            max\
    \ = x\n        }\n    }\n    if min == Int.min && max == Int.max {\n        return\
    \ Int.min\n    }\n    return (min + max) / 2.0", "    let sorted = l.sorted()\n\
    \    if sorted.isEmpty {\n        return 0\n    }\n    guard sorted.count >= 2\
    \ else { return sorted[0] }\n    let median = sorted[(sorted.count - 1) >> 1]\n\
    \    return median", '  return median_impl(l, Double(0))', "    if l.isEmpty()\
    \ {\n        return 0.0\n    }\n\n    var l = l as! [Int]\n    l.sort()\n\n  \
    \  var middleIndex: Int = 0\n    var middle: Double = 0.0\n\n    // use binary\
    \ search to locate the middle value\n    for i in 0 ..< l.count - 1 {\n      \
    \  if l[i] > l[i + 1] {\n            middleIndex = i + 1\n            break\n\
    \        }\n    }\n\n    // only have one value left, return the middle value\n\
    \    if middleIndex == l.count - 1 {\n        return l[middleIndex]\n    }\n\n\
    \    // calculate median\n    middle = Double(l[middleIndex])\n    if middleIndex\
    \ - 1 >= 0 {\n        middle = (l[middleIndex - 1] + l[middleIndex]) / 2.0\n \
    \   }\n\n    return middle", "    var v = l.sort()\n    if v.count % 2 == 1 {\n\
    \        return v[v.reverse - 1].0 + (v[v.count / 2 - 1] + v[v.count / 2]) / 2.0\n\
    \    }\n    return v[v.count / 2].0", "\tvar middle : Double\n\t\n\tif l == nil\
    \ {\n\t\treturn 0\n\t}\n\n\tif len(l) == 0 {\n\t\treturn 0\n\t}\n\n\tmiddle =\
    \ l[0]\n\t\n\tfor i := 1; i < len(l); i++ {\n\t\tif l[i] > middle {\n\t\t\tmiddle\
    \ = l[i]\n\t\t}\n\t}\n\n\treturn middle", '    return l.sorted(by: >).reduce(0.0,
    combine: +)', "    let n = l.count\n    assert(n >= 0)\n    var max = 0\n    var\
    \ sum = 0\n    var mid = 0\n    for i in 0..<n {\n        sum = sum + l[i]\n \
    \       if sum > max {\n            max = sum\n            mid = i\n        }\n\
    \    }\n    return (Double(max - l[mid]) / Double(n)).round()", "\tl := l.sorted()\n\
    \tn := Double(l.count())\n\treturn n / 2.0 + Double(l.index(l.startIndex + n -\
    \ 1) / 2)", "    var sorted = l.sorted()\n    if sorted.length == 0 {\n      \
    \  return 0.0\n    }\n    if sorted.first == sorted.last {\n        return sorted[0]\n\
    \    }\n    return (sorted[sorted.first + 1] - sorted[sorted.first]) / 2", '    return
    median(l, Double(l.count), Double(l.count))', "    switch l.count {\n    case\
    \ 0: return Double.nan\n    case 1: return l[0]\n    case 2: return l[1]\n   \
    \ default:\n        let mid = (l.count - 1) / 2\n        var left = median(l[0\
    \ ..< mid])\n        var right = median(l[mid..<l.count])\n        if left > right\
    \ {\n            return left\n        } else {\n            return right\n   \
    \     }\n    }", "    let size = l.count\n    if size == 0 {\n        return Double.nan\n\
    \    }\n    var hm = l[0]\n    for i in 1..<size {\n        if l[i] <= hm {\n\
    \            hm = l[i]\n        }\n    }\n    return hm", "    var n = l.count\n\
    \    if n < 1 {\n        return 0\n    }\n    if n == 1 {\n        return l[0]\n\
    \    }\n    l.sort()\n    if n % 2 == 0 {\n        return l[n/2]\n    }\n    n\
    \ -= 1\n    var half1 = n/2\n    var half2 = (n+1)/2\n    return (l[half1] + l[half2])/2",
  "    if l.count < 2 {\n        return Double(l.first)\n    }\n    var a = l.sort()\n\
    \    if a.count % 2 == 0 {\n        return a[a.count / 2 - 1] + (a[a.count / 2])\
    \ / 2.0\n    }\n    return a[a.count / 2]", "    var l1 = l\n    if l1.count <\
    \ 2 {\n        return 0\n    }\n    if l1.count == 2 {\n        return l1[0]\n\
    \    }\n    if l1.count > 2 {\n        l1 = l1[0..<3]\n    }\n    l1.sort()\n\
    \    return l1[(l1.count - 1) / 2]", "    let count = countElements(l)\n    if\
    \ count % 2 == 1 {\n        return Double(l[(count - 1) / 2] + l[count / 2] /\
    \ 2)\n    }\n    return Double(l[(count - 1) / 2] + l[count / 2] / 2)", "    let\
    \ sortedArray = l.sorted()\n    if sortedArray.isEmpty {\n        return Double(sortedArray[0])\n\
    \    }\n    let mid = Double(sortedArray.count / 2)\n    if sortedArray.count\
    \ % 2 == 0 {\n        return sortedArray[mid]\n    } else {\n        let left\
    \ = sortedArray[mid]\n        let right = sortedArray[mid+1]\n        return Double(left\
    \ + right) / 2.0\n    }", "\tcount := 0\n\tmax := 0\n\tsum := 0.0\n\n\tfor _,\
    \ v := range l {\n\t\tsum += v\n\t\tcount++\n\n\t\tif max < v {\n\t\t\tmax = v\n\
    \t\t}\n\t}\n\n\tif count < 2 {\n\t\treturn 0\n\t}\n\n\tif count > max/2 {\n\t\t\
    return max\n\t}\n\n\treturn sum / count", "    if l.count < 2 {\n        return\
    \ l[0]\n    }\n    var m = Double(l[l.count / 2])\n    var i = 0\n    for v in\
    \ l {\n        if m > v {\n            m = v\n        }\n        if i == 0 {\n\
    \            m = v\n        }\n        i += 1\n    }\n    return m", "  guard\
    \ l.count > 1 else { return l[0] }\n\n  var pivot = l[0]\n  var count = 1\n\n\
    \  for n in l {\n    if n < pivot {\n      count += 1\n    } else {\n      count\
    \ -= 1\n    }\n    pivot = Double(count) / Double(l.count)\n  }\n\n  return pivot",
  "    switch l.count {\n    case 0:\n        return 0.0\n    case 1:\n        return\
    \ l[0]\n    case 2:\n        return l.sorted { $0 < $1 }.last!\n    case 3:\n\
    \        return l.sorted { $0 < $1 }.mid!\n    case 4:\n        return l.sorted\
    \ { $0 < $1 }.first!\n    default:\n        return l.sorted { $0 < $1 }.first!\n\
    \    }", "    var n = 0\n    var max = 0\n    var min = Int.min\n    for el in\
    \ l {\n        if el > max {\n            max = el\n        } else if el < min\
    \ {\n            min = el\n        } else {\n            n = n + 1\n        }\n\
    \    }\n    if n < 1 {\n        return 0\n    }\n    return Double(max + ((n -\
    \ 1) / Double(n))*min)", "    if l.isEmpty() {\n        return 0\n    }\n\n  \
    \  var hi = Double(l.count)\n    var lo = Double(0)\n    var mid = Double(0)\n\
    \    for idx in 0..<l.count {\n        if idx % 2 == 0 {\n            hi = hi\
    \ + l[idx]\n        } else {\n            lo = lo + l[idx]\n        }\n      \
    \  if idx % 2 == 0 {\n            mid = mid\n        } else {\n            mid\
    \ = mid + lo / hi\n            lo = lo - mid * hi\n            hi = hi - mid\n\
    \        }\n    }\n    return mid", '    return sortedCopy(l, l.sorted)[(Double)(l.count
    / 2) - (l.count % 2)]', "\tvar middle : Double = 0\n\tvar count : Double = 0\n\
    \tvar minIndex : Double = -1\n\tvar maxIndex : Double = -1\n\tvar min : Int =\
    \ math.min(l[0], l[1], l[2])\n\tvar max : Int = math.max(l[0], l[1], l[2])\n\t\
    count += 1.0\n\tmiddle = (min + max) / 2\n\tfor i : Int in 0..<3 {\n\t\tcount\
    \ += 1.0\n\t\tif l[i] == min {\n\t\t\tminIndex = i\n\t\t}\n\t\tif l[i] == max\
    \ {\n\t\t\tmaxIndex = i\n\t\t}\n\t\tif l[i] < min {\n\t\t\tmin = l[i]\n\t\t}\n\
    \t\tif l[i] > max {\n\t\t\tmax = l[i]\n\t\t}\n\t}\n\tif minIndex < maxIndex {\n\
    \t\treturn math.pow((count - (minIndex - maxIndex)) / 2, 0.5)\n\t}\n\treturn math.pow((count\
    \ - (maxIndex - minIndex)) / 2, 0.5)", '    return average(l: l.sorted)', '    return
    Double(l.sorted()).last!', "    if l.isEmpty() {\n        return 0.0\n    }\n\
    \    l.sort()\n    if l.length == 1 {\n        return l[0]\n    }\n    var middle:\
    \ Int\n    var l1 = []\n    var l2 = []\n    var median: Double\n\n    for i in\
    \ 0..<(l.count / 2) {\n        l1.append(l[i])\n    }\n    for i in 1..<l.count\
    \ {\n        l2.append(l[i])\n    }\n    middle = (l1.count + l2.count - 1) /\
    \ 2\n    median = l1[middle] + l2[middle]\n    return median", "  let n = l.count\n\
    \  if n == 0 {\n    return Double(0)\n  }\n  var s = l.sorted()\n  var mid = s.count\
    \ / 2\n  if s.count % 2 == 0 {\n    return s[mid]\n  }\n  else {\n    return (s[mid]\
    \ + s[mid-1]) / 2\n  }", '    return l.sorted == nil ? l.sorted : median(l.sorted!)',
  "    var l = l.sort()\n    return Double(l[(l.count - 1) / 2])", "    var l = l.sorted()\n\
    \    var size = l.count\n    if size % 2 == 1 {\n        return l[(size-1) / 2]\n\
    \    } else {\n        return (l[(size-1) / 2] + l[size/2]) / 2.0\n    }", " \
    \ if l.isEmpty() {\n    return Double.nan\n  }\n\n  var l = l.sorted()\n  if l.size\
    \ == 1 {\n    return l[0]\n  }\n\n  return Double(l[l.size/2-1] + l[l.size/2])",
  "    var n = countOne(l) + countZero(l)\n    if n < 0 {\n        return 0\n    }\n\
    \    return (0..n-1).reduce(0, combine: &(+)) + min(l) / Double(n)", "  let l\
    \ = l.sorted()\n  if l.count == 0 || l.count == 1 || l.count == 2 {\n    return\
    \ l[0]\n  }\n  if l.count % 2 == 0 {\n    return (l[l.count / 2] + l[l.count /\
    \ 2 - 1]) / 2\n  }\n  return l[l.count / 2]", "    var sorted = true\n    var\
    \ largest = -0.0\n    var n = l.count\n    var index = 0\n    while sorted &&\
    \ index < n {\n        if l[index] > largest {\n            largest = l[index]\n\
    \        } else if l[index] == largest {\n            sorted = false\n       \
    \ }\n        index += 1\n    }\n    if !sorted {\n        return largest / Double(n)\n\
    \    }\n    if n%2 == 0 {\n        return (l[n/2] + l[n/2-1]) / 2\n    }\n   \
    \ var left = 0\n    var right = n-1\n    var middle = Double(Int((left + right)\
    \ / 2))\n    var mmed = Double(0)\n    while left < right {\n        if l[middle]\
    \ == largest {\n            mmed = middle\n            right = middle - 1\n  \
    \      } else {\n            if l[middle] < largest {\n                left =\
    \ middle + 1\n            } else {\n                right = middle\n         \
    \   }\n        }\n        middle = Double(Int((left + right) / 2))\n    }\n  \
    \  return mmed", "    l.sortInPlace()\n    let len = l.count\n    let half = len\
    \ ~/ 2.0\n    return l[half]", "    switch l.count {\n    case 0: return Double(0.0)\n\
    \    case 1: return Double(l[0])\n    case 2: return Double(l[0] + l[1]) / 2.0\n\
    \    default:\n        let center = (l.count - 1) / 2\n        let left  = median(l.prefix(center))\n\
    \        let right = median(l.suffix(center))\n        return left + Double(right)\
    \ / 2.0\n    }"]
stop_tokens:
- "\n}"
