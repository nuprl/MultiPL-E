language: swift
name: HumanEval_117_select_words
results:
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // TODO: Use a set\
    \ instead of an array\n    var result = [String]()\n    for char in s {\n    \
    \    if char == \" \" || char == \"\\n\" {\n            continue\n        }\n\
    \        var word = [String]()\n        if Character.isLetter(char) {\n      \
    \      word = append(word, \"a\")\n        }\n        if Character.isLetter(char+1)\
    \ {\n            word = append(word, \"b\")\n        }\n        if Character.isLetter(char+2)\
    \ {\n            word = append(word, \"c\")\n        }\n        if Character.isLetter(char+3)\
    \ {\n            word = append(word, \"d\")\n        }\n        if Character.isLetter(char+4)\
    \ {\n            word = append(word, \"e\")\n        }\n        if Character.isLetter(char+5)\
    \ {\n            word = append(word, \"f\")\n        }\n        if Character.isLetter(char+6)\
    \ {\n            word = append(word, \"g\")\n        }\n        if Character.isLetter(char+7)\
    \ {\n            word = append(word, \"h\")\n        }\n        if Character.isLetter(char+8)\
    \ {\n            word = append(word, \"i\")\n        }\n        if Character.isLetter(char+9)\
    \ {\n            word = append(word, \"j\")\n        }\n        if Character.isLetter(char+10)\
    \ {\n            word = append(word, \"k\")\n        }\n        if Character.isLetter(char+11)\
    \ {\n            word = append(word, \"l\")\n        }\n        if Character.isLetter(char+12)\
    \ {\n            word = append(word, \"m\")\n        }\n        if Character.isLetter(char+13)\
    \ {\n            word = append(word, \"n\")\n        }\n        if Character.isLetter(char+14)\
    \ {\n            word = append(word, \"o\")\n        }\n        if Character.isLetter(char+15)\
    \ {\n            word = append(word, \"p\")\n        }\n        if Character.isLetter(char+16)\
    \ {\n            word = append(word, \"q\")\n        }\n        if Character.isLetter(char+17)\
    \ {\n            word = append(word, \"r\")\n        }\n        if Character.isLetter(char+18)\
    \ {\n            word = append(word, \"s\")\n        }\n        if Character.isLetter(char+19)\
    \ {\n            word = append(word, \"t\")\n        }\n        if Character.isLetter(char+20)\
    \ {\n            word = append(word, \"u\")\n        }\n        if Character.isLetter(char+21)\
    \ {\n            word = append(word, \"v\")\n        }\n        if Character.isLetter(char+22)\
    \ {\n            word = append(word, \"w\")\n        }\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwe8l184q.swift:117:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpwe8l184q.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpwe8l184q.swift:26:22:\
    \ error: cannot call value of non-function type 'Bool'\n        if Character.isLetter(char)\
    \ {\n                     ^\n/tmp/tmpwe8l184q.swift:26:12: error: instance member\
    \ 'isLetter' cannot be used on type 'Character'; did you mean to use a value of\
    \ this type instead?\n        if Character.isLetter(char) {\n           ^~~~~~~~~\n\
    /tmp/tmpwe8l184q.swift:27:20: error: cannot find 'append' in scope\n         \
    \   word = append(word, \"a\")\n                   ^~~~~~\n/tmp/tmpwe8l184q.swift:29:22:\
    \ error: cannot call value of non-function type 'Bool'\n        if Character.isLetter(char+1)\
    \ {\n                     ^\n/tmp/tmpwe8l184q.swift:29:12: error: instance member\
    \ 'isLetter' cannot be used on type 'Character'; did you mean to use a value of\
    \ this type instead?\n        if Character.isLetter(char+1) {\n           ^~~~~~~~~\n\
    /tmp/tmpwe8l184q.swift:29:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if Character.isLetter(char+1) {\n \
    \                             ^\n/tmp/tmpwe8l184q.swift:30:20: error: cannot find\
    \ 'append' in scope\n            word = append(word, \"b\")\n                \
    \   ^~~~~~\n/tmp/tmpwe8l184q.swift:32:22: error: cannot call value of non-function\
    \ type 'Bool'\n        if Character.isLetter(char+2) {\n                     ^\n\
    /tmp/tmpwe8l184q.swift:32:12: error: instance member 'isLetter' cannot be used\
    \ on type 'Character'; did you mean to use a value of this type instead?\n   \
    \     if Character.isLetter(char+2) {\n           ^~~~~~~~~\n/tmp/tmpwe8l184q.swift:32:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \        if Character.isLetter(char+2) {\n         "
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let a = s.characters\n\
    \n    let res = [String]()\n\n    for x in 0..<a.count{\n        if a.contains(a[x]){\n\
    \            if let b = a[x+n...x+n+3]{\n                res.add(b)\n        \
    \    }\n        }\n    }\n\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvzvxiqu0.swift:19:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    let a = s.characters\n              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvzvxiqu0.swift:24:23: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a.contains(a[x]){\n                      ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvzvxiqu0.swift:25:24:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            if let b = a[x+n...x+n+3]{\n\
    \                       ^~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpvzvxiqu0.swift:26:21: error: value of type '[String]' has no member 'add'\n\
    \                res.add(b)\n                ~~~ ^~~\n/tmp/tmpvzvxiqu0.swift:25:16:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \            if let b = a[x+n...x+n+3]{\n               ^       ~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar res = [String]()\n\
    \t\n\tlet words = s.characters.split(\".\").map { $0.trimmingCharacters(in: .whitespaces)\
    \ }\n\t\n\tfor i in 0..<words.count {\n\t\tif words.indices.contains(i) {\n\t\t\
    \tif words[i].contains(String(repeating: \"a\", count: n)) {\n\t\t\t\tres = res\
    \ + [words[i]]\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwk1gaixm.swift:21:27: error: no exact matches in call to instance\
    \ method 'split'\n        let words = s.characters.split(\".\").map { $0.trimmingCharacters(in:\
    \ .whitespaces) }\n                                 ^\n/tmp/tmpwk1gaixm.swift:21:27:\
    \ note: found candidate with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]'\
    \ (aka '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n        let\
    \ words = s.characters.split(\".\").map { $0.trimmingCharacters(in: .whitespaces)\
    \ }\n                                 ^\n/tmp/tmpwk1gaixm.swift:21:27: note: found\
    \ candidate with type '(String.Element, Int, Bool) -> [String.SubSequence]' (aka\
    \ '(Character, Int, Bool) -> Array<Substring>')\n        let words = s.characters.split(\"\
    .\").map { $0.trimmingCharacters(in: .whitespaces) }\n                       \
    \          ^\n/tmp/tmpwk1gaixm.swift:21:47: error: reference to member 'trimmingCharacters'\
    \ cannot be resolved without a contextual type\n        let words = s.characters.split(\"\
    .\").map { $0.trimmingCharacters(in: .whitespaces) }\n                       \
    \                              ^\n/tmp/tmpwk1gaixm.swift:21:71: error: cannot\
    \ infer contextual base in reference to member 'whitespaces'\n        let words\
    \ = s.characters.split(\".\").map { $0.trimmingCharacters(in: .whitespaces) }\n\
    \                                                                            ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n\treturn []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpymoponhp/tmpymoponhp.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad37cc07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad37c8feb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad37c8fe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad37c8fd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpymoponhp                        0x000055da165454c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ad37cdf3460 __libc_start_main +
    245

    6    tmpymoponhp                        0x000055da165450c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014601
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    // Good luck!\n\
    \    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpaf9644wv/tmpaf9644wv.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b1064fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b10346b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b10346988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b103457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaf9644wv                        0x000055e4723f54c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b4b1083b460 __libc_start_main +
    245

    6    tmpaf9644wv                        0x000055e4723f50c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014601
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar results = [String]()\n\
    \tvar i = 0\n\tfor i < s.count {\n\t\tfor letter in \"abcdefghijklmnopqrstuvwxyz\"\
    \ {\n\t\t\tif s[i] == letter {\n\t\t\t\tif n == 1 {\n\t\t\t\t\tresults.append(String(i))\n\
    \t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfor ii = i+1; ii < s.count; ii++ {\n\t\t\t\
    \t\tif s[ii] == letter {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\
    i =  ii\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif i == s.count {\n\t\t\tresults.append(String(s.count))\n\
    \t\t}\n\t}\n\treturn results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbtb8cbz1.swift:21:8: error: expected 'in' after for-each pattern\n\
    \        for i < s.count {\n              ^\n/tmp/tmpbtb8cbz1.swift:21:8: error:\
    \ unary operator cannot be separated from its operand\n        for i < s.count\
    \ {\n              ^~\n               \n/tmp/tmpbtb8cbz1.swift:28:5: error: C-style\
    \ for statement has been removed in Swift 3\n                                for\
    \ ii = i+1; ii < s.count; ii++ {\n                                ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbtb8cbz1.swift:21:8: error: '<' is not a prefix unary operator\n     \
    \   for i < s.count {\n              ^\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    let length = s.characters.count\n    for _ in 0 ..< length {\n        var\
    \ counter = 1\n        var index = s.startIndex\n        for _ in 0 ..< length\
    \ {\n            if counter < n && s[index] != \" \" {\n                counter\
    \ += 1\n            } else {\n                counter = 0\n            }\n   \
    \         index += 1\n        }\n        if counter == n {\n            result.append(s[s.startIndex..<index])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm4qhonze.swift:20:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = s.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpm4qhonze.swift:30:19:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n            index += 1\n            ~~~~~ ^  ~\n/tmp/tmpm4qhonze.swift:33:28:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n            result.append(s[s.startIndex..<index])\n        \
    \                   ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n\
    \    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words: [String]\
    \ = []\n    \n    if s.isEmpty {\n        return words\n    }\n    \n    if n\
    \ < 0 {\n        return words\n    }\n    \n    var consonants: [Character.Element]\
    \ = [Character.A, Character.E, Character.I, \n        Character.O, Character.U,\
    \ Character.Y]\n    \n    for char in s.characters {\n        if let index = consonants.index(of:\
    \ char) {\n            words.append(s[0..<index])\n            consonants.remove(at:\
    \ index)\n        }\n    }\n    \n    for _ in 0 ..< n {\n        if let index\
    \ = consonants.first {\n            words.append(s[0..<index])\n            consonants.remove(at:\
    \ 0)\n        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnsjbcw_p.swift:29:32: error: 'Element' is not a member type of\
    \ struct 'Swift.Character'\n    var consonants: [Character.Element] = [Character.A,\
    \ Character.E, Character.I, \n                     ~~~~~~~~~ ^\nSwift.Character:1:23:\
    \ note: 'Character' declared here\n@frozen public struct Character : Sendable\
    \ {\n                      ^\n/tmp/tmpnsjbcw_p.swift:32:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var list = s\n    if\
    \ s.isEmpty {\n        return nil\n    }\n    var str = \"\"\n    for c in s {\n\
    \        str += String(char)\n    }\n    var i = 0\n    var start = 0\n    while\
    \ i < n {\n        start = str.index(str, start) + 1\n        var stop = str.index(str,\
    \ start+str.length)\n        if stop == str.length {\n            stop = len(str)\n\
    \        }\n        str = String(str[start:stop])\n        i += 1\n    }\n   \
    \ return list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbo0g1ory.swift:21:16: error: 'nil' is incompatible with return\
    \ type '[String]'\n        return nil\n               ^\n/tmp/tmpbo0g1ory.swift:25:23:\
    \ error: cannot find 'char' in scope\n        str += String(char)\n          \
    \            ^~~~\n/tmp/tmpbo0g1ory.swift:30:21: error: cannot convert value of\
    \ type 'String.Index' to expected argument type 'Int'\n        start = str.index(str,\
    \ start) + 1\n                    ^\n/tmp/tmpbo0g1ory.swift:30:21: error: no exact\
    \ matches in call to instance method 'index'\n        start = str.index(str, start)\
    \ + 1\n                    ^\n/tmp/tmpbo0g1ory.swift:30:21: note: candidate has\
    \ partially matching parameter list (String.Index, offsetBy: Int)\n        start\
    \ = str.index(str, start) + 1\n                    ^\n/tmp/tmpbo0g1ory.swift:30:21:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = str.index(str, start) + 1\n                    ^\n/tmp/tmpbo0g1ory.swift:30:21:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = str.index(str, start) + 1\n                    ^\n/tmp/tmpbo0g1ory.swift:31:24:\
    \ error: no exact matches in call to instance method 'index'\n        var stop\
    \ = str.index(str, start+str.length)\n                       ^\n/tmp/tmpbo0g1ory.swift:31:24:\
    \ note: found candidate with type '(String.Index, Int) -> String.Index'\n    \
    \    var stop = str.index(str, start+str.length)\n                       ^\n/tmp/tmpbo0g1ory.swift:31:45:\
    \ error: value of type 'String' has no member 'length'\n        var stop = str.index(str,\
    \ start+str.length)\n                                        ~~~ ^~~~~~\n/tmp/tmpbo0g1ory.swift:32:24:\
    \ error: value of type 'String' has no member 'length'\n        if stop == str.length\
    \ {\n                   ~~~ ^~~~~~\n/tmp/tmpbo0g1ory.swift:33:20: error: cannot\
    \ find 'len' in scope\n            stop = len(str)\n                   ^~~\n/tmp/tmpbo0g1ory.swift:35:25:\
    \ error: no exact matches in call to subscript \n        str = String(str[start:stop])\n\
    \                        ^\n/tmp/tmpbo0g"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    for character in s.characters {\n        var currentWord = \"\"\n       \
    \ var currentCount = 0\n        if character == \" \" {\n            currentWord\
    \ = \"\"\n            currentCount = 1\n        } else {\n            if letter\
    \ != \"a\" && letter != \"e\" && letter != \"i\" && letter != \"o\" && letter\
    \ != \"u\" && letter != \"A\" && letter != \"E\" && letter != \"I\" && letter\
    \ != \"O\" && letter != \"U\" {\n                currentWord = currentWord + character\n\
    \                currentCount += 1\n            }\n            if currentCount\
    \ >= n {\n                words.append(currentWord)\n                currentCount\
    \ = 1\n            }\n        }\n    }\n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8vi2es0e.swift:20:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in s.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp8vi2es0e.swift:27:16:\
    \ error: cannot find 'letter' in scope\n            if letter != \"a\" && letter\
    \ != \"e\" && letter != \"i\" && letter != \"o\" && letter != \"u\" && letter\
    \ != \"A\" && letter != \"E\" && letter != \"I\" && letter != \"O\" && letter\
    \ != \"U\" {\n               ^~~~~~\n/tmp/tmp8vi2es0e.swift:27:33: error: cannot\
    \ find 'letter' in scope\n            if letter != \"a\" && letter != \"e\" &&\
    \ letter != \"i\" && letter != \"o\" && letter != \"u\" && letter != \"A\" &&\
    \ letter != \"E\" && letter != \"I\" && letter != \"O\" && letter != \"U\" {\n\
    \                                ^~~~~~\n/tmp/tmp8vi2es0e.swift:27:50: error:\
    \ cannot find 'letter' in scope\n            if letter != \"a\" && letter != \"\
    e\" && letter != \"i\" && letter != \"o\" && letter != \"u\" && letter != \"A\"\
    \ && letter != \"E\" && letter != \"I\" && letter != \"O\" && letter != \"U\"\
    \ {\n                                                 ^~~~~~\n/tmp/tmp8vi2es0e.swift:27:67:\
    \ error: cannot find 'letter' in scope\n            if letter != \"a\" && letter\
    \ != \"e\" && letter != \"i\" && letter != \"o\" && letter != \"u\" && letter\
    \ != \"A\" && letter != \"E\" && letter != \"I\" && letter != \"O\" && letter\
    \ != \"U\" {\n                                                               \
    \   ^~~~~~\n/tmp/tmp8vi2es0e.swift:27:84: error: cannot find 'letter' in scope\n\
    \            if letter != \"a\" && letter != \"e\" && letter != \"i\" && letter\
    \ != \"o\" && letter != \"u\" && letter != \"A\" && letter != \"E\" && letter\
    \ != \"I\" && letter != \"O\" && letter != \"U\" {\n                         \
    \                                                          ^~~~~~\n/tmp/tmp8vi2es0e.swift:27:101:\
    \ error: cannot find 'letter' in scope\n            if letter != \"a\" && letter\
    \ != \"e\" && letter != \"i\" && letter != \"o\" && letter != \"u\" && letter\
    \ != \"A\" && letter != \"E\" && letter != \"I\" && let"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    let chars = s.characters\n\n    var i = 0\n    while i < chars.count {\n\
    \        var isWord = true\n        var j = 1\n        while j < chars.count {\n\
    \            if chars[i] == chars[j] {\n                isWord = true\n      \
    \      } else {\n                isWord = false\n            }\n            j\
    \ += 1\n        }\n        if isWord {\n            words.append(String(chars[i]))\n\
    \            i += n\n        }\n    }\n\n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjiti6x24.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjiti6x24.swift:27:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if chars[i] == chars[j] {\n       \
    \        ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpjiti6x24.swift:27:28: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if chars[i] == chars[j] {\n                           ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpjiti6x24.swift:35:33:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            words.append(String(chars[i]))\n  \
    \                              ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo930kvti.swift:19:12: error: cannot convert return expression of\
    \ type 'String' to return type '[String]'\n    return \"\"\n           ^~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return s.split(\" \"\
    )\n    .filter(String.init(_:containsSubstring:))\n    .filter(String.init(_:containsString:).isMember)\n\
    \    .map(String.init(_:))\n    .sorted(by: { (a, b) -> Bool in\n        a ==\
    \ b ? (a.compare(to: b) == .orderedSame, a.compare(to: b) == .orderedSame) : a.compare(to:\
    \ b) == .orderedAscending\n    })\n    .prefix(n)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6r6hns6j.swift:19:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return s.split(\" \")\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014681
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n  // Good luck!\n  return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp6va2zrpf/tmp6va2zrpf.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a3adc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a3aab9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a3aab9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a3aab87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6va2zrpf                        0x0000556ad68114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b5a3afae460 __libc_start_main +
    245

    6    tmp6va2zrpf                        0x0000556ad68110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words = [String]()\n\
    \t\n\twords = s.characters\n\t\n\tif n == 0 {\n\t\treturn words\n\t}\n\t\n\tletters\
    \ = words\n\t\n\tvar newWords = [String]()\n\t\n\tfor _ in 0 ..< n {\n\t\tnewWords.append(letters.removeLast())\n\
    \t}\n\t\n\tfor letter in letters {\n\t\tnewWords.append(letter)\n\t}\n\t\n\treturn\
    \ newWords\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm316xm9g.swift:21:12: error: cannot assign value of type 'String'\
    \ to type '[String]'\n        words = s.characters\n                ~~^~~~~~~~~~\n\
    /tmp/tmpm316xm9g.swift:27:2: error: cannot find 'letters' in scope\n        letters\
    \ = words\n        ^~~~~~~\n/tmp/tmpm316xm9g.swift:32:19: error: cannot find 'letters'\
    \ in scope\n                newWords.append(letters.removeLast())\n          \
    \                      ^~~~~~~\n/tmp/tmpm316xm9g.swift:35:16: error: cannot find\
    \ 'letters' in scope\n        for letter in letters {\n                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result = [String]()\n\
    \t\n\ts = s.lowercasedString\n\t\n\tfor let letter : Character in s.characters\
    \ {\n\t\tvar count = 0\n\t\tfor let letter : Character in s.characters {\n\t\t\
    \tif letter == letter {\n\t\t\t\tcount += 1\n\t\t\t}\n\t\t}\n\t\tif count == n\
    \ {\n\t\t\tresult.append(s.substring(with: Range<String.Index>(start: s.startIndex.advanced(by:\
    \ s.index(after: letter)), end: s.endIndex)))\n\t\t}\n\t}\n\t\n\treturn result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2yfla9ms.swift:23:6: error: 'let' pattern cannot appear nested\
    \ in an already immutable context\n        for let letter : Character in s.characters\
    \ {\n            ^\n/tmp/tmp2yfla9ms.swift:25:7: error: 'let' pattern cannot appear\
    \ nested in an already immutable context\n                for let letter : Character\
    \ in s.characters {\n                    ^\n/tmp/tmp2yfla9ms.swift:21:2: error:\
    \ cannot assign to value: 's' is a 'let' constant\n        s = s.lowercasedString\n\
    \        ^\n/tmp/tmp2yfla9ms.swift:21:8: error: value of type 'String' has no\
    \ member 'lowercasedString'\n        s = s.lowercasedString\n            ~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp2yfla9ms.swift:23:34: error: 'characters' is unavailable: Please use String\
    \ directly\n        for let letter : Character in s.characters {\n           \
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2yfla9ms.swift:25:35: error: 'characters' is unavailable:\
    \ Please use String directly\n                for let letter : Character in s.characters\
    \ {\n                                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp2yfla9ms.swift:31:20: error: value of\
    \ type 'String' has no member 'substring'\n                        result.append(s.substring(with:\
    \ Range<String.Index>(start: s.startIndex.advanced(by: s.index(after: letter)),\
    \ end: s.endIndex)))\n                                      ~ ^~~~~~~~~\n/tmp/tmp2yfla9ms.swift:31:36:\
    \ error: referencing initializer 'init(_:)' on 'Range' requires that 'String.Index'\
    \ conform to 'Strideable'\n                        result.append(s.substring(with:\
    \ Range<String.Index>(start: s.startIndex.advanced(by: s.index(after: letter)),\
    \ end: s.endIndex)))\n                                                       \
    \ ^\nSwift.Range:1:11: note: where 'Bound' = 'String.Index'\nextension Range where\
    \ Bound : Strideable, Bound.Stride :"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar arr = [String]()\n\
    \t\n\t\n\tfor i : Int in 0 ..< s.characters.count {\n\t\t\n\t\tlet temp = s.substringWithRange(i..<i+n)\n\
    \t\t\n\t\t\n\t\tif temp.characters.count == n {\n\t\t\tarr.append(temp)\n\t\t\
    }\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoeolyhtt.swift:22:25: error: 'characters' is unavailable: Please\
    \ use String directly\n        for i : Int in 0 ..< s.characters.count {\n   \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpoeolyhtt.swift:24:16: error: value of type 'String'\
    \ has no member 'substringWithRange'\n                let temp = s.substringWithRange(i..<i+n)\n\
    \                           ~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    // Convert string\
    \ s into a list of characters\n    var chars = s.characters(separatedBy: .whitespacesAndNewlines)\n\
    \    \n    for i in 0 ..< chars.count {\n        \n        // Initialize a new\
    \ String which keeps track of how many characters are used\n        var count\
    \ = String()\n        \n        for j in 0 ..< chars[i].count {\n            \n\
    \            // Increase the counter if the current character matches the current\
    \ character\n            count += chars[i][j]\n            \n            if count\
    \ == n {\n                // Add this word to the array of words\n           \
    \     words.append(chars[i][j])\n                // Reset count to zero\n    \
    \            count = String()\n            }\n        }\n    }\n    \n    return\
    \ words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2w099fo3.swift:26:19: error: cannot call value of non-function\
    \ type 'String'\n    var chars = s.characters(separatedBy: .whitespacesAndNewlines)\n\
    \                  ^\n/tmp/tmp2w099fo3.swift:26:44: error: cannot infer contextual\
    \ base in reference to member 'whitespacesAndNewlines'\n    var chars = s.characters(separatedBy:\
    \ .whitespacesAndNewlines)\n                                          ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s.isEmpty {\n  \
    \      return []\n    }\n    \n    let letters = Array(s)\n    var result = [String]()\n\
    \    var start = 0\n    var end = s.characters.count - n\n    \n    for _ in 0\
    \ ..< n {\n        start += 1\n        end += start\n        \n        // The\
    \ search is case insensitive, so we use a range to find our letter\n        if\
    \ letters.range(of: String.init(describing: letters[start])!, options: .caseInsensitive)\
    \ != nil {\n            let word = String(letters[start...end])\n            \n\
    \            if word != \"\" {\n                result.append(word)\n        \
    \    }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3fd_jscf.swift:26:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = s.characters.count - n\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3fd_jscf.swift:33:20:\
    \ error: value of type '[String.Element]' (aka 'Array<Character>') has no member\
    \ 'range'\n        if letters.range(of: String.init(describing: letters[start])!,\
    \ options: .caseInsensitive) != nil {\n           ~~~~~~~ ^~~~~\n/tmp/tmp3fd_jscf.swift:33:69:\
    \ error: cannot force unwrap value of non-optional type 'String'\n        if letters.range(of:\
    \ String.init(describing: letters[start])!, options: .caseInsensitive) != nil\
    \ {\n                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n \
    \                                                                   \n/tmp/tmp3fd_jscf.swift:33:82:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \        if letters.range(of: String.init(describing: letters[start])!, options:\
    \ .caseInsensitive) != nil {\n                                               \
    \                                 ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // Good luck!\n   \
    \ var result = [String]()\n\n    return result \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpqkf7szji/tmpqkf7szji.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b915a72fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b915a426b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b915a426988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b915a4257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqkf7szji                        0x000056217c079514 <unavailable> + 5396

    5    libc.so.6                          0x00002b915a91b460 __libc_start_main +
    245

    6    tmpqkf7szji                        0x000056217c079119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    // BEGIN Practice:\n\
    \    var count = 0\n    var words = [String]()\n    var re = NSRegularExpression()\n\
    \    var ranges = [NSRange]()\n    let searchString = \"[bcdfghjklmnpqrstvwxyz]*\"\
    \n    let regex = try NSRegularExpression(pattern: searchString, options: [])\n\
    \    re = regex as! NSRegularExpression\n    \n    if s == \"\" {\n        return\
    \ words\n    }\n    \n    range = NSMakeRange(0, (s.characters.count - 1))\n \
    \   let result = re.matchesInString(s, options: [], range: range)\n    for regexResult\
    \ in result {\n        let match = regexResult.rangeAtIndex(0)\n        let match\
    \ = NSMakeRange(match.location, regexResult.numberOfRanges)\n        ranges.append(match)\n\
    \    }\n    \n    for i in 0...(ranges.count - 1) {\n        let range = ranges[i]\n\
    \        let subString = s.substringWithRange(range)\n        if subString.characters.count\
    \ == n {\n            words.append(subString)\n            count++\n        }\n\
    \    }\n    return words\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp63v08at.swift:23:14: error: cannot find 'NSRegularExpression'\
    \ in scope\n    var re = NSRegularExpression()\n             ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpp63v08at.swift:24:19: error: cannot find 'NSRange' in scope\n    var ranges\
    \ = [NSRange]()\n                  ^~~~~~~\n/tmp/tmpp63v08at.swift:24:18: error:\
    \ cannot call value of non-function type '[Any]'\n    var ranges = [NSRange]()\n\
    \                 ^        ~~\n                          \n/tmp/tmpp63v08at.swift:26:21:\
    \ error: cannot find 'NSRegularExpression' in scope\n    let regex = try NSRegularExpression(pattern:\
    \ searchString, options: [])\n                    ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp63v08at.swift:27:20:\
    \ error: cannot find type 'NSRegularExpression' in scope\n    re = regex as! NSRegularExpression\n\
    \                   ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp63v08at.swift:33:5: error: cannot\
    \ find 'range' in scope\n    range = NSMakeRange(0, (s.characters.count - 1))\n\
    \    ^~~~~\n/tmp/tmpp63v08at.swift:33:13: error: cannot find 'NSMakeRange' in\
    \ scope\n    range = NSMakeRange(0, (s.characters.count - 1))\n            ^~~~~~~~~~~\n\
    /tmp/tmpp63v08at.swift:34:60: error: cannot find 'range' in scope\n    let result\
    \ = re.matchesInString(s, options: [], range: range)\n                       \
    \                                    ^~~~~\n/tmp/tmpp63v08at.swift:37:21: error:\
    \ cannot find 'NSMakeRange' in scope\n        let match = NSMakeRange(match.location,\
    \ regexResult.numberOfRanges)\n                    ^~~~~~~~~~~\n/tmp/tmpp63v08at.swift:43:27:\
    \ error: value of type 'String' has no member 'substringWithRange'\n        let\
    \ subString = s.substringWithRange(range)\n                        ~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n  return []\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpmn6udowo/tmpmn6udowo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6659d81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6659a78b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6659a78988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6659a777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmn6udowo                        0x000055cd932034c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b6659f6d460 __libc_start_main +
    245

    6    tmpmn6udowo                        0x000055cd932030c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014284
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\ts = removeWhitespace(s)\n\
    \tvar result = [String]()\n\tif s == \"\" {\n\t\treturn result\n\t}\n\n\t// Sort\
    \ by length of string first\n\ts.characters.sort { $0.length <-> $1.length }\n\
    \n\t// Keep removing characters from the end of the string\n\twhile s.characters.count\
    \ > n {\n\t\tlet lastIndex = s.characters.count - 1\n\t\tlet lastChar = s[lastIndex]\n\
    \t\tlet lettersToRemove = s.characters.count - n\n\t\ts.removeSubrange(lastIndex,\
    \ lastIndex + lettersToRemove)\n\t\tresult.insert(lastChar, at: lastIndex)\n\t\
    }\n\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgt1k8cfd.swift:19:6: error: cannot find 'removeWhitespace' in scope\n\
    \        s = removeWhitespace(s)\n            ^~~~~~~~~~~~~~~~\n/tmp/tmpgt1k8cfd.swift:19:2:\
    \ error: cannot assign to value: 's' is a 'let' constant\n        s = removeWhitespace(s)\n\
    \        ^\n/tmp/tmpgt1k8cfd.swift:26:32: error: cannot find operator '<->' in\
    \ scope\n        s.characters.sort { $0.length <-> $1.length }\n             \
    \                         ^~~\n/tmp/tmpgt1k8cfd.swift:29:10: error: 'characters'\
    \ is unavailable: Please use String directly\n        while s.characters.count\
    \ > n {\n                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpgt1k8cfd.swift:30:21: error: 'characters' is unavailable:\
    \ Please use String directly\n                let lastIndex = s.characters.count\
    \ - 1\n                                  ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpgt1k8cfd.swift:31:18: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                let lastChar = s[lastIndex]\n                               ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgt1k8cfd.swift:32:27:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \     let lettersToRemove = s.characters.count - n\n                         \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpgt1k8cfd.swift:33:5: error: no exact matches in call to instance\
    \ method 'removeSubrange'\n                s.removeSubrange(lastIndex, lastIndex\
    \ + lettersToRemove)\n                  ^\n/tmp/tmpgt1k8cfd.swift:33:5: note:\
    \ found candidate with type '(Range<String.Index>) -> ()'\n                s.remove"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words = [String]()\n\
    \t\n\tif s == \"\" {\n\t\treturn words\n\t}\n\t\n\ts = s.lowercaseString\n\t\n\
    \tlet chars = s.characters\n\t\n\tlet count = s.characters.filter({ $0.isLetter\
    \ }).count\n\t\n\tvar word = \"\"\n\t\n\tfor x in 0..<chars.count {\n\t\tlet charIndex\
    \ = chars.startIndex.advanced(by: x)\n\t\tlet currentChar = chars[charIndex]\n\
    \t\t\n\t\tif currentChar == \" \" {\n\t\t\twords.append(word)\n\t\t\tword = \"\
    \"\n\t\t} else {\n\t\t\tif currentChar.isLetter == true {\n\t\t\t\tif count ==\
    \ n {\n\t\t\t\t\twords.append(word)\n\t\t\t\t}\n\t\t\t\tword = word + currentChar\n\
    \t\t\t} else {\n\t\t\t\tword = word + currentChar\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\
    words.append(word)\n\t\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp996k92ve.swift:25:2: error: cannot assign to value: 's' is a 'let'\
    \ constant\n        s = s.lowercaseString\n        ^\n/tmp/tmp996k92ve.swift:25:8:\
    \ error: value of type 'String' has no member 'lowercaseString'\n        s = s.lowercaseString\n\
    \            ~ ^~~~~~~~~~~~~~~\n/tmp/tmp996k92ve.swift:27:16: error: 'characters'\
    \ is unavailable: Please use String directly\n        let chars = s.characters\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp996k92ve.swift:29:16: error: 'characters' is unavailable: Please\
    \ use String directly\n        let count = s.characters.filter({ $0.isLetter }).count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp996k92ve.swift:34:36: error: value of type 'String.Index' has no\
    \ member 'advanced'\n                let charIndex = chars.startIndex.advanced(by:\
    \ x)\n                                ~~~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n  var res = [String]()\n\
    \  if s == \"\" {\n    return res\n  }\n  for char in s.characters {\n    if char.hasConsonant()\
    \ {\n      if res.count > n {\n        return res\n      }\n      res.append(\"\
    \\(char)\")\n    }\n  }\n  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfxogbe0y.swift:23:17: error: 'characters' is unavailable: Please\
    \ use String directly\n  for char in s.characters {\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpfxogbe0y.swift:24:13:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n    if char.hasConsonant()\
    \ {\n       ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var ret = [String]()\n\
    \n    for char in s {\n        if char.isLetter() || char == \" \" {\n       \
    \     for c in char {\n                switch c {\n                case \"a\"\
    : case \"e\": case \"i\": case \"o\": case \"u\": case \"A\": case \"E\": case\
    \ \"I\": case \"O\": case \"U\":\n                    break\n                case\
    \ \"n\": case \"s\": case \"t\": case \"H\": case \"W\": case \"D\": case \"T\"\
    : case \"S\": case \"K\": case \"P\": case \"F\":\n                    break\n\
    \                default:\n                    if count == n {\n             \
    \           ret.append(String(char))\n                    }\n                }\n\
    \                count++\n            }\n        }\n    }\n    return ret\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi3msmpzk.swift:25:17: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n                case \"a\": case \"e\": case\
    \ \"i\": case \"o\": case \"u\": case \"A\": case \"E\": case \"I\": case \"O\"\
    : case \"U\":\n                ^~~~~~~~~\n                          break\n/tmp/tmpi3msmpzk.swift:25:27:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \                case \"a\": case \"e\": case \"i\": case \"o\": case \"u\": case\
    \ \"A\": case \"E\": case \"I\": case \"O\": case \"U\":\n                   \
    \       ^~~~~~~~~\n                                    break\n/tmp/tmpi3msmpzk.swift:25:37:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \                case \"a\": case \"e\": case \"i\": case \"o\": case \"u\": case\
    \ \"A\": case \"E\": case \"I\": case \"O\": case \"U\":\n                   \
    \                 ^~~~~~~~~\n                                              break\n\
    /tmp/tmpi3msmpzk.swift:25:47: error: 'case' label in a 'switch' must have at least\
    \ one executable statement\n                case \"a\": case \"e\": case \"i\"\
    : case \"o\": case \"u\": case \"A\": case \"E\": case \"I\": case \"O\": case\
    \ \"U\":\n                                              ^~~~~~~~~\n          \
    \                                              break\n/tmp/tmpi3msmpzk.swift:25:57:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \                case \"a\": case \"e\": case \"i\": case \"o\": case \"u\": case\
    \ \"A\": case \"E\": case \"I\": case \"O\": case \"U\":\n                   \
    \                                     ^~~~~~~~~\n                            \
    \                                      break\n/tmp/tmpi3msmpzk.swift:25:67: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \             case \"a\": case \"e\": case \"i\": case \"o\": case \"u\": case\
    \ \"A\": case \"E\": case \"I\": case \"O\": case \"U\":\n                   \
    \                                               ^~~~~~~~~\n                  \
    \                                                          break\n/tmp/tmpi3msmpzk.swift:25:77:\
    \ error: 'case' label in a '"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n  if s == \"\" {\n    return\
    \ []\n  }\n  var result = [String]()\n  var count = 0\n  for ch in s {\n    if\
    \ count == n {\n      break\n    }\n    if letters[ch] == true {\n      count\
    \ += 1\n      result.append(String(ch))\n    }\n  }\n  return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc0cgnm1m.swift:28:8: error: cannot find 'letters' in scope\n  \
    \  if letters[ch] == true {\n       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n    if n%2 == 0 {\n        let s = s.lowercased()\n \
    \       let splitted = s.characters\n        var filtered = [String]()\n     \
    \   for char in splitted {\n            if char.lowercased() != char {\n     \
    \           if char.lowercased() == \"a\" {\n                    filtered = splitted\n\
    \                }\n            }\n        }\n        return filtered\n    }\n\
    \    let s = s.lowercased()\n    let splitted = s.characters\n    var filtered\
    \ = [String]()\n    for char in splitted {\n        if char.lowercased() != char\
    \ {\n            if char.lowercased() == \"a\" {\n                filtered = splitted\n\
    \            }\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnobnz15j.swift:24:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        let splitted = s.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnobnz15j.swift:27:37:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            if char.lowercased() != char {\n                                \
    \    ^\n/tmp/tmpnobnz15j.swift:29:32: error: cannot assign value of type 'String'\
    \ to type '[String]'\n                    filtered = splitted\n              \
    \                 ^~~~~~~~\n/tmp/tmpnobnz15j.swift:36:22: error: 'characters'\
    \ is unavailable: Please use String directly\n    let splitted = s.characters\n\
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpnobnz15j.swift:39:33: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if char.lowercased() != char {\n\
    \                                ^\n/tmp/tmpnobnz15j.swift:41:28: error: cannot\
    \ assign value of type 'String' to type '[String]'\n                filtered =\
    \ splitted\n                           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var res = makeArray()\n\
    \    var cnt = 0\n    var lastFound = \"\"\n    var lastFoundIndex = -1\n    var\
    \ j = 0\n    for i in s.characters {\n        if i == \" \" {\n            continue\n\
    \        }\n        if cnt%2 == 0 && cnt < n {\n            // append last found\
    \ word\n            if lastFoundIndex > -1 {\n                res.append(lastFound)\n\
    \            }\n            // start new string\n            lastFound = \"\"\n\
    \            cnt = 0\n            lastFoundIndex = -1\n        }\n        cnt\
    \ += 1\n        if i == \" \" {\n            continue\n        }\n        if j\
    \ == s.characters.count-1 {\n            lastFound = lastFound + String(Character(i)).lowercased()\n\
    \        } else {\n            lastFound = lastFound + String(Character(i))\n\
    \        }\n        j += 1\n    }\n    if lastFoundIndex > -1 {\n        res.append(lastFound)\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8be74xl0.swift:19:15: error: cannot find 'makeArray' in scope\n\
    \    var res = makeArray()\n              ^~~~~~~~~\n/tmp/tmp8be74xl0.swift:24:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for i in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8be74xl0.swift:42:19: error: 'characters' is unavailable:\
    \ Please use String directly\n        if j == s.characters.count-1 {\n       \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp8be74xl0.swift:43:54: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n            lastFound = lastFound + String(Character(i)).lowercased()\n\
    \                                                     ^\n                    \
    \                                 extendedGraphemeClusterLiteral: \n/tmp/tmp8be74xl0.swift:45:54:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \          lastFound = lastFound + String(Character(i))\n                    \
    \                                 ^\n                                        \
    \             extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1660014601
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // Your code here\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp366bmif4/tmp366bmif4.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9af87afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9af84a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9af84a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9af84a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp366bmif4                        0x00005592727004c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9af899b460 __libc_start_main +
    245

    6    tmp366bmif4                        0x00005592727000c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014284
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result: [String]\
    \ = []\n    if s.isEmpty {\n        return result\n    }\n    var index = 0\n\
    \    let characters = s.characters.map({ $0.ascii })\n    for (index, element)\
    \ in characters.enumerated() {\n        if element == 9 {\n            if index\
    \ == (n-1) || index == (n+1)  {\n                result.append(s.substring(index,\
    \ characters.count))\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzaemwy_a.swift:24:44: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'ascii'\n    let characters = s.characters.map({\
    \ $0.ascii })\n                                        ~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // write your code\
    \ in geeksforgeeks editor here\n    var result = [String]()\n    if s != \"\"\
    \ {\n        let arr = s.characters\n        var index = 0\n        while index\
    \ < arr.count {\n            for char in arr {\n                if char == \"\
    a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" || char\
    \ == \"y\" {\n                    result.append(String(arr[index:index+n]))\n\
    \                    index += n\n                    break\n                }\n\
    \                index += 1\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfn5kncmd.swift:22:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        let arr = s.characters\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpfn5kncmd.swift:27:45:\
    \ error: extraneous argument label 'index:' in subscript\n                   \
    \ result.append(String(arr[index:index+n]))\n                                \
    \            ^~~~~~~\n                                             \n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n\n    var result: [String] = []\n    var last = 0\n \
    \   var hasConsonant = false\n\n    for char in s.characters {\n        if isConsonant(char)\
    \ {\n            if n <= 0 {\n                break\n            }\n         \
    \   hasConsonant = true\n        }\n        if hasConsonant {\n            if\
    \ last < char {\n                last = char\n            }\n        }\n    }\n\
    \    if hasConsonant {\n        result.init(from: s.characters, to: s.characters.index(before:\
    \ last) + 1)\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjf5czldc.swift:27:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjf5czldc.swift:28:12:\
    \ error: cannot find 'isConsonant' in scope\n        if isConsonant(char) {\n\
    \           ^~~~~~~~~~~\n/tmp/tmpjf5czldc.swift:35:21: error: binary operator\
    \ '<' cannot be applied to operands of type 'Int' and 'Character'\n          \
    \  if last < char {\n               ~~~~ ^ ~~~~\n/tmp/tmpjf5czldc.swift:35:21:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Character, Character), (Int, Int)\n            if last < char {\n         \
    \           ^\n/tmp/tmpjf5czldc.swift:36:24: error: cannot assign value of type\
    \ 'Character' to type 'Int'\n                last = char\n                   \
    \    ^~~~\n/tmp/tmpjf5czldc.swift:41:58: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        result.init(from: s.characters, to:\
    \ s.characters.index(before: last) + 1)\n                                    \
    \                     ^\n/tmp/tmpjf5czldc.swift:41:16: error: no exact matches\
    \ in call to initializer \n        result.init(from: s.characters, to: s.characters.index(before:\
    \ last) + 1)\n               ^\n/tmp/tmpjf5czldc.swift:41:16: note: found candidate\
    \ with type '(String) -> [String]'\n        result.init(from: s.characters, to:\
    \ s.characters.index(before: last) + 1)\n               ^\n/tmp/tmpjf5czldc.swift:41:16:\
    \ note: found candidate with type '(String, Int) -> [String]'\n        result.init(from:\
    \ s.characters, to: s.characters.index(before: last) + 1)\n               ^\n\
    /tmp/tmpjf5czldc.swift:41:16: note: found candidate with type '(any Decoder) throws\
    \ -> [String]'\n        result.init(from: s.characters, to: s.characters.index(before:\
    \ last) + 1)\n               ^\n/tmp/tmpjf5czldc.swift:41:72: error: cannot convert\
    \ value of type 'Int' to expected argument type 'String.Index'\n        result."
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var vowels = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]\n    var vowelSet = Set(vowels)\n    \n    var vowelCounts:\
    \ [Int] = [n]\n    var selectedStrings: [String] = []\n    \n    for s in s.split()\
    \ {\n        \n        if let firstLetter = s.first,\n            let index =\
    \ vowelSet.index(of: firstLetter) {\n            vowelCounts[index] += 1\n   \
    \         if vowelCounts.count == vowelCounts.maxIndex {\n                selectedStrings.append(s)\n\
    \                vowelCounts = Array(vowelCounts)\n            }\n        }\n\
    \    }\n    \n    return selectedStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1sp9lr1j.swift:25:22: error: missing argument for parameter 'separator'\
    \ in call\n    for s in s.split() {\n                     ^\n                \
    \     separator: <#String.Element#>\nSwift.Sequence:2:40: note: 'split(separator:maxSplits:omittingEmptySubsequences:)'\
    \ declared here\n    @inlinable public __consuming func split(separator: Self.Element,\
    \ maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    // TODO: select\
    \ words of length n by returning an array of all words of length n from the string\
    \ s\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp6t6ia5tg/tmp6t6ia5tg.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b742f18dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b742ee84b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b742ee84988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b742ee837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6t6ia5tg                        0x00005562c881c4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b742f379460 __libc_start_main +
    245

    6    tmp6t6ia5tg                        0x00005562c881c0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\treturn select_words_helper(s,\
    \ n, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr59r03em.swift:19:9: error: cannot find 'select_words_helper' in\
    \ scope\n        return select_words_helper(s, n, false)\n               ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n  return select_words(s:\
    \ s, n: n, selectedWords: [:])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmvn3sccz.swift:19:50: error: extra argument 'selectedWords' in\
    \ call\n  return select_words(s: s, n: n, selectedWords: [:])\n              \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n  return []\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpmn6udowo/tmpmn6udowo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6659d81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6659a78b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6659a78988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6659a777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmn6udowo                        0x000055cd932034c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b6659f6d460 __libc_start_main +
    245

    6    tmpmn6udowo                        0x000055cd932030c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014284
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // code here\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpd5gks5dq/tmpd5gks5dq.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe7a614c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe7a30bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe7a30b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe7a30a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd5gks5dq                        0x00005607770974c4 <unavailable> + 5316

    5    libc.so.6                          0x00002afe7a800460 __libc_start_main +
    245

    6    tmpd5gks5dq                        0x00005607770970c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // Good luck!\n   \
    \ \n    // BEGIN Solution\n    \n    if s == \"\" {\n        return []\n    }\n\
    \    \n    // Create a slice of all the consonants in the input string.\n    let\
    \ consonants = NSCharacterSet.consonants\n\n    var currentIndex = 0\n    var\
    \ currentSubstring = \"\"\n    var substring = \"\"\n    var finalSubstrings:\
    \ [String] = []\n    \n    // Loop through the input string and build an array\
    \ of substrings containing n\n    // consonants.\n    while currentIndex < s.characters.count\
    \ {\n        \n        // Add consonants to the current substring\n        currentSubstring\
    \ = currentSubstring + String(s[currentIndex])\n        \n        // If there\
    \ is enough space to add the next substring\n        if currentIndex + n <= s.characters.count\
    \ {\n            // Check if the current substring contains enough consonants\
    \ to add to the \n            // final array\n            if currentSubstring.rangeOfCharacterFromSet(consonants,\
    \ options: .CaseInsensitiveSearch, range: nil) == nil {\n                currentSubstring\
    \ = currentSubstring[1..<(currentSubstring.endIndex)]\n            }\n       \
    \ }\n        // Add the current substring to the final array\n        finalSubstrings.append(currentSubstring)\n\
    \        \n        // Increment the index\n        currentIndex++\n        \n\
    \        // Add the current substring to the current substring\n        currentSubstring\
    \ = \"\"\n        \n        // Add the next consonant to the current substring\n\
    \        currentSubstring = String(s[currentIndex])\n    }\n    \n    // Return\
    \ the final array\n    return finalSubstrings\n    \n    // END Solution\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy5nx88uy.swift:28:22: error: cannot find 'NSCharacterSet' in scope\n\
    \    let consonants = NSCharacterSet.consonants\n                     ^~~~~~~~~~~~~~\n\
    /tmp/tmpy5nx88uy.swift:37:28: error: 'characters' is unavailable: Please use String\
    \ directly\n    while currentIndex < s.characters.count {\n                  \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpy5nx88uy.swift:40:54:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        currentSubstring = currentSubstring + String(s[currentIndex])\n\
    \                                                     ^~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpy5nx88uy.swift:43:34:\
    \ error: 'characters' is unavailable: Please use String directly\n        if currentIndex\
    \ + n <= s.characters.count {\n                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpy5nx88uy.swift:46:33: error: value of\
    \ type 'String' has no member 'rangeOfCharacterFromSet'\n            if currentSubstring.rangeOfCharacterFromSet(consonants,\
    \ options: .CaseInsensitiveSearch, range: nil) == nil {\n               ~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpy5nx88uy.swift:46:79: error: cannot infer contextual\
    \ base in reference to member 'CaseInsensitiveSearch'\n            if currentSubstring.rangeOfCharacterFromSet(consonants,\
    \ options: .CaseInsensitiveSearch, range: nil) == nil {\n                    \
    \                                                         ~^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpy5nx88uy.swift:46:109: error: 'nil' requires a contextual type\n     \
    \       if currentSubstring.rangeOfCharacterFromSet(consonants, options: .CaseInsensitiveSearch,\
    \ range: nil) == nil {\n                                         "
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // Your code here\n\
    \    if s == \"\" { return [] }\n    var result = [String]()\n    var i = 0\n\
    \    var j = 0\n    for character in s {\n        let char = String(character)\n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            result.append(String(s[i:j]))\n            i =\
    \ j + 1\n        }\n        if char == \"b\" || char == \"c\" || char == \"d\"\
    \ || char == \"f\" || char == \"g\" || char == \"h\" || char == \"j\" || char\
    \ == \"k\" || char == \"l\" || char == \"m\" || char == \"n\" || char == \"p\"\
    \ || char == \"q\" || char == \"r\" || char == \"s\" || char == \"t\" || char\
    \ == \"v\" || char == \"x\" || char == \"z\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"A\" || char == \"E\" ||\
    \ char == \"I\" || char == \"O\" || char == \"U\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"B\" || char == \"C\" ||\
    \ char == \"D\" || char == \"F\" || char == \"G\" || char == \"H\" || char ==\
    \ \"J\" || char == \"K\" || char == \"L\" || char == \"M\" || char == \"N\" ||\
    \ char == \"P\" || char == \"Q\" || char == \"R\" || char == \"S\" || char ==\
    \ \"T\" || char == \"V\" || char == \"X\" || char == \"Z\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"1\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"2\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"3\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"4\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"5\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"6\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"7\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"8\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"9\" {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n        }\n        if char == \"0\" {\n            result.append(String(s[i:j]))\n\
    \            \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzbzfkus7.swift:102:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpzbzfkus7.swift:24:24:\
    \ note: to match this opening '{'\n    for character in s {\n                \
    \       ^\n/tmp/tmpzbzfkus7.swift:102:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpzbzfkus7.swift:18:50: note: to match this opening '{'\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n                                            \
    \     ^\n/tmp/tmpzbzfkus7.swift:27:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n/tmp/tmpzbzfkus7.swift:31:35:\
    \ error: extraneous argument label 'i:' in subscript\n            result.append(String(s[i:j]))\n\
    \                                  ^~~\n                                   \n\
    /tmp/tmpzbzfkus7.swift:35:35: error: extraneous argument label 'i:' in subscript\n\
    \            result.append(String(s[i:j]))\n                                 \
    \ ^~~\n                                   \n/tmp/tmpzbzfkus7.swift:39:35: error:\
    \ extraneous argument label 'i:' in subscript\n            result.append(String(s[i:j]))\n\
    \                                  ^~~\n                                   \n\
    /tmp/tmpzbzfkus7.swift:43:35: error: extraneous argument label 'i:' in subscript\n\
    \            result.append(String(s[i:j]))\n                                 \
    \ ^~~\n                                   \n/tmp/tmpzbzfkus7.swift:47:35: error:\
    \ extraneous argument label 'i:' in subscript\n            result.append(String(s[i:j]))\n\
    \                                  ^~~\n                                   \n\
    /tmp/tmpzbzfkus7.swift:51:35: error: extraneous argument label 'i:' in subscript\n\
    \            result.append(String(s[i:j]))\n                                 \
    \ ^"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let arr = s.characters.split(separator:\
    \ \" \").map({ String($0) }).sorted(by: { $0.count < $1.count })\n    return arr.filter\
    \ { $0.count == n }.map { $0.prefix(upTo: n) }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpuwtseneu.swift:19:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    let arr = s.characters.split(separator: \" \").map({\
    \ String($0) }).sorted(by: { $0.count < $1.count })\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpuwtseneu.swift:20:63:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \    return arr.filter { $0.count == n }.map { $0.prefix(upTo: n) }\n        \
    \                                                      ^\n/tmp/tmpuwtseneu.swift:20:50:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ closure result type 'String'\n    return arr.filter { $0.count == n }.map {\
    \ $0.prefix(upTo: n) }\n                                              ~~~^~~~~~~~~~~~~~~\n\
    \                                              String(           )\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return select_words(s,\
    \ n, \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpggzoigki.swift:19:31: error: extra argument in call\n    return\
    \ select_words(s, n, \"\")\n                       ~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    // BEGIN Practice\
    \ \n    \n    var words = [String]()\n    \n    // END Practice\n    \n    return\
    \ words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpzsonso1q/tmpzsonso1q.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b310da04c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b310d6fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b310d6fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b310d6fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzsonso1q                        0x00005563dbe01514 <unavailable> + 5396

    5    libc.so.6                          0x00002b310dbf0460 __libc_start_main +
    245

    6    tmpzsonso1q                        0x00005563dbe01119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var candidates = [String]()\n\
    \    var index = 0\n    for char in s {\n        if !isConsonant(char) && n !=\
    \ 0 && n == index {\n            candidates.append(char)\n        }\n        index++\n\
    \    }\n    return candidates\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyuj8nbyc.swift:22:13: error: cannot find 'isConsonant' in scope\n\
    \        if !isConsonant(char) && n != 0 && n == index {\n            ^~~~~~~~~~~\n\
    /tmp/tmpyuj8nbyc.swift:23:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            candidates.append(char)\n  \
    \                            ^\n/tmp/tmpyuj8nbyc.swift:25:14: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n        index++\n            \
    \ ^~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result: [String]\
    \ = []\n    var stack: [String] = s.characters\n\n    for _ in 0..<n {\n     \
    \   var newStack: [String] = []\n        for c in stack {\n            if isConsonant(c)\
    \ {\n                newStack.append(c)\n            } else {\n              \
    \  result.appendContentsOf(newStack)\n                result.appendContentsOf(stack)\n\
    \                newStack = []\n            }\n        }\n        if stack.isEmpty\
    \ {\n            result.appendContentsOf(newStack)\n        }\n        stack =\
    \ newStack\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpiw1adhdf.swift:20:29: error: cannot convert value of type 'String'\
    \ to specified type '[String]'\n    var stack: [String] = s.characters\n     \
    \                     ~~^~~~~~~~~~\n/tmp/tmpiw1adhdf.swift:25:16: error: cannot\
    \ find 'isConsonant' in scope\n            if isConsonant(c) {\n             \
    \  ^~~~~~~~~~~\n/tmp/tmpiw1adhdf.swift:28:24: error: value of type '[String]'\
    \ has no member 'appendContentsOf'\n                result.appendContentsOf(newStack)\n\
    \                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpiw1adhdf.swift:29:24: error:\
    \ value of type '[String]' has no member 'appendContentsOf'\n                result.appendContentsOf(stack)\n\
    \                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpiw1adhdf.swift:34:20: error:\
    \ value of type '[String]' has no member 'appendContentsOf'\n            result.appendContentsOf(newStack)\n\
    \            ~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    var result = [String]()\n\n    if s.isEmpty {\n        return result\n \
    \   }\n\n    for i in 0..<s.count {\n        let currentChar = String(s.characters[s.startIndex.advancedBy(i)]).lowercaseString\n\
    \        if currentChar.hasPrefix(alphabet[n-1]) {\n            result.append(s[s.startIndex.advancedBy(i)])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi87_u696.swift:27:60: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n        let currentChar = String(s.characters[s.startIndex.advancedBy(i)]).lowercaseString\n\
    \                                              ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpi87_u696.swift:27:76:\
    \ error: value of type 'String' has no member 'lowercaseString'\n        let currentChar\
    \ = String(s.characters[s.startIndex.advancedBy(i)]).lowercaseString\n       \
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpi87_u696.swift:29:42: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n            result.append(s[s.startIndex.advancedBy(i)])\n   \
    \                         ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var words: [String]\
    \ = []\n    var currentString = \"\"\n    var isComplete = false\n    \n    for\
    \ character in s {\n        if character == \" \" {\n            if currentString\
    \ != \"\" {\n                words.append(currentString)\n                currentString\
    \ = \"\"\n            }\n        } else {\n            if isComplete == false\
    \ {\n                currentString += String(character)\n            } else {\n\
    \                if n == 0 {\n                    isComplete = true\n        \
    \        } else {\n                    n--\n                }\n            }\n\
    \        }\n    }\n    \n    if currentString != \"\" {\n        words.append(currentString)\n\
    \    }\n    \n    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0wsxbuas.swift:37:22: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n                    n--\n                     ^~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    var count = 0\n    for word in s.split(\" \") {\n        for consonant\
    \ in \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n            .unicodeScalars.filter({\
    \ $0.isConsonant() }) {\n            if count < n {\n                if word ==\
    \ consonant.unicodeScalars {\n                    result.append(word)\n      \
    \              count += 1\n                }\n            } else {\n         \
    \       break\n            }\n        }\n    }\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqi3qjrpw.swift:22:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmpqi3qjrpw.swift:24:41: error: value of type\
    \ 'Unicode.Scalar' has no member 'isConsonant'\n            .unicodeScalars.filter({\
    \ $0.isConsonant() }) {\n                                     ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpy2j4mtyo/tmpy2j4mtyo.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1c0964c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1c065bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1c065b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1c065a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy2j4mtyo                        0x000055d0ec3894c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ab1c0b50460 __libc_start_main +
    245

    6    tmpy2j4mtyo                        0x000055d0ec3890c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmp71zsovev.swift:20:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    if s == \"\"\
    \ {\n        return []\n    }\n    \n    var result = [String]()\n    \n    if\
    \ n <= 0 {\n        return result\n    }\n    \n    if countConsonants(s) <= n\
    \ {\n        return selectString(s, n)\n    }\n    \n    if n % 2 == 0 {\n   \
    \     result = selectWords(s, n/2)\n    } else {\n        result = selectWords(s,\
    \ n/2) + selectWords(s, n/2)\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1_wvdbsz.swift:30:8: error: cannot find 'countConsonants' in scope\n\
    \    if countConsonants(s) <= n {\n       ^~~~~~~~~~~~~~~\n/tmp/tmp1_wvdbsz.swift:31:16:\
    \ error: cannot find 'selectString' in scope\n        return selectString(s, n)\n\
    \               ^~~~~~~~~~~~\n/tmp/tmp1_wvdbsz.swift:35:18: error: cannot find\
    \ 'selectWords' in scope\n        result = selectWords(s, n/2)\n             \
    \    ^~~~~~~~~~~\n/tmp/tmp1_wvdbsz.swift:37:18: error: cannot find 'selectWords'\
    \ in scope\n        result = selectWords(s, n/2) + selectWords(s, n/2)\n     \
    \            ^~~~~~~~~~~\n/tmp/tmp1_wvdbsz.swift:37:40: error: cannot find 'selectWords'\
    \ in scope\n        result = selectWords(s, n/2) + selectWords(s, n/2)\n     \
    \                                  ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if n <= 0 {\n     \
    \   return []\n    }\n    if s == \"\" {\n        return []\n    }\n    \n   \
    \ var vowels = \"aeiouAEIOU\".characters\n    var consonants = vowels.subtracting(NSCharacterSet.init(charactersIn:\
    \ \"bcdfghjklmnpqrstvwxyz\"))\n    \n    var prefixes: [String] = []\n    \n \
    \   for i in 1...n {\n        prefixes.append(s[0..<i].first!)\n    }\n    \n\
    \    var words: [String] = []\n    \n    for prefix in prefixes {\n        \n\
    \        var word = \"\"\n        for c in s {\n            \n            if c.isLetterOrDigit\
    \ {\n                \n                if c.isLetter {\n                    if\
    \ prefixes.contains(word) == false {\n                        words.append(word)\n\
    \                    }\n                } else {\n                    if word.containsString(prefix)\
    \ == false {\n                        words.append(word)\n                   \
    \ }\n                }\n                \n                word += c\n        \
    \        \n                if consonants.containsObject(word) {\n            \
    \        break\n                }\n                \n            } else {\n  \
    \              break\n            }\n        }\n    }\n    \n    return words\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjhjn5unj.swift:26:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    var vowels = \"aeiouAEIOU\".characters\n          \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjhjn5unj.swift:27:41: error: cannot find 'NSCharacterSet' in scope\n\
    \    var consonants = vowels.subtracting(NSCharacterSet.init(charactersIn: \"\
    bcdfghjklmnpqrstvwxyz\"))\n                                        ^~~~~~~~~~~~~~\n\
    /tmp/tmpjhjn5unj.swift:27:29: error: value of type 'String' has no member 'subtracting'\n\
    \    var consonants = vowels.subtracting(NSCharacterSet.init(charactersIn: \"\
    bcdfghjklmnpqrstvwxyz\"))\n                     ~~~~~~ ^~~~~~~~~~~\n/tmp/tmpjhjn5unj.swift:32:39:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n        prefixes.append(s[0..<i].first!)\n         \
    \                             ^\n/tmp/tmpjhjn5unj.swift:42:18: error: value of\
    \ type 'Character' has no member 'isLetterOrDigit'\n            if c.isLetterOrDigit\
    \ {\n               ~ ^~~~~~~~~~~~~~~\n/tmp/tmpjhjn5unj.swift:49:29: error: value\
    \ of type 'String' has no member 'containsString'\n                    if word.containsString(prefix)\
    \ == false {\n                       ~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpjhjn5unj.swift:54:25:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                word += c\n                        ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var ans = [String]()\n\
    \    for word in s.split(\" \") {\n        \n        if word.contains(\"x\") {\n\
    \            if word.contains(\"y\") && word.contains(\"z\") {\n             \
    \   ans.append(word)\n            }\n        }\n        \n        if word.contains(\"\
    z\") {\n            ans.append(word)\n        }\n        \n        if word.contains(\"\
    y\") {\n            if word.contains(\"z\") {\n                ans.append(word)\n\
    \            }\n        }\n        \n        if word.contains(\"x\") {\n     \
    \       if word.contains(\"y\") {\n                ans.append(word)\n        \
    \    }\n        }\n        \n        if word.contains(\"u\") {\n            if\
    \ word.contains(\"l\") {\n                ans.append(word)\n            }\n  \
    \      }\n        \n        if word.contains(\"l\") {\n            if word.contains(\"\
    u\") {\n                ans.append(word)\n            }\n        }\n        \n\
    \        if word.contains(\"u\") {\n            if word.contains(\"l\") {\n  \
    \              ans.append(word)\n            }\n        }\n        \n        if\
    \ word.contains(\"l\") {\n            if word.contains(\"u\") {\n            \
    \    ans.append(word)\n            }\n        }\n        \n        if word.contains(\"\
    f\") {\n            if word.contains(\"l\") {\n                ans.append(word)\n\
    \            }\n        }\n        \n        if word.contains(\"l\") {\n     \
    \       if word.contains(\"f\") {\n                ans.append(word)\n        \
    \    }\n        }\n        \n        if word.contains(\"f\") {\n            if\
    \ word.contains(\"l\") {\n                ans.append(word)\n            }\n  \
    \      }\n        \n        if word.contains(\"e\") {\n            if word.contains(\"\
    e\") {\n                ans.append(word)\n            }\n        }\n        \n\
    \        if word.contains(\"e\") {\n            if word.contains(\"i\") {\n  \
    \              ans.append(word)\n            }\n        }\n        \n        if\
    \ word.contains(\"i\") {\n            if word.contains(\"e\") {\n            \
    \    ans.append(word)\n            }\n        }\n        \n        if word.contains(\"\
    e\") {\n            if word.contains(\"i\") {\n                ans.append(word)\n\
    \            }\n        }\n        \n        if word.contains(\"i\") {\n     \
    \       if word.contains(\"e\") {\n                ans.append(word)\n        \
    \    }\n        }\n        \n        if word.contains(\"n\") {\n            if\
    \ word.contains(\"o\") {\n                ans.append(word)\n            }\n  \
    \      }\n        \n        if word.contains(\"o\") {\n            if word.contains(\"\
    n\") {\n                ans.append(word)\n            }\n        }\n        \n\
    \        if word.contains(\"n\") {\n            if word.contains(\"o\") {\n  \
    \              ans.append(word)\n            }\n        }\n        \n        if\
    \ word.contains(\"o\") {\n            if word.contains(\"n\") {\n            \
    \    ans.append(word)\n            }\n        }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvedhuwo6.swift:161:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpvedhuwo6.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpvedhuwo6.swift:21:19:\
    \ error: no exact matches in call to instance method 'split'\n    for word in\
    \ s.split(\" \") {\n                  ^\nSwift.Sequence:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n    \
    \                                   ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmpvedhuwo6.swift:143:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var ans = [String]()\n\
    \    if s == \"\" {\n        return ans\n    }\n    \n    // Find the number of\
    \ consonants in the string.\n    var consonants = 0\n    for ch in s {\n     \
    \   if ch.isUpper() {\n            break\n        }\n        consonants++\n  \
    \  }\n    \n    // Add the first word that matches n consonants.\n    var pos\
    \ = 0\n    while pos < len(s) {\n        \n        if s[pos].isUpper() {\n   \
    \         consonants--\n            break\n        }\n        pos++\n    }\n \
    \   \n    if consonants == n {\n        ans = append(ans, s[pos+1:])\n    }\n\
    \    \n    // Find the last word that matches n consonants.\n    pos = 0\n   \
    \ while pos < len(s) {\n        \n        if s[pos].isLower() {\n            consonants++\n\
    \            break\n        }\n        pos++\n    }\n    \n    if consonants ==\
    \ n {\n        ans = append(ans, s[pos...])\n    }\n    \n    return ans\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpphw6q3y4.swift:45:34: error: expected ',' separator\n        ans\
    \ = append(ans, s[pos+1:])\n                                 ^\n             \
    \                    ,\n/tmp/tmpphw6q3y4.swift:45:34: error: expected expression\
    \ in list of expressions\n        ans = append(ans, s[pos+1:])\n             \
    \                    ^\n/tmp/tmpphw6q3y4.swift:27:15: error: value of type 'Character'\
    \ has no member 'isUpper'\n        if ch.isUpper() {\n           ~~ ^~~~~~~\n\
    /tmp/tmpphw6q3y4.swift:30:19: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        consonants++\n                  ^~\n/tmp/tmpphw6q3y4.swift:35:17:\
    \ error: cannot find 'len' in scope\n    while pos < len(s) {\n              \
    \  ^~~\n/tmp/tmpphw6q3y4.swift:37:19: error: value of type 'Character' has no\
    \ member 'isUpper'\n        if s[pos].isUpper() {\n           ~~~~~~ ^~~~~~~\n\
    /tmp/tmpphw6q3y4.swift:38:23: error: cannot find operator '--' in scope; did you\
    \ mean '-= 1'?\n            consonants--\n                      ^~\n/tmp/tmpphw6q3y4.swift:41:12:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        pos++\n\
    \           ^~\n/tmp/tmpphw6q3y4.swift:45:15: error: cannot find 'append' in scope\n\
    \        ans = append(ans, s[pos+1:])\n              ^~~~~~\n/tmp/tmpphw6q3y4.swift:50:17:\
    \ error: cannot find 'len' in scope\n    while pos < len(s) {\n              \
    \  ^~~\n/tmp/tmpphw6q3y4.swift:52:19: error: value of type 'Character' has no\
    \ member 'isLower'\n        if s[pos].isLower() {\n           ~~~~~~ ^~~~~~~\n\
    /tmp/tmpphw6q3y4.swift:53:23: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            consonants++\n                      ^~\n/tmp/tmpphw6q3y4.swift:56:12:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        pos++\n\
    \           ^~\n/tmp/tmpphw6q3y4.swift:60:15: error: cannot find 'append' in scope\n\
    \        ans = append(ans, s[pos...])\n              ^~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var a = [String]()\n\
    \    for word in s.split(\" \") {\n        if count (word) == n {\n          \
    \  a.append(word)\n        }\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwsfrqnvc.swift:20:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return words.filter({\
    \ subs -> Bool in\n        return subs.contains(s)\n    }).filter({ subs -> Bool\
    \ in\n        return subs.count == n\n    }).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnt8fz9bx.swift:19:12: error: cannot find 'words' in scope\n   \
    \ return words.filter({ subs -> Bool in\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tguard n > 0 && n < words.count\
    \ else { return [] }\n\tvar words = [String]()\n\tvar word = \"\"\n\tfor i :=\
    \ 0; i < s.count; i++ {\n\t\tword = word + String(s.characters[i])\n\t\tif words.count\
    \ <= n {\n\t\t\twords.append(word)\n\t\t}\n\t\tif i == s.count - 1 {\n\t\t\tbreak\n\
    \t\t}\n\t}\n\treturn words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqi7lhfhl.swift:22:9: error: expected type\n        for i := 0;\
    \ i < s.count; i++ {\n               ^\n                <#type#>\n/tmp/tmpqi7lhfhl.swift:22:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < s.count;\
    \ i++ {\n               ^\n/tmp/tmpqi7lhfhl.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < s.count; i++ {\n     \
    \          ^\n/tmp/tmpqi7lhfhl.swift:19:21: error: use of local variable 'words'\
    \ before its declaration\n        guard n > 0 && n < words.count else { return\
    \ [] }\n                           ^\n/tmp/tmpqi7lhfhl.swift:20:6: note: 'words'\
    \ declared here\n        var words = [String]()\n            ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    for char in s {\n        if char.unicodeScalars.count == 1 {\n          \
    \  let first = char.unicodeScalars.first\n            let last = char.unicodeScalars.last\n\
    \            if last - first == n {\n                words.append(String(first))\n\
    \            }\n        }\n    }\n    return words\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8vi5y27d.swift:24:29: error: referencing operator function '=='\
    \ on 'BinaryInteger' requires that 'Unicode.Scalar' conform to 'BinaryInteger'\n\
    \            if last - first == n {\n                            ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension BinaryInteger {\n         \
    \ ^\n/tmp/tmp8vi5y27d.swift:24:21: error: binary operator '-' cannot be applied\
    \ to two 'Unicode.Scalar?' operands\n            if last - first == n {\n    \
    \           ~~~~ ^ ~~~~~\n/tmp/tmp8vi5y27d.swift:25:30: error: no exact matches\
    \ in call to initializer \n                words.append(String(first))\n     \
    \                        ^\nSwift.String:3:23: note: found candidate with type\
    \ 'Unicode.Scalar?'\n    @inlinable public init(_ scalar: Unicode.Scalar)\n  \
    \                    ^\nSwift.String:4:23: note: found candidate with type 'Unicode.Scalar?'\n\
    \    @inlinable public init<T>(_ value: T) where T : LosslessStringConvertible\n\
    \                      ^\nSwift.String:2:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:6:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    return []\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpzs66n6ss/tmpzs66n6ss.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5be131ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5be1011b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5be1011988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5be10107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzs66n6ss                        0x000055ef35cea4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b5be1506460 __libc_start_main +
    245

    6    tmpzs66n6ss                        0x000055ef35cea0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s.isEmpty {\n        return result\n    }\n\n    // Split string\n   \
    \ var words = s.componentsSeparatedByString(\" \")\n    var listCount = 0\n  \
    \  var nextCount = words.count\n\n    // Get words\n    for i in 0..<nextCount\
    \ {\n        let word = words[i]\n        let letterCount = word.characters.count\n\
    \        if (letterCount == n) {\n            result.append(word)\n          \
    \  listCount += 1\n        }\n    }\n    if listCount == nextCount {\n       \
    \ return result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr734osmf.swift:25:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    var words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let words = s.components(separatedBy:\
    \ \" \")\n    \n    var results = [String]()\n    for word in words {\n      \
    \  var isCount = false\n        for letter in word {\n            switch letter\
    \ {\n            case \"a\": isCount = true; break\n            case \"e\": isCount\
    \ = true; break\n            case \"i\": isCount = true; break\n            case\
    \ \"o\": isCount = true; break\n            case \"u\": isCount = true; break\n\
    \            default: isCount = false; break\n            }\n        }\n     \
    \   \n        if isCount {\n            if words.count > n {\n               \
    \ results.append(word)\n            }\n        } else {\n            if words.count\
    \ == n {\n                results.append(word)\n            }\n        }\n   \
    \ }\n    \n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxba0er5b.swift:19:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .characters\n    \n    var result: [String] = []\n    \n    // Check base case\n\
    \    if s == \"\" {\n        return result\n    }\n    \n    // Get the first\
    \ n characters\n    let firstChar = s[0...n]\n    \n    // Check each character\
    \ for consonants\n    for char in alphabet {\n        if let index = s.index(char,\
    \ options: .caseInsensitive) {\n            let word = String(s[0...index])\n\
    \            \n            // Found a consonant?\n            if word.hasSuffix(\"\
    a\") {\n                if word.hasPrefix(firstChar) {\n                    result.append(word)\n\
    \                }\n            }\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgi4e74zd.swift:19:75: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .characters\n                                                                \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpgi4e74zd.swift:29:21: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n    let firstChar\
    \ = s[0...n]\n                    ^~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpgi4e74zd.swift:33:48: error: extra argument 'options' in call\n      \
    \  if let index = s.index(char, options: .caseInsensitive) {\n               \
    \               ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpgi4e74zd.swift:33:48:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \        if let index = s.index(char, options: .caseInsensitive) {\n         \
    \                                     ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result : [String]\
    \ = []\n    var curPos : Int = Int(0)\n    for c in s.unicodeScalars {\n     \
    \   if c.value > '\\u{10FFFF}' {\n            break\n        }\n        if c.value\
    \ == n.0 {\n            if curPos < len(s) {\n                result.append(s[curPos])\n\
    \            }\n            curPos += 1\n        } else {\n            curPos\
    \ += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppqj36usn.swift:22:22: error: single-quoted string literal found,\
    \ use '\"'\n        if c.value > '\\u{10FFFF}' {\n                     ^~~~~~~~~~~~\n\
    \                     \"\\u{10FFFF}\"\n/tmp/tmppqj36usn.swift:22:20: error: binary\
    \ operator '>' cannot be applied to operands of type 'UInt32' and 'String'\n \
    \       if c.value > '\\u{10FFFF}' {\n           ~~~~~~~ ^ ~~~~~~~~~~~~\n/tmp/tmppqj36usn.swift:22:20:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (UInt32, UInt32)\n        if c.value > '\\u{10FFFF}' {\n                   ^\n\
    /tmp/tmppqj36usn.swift:25:25: error: value of type 'Int' has no member '0'\n \
    \       if c.value == n.0 {\n                      ~ ^\n/tmp/tmppqj36usn.swift:26:25:\
    \ error: cannot find 'len' in scope\n            if curPos < len(s) {\n      \
    \                  ^~~\n/tmp/tmppqj36usn.swift:27:32: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                result.append(s[curPos])\n\
    \                               ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let words = words.filter({\
    \ $0.containsString(s) })\n    return words.prefix(n)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxgqyn9tr.swift:19:17: error: use of local variable 'words' before\
    \ its declaration\n    let words = words.filter({ $0.containsString(s) })\n  \
    \              ^\n/tmp/tmpxgqyn9tr.swift:19:9: note: 'words' declared here\n \
    \   let words = words.filter({ $0.containsString(s) })\n        ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return s.split(separator:\
    \ \" \").filter({ $0.hasPrefix(\"\\u{0020}\") }).flatMap{$0.dropFirst(1).split(separator:\
    \ \" \").filter{$0.isPrefix(\"\\u{0020}\") }.countApprox(n) == n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5heq8ws2.swift:41:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp5heq8ws2.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp5heq8ws2.swift:19:167:\
    \ error: cannot convert value of type 'Bool' to closure result type 'String?'\n\
    \    return s.split(separator: \" \").filter({ $0.hasPrefix(\"\\u{0020}\") }).flatMap{$0.dropFirst(1).split(separator:\
    \ \" \").filter{$0.isPrefix(\"\\u{0020}\") }.countApprox(n) == n\n           \
    \                                                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmp5heq8ws2.swift:19:129: error: value of type 'Substring.SubSequence' (aka\
    \ 'Substring') has no member 'isPrefix'\n    return s.split(separator: \" \").filter({\
    \ $0.hasPrefix(\"\\u{0020}\") }).flatMap{$0.dropFirst(1).split(separator: \" \"\
    ).filter{$0.isPrefix(\"\\u{0020}\") }.countApprox(n) == n\n                  \
    \                                                                            \
    \                               ~~ ^~~~~~~~\n/tmp/tmp5heq8ws2.swift:19:152: error:\
    \ value of type '[Substring.SubSequence]' (aka 'Array<Substring>') has no member\
    \ 'countApprox'\n    return s.split(separator: \" \").filter({ $0.hasPrefix(\"\
    \\u{0020}\") }).flatMap{$0.dropFirst(1).split(separator: \" \").filter{$0.isPrefix(\"\
    \\u{0020}\") }.countApprox(n) == n\n                                         \
    \                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~\n/tmp/tmp5heq8ws2.swift:23:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tswitch {\n\tcase s ==\
    \ \"\":\n\t\treturn []\n\tdefault:\n\t\tvar result [String] = []\n\t\tfor (_,\
    \ subString) in s.splitWithSeparator(\" \") {\n\t\t\tif words.contains(subString)\
    \ {\n\t\t\t\tif select_words(subString, n) == n {\n\t\t\t\t\tresult.append(subString)\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaziu24d7.swift:19:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpaziu24d7.swift:23:13: error: consecutive\
    \ statements on a line must be separated by ';'\n                var result [String]\
    \ = []\n                          ^\n                          ;\n/tmp/tmpaziu24d7.swift:23:7:\
    \ error: type annotation missing in pattern\n                var result [String]\
    \ = []\n                    ^\n/tmp/tmpaziu24d7.swift:23:14: error: cannot assign\
    \ to immutable expression of type '[String].Type'\n                var result\
    \ [String] = []\n                           ^~~~~~~~\n/tmp/tmpaziu24d7.swift:23:25:\
    \ error: cannot assign value of type '[Any]' to type '[String].Type'\n       \
    \         var result [String] = []\n                                      ^~\n\
    /tmp/tmpaziu24d7.swift:24:3: error: failed to produce diagnostic for expression;\
    \ please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n                for (_, subString) in s.splitWithSeparator(\"\
    \ \") {\n                ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // Good luck!\n   \
    \ return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp0sz0u20n/tmp0sz0u20n.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba4a83f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba4a80f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba4a80f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba4a80ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0sz0u20n                        0x0000562f85a264c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ba4a85e5460 __libc_start_main +
    245

    6    tmp0sz0u20n                        0x0000562f85a260c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tswitch {\n\tcase n <\
    \ 0: return []\n\tcase n == 0: return []\n\tcase n == 1: return words.filter{\
    \ $0.hasConsonant() }\n\tdefault:\n\t\tlet words = s.words\n\t\treturn words.filter{\
    \ $0.hasConsonant() == n }\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpldjy133n.swift:19:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpldjy133n.swift:22:22: error: cannot\
    \ find 'words' in scope\n        case n == 1: return words.filter{ $0.hasConsonant()\
    \ }\n                            ^~~~~\n/tmp/tmpldjy133n.swift:24:17: error: value\
    \ of type 'String' has no member 'words'\n                let words = s.words\n\
    \                            ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    // Only proceed if there are characters in the string\n    if s.characters.count\
    \ > 0 {\n        // Iterate through each letter of the string\n        for letter\
    \ in s.characters.reverse() {\n            // If the letter is not a space\n \
    \           if letter != ' ' {\n                // If the letter doesn't meet\
    \ the requirement\n                if letter.isConsonant() == false {\n      \
    \              // Add it to the array of words\n                    words.append(String(letter))\n\
    \                    // If the number of characters equals the requirement then\
    \ break\n                    if letter == s.characters[s.characters.count-1] {\n\
    \                        break\n                    }\n                }\n   \
    \         }\n        }\n    }\n    return words\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpki5k_uih.swift:26:26: error: single-quoted string literal found,\
    \ use '\"'\n            if letter != ' ' {\n                         ^~~\n   \
    \                      \" \"\n/tmp/tmpki5k_uih.swift:22:10: error: 'characters'\
    \ is unavailable: Please use String directly\n    if s.characters.count > 0 {\n\
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpki5k_uih.swift:24:36:\
    \ error: value of type 'String' has no member 'reverse'\n        for letter in\
    \ s.characters.reverse() {\n                      ~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s.isEmpty {\n  \
    \      return []\n    }\n\n    // Initialize result array\n    var result: [String]\
    \ = []\n\n    // Find the length of the string\n    let charCount = s.characters.count\n\
    \n    // Initialize count of consonants\n    var consonantCount = 0\n\n    //\
    \ Iterate through string\n    for i in 0..<charCount {\n\n        // Get the character\
    \ at index\n        let char = String(s.characters[i])\n\n        // If char is\
    \ a consonant\n        if char.rangeOfCharacter(from: .letters) != nil {\n   \
    \         consonantCount += 1\n        }\n\n        // If the count of consonants\
    \ equals the number of consonants\n        // asked for\n        if consonantCount\
    \ == n {\n            result.append(String(s.substringWithRange(advance(s.startIndex,\
    \ i))))\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy6d2rr8p.swift:27:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    let charCount = s.characters.count\n              \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpy6d2rr8p.swift:36:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let char = String(s.characters[i])\n  \
    \                        ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpy6d2rr8p.swift:36:29: error: 'characters'\
    \ is unavailable: Please use String directly\n        let char = String(s.characters[i])\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpy6d2rr8p.swift:39:17: error: value of type 'String'\
    \ has no member 'rangeOfCharacter'\n        if char.rangeOfCharacter(from: .letters)\
    \ != nil {\n           ~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpy6d2rr8p.swift:39:41: error:\
    \ cannot infer contextual base in reference to member 'letters'\n        if char.rangeOfCharacter(from:\
    \ .letters) != nil {\n                                       ~^~~~~~~\n/tmp/tmpy6d2rr8p.swift:46:55:\
    \ error: cannot find 'advance' in scope\n            result.append(String(s.substringWithRange(advance(s.startIndex,\
    \ i))))\n                                                      ^~~~~~~\n/tmp/tmpy6d2rr8p.swift:46:36:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \   result.append(String(s.substringWithRange(advance(s.startIndex, i))))\n  \
    \                               ~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    // base case if string is empty\n    guard s.isEmpty else {\n     \
    \   return nil\n    }\n    \n    // if string is smaller than n, just return empty\
    \ array\n    if n < 0 {\n        return result\n    }\n    \n    // find first\
    \ consonant in the string\n    var index = s.startIndex\n    guard s[index] ==\
    \ \" \"\n    else {\n        let index = s.startIndex\n        let firstConsonant\
    \ = index\n        let secondConsonant = index + 1\n        let thirdConsonant\
    \ = index + 1\n        let fourthConsonant = index + 1\n        let fifthConsonant\
    \ = index + 1\n        let sixthConsonant = index + 1\n        \n        // while\
    \ index less than end of string\n        while index < s.endIndex {\n        \
    \    // if current character is vowel\n            if s[index] != \" \" {\n  \
    \              // if current index is less than current consonant\n          \
    \      guard index < firstConsonant else {\n                    // if current\
    \ consonant is not n, add it to result and move index\n                    if\
    \ index > firstConsonant && index < secondConsonant {\n                      \
    \  result.append(s[index])\n                        index++\n                \
    \    } else if index > secondConsonant && index < thirdConsonant {\n         \
    \               result.append(s[index])\n                        index++\n   \
    \                 } else if index > thirdConsonant && index < fourthConsonant\
    \ {\n                        result.append(s[index])\n                       \
    \ index++\n                    } else if index > fourthConsonant && index < fifthConsonant\
    \ {\n                        result.append(s[index])\n                       \
    \ index++\n                    } else if index > fifthConsonant && index < sixthConsonant\
    \ {\n                        result.append(s[index])\n                       \
    \ index++\n                    } else {\n                        index++\n   \
    \                 }\n                }\n            } else if s[index] == \" \"\
    \ {\n                index++\n            }\n        }\n    }\n    \n    // if\
    \ the return is empty then return nil, else append rest of string as result\n\
    \    if result.isEmpty {\n        return nil\n    } else {\n        result.append(s.suffixFrom(firstConsonant))\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7_j4ri0i.swift:23:16: error: 'nil' is incompatible with return\
    \ type '[String]'\n        return nil\n               ^\n/tmp/tmp7_j4ri0i.swift:37:31:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let secondConsonant = index + 1\n                           \
    \   ^\n/tmp/tmp7_j4ri0i.swift:38:30: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        let thirdConsonant = index + 1\n  \
    \                           ^\n/tmp/tmp7_j4ri0i.swift:39:31: error: cannot convert\
    \ value of type 'String.Index' to expected argument type 'Int'\n        let fourthConsonant\
    \ = index + 1\n                              ^\n/tmp/tmp7_j4ri0i.swift:40:30:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let fifthConsonant = index + 1\n                            \
    \ ^\n/tmp/tmp7_j4ri0i.swift:41:30: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        let sixthConsonant = index + 1\n  \
    \                           ^\n/tmp/tmp7_j4ri0i.swift:51:40: error: subscript\
    \ 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n\
    \                        result.append(s[index])\n                           \
    \            ^\nSwift.String:5:12: note: where 'R' = 'String.Index'\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmp7_j4ri0i.swift:52:30: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                        index++\n     \
    \                        ^~\n/tmp/tmp7_j4ri0i.swift:54:40: error: subscript 'subscript(_:)'\
    \ requires that 'String.Index' conform to 'RangeExpression'\n                \
    \        result.append(s[index])\n                                       ^\nSwift.String:5:12:\
    \ note: where 'R' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmp7_j4ri0i.swift:55:30:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \    "
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n    let r = s.characters.reduce([String](), combine:\
    \ { (a, b) -> [String] in\n        let s = a.characters.filter({$0 == \"a\" ||\
    \ $0 == \"e\" || $0 == \"i\" || $0 == \"o\" || $0 == \"u\" })\n        var b =\
    \ b\n        if b.characters.count > n {\n            b = b.characters.filter({$0\
    \ != \"a\" && $0 != \"e\" && $0 != \"i\" && $0 != \"o\" && $0 != \"u\"})\n   \
    \     }\n        return a + b\n    })\n    return r.filter({$0.characters.count\
    \ == n})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcwqojqw6.swift:22:32: error: extraneous argument label 'combine:'\
    \ in call\n    let r = s.characters.reduce([String](), combine: { (a, b) -> [String]\
    \ in\n                               ^            ~~~~~~~~~\n                \
    \                            \n/tmp/tmpcwqojqw6.swift:23:19: error: value of type\
    \ '[String]' has no member 'characters'\n        let s = a.characters.filter({$0\
    \ == \"a\" || $0 == \"e\" || $0 == \"i\" || $0 == \"o\" || $0 == \"u\" })\n  \
    \              ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s.isEmpty {\n  \
    \      return []\n    }\n    var result: [String] = []\n    var firstIndex = 0\n\
    \    var lastIndex = 0\n    var currentWord = \"\"\n    for currentIndex in 0..<s.count\
    \ {\n        if s[currentIndex].isLetter {\n            currentWord += s[currentIndex]\n\
    \            if currentIndex == s.count - 1 {\n                if currentWord.hasSuffix(n)\
    \ {\n                    result = append(result, currentWord)\n              \
    \  }\n                firstIndex = currentIndex + 1\n                currentWord\
    \ = \"\"\n            } else {\n                currentWord += \" \"\n       \
    \     }\n        } else {\n            if currentWord != \"\" {\n            \
    \    if currentWord.hasSuffix(n) {\n                    result = append(result,\
    \ currentWord)\n                }\n                firstIndex = currentIndex +\
    \ 1\n                currentWord = \"\"\n            }\n        }\n    }\n   \
    \ if currentWord != \"\" {\n        result = append(result, currentWord)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3g_g4b73.swift:27:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[currentIndex].isLetter\
    \ {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp3g_g4b73.swift:28:29: error: no exact matches\
    \ in call to subscript \n            currentWord += s[currentIndex]\n        \
    \                    ^\nSwift.String:3:12: note: candidate expects value of type\
    \ 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmp3g_g4b73.swift:30:42:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String'\n\
    \                if currentWord.hasSuffix(n) {\n                             \
    \            ^\n/tmp/tmp3g_g4b73.swift:31:30: error: cannot find 'append' in scope\n\
    \                    result = append(result, currentWord)\n                  \
    \           ^~~~~~\n/tmp/tmp3g_g4b73.swift:40:42: error: cannot convert value\
    \ of type 'Int' to expected argument type 'String'\n                if currentWord.hasSuffix(n)\
    \ {\n                                         ^\n/tmp/tmp3g_g4b73.swift:41:30:\
    \ error: cannot find 'append' in scope\n                    result = append(result,\
    \ currentWord)\n                             ^~~~~~\n/tmp/tmp3g_g4b73.swift:49:18:\
    \ error: cannot find 'append' in scope\n        result = append(result, currentWord)\n\
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // M1. \u6A21\u62DF\
    \n    \n    // \u9996\u5148\u6309\u7167\u5B57\u7B26\u4E32\u7684\u957F\u5EA6\u62C6\
    \u5206\u51FA\u6700\u5927\u7684\u5B57\u7B26\u4E32\u957F\u5EA6\n    let maxLen =\
    \ s.characters.count\n    if n == 0 {\n        return []\n    }\n    \n    //\
    \ \u7136\u540E\u6309\u7167n\u7684\u6B21\u65B9\u62C6\u5206\u51FA\u6700\u5927\u7684\
    \u5B57\u7B26\u4E32\u957F\u5EA6\n    var maxCount = 0\n    var maxStr = \"\"\n\
    \    for _ in 0 ..< n {\n        maxCount += maxLen\n        let newMax = maxCount\
    \ / n\n        if newMax > maxLen {\n            maxCount = maxLen\n         \
    \   maxStr = String(s.characters.suffix(maxLen))\n        } else {\n         \
    \   maxStr = String(s.characters.suffix(newMax))\n        }\n    }\n    \n   \
    \ // \u7136\u540E\u8FD4\u56DE\u6700\u5927\u5B57\u7B26\u4E32\n    let strArr =\
    \ s.characters.filter{ str in\n        let idx = s.indexOf(str,startIndex: s.startIndex)\n\
    \        return idx == maxLen\n    }\n    return strArr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0hrb4xp4.swift:22:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let maxLen = s.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp0hrb4xp4.swift:35:31:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxStr = String(s.characters.suffix(maxLen))\n                             \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp0hrb4xp4.swift:37:31:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxStr = String(s.characters.suffix(newMax))\n                             \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp0hrb4xp4.swift:43:21:\
    \ error: value of type 'String' has no member 'indexOf'\n        let idx = s.indexOf(str,startIndex:\
    \ s.startIndex)\n                  ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let words = s.characters.split\
    \ {\n        CharacterSet.consonants.contains($0)\n    }.map {\n        if let\
    \ index = s.index($0) {\n            s.substring(from: index)\n        } else\
    \ {\n            \"\"\n        }\n    }.filter { $0.characters.count == n }\n\
    \    return words.map { String($0) }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpucn5g7tw.swift:20:9: error: cannot find 'CharacterSet' in scope\n\
    \        CharacterSet.consonants.contains($0)\n        ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    switch {\n    case\
    \ s == \"\":\n        return []\n    case n == 0:\n        return []\n    case\
    \ n == 1:\n        return s.split(\" \")\n    case s.isEmpty():\n        return\
    \ []\n    default:\n        var result = [String]()\n        \n        for i in\
    \ 0 ..< s.characters.count {\n            let char = s.characters.element(i)\n\
    \            \n            if char.isConsonant() {\n                if n == 2\
    \ {\n                    let n = 2\n                    \n                   \
    \ for s in s.split(\" \") {\n                        if s.characters.count >=\
    \ n {\n                            result.append(s)\n                        }\n\
    \                    }\n                    \n                } else {\n     \
    \               result.append(s)\n                }\n            }\n        }\n\
    \        \n        return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2x57eg3b.swift:19:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n/tmp/tmp2x57eg3b.swift:25:18: error: no exact matches\
    \ in call to instance method 'split'\n        return s.split(\" \")\n        \
    \         ^\n/tmp/tmp2x57eg3b.swift:25:18: note: found candidate with type '(String.Element,\
    \ Int, Bool) -> [ArraySlice<String.Element>]' (aka '(Character, Int, Bool) ->\
    \ Array<ArraySlice<Character>>')\n        return s.split(\" \")\n            \
    \     ^\n/tmp/tmp2x57eg3b.swift:25:18: note: found candidate with type '(String.Element,\
    \ Int, Bool) -> [String.SubSequence]' (aka '(Character, Int, Bool) -> Array<Substring>')\n\
    \        return s.split(\" \")\n                 ^\n/tmp/tmp2x57eg3b.swift:25:18:\
    \ error: no 'split' candidates produce the expected contextual result type '[String]'\n\
    \        return s.split(\" \")\n                 ^\nSwift.Sequence:2:40: note:\
    \ 'split(separator:maxSplits:omittingEmptySubsequences:)' produces '[ArraySlice<String.Element>]'\
    \ (aka 'Array<ArraySlice<Character>>'), not the expected contextual result type\
    \ '[String]'\n    @inlinable public __consuming func split(separator: Self.Element,\
    \ maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: 'split(separator:maxSplits:omittingEmptySubsequences:)'\
    \ produces '[String.SubSequence]' (aka 'Array<Substring>'), not the expected contextual\
    \ result type '[String]'\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n/tmp/tmp2x57eg3b.swift:31:26:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ i in 0 ..< s.characters.count {\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp2x57eg3b.swift:32:37: error: value of\
    \ type 'String' has no member 'element'\n "
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var ans = []\n    var\
    \ last = 0\n\n    for letter in s {\n        if last == n {\n            ans.append(s[last..<s.endIndex])\n\
    \            last = s.endIndex\n        }\n        if last < s.endIndex && letter\
    \ == s[last] {\n            last = last + 1\n        }\n    }\n    return ans\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprn4obnr8.swift:19:15: error: empty collection literal requires\
    \ an explicit type\n    var ans = []\n              ^~\n/tmp/tmprn4obnr8.swift:24:26:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \            ans.append(s[last..<s.endIndex])\n                         ^\n/tmp/tmprn4obnr8.swift:25:22:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  last = s.endIndex\n                   ~~^~~~~~~~\n/tmp/tmprn4obnr8.swift:27:17:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \        if last < s.endIndex && letter == s[last] {\n                ^\nSwift.BinaryInteger:4:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func < <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmprn4obnr8.swift:31:12: error: cannot convert return expression of\
    \ type '[Any]' to return type '[String]'\n    return ans\n           ^\n/tmp/tmprn4obnr8.swift:31:12:\
    \ note: arguments to generic parameter 'Element' ('Any' and 'String') are expected\
    \ to be equal\n    return ans\n           ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return s.split(separator:\
    \ \" \").filter{ word in\n        guard word.count <= n else { return false }\n\
    \        let vowels = \"aeiou\".split(separator: \"\")\n        return word.hasPrefix(vowels.contains({$0.isUpper}))\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv3a8nafj.swift:19:36: error: cannot convert return expression of\
    \ type '[ArraySlice<String.Element>]' (aka 'Array<ArraySlice<Character>>') to\
    \ return type '[String]'\n    return s.split(separator: \" \").filter{ word in\n\
    \                                   ^\n/tmp/tmpv3a8nafj.swift:19:36: note: arguments\
    \ to generic parameter 'Element' ('ArraySlice<String.Element>' (aka 'ArraySlice<Character>')\
    \ and 'String') are expected to be equal\n    return s.split(separator: \" \"\
    ).filter{ word in\n                                   ^\n/tmp/tmpv3a8nafj.swift:22:21:\
    \ error: value of type 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>')\
    \ has no member 'hasPrefix'\n        return word.hasPrefix(vowels.contains({$0.isUpper}))\n\
    \               ~~~~ ^~~~~~~~~\n/tmp/tmpv3a8nafj.swift:22:47: error: missing argument\
    \ label 'where:' in call\n        return word.hasPrefix(vowels.contains({$0.isUpper}))\n\
    \                                              ^\n                           \
    \                   where: \n/tmp/tmpv3a8nafj.swift:22:51: error: value of type\
    \ 'String.SubSequence' (aka 'Substring') has no member 'isUpper'\n        return\
    \ word.hasPrefix(vowels.contains({$0.isUpper}))\n                            \
    \                   ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var words : [String]\
    \ = []\n    \n    // TODO: Write your code here\n    return words\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpri6zyj_h/tmpri6zyj_h.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a21cb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a219aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a219ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a219ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpri6zyj_h                        0x000055fd08dee4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b0a21ea3460 __libc_start_main +
    245

    6    tmpri6zyj_h                        0x000055fd08dee0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result : [String]\
    \ = []\n    for word in s.split(\" \") {\n        let letters = word.characters.split(\"\
    \")\n        let count = letters.filter({ $0 == \"c\" || $0 == \"C\" || $0 ==\
    \ \"d\" || $0 == \"D\" || $0 == \"h\" || $0 == \"H\" || $0 == \"l\" || $0 == \"\
    L\" || $0 == \"s\" || $0 == \"S\" || $0 == \"z\" || $0 == \"Z\"}).count\n    \
    \    if count == n {\n            result.append(word)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi2zsqaeh.swift:20:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmpi2zsqaeh.swift:22:21: error: the compiler\
    \ is unable to type-check this expression in reasonable time; try breaking up\
    \ the expression into distinct sub-expressions\n        let count = letters.filter({\
    \ $0 == \"c\" || $0 == \"C\" || $0 == \"d\" || $0 == \"D\" || $0 == \"h\" || $0\
    \ == \"H\" || $0 == \"l\" || $0 == \"L\" || $0 == \"s\" || $0 == \"S\" || $0 ==\
    \ \"z\" || $0 == \"Z\"}).count\n                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014928
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var wordsArray = [String]()\n\
    \    for character in s {\n        if character == \" \" || character == \"\\\
    t\" {\n            continue\n        }\n        for j in 0 ... n {\n         \
    \   if let index = string.index(of: character) {\n                wordsArray.append(s.prefix(upTo:\
    \ index))\n                break\n            }\n        }\n    }\n    return\
    \ wordsArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8kkryjl7.swift:25:28: error: cannot find 'string' in scope\n  \
    \          if let index = string.index(of: character) {\n                    \
    \       ^~~~~~\n/tmp/tmp8kkryjl7.swift:26:37: error: cannot convert value of type\
    \ 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \                wordsArray.append(s.prefix(upTo: index))\n                  \
    \                  ^\n                                  String(              )\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var arr = [String]()\n\
    \    for i in 1...n {\n        for j in s.characters {\n            if i != n\
    \ {\n                if j == \" \" {\n                    arr.append(\" \")\n\
    \                } else {\n                    if i == 1 {\n                 \
    \       if Character(j) == \"a\" || Character(j) == \"e\" || Character(j) == \"\
    i\" {\n                            arr.append(j)\n                        }\n\
    \                    } else if i == 2 {\n                        if Character(j)\
    \ == \"o\" || Character(j) == \"u\" || Character(j) == \"y\" {\n             \
    \               arr.append(j)\n                        }\n                   \
    \ } else if i == 3 {\n                        if Character(j) == \"y\" || Character(j)\
    \ == \"a\" || Character(j) == \"e\" || Character(j) == \"i\" || Character(j) ==\
    \ \"o\" {\n                            arr.append(j)\n                       \
    \ }\n                    }\n                }\n            }\n        }\n    }\n\
    \    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppxicy8by.swift:21:20: error: 'characters' is unavailable: Please\
    \ use String directly\n        for j in s.characters {\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppxicy8by.swift:27:38:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \                      if Character(j) == \"a\" || Character(j) == \"e\" || Character(j)\
    \ == \"i\" {\n                                     ^\n                       \
    \              extendedGraphemeClusterLiteral: \n/tmp/tmppxicy8by.swift:27:61:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \                      if Character(j) == \"a\" || Character(j) == \"e\" || Character(j)\
    \ == \"i\" {\n                                                            ^\n\
    \                                                            extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmppxicy8by.swift:27:84: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n                        if Character(j) == \"a\" || Character(j) ==\
    \ \"e\" || Character(j) == \"i\" {\n                                         \
    \                                          ^\n                               \
    \                                                    extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmppxicy8by.swift:28:40: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                            arr.append(j)\n\
    \                                       ^\n/tmp/tmppxicy8by.swift:31:38: error:\
    \ missing argument label 'extendedGraphemeClusterLiteral:' in call\n         \
    \               if Character(j) == \"o\" || Character(j) == \"u\" || Character(j)\
    \ == \"y\" {\n                                     ^\n                       \
    \              extendedGraphemeClusterLiteral: \n/tmp/tmppxicy8by.swift:31:61:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \                      if Character(j) == \"o\" || Character(j) == \"u\" || Character(j)\
    \ == \"y\" {\n          "
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    let chars = s.characters;\n\
    \    var result = \"\";\n    var i = 0;\n    \n    while i < chars.count {\n \
    \       let char = chars[i];\n        \n        if let foundIndex = char.countConsonants(of:\
    \ chars, range: NSMakeRange(i, char.count)) {\n            if foundIndex <= n\
    \ {\n                result += String(chars[i ..< foundIndex])\n             \
    \   i += foundIndex - i;\n            } else {\n                result += String(chars[i\
    \ ..< char.count])\n                i += char.count - i;\n            }\n    \
    \    } else {\n            result += String(chars[i ..< char.count])\n       \
    \     i += char.count - i;\n        }\n    }\n    \n    return result.characters.split{$0\
    \ == \" \"}.map(String.init)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0sz4cwcn.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters;\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0sz4cwcn.swift:25:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let char = chars[i];\n                \
    \   ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmp0sz4cwcn.swift:27:68: error: cannot find 'NSMakeRange' in scope\n\
    \        if let foundIndex = char.countConsonants(of: chars, range: NSMakeRange(i,\
    \ char.count)) {\n                                                           \
    \        ^~~~~~~~~~~\n/tmp/tmp0sz4cwcn.swift:27:34: error: value of type 'Character'\
    \ has no member 'countConsonants'\n        if let foundIndex = char.countConsonants(of:\
    \ chars, range: NSMakeRange(i, char.count)) {\n                            ~~~~\
    \ ^~~~~~~~~~~~~~~\n/tmp/tmp0sz4cwcn.swift:27:88: error: value of type 'Character'\
    \ has no member 'count'\n        if let foundIndex = char.countConsonants(of:\
    \ chars, range: NSMakeRange(i, char.count)) {\n                              \
    \                                                    ~~~~ ^~~~~\n/tmp/tmp0sz4cwcn.swift:32:51:\
    \ error: value of type 'Character' has no member 'count'\n                result\
    \ += String(chars[i ..< char.count])\n                                       \
    \      ~~~~ ^~~~~\n/tmp/tmp0sz4cwcn.swift:33:27: error: value of type 'Character'\
    \ has no member 'count'\n                i += char.count - i;\n              \
    \       ~~~~ ^~~~~\n/tmp/tmp0sz4cwcn.swift:36:47: error: value of type 'Character'\
    \ has no member 'count'\n            result += String(chars[i ..< char.count])\n\
    \                                         ~~~~ ^~~~~\n/tmp/tmp0sz4cwcn.swift:37:23:\
    \ error: value of type 'Character' has no member 'count'\n            i += char.count\
    \ - i;\n   "
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // TODO: use map to\
    \ return [String]\n    var words = [String]()\n\n    for char in s.characters\
    \ {\n        if char.consonant {\n            var word = \"\"\n            for\
    \ _ in 0..<n {\n                word += String(char)\n            }\n        \
    \    words.append(word)\n        }\n    }\n\n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpre7_q7qj.swift:22:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpre7_q7qj.swift:23:17:\
    \ error: value of type 'Character' has no member 'consonant'\n        if char.consonant\
    \ {\n           ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var res: [String]\
    \ = []\n    if s.isEmpty{\n        return res\n    }\n    var prevChar: Character\
    \ = \"a\"\n    for i in s.characters{\n        if i == prevChar {\n          \
    \  continue\n        }\n        \n        var newWord = String()\n        \n \
    \       if prevChar == \"s\" {\n            newWord += String(i)\n           \
    \ prevChar = String(i) + \"a\"\n        }\n        \n        if prevChar == \"\
    z\" {\n            newWord += \"z\"\n            prevChar = \"a\"\n        }\n\
    \        if prevChar == \"z\" {\n            newWord += String(i)\n          \
    \  prevChar = String(i) + \"a\"\n        }\n        \n        if prevChar == \"\
    y\" {\n            newWord += String(i)\n            prevChar = String(i) + \"\
    a\"\n        }\n        \n        if prevChar == \"a\" {\n            newWord\
    \ += String(i)\n            prevChar = String(i) + \"a\"\n        }\n        \n\
    \        if prevChar == \"w\" {\n            newWord += String(i)\n          \
    \  prevChar = String(i) + \"a\"\n        }\n        \n        if prevChar == \"\
    u\" {\n            newWord += String(i)\n            prevChar = String(i) + \"\
    a\"\n        }\n        \n        if prevChar == \"k\" {\n            newWord\
    \ += String(i)\n            prevChar = String(i) + \"a\"\n        }\n        \n\
    \        if prevChar == \"b\" {\n            newWord += String(i)\n          \
    \  prevChar = String(i) + \"a\"\n        }\n        \n        if prevChar == \"\
    v\" {\n            newWord += String(i)\n            prevChar = String(i) + \"\
    a\"\n        }\n        \n        if prevChar == \"m\" {\n            newWord\
    \ += String(i)\n            prevChar = String(i) + \"a\"\n        }\n        \n\
    \        if prevChar == \"d\" {\n            newWord += String(i)\n          \
    \  prevChar = String(i) + \"a\"\n        }\n        \n        if prevChar == \"\
    r\" {\n            newWord += String(i)\n            prevChar = String(i) + \"\
    a\"\n        }\n        \n        if prevChar == \"j\" {\n            newWord\
    \ += String(i)\n            prevChar = String(i) + \"a\"\n        }\n        \n\
    \        if prevChar == \"l\" {\n            newWord += String(i)\n          \
    \  prevChar = String(i) + \"a\"\n        }\n        \n        if prevChar == \"\
    m\" {\n            newWord += String(i)\n            prevChar = String(i) + \"\
    a\"\n        }\n        \n        if prevChar == \"e\" {\n            newWord\
    \ += String(i)\n            prevChar\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppgth5mbb.swift:135:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmppgth5mbb.swift:25:26:\
    \ note: to match this opening '{'\n    for i in s.characters{\n              \
    \           ^\n/tmp/tmppgth5mbb.swift:135:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmppgth5mbb.swift:18:50: note: to match this opening '{'\nfunc select_words(s:\
    \ String, n: Int) -> [String] {\n                                            \
    \     ^\n/tmp/tmppgth5mbb.swift:25:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters{\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppgth5mbb.swift:34:34:\
    \ error: cannot assign value of type 'String' to type 'Character'\n          \
    \  prevChar = String(i) + \"a\"\n                       ~~~~~~~~~~^~~~~\n/tmp/tmppgth5mbb.swift:43:34:\
    \ error: cannot assign value of type 'String' to type 'Character'\n          \
    \  prevChar = String(i) + \"a\"\n                       ~~~~~~~~~~^~~~~\n/tmp/tmppgth5mbb.swift:48:34:\
    \ error: cannot assign value of type 'String' to type 'Character'\n          \
    \  prevChar = String(i) + \"a\"\n                       ~~~~~~~~~~^~~~~\n/tmp/tmppgth5mbb.swift:53:34:\
    \ error: cannot assign value of type 'String' to type 'Character'\n          \
    \  prevChar = String(i) + \"a\"\n                       ~~~~~~~~~~^~~~~\n/tmp/tmppgth5mbb.swift:58:34:\
    \ error: cannot assign value of type 'String' to type 'Character'\n          \
    \  prevChar = String(i) + \"a\"\n                       ~~~~~~~~~~^~~~~\n/tmp/tmppgth5mbb.swift:63:34:\
    \ error: cannot assign value of type 'String' to type 'Character'\n          \
    \  prevChar = String(i) + \"a\"\n                       ~~~~~~~~~~^~~~~\n/tmp/tmppgth5mbb.swift:68:34: "
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    let array = s.characters\n    for i in 0 ..< array.count {\n      \
    \  if array[i].isConsonant() {\n            if n > 0 && array[i].isConsonant()\
    \ {\n                result.appendContentsOf(Array(array[i+1..<array.count]).filter({$0\
    \ == \" \"}))\n                n -= 1\n            } else {\n                result.append(array[i])\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpk3fmhq9s.swift:21:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let array = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpk3fmhq9s.swift:23:21:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if array[i].isConsonant()\
    \ {\n           ~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpk3fmhq9s.swift:24:34: error: value\
    \ of type 'Character' has no member 'isConsonant'\n            if n > 0 && array[i].isConsonant()\
    \ {\n                        ~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpk3fmhq9s.swift:25:24:\
    \ error: value of type '[String]' has no member 'appendContentsOf'\n         \
    \       result.appendContentsOf(Array(array[i+1..<array.count]).filter({$0 ==\
    \ \" \"}))\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpk3fmhq9s.swift:26:19:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \                n -= 1\n                ~ ^\n/tmp/tmpk3fmhq9s.swift:28:36: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.append(array[i])\n                                   ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // TODO\n    \n   \
    \ return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpk0_cog2x/tmpk0_cog2x.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3cd25e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3cd22dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3cd22db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3cd22da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk0_cog2x                        0x0000560fcfbb44c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b3cd27d0460 __libc_start_main +
    245

    6    tmpk0_cog2x                        0x0000560fcfbb40c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return wordsWithConsonantsThatAppearAtLeastNTimes(s,\
    \ n: n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj1f9es41.swift:19:12: error: cannot find 'wordsWithConsonantsThatAppearAtLeastNTimes'\
    \ in scope\n    return wordsWithConsonantsThatAppearAtLeastNTimes(s, n: n)\n \
    \          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for i := 0;\
    \ i < len(s); i++ {\n        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\"\
    \ || s[i] == \"o\" || s[i] == \"u\" {\n            result = append(result, s[0\
    \ : i])\n        }\n    }\n    \n    for i := 0; i < len(result); i++ {\n    \
    \    for j := 0; j < n; j++ {\n            if result[i][i] == \"a\" || result[i][i]\
    \ == \"e\" || result[i][i] == \"i\" || result[i][i] == \"o\" || result[i][i] ==\
    \ \"u\" {\n                result.removeAtIndex(i)\n                i = i - 1\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp116sllo7.swift:25:12: error: expected type\n    for i := 0; i <\
    \ len(s); i++ {\n           ^\n            <#type#>\n/tmp/tmp116sllo7.swift:25:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(s); i++\
    \ {\n           ^\n/tmp/tmp116sllo7.swift:25:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(s); i++ {\n           ^\n/tmp/tmp116sllo7.swift:27:41:\
    \ error: expected ',' separator\n            result = append(result, s[0 : i])\n\
    \                                        ^\n                                 \
    \      ,\n/tmp/tmp116sllo7.swift:27:41: error: expected expression in list of\
    \ expressions\n            result = append(result, s[0 : i])\n               \
    \                         ^\n/tmp/tmp116sllo7.swift:31:12: error: expected type\n\
    \    for i := 0; i < len(result); i++ {\n           ^\n            <#type#>\n\
    /tmp/tmp116sllo7.swift:31:12: error: expected 'in' after for-each pattern\n  \
    \  for i := 0; i < len(result); i++ {\n           ^\n/tmp/tmp116sllo7.swift:31:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(result);\
    \ i++ {\n           ^\n/tmp/tmp116sllo7.swift:32:16: error: expected type\n  \
    \      for j := 0; j < n; j++ {\n               ^\n                <#type#>\n\
    /tmp/tmp116sllo7.swift:32:16: error: expected 'in' after for-each pattern\n  \
    \      for j := 0; j < n; j++ {\n               ^\n/tmp/tmp116sllo7.swift:32:16:\
    \ error: expected Sequence expression for for-each loop\n        for j := 0; j\
    \ < n; j++ {\n               ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpy2j4mtyo/tmpy2j4mtyo.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1c0964c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1c065bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1c065b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1c065a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy2j4mtyo                        0x000055d0ec3894c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ab1c0b50460 __libc_start_main +
    245

    6    tmpy2j4mtyo                        0x000055d0ec3890c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014334
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let words = [String]()\n\
    \    let vowels = \"AEIOUaeiou\".unicodeScalars\n    let consDigits = [Character(UnicodeScalar(\"\
    0\".unicodeScalars.first!)), \n                      Character(UnicodeScalar(\"\
    1\".unicodeScalars.first!)),\n                      Character(UnicodeScalar(\"\
    2\".unicodeScalars.first!)),\n                      Character(UnicodeScalar(\"\
    3\".unicodeScalars.first!)),\n                      Character(UnicodeScalar(\"\
    4\".unicodeScalars.first!)),\n                      Character(UnicodeScalar(\"\
    5\".unicodeScalars.first!)),\n                      Character(UnicodeScalar(\"\
    6\".unicodeScalars.first!)),\n                      Character(UnicodeScalar(\"\
    7\".unicodeScalars.first!)),\n                      Character(UnicodeScalar(\"\
    8\".unicodeScalars.first!)),\n                      Character(UnicodeScalar(\"\
    9\".unicodeScalars.first!))]\n    \n    let vowelAndDigits =\n        (vowels\
    \ + consDigits).unicodeScalars\n        .filter { \n            (s.rangeOfString($0.unicodeScalars.first!)\
    \ != nil)\n        }\n        \n    let vowelsAndConsDigits =\n        vowelAndDigits.filter\
    \ { \n            vowelAndDigits.contains{$0.unicodeScalars.first!.unicodeScalars.first!\
    \ in\n                vowels.unicodeScalars\n            }\n        }\n    \n\
    \    if vowelsAndConsDigits.count == 0 {\n        return words\n    }\n    \n\
    \    let firstParts = vowelsAndConsDigits.prefix(n)\n    let remainingParts =\
    \ vowelsAndConsDigits.suffix(n)\n    \n    for (i, word) in firstParts.enumerated()\
    \ {\n        if remainingParts.contains(word) {\n            words.append(word)\n\
    \        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp11axrrpn.swift:40:83: error: consecutive statements on a line must\
    \ be separated by ';'\n            vowelAndDigits.contains{$0.unicodeScalars.first!.unicodeScalars.first!\
    \ in\n                                                                       \
    \           ^\n                                                              \
    \                    ;\n/tmp/tmp11axrrpn.swift:40:84: error: expected expression\n\
    \            vowelAndDigits.contains{$0.unicodeScalars.first!.unicodeScalars.first!\
    \ in\n                                                                       \
    \            ^\n/tmp/tmp11axrrpn.swift:33:17: error: binary operator '+' cannot\
    \ be applied to operands of type 'String.UnicodeScalarView' and '[Character]'\n\
    \        (vowels + consDigits).unicodeScalars\n         ~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmp11axrrpn.swift:33:31: error: reference to member 'unicodeScalars' cannot\
    \ be resolved without a contextual type\n        (vowels + consDigits).unicodeScalars\n\
    \                              ^\n/tmp/tmp11axrrpn.swift:35:16: error: value of\
    \ type 'String' has no member 'rangeOfString'\n            (s.rangeOfString($0.unicodeScalars.first!)\
    \ != nil)\n             ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    let characters\
    \ = s.characters()\n    let alphabet = CharacterSet.letters\n    \n    var result\
    \ = [String]()\n    \n    if s.isEmpty {\n        return result\n    }\n    \n\
    \    for char in characters {\n        if !alphabet.contains(char) {\n       \
    \     break\n        }\n    }\n    \n    if n == 0 {\n        return result\n\
    \    }\n    \n    if n == 1 {\n        return [\"\\(n) \" + s]\n    }\n    \n\
    \    if n == 2 {\n        var words: [String] = []\n        \n        for char\
    \ in characters {\n            if alphabet.contains(char) {\n                words.append(String(char))\n\
    \            }\n        }\n        \n        return words\n    }\n    \n    for\
    \ char in characters {\n        if !alphabet.contains(char) {\n            let\
    \ newWords = select_words(s, n - 1)\n            let newWordsString = String(newWords)\n\
    \            \n            for word in words {\n                if word == \"\\\
    (n) \" + s {\n                    result.insert(newWordsString, 0)\n         \
    \       }\n            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpizq233yv.swift:20:24: error: cannot call value of non-function\
    \ type 'String'\n    let characters = s.characters()\n                       ^\
    \         ~~\n                                 \n/tmp/tmpizq233yv.swift:21:20:\
    \ error: cannot find 'CharacterSet' in scope\n    let alphabet = CharacterSet.letters\n\
    \                   ^~~~~~~~~~~~\n/tmp/tmpizq233yv.swift:57:40: error: missing\
    \ argument labels 's:n:' in call\n            let newWords = select_words(s, n\
    \ - 1)\n                                       ^\n                           \
    \             s: n: \n/tmp/tmpizq233yv.swift:60:25: error: cannot find 'words'\
    \ in scope\n            for word in words {\n                        ^~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tresult := []String()\n\
    \t\n\tif s == \"\" {\n\t\treturn result\n\t}\n\n\twords := count_letters(s)\n\t\
    if words == 0 {\n\t\treturn result\n\t}\n\n\tindex := 0\n\tletters := count_letters(s)\n\
    \twhile index < len(s) {\n\t\tif letters == n {\n\t\t\tbreak\n\t\t}\n\n\t\tletters\
    \ = letters - 1\n\t\tresult = append(result, s[index: index+1])\n\t\tindex = index\
    \ + 1\n\t}\n\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpocn8mt4c.swift:19:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result := []String()\n              ^\n       \
    \       ;\n/tmp/tmpocn8mt4c.swift:19:9: error: expected expression\n        result\
    \ := []String()\n               ^\n/tmp/tmpocn8mt4c.swift:25:7: error: consecutive\
    \ statements on a line must be separated by ';'\n        words := count_letters(s)\n\
    \             ^\n             ;\n/tmp/tmpocn8mt4c.swift:25:8: error: expected\
    \ expression\n        words := count_letters(s)\n              ^\n/tmp/tmpocn8mt4c.swift:30:7:\
    \ error: consecutive statements on a line must be separated by ';'\n        index\
    \ := 0\n             ^\n             ;\n/tmp/tmpocn8mt4c.swift:30:8: error: expected\
    \ expression\n        index := 0\n              ^\n/tmp/tmpocn8mt4c.swift:19:2:\
    \ error: cannot find 'result' in scope\n        result := []String()\n       \
    \ ^~~~~~\n/tmp/tmpocn8mt4c.swift:22:10: error: cannot find 'result' in scope\n\
    \                return result\n                       ^~~~~~\n/tmp/tmpocn8mt4c.swift:25:2:\
    \ error: cannot find 'words' in scope\n        words := count_letters(s)\n   \
    \     ^~~~~\n/tmp/tmpocn8mt4c.swift:26:5: error: cannot find 'words' in scope\n\
    \        if words == 0 {\n           ^~~~~\n/tmp/tmpocn8mt4c.swift:27:10: error:\
    \ cannot find 'result' in scope\n                return result\n             \
    \          ^~~~~~\n/tmp/tmpocn8mt4c.swift:30:2: error: cannot find 'index' in\
    \ scope\n        index := 0\n        ^~~~~\n/tmp/tmpocn8mt4c.swift:32:8: error:\
    \ cannot find 'index' in scope\n        while index < len(s) {\n             \
    \ ^~~~~\n/tmp/tmpocn8mt4c.swift:32:16: error: cannot find 'len' in scope\n   \
    \     while index < len(s) {\n                      ^~~\n/tmp/tmpocn8mt4c.swift:33:6:\
    \ error: cannot find 'letters' in scope\n                if letters == n {\n \
    \                  ^~~~~~~\n/tmp/tmpocn8mt4c.swift:37:3: error: cannot find 'letters'\
    \ in scope\n                letters = letters - 1\n                ^~~~~~~\n/tmp/tmpocn8mt4c.swift:37:13:\
    \ error: cannot find 'letters' in scope\n                letters = letters - 1\n\
    \            "
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n    \n    func checkWord(word: String) -> Bool {\n  \
    \      var counter: Int = 0\n        for character in word {\n            if character\
    \ == \"a\" || character == \"e\" || character == \"i\" || character == \"o\" ||\
    \ character == \"u\" {\n                counter += 1\n            }\n        }\n\
    \        if counter == n {\n            return true\n        }\n        return\
    \ false\n    }\n    \n    var splits: [String] = []\n    \n    for character in\
    \ s {\n        if character == \" \" {\n            for s in splits {\n      \
    \          splits.append(s)\n            }\n            splits.removeAll()\n \
    \           continue\n        }\n        \n        if checkWord(character) {\n\
    \            splits.append(character)\n        }\n    }\n    \n    return splits\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6f1es0_h.swift:47:22: error: missing argument label 'word:' in\
    \ call\n        if checkWord(character) {\n                     ^\n          \
    \           word: \n/tmp/tmp6f1es0_h.swift:47:22: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n        if checkWord(character)\
    \ {\n                     ^\n/tmp/tmp6f1es0_h.swift:48:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            splits.append(character)\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let result: [String]\
    \ = []\n    for i in 0..<s.length {\n        if s[i].isConsonant() && s[i] !=\
    \ ' ' {\n            result += [s.substringWithRange(i..<i+n)]\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmptis1rzka.swift:21:42: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i].isConsonant() && s[i] != ' ' {\n                 \
    \                        ^~~\n                                         \" \"\n\
    /tmp/tmptis1rzka.swift:20:20: error: value of type 'String' has no member 'length'\n\
    \    for i in 0..<s.length {\n                 ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result : [String]\
    \ = []\n    \n    // write your code in here\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp_bgxbn1a/tmp_bgxbn1a.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e3ea44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e3e73bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e3e73b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e3e73a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_bgxbn1a                        0x000055d78cef94c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b7e3ec30460 __libc_start_main +
    245

    6    tmp_bgxbn1a                        0x000055d78cef90c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // BEGIN Question 3\n\
    \    var result = [String]()\n    for let c : Characters in s.characters {\n \
    \       if s.characters.count > n {\n            return result\n        }\n  \
    \      if c == \" \" {\n            continue\n        }\n        if c.isVowel\
    \ {\n            if s.characters.count > n {\n                return result\n\
    \            }\n            if s.characters.count < n {\n                return\
    \ []\n            }\n            if count > n {\n                return result\n\
    \            }\n            if count < n {\n                return []\n      \
    \      }\n        }\n        if c.isConsonant {\n            if s.characters.count\
    \ > n {\n                return result\n            }\n            if s.characters.count\
    \ < n {\n                return []\n            }\n            if count > n {\n\
    \                return result\n            }\n            if count < n {\n  \
    \              return []\n            }\n        }\n    }\n    return result\n\
    \    // END Question 3\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw8vo8jc4.swift:21:9: error: 'let' pattern cannot appear nested\
    \ in an already immutable context\n    for let c : Characters in s.characters\
    \ {\n        ^\n/tmp/tmpw8vo8jc4.swift:21:17: error: cannot find type 'Characters'\
    \ in scope\n    for let c : Characters in s.characters {\n                ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\treturn []\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp8j9p5rhv/tmp8j9p5rhv.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b5152dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b51224b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b51224988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b512237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8j9p5rhv                        0x000055d81af834c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b4b51719460 __libc_start_main +
    245

    6    tmp8j9p5rhv                        0x000055d81af830c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014283
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar arr = s.characters\n\
    \tvar start = 0\n\tvar result = [String]()\n\tfor start < s.characters.count {\n\
    \t\tlet found = find(arr, start, n)\n\t\tresult = append(result, arr[start...found])\n\
    \t\tstart = found + 1\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz4pkw9ig.swift:22:12: error: expected 'in' after for-each pattern\n\
    \        for start < s.characters.count {\n                  ^\n/tmp/tmpz4pkw9ig.swift:22:12:\
    \ error: unary operator cannot be separated from its operand\n        for start\
    \ < s.characters.count {\n                  ^~\n                   \n/tmp/tmpz4pkw9ig.swift:19:14:\
    \ error: 'characters' is unavailable: Please use String directly\n        var\
    \ arr = s.characters\n                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpz4pkw9ig.swift:22:12: error: '<' is not\
    \ a prefix unary operator\n        for start < s.characters.count {\n        \
    \          ^\n/tmp/tmpz4pkw9ig.swift:23:15: error: cannot find 'find' in scope\n\
    \                let found = find(arr, start, n)\n                           \
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if n == 0 { \n    \
    \    return []\n    }\n    let mut chars = s.chars();\n    let mut i = 1;\n  \
    \  let mut words: [[String]] = [[]];\n    while i < chars.count {\n        if\
    \ chars[i] == ' ' || chars[i] == ' ' && i != chars.count - 1 {\n            words[chars[i-1].intValue()].push(String(chars[i:i+n]))\n\
    \        }\n        i += n;\n    }\n    return words.map({ $0.joinWithSeparator(\"\
    \ \") }).filter({ !$0.isEmpty() })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpisgu0n6x.swift:22:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut chars =\
    \ s.chars();\n            ^\n/tmp/tmpisgu0n6x.swift:22:13: note: join the identifiers\
    \ together\n    let mut chars = s.chars();\n        ~~~~^~~~~\n        mutchars\n\
    /tmp/tmpisgu0n6x.swift:22:13: note: join the identifiers together with camel-case\n\
    \    let mut chars = s.chars();\n        ~~~~^~~~~\n        mutChars\n/tmp/tmpisgu0n6x.swift:23:13:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n    let mut i = 1;\n            ^\n/tmp/tmpisgu0n6x.swift:23:13:\
    \ note: join the identifiers together\n    let mut i = 1;\n        ~~~~^\n   \
    \     muti\n/tmp/tmpisgu0n6x.swift:23:13: note: join the identifiers together\
    \ with camel-case\n    let mut i = 1;\n        ~~~~^\n        mutI\n/tmp/tmpisgu0n6x.swift:24:13:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n    let mut words: [[String]] = [[]];\n            ^\n\
    /tmp/tmpisgu0n6x.swift:24:13: note: join the identifiers together\n    let mut\
    \ words: [[String]] = [[]];\n        ~~~~^~~~~\n        mutwords\n/tmp/tmpisgu0n6x.swift:24:13:\
    \ note: join the identifiers together with camel-case\n    let mut words: [[String]]\
    \ = [[]];\n        ~~~~^~~~~\n        mutWords\n/tmp/tmpisgu0n6x.swift:26:24:\
    \ error: single-quoted string literal found, use '\"'\n        if chars[i] ==\
    \ ' ' || chars[i] == ' ' && i != chars.count - 1 {\n                       ^~~\n\
    \                       \" \"\n/tmp/tmpisgu0n6x.swift:26:43: error: single-quoted\
    \ string literal found, use '\"'\n        if chars[i] == ' ' || chars[i] == '\
    \ ' && i != chars.count - 1 {\n                                          ^~~\n\
    \                                          \" \"\n/tmp/tmpisgu0n6x.swift:22:23:\
    \ error: value of type 'String' has no member 'chars'\n    let mut chars = s.chars();\n\
    \                    ~ ^~~~~\n/tmp/tmpisgu0n6x.swift:24:9: error: invalid redeclaration\
    \ of 'mut'\n    let mut words: [[String]] = [[]];\n        ^\n/tmp/t"
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // Good luck!\n   \
    \ return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp0sz0u20n/tmp0sz0u20n.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba4a83f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba4a80f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba4a80f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba4a80ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0sz0u20n                        0x0000562f85a264c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ba4a85e5460 __libc_start_main +
    245

    6    tmp0sz0u20n                        0x0000562f85a260c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n    var words: [String] = []\n    var i = 0\n    var\
    \ j = 0\n    for c in s {\n        if c == \" \" {\n            i += 2\n     \
    \       j = 0\n        } else if i == n {\n            words.append(s[i ..< j])\n\
    \            j = 0\n        } else {\n            i += 1\n        }\n    }\n \
    \   return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyr40_yrm.swift:30:26: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \            words.append(s[i ..< j])\n                         ^~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return select_words_c(s,\
    \ n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpa6p_34v_.swift:19:12: error: cannot find 'select_words_c' in scope\n\
    \    return select_words_c(s, n)\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var ret = [String]()\n\
    \    var index = 0\n    while index < s.characters.count {\n        let word =\
    \ String(s.characters[index..<index+n])\n        if word.hasPrefix(String(Character.consonantsSet))\
    \ {\n            ret.append(word)\n            index += n\n        }\n    }\n\
    \    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_eogek3z.swift:21:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    while index < s.characters.count {\n              \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp_eogek3z.swift:22:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n        let word = String(s.characters[index..<index+n])\n\
    \                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmp_eogek3z.swift:22:29: error: 'characters' is unavailable: Please use String\
    \ directly\n        let word = String(s.characters[index..<index+n])\n       \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_eogek3z.swift:23:44: error: type 'Character' has no member 'consonantsSet'\n\
    \        if word.hasPrefix(String(Character.consonantsSet)) {\n              \
    \                   ~~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // BEGIN PSEUDOCODE\n\
    \    let count = count_consonants(s)\n    var strs: [String] = []\n    \n    //\
    \ Loop over all words in strs.\n    for str in strs {\n        // Loop over all\
    \ characters in str.\n        for char in str {\n            // If character is\
    \ consonant.\n            if count == n {\n                // Add str to strs.\n\
    \                strs.append(str)\n            }\n        }\n    }\n    \n   \
    \ return strs\n    // END PSEUDOCODE\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmphg4osrzq.swift:20:17: error: cannot find 'count_consonants' in\
    \ scope\n    let count = count_consonants(s)\n                ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    while i < s.count {\n        var current = s.substring(i,\
    \ i+n)\n        if current.characters.count < n {\n            result.appendContentsOf(split(current))\n\
    \        }\n        i += n\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpychu0bli.swift:22:25: error: value of type 'String' has no member\
    \ 'substring'\n        var current = s.substring(i, i+n)\n                   \
    \   ~ ^~~~~~~~~\n/tmp/tmpychu0bli.swift:24:37: error: cannot find 'split' in scope\n\
    \            result.appendContentsOf(split(current))\n                       \
    \             ^~~~~\n/tmp/tmpychu0bli.swift:24:20: error: value of type '[String]'\
    \ has no member 'appendContentsOf'\n            result.appendContentsOf(split(current))\n\
    \            ~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result : [String]\
    \ = []\n    if s == \"\" {\n        return result\n    }\n    let regex = try\
    \ NSRegularExpression(pattern: \"[^\" + s.lowercaseString  + \"]\", options: [])\n\
    \    if let matches = regex.matches(in: s, range: NSMakeRange(0, s.characters.count))\
    \ {\n        for match in matches {\n            let start = match.rangeAt(0)\n\
    \            let end = match.rangeAt(match.numberOfRanges)\n            if end\
    \ - start == n {\n                result.append(s.substring(with: start))\n  \
    \          }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi_b9j6o4.swift:23:21: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try NSRegularExpression(pattern: \"[^\" + s.lowercaseString\
    \  + \"]\", options: [])\n                    ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpi_b9j6o4.swift:23:59:\
    \ error: value of type 'String' has no member 'lowercaseString'\n    let regex\
    \ = try NSRegularExpression(pattern: \"[^\" + s.lowercaseString  + \"]\", options:\
    \ [])\n                                                        ~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpi_b9j6o4.swift:24:50: error: cannot find 'NSMakeRange' in scope\n    if\
    \ let matches = regex.matches(in: s, range: NSMakeRange(0, s.characters.count))\
    \ {\n                                                 ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var ret: [String] =\
    \ [nil]\n    for i in 0..<s.characters.count {\n        var tmp: [String] = []\n\
    \        for j in 0..<n {\n            tmp.append(s.substringWithRange(NSMakeRange(i,\
    \ j+1)))\n        }\n        ret = tmp\n    }\n    return ret\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmptf0gk_hj.swift:19:26: error: 'nil' is not compatible with expected\
    \ element type 'String'\n    var ret: [String] = [nil]\n                     \
    \    ^\n/tmp/tmptf0gk_hj.swift:20:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<s.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmptf0gk_hj.swift:23:45:\
    \ error: cannot find 'NSMakeRange' in scope\n            tmp.append(s.substringWithRange(NSMakeRange(i,\
    \ j+1)))\n                                            ^~~~~~~~~~~\n/tmp/tmptf0gk_hj.swift:23:26:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \   tmp.append(s.substringWithRange(NSMakeRange(i, j+1)))\n                  \
    \     ~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tif n == 0 { return []\
    \ }\n\n\tlet words = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"\
    j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"\
    w\",\"x\",\"y\",\"z\"]\n\tvar out = [String]()\n\t\n\tif s == \"\" {\n\t\treturn\
    \ out\n\t}\n\t\n\tlet count = [String: Int]()\n\tfor letter in s {\n\t\tlet count\
    \ = count[letter]\n\t\tif count == nil {\n\t\t\tcount = 1\n\t\t} else {\n\t\t\t\
    count = count + 1\n\t\t}\n\t\tcount[letter] = count\n\t}\n\t\n\tfor letter in\
    \ words {\n\t\tlet count = count[letter]\n\t\tif count == n {\n\t\t\tout.insert(letter,\
    \ at: 0)\n\t\t}\n\t}\n\t\n\treturn out\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxd89vwev.swift:30:20: error: no exact matches in call to subscript\
    \ \n                let count = count[letter]\n                              \
    \   ^\nSwift.Dictionary:8:23: note: candidate expects value of type 'Dictionary<String,\
    \ Int>.Index' for parameter #1 (got 'Character')\n    @inlinable public subscript(position:\
    \ Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Element { get }\n  \
    \                    ^\nSwift.Dictionary:2:23: note: candidate expects value of\
    \ type 'String' for parameter #1 (got 'Character')\n    @inlinable public subscript(key:\
    \ Key) -> Value? { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: candidate expects value of type 'Range<Dictionary<String, Int>.Index>'\
    \ for parameter #1 (got 'Character')\n    @inlinable public subscript(bounds:\
    \ Range<Self.Index>) -> Slice<Self> { get }\n                      ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Character')\n    @inlinable public subscript(x: (UnboundedRange_) ->\
    \ ()) -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let arr = s.characters.split{$0\
    \ == \" \"}.map(String.init)\n    let arr = arr.filter{$0.characters.count >=\
    \ n}.sort{$0.characters.count < $1.characters.count}\n    return arr.reverse()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnbbcesi0.swift:19:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    let arr = s.characters.split{$0 == \" \"}.map(String.init)\n\
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpnbbcesi0.swift:20:52: error: cannot use mutating member on immutable\
    \ value: function call returns immutable value\n    let arr = arr.filter{$0.characters.count\
    \ >= n}.sort{$0.characters.count < $1.characters.count}\n              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar arr: [String] = []\n\
    \tfor i := 0; i < len(s); i++ {\n\t\tif s.hasConsonant(s[i]) {\n\t\t\tarr = append(arr,\
    \ s[0..i])\n\t\t}\n\t}\n\treturn arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcw848164.swift:20:9: error: expected type\n        for i := 0;\
    \ i < len(s); i++ {\n               ^\n                <#type#>\n/tmp/tmpcw848164.swift:20:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(s);\
    \ i++ {\n               ^\n/tmp/tmpcw848164.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(s); i++ {\n      \
    \         ^\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let n = n as Int\n\
    \    if s == \"\" {\n        return []\n    }\n    var res = [String]()\n    var\
    \ i = 0\n    for c in s {\n        if i > n {\n            break\n        }\n\
    \        if (c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\"\
    ) {\n            i += 1\n            continue\n        }\n        if c == \" \"\
    \ || c == \"\\t\" || c == \"\\n\" || c == \"\\r\" {\n            i += 1\n    \
    \        continue\n        }\n        if (c == \"n\" || c == \"t\" || c == \"\
    m\" || c == \"d\" || c == \"k\" || c == \"b\" || c == \"p\" || c == \"f\") {\n\
    \            res.insert(s.substringWithRange(i..<s.count), at: 0)\n          \
    \  i = s.endIndex\n            continue\n        }\n        res.insert(s.substringWithRange(i..<s.count),\
    \ at: 0)\n        i = s.endIndex\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp68bj8ute.swift:38:26: error: value of type 'String' has no member\
    \ 'substringWithRange'\n            res.insert(s.substringWithRange(i..<s.count),\
    \ at: 0)\n                       ~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp68bj8ute.swift:39:19:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  i = s.endIndex\n                ~~^~~~~~~~\n/tmp/tmp68bj8ute.swift:42:22: error:\
    \ value of type 'String' has no member 'substringWithRange'\n        res.insert(s.substringWithRange(i..<s.count),\
    \ at: 0)\n                   ~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp68bj8ute.swift:43:15:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n        i =\
    \ s.endIndex\n            ~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // M1. \u6A21\u62DF\
    \n    \n    // \u9996\u5148\u6309\u7167 s \u5B57\u7B26\u4E32\u7684\u957F\u5EA6\
    \u8FDB\u884C\u5224\u65AD, \u5982\u679C\u957F\u5EA6\u4E0D\u8DB3 n \u5219\u8FD4\u56DE\
    \u7A7A\u6570\u7EC4\n    let maxLength: Int = s.characters.count\n    let returnArray:\
    \ [String] = []\n    let count = n\n    for index in 0..<maxLength {\n       \
    \ if s.characters.count - index < count {\n            returnArray.append(\"\"\
    )\n        } else {\n            returnArray.append(String(s.characters[index..<index+count]))\n\
    \        }\n    }\n    \n    // \u7136\u540E\u8FDB\u884C\u7B5B\u9009, \u5982\u679C\
    \ count \u5927\u4E8E n \u5219\u7B5B\u9009\u5931\u8D25\u8FD4\u56DE\u7A7A\u6570\u7EC4\
    \n    if count > n {\n        return returnArray\n    }\n    \n    // M2. \u76F4\
    \u63A5\u7528 Swift \u7684\u96C6\u5408\u7684\u65B9\u6CD5\n    \n    // \u7B5B\u9009\
    \ s \u4E2D\u7B26\u5408\u6761\u4EF6\u7684\u5B57\u7B26\u4E32\n    var filtered:\
    \ [String] = []\n    s.characters.forEach({ c in\n        if c == \" \" || c ==\
    \ \"\\n\" || c == \"\\r\" || c == \"\\t\" {\n            return\n        }\n \
    \       if let index = s.indexOf(c) {\n            if index == 0 || index == s.characters.count\
    \ - 1 {\n                return\n            }\n            let subStr = String(s.characters.index(after:\
    \ index+1)..<s.characters.index(before: index))\n            filtered = filtered.filter\
    \ { subStr != $0 }\n        }\n    })\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmms1x6oa.swift:22:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let maxLength: Int = s.characters.count\n         \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmms1x6oa.swift:26:14: error: 'characters' is unavailable: Please\
    \ use String directly\n        if s.characters.count - index < count {\n     \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpmms1x6oa.swift:27:25:\
    \ error: cannot use mutating member on immutable value: 'returnArray' is a 'let'\
    \ constant\n            returnArray.append(\"\")\n            ~~~~~~~~~~~ ^\n\
    /tmp/tmpmms1x6oa.swift:23:5: note: change 'let' to 'var' to make it mutable\n\
    \    let returnArray: [String] = []\n    ^~~\n    var\n/tmp/tmpmms1x6oa.swift:29:25:\
    \ error: cannot use mutating member on immutable value: 'returnArray' is a 'let'\
    \ constant\n            returnArray.append(String(s.characters[index..<index+count]))\n\
    \            ~~~~~~~~~~~ ^\n/tmp/tmpmms1x6oa.swift:23:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let returnArray: [String] = []\n    ^~~\n    var\n\
    /tmp/tmpmms1x6oa.swift:46:26: error: value of type 'String' has no member 'indexOf'\n\
    \        if let index = s.indexOf(c) {\n                       ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // Your code here\n\
    \    let split = s.split(separator: \" \")\n    return split.filter({ $0.contains(\"\
    a\") || $0.contains(\"e\") || $0.contains(\"i\") || $0.contains(\"o\") || $0.contains(\"\
    u\") }).map{ String($0).trimmingCharacters(in: CharacterSet.letters) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg2hqk9w5.swift:21:166: error: cannot find 'CharacterSet' in scope\n\
    \    return split.filter({ $0.contains(\"a\") || $0.contains(\"e\") || $0.contains(\"\
    i\") || $0.contains(\"o\") || $0.contains(\"u\") }).map{ String($0).trimmingCharacters(in:\
    \ CharacterSet.letters) }\n                                                  \
    \                                                                            \
    \                                       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmp71zsovev.swift:20:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = Array(repeating:\
    \ \"Uncle\", count: n)\n    \n    if s.isEmpty {\n        return result\n    }\n\
    \    \n    var pos = 0\n    var charCount = 0\n    var startIndex = s.startIndex\n\
    \    \n    for char in s { // count consonants in substring of s\n        if char\
    \ == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\"\
    \ {\n            charCount++\n        }\n    }\n    \n    // count consonants\
    \ in substring of s\n    for char in s { // count consonants in substring of s\n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            charCount++\n        }\n    }\n    \n    if charCount\
    \ == n {\n        for char in s { // count consonants in substring of s\n    \
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n                result.insert(s.startIndex.advancedBy(pos),\
    \ char)\n            }\n            pos += 1\n        }\n    } else {\n      \
    \  result.insert(s.startIndex, \"\")\n        for char in s { // count consonants\
    \ in substring of s\n            if char == \"a\" || char == \"e\" || char ==\
    \ \"i\" || char == \"o\" || char == \"u\" {\n                result.insert(s.startIndex.advancedBy(pos),\
    \ char)\n            }\n            pos += 1\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8xo02u0y.swift:31:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            charCount++\n                     ^~\n/tmp/tmp8xo02u0y.swift:38:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  charCount++\n                     ^~\n/tmp/tmp8xo02u0y.swift:45:24: error:\
    \ no exact matches in call to instance method 'insert'\n                result.insert(s.startIndex.advancedBy(pos),\
    \ char)\n                       ^\n/tmp/tmp8xo02u0y.swift:45:24: note: found candidate\
    \ with type '(__owned String, Int) -> ()'\n                result.insert(s.startIndex.advancedBy(pos),\
    \ char)\n                       ^\n/tmp/tmp8xo02u0y.swift:45:44: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n                result.insert(s.startIndex.advancedBy(pos),\
    \ char)\n                              ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp8xo02u0y.swift:50:22:\
    \ error: missing argument labels 'contentsOf:at:' in call\n        result.insert(s.startIndex,\
    \ \"\")\n                     ^\n                      contentsOf:   at: \n/tmp/tmp8xo02u0y.swift:50:37:\
    \ error: cannot convert value of type 'String' to expected argument type 'Array<String>.Index'\
    \ (aka 'Int')\n        result.insert(s.startIndex, \"\")\n                   \
    \                 ^\n/tmp/tmp8xo02u0y.swift:50:9: error: instance method 'insert(contentsOf:at:)'\
    \ requires that 'String.Index' conform to 'Collection'\n        result.insert(s.startIndex,\
    \ \"\")\n        ^\nSwift.RangeReplaceableCollection:7:37: note: where 'C' = 'String.Index'\n\
    \    @inlinable public mutating func insert<C>(contentsOf newElements: __owned\
    \ C, at i: Self.Index) where C : Collection, Self.Element == C.Element\n     \
    \                               ^\n/tmp/tmp8xo02u0y.swift:53:24: error: no exact\
    \ matches in call to instance method 'insert'\n                result.insert(s.startIndex.advancedBy(pos),\
    \ char)\n                       ^\n/tmp/tmp8xo02u0y.swift:53:24: note: found candidate\
    \ with type '(__owned String, Int) -> ()'\n                result.insert(s.startIndex.advancedBy(pos),\
    \ char)\n        "
  stdout: ''
  timestamp: 1660014603
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // TODO: implement\
    \ me\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp8xpmztlr/tmp8xpmztlr.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af774f89c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af774c80b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af774c80988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af774c7f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8xpmztlr                        0x00005628307754c4 <unavailable> + 5316

    5    libc.so.6                          0x00002af775175460 __libc_start_main +
    245

    6    tmp8xpmztlr                        0x00005628307750c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var letters =\
    \ [String]()\n    \n    for letter in s.characters {\n        if letter != \"\
    \ \" {\n            if letters.count <= n {\n                letters.append(letter)\n\
    \            }\n            \n            if letters.count == n {\n          \
    \      return letters\n            }\n            \n        } else {\n       \
    \     return []\n        }\n    }\n    \n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfuico7nr.swift:22:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpfuico7nr.swift:25:32:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                letters.append(letter)\n                               ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n    if n == 0 {\n        return [s]\n    }\n    var words\
    \ = [s]\n    for i in 1..<n {\n        words = append(words, filterWords(s, i))\n\
    \    }\n    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaiavxsym.swift:27:17: error: cannot find 'append' in scope\n  \
    \      words = append(words, filterWords(s, i))\n                ^~~~~~\n/tmp/tmpaiavxsym.swift:27:31:\
    \ error: cannot find 'filterWords' in scope\n        words = append(words, filterWords(s,\
    \ i))\n                              ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var a: [String] = []\n\
    \    for char in s {\n        if char == \"a\" || char == \"e\" || char == \"\
    i\" || char == \"o\" || char == \"u\" {\n            for letter in char {\n  \
    \              if let index = s.index(s.index(of: letter), offsetBy: -1) {\n \
    \                   a.remove(at: index)\n                }\n            }\n  \
    \      }\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1w8ukx_5.swift:22:27: error: for-in loop requires 'Character' to\
    \ conform to 'Sequence'\n            for letter in char {\n                  \
    \        ^~~~\n/tmp/tmp1w8ukx_5.swift:23:42: error: value of optional type 'String.Index?'\
    \ must be unwrapped to a value of type 'String.Index'\n                if let\
    \ index = s.index(s.index(of: letter), offsetBy: -1) {\n                     \
    \                    ^\n/tmp/tmp1w8ukx_5.swift:23:42: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n              \
    \  if let index = s.index(s.index(of: letter), offsetBy: -1) {\n             \
    \                            ^\n                                             \
    \              ?? <#default value#>\n/tmp/tmp1w8ukx_5.swift:23:42: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \        if let index = s.index(s.index(of: letter), offsetBy: -1) {\n       \
    \                                  ^\n                                       \
    \                   !\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var res = Set<String>()\n\
    \    for i in s.characters {\n        if i.isUppercase {\n            res.insert(\"\
    %c\".stringByAppendingFormat(i), in: &res)\n        } else {\n            res.insert(\"\
    %c\".stringByAppendingFormat(i), in: &res)\n        }\n    }\n    \n    var results\
    \ = [String]()\n    \n    for v in res {\n        if v.count < n {\n         \
    \   continue\n        }\n        if v.count == n {\n            results.append(v)\n\
    \        } else {\n            for _ in 0..<n-v.count {\n                results.append(\"\
    %c\".stringByAppendingFormat(\" \"), in: &results)\n            }\n          \
    \  results.append(v)\n        }\n    }\n    \n    return results\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmm2kbfga.swift:20:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpmm2kbfga.swift:22:61:\
    \ error: extra argument 'in' in call\n            res.insert(\"%c\".stringByAppendingFormat(i),\
    \ in: &res)\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpmm2kbfga.swift:22:29: error: value of type 'String' has no member 'stringByAppendingFormat'\n\
    \            res.insert(\"%c\".stringByAppendingFormat(i), in: &res)\n       \
    \                ~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmm2kbfga.swift:24:61: error:\
    \ extra argument 'in' in call\n            res.insert(\"%c\".stringByAppendingFormat(i),\
    \ in: &res)\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpmm2kbfga.swift:24:29: error: value of type 'String' has no member 'stringByAppendingFormat'\n\
    \            res.insert(\"%c\".stringByAppendingFormat(i), in: &res)\n       \
    \                ~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmm2kbfga.swift:38:71: error:\
    \ extra argument 'in' in call\n                results.append(\"%c\".stringByAppendingFormat(\"\
    \ \"), in: &results)\n                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmpmm2kbfga.swift:38:37: error: value of type 'String' has no member 'stringByAppendingFormat'\n\
    \                results.append(\"%c\".stringByAppendingFormat(\" \"), in: &results)\n\
    \                               ~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar ans = [[String]]()\n\
    \t\n\tif s == \"\" {\n\t\treturn ans\n\t}\n\t\n\tlet chars = s.characters\n\t\n\
    \tfor i := 0; i < chars.count; i++ {\n\t\tif chars[i] == ' ' {\n\t\t\tfor j :=\
    \ i; j < chars.count; j++ {\n\t\t\t\tif chars[j] == 'a' || chars[j] == 'e' ||\
    \ chars[j] == 'i' || chars[j] == 'o' || chars[j] == 'u' {\n\t\t\t\t\tbreak\n\t\
    \t\t\t}\n\t\t\t\tans.append(s[i : j])\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans = ans.filter({$0.count\
    \ < n})\n\t\n\treturn ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmplciwl_9t.swift:27:9: error: expected type\n        for i := 0;\
    \ i < chars.count; i++ {\n               ^\n                <#type#>\n/tmp/tmplciwl_9t.swift:27:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < chars.count;\
    \ i++ {\n               ^\n/tmp/tmplciwl_9t.swift:27:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < chars.count; i++ {\n \
    \              ^\n/tmp/tmplciwl_9t.swift:28:18: error: single-quoted string literal\
    \ found, use '\"'\n                if chars[i] == ' ' {\n                    \
    \           ^~~\n                               \" \"\n/tmp/tmplciwl_9t.swift:29:11:\
    \ error: expected type\n                        for j := i; j < chars.count; j++\
    \ {\n                               ^\n                                <#type#>\n\
    /tmp/tmplciwl_9t.swift:29:11: error: expected 'in' after for-each pattern\n  \
    \                      for j := i; j < chars.count; j++ {\n                  \
    \             ^\n/tmp/tmplciwl_9t.swift:29:11: error: expected Sequence expression\
    \ for for-each loop\n                        for j := i; j < chars.count; j++\
    \ {\n                               ^\n/tmp/tmplciwl_9t.swift:30:20: error: single-quoted\
    \ string literal found, use '\"'\n                                if chars[j]\
    \ == 'a' || chars[j] == 'e' || chars[j] == 'i' || chars[j] == 'o' || chars[j]\
    \ == 'u' {\n                                               ^~~\n             \
    \                                  \"a\"\n/tmp/tmplciwl_9t.swift:30:39: error:\
    \ single-quoted string literal found, use '\"'\n                             \
    \   if chars[j] == 'a' || chars[j] == 'e' || chars[j] == 'i' || chars[j] == 'o'\
    \ || chars[j] == 'u' {\n                                                     \
    \             ^~~\n                                                          \
    \        \"e\"\n/tmp/tmplciwl_9t.swift:30:58: error: single-quoted string literal\
    \ found, use '\"'\n                                if chars[j] == 'a' || chars[j]\
    \ == 'e' || chars[j] == 'i' || chars[j] == 'o' || chars[j] == 'u' {\n        \
    \                                           "
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var newString:\
    \ [String] = []\n    \n    // Write your code here.\n    let regex = NSRegularExpression.escapedPattern\n\
    \    \n    let regex2 = try! NSRegularExpression(pattern: regex, options: [])\n\
    \    \n    let array = regex2.matches(in: s, options: [], range: NSRange(0..<s.characters.count))\n\
    \    \n    for i in array {\n        \n        let char = s[i.range.upperBound].uppercased()\n\
    \        if char == \" \" {\n            \n            if newString.count == n\
    \ {\n                return newString\n            }\n            \n         \
    \   newString.append(s[i.range.upperBound..<i.range.lowerBound])\n           \
    \ \n        } else if char == \"H\" {\n            \n            if newString.count\
    \ <= n {\n                return newString\n            }\n            \n    \
    \        newString.append(s[i.range.upperBound..<i.range.lowerBound])\n      \
    \      \n        } else if char == \"I\" {\n            \n            if newString.count\
    \ <= n {\n                return newString\n            }\n            \n    \
    \        newString.append(s[i.range.upperBound..<i.range.lowerBound])\n      \
    \      \n        } else if char == \"N\" {\n            \n            if newString.count\
    \ <= n {\n                return newString\n            }\n            \n    \
    \        newString.append(s[i.range.upperBound..<i.range.lowerBound])\n      \
    \      \n        } else if char == \"A\" {\n            \n            if newString.count\
    \ <= n {\n                return newString\n            }\n            \n    \
    \        newString.append(s[i.range.upperBound..<i.range.lowerBound])\n      \
    \      \n        } else if char == \"R\" {\n            \n            if newString.count\
    \ <= n {\n                return newString\n            }\n            \n    \
    \        newString.append(s[i.range.upperBound..<i.range.lowerBound])\n      \
    \      \n        } else if char == \"V\" {\n            \n            if newString.count\
    \ <= n {\n                return newString\n            }\n            \n    \
    \        newString.append(s[i.range.upperBound..<i.range.lowerBound])\n      \
    \      \n        } else if char == \"E\" {\n            \n            if newString.count\
    \ <= n {\n                return newString\n            }\n            \n    \
    \        newString.append(s[i.range.upperBound..<i.range.lowerBound])\n      \
    \      \n        } else if char == \"D\" {\n            \n            if newString.count\
    \ <= n {\n                return newString\n            }\n            \n    \
    \        newString.append(s[i.range.upperBound..<i.range.lowerBound])\n      \
    \      \n        } else if char == \"O\" {\n            \n            if newString.count\
    \ <= n {\n                return newString\n            }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9prjvywp.swift:130:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp9prjvywp.swift:29:20:\
    \ note: to match this opening '{'\n    for i in array {\n                   ^\n\
    /tmp/tmp9prjvywp.swift:130:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp9prjvywp.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp9prjvywp.swift:23:17:\
    \ error: cannot find 'NSRegularExpression' in scope\n    let regex = NSRegularExpression.escapedPattern\n\
    \                ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp9prjvywp.swift:25:23: error: cannot\
    \ find 'NSRegularExpression' in scope\n    let regex2 = try! NSRegularExpression(pattern:\
    \ regex, options: [])\n                      ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp9prjvywp.swift:27:59:\
    \ error: cannot find 'NSRange' in scope\n    let array = regex2.matches(in: s,\
    \ options: [], range: NSRange(0..<s.characters.count))\n                     \
    \                                     ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var list = [\"Mary\"\
    , \"lamb\"]\n    let array = s.componentsSeparatedByString(\" \")\n    for i in\
    \ 0..<array.count {\n        if array[i].characters.count >= n {\n           \
    \ list.append(array[i])\n        }\n    }\n    return list\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpk9dw7wbt.swift:20:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let array = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n\n    switch n {\n    case 0:\n        return s.split(\"\
    \ \")\n    case 1:\n        return s.split(\"\")\n    case 2:\n        return\
    \ s.split(\"\").filter(String.init(describing: \\.lowercase).contains(\"a\")...)\n\
    \    case 3:\n        return s.split(\"\").filter(String.init(describing: \\.lowercase).contains(\"\
    e\")...)\n    case 4:\n        return s.split(\"\").filter(String.init(describing:\
    \ \\.lowercase).contains(\"i\")...)\n    case 5:\n        return s.split(\"\"\
    ).filter(String.init(describing: \\.lowercase).contains(\"o\")...)\n    case 6:\n\
    \        return s.split(\"\").filter(String.init(describing: \\.lowercase).contains(\"\
    u\")...)\n    case 7:\n        return s.split(\"\").filter(String.init(describing:\
    \ \\.lowercase).contains(\"y\")...)\n    case 8:\n        return s.split(\"\"\
    ).filter(String.init(describing: \\.lowercase).contains(\"h\")...)\n    case 9:\n\
    \        return s.split(\"\").filter(String.init(describing: \\.lowercase).contains(\"\
    l\")...)\n    case 10:\n        return s.split(\"\").filter(String.init(describing:\
    \ \\.lowercase).contains(\"a\")...)\n    case 11:\n        return s.split(\"\"\
    ).filter(String.init(describing: \\.lowercase).contains(\"e\")...)\n    case 12:\n\
    \        return s.split(\"\").filter(String.init(describing: \\.lowercase).contains(\"\
    i\")...)\n    case 13:\n        return s.split(\"\").filter(String.init(describing:\
    \ \\.lowercase).contains(\"o\")...)\n    case 14:\n        return s.split(\"\"\
    ).filter(String.init(describing: \\.lowercase).contains(\"u\")...)\n    case 15:\n\
    \        return s.split(\"\").filter(String.init(describing: \\.lowercase).contains(\"\
    y\")...)\n    case 16:\n        return s.split(\"\").filter(String.init(describing:\
    \ \\.lowercase).contains(\"h\")...)\n    case 17:\n        return s.split(\"\"\
    ).filter(String.init(describing: \\.lowercase).contains(\"l\")...)\n    case 18:\n\
    \        return s.split(\"\").filter(String.init(describing: \\.lowercase).contains(\"\
    a\")...)\n    case 19:\n        return s.split(\"\").filter(String.init(describing:\
    \ \\.lowercase).contains(\"e\")...)\n    case 20:\n        return s.split(\"\"\
    ).filter(String.init(describing: \\.lowercase).contains(\"i\")...)\n    case 21:\n\
    \        return s.split(\"\").filter(String.init(describing: \\.lowercase).contains(\"\
    o\")...)\n    case 22:\n        return s.split(\"\").filter(String.init(describing:\
    \ \\.lowercase).contains(\"u\")...)\n    case 23:\n        return s.split(\"\"\
    ).filter(String.init(describing: \\.lowercase).contains(\"y\")...)\n    case 24:\n\
    \        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp223b7fsb.swift:95:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp223b7fsb.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp223b7fsb.swift:25:18:\
    \ error: no exact matches in call to instance method 'split'\n        return s.split(\"\
    \ \")\n                 ^\n/tmp/tmp223b7fsb.swift:25:18: note: found candidate\
    \ with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]' (aka\
    \ '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n        return s.split(\"\
    \ \")\n                 ^\n/tmp/tmp223b7fsb.swift:25:18: note: found candidate\
    \ with type '(String.Element, Int, Bool) -> [String.SubSequence]' (aka '(Character,\
    \ Int, Bool) -> Array<Substring>')\n        return s.split(\" \")\n          \
    \       ^\n/tmp/tmp223b7fsb.swift:25:18: error: no 'split' candidates produce\
    \ the expected contextual result type '[String]'\n        return s.split(\" \"\
    )\n                 ^\nSwift.Sequence:2:40: note: 'split(separator:maxSplits:omittingEmptySubsequences:)'\
    \ produces '[ArraySlice<String.Element>]' (aka 'Array<ArraySlice<Character>>'),\
    \ not the expected contextual result type '[String]'\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: 'split(separator:maxSplits:omittingEmptySubsequences:)'\
    \ produces '[String.SubSequence]' (aka 'Array<Substring>'), not the expected contextual\
    \ result type '[String]'\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n/tmp/tmp223b7fsb.swift:27:24:\
    \ error: missing argument label 'separator:' in call\n        return s.split(\"\
    \")\n    "
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // TODO: replace with\
    \ solution that uses \"all\" function from swift standard library\n    \n    let\
    \ words = [String]()\n    \n    if s == \"\" {\n        return words\n    }\n\
    \    \n    let letters = s.characters\n    \n    let re = try! NSRegularExpression(pattern:\
    \ \".*([cC]onsonant).*\")\n    let matches = re.matches(in: s, range: NSRange(s.startIndex...,\
    \ in: s))\n    \n    for match in matches {\n        let matchString = s[Range(match.range(at:\
    \ 1), in: s)!]\n        words.append(matchString)\n    }\n    \n    if words.count\
    \ <= n {\n        return words\n    }\n    \n    let remaining = n - words.count\n\
    \    \n    if remaining < words.count {\n        for _ in 0..<remaining {\n  \
    \          words.append(\"\")\n        }\n    }\n    \n    return words\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmptkgyvlnm.swift:27:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    let letters = s.characters\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptkgyvlnm.swift:29:19:\
    \ error: cannot find 'NSRegularExpression' in scope\n    let re = try! NSRegularExpression(pattern:\
    \ \".*([cC]onsonant).*\")\n                  ^~~~~~~~~~~~~~~~~~~\n/tmp/tmptkgyvlnm.swift:30:44:\
    \ error: cannot find 'NSRange' in scope\n    let matches = re.matches(in: s, range:\
    \ NSRange(s.startIndex..., in: s))\n                                         \
    \  ^~~~~~~\n/tmp/tmptkgyvlnm.swift:45:19: error: cannot use mutating member on\
    \ immutable value: 'words' is a 'let' constant\n            words.append(\"\"\
    )\n            ~~~~~ ^\n/tmp/tmptkgyvlnm.swift:21:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let words = [String]()\n    ^~~\n    var\n/tmp/tmptkgyvlnm.swift:33:34:\
    \ error: initializer expects a single parameter of type '(lower: Bound, upper:\
    \ Bound)' [with Bound = String.Index]\n        let matchString = s[Range(match.range(at:\
    \ 1), in: s)!]\n                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                  (                        )\n/tmp/tmptkgyvlnm.swift:33:41:\
    \ error: cannot convert value of type '(_, in: String)' to expected argument type\
    \ '(lower: String.Index, upper: String.Index)'\n        let matchString = s[Range(match.range(at:\
    \ 1), in: s)!]\n                                        ^\n/tmp/tmptkgyvlnm.swift:33:61:\
    \ error: cannot force unwrap value of non-optional type 'Range<_>'\n        let\
    \ matchString = s[Range(match.range(at: 1), in: s)!]\n                       \
    \     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n                                    \
    \                        \n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tswitch {\n\tcase n <\
    \ 1:\n\t\treturn []\n\tcase n == 1 {\n\t\treturn s.split(separator: \" \")\n\t\
    }\n\treturn s.split(separator: \" \")\n\t\t.filter { $0.contains(Character(Character($0).asciiValue\
    \ + n)) }\n\t\t.map { $0.split(separator: \" \") }\n\t\t.map { $0[0 ..< n] }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd3z0p8za.swift:19:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpd3z0p8za.swift:22:14: error: expected\
    \ ':' after 'case'\n        case n == 1 {\n                    ^\n/tmp/tmpd3z0p8za.swift:50:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpd3z0p8za.swift:18:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpd3z0p8za.swift:22:14:\
    \ error: closure expression is unused\n        case n == 1 {\n               \
    \     ^\n/tmp/tmpd3z0p8za.swift:22:14: note: did you mean to use a 'do' statement?\n\
    \        case n == 1 {\n                    ^\n                    do \n/tmp/tmpd3z0p8za.swift:26:25:\
    \ error: no exact matches in call to initializer \n                .filter { $0.contains(Character(Character($0).asciiValue\
    \ + n)) }\n                                      ^\n/tmp/tmpd3z0p8za.swift:26:25:\
    \ note: found candidate with type '(Unicode.Scalar) -> Character'\n          \
    \      .filter { $0.contains(Character(Character($0).asciiValue + n)) }\n    \
    \                                  ^\n/tmp/tmpd3z0p8za.swift:26:25: note: found\
    \ candidate with type '(String) -> Character'\n                .filter { $0.contains(Character(Character($0).asciiValue\
    \ + n)) }\n                                      ^\n/tmp/tmpd3z0p8za.swift:26:49:\
    \ error: cannot convert value of type 'UInt8?' to expected argument type 'Int'\n\
    \                .filter { $0.contains(Character(Character($0).asciiValue + n))\
    \ }\n                                                              ^\n/tmp/tmpd3z0p8za.swift:26:35:\
    \ error: no exact matches in call to initializer \n                .filter { $0.contains(Character(Character($0).asciiValue\
    \ + n)) }\n                                                ^\n/tmp/tmpd3z0p8za.swift:26:35:\
    \ note: found candidate with type '(Unicode.Scalar) -> Character'\n          \
    \      .filte"
  stdout: ''
  timestamp: 1660014604
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmp71zsovev.swift:20:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var arr: [String] =\
    \ []\n    var index = s.startIndex\n    var letter: Character = \"a\"\n    var\
    \ flag = false\n    \n    for _ in 0 ..< n {\n        if flag {\n            arr.append(String(s[index]))\n\
    \            flag = false\n        }\n        \n        if letter == \" \" {\n\
    \            arr.append(String(s[index]))\n            index += 1\n          \
    \  letter = \"a\"\n        } else if letter == \"a\" {\n            if s[index]\
    \ != \"a\" {\n                arr.append(String(s[index]))\n                index\
    \ += 1\n                letter = \"a\"\n            } else {\n               \
    \ letter = \" \"\n                flag = true\n            }\n        } else {\n\
    \            if s[index] == letter {\n                letter = \" \"\n       \
    \         flag = true\n            } else {\n                arr.append(String(s[index]))\n\
    \                index += 1\n                letter = \"a\"\n            }\n \
    \       }\n    }\n    \n    arr.append(String(s[index..<s.endIndex]))\n    return\
    \ arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwl22v613.swift:32:19: error: binary operator '+=' cannot be applied\
    \ to operands of type 'String.Index' and 'Int'\n            index += 1\n     \
    \       ~~~~~ ^  ~\n/tmp/tmpwl22v613.swift:37:23: error: binary operator '+='\
    \ cannot be applied to operands of type 'String.Index' and 'Int'\n           \
    \     index += 1\n                ~~~~~ ^  ~\n/tmp/tmpwl22v613.swift:49:23: error:\
    \ binary operator '+=' cannot be applied to operands of type 'String.Index' and\
    \ 'Int'\n                index += 1\n                ~~~~~ ^  ~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    let count = [String:\
    \ Int]()\n    let result = s.characters.split(separator: \" \").map(String.init)\n\
    \        .filter({ $0.isLetter && !count[$0] })\n        .filter { (word: String)\
    \ -> Bool in\n            guard let count = count[word] else { return false }\n\
    \            count[word] = count + 1\n            return count == n\n        }\n\
    \    \n    if s.isEmpty {\n        return []\n    } else {\n        return result\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy83qeou0.swift:22:40: error: optional type 'Int?' cannot be used\
    \ as a boolean; test for '== nil' instead\n        .filter({ $0.isLetter && !count[$0]\
    \ })\n                                 ~     ^\n                             \
    \     (         == nil)\n/tmp/tmpy83qeou0.swift:22:22: error: value of type 'String'\
    \ has no member 'isLetter'\n        .filter({ $0.isLetter && !count[$0] })\n \
    \                 ~~ ^~~~~~~~\n/tmp/tmpy83qeou0.swift:25:18: error: value of type\
    \ 'Int' has no subscripts\n            count[word] = count + 1\n            ~~~~~^\n"
  stdout: ''
  timestamp: 1660014609
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // your code here\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmplktfbzqi.swift:20:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    if s.isEmpty\
    \ {\n        return []\n    }\n    let arr = Array(s.characters)\n    \n    let\
    \ stack = Array(0..<n)\n    \n    var result = stack\n    \n    while !stack.isEmpty\
    \ {\n        \n        let head = stack.removeLast()\n        \n        var found\
    \ = false\n        \n        for i in 0..<arr.count {\n            \n        \
    \    let item = arr[i]\n            \n            if item == head {\n        \
    \        found = true\n                stack.insert(item, at: i)\n           \
    \     break\n            }\n            \n            if item.isLetterOrDigit()\
    \ {\n                continue\n            }\n            \n            if found\
    \ {\n                break\n            }\n        }\n        \n        if !found\
    \ {\n            stack.insert(head, at: 0)\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmph5qtk9d3.swift:23:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    let arr = Array(s.characters)\n                   \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmph5qtk9d3.swift:31:26:\
    \ error: cannot use mutating member on immutable value: 'stack' is a 'let' constant\n\
    \        let head = stack.removeLast()\n                   ~~~~~ ^\n/tmp/tmph5qtk9d3.swift:25:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let stack = Array(0..<n)\n\
    \    ^~~\n    var\n/tmp/tmph5qtk9d3.swift:41:23: error: no exact matches in call\
    \ to instance method 'insert'\n                stack.insert(item, at: i)\n   \
    \                   ^\n/tmp/tmph5qtk9d3.swift:41:23: note: found candidate with\
    \ type '(__owned Int, Int) -> ()'\n                stack.insert(item, at: i)\n\
    \                      ^\n/tmp/tmph5qtk9d3.swift:45:21: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'isLetterOrDigit'\n            if item.isLetterOrDigit()\
    \ {\n               ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmph5qtk9d3.swift:55:19: error:\
    \ no exact matches in call to instance method 'insert'\n            stack.insert(head,\
    \ at: 0)\n                  ^\n/tmp/tmph5qtk9d3.swift:55:19: note: found candidate\
    \ with type '(__owned Int, Int) -> ()'\n            stack.insert(head, at: 0)\n\
    \                  ^\n/tmp/tmph5qtk9d3.swift:59:12: error: cannot convert return\
    \ expression of type '[Int]' to return type '[String]'\n    return result\n  \
    \         ^\n/tmp/tmph5qtk9d3.swift:59:12: note: arguments to generic parameter\
    \ 'Element' ('Int' and 'String') are expected to be equal\n    return result\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var ans = [String]()\n\
    \n    for c in s.characters.reverse() {\n        // Check if the current character\
    \ is n consonants\n        if c == \" \" {\n            // The current character\
    \ is a space.  Let's see if it matches.\n            // We have to keep track\
    \ of words as we match them to the end\n            // of the string, since we\
    \ don't want to add words from the last\n            // space onto the output\
    \ array.\n            ans.append(\"\")\n        }\n        else if c != \"a\"\
    \ && c != \"e\" && c != \"i\" && c != \"o\" && c != \"u\" && c != \"A\" && c !=\
    \ \"E\" && c != \"I\" && c != \"O\" && c != \"U\" && c != \"a\" && c != \"e\"\
    \ && c != \"i\" && c != \"o\" && c != \"u\" {\n            // The current character\
    \ is not n consonants\n            if ans[ans.count-1] == \"\" {\n           \
    \     ans[ans.count-1] = String(Character(c))\n            }\n            else\
    \ {\n                ans[ans.count-1] += String(Character(c))\n            }\n\
    \        }\n    }\n    return ans.reverse()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3qnq09f7.swift:21:27: error: value of type 'String' has no member\
    \ 'reverse'\n    for c in s.characters.reverse() {\n             ~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmp3qnq09f7.swift:40:16: error: cannot convert return expression\
    \ of type '()' to return type '[String]'\n    return ans.reverse()\n         \
    \  ~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n\tlet letters = count_letters(s)\n\
    \t\n\tif letters < n {\n\t\treturn []\n\t}\n\t\n\tlet spaces = count_spaces(s)\n\
    \t\n\tlet consonants = [\n\t\t[\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\"\
    , \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"y\"\
    , \"z\", \"\xE4\", \"\xF6\", \"\xFC\", \"\xDF\"],\n\t\t[\"\xC4\", \"\xD6\", \"\
    \xDC\", \"\xDF\"]\n\t]\n\t\n\tlet indexes = [\n\t\t[0, 1],\n\t\t[0, 2],\n\t\t\
    [0, 3],\n\t\t[0, 4],\n\t\t[0, 5],\n\t\t[0, 6],\n\t\t[0, 7],\n\t\t[0, 8],\n\t\t\
    [0, 9],\n\t\t[0, 10],\n\t\t[0, 11],\n\t\t[0, 12],\n\t\t[0, 13],\n\t\t[0, 14],\n\
    \t\t[0, 15],\n\t\t[0, 16],\n\t\t[0, 17],\n\t\t[0, 18],\n\t\t[0, 19],\n\t\t[0,\
    \ 20],\n\t\t[0, 21],\n\t\t[0, 22],\n\t\t[0, 23],\n\t\t[0, 24],\n\t\t[0, 25],\n\
    \t\t[0, 26],\n\t\t[0, 27],\n\t\t[0, 28],\n\t\t[0, 29],\n\t\t[0, 30],\n\t\t[0,\
    \ 31],\n\t\t[0, 32],\n\t\t[0, 33],\n\t\t[0, 34],\n\t\t[0, 35],\n\t\t[0, 36],\n\
    \t\t[0, 37],\n\t\t[0, 38],\n\t\t[0, 39],\n\t\t[0, 40],\n\t\t[0, 41],\n\t\t[0,\
    \ 42],\n\t\t[0, 43],\n\t\t[0, 44],\n\t\t[0, 45],\n\t\t[0, 46],\n\t\t[0, 47],\n\
    \t\t[0, 48],\n\t\t[0, 49],\n\t\t[0, 50],\n\t\t[0, 51],\n\t\t[0, 52],\n\t\t[0,\
    \ 53],\n\t\t[0, 54],\n\t\t[0, 55],\n\t\t[0, 56],\n\t\t[0, 57],\n\t\t[0, 58],\n\
    \t\t[0, 59],\n\t\t[0, 60],\n\t\t[0, 61],\n\t\t[0, 62],\n\t\t[0, 63],\n\t\t[0,\
    \ 64],\n\t\t[0, 65],\n\t\t[0, 66],\n\t\t[0, 67],\n\t\t[0, 68],\n\t\t[0, 69],\n\
    \t\t[0, 70],\n\t\t[0, 71],\n\t\t[0, 72],\n\t\t[0, 73],\n\t\t[0, 74],\n\t\t[0,\
    \ 75],\n\t\t[0, 76],\n\t\t[0, 77],\n\t\t[0, 78],\n\t\t[0, 79],\n\t\t[0, 80],\n\
    \t\t[0, 81],\n\t\t[0, 82\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxlorucyj.swift:115:9: error: expected ']' in container literal\
    \ expression\n                [0, 82\n                      ^\n/tmp/tmpxlorucyj.swift:115:3:\
    \ note: to match this opening '['\n                [0, 82\n                ^\n\
    /tmp/tmpxlorucyj.swift:20:16: error: cannot find 'count_letters' in scope\n  \
    \      let letters = count_letters(s)\n                      ^~~~~~~~~~~~~\n/tmp/tmpxlorucyj.swift:26:15:\
    \ error: cannot find 'count_spaces' in scope\n        let spaces = count_spaces(s)\n\
    \                     ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let chars = Array(s)\n\
    \    if s.isEmpty { return [] }\n    var words: [String] = []\n    var c = 0\n\
    \    while c < s.count {\n        if chars[c] == \" \" {\n            words.append(chars[c..<s.endIndex])\n\
    \        }\n        c += 1\n    }\n    return words\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv5tap98o.swift:25:19: error: no exact matches in call to instance\
    \ method 'append'\n            words.append(chars[c..<s.endIndex])\n         \
    \         ^\n/tmp/tmpv5tap98o.swift:25:19: note: candidate has partially matching\
    \ parameter list (__owned String)\n            words.append(chars[c..<s.endIndex])\n\
    \                  ^\n/tmp/tmpv5tap98o.swift:25:19: note: candidate has partially\
    \ matching parameter list (__owned String)\n            words.append(chars[c..<s.endIndex])\n\
    \                  ^\n/tmp/tmpv5tap98o.swift:25:19: note: found candidate with\
    \ type '(__owned ArraySlice<String.Element>) -> ()' (aka '(__owned ArraySlice<Character>)\
    \ -> ()')\n            words.append(chars[c..<s.endIndex])\n                 \
    \ ^\n/tmp/tmpv5tap98o.swift:25:38: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            words.append(chars[c..<s.endIndex])\n\
    \                                     ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = s.components(separatedBy:\
    \ \" \")\n    \n    if s.isEmpty {\n        return []\n    }\n    \n    result.removeFirst()\n\
    \    \n    return result.filter({ $0.characters.count >= n }).sorted().flatMap({\
    \ $0.characters.prefix(n) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpx3gkciok.swift:19:20: error: value of type 'String' has no member\
    \ 'components'\n    var result = s.components(separatedBy: \" \")\n          \
    \       ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar result : [String]\
    \ = []\n\tfor word in s.split(\" \") {\n\t\tvar count : Int = 0\n\t\tfor letter\
    \ in word.lowercaseString.characters {\n\t\t\tif letter == \"a\" || letter ==\
    \ \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" {\n\t\t\t\tcount\
    \ += 1\n\t\t\t}\n\t\t}\n\t\tif count == n {\n\t\t\tresult = append(result, word)\n\
    \t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb_bacxo_.swift:20:16: error: no exact matches in call to instance\
    \ method 'split'\n        for word in s.split(\" \") {\n                     \
    \ ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    return []\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpzs66n6ss/tmpzs66n6ss.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5be131ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5be1011b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5be1011988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5be10107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzs66n6ss                        0x000055ef35cea4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b5be1506460 __libc_start_main +
    245

    6    tmpzs66n6ss                        0x000055ef35cea0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return words\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5f_tfcr1.swift:22:12: error: cannot find 'words' in scope\n   \
    \ return words\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let mut result = Array<String>()\n\
    \    for letter in s.characters {\n        if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' ||\n            letter == 'A'\
    \ || letter == 'E' || letter == 'I' || letter == 'O' || letter == 'U' ||\n   \
    \         letter == '0' {\n            \n        }\n    }\n    \n    \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz_ze02b7.swift:19:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut result =\
    \ Array<String>()\n            ^\n/tmp/tmpz_ze02b7.swift:19:13: note: join the\
    \ identifiers together\n    let mut result = Array<String>()\n        ~~~~^~~~~~\n\
    \        mutresult\n/tmp/tmpz_ze02b7.swift:19:13: note: join the identifiers together\
    \ with camel-case\n    let mut result = Array<String>()\n        ~~~~^~~~~~\n\
    \        mutResult\n/tmp/tmpz_ze02b7.swift:21:22: error: single-quoted string\
    \ literal found, use '\"'\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' ||\n                     ^~~\n    \
    \                 \"a\"\n/tmp/tmpz_ze02b7.swift:21:39: error: single-quoted string\
    \ literal found, use '\"'\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' ||\n                              \
    \        ^~~\n                                      \"e\"\n/tmp/tmpz_ze02b7.swift:21:56:\
    \ error: single-quoted string literal found, use '\"'\n        if letter == 'a'\
    \ || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' ||\n   \
    \                                                    ^~~\n                   \
    \                                    \"i\"\n/tmp/tmpz_ze02b7.swift:21:73: error:\
    \ single-quoted string literal found, use '\"'\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' ||\n             \
    \                                                           ^~~\n            \
    \                                                            \"o\"\n/tmp/tmpz_ze02b7.swift:21:90:\
    \ error: single-quoted string literal found, use '\"'\n        if letter == 'a'\
    \ || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' ||\n   \
    \                                                                            \
    \          ^~~\n                                                             \
    \                            \"u\"\n/tmp/tmpz_ze02b7.swift:22:23: error: single-quoted\
    \ string literal found, use '\"'\n            let"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// Your code here\n\t\
    return s.componentsSeparatedByString(\" \")\n\t\t.filter { $0.rangeOfCharacter(from:\
    \ NSCharacterSet.letters) == nil }\n\t\t.filter { $0.rangeOfCharacter(from: NSCharacterSet.whitespaceCharacters)\
    \ != nil }\n\t\t.filter { $0.rangeOfCharacter(from: NSCharacterSet.consonants)\
    \ != nil }\n\t\t.map { $0.lowercaseString.substring(with: NSRange(location: 0,\
    \ length: n)) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi269f_bp.swift:21:39: error: cannot find 'NSCharacterSet' in scope\n\
    \                .filter { $0.rangeOfCharacter(from: NSCharacterSet.letters) ==\
    \ nil }\n                                                    ^~~~~~~~~~~~~~\n\
    /tmp/tmpi269f_bp.swift:22:39: error: cannot find 'NSCharacterSet' in scope\n \
    \               .filter { $0.rangeOfCharacter(from: NSCharacterSet.whitespaceCharacters)\
    \ != nil }\n                                                    ^~~~~~~~~~~~~~\n\
    /tmp/tmpi269f_bp.swift:23:39: error: cannot find 'NSCharacterSet' in scope\n \
    \               .filter { $0.rangeOfCharacter(from: NSCharacterSet.consonants)\
    \ != nil }\n                                                    ^~~~~~~~~~~~~~\n\
    /tmp/tmpi269f_bp.swift:24:45: error: cannot find 'NSRange' in scope\n        \
    \        .map { $0.lowercaseString.substring(with: NSRange(location: 0, length:\
    \ n)) }\n                                                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let splits = s.split(separator:\
    \ \" \")\n    var res = [:]\n    for i in splits.indices {\n        for j in (0..<n).reverse()\
    \ {\n            let item = splits[i][j..<n+1]\n            if item.characters.count\
    \ == 0 {\n                break\n            } else {\n                if let\
    \ _ = res[item] {\n                    break\n                } else {\n     \
    \               res[item] = true\n                }\n            }\n        }\n\
    \    }\n    return res.keys.arrayValue.map {\n        $0.split(separator: \" \"\
    ).joined(separator: \" \")\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg7zgnfsp.swift:20:15: error: empty collection literal requires\
    \ an explicit type\n    var res = [:]\n              ^~~\n/tmp/tmpg7zgnfsp.swift:22:26:\
    \ error: value of type 'Range<Int>' has no member 'reverse'\n        for j in\
    \ (0..<n).reverse() {\n                 ~~~~~~~ ^~~~~~~\n/tmp/tmpg7zgnfsp.swift:35:21:\
    \ error: value of type 'Dictionary<AnyHashable, Any>.Keys' has no member 'arrayValue'\n\
    \    return res.keys.arrayValue.map {\n           ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpg7zgnfsp.swift:23:33:\
    \ error: subscript 'subscript(_:)' requires the types 'Substring.Index' (aka 'String.Index')\
    \ and 'Int' be equivalent\n            let item = splits[i][j..<n+1]\n       \
    \                         ^\nSwift.Collection:2:23: note: where 'Self.Index' =\
    \ 'Substring.Index' (aka 'String.Index'), 'R.Bound' = 'Int'\n    @inlinable public\
    \ subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var r: [String] = []\n\
    \    \n    for s in s {\n        if s == \"\" {\n            return r\n      \
    \  }\n        \n        for _ in 0..<n-1 {\n            if s[s.startIndex.advancedBy(1)]\
    \ != \" \" {\n                return r\n            }\n        }\n        \n \
    \       r.append(s)\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjyu2w9pj.swift:22:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if s == \"\" {\n     \
    \      ~ ^  ~~\n/tmp/tmpjyu2w9pj.swift:22:14: note: overloads for '==' exist with\
    \ these partially matching parameter lists: (Character, Character), (String, String)\n\
    \        if s == \"\" {\n             ^\n/tmp/tmpjyu2w9pj.swift:27:17: error:\
    \ value of type 'Character' has no subscripts\n            if s[s.startIndex.advancedBy(1)]\
    \ != \" \" {\n               ~^\n/tmp/tmpjyu2w9pj.swift:27:20: error: value of\
    \ type 'Character' has no member 'startIndex'\n            if s[s.startIndex.advancedBy(1)]\
    \ != \" \" {\n                 ~ ^~~~~~~~~~\n/tmp/tmpjyu2w9pj.swift:32:18: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        r.append(s)\n                 ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\treturn select_words_recur(s,\
    \ n, \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpey38wur8.swift:19:9: error: cannot find 'select_words_recur' in\
    \ scope\n        return select_words_recur(s, n, \"\")\n               ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n    var letters = s.characters\n    \n    var count =\
    \ 0\n    var res = NSMutableArray()\n    for i in 0..<letters.count {\n      \
    \  var letter = letters[i]\n        \n        if letter == \"a\" {\n         \
    \   continue\n        }\n        \n        if letter == \"e\" {\n            count\
    \ += 1\n        }\n        \n        if letter == \"i\" {\n            count +=\
    \ 1\n        }\n        \n        if letter == \"o\" {\n            count += 1\n\
    \        }\n        \n        if letter == \"u\" {\n            count += 1\n \
    \       }\n        \n        if letter == \" \" {\n            count += 1\n  \
    \      }\n        \n        if count == n {\n            res.add(s.substringWithRange(NSMakeRange(i+1,\
    \ 1)))\n            count = 0\n        }\n    }\n    \n    return res.toArray(as:\
    \ [String])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpntynwqyu.swift:22:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    var letters = s.characters\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpntynwqyu.swift:25:15:\
    \ error: cannot find 'NSMutableArray' in scope\n    var res = NSMutableArray()\n\
    \              ^~~~~~~~~~~~~~\n/tmp/tmpntynwqyu.swift:27:22: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        var letter = letters[i]\n                     ^~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpntynwqyu.swift:54:42:\
    \ error: cannot find 'NSMakeRange' in scope\n            res.add(s.substringWithRange(NSMakeRange(i+1,\
    \ 1)))\n                                         ^~~~~~~~~~~\n/tmp/tmpntynwqyu.swift:54:23:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \   res.add(s.substringWithRange(NSMakeRange(i+1, 1)))\n                    ~\
    \ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    let alphabet\
    \ = [\n        \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"\
    K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"\
    X\",\"Y\",\"Z\",\n        \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\"\
    ,\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\"\
    ,\"w\",\"x\",\"y\",\"z\",\n        \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"\
    7\",\"8\",\"9\",\n        \"_\",\"-\",\".\",\"=\",\"/\",\".\",\",\",\"-\",\".\"\
    ,\"'\",\"\\\"\"\n    ]\n    \n    var res = []\n    \n    for ch in s {\n    \
    \    if ch in alphabet {\n            let index = alphabet.index(of: ch)\n   \
    \         let substr = str[..<index]\n            let newStr = substr.flatMap\
    \ { $0 }\n            if newStr.count == n {\n                res.append (substr)\n\
    \            }\n        }\n    }\n    \n    if res.count == 0 {\n        res =\
    \ []\n    }\n    \n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpu_a31f9_.swift:30:15: error: expected '{' after 'if' condition\n\
    \        if ch in alphabet {\n              ^\n/tmp/tmpu_a31f9_.swift:27:15: error:\
    \ empty collection literal requires an explicit type\n    var res = []\n     \
    \         ^~\n/tmp/tmpu_a31f9_.swift:30:12: error: cannot convert value of type\
    \ 'Character' to expected condition type 'Bool'\n        if ch in alphabet {\n\
    \           ^~\n/tmp/tmpu_a31f9_.swift:31:44: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            let index = alphabet.index(of:\
    \ ch)\n                                           ^\n/tmp/tmpu_a31f9_.swift:32:26:\
    \ error: cannot find 'str' in scope\n            let substr = str[..<index]\n\
    \                         ^~~\n/tmp/tmpu_a31f9_.swift:44:12: error: cannot convert\
    \ return expression of type '[Any]' to return type '[String]'\n    return res\n\
    \           ^\n/tmp/tmpu_a31f9_.swift:44:12: note: arguments to generic parameter\
    \ 'Element' ('Any' and 'String') are expected to be equal\n    return res\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\t// TODO: write your code\
    \ in geeksforgeeks.org/select-words-in-string-containing-exactly-\n\t// n-consonants-in-order-these-words-appear-s-in-string-s-if-s-is-empty\n\
    \tvar res =  make([][String], s.count)\n\tvar i = 0\n\tvar index = s\n\tfor i\
    \ < s.count {\n\t\tvar count = 0\n\t\tfor index < s {\n\t\t\tif s[index] == \"\
    \ \" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcount++\n\t\t\tindex++\n\t\t\tif count >=\
    \ n {\n\t\t\t\tres[i] = make([][String], count)\n\t\t\t\tindex++\n\t\t\t\tcount\
    \ = 0\n\t\t\t}\n\t\t}\n\t\tres[i] = make([][String], count)\n\t\ti++\n\t}\n\t\
    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy52x0z5i.swift:24:8: error: expected 'in' after for-each pattern\n\
    \        for i < s.count {\n              ^\n/tmp/tmpy52x0z5i.swift:24:8: error:\
    \ unary operator cannot be separated from its operand\n        for i < s.count\
    \ {\n              ^~\n               \n/tmp/tmpy52x0z5i.swift:26:13: error: expected\
    \ 'in' after for-each pattern\n                for index < s {\n             \
    \             ^\n/tmp/tmpy52x0z5i.swift:26:13: error: unary operator cannot be\
    \ separated from its operand\n                for index < s {\n              \
    \            ^~\n                           \n/tmp/tmpy52x0z5i.swift:21:13: error:\
    \ cannot find 'make' in scope\n        var res =  make([][String], s.count)\n\
    \                   ^~~~\n/tmp/tmpy52x0z5i.swift:21:20: error: no exact matches\
    \ in call to subscript \n        var res =  make([][String], s.count)\n      \
    \                    ^\n/tmp/tmpy52x0z5i.swift:21:20: note: found candidate with\
    \ type '(Int) -> Any'\n        var res =  make([][String], s.count)\n        \
    \                  ^\n/tmp/tmpy52x0z5i.swift:21:20: note: found candidate with\
    \ type '(Range<Int>) -> ArraySlice<Any>'\n        var res =  make([][String],\
    \ s.count)\n                          ^\n/tmp/tmpy52x0z5i.swift:21:20: note: found\
    \ candidate with type '(String.Type) -> ArraySlice<Any>'\n        var res =  make([][String],\
    \ s.count)\n                          ^\n/tmp/tmpy52x0z5i.swift:21:20: note: found\
    \ candidate with type '((UnboundedRange_) -> ()) -> ArraySlice<Any>'\n       \
    \ var res =  make([][String], s.count)\n                          ^\n/tmp/tmpy52x0z5i.swift:24:8:\
    \ error: '<' is not a prefix unary operator\n        for i < s.count {\n     \
    \         ^\n/tmp/tmpy52x0z5i.swift:26:13: error: '<' is not a prefix unary operator\n\
    \                for index < s {\n                          ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n\n    guard let vowels = Set([\"a\", \"e\", \"i\", \"\
    o\", \"u\"]) else {\n        print(\"vowels cannot initalized!\")\n        return\
    \ []\n    }\n\n    let consonants = Set(s.characters.filter({ $0 != \"a\" && $0\
    \ != \"e\" && $0 != \"i\" && $0 != \"o\" && $0 != \"u\" }))\n\n    let possibleWords\
    \ = consonants.symmetrical.filter{ possibleWord in\n        vowels.contains(possibleWord[0])\n\
    \    }\n\n    return possibleWords.filter{ word in\n        word.count == n\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpx5n1atru.swift:23:11: error: initializer for conditional binding\
    \ must have Optional type, not 'Set<String>'\n    guard let vowels = Set([\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]) else {\n          ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpx5n1atru.swift:28:28: error: 'characters' is unavailable: Please use String\
    \ directly\n    let consonants = Set(s.characters.filter({ $0 != \"a\" && $0 !=\
    \ \"e\" && $0 != \"i\" && $0 != \"o\" && $0 != \"u\" }))\n                   \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpx5n1atru.swift:30:36:\
    \ error: value of type 'Set<String.Element>' (aka 'Set<Character>') has no member\
    \ 'symmetrical'\n    let possibleWords = consonants.symmetrical.filter{ possibleWord\
    \ in\n                        ~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\treturn []\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp8j9p5rhv/tmp8j9p5rhv.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b5152dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b51224b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b51224988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b512237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8j9p5rhv                        0x000055d81af834c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b4b51719460 __libc_start_main +
    245

    6    tmp8j9p5rhv                        0x000055d81af830c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014283
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    return []\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpzs66n6ss/tmpzs66n6ss.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5be131ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5be1011b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5be1011988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5be10107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzs66n6ss                        0x000055ef35cea4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b5be1506460 __libc_start_main +
    245

    6    tmpzs66n6ss                        0x000055ef35cea0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014602
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var ans = [String]()\n\
    \n    // Your code here\n\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp6bg86e8t/tmp6bg86e8t.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2219a69c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2219760b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2219760988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b221975f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6bg86e8t                        0x0000558d2cfb5514 <unavailable> + 5396

    5    libc.so.6                          0x00002b2219c55460 __libc_start_main +
    245

    6    tmp6bg86e8t                        0x0000558d2cfb5119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words = s.characters.split(\"\
    \ \").map{$0.lowercased()}\n    \n    for index in 0..<words.count{\n        if\
    \ words.contains(String(repeatElement(\"a\" , count-index))){\n            break\n\
    \        }\n    }\n    let index = count-index\n    return words[index..<words.count]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj3voc_n8.swift:19:36: error: missing argument label 'separator:'\
    \ in call\n    var words = s.characters.split(\" \").map{$0.lowercased()}\n  \
    \                                 ^\n                                   separator:\
    \ \n/tmp/tmpj3voc_n8.swift:26:17: error: cannot find 'count' in scope\n    let\
    \ index = count-index\n                ^~~~~\n/tmp/tmpj3voc_n8.swift:26:23: error:\
    \ use of local variable 'index' before its declaration\n    let index = count-index\n\
    \                      ^\n/tmp/tmpj3voc_n8.swift:26:9: note: 'index' declared\
    \ here\n    let index = count-index\n        ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for c in s.characters {\n        if n <= 0 || isConsonant(c) {\n        \
    \    continue\n        }\n        if n-- == 0 {\n            result.append(String(c))\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjekc508v.swift:20:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjekc508v.swift:21:22:\
    \ error: cannot find 'isConsonant' in scope\n        if n <= 0 || isConsonant(c)\
    \ {\n                     ^~~~~~~~~~~\n/tmp/tmpjekc508v.swift:24:13: error: cannot\
    \ find operator '--' in scope; did you mean '-= 1'?\n        if n-- == 0 {\n \
    \           ^~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    let counts =\
    \ s.split_whitespace().map(String.count)\n    let indices = counts.indices { (i,\
    \ _) -> Bool in\n        return counts[i] == n\n    }\n    return indices.map\
    \ { (i) -> String in\n        return String(s[indices[i]..<s.endIndex])\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp88l9f8np.swift:20:50: error: no exact matches in reference to property\
    \ 'count'\n    let counts = s.split_whitespace().map(String.count)\n         \
    \                                        ^\n/tmp/tmp88l9f8np.swift:20:50: note:\
    \ found candidate with type 'Int'\n    let counts = s.split_whitespace().map(String.count)\n\
    \                                                 ^\n/tmp/tmp88l9f8np.swift:20:20:\
    \ error: value of type 'String' has no member 'split_whitespace'\n    let counts\
    \ = s.split_whitespace().map(String.count)\n                 ~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var words: [String]\
    \ = []\n    if s.isEmpty {\n        return words\n    }\n    var current: String\
    \ = s.substringToIndex(s.startIndex.advancedBy(1))\n    for _ in 0 ..< n {\n \
    \       if current.isEmpty {\n            break\n        }\n        current =\
    \ current.substringToIndex(current.startIndex.advancedBy(-1))\n        if current.characters.count\
    \ == 1 {\n            words.append(current)\n        }\n    }\n    return words\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqcjsab5m.swift:23:29: error: value of type 'String' has no member\
    \ 'substringToIndex'\n    var current: String = s.substringToIndex(s.startIndex.advancedBy(1))\n\
    \                          ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpqcjsab5m.swift:23:59: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    var current: String\
    \ = s.substringToIndex(s.startIndex.advancedBy(1))\n                         \
    \                    ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqcjsab5m.swift:28:27: error:\
    \ value of type 'String' has no member 'substringToIndex'\n        current = current.substringToIndex(current.startIndex.advancedBy(-1))\n\
    \                  ~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpqcjsab5m.swift:28:63: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n        current = current.substringToIndex(current.startIndex.advancedBy(-1))\n\
    \                                           ~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqcjsab5m.swift:29:20:\
    \ error: 'characters' is unavailable: Please use String directly\n        if current.characters.count\
    \ == 1 {\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var list = s.characters.flatMap{\
    \ $0 }\n    var result: [String] = []\n    for i : Int in 0..<n {\n        var\
    \ index = i\n        for j in list...list {\n            if list[j] == list[index]\
    \ {\n                index = j\n            }\n        }\n        if index ==\
    \ list.endIndex {\n            list.append(list[i])\n        } else {\n      \
    \      result.append(String(list[index]))\n            list.append(list[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbcni20v7.swift:19:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    var list = s.characters.flatMap{ $0 }\n           \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpbcni20v7.swift:19:29:\
    \ warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where\
    \ closure returns an optional value\n    var list = s.characters.flatMap{ $0 }\n\
    \                            ^\n/tmp/tmpbcni20v7.swift:19:29: note: use 'compactMap(_:)'\
    \ instead\n    var list = s.characters.flatMap{ $0 }\n                       \
    \     ^~~~~~~\n                            compactMap\n/tmp/tmpbcni20v7.swift:23:22:\
    \ error: referencing operator function '...' on 'Comparable' requires that '[String.Element]'\
    \ (aka 'Array<Character>') conform to 'Comparable'\n        for j in list...list\
    \ {\n                     ^\nSwift.Comparable:1:11: note: where 'Self' = '[String.Element]'\
    \ (aka 'Array<Character>')\nextension Comparable {\n          ^\n/tmp/tmpbcni20v7.swift:23:22:\
    \ error: protocol 'Sequence' requires that '[String.Element]' (aka 'Array<Character>')\
    \ conform to 'Strideable'\n        for j in list...list {\n                  \
    \   ^\nSwift.ClosedRange:1:11: note: requirement from conditional conformance\
    \ of 'ClosedRange<[String.Element]>' (aka 'ClosedRange<Array<Character>>') to\
    \ 'Sequence'\nextension ClosedRange : Sequence where Bound : Strideable, Bound.Stride\
    \ : SignedInteger {\n          ^\n/tmp/tmpbcni20v7.swift:23:22: error: referencing\
    \ instance method 'makeIterator()' on 'ClosedRange' requires that '[String.Element]'\
    \ (aka 'Array<Character>') conform to 'Strideable'\n        for j in list...list\
    \ {\n                     ^\nSwift.ClosedRange:1:11: note: requirement from conditional\
    \ conformance of 'ClosedRange<[String.Element]>' (aka 'ClosedRange<Array<Character>>')\
    \ to 'Collection'\nextension ClosedRange : Collection, BidirectionalCollection,\
    \ RandomAccessCollection where Bound : Strideable, Bound.Stride : SignedInteger\
    \ {\n          ^\n<unknown>:0"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\t\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmpxn0mll4o.swift:20:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    let result =\
    \ s.components(separatedBy: \" \")\n    \n    let count = result.count\n    \n\
    \    if count < n {\n        return []\n    }\n    \n    let result2 = result.filter{\
    \ substr in\n        return substr.contains(\"a\") || substr.contains(\"e\") ||\
    \ substr.contains(\"i\") || substr.contains(\"o\") || substr.contains(\"u\") ||\
    \ substr.contains(\"y\")\n    }\n    \n    if count == n {\n        return result2\n\
    \    }\n    \n    let result3 = result2.filter{ substr in\n        return substr.countElements(of:\
    \ \"a\") >= n && substr.countElements(of: \"e\") >= n && substr.countElements(of:\
    \ \"i\") >= n && substr.countElements(of: \"o\") >= n && substr.countElements(of:\
    \ \"u\") >= n && substr.countElements(of: \"y\") >= n\n    }\n    \n    return\
    \ result3\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprhonkq6q.swift:20:20: error: value of type 'String' has no member\
    \ 'components'\n    let result = s.components(separatedBy: \" \")\n          \
    \       ~ ^~~~~~~~~~\n/tmp/tmprhonkq6q.swift:36:19: error: the compiler is unable\
    \ to type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n    let result3 = result2.filter{ substr in\n\
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014672
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo930kvti.swift:19:12: error: cannot convert return expression of\
    \ type 'String' to return type '[String]'\n    return \"\"\n           ^~\n"
  stdout: ''
  timestamp: 1660014601
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return words\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz845g619.swift:19:12: error: cannot find 'words' in scope\n   \
    \ return words\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tvar words = [String]()\n\
    \tlet letters = s.lowercased()\n\tfor letter in letters {\n\t\tif letter.count\
    \ == n {\n\t\t\twords.append(String(letter))\n\t\t}\n\t}\n\treturn words\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdpw02d9a.swift:22:13: error: value of type 'Character' has no member\
    \ 'count'\n                if letter.count == n {\n                   ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    for letter in s {\n        if contains(s, letter) {\n            result.append((letter,\
    \ s.count))\n        }\n    }\n    \n    // Sort result by number of consonants\n\
    \    result\n        .sorted(by: {$1.0 > $1.1})\n        .prefix(n)\n        .map({\
    \ $0.0 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw83_p9d7.swift:22:12: error: cannot find 'contains' in scope\n\
    \        if contains(s, letter) {\n           ^~~~~~~~\n/tmp/tmpw83_p9d7.swift:23:27:\
    \ error: cannot convert value of type '(Character, Int)' to expected argument\
    \ type 'String'\n            result.append((letter, s.count))\n              \
    \            ^\n/tmp/tmpw83_p9d7.swift:29:25: error: value of type 'String' has\
    \ no member '0'\n        .sorted(by: {$1.0 > $1.1})\n                     ~~ ^\n\
    /tmp/tmpw83_p9d7.swift:29:32: error: value of type 'String' has no member '1'\n\
    \        .sorted(by: {$1.0 > $1.1})\n                            ~~ ^\n/tmp/tmpw83_p9d7.swift:31:19:\
    \ error: value of type 'String' has no member '0'\n        .map({ $0.0 })\n  \
    \             ~~ ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char == \" \" {\n            if n\
    \ == 0 || result.isEmpty {\n                result += [String]()\n           \
    \ } else {\n                result.removeLast()\n            }\n        } else\
    \ if char == \" \" {\n            if n == 0 || result.isEmpty {\n            \
    \    result += [String]()\n            } else {\n                result.removeLast()\n\
    \            }\n        } else {\n            if n == 0 || result.isEmpty {\n\
    \                result.append(String(char))\n            } else {\n         \
    \       if char <= 122 {\n                    if char == 96 {\n              \
    \          result += [String]()\n                    } else {\n              \
    \          result.append(String(char))\n                    }\n              \
    \  } else {\n                    if char == 96 {\n                        result\
    \ += [String]()\n                    } else {\n                        if char\
    \ <= 123 {\n                            if char == 97 {\n                    \
    \            result += [String]()\n                            } else {\n    \
    \                            result += [String]()\n                          \
    \  }\n                        } else {\n                            if char ==\
    \ 97 {\n                                result += [String]()\n               \
    \             } else {\n                                if char <= 124 {\n   \
    \                                 if char == 98 {\n                          \
    \              result += [String]()\n                                    } else\
    \ {\n                                        result.append(String(char))\n   \
    \                                 }\n                                } else {\n\
    \                                    if char == 98 {\n                       \
    \                 result += [String]()\n                                    }\
    \ else {\n                                        if char <= 125 {\n         \
    \                                   if char == 99 {\n                        \
    \                        result += [String]()\n                              \
    \              } else {\n                                                result\
    \ += [String]()\n                                            }\n             \
    \                           } else {\n                                       \
    \     if char == 99 {\n                                                result\
    \ += [String]()\n                                            } else {\n      \
    \                                          if char <= 126 {\n                \
    \                                    if char == 100 {\n                      \
    \                                  result += [String]()\n                    \
    \                                } else {\n                                  \
    \                      result.append(String(char))\n                         \
    \                           }\n                                              \
    \  } else {\n                                                    if char == 100\
    \ {\n                                                        result += [String]()\n\
    \                                                    } else {\n              \
    \                                          if char <= 127 {\n                \
    \                                            result += [String]()\n          \
    \                                              } else {\n                    \
    \                                        result += [String]()\n              \
    \                                          }\n                               \
    \                     }\n                                                }\n \
    \                                           }\n                              \
    \          }\n                                    }\n                        \
    \        }\n                            }\n                        }\n       \
    \             }\n                }\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpknsu3bsr.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpknsu3bsr.swift:37:25:\
    \ error: binary operator '<=' cannot be applied to operands of type 'Character'\
    \ and 'Int'\n                if char <= 122 {\n                   ~~~~ ^  ~~~\n\
    /tmp/tmpknsu3bsr.swift:37:25: note: overloads for '<=' exist with these partially\
    \ matching parameter lists: (Int, Int)\n                if char <= 122 {\n   \
    \                     ^\n/tmp/tmpknsu3bsr.swift:38:29: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'Int'\n         \
    \           if char == 96 {\n                       ~~~~ ^  ~~\n/tmp/tmpknsu3bsr.swift:38:29:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (Int, Int)\n                    if char == 96 {\n  \
    \                          ^\n/tmp/tmpknsu3bsr.swift:44:29: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'Int'\n         \
    \           if char == 96 {\n                       ~~~~ ^  ~~\n/tmp/tmpknsu3bsr.swift:44:29:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (Int, Int)\n                    if char == 96 {\n  \
    \                          ^\n/tmp/tmpknsu3bsr.swift:47:33: error: binary operator\
    \ '<=' cannot be applied to operands of type 'Character' and 'Int'\n         \
    \               if char <= 123 {\n                           ~~~~ ^  ~~~\n/tmp/tmpknsu3bsr.swift:47:33:\
    \ note: overloads for '<=' exist with these partially matching parameter lists:\
    \ (Int, Int)\n                        if char <= 123 {\n                     \
    \           ^\n/tmp/tmpknsu3bsr.swift:48:37: error: binary operator '==' cannot\
    \ be applied to operands of type 'Character' and 'Int'\n                     \
    \       if char == 97 {\n                               ~~~~ ^  ~~\n/tmp/tmpknsu3bsr."
  stdout: ''
  timestamp: 1660014603
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpb0byxez7/tmpb0byxez7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c8b6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c8b3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c8b3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c8b3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0byxez7                        0x000055a03493d4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b9c8b8cf460 __libc_start_main +
    245

    6    tmpb0byxez7                        0x000055a03493d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = Set<String>()\n\
    \    for char in s {\n        if char.countConsonants() == n {\n            result.insert(char)\n\
    \        }\n    }\n    return result.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0w50qd1l.swift:21:17: error: value of type 'Character' has no member\
    \ 'countConsonants'\n        if char.countConsonants() == n {\n           ~~~~\
    \ ^~~~~~~~~~~~~~~\n/tmp/tmp0w50qd1l.swift:22:27: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            result.insert(char)\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n  return s.trimmingCharacters(in:\
    \ .whitespaces).split(separator: \" \").filter{$0.characters.count == n}.sorted(by:\
    \ >)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe1t5ff5a.swift:19:12: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n  return s.trimmingCharacters(in: .whitespaces).split(separator:\
    \ \" \").filter{$0.characters.count == n}.sorted(by: >)\n         ~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpe1t5ff5a.swift:19:36: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n  return s.trimmingCharacters(in: .whitespaces).split(separator:\
    \ \" \").filter{$0.characters.count == n}.sorted(by: >)\n                    \
    \              ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014604
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var result: [String]\
    \ = []\n    var current = \"\"\n    var flag = true\n    for word in s.split(separator:\
    \ \" \") {\n        current = word\n        if flag {\n            let letters\
    \ = current.characters.filter { !$0.isLetter }\n            if letters.count ==\
    \ n {\n                flag = false\n                result.append(word)\n   \
    \         }\n        } else {\n            let letters = current.characters.filter\
    \ { !$0.isLetter }\n            if letters.count < n {\n                flag =\
    \ true\n                result.append(word)\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp11knh88a.swift:23:19: error: cannot assign value of type 'String.SubSequence'\
    \ (aka 'Substring') to type 'String'\n        current = word\n               \
    \   ^~~~\n                  String( )\n/tmp/tmp11knh88a.swift:25:35: error: 'characters'\
    \ is unavailable: Please use String directly\n            let letters = current.characters.filter\
    \ { !$0.isLetter }\n                                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp11knh88a.swift:28:24: error: no exact\
    \ matches in call to instance method 'append'\n                result.append(word)\n\
    \                       ^\nSwift.Array:6:37: note: candidate expects value of\
    \ type 'String' for parameter #1 (got 'String.SubSequence' (aka 'Substring'))\n\
    \    @inlinable public mutating func append(_ newElement: __owned Element)\n \
    \                                   ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'String.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmp11knh88a.swift:28:24:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n                result.append(word)\n                  \
    \     ^\n/tmp/tmp11knh88a.swift:31:35: error: 'characters' is unavailable: Please\
    \ use String directly\n            let letters = current.characters.filter { !$0.isLetter\
    \ }\n                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp11knh88a.swift:34:24: error: no exact matches in call\
    \ to instance method 'append'\n                result.append(word)\n         \
    \              ^\nSwift.Array:6:37: note: candidate expects value of type 'String'\
    \ for parameter #1 (got 'String.SubSequence' (aka 'Substring'))\n    @inlinable\
    \ public mutating func append(_ newElement:"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return select_words(s.chars().map(String.init),\
    \ n: n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcjf_7dlc.swift:19:27: error: value of type 'String' has no member\
    \ 'chars'\n    return select_words(s.chars().map(String.init), n: n)\n       \
    \                 ~ ^~~~~\n/tmp/tmpcjf_7dlc.swift:19:24: error: missing argument\
    \ label 's:' in call\n    return select_words(s.chars().map(String.init), n: n)\n\
    \                       ^\n                        s: \n"
  stdout: ''
  timestamp: 1660014603
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return [] // TODO:\
    \ Complete this function\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp1rmvkk2t/tmp1rmvkk2t.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae34b8ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae34b5d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae34b5d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae34b5d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1rmvkk2t                        0x0000562b060134c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ae34bac9460 __libc_start_main +
    245

    6    tmp1rmvkk2t                        0x0000562b060130c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    \n    var arr\
    \ = [String]()\n    var vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n \
    \   var strArr = s.characters.split{$0 == \" \"}\n    \n    for str in strArr\
    \ {\n        if str.characters.count < n {\n            continue\n        }\n\
    \        var arr = str.characters.split{$0 == \"a\" || $0 == \"e\" || $0 == \"\
    i\" || $0 == \"o\" || $0 == \"u\"}\n        \n        if arr.count == n {\n  \
    \          arr = arr + arr\n        }\n        \n        var newArr = arr.filter{vowels.contains({String($0)})}\n\
    \        \n        arr = arr + newArr\n        \n    }\n    \n    return arr\n\
    \    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkdzjaqj6.swift:24:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var strArr = s.characters.split{$0 == \" \"}\n    \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpkdzjaqj6.swift:27:16: error: 'characters' is unavailable: Please\
    \ use Substring directly\n        if str.characters.count < n {\n            \
    \   ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: Substring { get set }\n               ^\n/tmp/tmpkdzjaqj6.swift:30:23:\
    \ error: 'characters' is unavailable: Please use Substring directly\n        var\
    \ arr = str.characters.split{$0 == \"a\" || $0 == \"e\" || $0 == \"i\" || $0 ==\
    \ \"o\" || $0 == \"u\"}\n                      ^~~~~~~~~~\nSwift.Substring:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n/tmp/tmpkdzjaqj6.swift:36:32: error: contextual\
    \ type for closure argument list expects 1 argument, which cannot be implicitly\
    \ ignored\n        var newArr = arr.filter{vowels.contains({String($0)})}\n  \
    \                             ^\n                                _ in \n/tmp/tmpkdzjaqj6.swift:36:49:\
    \ error: missing argument label 'where:' in call\n        var newArr = arr.filter{vowels.contains({String($0)})}\n\
    \                                                ^\n                         \
    \                       where: \n/tmp/tmpkdzjaqj6.swift:36:50: error: cannot convert\
    \ value of type 'String' to closure result type 'Bool'\n        var newArr = arr.filter{vowels.contains({String($0)})}\n\
    \                                                 ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\treturn select_words(s.characters,\
    \ n, s.characters.count) \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_7atq9k1.swift:19:52: error: extra argument in call\n        return\
    \ select_words(s.characters, n, s.characters.count) \n                       \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var output = [String]()\n\
    \    if s != \"\" {\n        var count = count_consonants(s)\n        var result\
    \ = [String]()\n        var s = s\n        for _ in 1...n {\n            output\
    \ = result.filter({ $0.contains(s) }).sorted() { $0.compare($1) == .orderedAscending\
    \ }\n            result.removeAll(output)\n            s = output.last!\n    \
    \    }\n        output = result.filter({ $0.contains(s) }).sorted() { $0.compare($1)\
    \ == .orderedAscending }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv1eetx1r.swift:21:21: error: cannot find 'count_consonants' in\
    \ scope\n        var count = count_consonants(s)\n                    ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpv1eetx1r.swift:25:70: error: value of type 'String' has no member 'compare'\n\
    \            output = result.filter({ $0.contains(s) }).sorted() { $0.compare($1)\
    \ == .orderedAscending }\n                                                   \
    \               ~~ ^~~~~~~\n/tmp/tmpv1eetx1r.swift:26:20: error: no exact matches\
    \ in call to instance method 'removeAll'\n            result.removeAll(output)\n\
    \                   ^\n/tmp/tmpv1eetx1r.swift:26:20: note: candidate expects value\
    \ of type '(String) throws -> Bool' for parameter #1 (got '@lvalue [String]')\n\
    \            result.removeAll(output)\n                   ^\n/tmp/tmpv1eetx1r.swift:26:20:\
    \ note: candidate expects value of type '(String) throws -> Bool' for parameter\
    \ #1 (got '@lvalue [String]')\n            result.removeAll(output)\n        \
    \           ^\n/tmp/tmpv1eetx1r.swift:29:66: error: value of type 'String' has\
    \ no member 'compare'\n        output = result.filter({ $0.contains(s) }).sorted()\
    \ { $0.compare($1) == .orderedAscending }\n                                  \
    \                            ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n\tarr := [String]()\n\t\
    var i int\n\tfor ; i < len(s); i++ {\n\t\tvar str [String]\n\t\tfor str[i] !=\
    \ \" \" && str[i] != \"\\n\" {\n\t\t\tif s[str[i]] != \"a\" && s[str[i]] != \"\
    e\" && s[str[i]] != \"i\" && s[str[i]] != \"o\" && s[str[i]] != \"u\" && s[str[i]]\
    \ != \"y\" && s[str[i]] != \"A\" && s[str[i]] != \"E\" && s[str[i]] != \"I\" &&\
    \ s[str[i]] != \"O\" && s[str[i]] != \"U\" && s[str[i]] != \"Y\" {\n\t\t\t\tbreak\n\
    \t\t\t}\n\t\t}\n\t\tif str[i] != \" \" && str[i] != \"\\n\" {\n\t\t\tarr.append(s[str:])\n\
    \t\t}\n\t}\n\treturn arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmplgny2tnh.swift:19:5: error: consecutive statements on a line must\
    \ be separated by ';'\n        arr := [String]()\n           ^\n           ;\n\
    /tmp/tmplgny2tnh.swift:19:6: error: expected expression\n        arr := [String]()\n\
    \            ^\n/tmp/tmplgny2tnh.swift:20:8: error: found an unexpected second\
    \ identifier in variable declaration; is there an accidental break?\n        var\
    \ i int\n              ^\n/tmp/tmplgny2tnh.swift:20:8: note: join the identifiers\
    \ together\n        var i int\n            ~~^~~\n            iint\n/tmp/tmplgny2tnh.swift:20:8:\
    \ note: join the identifiers together with camel-case\n        var i int\n   \
    \         ~~^~~\n            iInt\n/tmp/tmplgny2tnh.swift:21:2: error: C-style\
    \ for statement has been removed in Swift 3\n        for ; i < len(s); i++ {\n\
    \        ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmplgny2tnh.swift:22:10: error: consecutive\
    \ statements on a line must be separated by ';'\n                var str [String]\n\
    \                       ^\n                       ;\n/tmp/tmplgny2tnh.swift:23:10:\
    \ error: expected 'in' after for-each pattern\n                for str[i] != \"\
    \ \" && str[i] != \"\\n\" {\n                       ^\n/tmp/tmplgny2tnh.swift:29:21:\
    \ error: expected expression in list of expressions\n                        arr.append(s[str:])\n\
    \                                         ^\n/tmp/tmplgny2tnh.swift:19:2: error:\
    \ cannot find 'arr' in scope\n        arr := [String]()\n        ^~~\n/tmp/tmplgny2tnh.swift:20:6:\
    \ error: type annotation missing in pattern\n        var i int\n            ^\n\
    /tmp/tmplgny2tnh.swift:32:9: error: cannot find 'arr' in scope\n        return\
    \ arr\n               ^~~\n/tmp/tmplgny2tnh.swift:22:7: error: type annotation\
    \ missing in pattern\n                var str [String]\n                    ^\n\
    /tmp/tmplgny2tnh.swift:23:17: error: cannot convert value of type 'String' to\
    \ expected argument type '[String]'\n                for str[i] != \" \" && str[i]\
    \ != \"\\n\" {\n                              ^\n/tmp/tmplgny2tnh.swift:23:21:\
    \ error: for-in loop requires 'Bool' to conform to 'Sequence'\n              \
    \  for str[i]"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n  // BEGIN Question 6\n\
    \  \n  // END Question 6\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmp_39cs7_f.swift:22:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // BEGIN SOLUTION\n\
    \    \n    let countMap = countWords(s)\n    \n    var words: [String] = []\n\
    \    \n    for word, _ in countMap.keys {\n        \n        if countMap[word]\
    \ == n {\n            \n            words.append(word)\n        }\n    }\n   \
    \ \n    return words\n    \n    // END SOLUTION\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm_m42z61.swift:25:13: error: expected 'in' after for-each pattern\n\
    \    for word, _ in countMap.keys {\n            ^\n/tmp/tmpm_m42z61.swift:25:13:\
    \ error: expected Sequence expression for for-each loop\n    for word, _ in countMap.keys\
    \ {\n            ^\n/tmp/tmpm_m42z61.swift:21:20: error: cannot find 'countWords'\
    \ in scope\n    let countMap = countWords(s)\n                   ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s.isEmpty {\n  \
    \      return []\n    }\n    var res = []\n    var start = 0\n    for letter in\
    \ s {\n        if letter == \" \"{\n            res.append(s[start:])\n      \
    \      break\n        }\n        var count = 0\n        for c in letter {\n  \
    \          if c != \"a\" && c != \"e\" && c != \"i\" && c != \"o\" && c != \"\
    u\" && c != \"A\" && c != \"E\" && c != \"I\" && c != \"O\" && c != \"U\" {\n\
    \                count = count+1\n            }\n        }\n        if n == count\
    \ {\n            res.append(s[start:letter])\n        }\n        start = letter+1\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr3pkba_x.swift:26:32: error: expected expression in list of expressions\n\
    \            res.append(s[start:])\n                               ^\n/tmp/tmpr3pkba_x.swift:22:15:\
    \ error: empty collection literal requires an explicit type\n    var res = []\n\
    \              ^~\n/tmp/tmpr3pkba_x.swift:26:32: error: missing argument for parameter\
    \ #1 in call\n            res.append(s[start:])\n                            \
    \   ^\n                               <#String.Index#>\nSwift.String:12:12: note:\
    \ 'subscript(_:)' declared here\n    public subscript(i: String.Index) -> Character\
    \ { get }\n           ^\n/tmp/tmpr3pkba_x.swift:30:18: error: for-in loop requires\
    \ 'Character' to conform to 'Sequence'\n        for c in letter {\n          \
    \       ^~~~~~\n/tmp/tmpr3pkba_x.swift:36:25: error: no exact matches in call\
    \ to subscript \n            res.append(s[start:letter])\n                   \
    \     ^\n/tmp/tmpr3pkba_x.swift:36:25: note: candidate expects value of type 'String.Index'\
    \ for parameter #1 (got 'Character')\n            res.append(s[start:letter])\n\
    \                        ^\n/tmp/tmpr3pkba_x.swift:36:25: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Character')\n   \
    \         res.append(s[start:letter])\n                        ^\n/tmp/tmpr3pkba_x.swift:36:25:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Character')\n            res.append(s[start:letter])\n            \
    \            ^\n/tmp/tmpr3pkba_x.swift:38:17: error: cannot convert value of type\
    \ 'Character' to expected argument type 'Int'\n        start = letter+1\n    \
    \            ^\n/tmp/tmpr3pkba_x.swift:40:12: error: cannot convert return expression\
    \ of type '[Any]' to return type '[String]'\n    return res\n           ^\n/tmp/tmpr3pkba_x.swift:40:12:\
    \ note: arguments to generic parameter 'Element' ('Any' and 'String') are expected\
    \ to be equal\n    return res\n           ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    var words: [String]\
    \ = []\n    \n    let chars = count_chars(s)\n    \n    if chars.count >= n {\n\
    \        let strs = s.characters.split(separator: \" \")\n        strs.forEach({\
    \ words.append(String($0)) })\n    }\n    \n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpprsth0as.swift:22:17: error: cannot find 'count_chars' in scope\n\
    \    let chars = count_chars(s)\n                ^~~~~~~~~~~\n/tmp/tmpprsth0as.swift:25:22:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ strs = s.characters.split(separator: \" \")\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if n == 1 {\n     \
    \   return [s]\n    }\n    var strs = Array(s[...].unicodeScalars)\n    var words\
    \ = [String]()\n    var consonants: [String] = []\n    var i = 0\n    while i\
    \ < s.count {\n        i += 1\n        var str = \"\"\n        for j in strs {\n\
    \            str += String(j)\n            if j == \" \" {\n                str\
    \ += \" \"\n            }\n        }\n        if consonants.contains(str) {\n\
    \            continue\n        }\n        consonants.append(str)\n        let\
    \ found = s.unicodeScalars.filter { (_) -> Bool in\n            return $0.isLetter\n\
    \        }\n        for j in found {\n            words.append(String(j))\n  \
    \      }\n    }\n    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgyvyxnqt.swift:40:20: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments\n            return $0.isLetter\n\
    \                   ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var res = []\n    for\
    \ i in 0..<s.characters.count {\n        if s[i] != \" \" {\n            if let\
    \ _ = s.range(of: String(s.characters\n                .prefix(upTo: i+1)\n  \
    \              .filter {$0 in \" \"}).joinedByString()) {\n                res.insert(s[i..<i+n],\
    \ at: i)\n            }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3vp982qb.swift:24:28: error: consecutive statements on a line must\
    \ be separated by ';'\n                .filter {$0 in \" \"}).joinedByString())\
    \ {\n                           ^\n                           ;\n/tmp/tmp3vp982qb.swift:24:29:\
    \ error: expected expression\n                .filter {$0 in \" \"}).joinedByString())\
    \ {\n                            ^\n/tmp/tmp3vp982qb.swift:19:15: error: empty\
    \ collection literal requires an explicit type\n    var res = []\n           \
    \   ^~\n/tmp/tmp3vp982qb.swift:20:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<s.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp3vp982qb.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] != \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3vp982qb.swift:22:26:\
    \ error: value of type 'String' has no member 'range'\n            if let _ =\
    \ s.range(of: String(s.characters\n                       ~ ^~~~~\n/tmp/tmp3vp982qb.swift:23:32:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \                .prefix(upTo: i+1)\n                               ^\n/tmp/tmp3vp982qb.swift:24:26:\
    \ error: cannot convert value of type 'Substring.Element' (aka 'Character') to\
    \ closure result type 'Bool'\n                .filter {$0 in \" \"}).joinedByString())\
    \ {\n                         ^~\n/tmp/tmp3vp982qb.swift:24:38: error: value of\
    \ type 'String' has no member 'joinedByString'\n                .filter {$0 in\
    \ \" \"}).joinedByString()) {\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~\n\
    /tmp/tmp3vp982qb.swift:25:28: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n          \
    \      res.insert(s[i..<i+n], at:"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    // BEGIN PSEUDOCODE\n\
    \    \n    // BEGIN SOLUTION\n    \n    // END SOLUTION\n    \n    // END PSEUDOCODE\n\
    \    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmpxkgtzesq.swift:28:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n    var selected_words = [String]()\n    var word_list\
    \ = s.components(separatedBy: \" \")\n    for i in 0...word_list.count-1 {\n \
    \       var word = \"\"\n        var count = 0\n        for j in 0...word_list.count-1\
    \ {\n            word = word + word_list[j]\n            if word_list[j] == \"\
    \ \" {\n                count += 1\n            }\n            if count == n {\n\
    \                break\n            }\n        }\n        selected_words.append(word)\n\
    \    }\n    return selected_words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjmr19440.swift:23:23: error: value of type 'String' has no member\
    \ 'components'\n    var word_list = s.components(separatedBy: \" \")\n       \
    \             ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    if s == \"\" {\n  \
    \      return []\n    }\n    \n    let words = [String]()\n    var i = 0\n   \
    \ while i < s.count {\n        var j = i\n        while j > 0 && s[j-1] == ' '\
    \ {\n            j--\n        }\n        let word = String(s[i ..< j])\n     \
    \   if words.contains(word) {\n            j = i\n            while j > 0 && s[j-1]\
    \ == ' ' {\n                j--\n            }\n            var word2 = String(s[i\
    \ ..< j])\n            if n == word2.count {\n                words.append(word2)\n\
    \                j = i\n                while j > 0 && s[j-1] == ' ' {\n     \
    \               j--\n                }\n            } else {\n               \
    \ break\n            }\n        } else {\n            words.append(word)\n   \
    \     }\n        i = j + 1\n    }\n    return words\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpria_p7cx.swift:27:34: error: single-quoted string literal found,\
    \ use '\"'\n        while j > 0 && s[j-1] == ' ' {\n                         \
    \        ^~~\n                                 \" \"\n/tmp/tmpria_p7cx.swift:33:38:\
    \ error: single-quoted string literal found, use '\"'\n            while j > 0\
    \ && s[j-1] == ' ' {\n                                     ^~~\n             \
    \                        \" \"\n/tmp/tmpria_p7cx.swift:40:42: error: single-quoted\
    \ string literal found, use '\"'\n                while j > 0 && s[j-1] == ' '\
    \ {\n                                         ^~~\n                          \
    \               \" \"\n/tmp/tmpria_p7cx.swift:27:24: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        while j > 0 && s[j-1] == ' ' {\n                       ^~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpria_p7cx.swift:28:14:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  j--\n             ^~\n/tmp/tmpria_p7cx.swift:30:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n        let word = String(s[i ..< j])\n                    \
    \      ^~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript<R>(bounds: R) -> String where\
    \ R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpria_p7cx.swift:33:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            while j > 0 && s[j-1] == ' ' {\n  \
    \                         ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpria_p7cx.swift:34:18: error: cannot find operator\
    \ '--' in scope; did you mean '-= 1'?\n                j--\n                 ^~\n\
    /tmp/tmpria_p7cx.swift:36:32: error: 'subs"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    let words = s.split(\"\
    \ \")\n    return words.filter { (word: String) -> Bool in\n        select_consonants2(word,\
    \ n) == n\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzgpcuzq5.swift:19:19: error: no exact matches in call to instance\
    \ method 'split'\n    let words = s.split(\" \")\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmpzgpcuzq5.swift:21:9: error: cannot find\
    \ 'select_consonants2' in scope\n        select_consonants2(word, n) == n\n  \
    \      ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    guard s != \"\" else\
    \ {\n        return []\n    }\n    \n    var wordsArr = s.characters\n    var\
    \ wordsArrFiltered: [String] = []\n    \n    for letter in wordsArr {\n      \
    \  \n        let consonantsCount: Int = letter\n        \n        if consonantsCount\
    \ < n {\n            wordsArrFiltered.append(letter)\n        }\n    }\n    \n\
    \    return wordsArrFiltered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprel_2e7y.swift:23:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var wordsArr = s.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmprel_2e7y.swift:28:36:\
    \ error: cannot convert value of type 'Character' to specified type 'Int'\n  \
    \      let consonantsCount: Int = letter\n                                   ^~~~~~\n\
    /tmp/tmprel_2e7y.swift:31:37: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            wordsArrFiltered.append(letter)\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    var arr: [String] =\
    \ []\n    var i = 0\n    while i < s.characters.count {\n        var start = i\n\
    \        while i < s.characters.count && CharacterSet(s.characters[i]).count ==\
    \ n {\n            i += 1\n        }\n        arr.append(s[start ..< i])\n   \
    \ }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9nz93lul.swift:21:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    while i < s.characters.count {\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9nz93lul.swift:23:41:\
    \ error: cannot find 'CharacterSet' in scope\n        while i < s.characters.count\
    \ && CharacterSet(s.characters[i]).count == n {\n                            \
    \            ^~~~~~~~~~~~\n/tmp/tmp9nz93lul.swift:26:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n        arr.append(s[start ..< i])\n                   ^~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014603
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // Good luck!\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmpg7zo46d6.swift:20:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014603
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    // TODO:\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpa5ckw__8/tmpa5ckw__8.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2211b1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2211811b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2211811988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22118107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa5ckw__8                        0x0000560a40dde4c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b2211d06460 __libc_start_main +
    245

    6    tmpa5ckw__8                        0x0000560a40dde0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014604
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    return s.split(\" \"\
    ).filter{ $0.characters.count >= n }.map({ String($0) })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjx5acevq.swift:19:20: error: missing argument label 'separator:'\
    \ in call\n    return s.split(\" \").filter{ $0.characters.count >= n }.map({\
    \ String($0) })\n                   ^\n                   separator: \n"
  stdout: ''
  timestamp: 1660014604
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns an array of all words from string s\
    \ that contain exactly \n/// n consonants, in order these words appear in the\
    \ string s.\n/// If the string s is empty then the function should return an empty\
    \ array.\n/// Note: you may assume the input string contains only letters and\
    \ spaces.\n/// Examples:\n/// >>> select_words(s: \"Mary had a little lamb\",\
    \ n: 4)\n/// [\"little\"]\n/// >>> select_words(s: \"Mary had a little lamb\"\
    , n: 3)\n/// [\"Mary\", \"lamb\"]\n/// >>> select_words(s: \"simple white space\"\
    , n: 2)\n/// [] as [String]\n/// >>> select_words(s: \"Hello world\", n: 4)\n\
    /// [\"world\"]\n/// >>> select_words(s: \"Uncle sam\", n: 3)\n/// [\"Uncle\"\
    ]\nfunc select_words(s: String, n: Int) -> [String] {\n    \n    let mut result\
    \ = [String]()\n    \n    if s == \"\" {\n        return result\n    }\n    \n\
    \    // use recursion here\n    \n    let len = s.characters.count\n    \n   \
    \ if len >= n {\n        let first = s.characters[0..(len - 1)]\n        \n  \
    \      if n == 1 {\n            result.append(first)\n            return result\n\
    \        }\n        \n        if first == first[..] {\n            result.append(first)\n\
    \            return result\n        }\n    }\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2zwboq3x.swift:20:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut result =\
    \ [String]()\n            ^\n/tmp/tmp2zwboq3x.swift:20:13: note: join the identifiers\
    \ together\n    let mut result = [String]()\n        ~~~~^~~~~~\n        mutresult\n\
    /tmp/tmp2zwboq3x.swift:20:13: note: join the identifiers together with camel-case\n\
    \    let mut result = [String]()\n        ~~~~^~~~~~\n        mutResult\n/tmp/tmp2zwboq3x.swift:23:16:\
    \ error: cannot find 'result' in scope\n        return result\n              \
    \ ^~~~~~\n/tmp/tmp2zwboq3x.swift:28:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    let len = s.characters.count\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp2zwboq3x.swift:31:35:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n        let\
    \ first = s.characters[0..(len - 1)]\n                                  ^~\n \
    \                                 ...\n/tmp/tmp2zwboq3x.swift:34:13: error: cannot\
    \ find 'result' in scope\n            result.append(first)\n            ^~~~~~\n\
    /tmp/tmp2zwboq3x.swift:35:20: error: cannot find 'result' in scope\n         \
    \   return result\n                   ^~~~~~\n/tmp/tmp2zwboq3x.swift:38:27: error:\
    \ cannot find operator '..' in scope; did you mean '...'?\n        if first ==\
    \ first[..] {\n                          ^~\n                          ...\n/tmp/tmp2zwboq3x.swift:39:13:\
    \ error: cannot find 'result' in scope\n            result.append(first)\n   \
    \         ^~~~~~\n/tmp/tmp2zwboq3x.swift:40:20: error: cannot find 'result' in\
    \ scope\n            return result\n                   ^~~~~~\n/tmp/tmp2zwboq3x.swift:44:12:\
    \ error: cannot find 'result' in scope\n    return result\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014604
