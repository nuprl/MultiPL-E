language: swift
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max_impl(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpkeubdxox.swift:13:12: error: cannot find 'find_max_impl' in scope\n\
    \    return find_max_impl(words)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  let maxCount = words.reduce(0, {$0 + $1.characters.count})\n  return words.first(where:\
    \ {$0.characters.count == maxCount})!\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpskgxb8f_.swift:13:43: error: 'characters' is unavailable: Please\
    \ use String directly\n  let maxCount = words.reduce(0, {$0 + $1.characters.count})\n\
    \                                          ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpskgxb8f_.swift:14:33: error: 'characters'\
    \ is unavailable: Please use String directly\n  return words.first(where: {$0.characters.count\
    \ == maxCount})!\n                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard let words = words.sorted else { return \"\" }\n    return words[words.lastIndex(where:\
    \ { words.filter({ $0.count > words.filter { $0.count > 1 }.count }).count ==\
    \ words.filter { $0.count > 1 }.count })!]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpn5q6ay3k.swift:13:11: error: initializer for conditional binding\
    \ must have Optional type, not '() -> [String]'\n    guard let words = words.sorted\
    \ else { return \"\" }\n          ^           ~~~~~~~~~~~~\n/tmp/tmpn5q6ay3k.swift:14:12:\
    \ error: function 'words' was used as a property; add () to call it\n    return\
    \ words[words.lastIndex(where: { words.filter({ $0.count > words.filter { $0.count\
    \ > 1 }.count }).count == words.filter { $0.count > 1 }.count })!]\n         \
    \  ^\n                ()\n/tmp/tmpn5q6ay3k.swift:14:18: error: function 'words'\
    \ was used as a property; add () to call it\n    return words[words.lastIndex(where:\
    \ { words.filter({ $0.count > words.filter { $0.count > 1 }.count }).count ==\
    \ words.filter { $0.count > 1 }.count })!]\n                 ^\n             \
    \         ()\n/tmp/tmpn5q6ay3k.swift:14:41: error: contextual type for closure\
    \ argument list expects 1 argument, which cannot be implicitly ignored\n    return\
    \ words[words.lastIndex(where: { words.filter({ $0.count > words.filter { $0.count\
    \ > 1 }.count }).count == words.filter { $0.count > 1 }.count })!]\n         \
    \                               ^\n                                          _\
    \ in\n/tmp/tmpn5q6ay3k.swift:14:43: error: function 'words' was used as a property;\
    \ add () to call it\n    return words[words.lastIndex(where: { words.filter({\
    \ $0.count > words.filter { $0.count > 1 }.count }).count == words.filter { $0.count\
    \ > 1 }.count })!]\n                                          ^\n            \
    \                                   ()\n/tmp/tmpn5q6ay3k.swift:14:69: error: function\
    \ 'words' was used as a property; add () to call it\n    return words[words.lastIndex(where:\
    \ { words.filter({ $0.count > words.filter { $0.count > 1 }.count }).count ==\
    \ words.filter { $0.count > 1 }.count })!]\n                                 \
    \                                   ^\n                                      \
    \                                   ()\n/tmp/tmpn5q6ay3k.swift:14:117: error:\
    \ function 'words' was used as a property; add () to call it\n    return words[words.lastIndex(wh"
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty {\n        return \"\"\n    }\n\n    var max = 0\n \
    \   var maxWord = \"\"\n    for word in words {\n        let word = word.lowercased()\n\
    \        let count = (word.unicodeScalars.filter { unicodeScalar in unicodeScalar.value\
    \ > max }.count)\n        if count > max {\n            max = count\n        \
    \    maxWord = word\n        }\n    }\n\n    return maxWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp1mfzc2dc/tmp1mfzc2dc.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5521c31c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5521928b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5521928988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b55219277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1mfzc2dc                        0x000055b52a78eaf3 <unavailable> + 6899

    5    libc.so.6                          0x00002b5521e1d460 __libc_start_main +
    245

    6    tmp1mfzc2dc                        0x000055b52a78e519 <unavailable> + 5401

    '
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = \"\"\n    var bestIndex = 0\n    for i := 0; i < len(words);\
    \ i++ {\n        word = words[i]\n        count, _ := find_max_helper(word, max)\n\
    \        if count > 1 {\n            best = words[bestIndex]\n        } else {\n\
    \            best = word\n        }\n        if count > 1 {\n            bestIndex\
    \ = i\n        }\n    }\n    return best\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpa09ehjk8.swift:15:12: error: expected type\n    for i := 0; i <\
    \ len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpa09ehjk8.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(words);\
    \ i++ {\n           ^\n/tmp/tmpa09ehjk8.swift:15:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(words); i++ {\n      \
    \     ^\n/tmp/tmpa09ehjk8.swift:17:14: error: consecutive statements on a line\
    \ must be separated by ';'\n        count, _ := find_max_helper(word, max)\n \
    \            ^\n             ;\n/tmp/tmpa09ehjk8.swift:17:14: error: expected\
    \ expression\n        count, _ := find_max_helper(word, max)\n             ^\n\
    /tmp/tmpa09ehjk8.swift:27:12: error: cannot find 'best' in scope\n    return best\n\
    \           ^~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty {\n        return \"\"\n    }\n\n    var highestCount:\
    \ Int = 1\n    var bestWord = \"\"\n    for word: String in words {\n        let\
    \ count = count(word: word)\n        if count == highestCount {\n            bestWord\
    \ = word\n        } else if count > highestCount {\n            highestCount =\
    \ count\n            bestWord = word\n        }\n    }\n    return bestWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp1nz1nv_6.swift:20:21: error: use of local variable 'count' before\
    \ its declaration\n        let count = count(word: word)\n                   \
    \ ^\n/tmp/tmp1nz1nv_6.swift:20:13: note: 'count' declared here\n        let count\
    \ = count(word: word)\n            ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n\tswitch words {\n\tcase let words as [String]:\n\t\tlet set: Set<String>\
    \ = words.map { String($0).characterSet }.map(Set)\n\t\treturn set.max(by: { a,\
    \ b in a.count < b.count }).first!\n\tcase let words as [Any]:\n\t\tlet set: Set<String>\
    \ = words.map { String(describing: $0).characterSet }.map(Set)\n\t\treturn set.max(by:\
    \ { a, b in a.count < b.count }).first!\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp493ij1vm.swift:14:17: warning: 'as' test is always true\n     \
    \   case let words as [String]:\n                       ^\n/tmp/tmp493ij1vm.swift:15:49:\
    \ error: value of type 'String' has no member 'characterSet'\n               \
    \ let set: Set<String> = words.map { String($0).characterSet }.map(Set)\n    \
    \                                               ~~~~~~~~~~ ^~~~~~~~~~~~\n/tmp/tmp493ij1vm.swift:15:68:\
    \ error: cannot convert value of type 'Set<Element>.Type' to expected argument\
    \ type '(T) throws -> T'\n                let set: Set<String> = words.map { String($0).characterSet\
    \ }.map(Set)\n                                                               \
    \                  ^\n/tmp/tmp493ij1vm.swift:15:64: error: cannot convert value\
    \ of type '[T]' to specified type 'Set<String>'\n                let set: Set<String>\
    \ = words.map { String($0).characterSet }.map(Set)\n                         \
    \              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmp493ij1vm.swift:15:32:\
    \ error: generic parameter 'T' could not be inferred\n                let set:\
    \ Set<String> = words.map { String($0).characterSet }.map(Set)\n             \
    \                                ^\nSwift.Collection:2:28: note: in call to function\
    \ 'map'\n    @inlinable public func map<T>(_ transform: (Self.Element) throws\
    \ -> T) rethrows -> [T]\n                           ^\n/tmp/tmp493ij1vm.swift:15:68:\
    \ error: generic parameter 'Element' could not be inferred\n                let\
    \ set: Set<String> = words.map { String($0).characterSet }.map(Set)\n        \
    \                                                                         ^\n\
    /tmp/tmp493ij1vm.swift:15:68: note: explicitly specify the generic arguments to\
    \ fix this issue\n                let set: Set<String> = words.map { String($0).characterSet\
    \ }.map(Set)\n                                                               \
    \                  ^\n                                                       \
    \                             <<#Element: Hashable#>>\n/tmp/tmp493ij1vm.swift:16:51:\
    \ error: value of optional type 'String?' must be unw"
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var count = -1\n    var word = \"\"\n    for word in words {\n      \
    \  count = words.filter({ $0.count > 0 }).map { $0.count }.max()!\n        if\
    \ count > -1 {\n            break\n        }\n    }\n    return word\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpds4cfv55/tmpds4cfv55.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad0cf58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad0cc4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad0cc4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad0cc4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpds4cfv55                        0x000055ae0adab8de <unavailable> + 6366

    5    libc.so.6                          0x00002aad0d144460 __libc_start_main +
    245

    6    tmpds4cfv55                        0x000055ae0adab499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty {\n        return \"\"\n    }\n\n    var maxCount: Int\
    \ = 0\n    var maxCountIndex: Int = 0\n\n    for index in 0..<words.count {\n\
    \        let word = words[index]\n\n        var count = 1\n        var prevIndex:\
    \ Int = 0\n        for nextIndex in 0..<words.count {\n            let nextWord\
    \ = words[nextIndex]\n            if word < nextWord {\n                count\
    \ = 1\n            } else {\n                count += 1\n            }\n\n   \
    \         if prevIndex == nextIndex {\n                continue\n            }\n\
    \n            if count > maxCount {\n                maxCount = count\n      \
    \          maxCountIndex = nextIndex\n            }\n\n            prevIndex =\
    \ nextIndex\n        }\n    }\n\n    return words[maxCountIndex]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp_0xi4x6z/tmp_0xi4x6z.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b779bce9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b779b9e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b779b9e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b779b9df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_0xi4x6z                        0x000055b6fbb86983 <unavailable> + 6531

    5    libc.so.6                          0x00002b779bed5460 __libc_start_main +
    245

    6    tmp_0xi4x6z                        0x000055b6fbb863a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  if words.isEmpty() {\n    return \"\"\n  }\n  let dict = Dictionary()\n\
    \  let max = words.map({$0.count()}).max()\n  var res = \"\"\n  for word in words\
    \ {\n    if dict.contains(word) {\n      res = word\n      break\n    } else {\n\
    \      dict[word] = 1\n    }\n  }\n  return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp_rbpspg9.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n  if words.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp_rbpspg9.swift:16:14: error: generic parameter 'Key' could not be\
    \ inferred\n  let dict = Dictionary()\n             ^\n/tmp/tmp_rbpspg9.swift:16:14:\
    \ note: explicitly specify the generic arguments to fix this issue\n  let dict\
    \ = Dictionary()\n             ^\n                       <<#Key: Hashable#>, Any>\n\
    /tmp/tmp_rbpspg9.swift:17:27: error: cannot call value of non-function type 'Int'\n\
    \  let max = words.map({$0.count()}).max()\n                          ^    ~~\n\
    \                               \n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  // If the number of unique characters in the words is less than the maximum\n\
    \  // number of unique characters in the words, return the first word which comes\n\
    \  // first. If the number of unique characters is equal to the maximum number\n\
    \  // of unique characters, return the word with maximum number of unique characters.\n\
    \  var max = words[0]\n  for word in words {\n    if word.countUniqChars() > max.countUniqChars()\
    \ {\n      max = word\n    }\n  }\n  return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpvtdwt82y.swift:19:13: error: value of type 'String' has no member\
    \ 'countUniqChars'\n    if word.countUniqChars() > max.countUniqChars() {\n  \
    \     ~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpvtdwt82y.swift:19:36: error: value of type\
    \ 'String' has no member 'countUniqChars'\n    if word.countUniqChars() > max.countUniqChars()\
    \ {\n                               ~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    switch len(words) {\n    case 0:\n        return \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpxj4qgs77.swift:15:16: error: unterminated string literal\n    \
    \    return \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\n\
    \               ^\n/tmp/tmpxj4qgs77.swift:40:60: error: expected '}' at end of\
    \ brace statement\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")\n                                                           ^\n/tmp/tmpxj4qgs77.swift:12:42:\
    \ note: to match this opening '{'\nfunc find_max(words: [String]) -> String {\n\
    \                                         ^\n/tmp/tmpxj4qgs77.swift:13:12: error:\
    \ cannot find 'len' in scope\n    switch len(words) {\n           ^~~\n/tmp/tmpxj4qgs77.swift:19:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: String = \"\"\n    var maxCount = 0\n    for word in words {\n\
    \        var count: Int = 0\n        for c in word {\n            if c == \"a\"\
    \ || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\" {\n                count\
    \ += 1\n            }\n        }\n        if count > maxCount {\n            max\
    \ = word\n            maxCount = count\n        }\n    }\n    return max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpe517kyh6/tmpe517kyh6.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11a2f64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11a2c5bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11a2c5b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11a2c5a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe517kyh6                        0x000055e7ca3b87de <unavailable> + 6110

    5    libc.so.6                          0x00002b11a3150460 __libc_start_main +
    245

    6    tmpe517kyh6                        0x000055e7ca3b8399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // find the largest word's characters, if there are multiple words with\
    \ the same\n    // number of unique characters, return the word with the shortest\
    \ lexicographical order\n    // e.g. \"aaabbb\" comes first because it has 3 unique\
    \ characters and is lexicographically\n    // first in lexicographical order\n\
    \    var maxCount = 0\n    var maxWord = \"\"\n    for word in words {\n     \
    \   let count = word.characters.count\n        if count > maxCount {\n       \
    \     maxWord = word\n            maxCount = count\n        }\n    }\n    return\
    \ maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpjsq4_smf.swift:20:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        let count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxLength Int = 0\n    var maxString: String? = nil\n\n    for word\
    \ in words {\n        var count = word.characters.count\n\n        if count >\
    \ maxLength {\n            maxLength = count\n            maxString = word\n \
    \       }\n    }\n\n    return maxString!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpq_zm2nv0.swift:13:19: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n    var maxLength Int\
    \ = 0\n                  ^\n/tmp/tmpq_zm2nv0.swift:13:19: note: join the identifiers\
    \ together\n    var maxLength Int = 0\n        ~~~~~~~~~~^~~\n        maxLengthInt\n\
    /tmp/tmpq_zm2nv0.swift:17:26: error: 'characters' is unavailable: Please use String\
    \ directly\n        var count = word.characters.count\n                      \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpq_zm2nv0.swift:17:13:\
    \ warning: variable 'count' was never mutated; consider changing to 'let' constant\n\
    \        var count = word.characters.count\n        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: String = \"\"\n    var count = 1\n\n    for word in words {\n\
    \        for char in word {\n            if char == max {\n                count\
    \ += 1\n            } else {\n                if count > 1 {\n               \
    \     max = char\n                    count = 1\n                } else {\n  \
    \                  max = word\n                }\n            }\n        }\n \
    \   }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpqg0sfr6x.swift:18:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == max {\n\
    \               ~~~~ ^  ~~~\n/tmp/tmpqg0sfr6x.swift:18:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == max {\n                    ^\n/tmp/tmpqg0sfr6x.swift:22:27:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \          max = char\n                          ^~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maxCount: Int = 0\n  var maxWord = \"\"\n  for word in words {\n  \
    \  var count = count_words(words: words)\n    if count == maxCount {\n      maxWord\
    \ = word\n      continue\n    }\n    if count > maxCount {\n      maxCount = count\n\
    \      maxWord = word\n    }\n  }\n  return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpnktv97od.swift:16:17: error: cannot find 'count_words' in scope\n\
    \    var count = count_words(words: words)\n                ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n\twords := strings.Fields(words)\n\tsort.Strings(words)\n\tmaxCount := 0\n\
    \tvar maxWord String = \"\"\n\tfor _, word := range words {\n\t\tcount := strings.Count(word,\
    \ \"\")\n\t\tif count > maxCount {\n\t\t\tmaxCount = count\n\t\t\tmaxWord = word\n\
    \t\t}\n\t}\n\treturn maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpwjs2ic6f.swift:13:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        words := strings.Fields(words)\n             ^\n\
    \             ;\n/tmp/tmpwjs2ic6f.swift:13:8: error: expected expression\n   \
    \     words := strings.Fields(words)\n              ^\n/tmp/tmpwjs2ic6f.swift:16:14:\
    \ error: found an unexpected second identifier in variable declaration; is there\
    \ an accidental break?\n        var maxWord String = \"\"\n                  \
    \  ^\n/tmp/tmpwjs2ic6f.swift:16:14: note: join the identifiers together\n    \
    \    var maxWord String = \"\"\n            ~~~~~~~~^~~~~~\n            maxWordString\n\
    /tmp/tmpwjs2ic6f.swift:17:7: error: expected 'in' after for-each pattern\n   \
    \     for _, word := range words {\n             ^\n/tmp/tmpwjs2ic6f.swift:17:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, word :=\
    \ range words {\n             ^\n/tmp/tmpwjs2ic6f.swift:18:8: error: consecutive\
    \ statements on a line must be separated by ';'\n                count := strings.Count(word,\
    \ \"\")\n                     ^\n                     ;\n/tmp/tmpwjs2ic6f.swift:18:9:\
    \ error: expected expression\n                count := strings.Count(word, \"\"\
    )\n                      ^\n/tmp/tmpwjs2ic6f.swift:13:2: warning: expression of\
    \ type '[String]' is unused\n        words := strings.Fields(words)\n        ^~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  guard words.count > 0 else { return \"\" }\n  var maxCount = words[0].count\n\
    \  var maxStr = words[0]\n  for str in words {\n    if str.count > maxCount {\n\
    \      maxCount = str.count\n      maxStr = str\n    }\n  }\n  return maxStr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpqnjcqwcf/tmpqnjcqwcf.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17d4464c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17d415bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17d415b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17d415a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqnjcqwcf                        0x000055e00c3458c3 <unavailable> + 6339

    5    libc.so.6                          0x00002b17d4650460 __libc_start_main +
    245

    6    tmpqnjcqwcf                        0x000055e00c3452e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: String = \"\"\n    for word in words {\n        var unique:\
    \ Int = 0\n        for char in word {\n            if word.index(char, offsetBy:\
    \ word.startIndex) == word.endIndex {\n                unique += 1\n         \
    \   } else {\n                break\n            }\n        }\n        if unique\
    \ > max.count {\n            max = String(word)\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp0iy00o9j.swift:17:16: error: instance method 'index(_:offsetBy:)'\
    \ requires that 'String.Index' conform to 'BinaryInteger'\n            if word.index(char,\
    \ offsetBy: word.startIndex) == word.endIndex {\n               ^\nSwift.Collection:3:17:\
    \ note: where 'T' = 'String.Index'\n    public func index<T>(_ i: Self.Index,\
    \ offsetBy n: T) -> Self.Index where T : BinaryInteger\n                ^\n/tmp/tmp0iy00o9j.swift:17:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \            if word.index(char, offsetBy: word.startIndex) == word.endIndex {\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  return find_max3(words).1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpox1p_4c8.swift:13:10: error: cannot find 'find_max3' in scope\n\
    \  return find_max3(words).1\n         ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // Create a map of letter->count of unique letters in the word\n    var\
    \ freqs: [String:Int] = [:]\n    for w in words {\n        for c in w {\n    \
    \        freqs[c] = freqs[c] + 1\n        }\n    }\n    var maxVal = 0\n    var\
    \ maxLetter = \"\"\n    for (c, v) in freqs {\n        if v > maxVal {\n     \
    \       maxVal = v\n            maxLetter = c\n        }\n    }\n    return maxLetter\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpsibv8f_c.swift:17:30: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            freqs[c] = freqs[c] + 1\n  \
    \                           ^\n/tmp/tmpsibv8f_c.swift:17:29: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n            freqs[c]\
    \ = freqs[c] + 1\n                            ^\n/tmp/tmpsibv8f_c.swift:17:29:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            freqs[c] = freqs[c] + 1\n                            ^\n\
    \                       (        ?? <#default value#>)\n/tmp/tmpsibv8f_c.swift:17:29:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            freqs[c] = freqs[c] + 1\n                            ^\n\
    \                               !\n/tmp/tmpsibv8f_c.swift:17:19: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       freqs[c] = freqs[c] + 1\n                  ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let sorted = words.sorted()\n    if sorted.count == words.count {\n \
    \       return sorted[0]\n    }\n    if sorted.count > 1 {\n        return sorted[0]\n\
    \    }\n    if sorted.count == 1 {\n        return sorted[0]\n    }\n    if sorted.count\
    \ == 0 {\n        return \"\"\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpj4gy4t_j/tmpj4gy4t_j.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06bb76ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06bb461b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06bb461988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06bb4607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4gy4t_j                        0x00005634506b661e <unavailable> + 5662

    5    libc.so.6                          0x00002b06bb956460 __libc_start_main +
    245

    6    tmpj4gy4t_j                        0x00005634506b61d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxWord = \"\"\n    for word in words {\n \
    \       if word.count > maxCount {\n            maxCount = word.count\n      \
    \      maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpbalz3n2l/tmpbalz3n2l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29d68f4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29d65ebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29d65eb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29d65ea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbalz3n2l                        0x0000558bb7f20823 <unavailable> + 6179

    5    libc.so.6                          0x00002b29d6ae0460 __libc_start_main +
    245

    6    tmpbalz3n2l                        0x0000558bb7f20249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013514
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return max(words, {\n        count := 0\n        for word in words {\n\
    \            count += len(word)\n        }\n        return count\n    })\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp_r1uvuol.swift:14:14: error: consecutive statements on a line must\
    \ be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp_r1uvuol.swift:14:15:\
    \ error: expected expression\n        count := 0\n              ^\n/tmp/tmp_r1uvuol.swift:14:9:\
    \ error: cannot find 'count' in scope\n        count := 0\n        ^~~~~\n/tmp/tmp_r1uvuol.swift:16:13:\
    \ error: cannot find 'count' in scope\n            count += len(word)\n      \
    \      ^~~~~\n/tmp/tmp_r1uvuol.swift:16:22: error: cannot find 'len' in scope\n\
    \            count += len(word)\n                     ^~~\n/tmp/tmp_r1uvuol.swift:18:16:\
    \ error: cannot find 'count' in scope\n        return count\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max: String = \"\"\n  var count: Int = 0\n  for word in words {\n \
    \   if word[word.characters.count(\"-\"...)] == \"-\" {\n      continue\n    }\n\
    \    if word == max {\n      continue\n    }\n    if count > word.characters.count\
    \ {\n      max = word\n      count = word.characters.count\n    }\n  }\n  return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpnry4bi48.swift:16:29: error: cannot call value of non-function\
    \ type 'Int'\n    if word[word.characters.count(\"-\"...)] == \"-\" {\n      \
    \                      ^\n/tmp/tmpnry4bi48.swift:22:21: error: 'characters' is\
    \ unavailable: Please use String directly\n    if count > word.characters.count\
    \ {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpnry4bi48.swift:24:20: error: 'characters' is unavailable:\
    \ Please use String directly\n      count = word.characters.count\n          \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    words.sortWith(<)\n    return words[words.count - 1]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpo0uvphim.swift:13:11: error: value of type '[String]' has no member\
    \ 'sortWith'\n    words.sortWith(<)\n    ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let max = words.reduce(\"\") {\n        if let count = reduce($0, \"\"\
    ) {\n            return count\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp4cpdfas_.swift:14:24: error: cannot find 'reduce' in scope\n  \
    \      if let count = reduce($0, \"\") {\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // Add some whitespace to make the input more readable.\n    let words\
    \ = words.map({ $0 + \" \" })\n    let sortedWords = words.sorted()\n\n    var\
    \ mostCommon = \"\"\n    var mostCommonCount = 0\n\n    for word in sortedWords\
    \ {\n        // Ignore empty strings.\n        if word.characters.count > 0 {\n\
    \            // Use a set in case the same word appears twice.\n            var\
    \ characters = Set<Character>()\n            for character in word {\n       \
    \         // Ignore empty strings.\n                if character.characters.count\
    \ > 0 {\n                    characters.insert(character)\n                }\n\
    \            }\n            // If the word has more characters, then it has the\
    \ higher count.\n            if characters.count > mostCommonCount {\n       \
    \         mostCommon = word\n                mostCommonCount = characters.count\n\
    \            }\n        }\n    }\n    return mostCommon\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpj0i7l_jo.swift:22:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        if word.characters.count > 0 {\n              \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpj0i7l_jo.swift:27:30:\
    \ error: value of type 'Character' has no member 'characters'\n              \
    \  if character.characters.count > 0 {\n                   ~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var uniqueCharacters = Set<Character>()\n    for word := range words\
    \ {\n        for char in word {\n            uniqueCharacters.insert(char)\n \
    \       }\n    }\n\n    for word := range words {\n        var count = 1\n   \
    \     for char in word {\n            count *= 2\n            if char == uniqueCharacters.first()\
    \ {\n                count += 1\n            }\n        }\n        if count ==\
    \ uniqueCharacters.count {\n            return word\n        }\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbnuu51kh.swift:14:15: error: expected type\n    for word := range\
    \ words {\n              ^\n               <#type#>\n/tmp/tmpbnuu51kh.swift:14:15:\
    \ error: expected 'in' after for-each pattern\n    for word := range words {\n\
    \              ^\n/tmp/tmpbnuu51kh.swift:14:15: error: expected Sequence expression\
    \ for for-each loop\n    for word := range words {\n              ^\n/tmp/tmpbnuu51kh.swift:20:15:\
    \ error: expected type\n    for word := range words {\n              ^\n     \
    \          <#type#>\n/tmp/tmpbnuu51kh.swift:20:15: error: expected 'in' after\
    \ for-each pattern\n    for word := range words {\n              ^\n/tmp/tmpbnuu51kh.swift:20:15:\
    \ error: expected Sequence expression for for-each loop\n    for word := range\
    \ words {\n              ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let counts = Dictionary(grouping: words, by: { $0 }).sorted { $0.value.count\
    \ > $1.value.count }\n    return counts[counts.startIndex].key\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp7ww1ckwz/tmp7ww1ckwz.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab24d218c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab24cf0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab24cf0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab24cf0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ww1ckwz                        0x000055e4873e073e <unavailable> + 5950

    5    libc.so.6                          0x00002ab24d404460 __libc_start_main +
    245

    6    tmp7ww1ckwz                        0x000055e4873e02f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max: Int = 0\n  var found: Bool = false\n  for word in words {\n  \
    \  if count > max {\n      max = count\n      found = true\n    }\n    count =\
    \ count + 1\n  }\n  if !found {\n    return words[0]\n  }\n  return words[count\
    \ - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp8jj4i9l3.swift:16:8: error: cannot find 'count' in scope\n    if\
    \ count > max {\n       ^~~~~\n/tmp/tmp8jj4i9l3.swift:17:13: error: cannot find\
    \ 'count' in scope\n      max = count\n            ^~~~~\n/tmp/tmp8jj4i9l3.swift:20:5:\
    \ error: cannot find 'count' in scope\n    count = count + 1\n    ^~~~~\n/tmp/tmp8jj4i9l3.swift:20:13:\
    \ error: cannot find 'count' in scope\n    count = count + 1\n            ^~~~~\n\
    /tmp/tmp8jj4i9l3.swift:25:16: error: cannot find 'count' in scope\n  return words[count\
    \ - 1]\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words == nil {\n        fatalError(\"Cannot get max from nil array\"\
    )\n    }\n    var res = \"\"\n    words.withUnsafeBufferPointer { words -> Void\
    \ in\n        let count = words.length\n        for i in 0..<count {\n       \
    \     let word = words[i]\n            if word.characters.count == 1 {\n     \
    \           res = word\n                return\n            }\n            var\
    \ counts = [Int]()\n            let index = word.characters.index(word.startIndex,\
    \ offsetBy: 0)\n            let range = word.startIndex..<word.endIndex\n    \
    \        for j in 0..<range.count {\n                if !counts[word.characters[j]&0xff]&0xff\
    \ != 0 {\n                    counts[word.characters[j]&0xff]++\n            \
    \    } else {\n                    // multiple characters found for the same index,\
    \ skip it\n                    continue\n                }\n            }\n  \
    \          if counts.count == 1 {\n                // found only 1 unique character\
    \ for a word in the words[]\n                res = word\n                return\n\
    \            }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpsml5stfi.swift:13:14: warning: comparing non-optional value of\
    \ type '[String]' to 'nil' always returns false\n    if words == nil {\n     \
    \  ~~~~~ ^  ~~~\n/tmp/tmpsml5stfi.swift:30:52: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n                    counts[word.characters[j]&0xff]++\n\
    \                                                   ^~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty {\n        return \"\"\n    }\n    \n    let sorted\
    \ = words.sorted()\n    let count = sorted.reduce(0) { (r, s) in r + count_unique_chars(s)\
    \ }\n    let result = sorted.first { (a, b) -> Bool in\n        return count_unique_chars(a)\
    \ > count_unique_chars(b)\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpq1yeyzb0.swift:18:50: error: cannot find 'count_unique_chars' in\
    \ scope\n    let count = sorted.reduce(0) { (r, s) in r + count_unique_chars(s)\
    \ }\n                                                 ^~~~~~~~~~~~~~~~~~\n/tmp/tmpq1yeyzb0.swift:20:16:\
    \ error: cannot find 'count_unique_chars' in scope\n        return count_unique_chars(a)\
    \ > count_unique_chars(b)\n               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpq1yeyzb0.swift:20:40:\
    \ error: cannot find 'count_unique_chars' in scope\n        return count_unique_chars(a)\
    \ > count_unique_chars(b)\n                                       ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: Int = 0\n    var maxWord: String = \"\"\n    for word in words\
    \ {\n        if words.filter({ $0 == word }).count == words.filter({ $0 == word\
    \ }).count {\n            continue\n        }\n        let count = words.filter({\
    \ $0 == word }).count\n        if count > max {\n            maxWord = word\n\
    \            max = count\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmprs97qjgi/tmprs97qjgi.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b62d8353c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b62d804ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b62d804a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b62d80497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprs97qjgi                        0x0000561dc223a74e <unavailable> + 5966

    5    libc.so.6                          0x00002b62d853f460 __libc_start_main +
    245

    6    tmprs97qjgi                        0x0000561dc223a309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let unique = Array(Set(words))\n    guard let max = unique.max(), let\
    \ index = unique.index(of: max) else { return words[0] }\n    return words[index]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp0nu10u92/tmp0nu10u92.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac999198c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac998e8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac998e8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac998e8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0nu10u92                        0x000055d655e1e7fe <unavailable> + 6142

    5    libc.so.6                          0x00002ac999384460 __libc_start_main +
    245

    6    tmp0nu10u92                        0x000055d655e1e3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let sorted = words.sorted()\n    let maxCount = sorted[0].count\n   \
    \ if maxCount == 0 {\n        return \"unknown\"\n    }\n    var maxWord = \"\"\
    \n    for word in sorted {\n        if maxCount == word.count {\n            maxWord\
    \ = word\n            break\n        }\n        maxCount = word.count\n    }\n\
    \    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpykxekj9q.swift:24:9: error: cannot assign to value: 'maxCount'\
    \ is a 'let' constant\n        maxCount = word.count\n        ^~~~~~~~\n/tmp/tmpykxekj9q.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxCount = sorted[0].count\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    switch words.count {\n    case 0:\n        return \"nil\"\n    case 1:\n\
    \        return words[0]\n    default:\n        var max = 0\n        var maxIndex\
    \ = 0\n        var maxCount = 0\n        for (i, word) in words.enumerated() {\n\
    \            if word == \"nil\" {\n                continue\n            }\n \
    \           count = count_char(word, true)\n            if count > max {\n   \
    \             max = count\n                maxIndex = i\n                maxCount\
    \ = count\n            }\n        }\n        if maxCount < 2 {\n            return\
    \ words[maxIndex]\n        }\n        return words[maxIndex + 1]\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpvz1r4k9e.swift:26:13: error: cannot find 'count' in scope\n   \
    \         count = count_char(word, true)\n            ^~~~~\n/tmp/tmpvz1r4k9e.swift:26:21:\
    \ error: cannot find 'count_char' in scope\n            count = count_char(word,\
    \ true)\n                    ^~~~~~~~~~\n/tmp/tmpvz1r4k9e.swift:27:16: error:\
    \ cannot find 'count' in scope\n            if count > max {\n               ^~~~~\n\
    /tmp/tmpvz1r4k9e.swift:28:23: error: cannot find 'count' in scope\n          \
    \      max = count\n                      ^~~~~\n/tmp/tmpvz1r4k9e.swift:30:28:\
    \ error: cannot find 'count' in scope\n                maxCount = count\n    \
    \                       ^~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    counts = [0] * (Character.max() + 1)\n    wordsSorted = words.sorted()\n\
    \    longest = words[0]\n    for word in wordsSorted {\n        counts[word.unicodeScalars.first!.value\
    \ - Character.min()]++\n        if counts[word.unicodeScalars.first!.value - Character.min()]\
    \ > counts[longest.unicodeScalars.first!.value - Character.min()] {\n        \
    \    longest = word\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp7eo69c2r.swift:13:5: error: cannot find 'counts' in scope\n   \
    \ counts = [0] * (Character.max() + 1)\n    ^~~~~~\n/tmp/tmp7eo69c2r.swift:13:18:\
    \ error: binary operator '*' cannot be applied to operands of type '[Int]' and\
    \ 'Int'\n    counts = [0] * (Character.max() + 1)\n             ~~~ ^ ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7eo69c2r.swift:13:18: note: overloads for '*' exist with these partially\
    \ matching parameter lists: (Int, Int)\n    counts = [0] * (Character.max() +\
    \ 1)\n                 ^\n/tmp/tmp7eo69c2r.swift:13:31: error: type 'Character'\
    \ has no member 'max'\n    counts = [0] * (Character.max() + 1)\n            \
    \        ~~~~~~~~~ ^~~\n/tmp/tmp7eo69c2r.swift:14:5: error: cannot find 'wordsSorted'\
    \ in scope\n    wordsSorted = words.sorted()\n    ^~~~~~~~~~~\n/tmp/tmp7eo69c2r.swift:15:5:\
    \ error: cannot find 'longest' in scope\n    longest = words[0]\n    ^~~~~~~\n\
    /tmp/tmp7eo69c2r.swift:16:17: error: cannot find 'wordsSorted' in scope\n    for\
    \ word in wordsSorted {\n                ^~~~~~~~~~~\n/tmp/tmp7eo69c2r.swift:22:12:\
    \ error: cannot find 'longest' in scope\n    return longest\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words[words.map({ $0.characters.count }).max()]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp3cd3h1gv.swift:13:53: error: cannot convert value of type 'Int?'\
    \ to expected argument type 'Int'\n    return words[words.map({ $0.characters.count\
    \ }).max()]\n                                                    ^\n         \
    \                                                !\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = 0\n    var word = \"\"\n    for _, w1 := range words {\n  \
    \      for _, w2 := range words {\n            if w1 == w2 {\n               \
    \ continue\n            }\n            max = max == 0\n            max = max ||\
    \ strings.Count(w1, string([]rune(w2)) > strings.Count(w1, string([]rune(word))))\n\
    \            word = w1\n        }\n    }\n    return word\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmps584c23k.swift:15:10: error: expected 'in' after for-each pattern\n\
    \    for _, w1 := range words {\n         ^\n/tmp/tmps584c23k.swift:15:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, w1 := range words\
    \ {\n         ^\n/tmp/tmps584c23k.swift:16:14: error: expected 'in' after for-each\
    \ pattern\n        for _, w2 := range words {\n             ^\n/tmp/tmps584c23k.swift:16:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, w2 :=\
    \ range words {\n             ^\n/tmp/tmps584c23k.swift:21:53: error: expected\
    \ ',' separator\n            max = max || strings.Count(w1, string([]rune(w2))\
    \ > strings.Count(w1, string([]rune(word))))\n                               \
    \                     ^\n                                                    ,\n\
    /tmp/tmps584c23k.swift:21:92: error: expected ',' separator\n            max =\
    \ max || strings.Count(w1, string([]rune(w2)) > strings.Count(w1, string([]rune(word))))\n\
    \                                                                            \
    \               ^\n                                                          \
    \                                 ,\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var result: String = words[0]\n    for word in words {\n        if !is_unique_chars(result,\
    \ word) {\n            result = word\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp7c2ky0sp.swift:15:13: error: cannot find 'is_unique_chars' in scope\n\
    \        if !is_unique_chars(result, word) {\n            ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max = 0\n  var result: String? = nil\n  for word in words {\n    if\
    \ let length = word.count {\n      if length >= max {\n        max = 0\n     \
    \   result = word\n      } else {\n        max = length\n      }\n    }\n  }\n\
    \  return result!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp46cw1bfz.swift:16:8: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n    if let length = word.count {\n     \
    \  ^            ~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard !words.isEmpty else { return \"\" }\n    var max = \"\"\n    var\
    \ maxCount = 0\n    for word in words {\n        let characters = word.characters\n\
    \        if maxCount < characters.count {\n            max = word\n          \
    \  maxCount = characters.count\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpsu_feorh.swift:17:31: error: 'characters' is unavailable: Please\
    \ use String directly\n        let characters = word.characters\n            \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: String = \"\"\n    for word in words {\n        if words.filter({\
    \ $0.count > word.count }).count > 0 {\n            max = word\n            break\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpx2sojmij/tmpx2sojmij.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba46d695c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba46d38cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba46d38c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba46d38b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx2sojmij                        0x000056505b89b7ae <unavailable> + 6062

    5    libc.so.6                          0x00002ba46d881460 __libc_start_main +
    245

    6    tmpx2sojmij                        0x000056505b89b369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: String = \"\"\n    var maxCount = 0\n    for word in words {\n\
    \        let uniqueCharCount = word.characters.filter{$0 == CharacterSet.alphanumerics.first!}.count\n\
    \        if uniqueCharCount > maxCount {\n            max = word\n           \
    \ maxCount = uniqueCharCount\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpghe4p17j.swift:16:60: error: cannot find 'CharacterSet' in scope\n\
    \        let uniqueCharCount = word.characters.filter{$0 == CharacterSet.alphanumerics.first!}.count\n\
    \                                                           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max_with_offset(words: words, length: 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpw8rr2nzo.swift:13:12: error: cannot find 'find_max_with_offset'\
    \ in scope\n    return find_max_with_offset(words: words, length: 0)\n       \
    \    ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max = words[0]\n  for str in words {\n    if words.filter({ $0 != str\
    \ }).count() > words.filter({ $0 == str }).count() {\n      max = str\n    }\n\
    \  }\n  return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ciygajs.swift:15:74: error: cannot call value of non-function\
    \ type 'Int'\n    if words.filter({ $0 != str }).count() > words.filter({ $0 ==\
    \ str }).count() {\n                                                         \
    \                ^    ~~\n                                                   \
    \                           \n/tmp/tmp_ciygajs.swift:15:36: error: cannot call\
    \ value of non-function type 'Int'\n    if words.filter({ $0 != str }).count()\
    \ > words.filter({ $0 == str }).count() {\n                                  \
    \ ^    ~~\n                                        \n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.count == 0 {\n        return \"\"\n    }\n    \n    words.sortInPlace()\n\
    \    \n    var max = \"\"\n    \n    for (_, val) in words.enumerated() {\n  \
    \      if val > max {\n            max = val\n        }\n    }\n    \n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp94injrx4.swift:17:11: error: value of type '[String]' has no member\
    \ 'sortInPlace'\n    words.sortInPlace()\n    ~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words == nil || words.count == 0 {\n        return \"\"\n    }\n \
    \   var max: Int = 0\n    var maxWord = \"\"\n    for word in words {\n      \
    \  count = find_unique_characters(word)\n        if max < count {\n          \
    \  max = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp0qskobkj.swift:13:14: warning: comparing non-optional value of\
    \ type '[String]' to 'nil' always returns false\n    if words == nil || words.count\
    \ == 0 {\n       ~~~~~ ^  ~~~\n/tmp/tmp0qskobkj.swift:19:9: error: cannot find\
    \ 'count' in scope\n        count = find_unique_characters(word)\n        ^~~~~\n\
    /tmp/tmp0qskobkj.swift:19:17: error: cannot find 'find_unique_characters' in scope\n\
    \        count = find_unique_characters(word)\n                ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0qskobkj.swift:20:18: error: cannot find 'count' in scope\n        if\
    \ max < count {\n                 ^~~~~\n/tmp/tmp0qskobkj.swift:21:19: error:\
    \ cannot find 'count' in scope\n            max = count\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    let set = Set<String>()\n    for word in words {\n        let count\
    \ = set.count(for: word)\n        if count > set.count {\n            set.insert(word)\n\
    \        }\n    }\n    return set.first!\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpp5n6y9hk.swift:16:25: error: cannot call value of non-function\
    \ type 'Int'\n        let count = set.count(for: word)\n                     \
    \   ^\n/tmp/tmpp5n6y9hk.swift:18:17: error: cannot use mutating member on immutable\
    \ value: 'set' is a 'let' constant\n            set.insert(word)\n           \
    \ ~~~ ^\n/tmp/tmpp5n6y9hk.swift:14:5: note: change 'let' to 'var' to make it mutable\n\
    \    let set = Set<String>()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max(words, nil).0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpsqotgbo_.swift:13:28: error: extra argument in call\n    return\
    \ find_max(words, nil).0\n                   ~~~~~~~~^~~~\n/tmp/tmpsqotgbo_.swift:13:28:\
    \ error: 'nil' requires a contextual type\n    return find_max(words, nil).0\n\
    \                           ^\n/tmp/tmpsqotgbo_.swift:13:33: error: value of type\
    \ 'String' has no member '0'\n    return find_max(words, nil).0\n           ~~~~~~~~~~~~~~~~~~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maxString: String = \"\"\n  var maxCount: Int = 0\n  var index: Int\
    \ = 0\n  for i, word := range words {\n    if i == 0 {\n      maxCount = 1\n \
    \   } else {\n      if word.count() > maxCount {\n        maxCount = word.count()\n\
    \        maxString = word\n        index = i\n      }\n    }\n  }\n  if maxCount\
    \ == 0 {\n    return \"\"\n  }\n  return maxString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpkcn9w83s.swift:16:8: error: expected 'in' after for-each pattern\n\
    \  for i, word := range words {\n       ^\n/tmp/tmpkcn9w83s.swift:16:8: error:\
    \ expected Sequence expression for for-each loop\n  for i, word := range words\
    \ {\n       ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max = \"\"\n  var max = words[0]\n  for _, word := range words {\n\
    \    if len(word) > len(max) {\n      max = word\n    }\n  }\n  return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmptavsmijw.swift:15:8: error: expected 'in' after for-each pattern\n\
    \  for _, word := range words {\n       ^\n/tmp/tmptavsmijw.swift:15:8: error:\
    \ expected Sequence expression for for-each loop\n  for _, word := range words\
    \ {\n       ^\n/tmp/tmptavsmijw.swift:14:7: error: invalid redeclaration of 'max'\n\
    \  var max = words[0]\n      ^\n/tmp/tmptavsmijw.swift:13:7: note: 'max' previously\
    \ declared here\n  var max = \"\"\n      ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard let words = words.compactMap {\n        Array($0).filter {\n  \
    \          return $0.characters.count > 1\n        }\n    }\n    return words.sorted().first!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp2dngepfq.swift:13:40: error: expected 'else' after 'guard' condition\n\
    \    guard let words = words.compactMap {\n                                  \
    \     ^\n                                       else \n/tmp/tmp2dngepfq.swift:14:15:\
    \ error: anonymous closure argument not contained in a closure\n        Array($0).filter\
    \ {\n              ^\n/tmp/tmp2dngepfq.swift:13:23: error: generic parameter 'ElementOfResult'\
    \ could not be inferred\n    guard let words = words.compactMap {\n          \
    \            ^\nSwift.Sequence:2:28: note: in call to function 'compactMap'\n\
    \    @inlinable public func compactMap<ElementOfResult>(_ transform: (Self.Element)\
    \ throws -> ElementOfResult?) rethrows -> [ElementOfResult]\n                \
    \           ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard words.count > 0 else { return \"\" }\n\n    // Find all unique\
    \ characters\n    var uniqueCharacters = [String]()\n    for word in words {\n\
    \        var uniqueCharacterCount = 0\n        for char in word {\n          \
    \  if uniqueCharacters.contains(char) {\n                uniqueCharacterCount\
    \ += 1\n            } else {\n                uniqueCharacters.append(char)\n\
    \            }\n        }\n        if uniqueCharacterCount > words.count {\n \
    \           return word\n        }\n    }\n\n    // Return the word with maximum\
    \ number of unique characters\n    return uniqueCharacters.sorted()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpskwclaou.swift:20:42: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            if uniqueCharacters.contains(char)\
    \ {\n                                         ^\n/tmp/tmpskwclaou.swift:23:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                uniqueCharacters.append(char)\n                             \
    \           ^\n/tmp/tmpskwclaou.swift:32:29: error: cannot convert return expression\
    \ of type '[String]' to return type 'String'\n    return uniqueCharacters.sorted()\n\
    \           ~~~~~~~~~~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxValue = \"\"\n    for value := range words\
    \ {\n        if maxCount == 0 || maxCount < value {\n            maxCount = value\n\
    \            maxValue = value\n        }\n    }\n    return maxValue\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpv3eb6tar.swift:15:16: error: expected type\n    for value := range\
    \ words {\n               ^\n                <#type#>\n/tmp/tmpv3eb6tar.swift:15:16:\
    \ error: expected 'in' after for-each pattern\n    for value := range words {\n\
    \               ^\n/tmp/tmpv3eb6tar.swift:15:16: error: expected Sequence expression\
    \ for for-each loop\n    for value := range words {\n               ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max_with_sort(words).1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7n5uhgrj.swift:13:12: error: cannot find 'find_max_with_sort' in\
    \ scope\n    return find_max_with_sort(words).1\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let maxSet = NSCountedSet(array: words)\n    let max = maxSet.max()\n\
    \    return maxSet.firstObject ?? \"empty set\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpn_hx_kps.swift:13:18: error: cannot find 'NSCountedSet' in scope\n\
    \    let maxSet = NSCountedSet(array: words)\n                 ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: Character?\n    var maxCount: Int32 = 0\n    for word := range\
    \ words {\n        let wordChars = word.characters()\n        var count: Int32\
    \ = 0\n        for char in wordChars {\n            if char == max! {\n      \
    \          count += 1\n            } else {\n                max = char\n    \
    \            count = 1 //only count the first occurence\n            }\n     \
    \   }\n        if count > maxCount {\n            maxCount = count\n        }\n\
    \    }\n    return max!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpijzq84hy.swift:15:15: error: expected type\n    for word := range\
    \ words {\n              ^\n               <#type#>\n/tmp/tmpijzq84hy.swift:15:15:\
    \ error: expected 'in' after for-each pattern\n    for word := range words {\n\
    \              ^\n/tmp/tmpijzq84hy.swift:15:15: error: expected Sequence expression\
    \ for for-each loop\n    for word := range words {\n              ^\n/tmp/tmpijzq84hy.swift:30:15:\
    \ error: cannot convert return expression of type 'Character' to return type 'String'\n\
    \    return max!\n           ~~~^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxString = \"\"\n    for word : String in words {\n        for i\
    \ : String in word.characters {\n            if maxString.characters.count < i\
    \ {\n                maxString = word\n            }\n        }\n    }\n    return\
    \ maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmphyd2mt8n.swift:15:32: error: cannot convert sequence element type\
    \ 'Character' to expected type 'String'\n        for i : String in word.characters\
    \ {\n                               ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max(words: words).sorted()[0]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp466uxzeg.swift:13:43: error: cannot convert return expression of\
    \ type 'String.Element' (aka 'Character') to return type 'String'\n    return\
    \ find_max(words: words).sorted()[0]\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxString: String = \"\"\n    var maxCount: Int = 1\n    for s in\
    \ words {\n        var count = len(s)\n        if count > maxCount {\n       \
    \     maxString = s\n            maxCount = count\n        }\n    }\n    return\
    \ maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp6ptz2jh8.swift:16:21: error: cannot find 'len' in scope\n     \
    \   var count = len(s)\n                    ^~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty() {\n        return \"\"\n    }\n    let result = words.filter({\
    \ $0.count > 1 }).reduce(\"\") { $0 + String($1) }\n    if result.count == words.count\
    \ {\n        return result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2kcmi166.swift:13:14: error: cannot call value of non-function\
    \ type 'Bool'\n    if words.isEmpty() {\n             ^      ~~\n            \
    \        \n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = words[0]\n    for word in words {\n        for i := 0; i <\
    \ len(word); i++ {\n            if word[i] != max[i] {\n                break\n\
    \            }\n        }\n        if i == len(word) {\n            max = word\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpns50d6zc.swift:15:16: error: expected type\n        for i := 0;\
    \ i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmpns50d6zc.swift:15:16:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(word);\
    \ i++ {\n               ^\n/tmp/tmpns50d6zc.swift:15:16: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(word); i++ {\n   \
    \            ^\n/tmp/tmpns50d6zc.swift:20:12: error: cannot find 'i' in scope\n\
    \        if i == len(word) {\n           ^\n/tmp/tmpns50d6zc.swift:20:17: error:\
    \ cannot find 'len' in scope\n        if i == len(word) {\n                ^~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  sort.Sort(sort.Reverse(sort.Strings(words)), &StringLength)\n  return sort.Search(len(words[0]),\
    \ sort.Reverse(sort.Strings(words)), &StringLength)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpt0k5mawv.swift:13:3: error: cannot find 'sort' in scope\n  sort.Sort(sort.Reverse(sort.Strings(words)),\
    \ &StringLength)\n  ^~~~\n/tmp/tmpt0k5mawv.swift:13:13: error: cannot find 'sort'\
    \ in scope\n  sort.Sort(sort.Reverse(sort.Strings(words)), &StringLength)\n  \
    \          ^~~~\n/tmp/tmpt0k5mawv.swift:13:26: error: cannot find 'sort' in scope\n\
    \  sort.Sort(sort.Reverse(sort.Strings(words)), &StringLength)\n             \
    \            ^~~~\n/tmp/tmpt0k5mawv.swift:13:49: error: cannot find 'StringLength'\
    \ in scope\n  sort.Sort(sort.Reverse(sort.Strings(words)), &StringLength)\n  \
    \                                              ^~~~~~~~~~~~\n/tmp/tmpt0k5mawv.swift:14:10:\
    \ error: cannot find 'sort' in scope\n  return sort.Search(len(words[0]), sort.Reverse(sort.Strings(words)),\
    \ &StringLength)\n         ^~~~\n/tmp/tmpt0k5mawv.swift:14:22: error: cannot find\
    \ 'len' in scope\n  return sort.Search(len(words[0]), sort.Reverse(sort.Strings(words)),\
    \ &StringLength)\n                     ^~~\n/tmp/tmpt0k5mawv.swift:14:37: error:\
    \ cannot find 'sort' in scope\n  return sort.Search(len(words[0]), sort.Reverse(sort.Strings(words)),\
    \ &StringLength)\n                                    ^~~~\n/tmp/tmpt0k5mawv.swift:14:50:\
    \ error: cannot find 'sort' in scope\n  return sort.Search(len(words[0]), sort.Reverse(sort.Strings(words)),\
    \ &StringLength)\n                                                 ^~~~\n/tmp/tmpt0k5mawv.swift:14:73:\
    \ error: cannot find 'StringLength' in scope\n  return sort.Search(len(words[0]),\
    \ sort.Reverse(sort.Strings(words)), &StringLength)\n                        \
    \                                                ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxString = \"\"\n    var maxCount = 1\n\n    for word in words {\n\
    \        if let count = countUniqueLetters(word), count > maxCount {\n       \
    \     maxCount = count\n            maxString = word\n        }\n    }\n\n   \
    \ return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5tnt6gl_.swift:17:24: error: cannot find 'countUniqueLetters' in\
    \ scope\n        if let count = countUniqueLetters(word), count > maxCount {\n\
    \                       ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = 0\n    var last: String = nil\n    for word in words {\n  \
    \      if max < word.characters.count {\n            max = word.characters.count\n\
    \            last = word\n        }\n    }\n    return last\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp1yt30_rf.swift:14:24: error: 'nil' cannot initialize specified\
    \ type 'String'\n    var last: String = nil\n                       ^\n/tmp/tmp1yt30_rf.swift:14:15:\
    \ note: add '?' to form the optional type 'String?'\n    var last: String = nil\n\
    \              ^\n                    ?\n/tmp/tmp1yt30_rf.swift:16:23: error:\
    \ 'characters' is unavailable: Please use String directly\n        if max < word.characters.count\
    \ {\n                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp1yt30_rf.swift:17:24: error: 'characters' is unavailable:\
    \ Please use String directly\n            max = word.characters.count\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var charCount: [Character: Int] = [:]\n    for word in words {\n    \
    \    for char in word {\n            charCount[char] = (charCount[char] ?? 0)\
    \ + 1\n        }\n    }\n    var maxCount: Int = -1\n    var maxChar: String =\
    \ \"\"\n    for char in charCount {\n        if charCount[char] > maxCount {\n\
    \            maxCount = charCount[char]\n            maxChar = char\n        }\n\
    \    }\n    return maxChar\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpv1zdggu1.swift:22:21: error: no exact matches in call to subscript\
    \ \n        if charCount[char] > maxCount {\n                    ^\n/tmp/tmpv1zdggu1.swift:22:21:\
    \ note: found candidate with type '(Dictionary<Character, Int>.Index) -> (key:\
    \ Character, value: Int)'\n        if charCount[char] > maxCount {\n         \
    \           ^\n/tmp/tmpv1zdggu1.swift:22:21: note: candidate expects value of\
    \ type 'Character' for parameter #1 (got '(key: Character, value: Int)')\n   \
    \     if charCount[char] > maxCount {\n                    ^\n/tmp/tmpv1zdggu1.swift:22:28:\
    \ error: binary operator '>' cannot be applied to operands of type '(key: Character,\
    \ value: Int)' and 'Int'\n        if charCount[char] > maxCount {\n          \
    \ ~~~~~~~~~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpv1zdggu1.swift:22:28: note: overloads for\
    \ '>' exist with these partially matching parameter lists: (Int, Int)\n      \
    \  if charCount[char] > maxCount {\n                           ^\n/tmp/tmpv1zdggu1.swift:23:33:\
    \ error: no exact matches in call to subscript \n            maxCount = charCount[char]\n\
    \                                ^\n/tmp/tmpv1zdggu1.swift:23:33: note: found\
    \ candidate with type '(Dictionary<Character, Int>.Index) -> (key: Character,\
    \ value: Int)'\n            maxCount = charCount[char]\n                     \
    \           ^\n/tmp/tmpv1zdggu1.swift:23:33: note: found candidate with type '(Character)\
    \ -> @lvalue Int?'\n            maxCount = charCount[char]\n                 \
    \               ^\n/tmp/tmpv1zdggu1.swift:23:33: note: found candidate with type\
    \ '(Range<Dictionary<Character, Int>.Index>) -> Slice<[Character : Int]>'\n  \
    \          maxCount = charCount[char]\n                                ^\n/tmp/tmpv1zdggu1.swift:23:33:\
    \ note: found candidate with type '((key: Character, value: Int)) -> Dictionary<Character,\
    \ Int>.SubSequence' (aka '((key: Character, value: Int)) -> Slice<Dictionary<Character,\
    \ Int>>')\n            maxCount = charCount[char]\n                          \
    \      ^\n/tmp/tmpv1zdggu1.swift:23:33: note: found candidate with type '((UnboundedRange_)\
    \ -> ()) -> Dictionary<Charac"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    words.sort()\n    \n    var max: String = \"\"\n    var maxCount: UInt64\
    \ = 0\n    for word in words {\n        let count = word.toSet().count\n     \
    \   if count > maxCount {\n            maxCount = count\n            max = word\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp8xl8f3d4.swift:13:11: error: cannot use mutating member on immutable\
    \ value: 'words' is a 'let' constant\n    words.sort()\n    ~~~~~ ^\n/tmp/tmp8xl8f3d4.swift:18:26:\
    \ error: value of type 'String' has no member 'toSet'\n        let count = word.toSet().count\n\
    \                    ~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max(words).sorted()[0]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp_svgsxtd.swift:13:21: error: missing argument label 'words:' in\
    \ call\n    return find_max(words).sorted()[0]\n                    ^\n      \
    \              words: \n/tmp/tmp_svgsxtd.swift:13:36: error: cannot convert return\
    \ expression of type 'String.Element' (aka 'Character') to return type 'String'\n\
    \    return find_max(words).sorted()[0]\n           ~~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n\twords := make(map[string]int, len(words)+1)\n\tfor _, word := range words\
    \ {\n\t\twords[word] = count[word]\n\t}\n\tvar maxValue int\n\tvar maxString string\n\
    \tfor _, word := range words {\n\t\tif maxValue < words[word] {\n\t\t\tmaxValue\
    \ = words[word]\n\t\t\tmaxString = word\n\t\t}\n\t}\n\treturn maxString\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpp1ut06v2.swift:13:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        words := make(map[string]int, len(words)+1)\n \
    \            ^\n             ;\n/tmp/tmpp1ut06v2.swift:13:8: error: expected expression\n\
    \        words := make(map[string]int, len(words)+1)\n              ^\n/tmp/tmpp1ut06v2.swift:14:7:\
    \ error: expected 'in' after for-each pattern\n        for _, word := range words\
    \ {\n             ^\n/tmp/tmpp1ut06v2.swift:14:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, word := range words {\n             ^\n/tmp/tmpp1ut06v2.swift:17:15:\
    \ error: found an unexpected second identifier in variable declaration; is there\
    \ an accidental break?\n        var maxValue int\n                     ^\n/tmp/tmpp1ut06v2.swift:17:15:\
    \ note: join the identifiers together\n        var maxValue int\n            ~~~~~~~~~^~~\n\
    \            maxValueint\n/tmp/tmpp1ut06v2.swift:17:15: note: join the identifiers\
    \ together with camel-case\n        var maxValue int\n            ~~~~~~~~~^~~\n\
    \            maxValueInt\n/tmp/tmpp1ut06v2.swift:18:16: error: found an unexpected\
    \ second identifier in variable declaration; is there an accidental break?\n \
    \       var maxString string\n                      ^\n/tmp/tmpp1ut06v2.swift:18:16:\
    \ note: join the identifiers together\n        var maxString string\n        \
    \    ~~~~~~~~~~^~~~~~\n            maxStringstring\n/tmp/tmpp1ut06v2.swift:18:16:\
    \ note: join the identifiers together with camel-case\n        var maxString string\n\
    \            ~~~~~~~~~~^~~~~~\n            maxStringString\n/tmp/tmpp1ut06v2.swift:19:7:\
    \ error: expected 'in' after for-each pattern\n        for _, word := range words\
    \ {\n             ^\n/tmp/tmpp1ut06v2.swift:19:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, word := range words {\n             ^\n/tmp/tmpp1ut06v2.swift:13:2:\
    \ warning: expression of type '[String]' is unused\n        words := make(map[string]int,\
    \ len(words)+1)\n        ^~~~~\n/tmp/tmpp1ut06v2.swift:17:6: error: type annotation\
    \ missing in pattern\n        var maxValue int\n           "
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max_(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpnfxdpipi.swift:13:12: error: cannot find 'find_max_' in scope\n\
    \    return find_max_(words)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let freq = Dictionary(grouping: words, by: { String($0) })\n    let max\
    \ = freq.map { $0.value.count }.max() ?? 0\n    return freq.first!.value.filter\
    \ { $0.count == max }.first!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpahgxiqox/tmpahgxiqox.swift:15: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002adfe2137c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adfe1e2e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002adfe1e2e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002adfe1e2e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002adfe1e2dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpahgxiqox                        0x00005630aa8b0eb5 <unavailable> + 11957

    6    tmpahgxiqox                        0x00005630aa8af9cd <unavailable> + 6605

    7    libc.so.6                          0x00002adfe2323460 __libc_start_main +
    245

    8    tmpahgxiqox                        0x00005630aa8af649 <unavailable> + 5705

    '
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    words.sort();\n    for index in 0..<words.count {\n        if words.count\
    \ == 1 {\n            return words[0]\n        }\n        var j: Int = 0\n   \
    \     while j < words.count {\n            if words[j].characters.count > words[index].characters.count\
    \ {\n                break\n            }\n            j += 1\n        }\n   \
    \     if j == words.count {\n            return words[0]\n        }\n        if\
    \ words[index].characters.count == words[j].characters.count {\n            return\
    \ words[index]\n        }\n    }\n    return words[0]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpi25r5ai6.swift:13:11: error: cannot use mutating member on immutable\
    \ value: 'words' is a 'let' constant\n    words.sort();\n    ~~~~~ ^\n/tmp/tmpi25r5ai6.swift:20:25:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if words[j].characters.count > words[index].characters.count {\n           \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpi25r5ai6.swift:20:57: error: 'characters' is unavailable: Please\
    \ use String directly\n            if words[j].characters.count > words[index].characters.count\
    \ {\n                                                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpi25r5ai6.swift:28:25: error: 'characters'\
    \ is unavailable: Please use String directly\n        if words[index].characters.count\
    \ == words[j].characters.count {\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpi25r5ai6.swift:28:54: error: 'characters'\
    \ is unavailable: Please use String directly\n        if words[index].characters.count\
    \ == words[j].characters.count {\n                                           \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max(words: words, isSorted: true)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp04jah45a.swift:13:45: error: extra argument 'isSorted' in call\n\
    \    return find_max(words: words, isSorted: true)\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let counts = words.map({ $0.map { String($0).characters.count }.max })\n\
    \    let max = counts.max()\n    if max == 0 { return \"\" } // Empty strings\
    \ are fine\n    return words[counts.index(of: max)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbxbmvwtm.swift:13:69: warning: use of 'max' treated as a reference\
    \ to instance method in protocol 'Sequence'\n    let counts = words.map({ $0.map\
    \ { String($0).characters.count }.max })\n                                   \
    \                                 ^\nSwift.Sequence:5:28: note: 'max()' declared\
    \ here\n    @inlinable public func max() -> Self.Element?\n                  \
    \         ^\n/tmp/tmpbxbmvwtm.swift:13:69: note: use 'self.' to silence this warning\n\
    \    let counts = words.map({ $0.map { String($0).characters.count }.max })\n\
    \                                                                    ^\n     \
    \                                                               self.\n/tmp/tmpbxbmvwtm.swift:13:69:\
    \ note: use 'Swift.' to reference the global function\n    let counts = words.map({\
    \ $0.map { String($0).characters.count }.max })\n                            \
    \                                        ^\n                                 \
    \                                   Swift.\n/tmp/tmpbxbmvwtm.swift:13:50: error:\
    \ 'characters' is unavailable: Please use String directly\n    let counts = words.map({\
    \ $0.map { String($0).characters.count }.max })\n                            \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbxbmvwtm.swift:14:15: error: type '() -> Int?' cannot conform to\
    \ 'Comparable'\n    let max = counts.max()\n              ^\n/tmp/tmpbxbmvwtm.swift:14:15:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n    let max = counts.max()\n              ^\n/tmp/tmpbxbmvwtm.swift:14:15:\
    \ note: required by referencing instance method 'max()' on 'Sequence' where 'Self.Element'\
    \ = '() -> Int?'\n    let max = counts.max()\n              ^\n/tmp/tmpbxbmvwtm.swift:16:25:\
    \ error: value of optional type 'Array<() -> Int?>.Index?' (aka 'Optional<Int>')\
    \ must be unwrapped to a value of type 'Array<() -> Int?>.Index' (aka 'Int')\n\
    \    return words[counts.index(of: max)]\n                    "
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max(words: words, cmp: nil)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpm42a5_uc.swift:13:40: error: extra argument 'cmp' in call\n   \
    \ return find_max(words: words, cmp: nil)\n                   ~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmpm42a5_uc.swift:13:40: error: 'nil' requires a contextual type\n    return\
    \ find_max(words: words, cmp: nil)\n                                       ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let counts = words.reduce(into: [(String, Int)](), { dict, word in\n\
    \        var newDict = dict\n        let count = dict[word]\n        dict[word]\
    \ = count + 1\n        if dict[word] > 1 {\n            newDict = dict\n     \
    \   }\n    })\n    return counts.first {\n        $1.1 < $1.2 ? $1.0 : $1.1\n\
    \    }.key\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpnu62bixd.swift:15:25: error: no exact matches in call to subscript\
    \ \n        let count = dict[word]\n                        ^\nSwift.Array:16:23:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'String')\n\
    \    @inlinable public subscript(index: Int) -> Element { get set }\n        \
    \              ^\nSwift.Array:17:23: note: candidate expects value of type 'Range<Int>'\
    \ for parameter #1 (got 'String')\n    @inlinable public subscript(bounds: Range<Int>)\
    \ -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'String')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'String')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = \"\"\n    var maxCount = 0\n    for word := range words\
    \ {\n        count, found := frequencies[word]\n        if found {\n         \
    \   if count > maxCount {\n                maxWord = word\n                maxCount\
    \ = count\n            }\n        } else {\n            count, found = frequencies[\"\
    \"]\n            if found {\n                if count > maxCount {\n         \
    \           maxWord = word\n                    maxCount = count\n           \
    \     }\n            } else {\n                // If the empty word doesn't appear\
    \ in the words, add it.\n                frequencies[word] = 0\n            }\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpt2axh1j1.swift:15:15: error: expected type\n    for word := range\
    \ words {\n              ^\n               <#type#>\n/tmp/tmpt2axh1j1.swift:15:15:\
    \ error: expected 'in' after for-each pattern\n    for word := range words {\n\
    \              ^\n/tmp/tmpt2axh1j1.swift:15:15: error: expected Sequence expression\
    \ for for-each loop\n    for word := range words {\n              ^\n/tmp/tmpt2axh1j1.swift:16:14:\
    \ error: consecutive statements on a line must be separated by ';'\n        count,\
    \ found := frequencies[word]\n             ^\n             ;\n/tmp/tmpt2axh1j1.swift:16:14:\
    \ error: expected expression\n        count, found := frequencies[word]\n    \
    \         ^\n/tmp/tmpt2axh1j1.swift:23:18: error: consecutive statements on a\
    \ line must be separated by ';'\n            count, found = frequencies[\"\"]\n\
    \                 ^\n                 ;\n/tmp/tmpt2axh1j1.swift:23:18: error:\
    \ expected expression\n            count, found = frequencies[\"\"]\n        \
    \         ^\n"
  stdout: ''
  timestamp: 1660013705
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words == nil || words.isEmpty {\n        return \"\"\n    }\n\n  \
    \  var maxCount = 0\n    var maxStr = \"\"\n\n    for str in words {\n       \
    \ let count = str.unicodeScalars.filter({ return $0.isASCII }).count\n       \
    \ if count > maxCount {\n            maxCount = count\n            maxStr = str\n\
    \        }\n    }\n    return maxStr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpdjnpdgf2/tmpdjnpdgf2.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1a1897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1a158eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba1a158e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1a158d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdjnpdgf2                        0x000055a38348fa93 <unavailable> + 6803

    5    libc.so.6                          0x00002ba1a1a83460 __libc_start_main +
    245

    6    tmpdjnpdgf2                        0x000055a38348f4b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var result: String = \"\"\n    var maxCount: Int = 0\n    var maxLength:\
    \ Int = 0\n\n    for word in words {\n        count := wordCount(word)\n     \
    \   if count > maxCount {\n            maxCount = count\n            result =\
    \ word\n        }\n    }\n\n    if maxCount > 0 {\n        maxLength = wordCount(result)\n\
    \        for word in words {\n            length := wordCount(word)\n        \
    \    if length > maxLength {\n                maxLength = length\n           \
    \     result = word\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpwx4jhpnl.swift:18:14: error: consecutive statements on a line must\
    \ be separated by ';'\n        count := wordCount(word)\n             ^\n    \
    \         ;\n/tmp/tmpwx4jhpnl.swift:18:15: error: expected expression\n      \
    \  count := wordCount(word)\n              ^\n/tmp/tmpwx4jhpnl.swift:28:19: error:\
    \ consecutive statements on a line must be separated by ';'\n            length\
    \ := wordCount(word)\n                  ^\n                  ;\n/tmp/tmpwx4jhpnl.swift:28:20:\
    \ error: expected expression\n            length := wordCount(word)\n        \
    \           ^\n/tmp/tmpwx4jhpnl.swift:18:9: error: cannot find 'count' in scope\n\
    \        count := wordCount(word)\n        ^~~~~\n/tmp/tmpwx4jhpnl.swift:19:12:\
    \ error: cannot find 'count' in scope\n        if count > maxCount {\n       \
    \    ^~~~~\n/tmp/tmpwx4jhpnl.swift:20:24: error: cannot find 'count' in scope\n\
    \            maxCount = count\n                       ^~~~~\n/tmp/tmpwx4jhpnl.swift:26:21:\
    \ error: cannot find 'wordCount' in scope\n        maxLength = wordCount(result)\n\
    \                    ^~~~~~~~~\n/tmp/tmpwx4jhpnl.swift:28:13: error: cannot find\
    \ 'length' in scope\n            length := wordCount(word)\n            ^~~~~~\n\
    /tmp/tmpwx4jhpnl.swift:29:16: error: cannot find 'length' in scope\n         \
    \   if length > maxLength {\n               ^~~~~~\n/tmp/tmpwx4jhpnl.swift:30:29:\
    \ error: cannot find 'length' in scope\n                maxLength = length\n \
    \                           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.count == 0 {\n        return \"<no words>\"\n    }\n\n    var\
    \ max = words[0]\n    var num_unique = 1\n\n    for w := 1; w < words.count; w++\
    \ {\n        if num_unique < len(words[w]) {\n            num_unique = len(words[w])\n\
    \            max = words[w]\n        }\n    }\n\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp95xdt0q1.swift:20:12: error: expected type\n    for w := 1; w <\
    \ words.count; w++ {\n           ^\n            <#type#>\n/tmp/tmp95xdt0q1.swift:20:12:\
    \ error: expected 'in' after for-each pattern\n    for w := 1; w < words.count;\
    \ w++ {\n           ^\n/tmp/tmp95xdt0q1.swift:20:12: error: expected Sequence\
    \ expression for for-each loop\n    for w := 1; w < words.count; w++ {\n     \
    \      ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max_aux(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpjfoxh6w_.swift:13:12: error: cannot find 'find_max_aux' in scope\n\
    \    return find_max_aux(words)\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let maxCount = words.reduce(0) { (sum, word) -> Int in\n        guard\
    \ let word = word.unicodeScalars.filter { !$0.isControl }.joined(), !word.isEmpty\
    \ else { return 0 }\n        return sum + word.count\n    }\n    return words.filter\
    \ { (word: String) -> Bool in\n        let count = word.unicodeScalars.filter\
    \ { !$0.isControl }.joined().count\n        return count == maxCount\n    }.sorted\
    \ { $0.count > $1.count }.first!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmprl7fkhfu.swift:13:32: error: missing argument label 'into:' in\
    \ call\n    let maxCount = words.reduce(0) { (sum, word) -> Int in\n         \
    \                      ^\n                                into: \n/tmp/tmprl7fkhfu.swift:13:33:\
    \ error: cannot convert value of type 'Int' to expected argument type '(inout\
    \ @escaping (_, _) -> Int, String) throws -> ()'\n    let maxCount = words.reduce(0)\
    \ { (sum, word) -> Int in\n                                ^\n/tmp/tmprl7fkhfu.swift:18:54:\
    \ error: value of type 'Unicode.Scalar' has no member 'isControl'\n        let\
    \ count = word.unicodeScalars.filter { !$0.isControl }.joined().count\n      \
    \                                            ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: String = \"\"\n    var maxCount: Int = -1\n    for word in words\
    \ {\n        var count: Int = 0\n        for char in word.utf8 {\n           \
    \ if char != ' ' {\n                count += 1\n            }\n        }\n   \
    \     if count > maxCount {\n            maxCount = count\n            max = word\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmph39nd2cs.swift:18:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n/tmp/tmph39nd2cs.swift:18:21: error: binary operator '!='\
    \ cannot be applied to operands of type 'String.UTF8View.Element' (aka 'UInt8')\
    \ and 'String'\n            if char != ' ' {\n               ~~~~ ^  ~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.count < 1 {\n        return \"\"\n    }\n    if words.count\
    \ == 1 {\n        return words[0]\n    }\n\n    let mut max = words[0]\n    for\
    \ word in words {\n        if !maxTrie(max) {\n            return max\n      \
    \  }\n        max = word\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpuoa83f2b.swift:20:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut max = words[0]\n\
    \            ^\n/tmp/tmpuoa83f2b.swift:20:13: note: join the identifiers together\n\
    \    let mut max = words[0]\n        ~~~~^~~\n        mutmax\n/tmp/tmpuoa83f2b.swift:20:13:\
    \ note: join the identifiers together with camel-case\n    let mut max = words[0]\n\
    \        ~~~~^~~\n        mutMax\n/tmp/tmpuoa83f2b.swift:22:13: error: cannot\
    \ find 'maxTrie' in scope\n        if !maxTrie(max) {\n            ^~~~~~~\n/tmp/tmpuoa83f2b.swift:22:21:\
    \ error: generic parameter 'T' could not be inferred\n        if !maxTrie(max)\
    \ {\n                    ^\nSwift.max:1:24: note: in call to function 'max'\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpuoa83f2b.swift:23:20: error: generic parameter\
    \ 'T' could not be inferred\n            return max\n                   ^\nSwift.max:1:24:\
    \ note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y:\
    \ T) -> T where T : Comparable\n                       ^\n/tmp/tmpuoa83f2b.swift:23:20:\
    \ error: no 'max' candidates produce the expected contextual result type 'String'\n\
    \            return max\n                   ^\nSwift.max:1:24: note: found candidate\
    \ with type '(_, _) -> _'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T\
    \ where T : Comparable\n                       ^\nSwift.max:1:24: note: found\
    \ candidate with type '(_, _, _, _...) -> _'\n@inlinable public func max<T>(_\
    \ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Comparable\n            \
    \           ^\n/tmp/tmpuoa83f2b.swift:25:9: error: no exact matches in reference\
    \ to global function 'max'\n        max = word\n        ^\n/tmp/tmpuoa83f2b.swift:25:9:\
    \ note: found candidate with type '(_, _) -> _'\n        max = word\n        ^\n\
    /tmp/tmpuoa83f2b.swift:25:9: note: found candidate with type '(_, _, _, _...)\
    \ -> _'\n        max = word\n        ^\n/tmp/tmpuoa83f2b.swift:27:12: error: generic\
    \ parameter 'T' could not be inferred\n    return max\n           ^\nSwif"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = words[0]\n    var max_num: Int = 0\n    for word in words {\n\
    \        for ch in word {\n            if count > max_num {\n                max_num\
    \ = count\n                max = word\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpm8dk9sru.swift:17:16: error: cannot find 'count' in scope\n   \
    \         if count > max_num {\n               ^~~~~\n/tmp/tmpm8dk9sru.swift:18:27:\
    \ error: cannot find 'count' in scope\n                max_num = count\n     \
    \                     ^~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let result = words.reduce((max: String, curr: String, i: Int) -> (String,\
    \ Int)) {\n        if max.count < curr.count {\n            return (max, curr.count)\n\
    \        }\n        if max.count > curr.count {\n            return curr\n   \
    \     }\n        return (max, curr.count)\n    }\n    return result.0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmprl_fkvfy.swift:14:24: error: cannot find 'curr' in scope\n    \
    \    if max.count < curr.count {\n                       ^~~~\n/tmp/tmprl_fkvfy.swift:15:26:\
    \ error: cannot find 'curr' in scope\n            return (max, curr.count)\n \
    \                        ^~~~\n/tmp/tmprl_fkvfy.swift:17:24: error: cannot find\
    \ 'curr' in scope\n        if max.count > curr.count {\n                     \
    \  ^~~~\n/tmp/tmprl_fkvfy.swift:18:20: error: cannot find 'curr' in scope\n  \
    \          return curr\n                   ^~~~\n/tmp/tmprl_fkvfy.swift:20:22:\
    \ error: cannot find 'curr' in scope\n        return (max, curr.count)\n     \
    \                ^~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_count: Int64 = 0\n    var max_str: String = words[0]\n\n    for\
    \ word in words {\n        if !is_unique(word, max_count) {\n            continue\n\
    \        }\n\n        if max_count == 0 {\n            max_str = word\n      \
    \  } else {\n            if max_count > 0 {\n                if isLowerCase(word)\
    \ < isLowerCase(max_str) {\n                    max_str = word\n             \
    \   } else {\n                    if isLowerCase(word) > isLowerCase(max_str)\
    \ {\n                        max_str = word\n                    }\n         \
    \       }\n            } else {\n                max_str = word\n            }\n\
    \        }\n\n        max_count++\n    }\n\n    return max_str\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp_9knojjg.swift:17:13: error: cannot find 'is_unique' in scope\n\
    \        if !is_unique(word, max_count) {\n            ^~~~~~~~~\n/tmp/tmp_9knojjg.swift:25:20:\
    \ error: cannot find 'isLowerCase' in scope\n                if isLowerCase(word)\
    \ < isLowerCase(max_str) {\n                   ^~~~~~~~~~~\n/tmp/tmp_9knojjg.swift:25:40:\
    \ error: cannot find 'isLowerCase' in scope\n                if isLowerCase(word)\
    \ < isLowerCase(max_str) {\n                                       ^~~~~~~~~~~\n\
    /tmp/tmp_9knojjg.swift:28:24: error: cannot find 'isLowerCase' in scope\n    \
    \                if isLowerCase(word) > isLowerCase(max_str) {\n             \
    \          ^~~~~~~~~~~\n/tmp/tmp_9knojjg.swift:28:44: error: cannot find 'isLowerCase'\
    \ in scope\n                    if isLowerCase(word) > isLowerCase(max_str) {\n\
    \                                           ^~~~~~~~~~~\n/tmp/tmp_9knojjg.swift:37:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        max_count++\n\
    \                 ^~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard let count = count(words: words) else {\n        return \"\"\n \
    \   }\n    var max = \"\"\n    var best = \"\"\n    for word in words {\n    \
    \    var unique: Int = 0\n        for char in word {\n            unique += count(char:\
    \ char)?\n        }\n        if unique > max {\n            max = unique\n   \
    \         best = word\n        }\n    }\n    return best\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp7_aspjnt.swift:13:23: error: cannot find 'count' in scope\n   \
    \ guard let count = count(words: words) else {\n                      ^~~~~\n\
    /tmp/tmp7_aspjnt.swift:21:40: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n            unique += count(char: char)?\n       \
    \                                ^\n/tmp/tmp7_aspjnt.swift:21:40: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \         unique += count(char: char)?\n                                     \
    \  ^\n                                         ?? <#default value#>\n/tmp/tmp7_aspjnt.swift:21:40:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            unique += count(char: char)?\n                          \
    \             ^\n                      (                 )!\n/tmp/tmp7_aspjnt.swift:23:19:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'String'\n\
    \        if unique > max {\n           ~~~~~~ ^ ~~~\n/tmp/tmp7_aspjnt.swift:23:19:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if unique > max {\n                  ^\n/tmp/tmp7_aspjnt.swift:24:19:\
    \ error: cannot assign value of type 'Int' to type 'String'\n            max =\
    \ unique\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = words[0]\n    for word in words {\n        let uniqueChars\
    \ = Array(word).reduce(0) { $0.count < $1.count ? $0 + 1 : $1 }\n        if uniqueChars\
    \ > max.count {\n            max = word\n        }\n    }\n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmppbth04_r.swift:15:45: error: missing argument label 'into:' in\
    \ call\n        let uniqueChars = Array(word).reduce(0) { $0.count < $1.count\
    \ ? $0 + 1 : $1 }\n                                            ^\n           \
    \                                  into: \n"
  stdout: ''
  timestamp: 1660013710
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maxCount = 0\n  var maxWord = String()\n  for word : String in words\
    \ {\n    if maxCount < word.characters.count {\n      maxCount = word.characters.count\n\
    \      maxWord = word\n    }\n  }\n  return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmphmy6as89.swift:16:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    if maxCount < word.characters.count {\n           \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmphmy6as89.swift:17:23: error: 'characters' is unavailable: Please use String\
    \ directly\n      maxCount = word.characters.count\n                      ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    sortWords(words)\n    return words[words.index(words.maxElement())!]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp066mfnod.swift:13:5: error: cannot find 'sortWords' in scope\n\
    \    sortWords(words)\n    ^~~~~~~~~\n/tmp/tmp066mfnod.swift:14:24: error: no\
    \ exact matches in call to instance method 'index'\n    return words[words.index(words.maxElement())!]\n\
    \                       ^\n/tmp/tmp066mfnod.swift:14:24: note: found candidate\
    \ with type '((String) throws -> Bool) throws -> Array<String>.Index?' (aka '((String)\
    \ throws -> Bool) throws -> Optional<Int>')\n    return words[words.index(words.maxElement())!]\n\
    \                       ^\n/tmp/tmp066mfnod.swift:14:24: note: found candidate\
    \ with type '(String) -> Array<String>.Index?' (aka '(String) -> Optional<Int>')\n\
    \    return words[words.index(words.maxElement())!]\n                       ^\n\
    /tmp/tmp066mfnod.swift:14:36: error: value of type '[String]' has no member 'maxElement'\n\
    \    return words[words.index(words.maxElement())!]\n                        \
    \     ~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max_str(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpvrrepsz4.swift:13:12: error: cannot find 'find_max_str' in scope\n\
    \    return find_max_str(words)\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    words.sort { (word1, word2) -> Bool in\n        return word1.characters.count\
    \ > word2.characters.count\n    }\n    return words[0]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6l9hr0hz.swift:13:11: error: cannot use mutating member on immutable\
    \ value: 'words' is a 'let' constant\n    words.sort { (word1, word2) -> Bool\
    \ in\n    ~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty {\n        return \"\"\n    }\n    var maxCount: Int\
    \ = 0\n    var maxWord: String = words[0]\n    for i in 1..<words.count {\n  \
    \      let currentCount = words.filter{$0 == maxWord}.count\n        if currentCount\
    \ > maxCount {\n            maxCount = currentCount\n            maxWord = words[i]\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpcjuknft6/tmpcjuknft6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7dd811c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7dd508b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac7dd508988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac7dd5077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcjuknft6                        0x000055a4861a485e <unavailable> + 6238

    5    libc.so.6                          0x00002ac7dd9fd460 __libc_start_main +
    245

    6    tmpcjuknft6                        0x000055a4861a4419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maxCount: Int = 0\n  var maxWord: String = String()\n  for word in\
    \ words {\n    if let count = word.unicodeScalars.filter({ !$0.isControl }).count\
    \ {\n      if count > maxCount {\n        maxWord = word\n        maxCount = count\n\
    \      }\n    }\n  }\n  return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp8v7k_lvs.swift:16:53: error: value of type 'Unicode.Scalar' has\
    \ no member 'isControl'\n    if let count = word.unicodeScalars.filter({ !$0.isControl\
    \ }).count {\n                                                 ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  guard words != nil else {\n    throw RCTExceptionFromNSError(\n      NSError(domain:\
    \ NSCocoaErrorDomain, code: NSCocoaErrorNoMemory, userInfo: nil))\n  }\n\n  guard\
    \ words.count > 0 else {\n    throw RCTExceptionFromNSError(NSError(domain: NSCocoaErrorDomain,\
    \ code: NSCocoaErrorBadArgument, userInfo: nil))\n  }\n\n  guard words.count <=\
    \ MAX_WORDS else {\n    throw RCTExceptionFromNSError(NSError(domain: NSCocoaErrorDomain,\
    \ code: NSCocoaErrorStringOutOfRange, userInfo: nil))\n  }\n\n  guard !words.isEmpty\
    \ else {\n    throw RCTExceptionFromNSError(NSError(domain: NSCocoaErrorDomain,\
    \ code: NSCocoaErrorStringEmpty, userInfo: nil))\n  }\n\n  // Count words\n  var\
    \ counts = words.map({ $0.characters.count })\n\n  // Sort by count\n  counts\
    \ = counts[0..<counts.count - 1].sorted()\n\n  // Find the word with maximum count\n\
    \  guard counts[counts.count - 1] == 0 else {\n    throw RCTExceptionFromNSError(\n\
    \      NSError(domain: NSCocoaErrorDomain, code: NSCocoaErrorStringOutOfRange,\
    \ userInfo: nil))\n  }\n  return words[counts.count - 1]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp6sfge_56.swift:13:15: warning: comparing non-optional value of\
    \ type '[String]' to 'nil' always returns true\n  guard words != nil else {\n\
    \        ~~~~~ ^  ~~~\n/tmp/tmp6sfge_56.swift:14:11: error: cannot find 'RCTExceptionFromNSError'\
    \ in scope\n    throw RCTExceptionFromNSError(\n          ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp6sfge_56.swift:15:7: error: cannot find 'NSError' in scope\n      NSError(domain:\
    \ NSCocoaErrorDomain, code: NSCocoaErrorNoMemory, userInfo: nil))\n      ^~~~~~~\n\
    /tmp/tmp6sfge_56.swift:15:23: error: cannot find 'NSCocoaErrorDomain' in scope\n\
    \      NSError(domain: NSCocoaErrorDomain, code: NSCocoaErrorNoMemory, userInfo:\
    \ nil))\n                      ^~~~~~~~~~~~~~~~~~\n/tmp/tmp6sfge_56.swift:15:49:\
    \ error: cannot find 'NSCocoaErrorNoMemory' in scope\n      NSError(domain: NSCocoaErrorDomain,\
    \ code: NSCocoaErrorNoMemory, userInfo: nil))\n                              \
    \                  ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6sfge_56.swift:15:81: error:\
    \ 'nil' requires a contextual type\n      NSError(domain: NSCocoaErrorDomain,\
    \ code: NSCocoaErrorNoMemory, userInfo: nil))\n                              \
    \                                                  ^\n/tmp/tmp6sfge_56.swift:19:11:\
    \ error: cannot find 'RCTExceptionFromNSError' in scope\n    throw RCTExceptionFromNSError(NSError(domain:\
    \ NSCocoaErrorDomain, code: NSCocoaErrorBadArgument, userInfo: nil))\n       \
    \   ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6sfge_56.swift:19:35: error: cannot find\
    \ 'NSError' in scope\n    throw RCTExceptionFromNSError(NSError(domain: NSCocoaErrorDomain,\
    \ code: NSCocoaErrorBadArgument, userInfo: nil))\n                           \
    \       ^~~~~~~\n/tmp/tmp6sfge_56.swift:19:51: error: cannot find 'NSCocoaErrorDomain'\
    \ in scope\n    throw RCTExceptionFromNSError(NSError(domain: NSCocoaErrorDomain,\
    \ code: NSCocoaErrorBadArgument, userInfo: nil))\n                           \
    \                       ^~~~~~~~~~~~~~~~~~\n/tmp/tmp6sfge_56.swift:19:77: error:\
    \ cannot find 'NSCocoaErrorBadArgument' in scope\n    throw RCTExceptionFromNSError(NSError(domain:\
    \ NSCocoaErrorDomain, co"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var result = \"\"\n    var max = UInt32(0)\n    for word in words {\n\
    \        var count = UInt32(0)\n        for c in word {\n            if count\
    \ > max {\n                max = count\n                result = word\n      \
    \      }\n            count++\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp1kboq8gx.swift:22:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            count++\n                 ^~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let maxChars = words.reduce(0)(combine: +)\n    var maxChar: Int = 0\n\
    \    for word in words {\n        if maxChars > word.characters.count {\n    \
    \        maxChars = word.characters.count\n            maxChar = word.characters.count\n\
    \        } else if word.characters.count > maxChar {\n            maxChars = word.characters.count\n\
    \            maxChar = word.characters.count\n        }\n    }\n    return words.filter({\
    \ $0.characters.count == maxChar })\n        .sorted(by: { $0.characters.count\
    \ < $1.characters.count })\n        .first!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpfvgma2ny.swift:13:33: error: missing argument for parameter 'into'\
    \ in call\n    let maxChars = words.reduce(0)(combine: +)\n                  \
    \              ^\n                                into: <#_#>, \nSwift.Sequence:3:28:\
    \ note: 'reduce(into:_:)' declared here\n    @inlinable public func reduce<Result>(into\
    \ initialResult: __owned Result, _ updateAccumulatingResult: (_ partialResult:\
    \ inout Result, Self.Element) throws -> ()) rethrows -> Result\n             \
    \              ^\n/tmp/tmpfvgma2ny.swift:18:28: error: 'characters' is unavailable:\
    \ Please use String directly\n            maxChar = word.characters.count\n  \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpfvgma2ny.swift:19:24: error: 'characters' is unavailable:\
    \ Please use String directly\n        } else if word.characters.count > maxChar\
    \ {\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpfvgma2ny.swift:21:28: error: 'characters' is unavailable:\
    \ Please use String directly\n            maxChar = word.characters.count\n  \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpfvgma2ny.swift:24:30: error: 'characters' is unavailable:\
    \ Please use String directly\n    return words.filter({ $0.characters.count ==\
    \ maxChar })\n                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpfvgma2ny.swift:25:26: error: 'characters'\
    \ is unavailable: Please use String directly\n        .sorted(by: { $0.characters.count\
    \ < $1.characters.count })\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tm"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxNumChars: Int = 0\n    var maxWord = \"\"\n    for word in words\
    \ {\n        let numChars = word.characters.count\n        if numChars > maxNumChars\
    \ {\n            maxNumChars = numChars\n            maxWord = word\n        }\n\
    \    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpn68t7cm0.swift:16:29: error: 'characters' is unavailable: Please\
    \ use String directly\n        let numChars = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = 0\n    var maxString = \"\"\n    for _, word := range words\
    \ {\n        for _, c := range word {\n            max = math.Max(max, len(c))\n\
    \        }\n        if max > 0 {\n            if maxString == \"\" || maxString\
    \ < word {\n                maxString = word\n            }\n        }\n    }\n\
    \    return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmph220vagx.swift:15:10: error: expected 'in' after for-each pattern\n\
    \    for _, word := range words {\n         ^\n/tmp/tmph220vagx.swift:15:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, word := range words\
    \ {\n         ^\n/tmp/tmph220vagx.swift:16:14: error: expected 'in' after for-each\
    \ pattern\n        for _, c := range word {\n             ^\n/tmp/tmph220vagx.swift:16:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, c := range\
    \ word {\n             ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max: Int64 = -1\n  var word: String = \"\"\n  for word in words {\n\
    \    if max < word.count {\n      max = word.count\n    }\n  }\n  if max > 0 {\n\
    \    return words[words.indexOf(words.filter({ $0.count == max }))!]\n  }\n  return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpkzvg8ij1.swift:17:18: error: cannot assign value of type 'Int'\
    \ to type 'Int64'\n      max = word.count\n            ~~~~~^~~~~\n          \
    \  Int64(    )\n/tmp/tmpkzvg8ij1.swift:21:24: error: value of type '[String]'\
    \ has no member 'indexOf'\n    return words[words.indexOf(words.filter({ $0.count\
    \ == max }))!]\n                 ~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  // Initialize our \"best\" value with the first string in the array\n \
    \ var best = words[0]\n  // Initialize the number of unique characters to zero\n\
    \  var count = 0\n  // Iterate over the remaining strings in the array\n  for\
    \ string in words {\n    // If this string has fewer unique characters than our\
    \ \"best\" value\n    // so far, update our \"best\" value accordingly\n    if\
    \ count < stringCount(best) {\n      best = string\n      count = 0\n    }\n \
    \   // Update the number of unique characters for this string\n    count = count\
    \ + stringCount(string)\n  }\n  // Return the \"best\" value in the array\n  return\
    \ best\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpipz_x68m.swift:21:16: error: cannot find 'stringCount' in scope\n\
    \    if count < stringCount(best) {\n               ^~~~~~~~~~~\n/tmp/tmpipz_x68m.swift:26:21:\
    \ error: cannot find 'stringCount' in scope\n    count = count + stringCount(string)\n\
    \                    ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = \"\"\n    for word in words {\n        if let count = wordCounter(word:\
    \ word) {\n            if count == max {\n                return word\n      \
    \      }\n            max = count\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpjp3s01dv.swift:15:24: error: cannot find 'wordCounter' in scope\n\
    \        if let count = wordCounter(word: word) {\n                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxWord: String?\n    for word in words {\n\
    \        if let count = count_chars(word) {\n            if count > maxCount {\n\
    \                maxCount = count\n                maxWord = word\n          \
    \  }\n        }\n    }\n    return maxWord!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpojgzeg69.swift:16:24: error: cannot find 'count_chars' in scope\n\
    \        if let count = count_chars(word) {\n                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max_utf8(words.sorted(byLength).map(toUTF8))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp134ncxw_.swift:13:12: error: cannot find 'find_max_utf8' in scope\n\
    \    return find_max_utf8(words.sorted(byLength).map(toUTF8))\n           ^~~~~~~~~~~~~\n\
    /tmp/tmp134ncxw_.swift:13:39: error: cannot find 'byLength' in scope\n    return\
    \ find_max_utf8(words.sorted(byLength).map(toUTF8))\n                        \
    \              ^~~~~~~~\n/tmp/tmp134ncxw_.swift:13:53: error: cannot find 'toUTF8'\
    \ in scope\n    return find_max_utf8(words.sorted(byLength).map(toUTF8))\n   \
    \                                                 ^~~~~~\n/tmp/tmp134ncxw_.swift:13:39:\
    \ error: missing argument label 'by:' in call\n    return find_max_utf8(words.sorted(byLength).map(toUTF8))\n\
    \                                      ^\n                                   \
    \   by: \n/tmp/tmp134ncxw_.swift:13:39: error: converting non-escaping value to\
    \ '(String, String) throws -> Bool' may allow it to escape\n    return find_max_utf8(words.sorted(byLength).map(toUTF8))\n\
    \                                      ^\n/tmp/tmp134ncxw_.swift:13:32: error:\
    \ generic parameter 'T' could not be inferred\n    return find_max_utf8(words.sorted(byLength).map(toUTF8))\n\
    \                               ^\nSwift.Collection:2:28: note: in call to function\
    \ 'map'\n    @inlinable public func map<T>(_ transform: (Self.Element) throws\
    \ -> T) rethrows -> [T]\n                           ^\n/tmp/tmp134ncxw_.swift:13:53:\
    \ error: converting non-escaping value to '(String) throws -> T' may allow it\
    \ to escape\n    return find_max_utf8(words.sorted(byLength).map(toUTF8))\n  \
    \                                                  ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty { return \"\" }\n    \n    var maxChars = 0\n    var\
    \ maxWord = \"\"\n    \n    for word in words {\n        let count = countUniqueChars(word)\n\
    \        if count > maxChars {\n            maxWord = word\n            maxChars\
    \ = count\n        }\n    }\n    \n    return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpg3nneq1g.swift:19:21: error: cannot find 'countUniqueChars' in\
    \ scope\n        let count = countUniqueChars(word)\n                    ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.count <= 1 {\n        return words[0]\n    }\n\n    var maxWord\
    \ = \"\"\n    var maxCount = 0\n    for word in words {\n        if maxCount <\
    \ word.characters.count {\n            maxCount = word.characters.count\n    \
    \        maxWord = word\n        }\n    }\n\n    return maxWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpy9eoyud7.swift:20:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount < word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpy9eoyud7.swift:21:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxWord = \"\"\n    for _, word := range words\
    \ {\n        for count := 0; count < len(word); count++ {\n            if maxCount\
    \ < count {\n                maxCount = count\n                maxWord = word\n\
    \            }\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbx4cv6r1.swift:15:10: error: expected 'in' after for-each pattern\n\
    \    for _, word := range words {\n         ^\n/tmp/tmpbx4cv6r1.swift:15:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, word := range words\
    \ {\n         ^\n/tmp/tmpbx4cv6r1.swift:16:20: error: expected type\n        for\
    \ count := 0; count < len(word); count++ {\n                   ^\n           \
    \         <#type#>\n/tmp/tmpbx4cv6r1.swift:16:20: error: expected 'in' after for-each\
    \ pattern\n        for count := 0; count < len(word); count++ {\n            \
    \       ^\n/tmp/tmpbx4cv6r1.swift:16:20: error: expected Sequence expression for\
    \ for-each loop\n        for count := 0; count < len(word); count++ {\n      \
    \             ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = \"\"\n    var max_count = -1\n    for word in words {\n\
    \        var count = count(word)\n        if count > max_count {\n           \
    \ max_word = word\n            max_count = count\n        }\n    }\n    return\
    \ max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpvpvb6n85.swift:16:21: error: use of local variable 'count' before\
    \ its declaration\n        var count = count(word)\n                    ^\n/tmp/tmpvpvb6n85.swift:16:13:\
    \ note: 'count' declared here\n        var count = count(word)\n            ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard !words.isEmpty else {\n        return \"\"\n    }\n\n    var maxCount\
    \ = 0\n    var maxWord = \"\"\n    for word in words {\n        if let count =\
    \ count_unique_characters(word) {\n            if count > maxCount {\n       \
    \         maxCount = count\n                maxWord = word\n            }\n  \
    \      }\n    }\n\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpmndtvp5o.swift:20:24: error: cannot find 'count_unique_characters'\
    \ in scope\n        if let count = count_unique_characters(word) {\n         \
    \              ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: String = \"\"\n    var count: Int = 0\n    for word in words\
    \ {\n        count += word.countElements\n        if max < word {\n          \
    \  max = word\n        }\n    }\n    if count == 0 {\n        return \"\"\n  \
    \  }\n    if count < words[0].countElements {\n        return words[0]\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpcx46dic6.swift:16:23: error: value of type 'String' has no member\
    \ 'countElements'\n        count += word.countElements\n                 ~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmpcx46dic6.swift:24:25: error: value of type 'String' has\
    \ no member 'countElements'\n    if count < words[0].countElements {\n       \
    \        ~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty {\n        return \"\"\n    }\n\n    var mostFrequentCount\
    \ = 0\n    var mostFrequentWord = \"\"\n    for word in words {\n        guard\
    \ let charCount = word.unicodeScalars.filter { $0.value == 0 }.count,\n      \
    \      charCount > mostFrequentCount else {\n                continue\n      \
    \  }\n        if charCount > mostFrequentCount {\n            mostFrequentCount\
    \ = charCount\n            mostFrequentWord = word\n        }\n    }\n\n    return\
    \ mostFrequentWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp33205ugx.swift:20:58: warning: trailing closure in this context\
    \ is confusable with the body of the statement; pass as a parenthesized argument\
    \ to silence this warning\n        guard let charCount = word.unicodeScalars.filter\
    \ { $0.value == 0 }.count,\n                                                 \
    \       ~^\n                                                        (        \
    \         )\n/tmp/tmp33205ugx.swift:20:15: error: initializer for conditional\
    \ binding must have Optional type, not 'Int'\n        guard let charCount = word.unicodeScalars.filter\
    \ { $0.value == 0 }.count,\n              ^               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  guard !words.isEmpty else { return \"\" }\n  var maxCount = 0\n  var bestWord:\
    \ String = \"\"\n  for word in words {\n    if word.characters.count == 1 {\n\
    \      if maxCount < word.characters.count {\n        maxCount = word.characters.count\n\
    \        bestWord = word\n      }\n    } else {\n      if maxCount < word.characters.count\
    \ {\n        maxCount = word.characters.count\n        bestWord = word\n     \
    \ }\n    }\n  }\n  return bestWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpfas6z4qz.swift:17:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if word.characters.count == 1 {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpfas6z4qz.swift:18:26:\
    \ error: 'characters' is unavailable: Please use String directly\n      if maxCount\
    \ < word.characters.count {\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpfas6z4qz.swift:19:25: error: 'characters'\
    \ is unavailable: Please use String directly\n        maxCount = word.characters.count\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpfas6z4qz.swift:23:26: error: 'characters' is unavailable:\
    \ Please use String directly\n      if maxCount < word.characters.count {\n  \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpfas6z4qz.swift:24:25: error: 'characters' is unavailable:\
    \ Please use String directly\n        maxCount = word.characters.count\n     \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxWord = \"\"\n\n    for word in words {\n\
    \        var count = word.characters.count\n        if count > maxCount {\n  \
    \          maxCount = count\n            maxWord = word\n        }\n    }\n\n\
    \    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpv9w6xw_u.swift:17:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        var count = word.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpv9w6xw_u.swift:17:13: warning: variable 'count' was never mutated;\
    \ consider changing to 'let' constant\n        var count = word.characters.count\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = \"\"\n    for word in words {\n        let uniqueCount = count(word:\
    \ word, from: words)\n        if uniqueCount > count(word: max, from: words) {\n\
    \            max = word\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmplz9ywzc3.swift:15:27: error: cannot find 'count' in scope\n   \
    \     let uniqueCount = count(word: word, from: words)\n                     \
    \     ^~~~~\n/tmp/tmplz9ywzc3.swift:16:26: error: cannot find 'count' in scope\n\
    \        if uniqueCount > count(word: max, from: words) {\n                  \
    \       ^~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    // Your code here\n    // Write your code here\n    var longest\
    \ = \"\"\n    var max = 0\n    for word in words {\n        tmp = word_count(word)\n\
    \        if tmp > max {\n            max = tmp\n            longest = word\n \
    \       }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpqztuv5uo.swift:19:9: error: cannot find 'tmp' in scope\n      \
    \  tmp = word_count(word)\n        ^~~\n/tmp/tmpqztuv5uo.swift:19:15: error: cannot\
    \ find 'word_count' in scope\n        tmp = word_count(word)\n              ^~~~~~~~~~\n\
    /tmp/tmpqztuv5uo.swift:20:12: error: cannot find 'tmp' in scope\n        if tmp\
    \ > max {\n           ^~~\n/tmp/tmpqztuv5uo.swift:21:19: error: cannot find 'tmp'\
    \ in scope\n            max = tmp\n                  ^~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    var max = \"\"\n    var maxCount = 0\n    for word in words {\n\
    \        if word == max {\n            continue\n        }\n        if let count\
    \ = word.characters.count {\n            if maxCount < count {\n             \
    \   max = word\n                maxCount = count\n            }\n        }\n \
    \   }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp0cha43_1.swift:20:29: error: 'characters' is unavailable: Please\
    \ use String directly\n        if let count = word.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp0cha43_1.swift:20:12: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n        if let count = word.characters.count\
    \ {\n           ^           ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maxCharCount = 0\n  var maxChar: String = String()\n  var maxStr: String\
    \ = String()\n  for word in words {\n    if word == \"\" {\n      continue\n \
    \   }\n    var wordCharCount = 0\n    for char in word {\n      if char == ' '\
    \ || char == '\\t' || char == '\\n' || char == '\\0' {\n        continue\n   \
    \   }\n      if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char\
    \ == 'u' || char == 'A' || char == 'E' || char == 'I' || char == 'O' || char ==\
    \ 'U' {\n        charCount += 2\n      }\n      if char == 'c' || char == 'h'\
    \ || char == 'k' || char == 'l' || char == 'm' || char == 'n' || char == 'p' ||\
    \ char == 'r' || char == 's' || char == 't' || char == 'v' || char == 'A' || char\
    \ == 'C' || char == 'H' || char == 'K' || char == 'L' || char == 'M' || char ==\
    \ 'N' || char == 'P' || char == 'R' || char == 'S' || char == 'T' || char == 'V'\
    \ {\n        charCount += 1\n      }\n      charCount += 1\n    }\n    if wordCharCount\
    \ > maxCharCount {\n      maxCharCount = wordCharCount\n      maxChar = word\n\
    \      maxStr = word\n    }\n  }\n  return maxChar\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpo_ul73c_.swift:22:18: error: single-quoted string literal found,\
    \ use '\"'\n      if char == ' ' || char == '\\t' || char == '\\n' || char ==\
    \ '\\0' {\n                 ^~~\n                 \" \"\n/tmp/tmpo_ul73c_.swift:22:33:\
    \ error: single-quoted string literal found, use '\"'\n      if char == ' ' ||\
    \ char == '\\t' || char == '\\n' || char == '\\0' {\n                        \
    \        ^~~~\n                                \"\\t\"\n/tmp/tmpo_ul73c_.swift:22:49:\
    \ error: single-quoted string literal found, use '\"'\n      if char == ' ' ||\
    \ char == '\\t' || char == '\\n' || char == '\\0' {\n                        \
    \                        ^~~~\n                                              \
    \  \"\\n\"\n/tmp/tmpo_ul73c_.swift:22:65: error: single-quoted string literal\
    \ found, use '\"'\n      if char == ' ' || char == '\\t' || char == '\\n' || char\
    \ == '\\0' {\n                                                               \
    \ ^~~~\n                                                                \"\\0\"\
    \n/tmp/tmpo_ul73c_.swift:25:18: error: single-quoted string literal found, use\
    \ '\"'\n      if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char\
    \ == 'u' || char == 'A' || char == 'E' || char == 'I' || char == 'O' || char ==\
    \ 'U' {\n                 ^~~\n                 \"a\"\n/tmp/tmpo_ul73c_.swift:25:33:\
    \ error: single-quoted string literal found, use '\"'\n      if char == 'a' ||\
    \ char == 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'A' || char\
    \ == 'E' || char == 'I' || char == 'O' || char == 'U' {\n                    \
    \            ^~~\n                                \"e\"\n/tmp/tmpo_ul73c_.swift:25:48:\
    \ error: single-quoted string literal found, use '\"'\n      if char == 'a' ||\
    \ char == 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'A' || char\
    \ == 'E' || char == 'I' || char == 'O' || char == 'U' {\n                    \
    \                           ^~~\n                                            \
    \   \"i\"\n/tmp/tmpo_ul73c_.swift:25:63: error: single-quoted string literal found,\
    \ use '\"'\n      if char == 'a' || char == 'e' || char == 'i' || char == 'o' "
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n\tsort.Sort(uniqueByLength(words))\n\treturn words[len(words)-1]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbug2gnl8.swift:13:2: error: cannot find 'sort' in scope\n     \
    \   sort.Sort(uniqueByLength(words))\n        ^~~~\n/tmp/tmpbug2gnl8.swift:13:12:\
    \ error: cannot find 'uniqueByLength' in scope\n        sort.Sort(uniqueByLength(words))\n\
    \                  ^~~~~~~~~~~~~~\n/tmp/tmpbug2gnl8.swift:14:15: error: cannot\
    \ find 'len' in scope\n        return words[len(words)-1]\n                  \
    \   ^~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let sorted = words.sorted()\n    let count = sorted.reduce(0, { (prev,\
    \ curr) -> Int in\n        return prev + (curr.count())\n    })\n    let result\
    \ = sorted.last { $0.count() < count.count() }\n    return result!\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpsv52vsc7.swift:15:29: error: cannot call value of non-function\
    \ type 'Int'\n        return prev + (curr.count())\n                         \
    \   ^    ~~\n                                 \n/tmp/tmpsv52vsc7.swift:17:35:\
    \ error: cannot call value of non-function type 'Int'\n    let result = sorted.last\
    \ { $0.count() < count.count() }\n                                  ^    ~~\n\
    \                                       \n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words == nil || words == \"\" { return \"\" }\n    var result = \"\
    \"\n    var maxNum = 0\n    for str in words {\n        str = str.lowercased()\n\
    \        var numChars = countChars(str)\n        if numChars > maxNum { maxNum\
    \ = numChars }\n        if numChars == 0 { continue }\n        result = findString(str,\
    \ result)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmps3qkqzzn.swift:13:30: error: binary operator '==' cannot be applied\
    \ to operands of type '[String]' and 'String'\n    if words == nil || words ==\
    \ \"\" { return \"\" }\n                       ~~~~~ ^  ~~\n/tmp/tmps3qkqzzn.swift:13:30:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (String, String)\n    if words == nil || words == \"\" { return \"\" }\n   \
    \                          ^\n/tmp/tmps3qkqzzn.swift:17:9: error: cannot assign\
    \ to value: 'str' is a 'let' constant\n        str = str.lowercased()\n      \
    \  ^~~\n/tmp/tmps3qkqzzn.swift:18:24: error: cannot find 'countChars' in scope\n\
    \        var numChars = countChars(str)\n                       ^~~~~~~~~~\n/tmp/tmps3qkqzzn.swift:21:18:\
    \ error: cannot find 'findString' in scope\n        result = findString(str, result)\n\
    \                 ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n\tlet sorted = words.sorted(by: { $0.length < $1.length })\n\treturn sorted[0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp0g5ly8z7.swift:13:37: error: value of type 'String' has no member\
    \ 'length'\n        let sorted = words.sorted(by: { $0.length < $1.length })\n\
    \                                        ~~ ^~~~~~\n/tmp/tmp0g5ly8z7.swift:13:49:\
    \ error: value of type 'String' has no member 'length'\n        let sorted = words.sorted(by:\
    \ { $0.length < $1.length })\n                                               \
    \     ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    switch words {\n    case let words as [String]:\n        guard let max\
    \ = find_max(words) else {\n            return \"<None>\"\n        }\n       \
    \ return max\n    case let words as [String:Any]:\n        guard let max = find_max(words.keys)\
    \ else {\n            return \"<None>\"\n        }\n        return max\n    case\
    \ let words as [Any]:\n        return \"<None>\"\n    default:\n        return\
    \ \"<None>\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp0y0jj636.swift:14:20: warning: 'as' test is always true\n    case\
    \ let words as [String]:\n                   ^\n/tmp/tmp0y0jj636.swift:19:20:\
    \ warning: cast from '[String]' to unrelated type '[String : Any]' always fails\n\
    \    case let words as [String:Any]:\n                   ^~ ~~~~~~~~~~~~\n/tmp/tmp0y0jj636.swift:15:34:\
    \ error: missing argument label 'words:' in call\n        guard let max = find_max(words)\
    \ else {\n                                 ^\n                               \
    \  words: \n/tmp/tmp0y0jj636.swift:20:34: error: missing argument label 'words:'\
    \ in call\n        guard let max = find_max(words.keys) else {\n             \
    \                    ^\n                                 words: \n/tmp/tmp0y0jj636.swift:20:40:\
    \ error: cannot convert value of type 'Dictionary<String, Any>.Keys' to expected\
    \ argument type '[String]'\n        guard let max = find_max(words.keys) else\
    \ {\n                                       ^\n/tmp/tmp0y0jj636.swift:24:10: warning:\
    \ case is already handled by previous patterns; consider removing it\n    case\
    \ let words as [Any]:\n         ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = words[0]\n    for w in words {\n        if w != max && w.hasUniqueChars()\
    \ {\n            max = w\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpaclxrqqx.swift:15:26: error: value of type 'String' has no member\
    \ 'hasUniqueChars'\n        if w != max && w.hasUniqueChars() {\n            \
    \           ~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  // Count all the unique characters\n  var charsCount: [(Character, Int)]\
    \ = [()]\n  for str in words {\n    for char in str.unicodeScalars {\n      charsCount\
    \ = charsCount + [(char, .0)]\n    }\n  }\n\n  // If every character is unique,\
    \ return the longest string in lexicographical\n  // order\n  var maxChar = 0\n\
    \  for char, (count) in charsCount {\n    if count == maxChar {\n      continue\n\
    \    }\n    if count == charsCount.maxElement {\n      maxChar = count\n    }\n\
    \  }\n  return words.first!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpwg7zriqt.swift:17:41: error: '.0' is not a valid floating point\
    \ literal; it must be written '0.0'\n      charsCount = charsCount + [(char, .0)]\n\
    \                                        ^~\n                                \
    \        0\n/tmp/tmpwg7zriqt.swift:24:11: error: expected 'in' after for-each\
    \ pattern\n  for char, (count) in charsCount {\n          ^\n/tmp/tmpwg7zriqt.swift:24:11:\
    \ error: expected Sequence expression for for-each loop\n  for char, (count) in\
    \ charsCount {\n          ^\n/tmp/tmpwg7zriqt.swift:14:41: error: cannot convert\
    \ value of type '()' to expected element type '(Character, Int)'\n  var charsCount:\
    \ [(Character, Int)] = [()]\n                                        ^\n/tmp/tmpwg7zriqt.swift:17:35:\
    \ error: cannot convert value of type 'Unicode.Scalar' to expected element type\
    \ 'Character'\n      charsCount = charsCount + [(char, .0)]\n                \
    \                  ^\n/tmp/tmpwg7zriqt.swift:17:41: error: cannot convert value\
    \ of type 'Double' to expected element type 'Int'\n      charsCount = charsCount\
    \ + [(char, .0)]\n                                        ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  let maxCount = words.reduce(0, {$0 > $1.count})\n  guard maxCount == words.count\
    \ else { return \"\" }\n  return words[maxCount..<words.count].sorted().first!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpct9fib2c.swift:13:38: error: type '()' cannot conform to 'BinaryInteger'\n\
    \  let maxCount = words.reduce(0, {$0 > $1.count})\n                         \
    \            ^\n/tmp/tmpct9fib2c.swift:13:38: note: only concrete types such as\
    \ structs, enums and classes can conform to protocols\n  let maxCount = words.reduce(0,\
    \ {$0 > $1.count})\n                                     ^\n/tmp/tmpct9fib2c.swift:13:38:\
    \ note: required by referencing operator function '>' on 'BinaryInteger' where\
    \ 'Self' = '()'\n  let maxCount = words.reduce(0, {$0 > $1.count})\n         \
    \                            ^\n/tmp/tmpct9fib2c.swift:13:31: error: cannot convert\
    \ value of type 'Int' to expected argument type '()'\n  let maxCount = words.reduce(0,\
    \ {$0 > $1.count})\n                              ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    switch words {\n    case .named(let name):\n        return name\n\
    \    case .unnamed(let words):\n        if words.isEmpty {\n            return\
    \ \"\"\n        } else {\n            return words.min()\n        }\n    case\
    \ .empty(let words):\n        if words.isEmpty {\n            return \"\"\n  \
    \      } else {\n            let unique = words.unique()\n            return unique.first()\n\
    \        }\n    }\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ab5qukj.swift:15:11: error: type '[String]' has no member 'named'\n\
    \    case .named(let name):\n         ~^~~~~\n/tmp/tmp2ab5qukj.swift:17:11: error:\
    \ type '[String]' has no member 'unnamed'\n    case .unnamed(let words):\n   \
    \      ~^~~~~~~\n/tmp/tmp2ab5qukj.swift:23:11: error: type '[String]' has no member\
    \ 'empty'\n    case .empty(let words):\n         ~^~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var result = \"\"\n  var counter = 0\n  for w in words {\n    counter +=\
    \ length(w)\n    result = w if counter > length(result) else result\n  }\n  return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpb30hi7_f.swift:17:15: error: consecutive statements on a line must\
    \ be separated by ';'\n    result = w if counter > length(result) else result\n\
    \              ^\n              ;\n/tmp/tmpb30hi7_f.swift:17:44: error: unexpected\
    \ 'else' immediately following 'if' condition\n    result = w if counter > length(result)\
    \ else result\n                                           ^\n/tmp/tmpb30hi7_f.swift:17:44:\
    \ note: remove 'else' to execute the braced block of statements when the condition\
    \ is true\n    result = w if counter > length(result) else result\n          \
    \                                 ^~~~~\n                                    \
    \       \n/tmp/tmpb30hi7_f.swift:17:49: error: expected '{' after 'if' condition\n\
    \    result = w if counter > length(result) else result\n                    \
    \                            ^\n/tmp/tmpb30hi7_f.swift:16:16: error: cannot find\
    \ 'length' in scope\n    counter += length(w)\n               ^~~~~~\n/tmp/tmpb30hi7_f.swift:17:29:\
    \ error: cannot find 'length' in scope\n    result = w if counter > length(result)\
    \ else result\n                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxNum = 0\n    var maxChar = \"\"\n    for word in words {\n   \
    \     if word[word.index(maxNum, offsetBy: 0)] == maxChar {\n            maxNum\
    \ += 1\n        } else {\n            maxChar = word[word.index(maxNum, offsetBy:\
    \ 0)]\n            maxNum = 1\n        }\n    }\n    return maxChar\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbe15dzcq.swift:16:28: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        if word[word.index(maxNum,\
    \ offsetBy: 0)] == maxChar {\n                           ^\n/tmp/tmpbe15dzcq.swift:16:16:\
    \ error: subscript 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n\
    \        if word[word.index(maxNum, offsetBy: 0)] == maxChar {\n             \
    \  ^\nSwift.Collection:2:23: note: where 'R' = 'String.Index'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get }\n                      ^\n/tmp/tmpbe15dzcq.swift:19:39: error:\
    \ cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \            maxChar = word[word.index(maxNum, offsetBy: 0)]\n               \
    \                       ^\n/tmp/tmpbe15dzcq.swift:19:27: error: cannot assign\
    \ value of type 'Character' to type 'String'\n            maxChar = word[word.index(maxNum,\
    \ offsetBy: 0)]\n                      ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = 0\n    var result = \"\"\n    for word in words {\n       \
    \ if max < word.count {\n            max = word.count\n            result = word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpp2rut4tc/tmpp2rut4tc.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6fb4a92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6fb4789b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6fb4789988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6fb47887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp2rut4tc                        0x00005582ca598823 <unavailable> + 6179

    5    libc.so.6                          0x00002b6fb4c7e460 __libc_start_main +
    245

    6    tmpp2rut4tc                        0x00005582ca598249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  return find_max(&words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp4sul07sx.swift:13:19: error: missing argument label 'words:' in\
    \ call\n  return find_max(&words)\n                  ^\n                  words:\
    \ \n/tmp/tmp4sul07sx.swift:13:19: error: '&' used with non-inout argument of type\
    \ '[String]'\n  return find_max(&words)\n                  ^~~~~~\n          \
    \        \n/tmp/tmp4sul07sx.swift:13:19: error: cannot pass immutable value as\
    \ inout argument: 'words' is a 'let' constant\n  return find_max(&words)\n   \
    \               ^~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max = \"\"\n  var counts = [0]\n  for _, v := range words {\n    counts\
    \ = append(counts, 0)\n  }\n\n  for _, v := range words {\n    for i := 0; i <\
    \ len(words); i++ {\n      for j := 0; j < len(words); j++ {\n        if v ==\
    \ words[j] {\n          counts[i]++\n          counts[j]++\n        }\n      }\n\
    \    }\n\n    if counts[0] > counts[1] {\n      max = v\n      counts[0] = counts[1]\n\
    \    }\n  }\n\n  return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpy9dv7v21.swift:15:8: error: expected 'in' after for-each pattern\n\
    \  for _, v := range words {\n       ^\n/tmp/tmpy9dv7v21.swift:15:8: error: expected\
    \ Sequence expression for for-each loop\n  for _, v := range words {\n       ^\n\
    /tmp/tmpy9dv7v21.swift:19:8: error: expected 'in' after for-each pattern\n  for\
    \ _, v := range words {\n       ^\n/tmp/tmpy9dv7v21.swift:19:8: error: expected\
    \ Sequence expression for for-each loop\n  for _, v := range words {\n       ^\n\
    /tmp/tmpy9dv7v21.swift:20:12: error: expected type\n    for i := 0; i < len(words);\
    \ i++ {\n           ^\n            <#type#>\n/tmp/tmpy9dv7v21.swift:20:12: error:\
    \ expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n\
    \           ^\n/tmp/tmpy9dv7v21.swift:20:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpy9dv7v21.swift:21:14:\
    \ error: expected type\n      for j := 0; j < len(words); j++ {\n            \
    \ ^\n              <#type#>\n/tmp/tmpy9dv7v21.swift:21:14: error: expected 'in'\
    \ after for-each pattern\n      for j := 0; j < len(words); j++ {\n          \
    \   ^\n/tmp/tmpy9dv7v21.swift:21:14: error: expected Sequence expression for for-each\
    \ loop\n      for j := 0; j < len(words); j++ {\n             ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty() {\n        return \"\"\n    }\n    var maxCount =\
    \ 0\n    var maxString = \"\"\n    var maxValue: UInt32 = 0\n    for word in words\
    \ {\n        let value = word.unicodeScalars.reduce(0) { (result, scalar) in\n\
    \            var count = scalar.value\n            if count > maxCount {\n   \
    \             count = maxCount\n            }\n            if value > maxValue\
    \ {\n                maxCount = count\n                maxValue = value\n    \
    \        }\n            return result + count\n        }\n        maxString =\
    \ maxString + String(UnicodeScalar(Character(word.unicodeScalars.first!)))\n \
    \       if value == maxValue {\n            maxString = maxString + String(UnicodeScalar(Character(word.unicodeScalars.last!)))\n\
    \        }\n    }\n    return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpzl0aeczk.swift:13:14: error: cannot call value of non-function\
    \ type 'Bool'\n    if words.isEmpty() {\n             ^      ~~\n            \
    \        \n/tmp/tmpzl0aeczk.swift:23:25: error: cannot assign value of type 'Int'\
    \ to type 'UInt32'\n                count = maxCount\n                       \
    \ ^~~~~~~~\n                        UInt32( )\n/tmp/tmpzl0aeczk.swift:31:40: error:\
    \ no exact matches in call to initializer \n        maxString = maxString + String(UnicodeScalar(Character(word.unicodeScalars.first!)))\n\
    \                                       ^\nSwift.Unicode.Scalar:7:23: note: candidate\
    \ expects value of type 'UInt8' for parameter #1 (got 'Character')\n    @inlinable\
    \ public init(_ v: UInt8)\n                      ^\nSwift.Unicode.Scalar:8:23:\
    \ note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got\
    \ 'Character')\n    @inlinable public init(_ v: Unicode.Scalar)\n            \
    \          ^\n/tmp/tmpzl0aeczk.swift:33:44: error: no exact matches in call to\
    \ initializer \n            maxString = maxString + String(UnicodeScalar(Character(word.unicodeScalars.last!)))\n\
    \                                           ^\nSwift.Unicode.Scalar:7:23: note:\
    \ candidate expects value of type 'UInt8' for parameter #1 (got 'Character')\n\
    \    @inlinable public init(_ v: UInt8)\n                      ^\nSwift.Unicode.Scalar:8:23:\
    \ note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got\
    \ 'Character')\n    @inlinable public init(_ v: Unicode.Scalar)\n            \
    \          ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max_len(words, words.count())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjf7nerur.swift:13:12: error: cannot find 'find_max_len' in scope\n\
    \    return find_max_len(words, words.count())\n           ^~~~~~~~~~~~\n/tmp/tmpjf7nerur.swift:13:38:\
    \ error: cannot call value of non-function type 'Int'\n    return find_max_len(words,\
    \ words.count())\n                                     ^    ~~\n             \
    \                             \n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = \"\"\n    var maxCount = 0\n    for w := 0; w < words.Length;\
    \ w++ {\n        var count = 0\n        for c := 0; c < words[w].Lenght; c++ {\n\
    \            if words[w][c] == max {\n                count = count + 1\n    \
    \        }\n        }\n        if count > maxCount {\n            maxCount = count\n\
    \            max = words[w]\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5cjh12aq.swift:15:12: error: expected type\n    for w := 0; w <\
    \ words.Length; w++ {\n           ^\n            <#type#>\n/tmp/tmp5cjh12aq.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for w := 0; w < words.Length;\
    \ w++ {\n           ^\n/tmp/tmp5cjh12aq.swift:15:12: error: expected Sequence\
    \ expression for for-each loop\n    for w := 0; w < words.Length; w++ {\n    \
    \       ^\n/tmp/tmp5cjh12aq.swift:17:16: error: expected type\n        for c :=\
    \ 0; c < words[w].Lenght; c++ {\n               ^\n                <#type#>\n\
    /tmp/tmp5cjh12aq.swift:17:16: error: expected 'in' after for-each pattern\n  \
    \      for c := 0; c < words[w].Lenght; c++ {\n               ^\n/tmp/tmp5cjh12aq.swift:17:16:\
    \ error: expected Sequence expression for for-each loop\n        for c := 0; c\
    \ < words[w].Lenght; c++ {\n               ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty() {\n        return \"\"\n    }\n    let maxCount =\
    \ countUniqueChars(words[0])\n    var max = words[0]\n    var currentCount = 0\n\
    \    for word in words {\n        if countUniqueChars(word) > maxCount {\n   \
    \         max = word\n            maxCount = countUniqueChars(word)\n        }\n\
    \        currentCount += countUniqueChars(word)\n    }\n    if currentCount >\
    \ maxCount {\n        return max\n    }\n    return find_max(words: words[1..<words.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpfujkikrc.swift:13:14: error: cannot call value of non-function\
    \ type 'Bool'\n    if words.isEmpty() {\n             ^      ~~\n            \
    \        \n/tmp/tmpfujkikrc.swift:16:20: error: cannot find 'countUniqueChars'\
    \ in scope\n    let maxCount = countUniqueChars(words[0])\n                  \
    \ ^~~~~~~~~~~~~~~~\n/tmp/tmpfujkikrc.swift:20:12: error: cannot find 'countUniqueChars'\
    \ in scope\n        if countUniqueChars(word) > maxCount {\n           ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpfujkikrc.swift:22:24: error: cannot find 'countUniqueChars' in scope\n\
    \            maxCount = countUniqueChars(word)\n                       ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpfujkikrc.swift:24:25: error: cannot find 'countUniqueChars' in scope\n\
    \        currentCount += countUniqueChars(word)\n                        ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpfujkikrc.swift:29:33: error: cannot convert value of type 'ArraySlice<String>'\
    \ to expected argument type '[String]'\n    return find_max(words: words[1..<words.count])\n\
    \                                ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    // The longest word in the array.\n    var maxWord = words[0]\n\
    \    var maxCount = 0\n    for word in words {\n        // Count the number of\
    \ unique characters in the word.\n        var count = 1\n        for char in word\
    \ {\n            if word == maxWord {\n                count += maxCount\n   \
    \         } else {\n                count += 1\n            }\n        }\n   \
    \     \n        // If count is greater than the max count, update maxWord.\n \
    \       if count > maxCount {\n            maxWord = word\n            maxCount\
    \ = count\n        }\n    }\n    \n    // If maxCount is 0, return an empty string.\n\
    \    if maxCount == 0 {\n        return \"\"\n    }\n    \n    // If maxCount\
    \ is 1, return the maxWord.\n    if maxCount == 1 {\n        return maxWord\n\
    \    }\n    \n    // If maxCount is > 1, return the word with maxCount unique\
    \ characters.\n    var candidate = maxWord\n    for i in maxCount..<words.count\
    \ {\n        if words[i].index(of: candidate) != 0 {\n            candidate =\
    \ words[i]\n        }\n    }\n    return candidate\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbm5kz0tz.swift:48:17: error: no exact matches in call to subscript\
    \ \n        if words[i].index(of: candidate) != 0 {\n                ^\nSwift.Array:17:23:\
    \ note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n\
    \    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {\
    \ get set }\n                      ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\nSwift.MutableCollection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words[findMax(words)]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmptoosbdq0.swift:13:18: error: cannot find 'findMax' in scope\n \
    \   return words[findMax(words)]\n                 ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    type T = [String]\n    \n    var maxCount = 0\n    var maxWord = \"\"\
    \n    var wordToCount = T()\n    \n    for word in words {\n        \n       \
    \ // check whether this word has unique characters\n        var count = Strings.count(word)\n\
    \        \n        // if the word has no unique characters\n        if count ==\
    \ 0 {\n            \n            // set maxWord\n            if count > maxCount\
    \ {\n                maxCount = count\n                maxWord = word\n      \
    \      }\n            \n            // set wordToCount\n            wordToCount.append(word)\n\
    \            \n        // if the word has unique characters\n        } else {\n\
    \            \n            // set maxWord\n            if count > maxCount {\n\
    \                maxCount = count\n                maxWord = word\n          \
    \  }\n            \n            // set wordToCount\n            var wordToCountIndex\
    \ = -1\n            for wordToCountIndex in 0..<wordToCount.count {\n        \
    \        if wordToCount[wordToCountIndex] != word {\n                    break\n\
    \                }\n            }\n            \n            if wordToCountIndex\
    \ != -1 {\n                wordToCount[wordToCountIndex] = word\n            }\n\
    \        }\n    }\n    \n    // if maxWord has not been set\n    if maxWord ==\
    \ \"\" {\n        maxWord = words[0]\n    }\n    \n    // sort the wordToCount\
    \ array\n    wordToCount = wordToCount.sorted()\n    \n    // find the word with\
    \ maximum number of unique characters\n    for wordToCountIndex in 0..<wordToCount.count\
    \ {\n        \n        if wordToCount[wordToCountIndex] == maxWord {\n       \
    \     return wordToCount[wordToCountIndex]\n        }\n    }\n    \n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ux9tg41.swift:13:9: error: consecutive statements on a line must\
    \ be separated by ';'\n    type T = [String]\n        ^\n        ;\n/tmp/tmp7ux9tg41.swift:13:5:\
    \ error: type of expression is ambiguous without more context\n    type T = [String]\n\
    \    ^~~~\n/tmp/tmp7ux9tg41.swift:13:10: error: cannot find 'T' in scope\n   \
    \ type T = [String]\n         ^\n/tmp/tmp7ux9tg41.swift:17:23: error: cannot find\
    \ 'T' in scope\n    var wordToCount = T()\n                      ^\n/tmp/tmp7ux9tg41.swift:22:21:\
    \ error: cannot find 'Strings' in scope\n        var count = Strings.count(word)\n\
    \                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n\tlet maxKey = words[0]\n\tlet maxValue = words[0]\n\tlet maxCount = 1\n\t\
    for word in words {\n\t\tif word == maxKey {\n\t\t\tcontinue\n\t\t}\n\t\tlet value\
    \ = countUniqueChar(word)\n\t\tif value > maxValue {\n\t\t\tmaxValue = value\n\
    \t\t\tmaxKey = word\n\t\t}\n\t\tmaxCount += 1\n\t}\n\treturn maxKey\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmphe0dszv4.swift:20:15: error: cannot find 'countUniqueChar' in scope\n\
    \                let value = countUniqueChar(word)\n                         \
    \   ^~~~~~~~~~~~~~~\n/tmp/tmphe0dszv4.swift:22:4: error: cannot assign to value:\
    \ 'maxValue' is a 'let' constant\n                        maxValue = value\n \
    \                       ^~~~~~~~\n/tmp/tmphe0dszv4.swift:14:2: note: change 'let'\
    \ to 'var' to make it mutable\n        let maxValue = words[0]\n        ^~~\n\
    \        var\n/tmp/tmphe0dszv4.swift:23:4: error: cannot assign to value: 'maxKey'\
    \ is a 'let' constant\n                        maxKey = word\n               \
    \         ^~~~~~\n/tmp/tmphe0dszv4.swift:13:2: note: change 'let' to 'var' to\
    \ make it mutable\n        let maxKey = words[0]\n        ^~~\n        var\n/tmp/tmphe0dszv4.swift:25:12:\
    \ error: left side of mutating operator isn't mutable: 'maxCount' is a 'let' constant\n\
    \                maxCount += 1\n                ~~~~~~~~ ^\n/tmp/tmphe0dszv4.swift:15:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let maxCount = 1\n \
    \       ^~~\n        var\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // count the number of characters\n    // create a set of unique characters\n\
    \    // sort lexicographically and return the one that comes first\n    \n   \
    \ var charCounts = Dictionary<Int, Int>()\n    for word in words {\n        for\
    \ char in word {\n            if charCounts.contains(char) {\n               \
    \ charCounts[char] = charCounts[char] + 1\n            } else {\n            \
    \    charCounts[char] = 1\n            }\n        }\n    }\n    \n    var maxCharCount\
    \ = 0\n    var maxChar = \"\"\n    var sortedWords = Dictionary(uniqueKeysWithValues:\
    \ true)\n    for char in charCounts {\n        if charCounts[char] > maxCharCount\
    \ {\n            maxCharCount = charCounts[char]\n            maxChar = char\n\
    \        }\n    }\n    \n    return sortedWords[maxChar]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp4ht3th9n.swift:20:36: error: missing argument label 'where:' in\
    \ call\n            if charCounts.contains(char) {\n                         \
    \          ^\n                                   where: \n/tmp/tmp4ht3th9n.swift:20:36:\
    \ error: cannot convert value of type 'Character' to expected argument type '(Dictionary<Int,\
    \ Int>.Element) throws -> Bool' (aka '((key: Int, value: Int)) throws -> Bool')\n\
    \            if charCounts.contains(char) {\n                                \
    \   ^\n/tmp/tmp4ht3th9n.swift:21:46: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n                charCounts[char] = charCounts[char]\
    \ + 1\n                                             ^\n/tmp/tmp4ht3th9n.swift:21:46:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n                charCounts[char] = charCounts[char] + 1\n           \
    \                                  ^\n                                   (   \
    \             ?? <#default value#>)\n/tmp/tmp4ht3th9n.swift:21:46: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \        charCounts[char] = charCounts[char] + 1\n                           \
    \                  ^\n                                                   !\n/tmp/tmp4ht3th9n.swift:21:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \                charCounts[char] = charCounts[char] + 1\n                   \
    \        ^\n/tmp/tmp4ht3th9n.swift:21:47: error: cannot convert value of type\
    \ 'Character' to expected argument type 'Int'\n                charCounts[char]\
    \ = charCounts[char] + 1\n                                              ^\n/tmp/tmp4ht3th9n.swift:23:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \                charCounts[char] = 1\n                           ^\n/tmp/tmp4ht3th9n.swift:30:23:\
    \ error: initializer 'init(uniqueKeysWithValues:)' requires that 'Bool' conform\
    \ to 'Sequence'\n    var sortedWords = Dictionary(uniqueKeysWithValues: true)\n\
    \                      ^"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n\tvar result: String = words[0]\n\tvar numUniqueChars: Int = 0\n\n\tfor _,\
    \ word := range words {\n\t\tif !is_unique(word, &numUniqueChars) {\n\t\t\tbreak\n\
    \t\t}\n\n\t\tif numUniqueChars > result.countByValue() {\n\t\t\tresult = word\n\
    \t\t}\n\t}\n\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbny94kz_.swift:16:7: error: expected 'in' after for-each pattern\n\
    \        for _, word := range words {\n             ^\n/tmp/tmpbny94kz_.swift:16:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, word :=\
    \ range words {\n             ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = \"\"\n    var maxCount = 0\n    for w in words {\n        var\
    \ count = 0\n        for _, b in w.unicodeScalars {\n            if !(b&0xff000000)\
    \ {\n                count++\n            }\n        }\n        if count > maxCount\
    \ {\n            max = w\n            maxCount = count\n        }\n    }\n   \
    \ return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbl1z03ok.swift:17:14: error: expected 'in' after for-each pattern\n\
    \        for _, b in w.unicodeScalars {\n             ^\n/tmp/tmpbl1z03ok.swift:17:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, b in w.unicodeScalars\
    \ {\n             ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.reduce((max: String, current: String) -> String in\n   \
    \     if current.characters.count > max.characters.count {\n            return\
    \ current\n        }\n        return max\n    )\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9rnqyf0e.swift:13:66: error: expected ',' separator\n    return\
    \ words.reduce((max: String, current: String) -> String in\n                 \
    \                                                ^\n                         \
    \                                       ,\n/tmp/tmp9rnqyf0e.swift:13:66: error:\
    \ expected expression in list of expressions\n    return words.reduce((max: String,\
    \ current: String) -> String in\n                                            \
    \                     ^\n/tmp/tmp9rnqyf0e.swift:13:65: error: missing argument\
    \ for parameter #2 in call\n    return words.reduce((max: String, current: String)\
    \ -> String in\n                                                             \
    \   ^\n                                                                , <#(((String,\
    \ String) -> String).Type, String) throws -> ((String, String) -> String).Type#>\n\
    Swift.Sequence:2:28: note: 'reduce' declared here\n    @inlinable public func\
    \ reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult:\
    \ Result, Self.Element) throws -> Result) rethrows -> Result\n               \
    \            ^\n/tmp/tmp9rnqyf0e.swift:13:18: error: cannot convert return expression\
    \ of type '((String, String) -> String).Type' to return type 'String'\n    return\
    \ words.reduce((max: String, current: String) -> String in\n           ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n\tvar max := 0\n\tvar key := \"\"\n\tfor _, word := range words {\n\t\tif\
    \ strings.Count(word, \"a\") > max {\n\t\t\tmax = strings.Count(word, \"a\")\n\
    \t\t\tkey = word\n\t\t}\n\t}\n\treturn key\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqspgojmo.swift:13:11: error: expected type\n        var max :=\
    \ 0\n                 ^\n                  <#type#>\n/tmp/tmpqspgojmo.swift:14:11:\
    \ error: expected type\n        var key := \"\"\n                 ^\n        \
    \          <#type#>\n/tmp/tmpqspgojmo.swift:15:7: error: expected 'in' after for-each\
    \ pattern\n        for _, word := range words {\n             ^\n/tmp/tmpqspgojmo.swift:15:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, word :=\
    \ range words {\n             ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let maxKey = Dictionary(grouping: words) { (word, count) in\n       \
    \ return word.count * word\n    }\n    var maxVal = countToKey(maxKey)\n    for\
    \ word in words {\n        if let count = maxVal[key: countToKey(word)] {\n  \
    \          if count > maxVal.count {\n                maxVal = countToKey(word)\n\
    \            }\n        }\n    }\n    return maxVal.key\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpngqfm_rs.swift:13:48: error: contextual closure type '(String)\
    \ throws -> Key' expects 1 argument, but 2 were used in closure body\n    let\
    \ maxKey = Dictionary(grouping: words) { (word, count) in\n                  \
    \                             ^\n/tmp/tmpngqfm_rs.swift:16:18: error: cannot find\
    \ 'countToKey' in scope\n    var maxVal = countToKey(maxKey)\n               \
    \  ^~~~~~~~~~\n/tmp/tmpngqfm_rs.swift:18:36: error: cannot find 'countToKey' in\
    \ scope\n        if let count = maxVal[key: countToKey(word)] {\n            \
    \                       ^~~~~~~~~~\n/tmp/tmpngqfm_rs.swift:20:26: error: cannot\
    \ find 'countToKey' in scope\n                maxVal = countToKey(word)\n    \
    \                     ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  guard let sortedArray = words.sorted() else { return \"\" }\n  let result\
    \ = sortedArray[0]\n  for element in sortedArray.dropFirst() {\n    var count\
    \ = 0\n    for char in element {\n      if !result.hasPrefix(char) {\n       \
    \ result = char + String(count)\n      }\n      count = count + 1\n    }\n  }\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp6r9of2qs.swift:13:9: error: initializer for conditional binding\
    \ must have Optional type, not '[String]'\n  guard let sortedArray = words.sorted()\
    \ else { return \"\" }\n        ^                 ~~~~~~~~~~~~~~\n/tmp/tmp6r9of2qs.swift:18:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \      if !result.hasPrefix(char) {\n                           ^\n/tmp/tmp6r9of2qs.swift:19:18:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result = char + String(count)\n                 ^\n/tmp/tmp6r9of2qs.swift:19:9:\
    \ error: cannot assign to value: 'result' is a 'let' constant\n        result\
    \ = char + String(count)\n        ^~~~~~\n/tmp/tmp6r9of2qs.swift:14:3: note: change\
    \ 'let' to 'var' to make it mutable\n  let result = sortedArray[0]\n  ^~~\n  var\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max: String = \"\"\n  var maxCharCount: Int = 0\n  for word in words\
    \ {\n    var charCount = 0\n    for char in word {\n      if charCount.charCount\
    \ > maxCharCount {\n        max = word\n        maxCharCount = charCount\n   \
    \   }\n      charCount += 1\n    }\n  }\n  return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmph7r4pw0e.swift:18:20: error: value of type 'Int' has no member\
    \ 'charCount'\n      if charCount.charCount > maxCharCount {\n         ~~~~~~~~~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  if words.isEmpty() {\n    return \"nothing\"\n  }\n  if words.count ==\
    \ 1 {\n    return words[0]\n  }\n  \n  var maxCount = 0\n  \n  var maxWord = \"\
    \"\n  \n  for word in words {\n    var count = 0\n    for char in word {\n   \
    \   if char != word[0] {\n        count += 1\n      }\n    }\n    \n    if count\
    \ > maxCount {\n      maxCount = count\n      maxWord = word\n    }\n  }\n  \n\
    \  return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvwm0n3p.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n  if words.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpxvwm0n3p.swift:27:18: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n      if char !=\
    \ word[0] {\n                 ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max(words.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpwws1gvhu.swift:13:21: error: missing argument label 'words:' in\
    \ call\n    return find_max(words.sorted())\n                    ^\n         \
    \           words: \n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: Int = 0\n    var result: String = \"\"\n    for word in words\
    \ {\n        charCount := count_chars(word)\n        if charCount > max {\n  \
    \          max = charCount\n            result = word\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpmk4z2_jl.swift:16:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        charCount := count_chars(word)\n              \
    \   ^\n                 ;\n/tmp/tmpmk4z2_jl.swift:16:19: error: expected expression\n\
    \        charCount := count_chars(word)\n                  ^\n/tmp/tmpmk4z2_jl.swift:16:9:\
    \ error: cannot find 'charCount' in scope\n        charCount := count_chars(word)\n\
    \        ^~~~~~~~~\n/tmp/tmpmk4z2_jl.swift:17:12: error: cannot find 'charCount'\
    \ in scope\n        if charCount > max {\n           ^~~~~~~~~\n/tmp/tmpmk4z2_jl.swift:18:19:\
    \ error: cannot find 'charCount' in scope\n            max = charCount\n     \
    \             ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // TODO: check words and return \"too long\" if there are too many unique\
    \ characters\n    var maxCount = 0\n    var maxIndex = 0\n    for idx, word :=\
    \ range words {\n        count := countUnique(word)\n        if count > maxCount\
    \ {\n            maxCount = count\n            maxIndex = idx\n        }\n   \
    \ }\n    if maxCount > 1 {\n        return words[maxIndex]\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp7c_y5pdh.swift:16:12: error: expected 'in' after for-each pattern\n\
    \    for idx, word := range words {\n           ^\n/tmp/tmp7c_y5pdh.swift:16:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, word :=\
    \ range words {\n           ^\n/tmp/tmp7c_y5pdh.swift:17:14: error: consecutive\
    \ statements on a line must be separated by ';'\n        count := countUnique(word)\n\
    \             ^\n             ;\n/tmp/tmp7c_y5pdh.swift:17:15: error: expected\
    \ expression\n        count := countUnique(word)\n              ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    strings.Sort()\n    var max = String()\n    var maxCount = 0\n    for\
    \ _, w := range words {\n        if w == max {\n            continue\n       \
    \ }\n        if strings.HasPrefix(w, max) {\n            continue\n        }\n\
    \        if strings.HasPrefix(max, w) {\n            continue\n        }\n   \
    \     if strings.HasSuffix(w, max) {\n            continue\n        }\n      \
    \  if strings.HasSuffix(max, w) {\n            continue\n        }\n        maxCount\
    \ = 0\n        for _, c := range w {\n            if c == max[0] {\n         \
    \       maxCount++\n            }\n        }\n        if maxCount > 1 {\n    \
    \        continue\n        }\n        max = w\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmppcsdpnry.swift:16:10: error: expected 'in' after for-each pattern\n\
    \    for _, w := range words {\n         ^\n/tmp/tmppcsdpnry.swift:16:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, w := range words\
    \ {\n         ^\n/tmp/tmppcsdpnry.swift:33:14: error: expected 'in' after for-each\
    \ pattern\n        for _, c := range w {\n             ^\n/tmp/tmppcsdpnry.swift:33:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, c := range\
    \ w {\n             ^\n/tmp/tmppcsdpnry.swift:13:5: error: cannot find 'strings'\
    \ in scope\n    strings.Sort()\n    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 1\n    var maxWord: String = \"\"\n    for word in words\
    \ {\n        for letter in word {\n            if letter in words {\n        \
    \        continue\n            }\n            if letter in maxWord {\n       \
    \         continue\n            }\n            if letter == maxCount {\n     \
    \           continue\n            }\n            maxCount = letter\n         \
    \   maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpdylh5o51.swift:17:23: error: expected '{' after 'if' condition\n\
    \            if letter in words {\n                      ^\n/tmp/tmpdylh5o51.swift:20:23:\
    \ error: expected '{' after 'if' condition\n            if letter in maxWord {\n\
    \                      ^\n/tmp/tmpdylh5o51.swift:17:16: error: cannot convert\
    \ value of type 'Character' to expected condition type 'Bool'\n            if\
    \ letter in words {\n               ^~~~~~\n/tmp/tmpdylh5o51.swift:20:16: error:\
    \ cannot convert value of type 'Character' to expected condition type 'Bool'\n\
    \            if letter in maxWord {\n               ^~~~~~\n/tmp/tmpdylh5o51.swift:23:23:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'Int'\n            if letter == maxCount {\n               ~~~~~~ ^  ~~~~~~~~\n\
    /tmp/tmpdylh5o51.swift:23:23: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (Int, Int)\n            if\
    \ letter == maxCount {\n                      ^\n/tmp/tmpdylh5o51.swift:26:24:\
    \ error: cannot assign value of type 'Character' to type 'Int'\n            maxCount\
    \ = letter\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  return find_max(words: words, n: 0)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjv_3h2ai.swift:13:36: error: extra argument 'n' in call\n  return\
    \ find_max(words: words, n: 0)\n                 ~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCharCount: Int = 0\n    var maxWord: String = \"\"\n    for word\
    \ in words {\n        let charCount = word.characters.count\n        if charCount\
    \ > maxCharCount {\n            maxWord = word\n            maxCharCount = charCount\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpgg21sr3g.swift:16:30: error: 'characters' is unavailable: Please\
    \ use String directly\n        let charCount = word.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max: String = words[0]\n  for word in words {\n    if word.count >\
    \ max.count {\n      max = word\n    }\n  }\n  return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpjrdbpax6/tmpjrdbpax6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf48d55c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf48a4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf48a4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf48a4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjrdbpax6                        0x0000557bd4052873 <unavailable> + 6259

    5    libc.so.6                          0x00002aaf48f41460 __libc_start_main +
    245

    6    tmpjrdbpax6                        0x0000557bd4052299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: String = \"\"\n    var maxCount = 0\n    for word in words {\n\
    \        var wordCount: Int = 0\n        for letter in word {\n            wordCount\
    \ += unique[letter]!.count\n        }\n        if wordCount > maxCount {\n   \
    \         max = word\n            maxCount = wordCount\n        }\n    }\n   \
    \ return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ryplimb.swift:18:26: error: cannot find 'unique' in scope\n  \
    \          wordCount += unique[letter]!.count\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let nums = words.map { $0.characters.count }\n    let maxIndex = nums.maxIndex(of:\
    \ UInt32.init)\n    if maxIndex == nums.count {\n        return \"\"\n    } else\
    \ {\n        return words[maxIndex]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqsnsh_j5.swift:13:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let nums = words.map { $0.characters.count }\n    \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpqsnsh_j5.swift:14:25: error: value of type '[Int]' has\
    \ no member 'maxIndex'\n    let maxIndex = nums.maxIndex(of: UInt32.init)\n  \
    \                 ~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    switch words {\n    case let words as [String]?:\n        return find_max(words:\
    \ words)\n    case let words as String[]:\n        let count = words.reduce(0,\
    \ { ($0, $1) })\n        return count==words.count ? words[0] : find_max(words:\
    \ words.filter({$0==count}))\n    default:\n        return \"ERROR\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp30p9s14c.swift:16:29: error: array types are now written with the\
    \ brackets around the element type\n    case let words as String[]:\n        \
    \                    ^\n                      [     \n/tmp/tmp30p9s14c.swift:16:20:\
    \ warning: 'as' test is always true\n    case let words as String[]:\n       \
    \            ^\n/tmp/tmp30p9s14c.swift:15:32: error: value of optional type '[String]?'\
    \ must be unwrapped to a value of type '[String]'\n        return find_max(words:\
    \ words)\n                               ^\n/tmp/tmp30p9s14c.swift:15:32: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        return find_max(words: words)\n                               ^\n   \
    \                                  ?? <#default value#>\n/tmp/tmp30p9s14c.swift:15:32:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return find_max(words: words)\n                             \
    \  ^\n                                    !\n/tmp/tmp30p9s14c.swift:17:39: error:\
    \ cannot convert value of type '(Int, String)' to closure result type 'Int'\n\
    \        let count = words.reduce(0, { ($0, $1) })\n                         \
    \             ^~~~~~~~\n/tmp/tmp30p9s14c.swift:16:10: warning: case is already\
    \ handled by previous patterns; consider removing it\n    case let words as String[]:\n\
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.reduce((max: String, value: String) -> String in\n     \
    \   guard let value = value.characters.flatMap { String($0) }.sorted else {\n\
    \            return max\n        }\n        if max == value {\n            return\
    \ max\n        } else {\n            return value\n        }\n    )\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpc9c0vk80.swift:13:64: error: expected ',' separator\n    return\
    \ words.reduce((max: String, value: String) -> String in\n                   \
    \                                            ^\n                             \
    \                                 ,\n/tmp/tmpc9c0vk80.swift:13:64: error: expected\
    \ expression in list of expressions\n    return words.reduce((max: String, value:\
    \ String) -> String in\n                                                     \
    \          ^\n/tmp/tmpc9c0vk80.swift:14:73: error: consecutive statements on a\
    \ line must be separated by ';'\n        guard let value = value.characters.flatMap\
    \ { String($0) }.sorted else {\n                                             \
    \                           ^\n                                              \
    \                          ;\n/tmp/tmpc9c0vk80.swift:14:74: error: expected expression\n\
    \        guard let value = value.characters.flatMap { String($0) }.sorted else\
    \ {\n                                                                        \
    \ ^\n/tmp/tmpc9c0vk80.swift:22:5: error: expected expression\n    )\n    ^\n/tmp/tmpc9c0vk80.swift:13:63:\
    \ error: missing argument for parameter #2 in call\n    return words.reduce((max:\
    \ String, value: String) -> String in\n                                      \
    \                        ^\n                                                 \
    \             , <#(((String, String) -> String).Type, String) throws -> ((String,\
    \ String) -> String).Type#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n\
    \    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult:\
    \ (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n/tmp/tmpc9c0vk80.swift:13:18: error: cannot convert\
    \ return expression of type '((String, String) -> String).Type' to return type\
    \ 'String'\n    return words.reduce((max: String, value: String) -> String in\n\
    \           ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpc9c0vk80.swift:14:27:\
    \ error: use of local variable 'value' before its declaration\n        gu"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let counts = words.reduce([String: Int](), combine: {\n        (counts,\
    \ word: String) in\n        counts[word] = (counts[word] ?? 0) + 1\n        return\
    \ counts\n    })\n    return words.filter{$0.value.count == counts.value.max}\
    \ .first!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp9lbcu8ds.swift:13:30: error: extraneous argument label 'combine:'\
    \ in call\n    let counts = words.reduce([String: Int](), combine: {\n       \
    \                      ^                 ~~~~~~~~~\n                         \
    \                      \n/tmp/tmp9lbcu8ds.swift:15:15: error: cannot assign through\
    \ subscript: 'counts' is a 'let' constant\n        counts[word] = (counts[word]\
    \ ?? 0) + 1\n        ~~~~~~^\n/tmp/tmp9lbcu8ds.swift:18:28: error: value of type\
    \ 'String' has no member 'value'\n    return words.filter{$0.value.count == counts.value.max}\
    \ .first!\n                        ~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max = \"\"\n  var maxCount = 0\n  for w in words {\n    if w.countUnique\
    \ < maxCount {\n      max = w\n      maxCount = w.countUnique\n    }\n  }\n  return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpjllkm_lm.swift:16:10: error: value of type 'String' has no member\
    \ 'countUnique'\n    if w.countUnique < maxCount {\n       ~ ^~~~~~~~~~~\n/tmp/tmpjllkm_lm.swift:18:20:\
    \ error: value of type 'String' has no member 'countUnique'\n      maxCount =\
    \ w.countUnique\n                 ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var wordCounts = Dictionary()\n    for word in words {\n        wordCounts[word]\
    \ = (wordCounts[word] ?? 0) + 1\n    }\n    if wordCounts.count > 1 {\n      \
    \  var max = wordCounts.first\n        for word in words {\n            if wordCounts[word]\
    \ > wordCounts[max] {\n                max = word\n            }\n        }\n\
    \        return max\n    } else {\n        return words[0]\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpehyk4lwn.swift:13:22: error: generic parameter 'Key' could not\
    \ be inferred\n    var wordCounts = Dictionary()\n                     ^\n/tmp/tmpehyk4lwn.swift:13:22:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var wordCounts\
    \ = Dictionary()\n                     ^\n                               <<#Key:\
    \ Hashable#>, Any>\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return max(words, count).0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpgd02bi09.swift:13:23: error: cannot find 'count' in scope\n   \
    \ return max(words, count).0\n                      ^~~~~\n/tmp/tmpgd02bi09.swift:13:30:\
    \ error: value of type '[String]' has no member '0'\n    return max(words, count).0\n\
    \           ~~~~~~~~~~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.sorted().reduce(into: \"\") {\n        if let last = $1.characters.count\
    \ {\n            if last > $1.characters.count {\n                $0.append(contentsOf:\
    \ $1)\n                $1.removeLast()\n            }\n        } else {\n    \
    \        $0.append(contentsOf: $1)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpu3yp0lrk.swift:17:20: error: cannot use mutating member on immutable\
    \ value: '$1' is immutable\n                $1.removeLast()\n                ~~\
    \ ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maximum = String()\n  var maxCount = 0\n  for word in words {\n   \
    \ if count := count(word); count > maxCount {\n      maximum = word\n      maxCount\
    \ = count\n    }\n  }\n  return maximum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmppzd2bzqa.swift:16:14: error: expected '{' after 'if' condition\n\
    \    if count := count(word); count > maxCount {\n             ^\n/tmp/tmppzd2bzqa.swift:16:8:\
    \ error: cannot find 'count' in scope\n    if count := count(word); count > maxCount\
    \ {\n       ^~~~~\n/tmp/tmppzd2bzqa.swift:18:18: error: cannot find 'count' in\
    \ scope\n      maxCount = count\n                 ^~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max_(words, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpgwj37qtb.swift:13:12: error: cannot find 'find_max_' in scope\n\
    \    return find_max_(words, nil)\n           ^~~~~~~~~\n/tmp/tmpgwj37qtb.swift:13:29:\
    \ error: 'nil' requires a contextual type\n    return find_max_(words, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.count == 0 {\n        return \"\"\n    }\n\n    var maxCount\
    \ = 0\n    var maxStr = \"\"\n\n    for word in words {\n        var count = 0\n\
    \        for char in word {\n            count += 1\n        }\n        if count\
    \ > maxCount {\n            maxCount = count\n            maxStr = word\n    \
    \    }\n    }\n    return maxStr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpsazelnnd/tmpsazelnnd.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ede2c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1eddfbcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1eddfbc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1eddfbb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsazelnnd                        0x000055cee43f88d3 <unavailable> + 6355

    5    libc.so.6                          0x00002b1ede4b1460 __libc_start_main +
    245

    6    tmpsazelnnd                        0x000055cee43f82f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013707
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxString = \"\"\n    for w in words {\n  \
    \      let count = words.filter{ $0 == w }.count\n        if count > maxCount\
    \ {\n            maxCount = count\n            maxString = w\n        }\n    }\n\
    \    return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpxze1lb_8/tmpxze1lb_8.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5401ac2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b54017b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b54017b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54017b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxze1lb_8                        0x00005599ba9a374e <unavailable> + 5966

    5    libc.so.6                          0x00002b5401cae460 __libc_start_main +
    245

    6    tmpxze1lb_8                        0x00005599ba9a3309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  words.sortInPlace()\n  return words[words.indexOf(words[words.count])]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpott_ssac.swift:13:9: error: value of type '[String]' has no member\
    \ 'sortInPlace'\n  words.sortInPlace()\n  ~~~~~ ^~~~~~~~~~~\n/tmp/tmpott_ssac.swift:14:22:\
    \ error: value of type '[String]' has no member 'indexOf'\n  return words[words.indexOf(words[words.count])]\n\
    \               ~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max: String = \"\"\n  var maxCount: Int = 0\n\n  for word in words\
    \ {\n    if maxCount == 0 {\n      max = word\n      maxCount = word.count\n \
    \   } else {\n      if maxCount > word.count {\n        max = word\n        maxCount\
    \ = word.count\n      }\n    }\n  }\n\n  return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpt8eonv8u/tmpt8eonv8u.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3f3f3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3f3c31b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae3f3c31988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae3f3c307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt8eonv8u                        0x000055feefbdf68e <unavailable> + 5774

    5    libc.so.6                          0x00002ae3f4126460 __libc_start_main +
    245

    6    tmpt8eonv8u                        0x000055feefbdf249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var result: Character? = nil\n  for word in words {\n    let count = countUniqueChars(word)\n\
    \    if let result = count {\n      if count > result[word.startIndex]! {\n  \
    \      result = word\n      }\n    }\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpsanxkwbd.swift:15:17: error: cannot find 'countUniqueChars' in\
    \ scope\n    let count = countUniqueChars(word)\n                ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpsanxkwbd.swift:22:10: error: cannot convert return expression of type\
    \ 'Character?' to return type 'String'\n  return result\n         ^~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // use an auxiliary array to count the number of chars for each word\n\
    \    var charCounts = [String: Int]()\n    for w in words {\n        charCounts[w]\
    \ = count(w)\n    }\n    // find the word with max chars\n    var max = 0\n  \
    \  var maxCharCount = 0\n    for (chars, w) in charCounts {\n        if w > max\
    \ {\n            max = w\n            maxCharCount = chars\n        }\n    }\n\
    \    // return null if there are no words\n    if max == 0 {\n        return \"\
    \"\n    }\n    // return the first word which has max chars\n    for (chars, w)\
    \ in charCounts {\n        if w == max {\n            return w\n        }\n  \
    \  }\n    // could not find one with max chars\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpjrzm42sg.swift:16:25: error: cannot find 'count' in scope\n   \
    \     charCounts[w] = count(w)\n                        ^~~~~\n/tmp/tmpjrzm42sg.swift:24:28:\
    \ error: cannot assign value of type 'String' to type 'Int'\n            maxCharCount\
    \ = chars\n                           ^~~~~\n/tmp/tmpjrzm42sg.swift:34:20: error:\
    \ cannot convert return expression of type 'Int' to return type 'String'\n   \
    \         return w\n                   ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var result = \"\"\n  var maxLength = -1\n  for word in words {\n    //\
    \ Compute the length of the word from scratch since String.count does\n    //\
    \ not work properly for Unicode. This will be faster than calling .utf8\n    //\
    \ on the word after finding its length.\n    var len = word.utf8().count\n   \
    \ if maxLength < len {\n      maxLength = len\n      result = word\n    }\n  }\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpu2oj61ce.swift:19:20: error: cannot call value of non-function\
    \ type 'String.UTF8View'\n    var len = word.utf8().count\n                  \
    \ ^   ~~\n                       \n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxWord = \"\"\n\n    for word in words {\n\
    \        wordArray := [Character]()\n\n        for c in word {\n            if\
    \ wordArray.contains(c) {\n                wordArray.remove(c)\n            }\
    \ else {\n                wordArray.append(c)\n            }\n        }\n\n  \
    \      if wordArray.count > maxCount {\n            maxCount = wordArray.count\n\
    \            maxWord = word\n        }\n    }\n\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpcc1xmce6.swift:17:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        wordArray := [Character]()\n                 ^\n\
    \                 ;\n/tmp/tmpcc1xmce6.swift:17:19: error: expected expression\n\
    \        wordArray := [Character]()\n                  ^\n/tmp/tmpcc1xmce6.swift:17:9:\
    \ error: cannot find 'wordArray' in scope\n        wordArray := [Character]()\n\
    \        ^~~~~~~~~\n/tmp/tmpcc1xmce6.swift:20:16: error: cannot find 'wordArray'\
    \ in scope\n            if wordArray.contains(c) {\n               ^~~~~~~~~\n\
    /tmp/tmpcc1xmce6.swift:21:17: error: cannot find 'wordArray' in scope\n      \
    \          wordArray.remove(c)\n                ^~~~~~~~~\n/tmp/tmpcc1xmce6.swift:23:17:\
    \ error: cannot find 'wordArray' in scope\n                wordArray.append(c)\n\
    \                ^~~~~~~~~\n/tmp/tmpcc1xmce6.swift:27:12: error: cannot find 'wordArray'\
    \ in scope\n        if wordArray.count > maxCount {\n           ^~~~~~~~~\n/tmp/tmpcc1xmce6.swift:28:24:\
    \ error: cannot find 'wordArray' in scope\n            maxCount = wordArray.count\n\
    \                       ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    words := strings.Split(strings.Join(words, \"|\"), \"|\")\n    var maxCount\
    \ int\n    result := \"\"\n    for _, word := range words {\n        count :=\
    \ len(word) * len(word) - strings.Count(word, \"\")\n        if count > maxCount\
    \ {\n            maxCount = count\n            result = word\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpkbvy32cw.swift:13:10: error: consecutive statements on a line must\
    \ be separated by ';'\n    words := strings.Split(strings.Join(words, \"|\"),\
    \ \"|\")\n         ^\n         ;\n/tmp/tmpkbvy32cw.swift:13:11: error: expected\
    \ expression\n    words := strings.Split(strings.Join(words, \"|\"), \"|\")\n\
    \          ^\n/tmp/tmpkbvy32cw.swift:14:18: error: found an unexpected second\
    \ identifier in variable declaration; is there an accidental break?\n    var maxCount\
    \ int\n                 ^\n/tmp/tmpkbvy32cw.swift:14:18: note: join the identifiers\
    \ together\n    var maxCount int\n        ~~~~~~~~~^~~\n        maxCountint\n\
    /tmp/tmpkbvy32cw.swift:14:18: note: join the identifiers together with camel-case\n\
    \    var maxCount int\n        ~~~~~~~~~^~~\n        maxCountInt\n/tmp/tmpkbvy32cw.swift:15:11:\
    \ error: consecutive statements on a line must be separated by ';'\n    result\
    \ := \"\"\n          ^\n          ;\n/tmp/tmpkbvy32cw.swift:15:12: error: expected\
    \ expression\n    result := \"\"\n           ^\n/tmp/tmpkbvy32cw.swift:16:10:\
    \ error: expected 'in' after for-each pattern\n    for _, word := range words\
    \ {\n         ^\n/tmp/tmpkbvy32cw.swift:16:10: error: expected Sequence expression\
    \ for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpkbvy32cw.swift:17:14:\
    \ error: consecutive statements on a line must be separated by ';'\n        count\
    \ := len(word) * len(word) - strings.Count(word, \"\")\n             ^\n     \
    \        ;\n/tmp/tmpkbvy32cw.swift:17:15: error: expected expression\n       \
    \ count := len(word) * len(word) - strings.Count(word, \"\")\n              ^\n\
    /tmp/tmpkbvy32cw.swift:13:5: warning: expression of type '[String]' is unused\n\
    \    words := strings.Split(strings.Join(words, \"|\"), \"|\")\n    ^~~~~\n/tmp/tmpkbvy32cw.swift:14:9:\
    \ error: type annotation missing in pattern\n    var maxCount int\n        ^\n\
    /tmp/tmpkbvy32cw.swift:15:5: error: cannot find 'result' in scope\n    result\
    \ := \"\"\n    ^~~~~~\n/tmp/tmpkbvy32cw.swift:23:12: error: cannot find 'result'\
    \ in scope\n    return result\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // Sort the list of strings lexicographically.\n    var wordCount: [String]\
    \ = words.sorted()\n\n    // Count the number of unique characters in the sorted\
    \ list.\n    var uniqueCharacterCount = 0\n    for word in wordCount {\n     \
    \   for character in word {\n            if character == character {\n       \
    \         uniqueCharacterCount++\n            }\n        }\n    }\n\n    // Find\
    \ the index of the item with the maximum number of unique characters.\n    var\
    \ maximumCount: Int = -1\n    for index in 0..<wordCount.count {\n        if wordCount[index]\
    \ == wordCount[index] {\n            if maximumCount < uniqueCharacterCount {\n\
    \                maximumCount = uniqueCharacterCount\n            }\n        }\
    \ else {\n            if maximumCount > uniqueCharacterCount {\n             \
    \   maximumCount = uniqueCharacterCount\n            }\n        }\n    }\n\n \
    \   // Return the word that has maximum number of unique characters.\n    return\
    \ wordCount[maximumCount]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpnqzitiow.swift:21:37: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                uniqueCharacterCount++\n             \
    \                       ^~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty {\n        return \"\"\n    }\n    var maxCount = 0\n\
    \    var maxChar = \"\"\n    var maxPos = -1\n    for i := 0; i < words.count;\
    \ i++ {\n        for _, char := range words[i] {\n            count := 0\n   \
    \         pos := -1\n            for j := 0; j < len(maxChar); j++ {\n       \
    \         if maxChar[j] == char {\n                    pos++\n               \
    \ } else {\n                    count++\n                }\n            }\n  \
    \          if count == maxCount {\n                if pos < maxPos {\n       \
    \             return words[i]\n                }\n            } else {\n     \
    \           if pos < maxPos {\n                    maxPos = pos\n            \
    \        maxChar = char\n                    maxCount = count\n              \
    \  }\n            }\n        }\n    }\n    return words[0]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpund0p7pl.swift:19:12: error: expected type\n    for i := 0; i <\
    \ words.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpund0p7pl.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < words.count;\
    \ i++ {\n           ^\n/tmp/tmpund0p7pl.swift:19:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < words.count; i++ {\n     \
    \      ^\n/tmp/tmpund0p7pl.swift:20:14: error: expected 'in' after for-each pattern\n\
    \        for _, char := range words[i] {\n             ^\n/tmp/tmpund0p7pl.swift:20:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, char :=\
    \ range words[i] {\n             ^\n/tmp/tmpund0p7pl.swift:21:18: error: consecutive\
    \ statements on a line must be separated by ';'\n            count := 0\n    \
    \             ^\n                 ;\n/tmp/tmpund0p7pl.swift:21:19: error: expected\
    \ expression\n            count := 0\n                  ^\n/tmp/tmpund0p7pl.swift:23:20:\
    \ error: expected type\n            for j := 0; j < len(maxChar); j++ {\n    \
    \               ^\n                    <#type#>\n/tmp/tmpund0p7pl.swift:23:20:\
    \ error: expected 'in' after for-each pattern\n            for j := 0; j < len(maxChar);\
    \ j++ {\n                   ^\n/tmp/tmpund0p7pl.swift:23:20: error: expected Sequence\
    \ expression for for-each loop\n            for j := 0; j < len(maxChar); j++\
    \ {\n                   ^\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let uniques = Array(Set(words))\n    return uniques.first ?? \"?\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpcjpkwp98/tmpcjpkwp98.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b397cdf0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b397cae7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b397cae7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b397cae67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcjpkwp98                        0x0000561061f6e853 <unavailable> + 6227

    5    libc.so.6                          0x00002b397cfdc460 __libc_start_main +
    245

    6    tmpcjpkwp98                        0x0000561061f6e279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var result = \"\"\n    var count = [Int]()\n\n    for word in words {\n\
    \        let count = count(word)\n\n        if count == 0 {\n            result\
    \ += \"*\"\n        } else {\n            if count.isEmpty {\n               \
    \ result = word\n            } else {\n                if count.max() <= count[0]\
    \ {\n                    result = word\n                } else {\n           \
    \         result = word[0]\n                    for index in 1..<count.count {\n\
    \                        if count[index] > count[index-1] {\n                \
    \            result = word[index]\n                            break\n       \
    \                 }\n                    }\n                }\n            }\n\
    \        }\n\n        count[word.unicodeScalars.count] = count[word.unicodeScalars.count]\
    \ + 1\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbfqsz19b.swift:17:21: error: cannot call value of non-function\
    \ type '[Int]'\n        let count = count(word)\n                    ^\n/tmp/tmpbfqsz19b.swift:28:34:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \          result = word[0]\n                             ~~~~^~~\n"
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // TODO: Work out the actual problem and see if this can be done without\n\
    \    // sorting the input first\n    let uniqueChars = words.reduce([String]())\
    \ { $0.append($1), $1 }\n    var max: Int64 = -1\n    var result: String = \"\"\
    \n    for word in words {\n        max = -99\n        for char in word.unicodeScalars.filter({\
    \ !$0.isControl }).sorted(by: { $0.value <  $1.value }).map({ $0.value }) {\n\
    \            if max < $0.value.int64Value {\n                max = $0.value.int64Value\n\
    \                result = word\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpeslex0i6.swift:15:63: error: consecutive statements on a line must\
    \ be separated by ';'\n    let uniqueChars = words.reduce([String]()) { $0.append($1),\
    \ $1 }\n                                                              ^\n    \
    \                                                          ;\n/tmp/tmpeslex0i6.swift:15:63:\
    \ error: expected expression\n    let uniqueChars = words.reduce([String]()) {\
    \ $0.append($1), $1 }\n                                                      \
    \        ^\n/tmp/tmpeslex0i6.swift:21:22: error: anonymous closure argument not\
    \ contained in a closure\n            if max < $0.value.int64Value {\n       \
    \              ^\n/tmp/tmpeslex0i6.swift:22:23: error: anonymous closure argument\
    \ not contained in a closure\n                max = $0.value.int64Value\n    \
    \                  ^\n/tmp/tmpeslex0i6.swift:15:53: error: cannot convert value\
    \ of type '()' to closure result type '[String]'\n    let uniqueChars = words.reduce([String]())\
    \ { $0.append($1), $1 }\n                                                 ~~~^~~~~~~~~~\n\
    /tmp/tmpeslex0i6.swift:15:53: error: cannot use mutating member on immutable value:\
    \ '$0' is immutable\n    let uniqueChars = words.reduce([String]()) { $0.append($1),\
    \ $1 }\n                                                 ~~ ^\n/tmp/tmpeslex0i6.swift:20:54:\
    \ error: value of type 'Unicode.Scalar' has no member 'isControl'\n        for\
    \ char in word.unicodeScalars.filter({ !$0.isControl }).sorted(by: { $0.value\
    \ <  $1.value }).map({ $0.value }) {\n                                       \
    \           ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard words != nil else {\n        return \"\"\n    }\n    var max =\
    \ 0\n    var maxWord = \"\"\n    for (index, word) in words.enumerated() {\n \
    \       let count = countCharacters(word)\n        if count > max {\n        \
    \    max = count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpoim_2hes.swift:13:17: warning: comparing non-optional value of\
    \ type '[String]' to 'nil' always returns true\n    guard words != nil else {\n\
    \          ~~~~~ ^  ~~~\n/tmp/tmpoim_2hes.swift:19:21: error: cannot find 'countCharacters'\
    \ in scope\n        let count = countCharacters(word)\n                    ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013706
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard words.count > 0 else {\n        return \"\"\n    }\n    // The\
    \ longest word has the maximum number of unique characters.\n    var maxWord =\
    \ words[0]\n    // The word with the maximum number of unique characters is first.\n\
    \    var minWord = words[0]\n    // The current word counts the unique characters\
    \ in the current word.\n    var count = 0\n    // Traverse the words and count\
    \ the unique characters.\n    for i in 1 ..< words.count {\n        let word =\
    \ words[i]\n        // Ignore the empty string.\n        if word != \"\" {\n \
    \           // Count unique characters in the current word.\n            count\
    \ += word.unicodeScalars.filter{ $0.value > 0 }.count\n            // Find the\
    \ new word with the maximum number of unique characters.\n            if count\
    \ > maxWord.unicodeScalars.filter{ $0.value > 0 }.count {\n                maxWord\
    \ = word\n            }\n            // Find the new word with the maximum number\
    \ of unique characters.\n            if count < minWord.unicodeScalars.filter{\
    \ $0.value > 0 }.count {\n                minWord = word\n            }\n    \
    \    }\n    }\n    // Return the result if both words have maximum number of unique\
    \ characters.\n    if maxWord.unicodeScalars.filter{ $0.value > 0 }.count == minWord.unicodeScalars.filter{\
    \ $0.value > 0 }.count {\n        return maxWord\n    }\n    // Return the result\
    \ if the first word has maximum number of unique characters.\n    if maxWord.unicodeScalars.filter{\
    \ $0.value > 0 }.count == 1 {\n        return maxWord\n    }\n    // Return the\
    \ result if the second word has maximum number of unique characters.\n    if minWord.unicodeScalars.filter{\
    \ $0.value > 0 }.count == 1 {\n        return minWord\n    }\n    // Return the\
    \ result if none of them has maximum number of unique characters.\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpcljk87zu/tmpcljk87zu.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b154888cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1548583b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1548583988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b15485827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcljk87zu                        0x000056132767397e <unavailable> + 6526

    5    libc.so.6                          0x00002b1548a78460 __libc_start_main +
    245

    6    tmpcljk87zu                        0x0000561327673539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount: Int = 0\n    var max: String = words[0]\n    for word :\
    \ String in words {\n        let count = countUniqCharacters(word)\n        if\
    \ count > maxCount {\n            maxCount = count\n            max = word\n \
    \       }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp9rhmvqk_.swift:16:21: error: cannot find 'countUniqCharacters'\
    \ in scope\n        let count = countUniqCharacters(word)\n                  \
    \  ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmptuoqm9dq.swift:13:21: error: missing argument label 'words:' in\
    \ call\n    return find_max(words)\n                    ^\n                  \
    \  words: \n"
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty {\n        return \"\"\n    }\n    var maxWord = words[0]\n\
    \    var maxCount = 1\n    for word in words {\n        if maxCount > word.characters.count\
    \ {\n            maxCount = word.characters.count\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp2cpnpxd5.swift:19:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxCount > word.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp2cpnpxd5.swift:20:29: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxCount = word.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.isEmpty() {\n        return \"\"\n    }\n    var max: Int64\
    \ = 0\n    var maxString: String = \"\"\n    for word : String in words {\n  \
    \      let charCounts = Array(Set(word))\n        for charCount : Int64 in charCounts\
    \ {\n            if charCount > max {\n                max = charCount\n     \
    \           maxString = word\n            }\n        }\n    }\n    return maxString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmprlrpm_e7.swift:13:14: error: cannot call value of non-function\
    \ type 'Bool'\n    if words.isEmpty() {\n             ^      ~~\n            \
    \        \n/tmp/tmprlrpm_e7.swift:20:34: error: cannot convert sequence element\
    \ type 'String.Element' (aka 'Character') to expected type 'Int64'\n        for\
    \ charCount : Int64 in charCounts {\n                                 ^\n"
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.reduce((max: String?, word: String) -> String in\n     \
    \   guard let maxString = max else {\n            return word\n        }\n   \
    \     var count = maxString.characters.count\n        for char in word.characters\
    \ {\n            if count < maxString.characters.count {\n                count\
    \ = maxString.characters.count\n            }\n        }\n        return maxString\n\
    \    )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpc_f3hve_.swift:13:64: error: expected ',' separator\n    return\
    \ words.reduce((max: String?, word: String) -> String in\n                   \
    \                                            ^\n                             \
    \                                 ,\n/tmp/tmpc_f3hve_.swift:13:64: error: expected\
    \ expression in list of expressions\n    return words.reduce((max: String?, word:\
    \ String) -> String in\n                                                     \
    \          ^\n/tmp/tmpc_f3hve_.swift:14:34: error: consecutive statements on a\
    \ line must be separated by ';'\n        guard let maxString = max else {\n  \
    \                               ^\n                                 ;\n/tmp/tmpc_f3hve_.swift:14:35:\
    \ error: expected expression\n        guard let maxString = max else {\n     \
    \                             ^\n/tmp/tmpc_f3hve_.swift:24:5: error: expected\
    \ expression\n    )\n    ^\n/tmp/tmpc_f3hve_.swift:13:63: error: missing argument\
    \ for parameter #2 in call\n    return words.reduce((max: String?, word: String)\
    \ -> String in\n                                                             \
    \ ^\n                                                              , <#(((String?,\
    \ String) -> String).Type, String) throws -> ((String?, String) -> String).Type#>\n\
    Swift.Sequence:2:28: note: 'reduce' declared here\n    @inlinable public func\
    \ reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult:\
    \ Result, Self.Element) throws -> Result) rethrows -> Result\n               \
    \            ^\n/tmp/tmpc_f3hve_.swift:13:18: error: cannot convert return expression\
    \ of type '((String?, String) -> String).Type' to return type 'String'\n    return\
    \ words.reduce((max: String?, word: String) -> String in\n           ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpc_f3hve_.swift:14:31: error: generic parameter 'T' could not be inferred\n\
    \        guard let maxString = max else {\n                              ^\nSwift.max:1:24:\
    \ note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y:\
    \ T) -> T where T : Comparable\n                  "
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max(words.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpwws1gvhu.swift:13:21: error: missing argument label 'words:' in\
    \ call\n    return find_max(words.sorted())\n                    ^\n         \
    \           words: \n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max(words.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpwws1gvhu.swift:13:21: error: missing argument label 'words:' in\
    \ call\n    return find_max(words.sorted())\n                    ^\n         \
    \           words: \n"
  stdout: ''
  timestamp: 1660013706
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = words[0]\n    for word := 1; word < words.Count; word++ {\n\
    \        for character := 0; character < words[word].Count; character++ {\n  \
    \          if max < words[word][character] {\n                max = words[word][character]\n\
    \            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp53xku_zp.swift:14:15: error: expected type\n    for word := 1;\
    \ word < words.Count; word++ {\n              ^\n               <#type#>\n/tmp/tmp53xku_zp.swift:14:15:\
    \ error: expected 'in' after for-each pattern\n    for word := 1; word < words.Count;\
    \ word++ {\n              ^\n/tmp/tmp53xku_zp.swift:14:15: error: expected Sequence\
    \ expression for for-each loop\n    for word := 1; word < words.Count; word++\
    \ {\n              ^\n/tmp/tmp53xku_zp.swift:15:24: error: expected type\n   \
    \     for character := 0; character < words[word].Count; character++ {\n     \
    \                  ^\n                        <#type#>\n/tmp/tmp53xku_zp.swift:15:24:\
    \ error: expected 'in' after for-each pattern\n        for character := 0; character\
    \ < words[word].Count; character++ {\n                       ^\n/tmp/tmp53xku_zp.swift:15:24:\
    \ error: expected Sequence expression for for-each loop\n        for character\
    \ := 0; character < words[word].Count; character++ {\n                       ^\n"
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var wordDict: [String: Int] = [:]\n    for word in words {\n        if\
    \ wordDict[word] != nil {\n            wordDict[word] += 1\n        } else {\n\
    \            wordDict[word] = 1\n        }\n    }\n    var maxVal = wordDict.values().max()\n\
    \    for word in wordDict.keys {\n        if wordDict[word] == maxVal {\n    \
    \        return word\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpdd7sbtbd.swift:16:21: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n            wordDict[word] += 1\n   \
    \                 ^\n/tmp/tmpdd7sbtbd.swift:16:21: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n            wordDict[word]\
    \ += 1\n                    ^\n                          !\n/tmp/tmpdd7sbtbd.swift:21:27:\
    \ error: cannot call value of non-function type 'Dictionary<String, Int>.Values'\n\
    \    var maxVal = wordDict.values().max()\n                          ^     ~~\n\
    \                                \n"
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return find_max(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmptuoqm9dq.swift:13:21: error: missing argument label 'words:' in\
    \ call\n    return find_max(words)\n                    ^\n                  \
    \  words: \n"
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  words.sortInPlace()\n  \n  var result = \"\"\n  var count = 0\n  \n  for\
    \ word in words {\n    if count < word.count {\n      result = word\n      count\
    \ = 1\n    } else {\n      count += 1\n    }\n  }\n  \n  return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmplcbxk4p0.swift:13:9: error: value of type '[String]' has no member\
    \ 'sortInPlace'\n  words.sortInPlace()\n  ~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maxCount = 0\n  var maxIndex = -1\n  for index in 0..<words.count {\n\
    \    var count = countCharactersInString(words[index])\n    if count > maxCount\
    \ {\n      maxCount = count\n      maxIndex = index\n    }\n  }\n  if maxIndex\
    \ != -1 {\n    return words[maxIndex]\n  }\n  return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmprngvet5l.swift:16:17: error: cannot find 'countCharactersInString'\
    \ in scope\n    var count = countCharactersInString(words[index])\n          \
    \      ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013707
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  // O(n)\n  var word = words[0]\n  var count = 1\n  for word in words {\n\
    \    if count < word.countByCharactersInString().count {\n      word = word\n\
    \      count = word.countByCharactersInString().count\n    }\n  }\n  return word\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpzvuubx5j.swift:17:21: error: value of type 'String' has no member\
    \ 'countByCharactersInString'\n    if count < word.countByCharactersInString().count\
    \ {\n               ~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzvuubx5j.swift:18:7:\
    \ error: cannot assign to value: 'word' is a 'let' constant\n      word = word\n\
    \      ^~~~\n/tmp/tmpzvuubx5j.swift:19:20: error: value of type 'String' has no\
    \ member 'countByCharactersInString'\n      count = word.countByCharactersInString().count\n\
    \              ~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013707
