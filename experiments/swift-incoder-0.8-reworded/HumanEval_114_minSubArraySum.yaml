name: HumanEval_114_minSubArraySum
language: swift
prompt: "\n/// Given an array of integers nums, find the minimum sum of any non-empty\
  \ sub-array\n/// of nums.\n/// Example\n/// >>> minSubArraySum(nums: [2, 3, 4, 1,\
  \ 2, 4])\n/// 1\n/// >>> minSubArraySum(nums: [-1, -2, -3])\n/// -6\nfunc minSubArraySum(nums:\
  \ [Int]) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4])\
  \ == 1)\nassert(minSubArraySum(nums: [-1, -2, -3]) == -6)\nassert(minSubArraySum(nums:\
  \ [-1, -2, -3, 2, -10]) == -14)\nassert(minSubArraySum(nums: [-9999999999999999])\
  \ == -9999999999999999)\nassert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)\n\
  assert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums:\
  \ [100, -1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [10, 11, 13, 8,\
  \ 3, 4]) == 3)\nassert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)\n\
  assert(minSubArraySum(nums: [-10]) == -10)\nassert(minSubArraySum(nums: [7]) ==\
  \ 7)\nassert(minSubArraySum(nums: [1, -1]) == -1)"
completions: ["    var sum = Int()\n    var leftIndex = 0\n    var rightIndex = nums.count\n\
    \    guard rightIndex > 0 else { return 0 }\n\n    while leftIndex < rightIndex\
    \ {\n        sum = nums[leftIndex] + nums[rightIndex] + sum\n        guard sum\
    \ > 0 else { return 0 }\n        leftIndex += 1\n        rightIndex -= 1\n   \
    \ }\n    return sum", "  if nums.isEmpty {\n    return 0\n  }\n\n  let min = nums[0]\n\
    \  var sum = nums[0]\n  for num in nums {\n    if num > min {\n      sum += min\n\
    \    }\n    sum += num\n    min = max(min, num)\n  }\n  return sum", '    return
    minSubArraySum(nums, 0, nums.count)', "    var minSum = Int.min\n    for num in\
    \ nums {\n        let sum = num + nums[nums.index {$0 >= num}]\n        if sum\
    \ < minSum {\n            minSum = sum\n        }\n    }\n    return minSum",
  "    var sum = 0\n    for num in nums {\n        sum += num\n    }\n    return sum",
  "    var min: Int? = nil\n    for number in nums {\n        guard let currentMin\
    \ = min?.min() else { min = Int(number); continue }\n        min = min(currentMin,\
    \ Int(number))\n    }\n    return min!", "    var sum = 0\n    for i in 0..<nums.count\
    \ {\n        for j in 0..<i {\n            sum += nums[j] + nums[j+i]\n      \
    \  }\n    }\n    return sum", "    // This approach iterates through the input\
    \ array once\n    var sum: Int = 0\n    for number in nums {\n        sum += number\n\
    \    }\n    \n    // This approach iterates through the input array twice\n  \
    \  var minSum: Int = sum\n    for number in nums {\n        minSum -= number\n\
    \    }\n    \n    return minSum", "    var result: Int = 0\n    for num in nums\
    \ {\n        result += num\n    }\n    return result", "    var min = nums[0]\n\
    \    for index in 1..<nums.count {\n        if nums[index] < nums[index-1] {\n\
    \            min = nums[index] - nums[index-1]\n        }\n    }\n    return min",
  "    var min = nums[0]\n    for n in nums {\n        if n < min {\n            min\
    \ = n\n        }\n    }\n    return min", "    var result = 0\n    for num in\
    \ nums {\n        result = result + num\n    }\n    return result", "    // TODO:\
    \ check overflow\n    if nums.isEmpty { return 0 }\n    var minSoFar = nums[0]\n\
    \    for n in nums.dropFirst() {\n        guard n > minSoFar else {\n        \
    \    // The current number is the min so far.\n            // So just add the\
    \ current number\n            // to minSoFar and move on to the next number\n\
    \            minSoFar += n\n            continue\n        }\n        // current\
    \ number is not the min so far.\n        // So check if its a sub array or not\n\
    \        if n == minSubArraySum(nums.suffix(from: 0)) { return n }\n    }\n  \
    \  return minSoFar", "    // write your code in JavaScript (Node.js 8.9.4)\n \
    \   if nums == nil || nums.isEmpty() {\n        return -1\n    }\n    var min\
    \ = Int.min\n    var result = Int.max\n    for index in 0..<nums.count {\n   \
    \     let subArray = Array(nums[index..<index+1])\n        let min = subArray.min\
    \ { (a,b) -> Bool in\n            return a + b < min\n        }\n        let max\
    \ = subArray.max { (a,b) -> Bool in\n            return a + b > max\n        }\n\
    \        if min > result {\n            result = min\n        }\n        if max\
    \ < result {\n            result = max\n        }\n    }\n    return result",
  "    guard nums.count > 0 else { return 0 }\n\n    var result = nums[0]\n    for\
    \ num in nums.dropFirst() {\n        result = max(result, num + result)\n    }\n\
    \    return result", "    guard nums.count > 0 else {\n        return 0\n    }\n\
    \    var min = nums[0]\n    for num in nums.dropFirst() {\n        min = min(min\
    \ + num, num)\n    }\n    return min", "  guard let maxSum = maxSum(nums: nums)\
    \ else {\n    return 0\n  }\n\n  for num in nums {\n    let newSum = maxSum -\
    \ num\n    if newSum < 0 {\n      return 0\n    }\n    if newSum < minSum {\n\
    \      minSum = newSum\n    }\n  }\n\n  return minSum", "    var sum = 0\n   \
    \ for num in nums {\n        sum += num\n    }\n    return sum", '    return subArraySum(nums,
    nums.count).min()', "    if nums.isEmpty {\n        return 0\n    }\n    var min\
    \ = nums[0]\n    for x in nums[1..] {\n        if x >= min {\n            min\
    \ = x\n        }\n    }\n    return min", "    let numsArray = nums.sorted()\n\
    \    let sum = numsArray.reduce(0.0, +)\n    let min = numsArray[0]\n    for i\
    \ in 0..<numsArray.count {\n        if numsArray[i] - min > 0 {\n            sum\
    \ += min\n        }\n        min = min(numsArray[i + 1], min)\n    }\n    return\
    \ sum", '    return minSubArraySum(nums, nums.count)', "  if nums.isEmpty() {\n\
    \    return 0\n  }\n\n  var low = nums[0]\n  var high = nums[0]\n  for x in nums\
    \ {\n    low = min(low, x)\n    high = max(high, x)\n  }\n\n  var sum = 0\n  for\
    \ x in\n    stride(from: low, to: high, by: 1) {\n    sum += x\n  }\n\n  return\
    \ sum", '    return minSubArraySum(nums, nums.count)', "    // Sort the array\
    \ of numbers so that the smallest number is the first.\n    let sortedNums = nums.sorted()\n\
    \    // The subarrays of the array will have the following indexes:\n    // [start\
    \ index, end index) of the smallest sub-array (the largest is at the\n    // last\
    \ index).\n    var subarrays = [Int]()\n    var min = sortedNums[0]\n    for index\
    \ in 1..<nums.count {\n        // Check if the sum of the current number and the\
    \ previous number is greater\n        // than the smallest subarray. If so, update\
    \ the subarray and update the min\n        // number.\n        let currentSum\
    \ = sortedNums[index] + sortedNums[index - 1]\n        if currentSum > min {\n\
    \            subarrays.append(min)\n            min = currentSum\n        } else\
    \ {\n            // If the current number and the previous number are equal, add\
    \ it to\n            // the subarray.\n            subarrays.append(currentSum)\n\
    \        }\n    }\n    // Return the sum of the smallest subarray.\n    return\
    \ subarrays.reduce(0, +)", '    return binarySearch(nums, 0, nums.count-1, 0)',
  "    guard nums.isEmpty == false else {\n        return 0\n    }\n    var minSum\
    \ = nums[0]\n    for val in nums {\n        for i = 1...val {\n            minSum\
    \ -= i\n        }\n        if minSum < 0 {\n            minSum = 0\n        }\n\
    \    }\n    return minSum", "  var result: Int = 0\n  for i in 0 ..< nums.count\
    \ {\n    let start = max(i, 0)\n    let end = min(i + 1, nums.count)\n    for\
    \ j in start ..< end {\n      result += nums[j] - nums[i - j]\n    }\n  }\n  return\
    \ result", "    let n = nums.count\n    let m = Int(pow(Double(n), Double(2)))\n\
    \    let dp = [Int](n) { Int(pow(2, Double($0)) / m) }\n\n    for _ in 0..<n {\n\
    \        for _ in 0..<m {\n            if nums.filter({$0 > 0}).count > 0 {\n\
    \                if dp[n - 1] + nums.filter({$0 > 0}).min() <= dp[n] {\n     \
    \               dp[n - 1] = nums.filter({$0 > 0}).min()\n                }\n \
    \           }\n        }\n    }\n    return dp[n]", "    if nums.isEmpty {\n \
    \       return 0\n    }\n    var minSum = nums[0]\n    for num in nums {\n   \
    \     if num < minSum {\n            minSum = num\n        }\n    }\n    return\
    \ minSum", "    // base case\n    if nums.isEmpty {\n        return 0\n    }\n\
    \    // get the lowest element\n    var lowest = nums[0]\n    // get all the elements\
    \ starting from lowest and end at 0\n    for i in 1..<nums.count {\n        if\
    \ nums[i] < lowest {\n            lowest = nums[i]\n        }\n    }\n    // the\
    \ lowest sum sub-array\n    var minSum = Int64(0)\n    // get the index where\
    \ lowest is located\n    var index = -1\n    // iterate over the array from lowest\
    \ to 0\n    for i in lowest..<0 {\n        minSum = minSum + nums[i]\n       \
    \ index = i\n    }\n    return minSum", "    var sum = 0\n    for num in nums\
    \ {\n        sum += num\n    }\n    return sum", "    var sum = 0\n    for num\
    \ in nums {\n        sum += num\n    }\n    for num in nums.reversed() {\n   \
    \     sum -= num\n    }\n    return sum", "    let maxSum = nums.max()\n    var\
    \ minSum = -Int(maxSum)\n    for num in nums.reversed() {\n        let diff =\
    \ num - maxSum\n        if diff > 0 {\n            if minSum > diff {\n      \
    \          minSum = diff\n            }\n        } else {\n            if minSum\
    \ < 0 {\n                minSum = -minSum\n            }\n        }\n        maxSum\
    \ -= num\n    }\n    return minSum", '    return minSubArraySumHelper(nums, nums.count)',
  "    guard nums.count > 0 else { return 0 }\n    var minimum = nums[0]\n    var\
    \ maximum = nums[0]\n    for i in 1..<nums.count {\n        var smallerSum = nums[i]\n\
    \        for j in 0..<i - 1 {\n            smallerSum -= nums[j]\n        }\n\
    \        minimum = min(minimum, smallerSum)\n        maximum = max(maximum, smallerSum)\n\
    \    }\n    return maximum", "    if nums.isEmpty { return 0 }\n    var minSum\
    \ = nums[0]\n    for num in nums.dropFirst() {\n        minSum = minSum + num\n\
    \    }\n    return minSum", "    // Write your code here.\n    var sum = 0\n \
    \   for i in 0..<nums.count {\n        var j = i\n        while j > 0 && nums[j-1]\
    \ > nums[j] {\n            sum += nums[j]\n            j /= 2\n        }\n   \
    \     sum += nums[i]\n    }\n    return sum", "    var smallestSum: Int = Int.max\n\
    \n    for (_, num) in nums.enumerated() {\n        let sumOfSubArray: Int = num\
    \ + smallestSum\n        smallestSum = minOf(sumOfSubArray, smallestSum)\n   \
    \ }\n\n    return smallestSum", "    var min = nums[0]\n    for number in nums\
    \ {\n        for j in 0 ..< number - min {\n            min += nums[j]\n     \
    \   }\n    }\n    return min", "    // write your code here\n    var min = nums[0]\n\
    \    for element in nums {\n        for index in 0..<element {\n            if\
    \ element > min {\n                min = element\n            }\n        }\n \
    \   }\n    return min", "    if nums.isEmpty {\n        return 0\n    }\n\n  \
    \  // 1. Construct a map with current sum and number as key\n    let map = Dictionary<Int,\
    \ Int>()\n    for val in nums {\n        if let _ = map.get(val) {\n         \
    \   map[val] = map[val] + 1\n        } else {\n            map[val] = 1\n    \
    \    }\n    }\n\n    // 2. Iterate over map to find the minimum sum\n    var min\
    \ = nums.first!\n    for val in map.keys {\n        if val == min {\n        \
    \    continue\n        }\n        if val <= min {\n            break\n       \
    \ }\n\n        // 3. Update the current min with the current number\n        min\
    \ = val\n    }\n\n    return min", "    guard nums.isEmpty == false else {\n \
    \       return nums.minElement()!\n    }\n\n    var sum = 0\n    var minElement\
    \ = nums.first!\n    for element in nums {\n        if element < minElement {\n\
    \            sum = sum + element - minElement\n        } else {\n            sum\
    \ += minElement - element\n        }\n        minElement = element\n    }\n\n\
    \    return sum", "    var sum = 0\n    var min = nums[0]\n    for n in nums {\n\
    \        sum += n\n        if sum < min {\n            min = sum\n        }\n\
    \    }\n    return min", "    var min: Int = 0\n    var minSum: Int = 0\n    for\
    \ n in nums {\n        minSum += n\n        if minSum < min {\n            min\
    \ = minSum\n        }\n    }\n    return min", "    // If there is 1 number in\
    \ the array return the array\n    guard nums.count > 0 else { return 0 }\n\n \
    \   var minSum = nums[0]\n    for num in nums {\n        minSum = num > minSum\
    \ ? num - minSum : minSum\n    }\n\n    return minSum", "    var min = 0\n   \
    \ for n in nums {\n        let temp = min + n\n        if temp < 0 {\n       \
    \     min = temp\n        } else {\n            min = temp\n            break\n\
    \        }\n    }\n    return min", '    return minSubArraySumHelper(nums, nums.count)',
  "    var sum = 0\n    var min = nums[0]\n    for n in nums {\n        if n > 0 {\n\
    \            sum += n\n            if sum < min {\n                min = sum\n\
    \            }\n        }\n    }\n    return min", '    return min(nums.reduce(0)
    { $0 + $1 })', "    var minSoFar = nums[0]\n    for num in nums {\n        minSoFar\
    \ = min(minSoFar, num + minSubArraySum(nums: nums + [num]) - num)\n    }\n   \
    \ return minSoFar", "    let n = nums.count\n    let m = nums.max\n    var min\
    \ = nums.max\n    for i in 0..<n {\n        for j in i+1..<n {\n            let\
    \ sum = nums[i] - nums[j]\n            if sum < min {\n                min = sum\n\
    \            }\n        }\n    }\n    return min", "    var sum: Int = nums[0]\n\
    \    for i in 1..<nums.count {\n        if sum > nums[i] {\n            sum =\
    \ nums[i]\n        }\n    }\n    return sum", "    var min = Int()\n    for element\
    \ in nums {\n        for subarray in nums.dropLast() {\n            min += subarray\
    \ - element\n        }\n    }\n    return min", "    if nums.isEmpty {\n     \
    \   return 0\n    }\n    if nums.isEmpty || nums.count < 2 {\n        return nums[0]\n\
    \    }\n    if nums[0] == 0 {\n        return minSubArraySum(nums.dropFirst())\n\
    \    }\n    if nums[0] < 0 {\n        return Int64(Int.max) / Int64(Int64(nums[0]))\
    \ * minSubArraySum(nums.dropFirst())\n    }\n    var max = 0\n    var min = nums[0]\n\
    \    for num in nums.dropFirst() {\n        max = max * num + num\n        if\
    \ max > num {\n            break\n        }\n        min = min + num\n    }\n\
    \    if max == Int.max {\n        return Int64(Int.max)\n    }\n    return min\
    \ * Int64(Int64(max) - Int64(min))", "    var sum = 0\n    for number in nums\
    \ {\n        sum += number\n    }\n    return sum", "    var sum = 0\n    var\
    \ min = nums[0]\n    for i in 1..<nums.count {\n        if nums[i] > min {\n \
    \           min = nums[i]\n        }\n        sum += min\n    }\n    return sum",
  "    let max = nums[0]\n    var sum = max\n    for i in nums.dropFirst() {\n   \
    \     let sum = sum + i\n        if sum < max {\n            max = sum\n     \
    \   }\n    }\n    return max", "    guard nums.count > 0 else { return 0 }\n \
    \   \n    var sum: Int = 0\n    for i in 0..<nums.count {\n        sum += nums[i]\n\
    \    }\n    \n    for index in 0..<nums.count {\n        var minSum = sum\n  \
    \      for j in index+1..<nums.count {\n            minSum -= nums[j] \n     \
    \   }\n        if minSum < 0 {\n            minSum = 0\n        }\n        sum\
    \ += minSum\n    }\n    return sum", "    \n    var sum = Int.max\n    for n in\
    \ nums {\n        sum += n\n    }\n    \n    return sum", "    if nums.isEmpty()\
    \ {\n        return 0\n    }\n    let result = nums[0]\n    for i in 1..<nums.count\
    \ {\n        if nums[i] > result {\n            result = nums[i]\n        }\n\
    \    }\n    return result", "    var min = nums[0]\n    for n in nums {\n    \
    \    var m = min + n\n        if m < n {\n            m = n\n        }\n     \
    \   min = m\n    }\n    return min", "    let sum = nums.reduce(Int.min, { $0\
    \ + $1 })\n    let len = nums.count\n    var sumOfSubArrays = sum\n    for index\
    \ = 0; index < len; index += 1 {\n        if sumOfSubArrays > 0 {\n          \
    \  sumOfSubArrays -= nums[index]\n        } else {\n            sumOfSubArrays\
    \ += nums[index]\n        }\n    }\n    return sum", "    precondition(nums.count\
    \ >= 1, \"minSubArraySum: nums must have at least 1 element\")\n    if nums.count\
    \ == 1 {\n        return nums[0]\n    }\n    var minSum : Int = 0\n    var minIndex\
    \ : Int = 0\n    var index = 0\n    for element in nums {\n        if element\
    \ < minSum {\n            minSum = element\n            minIndex = index\n   \
    \     }\n        index += 1\n    }\n    if minSum == 0 {\n        return minSum\n\
    \    }\n    while minIndex < nums.count - 1 {\n        if nums[minIndex] + nums[minIndex\
    \ + 1] <= minSum {\n            minSum += nums[minIndex + 1]\n            minIndex\
    \ += 1\n        } else {\n            minSum = nums[minIndex]\n            minIndex\
    \ = minIndex + 1\n        }\n    }\n    return minSum", "    let minVal = nums[0]\n\
    \    var min = minVal\n    for num in nums {\n        minVal = min(minVal, num)\n\
    \        min = min(min, minVal)\n    }\n    return min", '    return minSubArraySum(nums,
    0, nums.count, 0)', "    let length = nums.count\n    var min = nums[0]\n    for\
    \ i in 1..<length {\n        if nums[i] - min > 0 {\n            min = nums[i]\n\
    \        }\n    }\n    return min", "  guard nums.count > 0 else {\n    return\
    \ 0\n  }\n  var minSum = nums[0]\n  var minStartIndex = 0\n  for index in 1..<nums.count\
    \ {\n    let currentSum = nums[index] + minSum\n    if currentSum < minSum {\n\
    \      minSum = currentSum\n      minStartIndex = index\n    }\n  }\n  return\
    \ nums[minStartIndex] + minSum", "    let min = Int(self.max(nums))\n    for i\
    \ in 0..<nums.count {\n        for j in i..<nums.count {\n            if nums[i]\
    \ > nums[j] {\n                break\n            }\n        }\n        if nums[i]\
    \ > min {\n            min = nums[i]\n        }\n    }\n    return min", "   \
    \ var sum = 0\n    for i in 0..<nums.count {\n        sum += nums[i]\n       \
    \ if sum < 0 {\n            sum = 0\n        }\n    }\n    return sum", "    var\
    \ min = FLT_MAX\n    var sum = 0\n    for i in 0..<nums.count {\n        sum +=\
    \ nums[i]\n        if sum < min {\n            min = sum\n        }\n    }\n \
    \   return sum", "    guard let numsSorted = nums.sorted else {\n        return\
    \ Int64(0)\n    }\n    var min = Int64(0)\n    var index = -1\n    for i in 0..<numsSorted.count\
    \ {\n        var cur = numsSorted[i]\n        if cur == 0 {\n            continue\n\
    \        }\n        min = min(min!, cur)\n        \n        while numsSorted[index]\
    \ > 0 {\n            cur -= numsSorted[index]\n            index += 1\n      \
    \  }\n        while cur > 0 {\n            cur -= numsSorted[index] \n       \
    \     index += 1\n        }\n        min = min(min!, cur)\n    }\n    return min",
  "    // Add up the array and find the min value\n    // We know that if all the\
    \ elements are positive, sum will be positive,\n    // so we only need to check\
    \ positive numbers\n    var sum = 0\n    for num in nums {\n        if num >=\
    \ 0 {\n            sum += num\n        }\n    }\n\n    // Find the min sum no\
    \ subarray exists of length 1 and nums has at least 1 element\n    if sum == 0\
    \ && nums.count > 0 {\n        return 0\n    }\n\n    // Start with the element\
    \ in the middle of the array\n    // Subtract out the left part of the array until\
    \ you get down to length 1\n    // and sum is the min sum no subarray exists anymore\n\
    \    var minSum = sum / 2\n    for index in stride(from: nums.count / 2, through:\
    \ 0, by: -1) {\n        let left = nums[index]\n        sum -= left\n        if\
    \ sum < minSum {\n            minSum = sum\n        }\n    }\n\n    return minSum",
  "    var minSum = -1\n    for num in nums {\n        minSum = minSum * num + num\n\
    \    }\n    return minSum", '    return minSubArraySum(nums, nums.count)', " \
    \ if nums.isEmpty {\n    return 0\n  }\n\n  var sum = 0\n  var currentSum = 0\n\
    \  for i in 0..<nums.count {\n    currentSum += nums[i]\n    if currentSum < sum\
    \ {\n      sum = currentSum\n    }\n  }\n\n  return sum", "    \n    guard nums.count\
    \ >= 1 else {\n        return 0\n    }\n    \n    let maxRange = nums.count\n\
    \    var maxSum: Int = 0\n    var sum: Int = 0\n    \n    for i in 0..<maxRange\
    \ {\n        sum += nums[i]\n        if sum >= maxSum {\n            maxSum =\
    \ sum\n        }\n    }\n    return maxSum", "    var sum = 0\n    for i in nums.indices\
    \ {\n        if nums[i] > 0 {\n            sum += nums[i]\n            sum -=\
    \ nums[nums[i]]\n        }\n    }\n    return sum", "    if nums.isEmpty() {\n\
    \        return 0 // or whatever value you want here\n    }\n    \n    var sum\
    \ = 0\n    \n    for num in nums {\n        if num == 0 {\n            break\n\
    \        }\n        \n        if num > 0 {\n            sum += num\n        }\n\
    \    }\n    \n    return sum", "    var minSum = nums[0]\n\n    for i in 1 ..<\
    \ nums.count {\n        minSum = min(minSum + nums[i], minSum)\n    }\n\n    return\
    \ minSum", "    var min = Int.max\n    var index = 0\n    \n    for i in 0..<nums.count\
    \ {\n        if i == 0 {\n            min = nums[i]\n            continue\n  \
    \      }\n        if nums[i] > min {\n            min = 0\n        }\n       \
    \ \n        var cur = min - nums[i]\n        for j in 1..<nums.count {\n     \
    \       if nums[j] > cur {\n                cur = nums[j] - nums[i]\n        \
    \    }\n        }\n        \n        if cur < min {\n            min = cur\n \
    \       }\n        \n    }\n    \n    return min", "    if nums.isEmpty {\n  \
    \      return 0\n    }\n\n    // sort nums\n    let sortedNums = nums.sorted()\n\
    \n    // initialize minSum with first element of nums\n    var minSum = sortedNums[0]\n\
    \n    // loop through nums to find smallest sum of nums\n    for nextNum in sortedNums\
    \ {\n        // add nextNum to minSum\n        minSum = minSum + nextNum\n\n \
    \       // remove nextNum from nums\n        let removedIndex = nums.index(of:\
    \ nextNum)\n        nums.remove(at: removedIndex)\n    }\n\n    return minSum",
  "    var s = nums[0]\n    for i in 1..<nums.count {\n        if nums[i-1] > nums[i]\
    \ {\n            s = min(s, nums[i-1]+nums[i])\n        }\n    }\n    return s",
  "    // Write your code here.\n    \n    var sum = 0\n    var minSum = nums[0]\n\
    \    for n in nums {\n        sum += n\n        if sum < minSum {\n          \
    \  minSum = sum\n        }\n    }\n    return minSum", "    var minSubArray =\
    \ [0]\n    var min = nums[0]\n    for num in nums {\n        for i := 0; i < minSubArray.count;\
    \ i++ {\n            minSubArray[i] += num - min\n            if minSubArray[i]\
    \ < 0 {\n                minSubArray[i] -= num\n                min = -num\n \
    \               minSubArray = [0]\n            }\n        }\n        if min >\
    \ num {\n            min = num\n        }\n        minSubArray = minSubArray[0..<minSubArray.count]\n\
    \    }\n    return min", "    var min = Int.max\n    for num in nums {\n     \
    \   if min > num {\n            min = num\n        }\n    }\n    return min",
  "  var min = Int(nums[0])\n  for number in nums.dropFirst() {\n    min += number\n\
    \  }\n  return min", "  var sum = nums[0]\n  for num in nums.dropFirst() {\n \
    \   var sum = sum + num\n    if sum < 0 {\n      break\n    }\n  }\n  return sum",
  "    if nums.isEmpty {\n        return 0\n    }\n    \n    let start = 1\n    let\
    \ end = nums.count - 1\n    var sum = nums[0]\n    for i in start..<end {\n  \
    \      sum += nums[i]\n    }\n    \n    if sum < 0 {\n        sum = 0\n    }\n\
    \    \n    return sum", "    if nums.isEmpty {\n        return nums.min()\n  \
    \  }\n    var min = nums[0]\n    for i in 1..<nums.count {\n        if nums[i]\
    \ - nums[i - 1] >  min {\n            min = nums[i] - nums[i - 1]\n        }\n\
    \    }\n    return min", "    var sum = 0\n    for num in nums {\n        sum\
    \ += num\n    }\n    return sum", "    if nums.isEmpty {\n        return 0\n \
    \   }\n    var sum = 0\n    var low = nums.startIndex\n    var high = nums.endIndex\n\
    \    for curIndex in 0..<nums.count {\n        let cur = nums[curIndex]\n    \
    \    for lowIndex = low..<high {\n            let low = nums[lowIndex]\n     \
    \       if cur + low <= 0 {\n                break\n            }\n          \
    \  sum += cur + low\n            if low == nums[lowIndex] {\n                low\
    \ = lowIndex + 1\n            } else {\n                low = lowIndex\n     \
    \       }\n        }\n        high = nums.endIndex\n        for lowIndex = high..<nums.count\
    \ {\n            let low = nums[lowIndex]\n            if cur + low <= 0 {\n \
    \               break\n            }\n            sum += cur + low\n         \
    \   if low == nums[lowIndex] {\n                low = lowIndex - 1\n         \
    \   } else {\n                low = lowIndex\n            }\n        }\n     \
    \   low = nums.startIndex\n        for highIndex = low..<high {\n            let\
    \ high = nums[highIndex]\n            if cur + high <= 0 {\n                break\n\
    \            }\n            sum += cur + high\n            if high == nums[highIndex]\
    \ {\n                high = highIndex - 1\n            } else {\n            \
    \    high = highIndex\n            }\n        }\n    }\n    return sum", '    return
    minSubArraySum(nums, nums.count)', "  if nums.isEmpty() {\n    return 0\n  }\n\
    \  var min = nums[0]\n  var bestSum = nums[0]\n  for _ in 0..<nums.count {\n \
    \   let sum = bestSum + nums[bestSum]\n    if sum > min {\n      min = sum\n \
    \   }\n    bestSum = sum\n  }\n  return bestSum", "    var min = Int()\n    var\
    \ minSum = Int()\n\n    for i in 0..<nums.count {\n        var sum = nums[i]\n\
    \        min = min\n        minSum = 0\n\n        for (index, _) in (nums.enumerated().reversed().enumerate()\
    \ {\n            if index != i {\n                sum = sum + nums[index]\n  \
    \              if sum < min {\n                    min = sum\n               \
    \     minSum = sum\n                }\n            }\n        })\n\n        if\
    \ minSum > sum {\n            minSum = sum\n            min = minSum\n       \
    \ }\n    }\n    return min", "    let n = nums.count\n    var min = nums[0]\n\
    \    for i in 1..<n {\n        if nums[i] < min {\n            min = nums[i]\n\
    \        }\n    }\n    for let k in stride(from: 0, to: n, by: 1) {\n        if\
    \ min > nums[k] + nums[k-1] {\n            min = nums[k] + nums[k-1]\n       \
    \ }\n    }\n    return min", "    // Write your code here.\n    var sum: Int =\
    \ 0\n    for i in 0..<nums.count {\n        for j in 0..<nums.count {\n      \
    \      if j != i {\n                sum += nums[j] + nums[i]\n            }\n\
    \        }\n    }\n    return sum", "    if nums.isEmpty() {\n        return 0\n\
    \    }\n    var minSum = nums[0]\n    for num in nums {\n        if num < 0 {\n\
    \            continue\n        }\n        minSum += num\n    }\n    return minSum",
  "  guard nums.count != 0 else { return 0 }\n  \n  var minSum = -Double.infinity\n\
    \  \n  for index in 0..<nums.count {\n    if let indexSum = nums[index] + minSum,\
    \ indexSum <= minSum {\n      minSum = indexSum\n    }\n  }\n  return minSum",
  "    var sum = 0\n    var minSum = Int.max\n    for i in nums {\n        sum +=\
    \ i\n        if sum < minSum {\n            minSum = sum\n        }\n    }\n \
    \   return minSum", "    // TODO: Pre-allocate result\n    var result = Int.max\n\
    \n    for num in nums {\n        if num > result {\n            result = num\n\
    \        }\n    }\n    return result", "    var min = Int.max\n    for a in nums\
    \ {\n        for b in nums {\n            min += a\n        }\n    }\n    return\
    \ min", "    var maxSum = -(1 << (32 - 2))\n    for n in nums {\n        if n\
    \ > 0 {\n            maxSum = maxSum * n + n\n        }\n    }\n    return maxSum",
  "    var minSoFar = Int.max\n    for n in nums {\n        if n != 0 {\n        \
    \    minSoFar = min(minSoFar, n - nums.reduce(0, { $0 + $1 }))\n        }\n  \
    \  }\n    return minSoFar", "    var minSum = nums[0]\n    for num in nums {\n\
    \        minSum = minSum - num\n    }\n    return minSum", "    var minSum: Int\
    \ = Int.max\n    for n in nums {\n        minSum = min(minSum, (n + minSubArraySum(nums[0..<n]))!)\n\
    \    }\n    return minSum", "    var result = 0\n    var startIndex = 0\n    var\
    \ endIndex = 0\n    for i = 0; i <= nums.count - 1; i++ {\n        startIndex\
    \ = endIndex\n        endIndex = i\n        result = result + nums[startIndex]\n\
    \        if startIndex < nums.count - 1 && nums[endIndex + 1] > nums[startIndex]\
    \ {\n            result += nums[endIndex + 1] - nums[startIndex + 1]\n       \
    \ }\n    }\n    return result", "    guard nums.count > 0 else { return 0 }\n\
    \    guard !nums.isEmpty else { return 0 }\n\n    let minSum = nums[0]\n    for\
    \ n in 1..<nums.count {\n        let sum = nums[n] - minSum\n        if sum <\
    \ 0 {\n            return sum\n        }\n        minSum = sum\n    }\n    return\
    \ minSum", "    var maxSum = -10000\n    for num in nums {\n        let sum =\
    \ nums.reduce(0, combine: {$0 + $1})\n        if sum > maxSum {\n            maxSum\
    \ = sum\n        }\n    }\n    return maxSum", "    // https://leetcode.com/problems/minimum-subarray/discuss/106965/Python-version-by-Nick\n\
    \    var maxSum = nums[0]\n    for idx in 1..<nums.count {\n        if maxSum\
    \ < 0 {\n            return -maxSum\n        }\n        maxSum = max(nums[idx],\
    \ maxSum)\n    }\n    return maxSum", "    guard let low = nums.first else { return\
    \ 0 }\n    return min {\n        let sum = min {\n            if nums.first <\
    \ low { return low }\n            else { return nums.last }\n        }\n     \
    \   let end = min {\n            if nums.last > sum { return nums.last }\n   \
    \         else { return nums.first }\n        }\n        nums.enumerated().forEach\
    \ {\n            guard let i = $0.offset else { return }\n            guard $0.value\
    \ < sum else { return }\n            sum += nums[i]\n        }\n        return\
    \ sum\n    }", "\tguard nums.count > 0 else {\n\t\treturn 0\n\t}\n\tvar minSoFar:\
    \ Int = 0\n\tfor i in 0..<nums.count {\n\t\tlet currentSum = nums[i]\n\t\tvar\
    \ j = 0\n\t\tfor k in i..<nums.count {\n\t\t\tcurrentSum += nums[k]\n\t\t\tif\
    \ currentSum < minSoFar {\n\t\t\t\tminSoFar = currentSum\n\t\t\t}\n\t\t\tj +=\
    \ 1\n\t\t}\n\t}\n\treturn minSoFar", "    var result: Int = 0\n\n    for n in\
    \ nums {\n        if n > result {\n            result = n\n        }\n    }\n\n\
    \    return result", '    return min(nums.filter { $0 > 0 }).reduce(0, combine:
    +)', "  var sum = 0\n  \n  for num in nums {\n    sum += num\n  }\n\n  return\
    \ sum", "    guard nums.count != 0 else {\n        return 0\n    }\n    var minimumSum\
    \ = nums[0]\n    var index = 0\n    while index < nums.count {\n        minimumSum\
    \ = min(minimumSum + nums[index], nums[index + 1])\n        index += 1\n    }\n\
    \    return minimumSum", "    guard !nums.isEmpty else { return Int.min }\n  \
    \  \n    var min = Int.min\n    var minArray: Array<Int> = nums\n    \n    for\
    \ i in 0..<min(nums.count, minArray.count) {\n        var sum = minArray[i] +\
    \ minArray[min(i, minArray.count - 1)]\n        \n        min = min(min, sum)\n\
    \        minArray.remove(at: i)\n        \n        if i == minArray.count - 1\
    \ {\n            minArray.append(0)\n        }\n    }\n    \n    return min",
  "    precondition(nums.count > 0, \"nums must have at least 1 element\")\n    let\
    \ numsLength = nums.count\n    if numsLength == 1 {\n        return nums[0]\n\
    \    }\n    var min = nums[0]\n    for index in 1..<numsLength {\n        for\
    \ value in 1..<numsLength {\n            if value < index {\n                continue\n\
    \            }\n            min = min(value, min + nums[index - 1])\n        }\n\
    \    }\n    return min", "    let sum = nums.reduce(0, combine: { $0 + $1 })\n\
    \    guard sum != 0 else {\n        return 0\n    }\n    let minSubArray = nums.filter{$0\
    \ >= sum}.min()\n    return sum - minSubArray!", "  if nums.isEmpty { return 0\
    \ }\n  let leftSum = minSubArraySum(nums.prefix(2))\n  let rightSum = minSubArraySum(nums.suffix(2))\n\
    \  return min(leftSum, rightSum) + min(nums[0], nums[1])", "    var minSum = nums[0]\n\
    \    for i in 1..<nums.count {\n        if nums[i-1] > nums[i] {\n           \
    \ minSum = max(nums[i-1], minSum)\n        }\n    }\n    return minSum", "   \
    \ var minSum = -Int.max\n\n    for i in 0 ..< nums.count {\n        let sum =\
    \ nums.reduce(0) { (sum, cur) -> Int in\n            return sum + cur\n      \
    \  }\n\n        if sum < minSum {\n            minSum = sum\n        }\n    }\n\
    \n    return minSum", "    if nums.isEmpty {\n        return 0\n    }\n\n    let\
    \ minSum = nums[0]\n    var sum = 0\n\n    for x in 1..<nums.count {\n       \
    \ if nums[x] == nums[x-1] {\n            sum += x\n        } else {\n        \
    \    sum = sum + minSum\n        }\n    }\n\n    return sum + minSum", "    var\
    \ min = nums[0]\n    var sum = nums[0]\n    for n in nums {\n        if n >= min\
    \ {\n            sum += n\n        } else {\n            min = n\n           \
    \ sum = n\n        }\n    }\n    return sum", "    let low = Int64(nums.min())\n\
    \    let high = Int64(nums.max)\n\n    var sum = low\n\n    for num in nums where\
    \ num < low || num > high {\n        let mid = low + high\n        sum = mid\n\
    \        if num < mid {\n            low = mid\n        } else {\n           \
    \ high = mid\n        }\n    }\n    return sum", "    var minSum = nums[0]\n \
    \   for i in 1 ..< nums.count {\n        minSum = minSum + nums[i]\n    }\n  \
    \  return minSum", "    guard nums.count > 0 else { return 0 }\n    var sum =\
    \ nums[0]\n    for element in nums {\n        sum += element\n    }\n    return\
    \ sum", "    let numsLength  = nums.count\n    var sumOfMins = nums[0]\n    for\
    \ i in 0..<(numsLength-1) {\n        if sumOfMins > nums[i] {\n            sumOfMins\
    \ = nums[i]\n        }\n    }\n    return sumOfMins", "    \n    var minSum =\
    \ nums[0]\n    for n in 1..<nums.count {\n        let s = minSum + nums[n]\n \
    \       minSum = s\n    }\n    return minSum", "    var min = INFINITY\n    var\
    \ max = 0\n    for num in nums {\n        if num < min {\n            min = num\n\
    \        } else {\n            max += num\n        }\n    }\n    return max",
  "    // We have a simple solution with O(n) time and O(n) space,\n    // but a better\
    \ solution with better space is possible.\n\n    // Create an array of size n\
    \ and initialize to infinity.\n    // We could create a vector of size n and initialize\
    \ to infinity as well\n    // but this approach is easier to understand.\n   \
    \ var minSum = Int.max\n    var minSumIndex = 0\n    for i in 0..<nums.count {\n\
    \        minSum = min (minSum, nums[i] + minSum)\n        if minSum == nums[i]\
    \ {\n            minSumIndex = i\n        }\n    }\n    return minSum", '    return
    minSubArraySumImpl(nums, 0, nums.count - 1, 0)', "    guard !nums.isEmpty else\
    \ { return 0 }\n\n    var min = nums[0]\n    for i in 1..<nums.count {\n     \
    \   min = min(nums[i], min)\n    }\n    return min", "    if nums.isEmpty {\n\
    \        return Int.max\n    }\n    \n    var min = Int.max\n    var minSubArray\
    \ = [0]\n    var minSubArraySum = 0\n    \n    for i in 0 ..< nums.count {\n \
    \       let sum = nums[i] + minSubArraySum\n        \n        if sum < min {\n\
    \            min = sum\n            minSubArray = [i]\n            minSubArraySum\
    \ = sum\n        } else if sum == min {\n            minSubArray.append(i)\n \
    \           minSubArraySum += sum\n        }\n    }\n    \n    return min", " \
    \ var minSum: Int = 0\n  for num in nums {\n    if num >= minSum {\n      minSum\
    \ = num\n    } else {\n      minSum = minSum + num\n    }\n  }\n  return minSum",
  "    // Write your code here\n    var sum = 0\n    for v in nums {\n        sum\
    \ = sum + v\n    }\n    return sum", "    var sum = 0\n    var min = nums[0]\n\
    \    for i in nums.indices {\n        if i > 0 && nums[i] < nums[i-1] {\n    \
    \        sum += nums[i]\n        } else {\n            if sum > min {\n      \
    \          min = sum\n            }\n            sum = 0\n        }\n    }\n \
    \   return min", "  if nums.isEmpty() {\n    return 0\n  }\n  guard nums.isEmpty\
    \ == false else {\n    return -1\n  }\n  guard nums.isEmpty == true else {\n \
    \   return -2\n  }\n  var minSoFar = nums[0]\n  for i in 1..<nums.count {\n  \
    \  let sum = nums[i] + nums[i - 1]\n    if sum < minSoFar {\n      minSoFar =\
    \ sum\n    }\n  }\n  return minSoFar", "    var min = Double.infinity\n    for\
    \ num in nums {\n        var subArraySum = Double.infinity\n        for (i, element)\
    \ in stride(from: nums.startIndex, to: nums.endIndex, by: 1).enumerate() {\n \
    \           if nums[element] > num {\n                subArraySum -= num\n   \
    \         } else {\n                subArraySum += num\n            }\n      \
    \  }\n        min = min(min, subArraySum)\n    }\n    return Int(min)", "    var\
    \ min = Int()\n    for num in nums {\n        if min > num {\n            min\
    \ = num\n        }\n    }\n    return min", '    return subArraySum(nums, nums.count)
    - 1', "    // If there is only one element\n    if nums.count == 1 {\n       \
    \ return nums[0]\n    }\n\n    // Initialize the min sum\n    var minSum = nums[0]\n\
    \n    // Start with the second element and subtract until there's no more second\
    \ element\n    for index in 1..<nums.count {\n        if nums[index-1] > minSum\
    \ {\n            minSum -= nums[index-1]\n        }\n    }\n\n    // Return the\
    \ min sum\n    return minSum", "    // sort nums\n    let sortedNums = nums.sort()\n\
    \    var minSum = sortedNums[0]\n    for num in sortedNums {\n        if num <\
    \ 0 {\n            minSum -= num\n        } else {\n            minSum -= minSum\
    \ + num\n        }\n    }\n    return minSum", "    // base case\n    if nums.isEmpty\
    \ {\n        return 0\n    }\n\n    var minSum = 0\n\n    for i : Int in 1...nums.count\
    \ {\n        var maxSum = nums[0]\n        var sum = 0\n\n        for j : Int\
    \ in 1...i {\n            sum += nums[j]\n            maxSum = max(sum, maxSum)\n\
    \        }\n\n        if maxSum > minSum {\n            minSum = maxSum\n    \
    \    }\n    }\n    return minSum", "    guard nums.count > 0 else {\n        return\
    \ 0\n    }\n\n    let leftSum = nums[0]\n    var rightSum = nums[0]\n    for _\
    \ in 1..<nums.count {\n        if leftSum > rightSum {\n            rightSum +=\
    \ nums[_]\n        } else {\n            leftSum += nums[_]\n        }\n    }\n\
    \n    if leftSum == rightSum {\n        return 0\n    }\n    return leftSum",
  "    var result: Int = 0\n    var next: Int = 0\n    for a in nums {\n        for\
    \ b in nums {\n            if a == b {\n                continue\n           \
    \ }\n            next = a + b\n            if next < result {\n              \
    \  result = next\n            }\n        }\n    }\n    return result", "    var\
    \ sum: Int = 0\n    for var i = 0; i < nums.count; i++ {\n        sum += nums[i]\n\
    \    }\n    return sum", "    var minium = 0\n    var result = 0\n    for x in\
    \ nums {\n        let y = x + minium\n        if y + result > minium {\n     \
    \       result = y + minium\n        }\n        minium = y\n    }\n    return\
    \ result", "    // Find start and end index\n    let start = nums.startIndex\n\
    \    let end = nums.endIndex\n    var minSum: Int = 0\n\n    // Iterate over each\
    \ subarray\n    for i in start...end {\n        // If current element is negative,\
    \ increment the sum\n        if nums[i] < 0 {\n            minSum = nums[i] -\
    \ minSum\n        }\n        // Otherwise, the sum is 0\n        else {\n    \
    \        minSum = 0\n        }\n\n        // If sum is negative, we need to update\
    \ the minSum\n        if minSum < 0 {\n            minSum = nums[i]\n        }\n\
    \    }\n\n    // The minSum is now the last element of the array.\n    return\
    \ minSum", "    var minSum = nums[0]\n    var index = [0]\n    for index in 1..<nums.count\
    \ {\n        minSum = nums[index] + minSum\n    }\n    return minSum", "    var\
    \ minSum = nums[0]\n    for _ in 1...nums.count {\n        minSum = minSum - nums[nums.index(minSum)]\
    \ + nums[0]\n    }\n    return minSum", "    let len = nums.count\n    var min\
    \ = nums[0]\n    for i in 0..<len {\n        for j in 0..<len {\n            min\
    \ = min(i, j)\n        }\n    }\n    return min", "    var minSum = nums[0]\n\
    \    for i in 1..<nums.count {\n        minSum = minSum + nums[i]\n    }\n   \
    \ return minSum", "    func recursiveMinSum(\n        sum: Int, subArray: [Int],\
    \ startIndex: Int) -> Int {\n            if startIndex == subArray.count {\n \
    \               return sum\n            }\n            let minimum = subArray[startIndex]\n\
    \            let rest = subArray[startIndex + 1]\n            return recursiveMinSum(minimum\
    \ + sum, rest, startIndex + 1)\n        }\n    return recursiveMinSum(0, nums,\
    \ 0)", "    let result = nums.reduce(0) { (result, num) -> Int in\n        let\
    \ currentSum = result + num\n        if currentSum < result {\n            result\
    \ = currentSum\n        }\n        return result\n    }\n    return result", " \
    \   guard nums.count > 0 else {\n        return 0\n    }\n    let sum = nums.reduce(0)\
    \ {\n        guard $1 < $0 else {\n            $0\n        }\n        else { $1\
    \ + $0 }\n    }\n    return sum", "    if nums.isEmpty {\n        return 0\n \
    \   }\n    var sum = 0\n    var min = nums[0]\n    for i in 1..<nums.count {\n\
    \        if sum > sum + nums[i] {\n            sum = sum + nums[i]\n         \
    \   min = nums[i]\n        } else if sum < sum + nums[i] {\n            sum =\
    \ sum + nums[i]\n            min = nums[i]\n        }\n    }\n    return sum",
  "    if nums.isEmpty() {\n        return 0\n    }\n\n    var sum = nums.reduce(0,\
    \ combine: +)\n    var leftSum = 0\n    for v in nums {\n        leftSum += v\n\
    \        sum += leftSum\n    }\n    return sum", "    // Write your code here.\n\
    \    let sum = 0\n    for num in nums {\n        sum += num\n    }\n    return\
    \ sum", "    guard nums.count > 0 else {\n        return 0\n    }\n    if nums.count\
    \ == 1 {\n        return nums[0]\n    }\n    var max = nums[0]\n    for num in\
    \ nums {\n        if max < num {\n            max = num\n        }\n    }\n  \
    \  let min = max\n    var sum = Int()\n    for num in nums {\n        if num <\
    \ min {\n            sum += max\n            min = num\n        }\n        else\
    \ {\n            sum += num\n        }\n    }\n    return sum", "    guard nums.isEmpty\
    \ == false else { return Int.max }\n    guard let min = nums.first else { return\
    \ Int.max }\n    return nums.reduce(min, { min, num in min + num })", "    guard\
    \ nums.count > 0 else {\n        return 0\n    }\n    guard nums.count == 1 ||\
    \ nums.count > 100 else {\n        return 0\n    }\n    guard let firstNum = nums.first\
    \ else {\n        return 0\n    }\n    var subSum = firstNum\n    for i in 1...nums.count\
    \ {\n        if nums[i-1] > subSum {\n            subSum = nums[i-1]\n       \
    \ }\n    }\n    return subSum", "    var sum = 0\n    for num in nums {\n    \
    \    sum += num\n    }\n    return sum", "    var minSum = nums[0]\n    for n\
    \ in nums {\n        if n == minSum {\n            continue\n        }\n     \
    \   var subSum = minSum + n\n        minSum = subSum\n    }\n    return minSum",
  "  var min = Int.max\n  for num in nums {\n    min = min + num\n  }\n  return min",
  "    guard !nums.isEmpty else {\n        return 0\n    }\n    var minSum = nums[0]\n\
    \    for num in nums.dropFirst() {\n        minSum = minSum + num\n    }\n   \
    \ return minSum", "    var minSum = nums[0]\n    for i : Int in 1 ..< nums.count\
    \ {\n        minSum = i\n        for j : Int in 0 ..< i {\n            if (nums[j]\
    \ < minSum) {\n                minSum = nums[j]\n            }\n        }\n  \
    \  }\n    return minSum", "    if nums.isEmpty {\n        return 0\n    }\n  \
    \  var sum = nums[0]\n    for num in nums {\n        sum += num\n    }\n    if\
    \ sum < 0 {\n        return sum\n    }\n    var minSum = sum\n    for num in nums\
    \ {\n        sum /= num\n        if sum < 0 {\n            return sum\n      \
    \  }\n        if sum < minSum {\n            minSum = sum\n        }\n    }\n\
    \    return minSum", "  guard !nums.isEmpty else { return 0 }\n  var sum = 0\n\
    \  var n = nums.count\n  for number in nums {\n    sum += number\n    if sum <\
    \ 0 {\n      sum = -sum\n      n -= 1\n    }\n  }\n  return sum", "    var min\
    \ = Int64(Int.max)\n\n    for n in nums {\n        let leftSum = 1 + n + (n -\
    \ min) * Int64(nums.count - 1)\n        let rightSum = 1 + n + n * Int64(nums.count)\n\
    \        if leftSum < min {\n            min = leftSum\n        } else if rightSum\
    \ < min {\n            min = rightSum\n        }\n    }\n    return min", '  return
    minSubArraySumHelper(nums, 0, nums.count, 0)', "  let min = nums[0]\n  var s =\
    \ nums[0]\n  for n in nums {\n    s = s + n\n    if s < min {\n      min = s\n\
    \    }\n  }\n  return min", "    guard nums.count > 0 else { return 0 }\n    var\
    \ minSum = nums[0]\n    for i in 1..<nums.count {\n        if nums[i-1] > minSum\
    \ {\n            minSum = nums[i-1]\n        }\n    }\n    return minSum", " \
    \   var min = nums[0]\n    var sum = 0\n    for num in nums {\n        sum +=\
    \ num\n        if sum < min {\n            min = sum\n        }\n    }\n    return\
    \ min", "    if nums.isEmpty() {\n        return 0\n    }\n    \n    var min =\
    \ nums[0]\n    var sum = 0\n    \n    for i in 0 ..< nums.count {\n        sum\
    \ += nums[i]\n        if sum < min {\n            min = sum\n        }\n    }\n\
    \    \n    return min", "    var sum = 0\n    for num in nums {\n        sum +=\
    \ num\n    }\n    return sum", "    guard !nums.isEmpty else {\n        return\
    \ 0\n    }\n    var min = nums[0]\n    for n in nums {\n        guard n >= 0 else\
    \ {\n            return min // invalid case\n        }\n        if min > n {\n\
    \            min = n\n        }\n    }\n    return min", "    let subArrays =\
    \ nums.reduce((results: [Int], num: Int) -> [Int] {\n        var resultSubArrays\
    \ = [Int]()\n        for subArraySubIndex in 0..<nums.count {\n            let\
    \ subArray = [nums[subArraySubIndex]]\n            resultSubArrays.append(subArray\
    \ + results[subArraySubIndex])\n        }\n        results.append(resultSubArrays)\n\
    \        return results\n        }, [])\n\n    return subArrays.reduce(Int.min)\
    \ {\n        min($0 + $1, $0 + $2)\n    }", "  let n = nums.count\n  if n < 1\
    \ {\n    return 0\n  }\n  let dp = [Int](repeating: 0, count: n+1)\n  dp[0] =\
    \ 1\n  for k in 1..<n {\n    dp[k] = min(dp[k-1], dp[k] + nums[k])\n  }\n  return\
    \ dp[n]", "    if nums.isEmpty {\n        return Int(0)\n    }\n    var min: Int\
    \ = nums[0]\n    var minSum = nums[0]\n    var sum: Int = 0\n    for idx in 1..<nums.count\
    \ {\n        sum += nums[idx]\n        if sum < min {\n            min = sum\n\
    \            minSum = sum\n        } else if sum > minSum {\n            minSum\
    \ = sum\n        }\n    }\n    return minSum", "    var min = nums[0]\n    for\
    \ i in 1..<nums.count {\n        min = min > nums[i] || min == 0 ? nums[i] : min\n\
    \    }\n    return min", "    let sum = nums.reduce(0, combine: +)\n    let minSum\
    \ = sum\n    for i in 0..<nums.count {\n        sum += nums[i]\n        if sum\
    \ < minSum {\n            minSum = sum\n        }\n    }\n    return minSum",
  "    if nums.isEmpty {\n        return 0\n    }\n    var minSum = nums[0]\n    for\
    \ i in 1..<nums.count {\n        minSum += nums[i]\n    }\n    return minSum",
  "  if nums.isEmpty { return 0 }\n  let numsCount = nums.count\n  return nums.reduce(0,\
    \ combine: minSubArraySum)", "    if nums.isEmpty { return 0 }\n    var minSum\
    \ = nums[0]\n    for n in nums {\n        if minSum > n {\n            minSum\
    \ = n - minSum\n        }\n    }\n    return minSum", "    if nums.isEmpty {\n\
    \        return 0\n    }\n    var maxSum = nums[0]\n    for num in nums {\n  \
    \      if num > maxSum {\n            maxSum = num\n        }\n    }\n    for\
    \ num in nums {\n        if maxSum - num < 0 {\n            return maxSum\n  \
    \      }\n        maxSum -= num\n    }\n    return maxSum", "    var min = nums[0]\n\
    \    for i in 1..<nums.count {\n        if nums[i] < min {\n            min =\
    \ nums[i]\n        }\n    }\n    return min", "    guard nums.count > 0 else {\n\
    \        return 0\n    }\n\n    let minSum = nums[0]\n    for i in 1..<nums.count\
    \ {\n        minSum = minSum + nums[i]\n    }\n\n    return minSum", "    var\
    \ ans = nums[0]\n    var minAns = nums[0]\n    for n in nums {\n        if n <\
    \ minAns {\n            minAns = n\n        }\n        if n != 0 && minAns !=\
    \ 0 {\n            ans += minAns\n        }\n        minAns = n\n    }\n    return\
    \ ans", "    \n    if nums.isEmpty {\n        return math.infinity\n    }\n  \
    \  \n    var sum: Int = 0\n    for i in 0..<nums.count {\n        sum += nums[i]\n\
    \    }\n    \n    var minSum = sum\n    for i in 0..<nums.count {\n        sum\
    \ -= nums[i]\n        if sum < minSum {\n            minSum = sum\n        }\n\
    \    }\n    return minSum", "    var sum = 0\n    for num in nums {\n        if\
    \ num > 0 {\n            sum += num\n        }\n    }\n    return sum", "    //\
    \ base case\n    if nums.count == 0 {\n        return nums[0]\n    }\n\n    //\
    \ Find minimum sum between any two consecutive elements in nums\n    // inclusive.\n\
    \    var sum: Int = nums[0]\n    for i in 1..<nums.count {\n        sum = min(sum,\
    \ nums[i])\n    }\n\n    // For each remaining element in nums, sum up the minimum\
    \ of those\n    // elements and the remaining sum.\n    var minSum = sum\n   \
    \ for i in nums.count-1..<nums.count {\n        minSum = min(minSum, nums[i]+sum)\n\
    \    }\n\n    return minSum", "    guard nums.isEmpty else { return nums.reduce(0)\
    \ - nums[0] }\n    return min(nums.reduce(0), nums.reduce(0) {\n        guard\
    \ $0 >= $1 else {\n            return $0\n        }\n        return $1\n    })",
  '    return nums.min().flatMap { sum in subArraySum(nums, nums.firstIndex(of: $0),
    nums.firstIndex(of: $1) + 1, sum) }.reduce(0, +)', "    let sum = nums.reduce(0,\
    \ combine: +)\n    return sum", "    var sum = 0\n    for number in nums {\n \
    \       sum += number\n    }\n    return sum", "  if nums.isEmpty {\n    return\
    \ 0\n  }\n  var minSum = nums[0]\n  for num in nums[1..] {\n    minSum = min(minSum\
    \ + num, num)\n  }\n  return minSum", "    if nums.isEmpty { return 0 }\n    \n\
    \    var minSum: Int = nums[0]\n    for i in 1..<nums.count {\n        minSum\
    \ += nums[i]\n    }\n    \n    if minSum < 0 { return 0 }\n    \n    return minSum",
  "    var minSoFar = nums[0]\n    for num in nums {\n        var newMin = num\n \
    \       for (i, v) in nums.enumerated() {\n            if i != i {\n         \
    \       newMin += v\n            }\n        }\n        minSoFar = min(minSoFar,\
    \ newMin)\n    }\n    return minSoFar", "  if nums.isEmpty {\n    return 0\n \
    \ }\n  var min = nums[0]\n  for i in 1..<nums.count {\n    if min > nums[i] {\n\
    \      min = nums[i]\n    }\n  }\n  return min"]
stop_tokens:
- "\n}"
