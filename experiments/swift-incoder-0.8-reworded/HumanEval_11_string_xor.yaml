name: HumanEval_11_string_xor
language: swift
prompt: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(a:\
  \ \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String, b: String) -> String\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\"\
  ) == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
  \ \"0101\", b: \"0000\") == \"0101\")"
completions: ["\tlet resultLength = min(len(a), len(b)) + len(b) - len(a)\n\tlet resultBuffer\
    \ = UnsafeMutablePointer<Int8>(allocatingCapacity: resultLength)\n\tdefer { free(resultBuffer)\
    \ }\n\t\n\tvar aStart, bStart, aIndex, bIndex, carryOver\n\t\n\tfor aIndex = 0,\
    \ bIndex = 0; aIndex < len(a) && bIndex < len(b); {\n\t\taStart = aIndex\n\t\t\
    bStart = bIndex\n\t\t\n\t\tif aIndex < len(a) && bIndex < len(b) && a[bStart]\
    \ == '1' && a[aStart] == '0' {\n\t\t\tcarryOver = a[aStart]\n\t\t\taIndex += 1\n\
    \t\t}\n\t\tif aIndex < len(a) && bIndex < len(b) && b[bStart] == '1' && b[aStart]\
    \ == '0' {\n\t\t\tcarryOver = b[bStart]\n\t\t\tbIndex += 1\n\t\t}\n\t\t\n\t\t\
    if aIndex < len(a) {\n\t\t\tresultBuffer[resultIndex] = carryOver\n\t\t\tresultIndex\
    \ += 1\n\t\t}\n\t\tif bIndex < len(b) {\n\t\t\tresultBuffer[resultIndex] = carryOver\n\
    \t\t\tresultIndex += 1\n\t\t}\n\t}\n\t\n\treturn String(bytes: resultBuffer, encoding:\
    \ .utf8)", "    let a = String(a)\n    let b = String(b)\n    let resultSize =\
    \ min(len(a), len(b)) >> 1\n    if resultSize != 0 {\n        if resultSize >\
    \ 1 {\n            for i in 0..<resultSize {\n                let tmp = a[i <<\
    \ 1]\n                let j = i + resultSize\n                let tmp2 = b[j <<\
    \ 1]\n                a[i] = tmp2 ^ tmp\n                b[j] = tmp2 ^ tmp\n \
    \           }\n        }\n        return String(a)\n    }\n    if a.len() < b.len()\
    \ {\n        return String(a)\n    }\n    return String(b)", "    var result =\
    \ \"\"\n    for _, bCh in b.characters {\n        if aChar == bCh {\n        \
    \    result += aChar\n        }\n    }\n    return result", '    return a.codePoints().filter({
    $0 != b.codePoints().first() }).map({ String($0) }).joined()', "    var result\
    \ = \"\"\n    for _, bByte in b.characters {\n        if let aByte = a.characters.first\
    \ {\n            result = result + String(aByte ^ bByte)\n        } else {\n \
    \           return \"\"\n        }\n    }\n    return result", "    var result\
    \ = \"\"\n    for i in 0..<len(b) {\n        if b[i] != a[i] {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result", "    let length = min(count_bytes(a), count_bytes(b))\n \
    \   var result = \"\"\n\n    for i in 0..<length {\n        result += (a[i & length]\
    \ != b[i & length]) ? \"1\" : \"0\"\n    }\n\n    return result", "    let ones\
    \ = String(a)\n    let zeros = String(b)\n    var c = \"\"\n    for char in ones\
    \ {\n        c = c + String(char.unicodeScalars.filter({ $0.value == 0x00 }).count)\n\
    \    }\n    for char in zeros {\n        c = c + String(char.unicodeScalars.filter({\
    \ $0.value == 0x00 }).count)\n    }\n    return c", "    guard a.utf8.count ==\
    \ b.utf8.count else {\n        fatalError(\"Strings should have equal length\"\
    )\n    }\n\n    var result = \"\"\n    for i in 0..<a.utf8.count {\n        result\
    \ += char(a[i] ^ b[i])\n    }\n\n    return result", "\treturn a.repeated(by:\
    \ b.count).reduce(String.init(), { $0 ^ $1 })", "    let length = max(len(a),\
    \ len(b))\n    var result = \"\"\n    var carry = 0\n    for i in 0..<length {\n\
    \        if a[i] == b[i] {\n            carry += 1\n        }\n        else {\n\
    \            result += String(carry).uppercase\n            carry = 0\n      \
    \  }\n        if carry == 2 {\n            result += String(carry)\n         \
    \   carry = 0\n        }\n    }\n    if carry > 0 {\n        result += String(carry)\n\
    \    }\n    return result", "    let bitMask = 0x3FF\n    let result = (a as NSString).stringByXORing(b\
    \ as NSString).stringByAppendingString((a as NSString).stringByXORing(b as NSString))\n\
    \    return result.stringByReplacingOccurrencesOfString(a.bridge(), withString:\
    \ b.bridge())", '    return String(XOR(UTF8String(a), UTF8String(b)))', "    let\
    \ length = max(a.count, b.count)\n\n    let mut result = String::with_capacity(length)\n\
    \    for i in 0..<length {\n        let a_ind = a.index(i, offsetBy: 0)\n    \
    \    let b_ind = b.index(i, offsetBy: 0)\n        if a_ind < b_ind {\n       \
    \     result.append(a[..a_ind])\n        } else {\n            result.append(b[..b_ind])\n\
    \        }\n    }\n    result", "    if a != b { \n        let a2 = string_to_bits(a)\n\
    \        let b2 = string_to_bits(b)\n        let result = xor(a2, b2)\n      \
    \  return result.toString(radix: 2)\n    }\n    return \"\"", '    return string_binaryXOR(a,
    b)', '    return a.binaryXor(b)', '    return string_to_binary(a).XOR(string_to_binary(b)).String()',
  "    if a == \"\" || b == \"\" {\n        return \"\"\n    }\n    var res = \"\"\
    \n    for a_ch in a.characters {\n        res += String(a_ch ^ b.characters[b.startIndex])\n\
    \    }\n    return res", '    return hex_string(hex_sub(a, "0") + hex_sub(b, "0"))',
  '    return String(a) XOR(b) // Equivalent to String(a) ^ String(b)', "    var str\
    \ = \"\"\n    for _, b in zip(a.characters, b.characters) {\n        str = String(format:\
    \ \"%c\", str) ^ String(format: \"%c\", b)\n    }\n    return String(str)", " \
    \   var res = \"\"\n    for i in 0..<a.count {\n        res += String(a[i]) ^\
    \ String(b[i])\n    }\n    return res", "  let l = (a as NSString).length &< (b\
    \ as NSString).length\n  \n  // Handle empty input strings\n  if l == 0 {\n  \
    \  return \"\"\n  }\n  \n  // Handle single character input strings\n  if l ==\
    \ 1 {\n    let c = a as NSString\n    let p = b as NSString\n    \n    // Handle\
    \ a character that is a and b\n    if c.characterAtIndex(0) == p.characterAtIndex(0)\
    \ { return \"\" }\n    \n    // Handle a character that is a or b\n    if c.characterAtIndex(0)\
    \ == p.characterAtIndex(1){ return c }\n    \n    return c\n  }\n  \n  // Handle\
    \ general strings\n  var result = \"\"\n  var c = 0\n  var p = 0\n  while c <\
    \ l {\n    // Handle two characters in a single iteration\n    if c < (l & 1)\
    \ {\n      let a = a as NSString\n      let b = b as NSString\n      \n      //\
    \ Handle character that is a and b\n      if a.characterAtIndex(c) == b.characterAtIndex(c)\
    \ { c += 1 }\n      \n      // Handle character that is a or b\n      if a.characterAtIndex(c)\
    \ == b.characterAtIndex(p) { p += 1 }\n    }\n    \n    // Handle single character\
    \ in a single iteration\n    if p < (l & 1) {\n      let a = a as NSString\n \
    \     let b = b as NSString\n      \n      // Handle character that is a and b\n\
    \      if a.characterAtIndex(p) == b.characterAtIndex(p) { p += 1 }\n      \n\
    \      // Handle character that is a or b\n      if a.characterAtIndex(p) == b.characterAtIndex(c)\
    \ { c += 1 }\n    }\n    \n    // Handle two characters in a single iteration\n\
    \    if c < (l & 1) {\n      let a = a as NSString\n      let b = b as NSString\n\
    \      \n      // Handle character that is a and b\n      if a.characterAtIndex(c)\
    \ == b.characterAtIndex(c) { c += 1 }\n      \n      // Handle character that\
    \ is a or b\n      if a.characterAtIndex(c) == b.characterAtIndex(p) { p += 1\
    \ }\n    }\n    \n    // Handle single character in a single iteration\n    if\
    \ p < (l & 1) {\n      let a = a as NSString\n      let b = b as NSString\n  \
    \    \n      // Handle character that is a and b\n      if a.characterAtIndex(p)\
    \ == b.characterAtIndex(p) { p += 1 }\n      \n      // Handle character that\
    \ is a or b\n      if a.characterAtIndex(p) == b.characterAtIndex(c) { c += 1\
    \ }\n    }\n    \n    // Handle two characters in a single iteration\n    if c\
    \ < (l & 1) {\n      let a = a as NSString\n      let b = b as NSString\n    \
    \  \n      // Handle character that is a and b\n", "\tvar result String\n\tfor\
    \ i in 0..<a.count {\n\t\tresult += String(a[i]) ^ String(b[i])\n\t}\n\treturn\
    \ result", "    let a = a.utf8CString\n    let b = b.utf8CString\n    if a ==\
    \ nil {\n        return b\n    }\n    if b == nil {\n        return a\n    }\n\
    \    var result = String(cString: nil)\n    defer { result.free() }\n    swift_xor_buf(&result,\
    \ a, b, a.count, b.count)\n    return result", "    if a != b {\n        return\
    \ String(xor(a, b))\n    }\n    return a", "    if a == \"0\" {\n        return\
    \ b\n    } else if a == \"1\" {\n        return b\n    }\n    return a + b", " \
    \   if a != nil && b != nil && a != \"\" && b != \"\" {\n        var result =\
    \ \"\"\n        for i in 0..<min(len(a), min(b)) {\n            if a[i] != b[i]\
    \ {\n                result += \"0\"\n            } else {\n                result\
    \ += \"1\"\n            }\n        }\n        if result != \"\" {\n          \
    \  if result == \"0\" {\n                result = \"1\"\n            } else {\n\
    \                result = \"0\"\n            }\n        }\n        return String(result)\n\
    \    } else {\n        return nil\n    }", '    return ""', "    var result =\
    \ \"\"\n    for _, bt := range []byte(b) {\n        result += '0' + (a[t] ^ bt)\n\
    \    }\n    return result", "    // Write your code here.\n    var result = \"\
    \"\n    for i in 0 ..< a.characters.count {\n        if a.characters.at(i) ==\
    \ b.characters.at(i) {\n            result += a.characters.at(i)\n        }\n\
    \    }\n    return result", "    return String(a.unicodeScalars.map({\n      \
    \  $0 == $1 ? 0 : 1\n    }).reduce(nil, { $0 != nil ? $0.1 & *$1 : nil })!)",
  "    var result = \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] != \"\
    0\" && a[i] != \"1\" {\n            result += \"0\"\n        } else {\n      \
    \      result += \"1\"\n        }\n    }\n    for i := 0; i < len(b); i++ {\n\
    \        if b[i] != \"0\" && b[i] != \"1\" {\n            result += \"0\"\n  \
    \      } else {\n            result += \"1\"\n        }\n    }\n    return result",
  "    func _loop(a: String, b: String) -> String {\n        let xor = a[0] ^ b[0]\n\
    \        let xor2 = (a[1] & b[1]) ? (xor << 1) ^ xor : xor\n        let xor3 =\
    \ (a[2] & b[2]) ? (xor2 << 1) ^ xor2 : xor2\n        let xor4 = (a[3] & b[3])\
    \ ? (xor3 << 1) ^ xor3 : xor3\n        let xor5 = (a[4] & b[4]) ? (xor4 << 1)\
    \ ^ xor4 : xor4\n        let xor6 = (a[5] & b[5]) ? (xor5 << 1) ^ xor5 : xor5\n\
    \        let xor7 = (a[6] & b[6]) ? (xor6 << 1) ^ xor6 : xor6\n        let xor8\
    \ = (a[7] & b[7]) ? (xor7 << 1) ^ xor7 : xor7\n        let xor9 = (a[8] & b[8])\
    \ ? (xor8 << 1) ^ xor8 : xor8\n        let xor10 = (a[9] & b[9]) ? (xor9 << 1)\
    \ ^ xor9 : xor9\n        let xor11 = (a[10] & b[10]) ? (xor10 << 1) ^ xor10 :\
    \ xor10\n        let xor12 = (a[11] & b[11]) ? (xor11 << 1) ^ xor11 : xor11\n\
    \        let xor13 = (a[12] & b[12]) ? (xor12 << 1) ^ xor12 : xor12\n        let\
    \ xor14 = (a[13] & b[13]) ? (xor13 << 1) ^ xor13 : xor13\n        let xor15 =\
    \ (a[14] & b[14]) ? (xor14 << 1) ^ xor14 : xor14\n        let xor16 = (a[15] &\
    \ b[15]) ? (xor15 << 1) ^ xor15 : xor15\n        return String(xor16)\n    }\n\
    \    return _loop(a: a, b: b)", "    if a == \"\" || b == \"\" {\n        return\
    \ \"\"\n    }\n\n    let aInt = string_to_int(a)\n    let bInt = string_to_int(b)\n\
    \    let result = Int(aInt) ^ Int(bInt)\n    let result = binary_to_string[result]\n\
    \n    return result", "    var a_char = UInt8(a.utf8)\n    var b_char = UInt8(b.utf8)\n\
    \    var res = \"\"\n    var remainder: UInt8 = 0\n\n    while a_char != 0 ||\
    \ b_char != 0 {\n        let carry = UInt8((a_char & b_char) ^ remainder)\n  \
    \      res += String(carry)\n        remainder = carry\n        a_char = UInt8(a_char\
    \ >> 1)\n        b_char = UInt8(b_char >> 1)\n    }\n\n    return res", "    if\
    \ a == \"00\" || b == \"00\" {\n        return \"00\"\n    }\n    if a == \"11\"\
    \ || b == \"11\" {\n        return \"01\"\n    }\n    var result = \"00\"\n  \
    \  for (i0, a0) in enumerate(a) {\n        for (i1, b1) in enumerate(b) {\n  \
    \          result += String(a0) - String(b1)\n        }\n    }\n    return result",
  "    if a != b {\n        var xorByte = UInt8(0)\n        for index in 0 ..< a.utf8.count\
    \ {\n            xorByte ^= UInt8(a.utf8[index]) ^ UInt8(b.utf8[index])\n    \
    \    }\n        return String(xorByte)\n    }\n    return a", "    var result\
    \ = \"0\"\n    for i in 0..<min(len(a), len(b)) {\n        if a[i] == b[i] {\n\
    \            result += a[i]\n            continue\n        }\n        if a[i]\
    \ != \"0\" && a[i] != \"1\" {\n            continue\n        }\n        if b[i]\
    \ != \"0\" && b[i] != \"1\" {\n            continue\n        }\n        result\
    \ += \"0\"\n        break\n    }\n    for _ in 1..<min(len(a), len(b)) {\n   \
    \     if a[0] != \"0\" && a[0] != \"1\" {\n            continue\n        }\n \
    \       if b[0] != \"0\" && b[0] != \"1\" {\n            continue\n        }\n\
    \        break\n    }\n    return result", "\tvar res String = \"\"\n\tfor idx,\
    \ c := range a {\n\t\tif b[idx] == '1' {\n\t\t\tres += c\n\t\t}\n\t}\n\treturn\
    \ res", "    var result = \"\"\n    for i = 0; i < len(a); i++ {\n        result\
    \ += a[i] ^ b[i]\n    }\n    return result", "    return string_from_char_codes(\n\
    \        char_code_xor_of_byte_slices(a.utf8_bridge(), b.utf8_bridge())\n    )",
  "    guard a != \"\" else { return \"\" }\n    guard b != \"\" else { return \"\"\
    \ }\n    var result = \"\"\n    var i = 0\n    let l1 = a.count\n    let l2 =\
    \ b.count\n    while i < l1 && i < l2 {\n        if a[i..<i + 1] == b[i..<i +\
    \ 1] {\n            result += String(a[i..<i + 1])\n            i += l1 - 1\n\
    \        } else {\n            result += \"0\"\n        }\n    }\n    while i\
    \ < l1 {\n        result += \"0\"\n        i += 1\n    }\n    while i < l2 {\n\
    \        result += \"0\"\n        i += 1\n    }\n    return result", '    return
    binaryXOR(a, b)', "    // TODO: replace with proper xor\n    return string_to_binary((a)\
    \ ^ (b))", "    var res = \"\"\n    for i := 0; i < len(a); i++ {\n        if\
    \ a[i] == b[i] {\n            res += a[i]\n        } else {\n            res +=\
    \ \"0\"\n        }\n    }\n    return res", '    return stringxor(a, b)', "  \
    \  let length = a.length\n    var c: [Int8] = [0]\n    var i = 0\n    repeat {\n\
    \        if i < length && a[i] == b[i] {\n            c[i] = 0\n        } else\
    \ {\n            c[i] = 1\n        }\n        i += 1\n    } while (i < length)\n\
    \    return string_from_chars(c)", "    var xor = String()\n\n    for index in\
    \ 0..<min(len(a), len(b)) {\n        xor += String(format: \"%02.2X\", Int(a[index])\
    \ ^ Int(b[index]))\n    }\n\n    return xor", "    guard a.characters.count ==\
    \ b.characters.count else {\n        fatalError(\"a and b must contain the same\
    \ number of characters\")\n    }\n\n    var result = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let ai = a[i] - '0'\n        let bi = b[i] - '0'\n        let value\
    \ = ai ^ bi\n        switch value {\n        case 0:\n            result += \"\
    0\"\n        case 1:\n            result += \"1\"\n        default:\n        \
    \    fatalError(\"result cannot be more than 2 bits\")\n        }\n    }\n   \
    \ return result", "    var result = \"\"\n\n    for i := 0; i < len(a); i++ {\n\
    \        if a[i] != b[i] {\n            result += String(a[i])\n        }\n  \
    \  }\n\n    return result", "    if a == b {\n        return a\n    }\n    let\
    \ n = (a as NSString).length + (b as NSString).length\n    var result = \"\"\n\
    \    if n <= 1 {\n        return result\n    }\n    for i in 0..<n {\n       \
    \ let a = a[0 ..< i]\n        let b = b[0 ..< i]\n        let aInt = Int(a)\n\
    \        let bInt = Int(b)\n        let xorInt = aInt xor bInt\n        let charInt\
    \ = xorInt as Character\n        result = String(charInt, radix: 16)\n    }\n\
    \    return result", "    assert(len(a) == 1 && len(b) == 1)\n    return String(a[0]\
    \ ^ b[0])", '    return string_intern(a) + string_intern(b).bytes().map(|v| v
    ^ 0xff).collect::<String>().unwrap_or("")', "    var res = \"\"\n    for _, bChar\
    \ := range b {\n        res += String(a[bChar] ^ bChar)\n    }\n    return res",
  "    var result = \"\"\n    for (ix = 0; ix < len(a); ix++ {\n        var v = UInt8((b[ix]\
    \ ^ a[ix]))\n        result = String(format: \"%02.2X\", v)\n    }\n    return\
    \ result", "    guard a.count > 0 && b.count > 0 else {\n        return \"0\"\n\
    \    }\n\n    let len = a.count\n    let mut ret = StringBuilder(len * 2)\n  \
    \  for i in 0..<len {\n        ret.append_char(Int(a[i]) ^ Int(b[i]))\n    }\n\
    \n    return ret.toString()", "    let l = a.length\n    let r = b.length\n  \
    \  if l != r {\n        throw AssertionError.unimplemented(\"Binary XOR is only\
    \ defined for equal length strings\")\n    }\n    var result: String = String()\n\
    \    var i = 0\n    while i < l {\n        let c = a[i] ^ b[i]\n        if c ==\
    \ 0 {\n            result = \"0\"\n        } else {\n            result = \"1\"\
    \ + result\n        }\n        i += 1\n    }\n    return result", "    if a !=\
    \ b {\n        return \"\"\n    }\n    return a", "    let a_utf8 = a.utf8.map\
    \ { String($0) }\n    let b_utf8 = b.utf8.map { String($0) }\n    var result =\
    \ \"\"\n    for i in 0..<a_utf8.count {\n        result += a_utf8[i] ^ b_utf8[i]\n\
    \    }\n    return result", "    let xor_result = UnsafePointer<UInt8>.allocate(capacity:\
    \ a.count)\n    let length = a.utf8CString.withCString { cptr in ptr in\n    \
    \    return ptr.withMemoryRebound(to: UInt8.self, capacity: a.count) { cptr in\
    \ xor_result.withMemoryRebound(to: UInt8.self, capacity: a.count) { cptr in xor_result.withMemoryRebound(to:\
    \ Int8.self, capacity: a.count) { cptr in UnsafeMutablePointer<UInt8>(cptr).xorBytes(aPtr:\
    \ cptr, another: bPtr, length: a.count, xorOut: xorOutPtr) } }\n    }\n    return\
    \ String(validatingUTF8: xor_result.baseAddress!, count: length)", "    var result:\
    \ String = \"\"\n    for aIndex in 0..<a.count {\n        for bIndex in 0..<b.count\
    \ {\n            if a.substring(aIndex, 1).isEqualTo(b, bIndex) {\n          \
    \      result = result + (\"0\" * (aIndex + 1 - a.count)).stringByAppending(\"\
    0\" * (b.count - b.count)).stringByAppending(a.substring(aIndex + 1))\n      \
    \          break\n            }\n        }\n    }\n    return result", "    let\
    \ s = a + b\n    return s.characters.reduce(\"\") {\n        a, b in\n       \
    \ let sum = Int(a) ^ Int(b)\n        return String(UnicodeScalar(UInt8(sum)))\n\
    \    }", "    let num1 = UInt8(a).bigEndian\n    let num2 = UInt8(b).bigEndian\n\
    \    return String(format: \"%08x\", num1 xor num2)", "    // TODO: handle empty\
    \ strings\n    if a != \"\" && b != \"\" {\n        var s = \"\"\n        for\
    \ i := 0; i < len(a); i++ {\n            s += a[i] ^ b[i]\n        }\n       \
    \ return s\n    }\n    return \"\"", "    var result = \"\"\n    for index in\
    \ 0 ..< min(len(a), len(b)) {\n        if a[index] == \"1\" {\n            if\
    \ result[len(result)-1] != \"0\" {\n                result += \"0\"\n        \
    \    } else {\n                result += \"1\"\n            }\n        } else\
    \ {\n            if result[len(result)-1] != \"1\" {\n                result +=\
    \ \"1\"\n            } else {\n                result += \"0\"\n            }\n\
    \        }\n    }\n    return result", "    var res = \"\"\n    for i := 0; i\
    \ < len(a); i++ {\n        res += string(a[i]^b[i])\n    }\n    return res", " \
    \   let lena = a.utf8.count\n    let lenb = b.utf8.count\n    if (lena == 0 ||\
    \ lenb == 0) || (lena != lenb) {\n        throw Error::InvalidInput(\"XOR requires\
    \ strings of equal length.\")\n    }\n    var result = \"\"\n    for i in 0 ..<\
    \ (lena - 1) {\n        result.append(String(format: \"%08b\", Int(a.utf8.bytes[i])\
    \ ^ Int(b.utf8.bytes[i])))\n    }\n    for i in 0 ..< (lenb - 1) {\n        result.append(String(format:\
    \ \"%08b\", Int(b.utf8.bytes[i]) ^ Int(a.utf8.bytes[i])))\n    }\n    return result",
  "    var result = \"\"\n    for idx, bit := range b {\n        if bit == \"1\" {\n\
    \            result += a[idx]\n        }\n    }\n    return result", "  var c\
    \ = [Int](repeating: 0, count: count_bits(a) * count_bits(b) * 2)\n  for idx in\
    \ 0..<c.count {\n    c[idx] = string_xor(a[idx], b[idx])\n  }\n  return str_from_bytes(c)",
  "\tchar2bin(a, &a)\n\tchar2bin(b, &b)\n\ta ^= b\n\treturn bin2str(&a)", "    var\
    \ result = \"\"\n    for i in a { result = result + String(i) }\n    for j in\
    \ b { result = result + String(j) }\n    return result", "\tlet ab = a.utf8\n\t\
    let bc = b.utf8\n\tvar result = \"\"\n\n\tfor k in 0..<ab.count {\n\t\tlet byteA\
    \ = ab[k]\n\t\tlet byteB = bc[k]\n\t\tlet result = byteA ^ byteB\n\t\tresult +=\
    \ String(format: \"%08x\", result)\n\t}\n\n\treturn result", "    let res = \"\
    0\"\n    for b in b.characters {\n        res.insert(res.characters.index(of:\
    \ b), a: a)\n    }\n    return res", '    return a + string_xor(a, b)', "\tvar\
    \ r : String = String()\n\tlet n = (a as NSString).length + (b as NSString).length\n\
    \tfor i in 0..<n {\n\t\tif Int(a[i.advanced(by: i)]) xor Int(b[i.advanced(by:\
    \ i)])\n\t\t\tr.appendChar(Int(a[i.advanced(by: i)])) }\n\treturn r", "    return\
    \ string(string([]rune(strxor(a, b)[:])),\n        string([]rune(strxor(a, b)[len(a):])))",
  "    var result = \"\"\n    for i in 0 ..< a.count {\n        if a[i] != \"0\" &&\
    \ b[i] != \"0\" {\n            result = \"0\"\n            break\n        } else\
    \ if a[i] == \"0\" && b[i] == \"0\" {\n            result = \"1\"\n          \
    \  break\n        }\n    }\n    return result", "    if a == \"\" || b == \"\"\
    \ {\n        return \"\"\n    }\n    let mut binary = BinaryHelper::from_string(a).unwrap();\n\
    \    binary.apply_xor_with_string(b).unwrap();\n    binary.to_string()", '    return
    bits.Xor(a, b).ToString()', "    let a_bytes = Array(a.utf8).map { UInt8($0) }\n\
    \    let b_bytes = Array(b.utf8).map { UInt8($0) }\n    \n    let result_bytes\
    \ = a_bytes.map { $0 ^ b_bytes[$0] }\n    return String(result_bytes.map { UInt8($0)\
    \ })", '    return string_xor_bytes([]byte(a), []byte(b))', "    if a == \"1\"\
    \ {\n        return b\n    }\n    if b == \"1\" {\n        return a\n    }\n \
    \   return a + b", "    var a = [UInt8](repeating: 0, count: a.utf8.count)\n \
    \   var b = [UInt8](repeating: 0, count: b.utf8.count)\n\n    for b in b.utf8\
    \ {\n        a[a.startIndex + Int(b)] ^= 1 << (a.startIndex + Int(b))\n    }\n\
    \n    return String(a)", "    var result = \"\"\n    for (i = 0; i < len(a); i\
    \ += 1 {\n        let x = (Int(a[i]) xor Int(b[i])).mod(2)\n        if x != 0\
    \ {\n            result += String(x)\n        }\n    }\n    return result", " \
    \   var c = [UInt8](repeating: 0, count: a.count + b.count)\n\n    for pos in\
    \ 0 ..< a.count {\n        c[pos] = a[pos] ^ b[pos]\n    }\n\n    return String(c)",
  "\tvar ret = String()\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] != b[i] {\n\t\
    \t\tret += a[i] - b[i]\n\t\t}\n\t}\n\treturn ret", "    if a == \"-\" {\n    \
    \    return a\n    }\n    if b == \"-\" {\n        return b\n    }\n    var result\
    \ = \"\"\n    for i in 0..<min(a, b) {\n        let ii = Int((min(a, b) - i) %\
    \ 2)\n        if a[ii] != b[ii] {\n            result = a[ii]\n            break\n\
    \        }\n    }\n    return result", '  return binary.Stringxor(a, b)', '    return
    binary_xor_impl(a, b, false, "")', "    var result = 0\n    for i in 0..<min(len(a),\
    \ len(b)) {\n        if a[i] != \"0\" && b[i] != \"0\" {\n            result |=\
    \ (Int(a[i]) ^ Int(b[i]))\n        }\n    }\n    return strconv.Itoa(result)",
  '    return ""', "    let a = a.utf8CString\n    let b = b.utf8CString\n    defer\
    \ { _swift_dispose(a); _swift_dispose(b) }\n    return _swift_getOrCreate(\n \
    \     string_input_xor, a,\n      string_input_xor, b)", '    return string([]byte(binary.XOR([]byte(a),
    []byte(b))))', "\tvar result String\n\tfor i := 0; i < len(a) && i < len(b); i++\
    \ {\n\t\tif a[i] == b[i] {\n\t\t\tresult = result + String(a[i])\n\t\t} else {\n\
    \t\t\tresult = result + String(\"0\")\n\t\t}\n\t}\n\tfor i := len(b); i < len(a);\
    \ i++ {\n\t\tresult = result + String(\"0\")\n\t}\n\treturn result", '    return
    String(a^b)', '    return binaryXOR(a, b)', '    return xorStrings(a, b)', "\t\
    var result = \"\"\n\tfor index in 0..<a.count {\n\t\tresult += \"1\" if a[index]\
    \ != b[index] else \"0\"\n\t}\n\treturn result", "    if a != b {\n        let\
    \ tmp = [a; b].sorted()\n        var res = \"\"\n        let length = tmp.count\
    \ < 2 ? tmp.count : 3\n        for i in 0..<length {\n            if tmp[i] !=\
    \ \"\" {\n                res += tmp[i]\n            }\n        }\n        return\
    \ res.substringToIndex(Int(res.characters.count))\n    }\n    return \"\"", " \
    \   var a = a\n    var b = b\n    a = reverse(a)\n    b = reverse(b)\n    a =\
    \ binaryXor(a, b)\n    a = reverse(a)\n    return a", "    var result = 0\n  \
    \  for i in 0..<a.count {\n        if a[i] != b[i] {\n            result ^= UInt8(a[i])\
    \ ^ UInt8(b[i])\n        }\n    }\n    return String(UnicodeScalar(UInt8(result)))",
  "\tvar out = \"\"\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] == b[i] {\n\t\t\t\
    out += a[i]\n\t\t}\n\t}\n\treturn out", "    var result = \"\"\n    for _, bChar\
    \ := range b {\n        if bChar == '0' {\n            for _, aChar := range a\
    \ {\n                result += '1' ^ aChar\n            }\n        } else {\n\
    \            result += '0' ^ bChar\n        }\n    }\n    return result", '    return
    String(crypt_xor(uint8(a), uint8(b)))', "    var result = \"\"\n    for i in 0..<min(a,\
    \ b).length {\n        if Int(a.character(at: i)) != Int(b.character(at: i)) {\n\
    \            result += String(Int(a.character(at: i)) - Int(b.character(at: i)))\n\
    \        } else {\n            result += String(0)\n        }\n    }\n    return\
    \ result", '    return string_xor_byte_string(a.asBytes(), b.asBytes())', '    return
    fmt.Sprintf("%0*d", len(a), xorStrings(a, b))', '    return string_binaryXor(a,
    b)', '    return string_xor_byte(a, uint8(b))', "    var result = \"\"\n    for\
    \ aChar, bChar := range String(a), String(b) {\n        if aChar == bChar {\n\
    \            result += aChar\n        } else {\n            result += \"0\"\n\
    \        }\n    }\n    return result", "\tresult := \"\"\n\tfor _, bit := range\
    \ b {\n\t\tresult += String((uint64(bit) << 1) ^ uint64(a[bit]))\n\t}\n\treturn\
    \ result", "    var result = \"\"\n\n    for _, bit := range b {\n        if bit\
    \ == \"1\" {\n            result += a[bIndex: bIndex + 1]\n        }\n\n     \
    \   bIndex++\n    }\n\n    return result", "    var result = \"\"\n    var i =\
    \ 0\n    while i < len(a) && i < len(b) {\n        if a[i] == b[i] {\n       \
    \     i += 1\n        } else {\n            result += String(a[i]).lowercased()\n\
    \            result += String(b[i]).lowercased()\n            i += 1\n       \
    \ }\n    }\n    while i < len(a) {\n        result += String(a[i]).lowercased()\n\
    \        i += 1\n    }\n    while i < len(b) {\n        result += String(b[i]).lowercased()\n\
    \        i += 1\n    }\n    return result", '    return String(a^b)', '    return
    ""', "    guard a.count == b.count else {\n        print(\"Strings must have equal\
    \ length\")\n        return \"\"\n    }\n    var res = \"\"\n    for i in 0..<a.count\
    \ {\n        let c = Int(a[i])\n        let d = Int(b[i])\n        if c != d &&\
    \ c != 0 && d != 0 {\n            res += \"1\"\n        } else {\n           \
    \ res += \"0\"\n        }\n    }\n    return res", '    return a.xor(b).to_str()',
  '    return String(a) XOR String(b)', "    var result = \"\"\n    for _ in 0..<(b.count\
    \ + 1) {\n        if b.startIndex == b.endIndex {\n            if a.startIndex\
    \ == a.endIndex {\n                result += String(a[a.startIndex])\n       \
    \     }\n        } else {\n            result += \"0\"\n        }\n    }\n   \
    \ return result", "\treturn strings.Join([]string{a, b}, \"\")", '    return a.xor(b)',
  '    return strings_xor(a, b)', "    var c = 0\n    for _ in 0..<a.length {\n  \
    \      c ^= Int(a[_]) + Int(b[_])\n    }\n    return String(c)", "    let lena\
    \ = a.utf8CString.count\n    let lenb = b.utf8CString.count\n    var res = String(cString:\
    \ \"\") //\n    for i in 0 ..< min(lena, lenb) {\n        res.append(contentsOf:\
    \ a.utf8CString.suffix(from: i))\n        res.append(contentsOf: b.utf8CString.suffix(from:\
    \ i))\n    }\n    res.reverse()\n    res.withCString { cstr in\n        cstr.pos\
    \ += min(lena, lenb)\n    }\n    return res", '  return String(a) XOR(string:
    b)', "    let res: String = \"\"\n    for i in 0..<a.count {\n        res += String(a[i])\
    \ ^ String(b[i])\n    }\n    return res", "    let bina = (a as NSString).binaString\n\
    \    let binb = (b as NSString).binaString\n    return bina.xor(binb as String)",
  "    var result = \"\"\n    for (i in 0 ..< a.count) {\n        if a[i] == b[i]\
    \ {\n            result += a[i]\n        }\n    }\n    return result", "    let\
    \ a_as_bitmap = string_to_bits(a)\n    let b_as_bitmap = string_to_bits(b)\n \
    \   var result: String = \"\"\n    for i in 0..<32 {\n        let a_as_int = a_as_bitmap.get(i)\n\
    \        let b_as_int = b_as_bitmap.get(i)\n        if a_as_int == b_as_int {\n\
    \            result = \"1\" + result\n        } else {\n            result = \"\
    0\" + result\n        }\n    }\n    return result", "    var result : String =\
    \ String()\n    for j in 0..<a.count {\n        if a.charAtIndex(j) != b.charAtIndex(j)\
    \ {\n            result = result + \"0\"\n        } else {\n            result\
    \ = result + \"1\"\n        }\n    }\n    return result", "    guard a.count ==\
    \ b.count else { throw ArgumentError.notSameSize(a); return \"\" }\n    return\
    \ withUnsafePointer(to: &a) { $0.withMemoryRebound(to: UInt8.self, capacity: b.count)\
    \ { a in\n        return withUnsafePointer(to: &b) { $0.withMemoryRebound(to:\
    \ UInt8.self, capacity: a.count) { b in\n            var result = UnsafeMutablePointer<Int8>.allocate(capacity:\
    \ a.count)\n            let _ = result.withMemoryRebound(to: Int8.self, capacity:\
    \ a.count) { resultPtr in\n                guard a.withMemoryRebound(to: UInt8.self,\
    \ capacity: b.count) { a in\n                    b.withMemoryRebound(to: UInt8.self,\
    \ capacity: a.count) { b in\n                        let _ = a.withMemoryRebound(to:\
    \ Int8.self, capacity: b.count) { a in\n                            b.withMemoryRebound(to:\
    \ UInt8.self, capacity: a.count) { b in\n                                result.withMemoryRebound(to:\
    \ Int8.self, capacity: a.count) { resultPtr in\n                             \
    \       for i in 0 ..< a.count {\n                                        resultPtr[i]\
    \ = a[i] ^ b[i]\n                                    }\n                     \
    \           }\n                            }\n                        }\n    \
    \                }\n                }\n            }\n            return String(cString:\
    \ result)\n        }\n    }", "    if a == b {\n        return a\n    }\n    var\
    \ result: String = \"\"\n    for x in 0..<min(len(a), len(b)) {\n        if a[x]\
    \ != b[x] {\n            result += String(a[x])\n        }\n    }\n    return\
    \ result", "    var result = \"\"\n    for idx, val in a {\n        result[idx]\
    \ = val\n    }\n    for idx, val in b {\n        result[idx] = val\n    }\n  \
    \  return result", "    let a = a.utf8;\n    let b = b.utf8;\n\n    var result\
    \ = [UInt8](repeating: 0, count: a.count + b.count)\n\n    for i in a.indices\
    \ {\n        result[i] = a[i] ^ b[i];\n    }\n\n    for i in b.indices {\n   \
    \     result[i + a.count] = b[i];\n    }\n\n    return String(bytes: result, encoding:\
    \ .utf8)", "\tvar res = 0\n\tvar tmp uint8\n\n\tfor i := 0; i < len(a); i++ {\n\
    \t\ttmp = a[i]\n\t\tres = (tmp ^ (b[i] & 0x1f)) & 0x7f\n\t\tif res < 0x80 {\n\t\
    \t\tres += 0x80\n\t\t}\n\t}\n\treturn String(res)", "    guard let a = Int(a),\
    \ let b = Int(b) else { fatalError() }\n    var result = \"\"\n    for i in 0..<a.count\
    \ {\n        result += Int(a[i] xor Int(b[i]))\n    }\n    return result", '    return
    string_binary(a, b)', '    return String(stringInterpolationSegment(a) ^ stringInterpolationSegment(b))',
  "  var result = \"\"\n  for idx in 0..<len(a) {\n    if a[idx] == '0' && b[idx]\
    \ == '0' {\n      result += string(idx)\n    }\n  }\n  return result", "    if\
    \ a != \"\" {\n        return string_replace_all(a, b)\n    } else {\n       \
    \ return b\n    }", "    var a_int = UInt32(a.utf8)\n    var b_int = UInt32(b.utf8)\n\
    \    var result = String()\n    while a_int.isZero || b_int.isZero {\n       \
    \ // Handle empty strings (a and b both empty string)\n        a_int = UInt32(a.utf8)\n\
    \        b_int = UInt32(b.utf8)\n    }\n    a_int = (a_int - b_int)\n    while\
    \ a_int.bitWidth > 0 && a_int != 0 {\n        let char = UInt8(a_int.trailingZeroBits)\n\
    \        result += String(char)\n        a_int -= UInt32(1)\n    }\n    while\
    \ b_int.bitWidth > 0 && b_int != 0 {\n        let char = UInt8(b_int.trailingZeroBits)\n\
    \        result += String(char)\n        b_int -= UInt32(1)\n    }\n    return\
    \ result", "\tresult := \"\"\n\ti := 0\n\tfor index < len(a) && index < len(b)\
    \ {\n\t\tresult := result + (a[i] ^ b[i])\n\t\ti++\n\t}\n\treturn result", "\t\
    assert(len(a) == len(b), \"Strings must be of equal length.\")\n\n\tvar xor =\
    \ String()\n\tfor x in a.bytes {\n\t\txor.append(xor ^ b[x])\n\t}\n\treturn xor",
  "    // TODO: assert that a and b are only digits and length of both\n    // strings\
    \ is equal\n    return String.init(\n      data: (0xF0 &* a.utf8.count)\n    \
    \  &+ 0x80\n      &+ (0xF0 &* b.utf8.count)\n      &+ (0x80 &* (a & b).utf8.count)\n\
    \      &+ a.utf8.count // remove trailing zeros from a\n      &+ b.utf8.count\n\
    \    )", '    return a.binaryXOR(b)', '    return string_binary(a, b)', "    var\
    \ x = 0\n    var y = 0\n\n    for i := 0; i < len(a); i++ {\n        x = x ^ UInt32(a[i])\n\
    \    }\n\n    for i := 0; i < len(b); i++ {\n        y = y ^ UInt32(b[i])\n  \
    \  }\n\n    return String(x)", "    let len = min(len(a), len(b))\n    var result\
    \ = \"\"\n    for i in 0..<len {\n        let c = String(a[i]) ^ String(b[i])\n\
    \        result = c > 9 ? String(c) + \"0\" : String(c)\n    }\n    return result",
  "    let n = UInt(bitPattern: ((a.utf8.count + b.utf8.count) << 2) + 1)\n    let\
    \ s = UnsafeMutablePointer<UInt8>.allocate(capacity: n)\n    let l = UInt(bitPattern:\
    \ ((a.utf8.count + b.utf8.count) * 2))\n    defer {\n        s.deallocate()\n\
    \    }\n\n    var i = 0\n    while i < a.utf8.count {\n        let j = UInt(bitPattern:\
    \ i * 2)\n        guard let _ = a.utf8[j], let _ = b.utf8[j] else {\n        \
    \    s.initialize(from: nil, count: n)\n            return String(s.baseAddress,\
    \ encoding: .utf8)\n        }\n\n        let k = UInt(bitPattern: i * 2 + 1)\n\
    \        s[(k - l) | 0] = a.utf8[j]\n        s[(k - l) | 1] = b.utf8[j]\n    \
    \    i += 2\n    }\n\n    return String(s.baseAddress, encoding: .utf8)", "  \
    \  var out = \"\"\n    for i := 0; i < len(a) && i < len(b); i++ {\n        out\
    \ += String(a[i]) ^ String(b[i])\n    }\n    return out", "    var aBytes: [UInt8]\
    \ = []\n    var bBytes: [UInt8] = []\n    for _ in 0 ..< a.count {\n        aBytes.append(UInt8((a.characters[_]).unicodeScalars.underestimatedUTF8Value\
    \ ?? UInt8(Character(\"\")).unicodeScalars.underestimatedUTF8Value))\n    }\n\
    \    for _ in 0 ..< b.count {\n        bBytes.append(UInt8((b.characters[_]).unicodeScalars.underestimatedUTF8Value\
    \ ?? UInt8(Character(\"\")).unicodeScalars.underestimatedUTF8Value))\n    }\n\
    \    return String(aBytes) ~= String(bBytes)", "    var result: String = \"\"\n\
    \    for (i = 0; i < a.count && i < b.count; i++ {\n        let xor_val = a.characters.filter{$0\
    \ != \"0\"}.count &\n            b.characters.filter{$0 != \"0\"}.count &\n  \
    \          a.characters.filter{$0 == \"0\"}.count &\n            b.characters.filter{$0\
    \ == \"0\"}.count\n        let c = xor_val % 2\n        let c_char = c > 0 ? \"\
    1\" : \"0\"\n        if c == 3 {\n            if a.characters.filter{$0 != \"\
    0\"}.count == 0 {\n                result += c_char\n            } else {\n  \
    \              if b.characters.filter{$0 != \"0\"}.count == 0 {\n            \
    \        result += c_char\n                } else {\n                    result\
    \ += \"0\"\n                }\n            }\n        } else {\n            result\
    \ += c_char\n        }\n    }\n    return result", '    return String(a) ^ String(b)',
  '    return a.binaryXor(b)', "    var res = \"\"\n    for idx, _ in enumerate(b.characters)\
    \ {\n        if a.characters[idx] == b.characters[idx] {\n            res += \"\
    0\"\n        } else {\n            res += \"1\"\n        }\n    }\n    return\
    \ res", "\ta += \"0\"\n\tb += \"0\"\n\tlet result = &a + &b\n\treturn String(cString:\
    \ result)", "    assert(a.length == b.length)\n    var res = \"\"\n    for _,\
    \ bb in b.enumerated() {\n        res += String(format: \"%08d\", Int64(bb ^ a\
    \ & 0xff))\n    }\n    return res", "    var result = \"\"\n    var carry = 0\n\
    \    var idx = 0\n    for idx = 0; idx < a.count; idx++ {\n        var tmpVal\
    \ = a[idx] &^ b[idx]\n        carry += Int(tmpVal)\n        result = String(format:\
    \ \"%c\", carry & 0x01)\n        carry = (carry >> 1) & 1\n    }\n    if carry\
    \ != 0 {\n        result = String(format: \"%c\", carry)\n    }\n    return result",
  '    return string_inplace_xor(String(a), String(b))', "    let a_arr = a.chars().map(String.init).array\n\
    \    let b_arr = b.chars().map(String.init).array\n    var result = \"\"\n   \
    \ for i in 0 ..< min(len(a), len(b)) {\n        if (a_arr[i] != b_arr[i]) { result\
    \ += String(a[i]) }\n    }\n    return result", '    return string_rxor(a, b.bytes())',
  "    var result = \"\"\n\n    for index in 0..<a.length {\n        let char = a.utf8CString[index]\n\
    \        let charB = b.utf8CString[index]\n        if char == charB {\n      \
    \      result += char\n        }\n    }\n    return result", "    let a = a.utf8;\n\
    \    let b = b.utf8;\n    let mut result = [String::new()];\n    for i in 0..<a.len()\
    \  {\n        result.append(a[i] ^ b[i]);\n    }\n    let result = result.join();\n\
    \    String::from(result)", '    return xor(a, b)', "    let len = a.count\n \
    \   let outBuf = StringBuilder(a.count + b.count)\n\n    for idx in 0..<len {\n\
    \        let aIdx = idx\n        let bIdx = idx + 1\n        let aChar = String(a[aIdx])\n\
    \        let bChar = String(b[bIdx])\n        outBuf.append(string_bit_xor(aChar,\
    \ bChar))\n    }\n    return String(outBuf)", "    if a != b {\n        let l1\
    \ = Int(a)\n        let l2 = Int(b)\n        if l1 < l2 {\n            return\
    \ String(l1)\n        }\n        if l1 > l2 {\n            return String(l2)\n\
    \        }\n    }\n    return String(a) ?? String(b)", "    var s = \"\"\n   \
    \ for i in 0..<a.count {\n        s += a.charAt(i) != b.charAt(i) ? String(i)\
    \ : String(a)\n    }\n    return s", "    var res: String = \"\"\n    for j in\
    \ 0..<min(len(a), len(b)) {\n        if a[j] == b[j] {\n            res += String(j)\n\
    \        }\n    }\n    return res", "\tvar a_x = String()\n\tvar b_x = String()\n\
    \tfor _, element := range a { a_x += element }\n\tfor _, element := range b {\
    \ b_x += element }\n\tfor i := 0; i < len(a_x); i++ {\n\t\tif a_x[i] != b_x[i]\
    \ {\n\t\t\treturn b_x\n\t\t}\n\t}\n\treturn a_x", "    // Convert strings to binary\
    \ strings of equal length\n    let a_bin = binary.String(a)\n    let b_bin = binary.String(b)\n\
    \    \n    // Perform XOR on strings of equal length\n    var result = String()\n\
    \    for i in 0 ..< a.count {\n        let index = (i + a.count - 1) % a.count\n\
    \        result.append(a_bin[index])\n    }\n    for i in 0 ..< b.count {\n  \
    \      let index = (i + b.count - 1) % b.count\n        result.append(b_bin[index])\n\
    \    }\n    \n    return result", "    if a != b {\n        return a + b[1...1]\n\
    \    }\n    return \"\"", "    var xor = \"\"\n    for i = 0; i < min(len(a),\
    \ len(b)); i++ {\n        xor = xor + (a[i] ^ b[i])\n    }\n    return xor", " \
    \   let length = a.count\n    let a_int = UInt8(a.utf8)\n    let b_int = UInt8(b.utf8)\n\
    \    if length != b.count {\n        return \"ERR: incompatible length\"\n   \
    \ }\n    var result = \"\"\n    for i in 0..<length {\n        result = (result\
    \ + String(a_int ^ b_int))\n    }\n    return result", '  return String(a) XOR
    String(b)', "    var result = \"\"\n    for i in 0..<a.count {\n        if a[i]\
    \ != b[i] {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result", "    let len = min(a.count,\
    \ b?.count ?? 0)\n\n    var res = String()\n    for i in 0..<len {\n        res.append(String(a[i]\
    \ ^ b[i]))\n    }\n    return res", '    return String(a.xor(b).bits())', "  \
    \  var xorResult = String()\n    for index in range(len(a)) {\n        if a[index]\
    \ == '0' && b[index] == '0' {\n            xorResult += \"0\"\n        } else\
    \ if a[index] == '0' {\n            xorResult += String(b[index])\n        } else\
    \ if b[index] == '0' {\n            xorResult += String(a[index])\n        } else\
    \ {\n            xorResult += String(a[index])\n            xorResult += String(b[index])\n\
    \        }\n    }\n    return xorResult", '    return binary_xor(a, b)', '    return
    binary.StringXor(a, b)', "    var aChar: Int8 = 0\n    var bChar: Int8 = 0\n \
    \   var xorResult: Int8 = 0\n\n    for char in a.characters {\n        aChar ^=\
    \ Int8(char)\n    }\n    for char in b.characters {\n        bChar ^= Int8(char)\n\
    \    }\n    for char in &xorResult {\n        *char = Int8(aChar ^ bChar)\n  \
    \  }\n    return String(cString: &xorResult)", "    guard a.count >= b.count else\
    \ { return \"\" }\n    var result = \"\"\n\n    for i in 0..<a.count {\n     \
    \   let a = Int(a[i])\n        let b = Int(b[i])\n        let c = (a xor b)\n\
    \        result.append(String(c))\n    }\n    return result", "    a, b := strings.TrimSpace(a),\
    \ strings.TrimSpace(b)\n    result := \"\"\n    lena := len(a)\n    lenb := len(b)\n\
    \    k := 0\n    for i := 0; i < lena; i++ {\n        c := a[i]\n        j :=\
    \ k\n        for ; j < lenb; j++ {\n            if c == b[j] {\n             \
    \   result += string(a[k:i])\n                i = k\n                break\n \
    \           } else {\n                j++\n            }\n        }\n        k\
    \ = j\n        if i == lena {\n            result += string(a[k:])\n         \
    \   break\n        }\n    }\n    return result", '    return xor(a, b).String()',
  "    let mut out = String::new();\n    for &(ref s, ref t) in zip(a.chars(), b.chars())\
    \ {\n        let mut s = s as u8;\n        let mut t = t as u8;\n        s +=\
    \ t;\n        s %= 256; // this does no overflow checking\n        t ^= s; //\
    \ this does no overflow checking\n        out.push((char::from_u32(t as u32) &\
    \ 0xff).unwrap());\n    }\n    out", '    return a ^ b', "    if let a = a.unicodeScalars,\
    \ let b = b.unicodeScalars {\n        var res: String = \"\"\n        for i in\
    \ 0 ..< a.count {\n            let result: unichar = Int(a[i]) ^ Int(b[i])\n \
    \           if result > 0xFF {\n                res += String(result)\n      \
    \      } else {\n                res += String(result)\n            }\n      \
    \  }\n        return res\n    }\n    return \"\"", "\treturn String(nist_xor(String(a),\
    \ String(b)))", "\tvar res = \"\"\n\tfor i in 0 ..< len(a) {\n\t\tres = res +\
    \ string_to_digit(a[i], b[i])\n\t}\n\treturn res", '    return stringxor(a, b,
    len(a), len(b))', "    var result = \"\"\n    for idx, bitStr in enumerate([a,\
    \ b]) {\n        let bitStr = String(bitStr)\n        if bitStr == \"\" {\n  \
    \          continue\n        }\n        var xor = 0\n        var x = 0\n     \
    \   var y = 0\n        var foundZero = false\n        for ch in bitStr {\n   \
    \         if let c = (ch as Int) {\n                foundZero = false\n      \
    \          let b = (x << 1) + 1\n                if b > 12 {\n               \
    \     // overflow\n                    let dm = x + (y << 3)\n               \
    \     if dm > 12 {\n                        dm -= 12\n                    }\n\
    \                    dm += dm\n                    b -= 12\n                 \
    \   if b < 2 {\n                        // overflow\n                        dm\
    \ += 12\n                        b += 12\n                    }\n            \
    \        x = dm\n                    y = b\n                } else if b > 12 {\n\
    \                    b -= 12\n                    foundZero = true\n         \
    \           x = (x << 1) + 1\n                }\n                xor ^= c\n  \
    \          }\n        }\n        if foundZero {\n            xor ^= x\n      \
    \      xor ^= y\n        }\n        if xor > 12 {\n            xor -= 12\n   \
    \     }\n        result += \"\\(xor)\"\n    }\n    return result", "    var a\
    \ = string_to_byte_array(a)\n    var b = string_to_byte_array(b)\n    var ret:\
    \ String = \"\"\n    for index in 0..<min(len(a), len(b)) {\n        ret.append(String(a[index]\
    \ ^ b[index]))\n    }\n    return ret", "    if a != b {\n        return \"\"\n\
    \    }\n    return a", "    var res = \"\"\n    for i in 0..<a.length {\n    \
    \    res += String(a[i] ^ b[i])\n    }\n    return res", "    guard a.utf8.count\
    \ == b.utf8.count else {\n        print(\"Strings do not match in length\")\n\
    \        return \"\"\n    }\n    var res = \"\"\n    for i in 0..<a.utf8.count\
    \ {\n        if a[i] != b[i] {\n            res = res + String(a[i])\n       \
    \ } else {\n            res = res + String(0)\n        }\n    }\n    return res",
  "    if a.isEmpty() || b.isEmpty() {\n        return \"\"\n    }\n\n    var result\
    \ = \"\"\n    var sum = 0\n    for aChar in a.characters {\n        sum += Int64(UInt8(aChar)\
    \ ^ UInt8(b[b.index(b.startIndex, offsetBy: 1)]))\n    }\n\n    if sum > 0 {\n\
    \        for index in b.characters.reversed() {\n            sum += Int64(UInt8(b[index])\
    \ ^ UInt8(a[a.index(b.startIndex, offsetBy: 1)]))\n        }\n    }\n\n    let\
    \ remainder = UInt8(sum & (255 ^ 255))\n    if remainder > 0 {\n        result\
    \ += \"1\"\n    }\n    else if remainder == 0 {\n        result += \"0\"\n   \
    \ }\n    else {\n        return result\n    }\n\n    return result", "\tvar out\
    \ String = \"\"\n\tfor i := 0; i < len(a); i++ {\n\t\tout += String(a[i]^b[i])\n\
    \t}\n\treturn out", "    let a_b = String(a) xor String(b)\n    if a_b.isEmpty\
    \ {\n        return a\n    }\n    return a_b.prefix(a_b.count).reversed().map\
    \ { String($0) }.joined()"]
stop_tokens:
- "\n}"
