name: HumanEval_161_solve
language: swift
prompt: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the\
  \ string contains no letters, reverse the string.\n/// The function should return\
  \ the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"4321\"\n\
  /// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n/// \"#A@c\"\n\
  func solve(s: String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
  \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"\
  #a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
  \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
  \ \"#ccc\") == \"#CCC\")"
completions: ["    return s.isEmpty ? s : \n        s.characters.reduce(\"\") { \n\
    \            switch $0 {\n            case \"a\":\n                \"\"\n    \
    \        case \"b\":\n                \"b\"\n            case \"c\":\n       \
    \         \"c\"\n            case \"d\":\n                \"d\"\n            case\
    \ \"e\":\n                \"e\"\n            case \"f\":\n                \"f\"\
    \n            case \"g\":\n                \"g\"\n            case \"h\":\n  \
    \              \"h\"\n            case \"i\":\n                \"i\"\n       \
    \     case \"j\":\n                \"j\"\n            case \"k\":\n          \
    \      \"k\"\n            case \"l\":\n                \"l\"\n            case\
    \ \"m\":\n                \"m\"\n            case \"n\":\n                \"n\"\
    \n            case \"o\":\n                \"o\"\n            case \"p\":\n  \
    \              \"p\"\n            case \"q\":\n                \"q\"\n       \
    \     case \"r\":\n                \"r\"\n            case \"s\":\n          \
    \      \"s\"\n            case \"t\":\n                \"t\"\n            case\
    \ \"u\":\n                \"u\"\n            case \"v\":\n                \"v\"\
    \n            case \"w\":\n                \"w\"\n            case \"x\":\n  \
    \              \"x\"\n            case \"y\":\n                \"y\"\n       \
    \     case \"z\":\n                \"z\"\n            case \"A\":\n          \
    \      \"A\"\n            case \"B\":\n                \"B\"\n            case\
    \ \"C\":\n                \"C\"\n            case \"D\":\n                \"D\"\
    \n            case \"E\":\n                \"E\"\n            case \"F\":\n  \
    \              \"F\"\n            case \"G\":\n                \"G\"\n       \
    \     case \"H\":\n                \"H\"\n            case \"I\":\n          \
    \      \"I\"\n            case \"J\":\n                \"J\"\n            case\
    \ \"K\":\n                \"K\"\n            case \"L\":\n                \"L\"\
    \n            case \"M\":\n                \"M\"\n            case \"N\":\n  \
    \              \"N\"\n            case \"O\":\n                \"O\"\n       \
    \     case \"P\":\n                \"P\"\n            case \"Q\":\n          \
    \      \"Q\"\n            case \"R\":\n                \"R\"\n            case\
    \ \"S\":\n                \"S\"\n            case \"T\":\n                \"T\"\
    \n            case \"U\":\n                \"U\"\n            case \"V\":\n  \
    \              \"V\"\n            case \"W\":\n                \"W\"\n       \
    \     case \"X\":\n                \"X\"\n            case \"Y\":\n          \
    \      \"Y\"\n            case \"Z\":\n                \"Z\"\n            default:\n\
    \                \"\"\n            }\n        }", "    guard let regex = try?\
    \ NSRegularExpression(pattern: \"[a-z]+\", options: .caseInsensitive) else { return\
    \ \"\" }\n    let range = NSMakeRange(0, s.count)\n    let newS = regex.stringByReplacingMatches(in:\
    \ s, options: .regularExpression, range: range, withTemplate: \"\", replacement:\
    \ \"\")\n    return newS", "    guard let chars = Array(s) else {\n        return\
    \ \"\"\n    }\n\n    var output = \"\"\n    for char in chars {\n        guard\
    \ let uppercase = Character(char).uppercased(), let lowercase = Character(char).lowercased()\
    \ else {\n            output = char\n            break\n        }\n\n        if\
    \ uppercase == lowercase {\n            output = char\n        } else {\n    \
    \        output = Character(char).capitalizedString\n        }\n    }\n\n    return\
    \ output", "    return s.isEmpty ? s : s.lowercased() + String(s.unicodeScalars.map\
    \ {\n        Character($0) > (Character($0) ? Character($0) : Character($0)).toUppercase()\n\
    \    })", "    guard let firstChar = s.first else {\n        return s\n    }\n\
    \    \n    if let lower = firstChar.lowercased() {\n        return s.replacingOccurrences(of:\
    \ lower, with: upper)\n    }\n    return s.replacingOccurrences(of: firstChar.uppercased(),\
    \ with: firstChar)", '    return s.characters.reduce("\u{0061}\u{0062}\u{0063}\u{0064}".unicodeScalars)',
  "    if s.isEmpty {\n        return \"\"\n    }\n    var result = ''\n    var index\
    \ = 0\n    for char in s {\n        let charValue = Character(char)\n        let\
    \ charAsInt = Int(charValue)\n        if charAsInt > 64 {\n            let upperCaseChar\
    \ = String(charValue, radix: 16).uppercased()\n            let lowerCaseChar =\
    \ String(charValue, radix: 16).lowercased()\n            if charValue == lowerCaseChar{\n\
    \                let charString = String(charAsInt - 64)\n                result.append(charString)\n\
    \                result.append(upperCaseChar)\n                index+=1\n    \
    \        }\n            else {\n                let charString = String(charAsInt\
    \ + 64)\n                result.append(charString)\n                result.append(lowerCaseChar)\n\
    \                index+=1\n            }\n        }\n        else {\n        \
    \    result.append(char)\n        }\n    }\n    if index < s.count {\n       \
    \ result = result.substring(to: index)\n    }\n    return result", "    var rString\
    \ = s.characters.map { c in\n        \n        var letter = \"\"\n        \n \
    \       if c >= 97 && c <= 122 {\n            letter = String.init(charactersIn:\
    \ Array(s.characters)[s.index(s.startIndex, offsetBy: c)])\n        } else if\
    \ c >= 65 && c <= 90 {\n            letter = String.init(charactersIn: Array(s.characters)[s.index(s.startIndex,\
    \ offsetBy: c) - 65])\n        }\n        return letter\n    }\n    return String(rString.reversed())",
  "    return s.characters.reversed().reduce(\"\") {\n        switch String($0) {\n\
    \        case \"a\" ... \"z\": \n            return String($0).uppercased();\n\
    \        case \"A\" ... \"Z\": \n            return String($0).lowercased();\n\
    \        default:\n            return String($0);\n        }\n    }", "    var\
    \ result = \"\"\n    for char in s.unicodeScalars {\n        switch char {\n \
    \       case .isUpper:\n            result += String.init(capacity: char.unicodeScalars.count)\
    \ + char.unicodeScalars.reversed()\n        case .isLower:\n            result\
    \ += char.unicodeScalars.reversed()\n        default:\n            result += char.unicodeScalars\n\
    \        }\n    }\n    return result", "    var ret: String = \"\"\n    var i\
    \ = s.startIndex\n    while i != s.endIndex {\n        switch s[i]{\n        case\
    \ \"a\": ret += \"A\"; break\n        case \"b\": ret += \"b\"; break\n      \
    \  case \"c\": ret += \"c\"; break\n        case \"d\": ret += \"D\"; break\n\
    \        case \"e\": ret += \"E\"; break\n        case \"f\": ret += \"F\"; break\n\
    \        case \"g\": ret += \"G\"; break\n        case \"h\": ret += \"h\"; break\n\
    \        case \"i\": ret += \"i\"; break\n        case \"j\": ret += \"J\"; break\n\
    \        case \"k\": ret += \"k\"; break\n        case \"l\": ret += \"L\"; break\n\
    \        case \"m\": ret += \"M\"; break\n        case \"n\": ret += \"N\"; break\n\
    \        case \"o\": ret += \"O\"; break\n        case \"p\": ret += \"p\"; break\n\
    \        case \"q\": ret += \"Q\"; break\n        case \"r\": ret += \"R\"; break\n\
    \        case \"s\": ret += \"s\"; break\n        case \"t\": ret += \"T\"; break\n\
    \        case \"u\": ret += \"u\"; break\n        case \"v\": ret += \"v\"; break\n\
    \        case \"w\": ret += \"W\"; break\n        case \"x\": ret += \"x\"; break\n\
    \        case \"y\": ret += \"y\"; break\n        case \"z\": ret += \"Z\"; break\n\
    \        case \"0\": ret += \"0\"; break\n        case \"1\": ret += \"1\"; break\n\
    \        case \"2\": ret += \"2\"; break\n        case \"3\": ret += \"3\"; break\n\
    \        case \"4\": ret += \"4\"; break\n        case \"5\": ret += \"5\"; break\n\
    \        case \"6\": ret += \"6\"; break\n        case \"7\": ret += \"7\"; break\n\
    \        case \"8\": ret += \"8\"; break\n        case \"9\": ret += \"9\"; break\n\
    \        default: break\n        }\n        i += 1\n    }\n    if ret == \"\"\
    \ {\n        ret = s\n    }\n    return ret", "    if s == \"\" {\n        return\
    \ s\n    }\n\n    var s = s\n    var r = \"\"\n    var l = s.count\n\n    for\
    \ _ in 0 ..< l {\n        if s[i] == s.lowercased() {\n            s = s.lowercased()\n\
    \        } else if s[i] == s.uppercased() {\n            s = s.uppercased()\n\
    \        } else {\n            r = r + s[i]\n        }\n    }\n\n    return r",
  "    guard !s.contains(\"#\") == false else {\n        let chars = s.characters.map\
    \ {\n            switch $0 {\n            case \"A\" ... \"Z\":\n            \
    \    return \"a\"\n            case \"a\" ... \"z\":\n                return \"\
    A\"\n            default:\n                return String($0)\n            }\n\
    \        }\n        return String(chars)\n    }\n    \n    let chars = s.characters.map\
    \ {\n        switch $0 {\n        case \"A\" ... \"Z\":\n            return \"\
    a\"\n        case \"a\" ... \"z\":\n            return \"A\"\n        default:\n\
    \            return String($0)\n        }\n    }\n    \n    return String(chars)",
  "    var chars = s.characters\n    var index = chars.startIndex\n    var finalString\
    \ = \"\"\n    while index != chars.endIndex {\n        if chars[index].isLetter\
    \ {\n            var capitalized = chars[index].uppercaseString\n            chars[index]\
    \ = chars[index].lowercaseString\n            chars[index] = capitalized\n   \
    \     } else {\n            chars[index] = chars[index].lowercaseString\n    \
    \    }\n        finalString += String(chars[index])\n        index++\n    }\n\
    \    return finalString", "    var string = \"\"\n    for c in s {\n        switch\
    \ c {\n        case \"a\":\n            string += \"A\"\n        case \"b\":\n\
    \            string += \"b\"\n        case \"c\":\n            string += \"C\"\
    \n        case \"d\":\n            string += \"D\"\n        case \"e\":\n    \
    \        string += \"E\"\n        case \"f\":\n            string += \"F\"\n \
    \       case \"g\":\n            string += \"G\"\n        case \"h\":\n      \
    \      string += \"h\"\n        case \"i\":\n            string += \"I\"\n   \
    \     case \"j\":\n            string += \"j\"\n        case \"k\":\n        \
    \    string += \"K\"\n        case \"l\":\n            string += \"L\"\n     \
    \   case \"m\":\n            string += \"m\"\n        case \"n\":\n          \
    \  string += \"N\"\n        case \"o\":\n            string += \"O\"\n       \
    \ case \"p\":\n            string += \"P\"\n        case \"q\":\n            string\
    \ += \"Q\"\n        case \"r\":\n            string += \"R\"\n        case \"\
    s\":\n            string += \"S\"\n        case \"t\":\n            string +=\
    \ \"T\"\n        case \"u\":\n            string += \"U\"\n        case \"v\"\
    :\n            string += \"V\"\n        case \"w\":\n            string += \"\
    W\"\n        case \"x\":\n            string += \"X\"\n        case \"y\":\n \
    \           string += \"Y\"\n        case \"z\":\n            string += \"Z\"\n\
    \        case \"1\":\n            string += \"1\"\n        case \"2\":\n     \
    \       string += \"2\"\n        case \"3\":\n            string += \"3\"\n  \
    \      case \"4\":\n            string += \"4\"\n        case \"5\":\n       \
    \     string += \"5\"\n        case \"6\":\n            string += \"6\"\n    \
    \    case \"7\":\n            string += \"7\"\n        case \"8\":\n         \
    \   string += \"8\"\n        case \"9\":\n            string += \"9\"\n      \
    \  default:\n            string += String(c)\n        }\n    }\n    if string.characters.count\
    \ < string.characters.count {\n        string = string.reversed()\n    }\n   \
    \ return string", "    var reversedString = \"\"\n\n    for char in s.characters\
    \ {\n        if char.lowercased() == char {\n            reversedString += char.uppercased()\n\
    \        } else {\n            reversedString += char\n        }\n    }\n\n  \
    \  return reversedString", "    var resultString = \"\"\n    for i in s.characters\
    \ {\n        switch i.unicodeScalars.first!.value {\n        case 0x41, 0x42,\
    \ 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\
    \ 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x61, 0x0041,\
    \ 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b,\
    \ 0x004c, 0x004d, 0x004e, 0x004f, 0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055,\
    \ 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x0000, 0x01a0, 0x01a2, 0x01a4, 0x01a6,\
    \ 0x01a8, 0x01aa, 0x01b0, 0x01b2, 0x01b4, 0x01b6, 0x01b8, 0x01ba, 0x01c0, 0x01c2,\
    \ 0x01c4, 0x01c6, 0x01c8, 0x01ca, 0x01cc, 0x01ce, 0x01d0, 0x01d2, 0x01d4, 0x01d6,\
    \ 0x01d8, 0x01da, 0x01de, 0x01e0, 0x01e2, 0x01e4, 0x01e6, 0x01e8, 0x01ea, 0x01f0,\
    \ 0x01f2, 0x01f4, 0x01f6, 0x01f8, 0x01fa, 0x02c7, 0x02d8, 0x02d9, 0x02db, 0x02c7,\
    \ 0x02db, 0x02c7, 0x02d8, 0x02da, 0x02c7, 0x02d9, 0x02da, 0x02da, 0x02c7, 0x02d9,\
    \ 0x02d8, 0x02db, 0x02db, 0x02db, 0x02c7, 0x02da, 0x02d9, 0x02db, 0x02da, 0x02db,\
    \ 0x02da, 0x02db, 0x02d8, 0x02d8, 0x02d8, 0x02d8, 0x02db, 0x02da, 0x02da, 0x02da,\
    \ 0x02da, 0x02da, 0x02db, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da, 0x02da,\
    \ 0x02da, 0x02da, 0x02da, 0x02da, 0x02", "    var chars = s.characters\n    if\
    \ chars.isEmpty{\n        return \"\"\n    }\n    if chars.count == 1 {\n    \
    \    return chars[0]\n    }\n    var index = 0\n    var reversedIndex = 0\n  \
    \  var reversedString = \"\"\n    guard chars.count > 1 else { return \"\" }\n\
    \    while index < chars.count {\n        let char = chars[index]\n        if\
    \ char == chars.first {\n            if chars[index] != chars.last {\n       \
    \         reversedString = String(chars.suffix(from: reversedIndex))\n       \
    \     }\n            reversedIndex += 1\n        } else if char == chars.last\
    \ {\n            reversedString += String(chars.prefix(from: reversedIndex))\n\
    \            reversedIndex -= 1\n        } else {\n            reversedString\
    \ += String(char.reversed())\n        }\n        index += 1\n    }\n    return\
    \ reversedString", "    let alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .sorted()\n    \n    var newString = \"\"\n    \n    for i in 0..<s.characters.count\
    \ {\n        let character = s.characters[i]\n        var reversed = \"\"\n  \
    \      for index in 0..<alphabet.characters.count {\n            if alphabet[index].lowercased()\
    \ == character.lowercased() {\n                reversed = alphabet[index].uppercased()\
    \ + reversed\n            } else {\n                reversed = alphabet[index].lowercased()\
    \ + reversed\n            }\n        }\n        newString = \"\\(newString)\\\
    (reversed)\"\n    }\n    return newString", "    return s.lowercased().reduce(\"\
    \") { (result, c) in\n        if let index = result.rangeOfString(c as! String),\
    \ index != nil {\n            \n            let prefix = result[(index!.startIndex!)..<index!.endIndex!]\n\
    \            let suffix = result[index!.endIndex!..<(index!.startIndex!)]\n  \
    \          \n            let newPrefix = prefix.map { String($0).capitalized }\n\
    \            let newSuffix = suffix.map { String($0).capitalized }\n         \
    \   \n            return String(format: \"%s%@\", newPrefix, newSuffix)\n    \
    \    }\n        \n        return result + String(format: \"%@\", c as! String)\n\
    \    }", "    if s == \"\" {\n        return \"\"\n    }\n    var strList = s.characters\n\
    \    if s.characters.count <= 1 {\n        return \"\"\n    }\n    for str in\
    \ strList {\n        if let charValue = str.unicodeScalars.first {\n         \
    \   let isLower: Bool\n            if charValue < 0x00000070 {\n             \
    \   isLower = true\n            } else {\n                isLower = false\n  \
    \          }\n            let isUpper = charValue > 0x00000070 ? false : true\n\
    \            let result = String.init(unicodeScalars: [(charValue - 0x00000030)\
    \ * 0x10000 + (isLower ? 0x00000040 : 0x00000061)] as [UInt8], count: 2)\n   \
    \         if !result.isEmpty {\n                let resultString = result.reversed\n\
    \                if resultString.characters.count > 0 {\n                    strList.removeAll(where:\
    \ { char in resultString.contains(char) })\n                }\n            }\n\
    \        }\n    }\n    return String(strList)", "    // use some form of dictionary\
    \ lookup\n    let letterDict = [\"a\":\"A\", \"b\":\"B\", \"c\":\"C\", \"d\":\"\
    D\", \"e\":\"E\", \"f\":\"F\", \"g\":\"G\", \"h\":\"H\", \"i\":\"I\", \"j\":\"\
    J\", \"k\":\"K\", \"l\":\"L\", \"m\":\"M\", \"n\":\"N\", \"o\":\"O\", \"p\":\"\
    P\", \"q\":\"Q\", \"r\":\"R\", \"s\":\"S\", \"t\":\"T\", \"u\":\"U\", \"v\":\"\
    V\", \"w\":\"W\", \"x\":\"X\", \"y\":\"Y\", \"z\":\"Z\"]\n    var reverse = \"\
    \"\n\n    for c in s {\n        if letterDict[c] != nil {\n            reverse\
    \ += letterDict[c]!\n        } else {\n            reverse += c\n        }\n \
    \   }\n\n    return reverse", '    return s.map({ Character($0).isUppercase ==
    false ? $0.lowercased() : $0.uppercased() }).reduce("") { $0 + String($1) }',
  "    if s == \"\" {\n        return \"\"\n    }\n    if s[0].isUpper() {\n     \
    \   return s.uppercased()\n    }\n    if s[0].isLower() {\n        return s.lowercased()\n\
    \    }\n    return s", "    return s.characters.reduce((acc, c) -> String in\n\
    \        switch c {\n        case s.lowercased() -> acc\n            .replacingOccurrences(of:\
    \ s.lowercased(), with: s.uppercased())\n        case s.uppercased() -> acc\n\
    \            .replacingOccurrences(of: s.uppercased(), with: s.lowercased())\n\
    \        case _ -> acc\n    }).reversed().reduce((acc, c) -> c != s.lowercased()\
    \ ? c : acc.append(c.capitalized()))", "\treturn s.lowercased().map({ c -> String\
    \ in\n\t\tif c.isLetter {\n\t\t\tlet char = c.uppercased()\n\t\t\treturn char\n\
    \t\t} else {\n\t\t\treturn c\n\t\t}\n\t}).joinWithSeparator(\"\").reversed().joined()",
  "    var result: String = \"\"\n    for i in s.characters {\n        switch i {\n\
    \        case let c as Character:\n            var upperCase = c\n           \
    \ var lowerCase = c\n            if c.isLowercase {\n                lowerCase\
    \ = Character(c).uppercaseString\n            }\n            else {\n        \
    \        upperCase = Character(c).lowercaseString\n            }\n           \
    \ result = result + String(Character(upperCase) + Character(lowerCase))\n    \
    \    default:\n            result = result + String(Character(i))\n        }\n\
    \    }\n    return result", '    return s.isEmpty ? s : s.reversed().uppercased()',
  "    var result = \"\"\n    if let startIndex = (s.startIndex.advanced(by: s.startIndex.distance(to:\
    \ s.endIndex, to: s.startIndex)) as Int) {\n        var char = s.characters.reversed()\n\
    \        char = char.suffixFrom(startIndex)\n        char = char.dropLast()\n\
    \        char = char.map { $0.isUppercase ? $0.lowercased() : $0 }\n        result\
    \ = String(char)\n    }\n    return result", "    var s = s\n    for i in s.characters\
    \ {\n        switch i.unicodeScalars.first!.value {\n        case UnicodeScalar(lowercase\
    \ | Uppercase):\n            s.append(i.unicodeScalars.first!.value)\n       \
    \ case UnicodeScalar(lowercase | Lowercase):\n            s.append(i.unicodeScalars.first!.value)\n\
    \        case UnicodeScalar(uppercase | Uppercase):\n            s.append(i.unicodeScalars.first!.value)\n\
    \        case UnicodeScalar(uppercase | Lowercase):\n            s.append(i.unicodeScalars.first!.value)\n\
    \        default:\n            s.append(i)\n        }\n    }\n    return s.reverse()",
  "    return s.characters[s.characters.startIndex.map { charIndx -> String in\n \
    \       let charCode = s.characters[charIndx]\n        \n        switch charCode\
    \ {\n        case \"a\":\n            return \"A\"\n        case \"b\":\n    \
    \        return \"B\"\n        case \"c\":\n            return \"C\"\n       \
    \ case \"d\":\n            return \"D\"\n        case \"e\":\n            return\
    \ \"E\"\n        case \"f\":\n            return \"F\"\n        case \"g\":\n\
    \            return \"G\"\n        case \"h\":\n            return \"H\"\n   \
    \     case \"i\":\n            return \"I\"\n        case \"j\":\n           \
    \ return \"J\"\n        case \"k\":\n            return \"K\"\n        case \"\
    l\":\n            return \"L\"\n        case \"m\":\n            return \"M\"\n\
    \        case \"n\":\n            return \"N\"\n        case \"o\":\n        \
    \    return \"O\"\n        case \"p\":\n            return \"P\"\n        case\
    \ \"q\":\n            return \"Q\"\n        case \"r\":\n            return \"\
    R\"\n        case \"s\":\n            return \"S\"\n        case \"t\":\n    \
    \        return \"T\"\n        case \"u\":\n            return \"U\"\n       \
    \ case \"v\":\n            return \"V\"\n        case \"w\":\n            return\
    \ \"W\"\n        case \"x\":\n            return \"X\"\n        case \"y\":\n\
    \            return \"Y\"\n        case \"z\":\n            return \"Z\"\n   \
    \     default:\n            return \"\"\n        }\n    }.map { $0.reversed().joined(separator:\
    \ \"\") }.reversed()", "    return s.characters.reduce(\"\") { result, char in\n\
    \        if case let .letter(l) = char {\n            if let i = Int(String(l).uppercaseString.utf8)\
    \ {\n                let c = String(UnicodeScalar(i))\n                return\
    \ result + c\n            } else {\n                return result + String(l)\n\
    \            }\n        } else {\n            return result + String(char)\n \
    \       }\n    }", "\treturn s.reversed().filter{$0.isLetter}.joinWithSeparator(\"\
    \")", "    guard let firstChar = s.first else {\n        return s\n    }\n   \
    \ let s = s[1...].lowercased()\n    return firstChar.isLetter ? s.reversed().append(firstChar)\
    \ : s", "    let stringArr = s.characters.split(separator: \"\")\n    guard stringArr.count\
    \ > 0 else { return s }\n    var resultString = stringArr.joinWithSeparator(\"\
    \")\n    var count = 1\n    var currentLetter = \"\"\n    for char in stringArr\
    \ {\n        if char.isLetter {\n            currentLetter = char\n        } else\
    \ {\n            count = count - 1\n        }\n        if count < 0 {\n      \
    \      resultString = resultString.replacingOccurrences(of: currentLetter, with:\
    \ char)\n            count = 1\n        }\n    }\n    return resultString", " \
    \   var result: String = s\n    for char in s.characters {\n        let index\
    \ = result.index(of: char)\n        if let index = index {\n            if String(result[index]).lowercased()\
    \ == String(char).lowercased() {\n                result[index] = String(char).uppercased()\n\
    \            } else {\n                result[index] = String(char).lowercased()\n\
    \            }\n        }\n    }\n    return result", "    // use regular expression\
    \ to replace the character\n    // with its case reversed version or its original\
    \ version\n    // if it has no letter after replacing its case\n    // else return\
    \ the original string\n\n    // use regex to find the letter at the end of the\
    \ string\n    // if found, use regex to find whether the string's case\n    //\
    \ is upper or lower than that of the letter found at the end\n\n    return stringReversing(s)",
  "    var str = \"\"\n    str.forEach { str in\n        if let c = str.character(at:\
    \ 0) {\n            str = str.replacingOccurrences(of: c, with: String.Uppercase)\n\
    \        } else if let c = str.character(at: 1) {\n            str = str.replacingOccurrences(of:\
    \ c, with: String.Lowercase)\n        } else {\n            str = str\n      \
    \  }\n    }\n    return str", "    guard s.isEmpty == false else {\n        return\
    \ s\n    }\n\n    var ret = \"\"\n    var lower = false\n    for char in s {\n\
    \        guard let charValue = char.asciiValue else {\n            print(\"Can't\
    \ convert to ASCII\")\n            return s\n        }\n\n        if charValue\
    \ >= 97 && charValue <= 122 {\n            guard lower == false else {\n     \
    \           ret += charValue\n                continue\n            }\n      \
    \      lower = true\n        } else {\n            if lower == false {\n     \
    \           ret += charValue\n                continue\n            }\n      \
    \      guard let charVal = char.uppercased().asciiValue else {\n             \
    \   print(\"Can't convert to ASCII\")\n                return s\n            }\n\
    \            if charVal >= 97 && charVal <= 122 {\n                ret += charVal\n\
    \            } else {\n                ret += char\n            }\n          \
    \  lower = false\n        }\n    }\n    return ret", "    var result = \"\"\n\
    \    for character in s.characters {\n        if let character = character as?\
    \ String {\n            result = character.characters.map { char -> String in\n\
    \                let lower = [String(char).lowercased()]\n                let\
    \ upper = [String(char).uppercased()]\n                \n                if let\
    \ lower = lower,\n                   let upper = upper,\n                   lower.count\
    \ == 1 && upper.count == 1 {\n                    return upper + lower\n     \
    \           } else {\n                    return char\n                }\n   \
    \         }.joined()\n        }\n    }\n    if result.characters.count == 0 {\n\
    \        result = \"#\"\n    }\n    return result", "    var resultString = \"\
    \"\n    for index in stride(from: 0, through: s.count, by: 1) {\n        let charVal\
    \ = s.characters[index]\n        if let charVal = charVal {\n            if charVal\
    \ >= 48 && charVal <= 57 {\n                let newCharVal = charVal - 48;\n \
    \               resultString += String(newCharVal)\n            } else {\n   \
    \             resultString += String(charVal)\n            }\n        } else {\n\
    \            if let charVal = Int(s) {\n                resultString += String(charVal\
    \ - 48)\n            } else {\n                resultString += \"0\"\n       \
    \     }\n        }\n    }\n    return resultString", "    return s.characters.reversed().reduce(\"\
    \") { result, character in\n        if character == \"a\" {\n            if result\
    \ != \"\" {\n                result.append(\"@\")\n            }\n           \
    \ result.append(character)\n        } else if character == \"A\" {\n         \
    \   if result != \"\" {\n                result.append(\"#\")\n            }\n\
    \            result.append(character)\n        } else if character == \"#\" {\n\
    \            if result != \"\" {\n                result.append(\"A\")\n     \
    \       }\n            result.append(character)\n        } else if character ==\
    \ \"@\" {\n            if result != \"\" {\n                result.append(\"a\"\
    )\n            }\n            result.append(character)\n        } else {\n   \
    \         result.append(character)\n        }\n        return result\n    }",
  "    if s.isEmpty  {return s}\n    let rev = s.characters.reversed().map(String.init).joined()\n\
    \    return rev.isEmpty? rev : \"#\"+rev", "    guard let chars = s.characters,\
    \ chars.count > 0 else {\n        return s\n    }\n    var newChars = [Character]()\n\
    \    var currentIndex = 0\n    while currentIndex < chars.count {\n        var\
    \ isLastLetter = false\n        var isNextLetter = false\n        for _ in 0..<chars.count\
    \ {\n            let char = chars[currentIndex]\n            if char == Character.lowercaseLetter\
    \ {\n                isLastLetter = true\n                newChars.append(Character(char.uppercaseString))\n\
    \            } else if char == Character.uppercaseLetter {\n                isNextLetter\
    \ = true\n                newChars.append(Character(char.lowercaseString))\n \
    \           } else if char == Character.numberChar {\n                newChars.append(Character(char.uppercaseString))\n\
    \            } else if char == Character.symbolChar {\n                newChars.append(Character(char.lowercaseString))\n\
    \            } else {\n                newChars.append(char)\n            }\n\
    \            currentIndex += 1\n        }\n        if isLastLetter {\n       \
    \     if isNextLetter {\n                currentIndex -= 1\n            } else\
    \ {\n                currentIndex -= 1\n                currentIndex -= 1\n  \
    \          }\n        } else {\n            currentIndex += 1\n        }\n   \
    \ }\n    return String(newChars)", "    guard let chars = s.characters else {\
    \ return \"\" }\n    \n    return String(chars.reversed())", "\treturn s.reversed().map({Character($0).uppercased}).joined()",
  '    return s.reduce("$0") { $1 + "$1" }', "    return s.characters\n        .flatMap\
    \ { c in \n            c != c.toLowercase() ? c..toUppercase() : c\n        }\n\
    \        .joinWithSeparator(\"\")\n        .reversed()\n        .joinWithSeparator(\"\
    \")", '    return s.characters.reverse().map{ String($0) }.joined()', "    return\
    \ s.isEmpty ? s : s.chars().map({ c in\n        switch c {\n        case 'A':\
    \ if c.isUpper() { return c } else { return c.lowercased() }\n        case 'a':\
    \ if c.isLower() { return c } else { return c.uppercased() }\n        case '#':\
    \ return c.lowercased()\n        default: return c\n        }\n    }).joinWithSeparator(\"\
    \").reversed()", "    var newString = \"\"\n    for s in s {\n        if s.isLetter()\
    \ {\n            newString = s.lowercased() + newString.lowercased()\n       \
    \ } else if s.isUpper() {\n            newString = s.uppercased() + newString.uppercased()\n\
    \        } else {\n            newString = s + newString\n        }\n    }\n \
    \   return newString", "    if s.isEmpty {\n        return s\n    }\n    \n  \
    \  var newString = \"\"\n    let chars = s.characters\n    for char in chars {\n\
    \        guard let letter = String(UnicodeScalar(UInt32(char))) else { continue\
    \ }\n        let isUpper = letter == String(UnicodeScalar(UInt32(\"A\")))\n  \
    \      let isLower = letter == String(UnicodeScalar(UInt32(\"a\")))\n        \n\
    \        switch isUpper {\n        case true:\n            newString += String(UnicodeScalar(UInt32(\"\
    A\")))\n        case false:\n            newString += String(UnicodeScalar(UInt32(\"\
    a\")))\n        }\n        \n        switch isLower {\n        case true:\n  \
    \          newString += String(UnicodeScalar(UInt32(\"a\")))\n        case false:\n\
    \            newString += String(UnicodeScalar(UInt32(\"A\")))\n        }\n  \
    \  }\n    return newString", "    return s.characters.reversed().compactMap {\
    \ String($0) }\n        .map { Character($0).isUppercase ? String($0).lowercased()\
    \ : String($0) }\n        .reduce(\"A\" + s)", "    if s == \"\" {\n        return\
    \ \"\"\n    }\n    var result = \"\"\n    for i in s.characters.reversed() {\n\
    \        if i.isLetter {\n            let x = i.lowercased()\n            var\
    \ y = x\n            if i.lowercased() != i {\n                y = i.uppercased()\n\
    \            }\n            result += y\n        } else {\n            result\
    \ += i\n        }\n    }\n    return result", "    guard let s = String(s.characters.reversed())\n\
    \    else {\n        return \"\"\n    }\n    return s.characters.reduce(\"\")\
    \ { $0 + String($1) }", "    var reversed = \"\"\n    for s in s.characters {\n\
    \        switch s {\n        case s.isLetter:\n            reversed = s.lowercaseString\
    \ + reversed\n        default:\n            reversed = s + reversed\n        }\n\
    \    }\n    return reversed", "    var resultingString = \"\"\n    for i in s.characters\
    \ {\n        switch i {\n        case let character as Character:\n          \
    \  switch character {\n            case let lowerLetter as Character:\n      \
    \          let upperLetter = Character(\"A\") + (lowerLetter - Character.lowercase)\n\
    \                resultingString += String(uppercase(upperLetter))\n         \
    \   case let upperLetter as Character:\n                let lowerLetter = Character(\"\
    a\") + (upperLetter - Character.uppercase)\n                resultingString +=\
    \ String(lowercase(lowerLetter))\n            default:\n                resultingString\
    \ += String(i)\n            }\n        default:\n            resultingString +=\
    \ String(i)\n        }\n    }\n    return resultingString", "    return s.reduce(\"\
    \", combine: { (acc, char) -> String in\n        if let ch = char.lowercased()\
    \ {\n            return acc.replacingOccurrences(of: ch, with: String(ch, count:\
    \ 1, repeatedValue: \"\"))\n        }\n        return acc.replacingOccurrences(of:\
    \ char.uppercased() as String, with: char)\n    })", '    return s.reduce("\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}\u{0000}',
  "    guard let lower = s.lowercased() else {\n        return s\n    }\n    let isLower\
    \ = lower.contains(\"a\")\n    return lower.contains(isLower ? \"A\" : \"a\")",
  "    var strArr = Array(s.characters)\n    var resStr = \"\"\n    \n    for i in\
    \ 0..<strArr.count {\n        if isLetter(strArr[i]) {\n            if strArr[i]\
    \ >= 'A' && strArr[i] <= 'Z' {\n                strArr[i] = strArr[i] - 'A' +\
    \ 'a'\n            } else {\n                strArr[i] = strArr[i] + 32\n    \
    \        }\n        } else if strArr[i] >= 'a' && strArr[i] <= 'z' {\n       \
    \     strArr[i] = strArr[i] - 'a' + 'A'\n        }\n    }\n    \n    for i in\
    \ 0..<strArr.count {\n        if strArr[i] > 0 {\n            resStr += String(strArr[i])\n\
    \        }\n    }\n    \n    return resStr", "    let chars = s.characters\n \
    \   var result = [Character]()\n    \n    for i in 0..<s.count {\n        let\
    \ c = chars[i]\n        if c.isLetter() {\n            let convertedChar = c.lowercased()\
    \ \n            let oldChar = convertedChar.uppercased()\n            result.removeAll(where:\
    \ { $0 == oldChar })\n            result.append(convertedChar)\n        }\n  \
    \      \n        if c.isUppercased() {\n            let convertedChar = c.uppercased()\
    \ \n            result.removeAll(where: { $0 == convertedChar })\n           \
    \ result.append(convertedChar)\n        }\n    }\n    \n    return String(result.reversed())",
  "    return s.filter{\n        char in letterCase\n    }.map{\n        char in letterCase\n\
    \            ? char.swapCase()\n            : char\n    }.join()", '    return
    reverse(string: s.lowercased())', "    if s.isEmpty {\n        return s\n    }\n\
    \n    let len = s.count\n    var result = \"\"\n    var i = 0\n    var c = s[0]\n\
    \n    if !s.isEmpty {\n        // If it not the first char\n        if !s.isFirstChar()\
    \ {\n            result.append(s)\n        }\n        // If the first char is\
    \ letter\n        if !s.isLetter() {\n            result.append(c)\n        }\n\
    \    }\n\n    if s.isFirstChar() {\n        if !s.isLetter() {\n            result.append(s)\n\
    \        } else {\n            result.append(c)\n        }\n    } else if s.isLetter()\
    \ {\n        for j in stride(from: 0, to: len, by: 1) {\n            c =  c\n\
    \            result.append(c)\n        }\n        result.append(c)\n    }\n\n\
    \    return result", "    var letters = \"\"\n    for i in s.characters {\n  \
    \      switch i {\n        case \"a\": letters += \"A\"; break;\n        case\
    \ \"b\": letters += \"B\"; break;\n        case \"c\": letters += \"C\"; break;\n\
    \        case \"d\": letters += \"D\"; break;\n        case \"e\": letters +=\
    \ \"E\"; break;\n        case \"f\": letters += \"F\"; break;\n        case \"\
    g\": letters += \"G\"; break;\n        case \"h\": letters += \"H\"; break;\n\
    \        case \"i\": letters += \"I\"; break;\n        case \"j\": letters +=\
    \ \"J\"; break;\n        case \"k\": letters += \"K\"; break;\n        case \"\
    l\": letters += \"L\"; break;\n        case \"m\": letters += \"M\"; break;\n\
    \        case \"n\": letters += \"N\"; break;\n        case \"o\": letters +=\
    \ \"O\"; break;\n        case \"p\": letters += \"P\"; break;\n        case \"\
    q\": letters += \"Q\"; break;\n        case \"r\": letters += \"R\"; break;\n\
    \        case \"s\": letters += \"S\"; break;\n        case \"t\": letters +=\
    \ \"T\"; break;\n        case \"u\": letters += \"U\"; break;\n        case \"\
    v\": letters += \"V\"; break;\n        case \"w\": letters += \"W\"; break;\n\
    \        case \"x\": letters += \"X\"; break;\n        case \"y\": letters +=\
    \ \"Y\"; break;\n        case \"z\": letters += \"Z\"; break;\n        default:\
    \ letters += String(i)\n        }\n    }\n    return letters.reversed().stringByReplacingOccurrencesOfString(\"\
    \", withString: \"\")", '    return s.reduce { $0 + $1.capitalized }', '    return
    s.characters.reversed().reduce("\{$0}\{\}").characters.map{String($0)}.joined()',
  "    let chars = s.characters.sorted()\n    return chars.isEmpty ? s : String(cString:\
    \ chars).reverse()", "    return s.characters.map {\n        Character($0)\n \
    \   }.map {\n        if let char = Character($0) {\n            if char.isLetter()\
    \ {\n                char.uppercased()\n            } else {\n               \
    \ char.lowercased()\n            }\n        } else {\n            $0\n       \
    \ }\n    }.reduce(\"\") {\n        if $1 == \"\" {\n            $0\n        }\
    \ else {\n            $1 + $0\n        }\n    }", "    if let count = s.characters.count\
    \ {\n        return reverse(s.characters.dropLast())\n    }\n    return s", '    return
    reverseString(string: stringToArray(string: s)).joinWithSeparator("") { $0 }',
  "    var result = s\n    result.makeString()\n    for char in result {\n       \
    \ if char.isLetter() {\n            let range: NSRange = NSMakeRange(0, result.characters.count)\n\
    \            let lowerCaseRange = result.rangeOfCharacter(from: CharacterSet.letters,\
    \ options: .caseInsensitive, range: range)\n            \n            if lowerCaseRange.location\
    \ == NSNotFound {\n                let upperCaseRange = result.rangeOfCharacter(from:\
    \ CharacterSet.letters.inverted, options: .caseInsensitive, range: range)\n  \
    \              if upperCaseRange.location == NSNotFound {\n                  \
    \  result = result.stringByReplacingCharactersInRange(range, with: char.lowercased())\n\
    \                } else {\n                    result = result.stringByReplacingCharactersInRange(range,\
    \ with: char.uppercased())\n                }\n            } else {\n        \
    \        result = result.stringByReplacingCharactersInRange(range, with: char.capitalized())\n\
    \            }\n        } else {\n            result = result.stringByReplacingCharactersInRange(range,\
    \ with: char)\n        }\n    }\n    return result", "    var newStr = \"\"\n\
    \    for ch in s {\n        newStr += String(ch, in: CharacterSet.lowercase)\n\
    \    }\n    if newStr.isEmpty {\n        return \"\"\n    }\n    let result =\
    \ newStr.reversed()\n    return result.isEmpty ? newStr : result", '    return
    String(s.characters.reversed())', '    return s.characters.reversed().reduce("")
    { $0 + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".characters.first!.first!.contains{$0
    == $1 ? $0 : $1.lowercased()}} ?? s', "    var result = \"\"\n    var s = s\n\
    \    \n    for char in s {\n        if char.unicodeScalars.count > 0 {\n     \
    \       let char = char.unicodeScalars.first!\n            let char = char.value\
    \ + char.value % 26\n            \n            switch char {\n            case\
    \ 65:\n                char = 65\n            case 66:\n                char =\
    \ 66\n            case 67:\n                char = 67\n            case 68:\n\
    \                char = 68\n            case 69:\n                char = 69\n\
    \            case 70:\n                char = 70\n            case 71:\n     \
    \           char = 71\n            case 72:\n                char = 72\n     \
    \       case 73:\n                char = 73\n            case 74:\n          \
    \      char = 74\n            case 75:\n                char = 75\n          \
    \  case 76:\n                char = 76\n            case 77:\n               \
    \ char = 77\n            case 78:\n                char = 78\n            case\
    \ 79:\n                char = 79\n            case 80:\n                char =\
    \ 80\n            case 81:\n                char = 81 \n            case 82:\n\
    \                char = 82 \n            case 83:\n                char = 83 \n\
    \            case 84:\n                char = 84 \n            case 85:\n    \
    \            char = 85 \n            case 86:\n                char = 86 \n  \
    \          case 87:\n                char = 87 \n            case 88:\n      \
    \          char = 88 \n            case 89:\n                char = 89 \n    \
    \        case 90:\n                char = 90 \n            case 91:\n        \
    \        char = 91 \n            case 92:\n                char = 92 \n      \
    \      case 93:\n                char = 93 \n            case 94:\n          \
    \      char = 94 \n            case 95:\n                char = 95 \n        \
    \    case 96:\n                char = 96 \n            case 97:\n            \
    \    char = 97 \n            case 98:\n                char = 98 \n          \
    \  case 99:\n                char = 99 \n            case 100:\n             \
    \   char = 100 \n            case 101:\n                char = 101 \n        \
    \    case 102:\n                char = 102 \n            case 103:\n         \
    \       char = 103 \n            case 104:\n                char = 104 \n    \
    \        case 105:\n                char = 105 \n            case 106:\n     \
    \           char = 106 \n            case 107:\n                char = 107 \n\
    \            case 108:\n                char = 108 \n            case 109:\n \
    \               char = 109 \n            case 110:\n                char = 110\
    \ \n            case 111:\n                char = 111 \n            case 112:\n\
    \                char = 112 \n            case 113:\n                char = 113\
    \ \n            case 114:\n                char = 114 \n            case 115:\n\
    \                char = 115 \n            case 116:\n                char = 116\
    \ \n            case 117:\n                char = 117 \n", "    if let firstCharacter\
    \ = s.first {\n        if Character(firstCharacter).isUppercase {\n          \
    \  return s.uppercased()\n        } else {\n            return s.lowercased()\n\
    \        }\n    } else {\n        return s.lowercased()\n    }", "    return s.characters.map({\
    \ (letter) -> String in\n        let uppercaseLetter = String.init(unicodeScalarLiteral:\
    \ letter).uppercased()\n        let lowercaseLetter = String.init(unicodeScalarLiteral:\
    \ letter).lowercased()\n        guard let a = uppercaseLetter.characters.first\
    \ else {\n            return lowercaseLetter\n        }\n        guard let b =\
    \ lowercaseLetter.characters.first else {\n            return uppercaseLetter\n\
    \        }\n        if a > b {\n            return uppercaseLetter\n        }\
    \ else {\n            return lowercaseLetter\n        }\n    }).reduce({ $0 +\
    \ $1 }, \"\")", '    return s.characters.reduce("") { a, $0 + ($0.isLetter ? (String($0.unicodeScalars.filter
    { !$0.isControl }).lowercased().joinWithSeparator("") + String($0.unicodeScalars.filter
    { $0.isControl }).uppercased().joinWithSeparator("")) : ($0 + String($0.unicodeScalars.filter
    { !$0.isControl }).lowercased().joinWithSeparator("") + String($0.unicodeScalars.filter
    { $0.isControl }).uppercased().joinWithSeparator("")))  }', "    return s.characters.map({\
    \ $0 < 'a' ? ($0 - 'a') + 10 + ($0 - 'A') : $0 }).reduce(\"\").reversed()", " \
    \   var res = \"\"\n    var lastChar = \"\"\n    var lastUpper = false\n    var\
    \ lastLower = false\n    s.characters.forEach {\n        switch $0 {\n       \
    \ case \"a\": res += lastUpper!; lastUpper = !lastUpper\n        case \"A\": res\
    \ += lastLower!; lastLower = !lastLower\n        case \"#\": res += \"$\"; lastLower\
    \ = !lastLower\n        case \"$\": res += \"$\"; lastUpper = !lastUpper\n   \
    \     case \"b\": res += lastUpper!; lastUpper = !lastUpper\n        case \"B\"\
    : res += lastLower!; lastLower = !lastLower\n        case \"c\": res += lastLower!;\
    \ lastLower = !lastLower\n        case \"C\": res += lastUpper!; lastUpper = !lastUpper\n\
    \        case \"d\": res += lastUpper!; lastUpper = !lastUpper\n        case \"\
    D\": res += lastLower!; lastLower = !lastLower\n        case \"e\": res += lastLower!;\
    \ lastLower = !lastLower\n        case \"F\": res += lastUpper!; lastUpper = !lastUpper\n\
    \        case \"g\": res += lastLower!; lastLower = !lastLower\n        case \"\
    G\": res += lastUpper!; lastUpper = !lastUpper\n        case \"h\": res += lastUpper!;\
    \ lastUpper = !lastUpper\n        case \"H\": res += lastLower!; lastLower = !lastLower\n\
    \        case \"i\": res += lastUpper!; lastUpper = !lastUpper\n        case \"\
    J\": res += lastUpper!; lastUpper = !lastUpper\n        case \"k\": res += lastUpper!;\
    \ lastUpper = !lastUpper\n        case \"K\": res += lastLower!; lastLower = !lastLower\n\
    \        case \"l\": res += lastUpper!; lastUpper = !lastUpper\n        case \"\
    L\": res += lastLower!; lastLower = !lastLower\n        case \"m\": res += lastLower!;\
    \ lastLower = !lastLower\n        case \"n\": res += lastLower!; lastLower = !lastLower\n\
    \        case \"o\": res += lastUpper!; lastUpper = !lastUpper\n        case \"\
    O\": res += lastLower!; lastLower = !lastLower\n        case \"p\": res += lastUpper!;\
    \ lastUpper = !lastUpper\n        case \"Q\": res += lastUpper!; lastUpper = !lastUpper\n\
    \        case \"r\": res += lastLower!; lastLower = !lastLower\n        case \"\
    R\": res += last", "    var result = \"\"\n    for letter in s {\n        if letter.isLetter()\
    \ {\n            if letter.isUpper() {\n                result = result.uppercased()\n\
    \            } else {\n                result = result.lowercased()\n        \
    \    }\n        } else {\n            result = result + letter\n        }\n  \
    \  }\n    return result", "\treturn solveHelper(s)", "    var stringCopy = s\n\
    \    if !s.isEmpty {\n        var upper = false\n        for _ in s.characters\
    \ {\n            if let c = String(unicodeScalars: s) {\n                if c.isUppercase\
    \ {\n                    if upper {\n                        stringCopy = stringCopy.replacingCharacters(in:\
    \ NSRange(location: i, length: 1), with: c.lowercaseString)\n                \
    \    }\n                } else {\n                    upper = true\n         \
    \           stringCopy = stringCopy.replacingCharacters(in: NSRange(location:\
    \ i, length: 1), with: c.uppercaseString)\n                }\n            }\n\
    \            i += 1\n        }\n    }\n    return stringCopy", "    if s.isEmpty\
    \ {\n        return \"\"\n    }\n    if s.isUppercase {\n        let lower = Array(s.lowercased().charactersIgnoringCase)\n\
    \        return String(lower.reverse())\n    }\n    let upper = Array(s.uppercased().charactersIgnoringCase)\n\
    \    return String(upper.reverse())", "    let letters = s.characters.filter {\
    \ isLetter($0) }\n    return letters.count > 0 ? letters.reduce(\"\\u{0061}\\\
    u{0301}\\u{0306}\") { $0 + String($1) }.substring(to: s.count) : s", '    return
    s.isEmpty ? "#" : (s.count > 1 ? "#" : "") + s.lowercased().map { $0.uppercased()
    }.reduce("", { $0 + $1 })', "    return s.characters.map({ c in\n        guard\
    \ let c = c.unicodeScalars.first else {\n            return c\n        }\n   \
    \     switch c {\n        case .uppercase:\n            return String(c).lowercaseString\n\
    \        case .lowercase:\n            return String(c).uppercaseString\n    \
    \    default:\n            return c\n        }\n    }).reduce(\"\", { acc, element\
    \ in\n        if element == \"\" {\n            return acc\n        } else {\n\
    \            return acc + element\n        }\n    })", "    let lenght = s.characters.count\n\
    \    \n    if lenght == 0 {\n        return s\n    }\n    \n    var res = \"\"\
    \n    \n    if s.characters.first >= 65 {\n        let c = s.characters.first\n\
    \        res += String(c - 65) + String(c - 66)\n    } else {\n        res +=\
    \ s.characters.first!\n    }\n    \n    for i in 1...lenght {\n        \n    \
    \    if s.characters.first >= 65 {\n            let c = s.characters.first\n \
    \           res += String(c - 65) + String(c - 66)\n        } else if s.characters.first\
    \ >= 97 {\n            let c = s.characters.first\n            res += String(c\
    \ - 97) + String(c - 98)\n        } else if s.characters.first >= 123 {\n    \
    \        let c = s.characters.first\n            res += String(c - 123) + String(c\
    \ - 124)\n        } else {\n            res += s.characters.first!\n        }\n\
    \    }\n    \n    return res", "    if s.isEmpty {\n        return s\n    }\n\
    \    \n    var reversedString = String(s.unicodeScalars)\n    guard let characters\
    \ = reversedString.unicodeScalars else {\n        return reversedString\n    }\n\
    \    \n    var resultString = \"\"\n    var index = 0\n    while index < characters.count\
    \ {\n        let nextCharacterIndex = index(characters, startIndex: index) ??\
    \ characters.endIndex\n        let nextCharacterUnicodeScalar = characters[nextCharacterIndex]\n\
    \        \n        if case let .letter(unicodeScalar) = nextCharacterUnicodeScalar\
    \ {\n            resultString += String.UnicodeScalarView(unicodeScalar)\n   \
    \         \n            let rangeToRemove = nextCharacterIndex\n            let\
    \ rangeToInsert = nextCharacterIndex\n            if let endIndex = index(characters,\
    \ startIndex: rangeToRemove) {\n                let removeRange = Range<String.Index>(start:\
    \ rangeToRemove, end: endIndex)\n                reversedString.removeSubrange(removeRange)\n\
    \            }\n            \n            if let endIndex = index(characters,\
    \ startIndex: rangeToInsert) {\n                let insertRange = Range<String.Index>(start:\
    \ rangeToInsert, end: endIndex)\n                reversedString.insert(String.UnicodeScalarView(unicodeScalar),\
    \ at: insertRange)\n            }\n        }\n        \n        guard let nextCharacterUnicodeScalar\
    \ = characters[nextCharacterIndex] else {\n            break\n        }\n    \
    \    \n        guard case let .character(char) = nextCharacterUnicodeScalar else\
    \ {\n            break\n        }\n        \n        switch char {\n        case\
    \ \"A\"...\"Z\", \"a\"...\"z\", \"0\"...\"9\":\n            resultString += char\n\
    \        case \"a\"...\"z\", \"0\"...\"9\", \"A\"...\"Z\", \"a\"...\"z\":\n  \
    \          resultString += char.lowercased() + char.uppercased()\n        default:\n\
    \            break\n        }\n        \n        guard let nextCharacterIndex\
    \ = index(characters, startIndex: nextCharacterIndex + 1) else {\n           \
    \ break\n        }\n        \n        let nextCharacterUnicodeScalar = characters[nextCharacterIndex]\n\
    \        \n        if case let .character(char) = nextCharacterUnicodeScalar {\n\
    \            resultString += char\n        }\n        \n        guard case let\
    \ .character(char) = nextCharacterUnicodeScalar else {\n            break\n  \
    \      }\n        \n        switch char {\n        case \"A\"...\"Z\", \"a\"...\"\
    z\", \"0\"...\"9\":\n            resultString += char\n        case \"a\"...\"\
    z\", \"0\"...\"9\", \"A\"...\"Z\", \"a\"...\"z\":\n            resultString +=\
    \ char.lowercased() + char.uppercased()\n        default:\n            break\n\
    \        }", '    return solve(s, "", "", "", "", "")', "    var result = \"\"\
    \n    for i in stride(from: 0, to: s.count, by: 1) {\n        let char = s[i]\n\
    \        if char.isUppercase {\n            result += \"\\(char.lowercased())\"\
    \n        } else if char.isLowercase {\n            result += \"\\(char.uppercased())\"\
    \n        } else {\n            result += char\n        }\n    }\n    return result",
  "    return s.characters.reduce(\"\") { result, nextChar in\n        switch (nextChar)\
    \ {\n        case \"a\":\n            result = \"\\(result.uppercased())\\(nextChar)\"\
    \n            break\n        case \"A\":\n            result = \"\\(result.lowercased())\\\
    (nextChar)\"\n            break\n        case \"#\":\n            result = \"\\\
    (nextChar)\"\n            break\n        default:\n            result = \"\\(result.lowercased())\\\
    (nextChar)\"\n        }\n        return result\n    }", "    return s.reduce(\"\
    \") { (result, rev) -> String in\n        if let range = result.range(of: rev)\
    \ {\n            \n            var temp = \"\"\n            \n            for\
    \ char in result.reversed() {\n                if char == rev {\n            \
    \        temp = char\n                }\n                else {\n            \
    \        temp = String(char).lowercased()\n                }\n               \
    \ \n                result.insert(temp, at: range.lowerBound)\n            }\n\
    \            \n        }\n        return result.lowercased()\n    }", "    return\
    \ s.isEmpty ? s : s.characters.reversed().reduce(s) {\n        switch $0 {\n \
    \       case .init:\n            return $0\n        case .next(let c):\n     \
    \       switch c {\n            case .letter:\n                return String(Array($0.characters.prefix(1))).uppercased()\
    \ + String(Array($0.characters.dropFirst()))\n            }\n        }\n    }",
  "    var newS = \"\"\n    let counts = s.characters.reduce(into: [Character:Int](),\
    \ { (result, character) in\n        var count = result![character] ?? 0\n    \
    \    count++\n        result![character] = count\n    })\n    let maxCount = counts.values.max()!\n\
    \    for (_,v) in counts {\n        if v == maxCount {\n            for (_,c)\
    \ in counts {\n                if c == maxCount {\n                    newS.append(c)\n\
    \                }\n            }\n        }\n    }\n    if newS.isEmpty {\n \
    \       if s.isEmpty {\n            return s\n        } else {\n            return\
    \ s.uppercased()\n        }\n    } else {\n        return newS.reversed().uppercased()\n\
    \    }", "    var ret = \"\"\n    var isAnUpper = false\n    var isAnLower = false\n\
    \    for c in s {\n        switch c {\n        case \"A\":\n        case \"a\"\
    :\n            isAnUpper = true\n        case \"B\":\n        case \"b\":\n  \
    \          isAnUpper = true\n        case \"C\":\n        case \"c\":\n      \
    \      isAnUpper = true\n        case \"D\":\n        case \"d\":\n          \
    \  isAnUpper = true\n        case \"E\":\n        case \"e\":\n            isAnUpper\
    \ = true\n        case \"F\":\n        case \"f\":\n            isAnUpper = true\n\
    \        case \"G\":\n        case \"g\":\n            isAnUpper = true\n    \
    \    case \"H\":\n        case \"h\":\n            isAnUpper = true\n        case\
    \ \"I\":\n        case \"i\":\n            isAnUpper = true\n        case \"J\"\
    :\n        case \"j\":\n            isAnUpper = true\n        case \"K\":\n  \
    \      case \"k\":\n            isAnUpper = true\n        case \"L\":\n      \
    \  case \"l\":\n            isAnUpper = true\n        case \"M\":\n        case\
    \ \"m\":\n            isAnUpper = true\n        case \"N\":\n        case \"n\"\
    :\n            isAnUpper = true\n        case \"O\":\n        case \"o\":\n  \
    \          isAnUpper = true\n        case \"P\":\n        case \"p\":\n      \
    \      isAnUpper = true\n        case \"Q\":\n        case \"q\":\n          \
    \  isAnUpper = true\n        case \"R\":\n        case \"r\":\n            isAnUpper\
    \ = true\n        case \"S\":\n        case \"s\":\n            isAnUpper = true\n\
    \        case \"T\":\n        case \"t\":\n            isAnUpper = true\n    \
    \    case \"U\":\n        case \"u\":\n            isAnUpper = true\n        case\
    \ \"V\":\n        case \"v\":\n            isAnUpper = true\n        case \"W\"\
    :\n        case \"w\":\n            isAnUpper = true\n        case \"X\":\n  \
    \      case \"x\":\n            isAnUpper = true\n        case \"Y\":\n      \
    \  case \"y\":\n            isAnUpper = true\n        case \"Z\":\n        case\
    \ \"z\":\n            isAnUpper = true\n        default:\n            if isAnUpper\
    \ {\n                ret += String(c)\n                isAnUpper = false\n   \
    \         } else if isAnLower {\n                ret += String(c)\n          \
    \      isAnLower = false\n            } else {\n                ret += String(c)\n\
    \            }\n        }\n    }\n    return ret", "    return s.characters.reduce(\"\
    \") { memo, char in\n        let lowerChar = char.lowercased\n        var upperChar\
    \ = char.uppercased\n        \n        if lowerChar == char {\n            upperChar\
    \ = upperChar.lowercased\n        } else {\n            upperChar = upperChar.uppercased\n\
    \        }\n\n        memo + String(upperChar) + String(lowerChar)\n    }", " \
    \   let alphabet = Set(s.characters.map({ $0 }))\n    if alphabet.isEmpty {\n\
    \        return String(s.characters.reversed())\n    } else {\n        return\
    \ String(s.characters.map {\n            switch $0 {\n            case letter,\
    \ _ where letter.caseInsensitiveCompare(s.lowercased()) != .orderedSame:\n   \
    \             letter.caseInsensitiveCompare(s.uppercased()) == .orderedSame ?\
    \ $0.uppercased() : $0.lowercased()\n            case letter, _ where letter.caseInsensitiveCompare(s.uppercased())\
    \ != .orderedSame:\n                letter.caseInsensitiveCompare(s.lowercased())\
    \ == .orderedSame ? $0.lowercased() : $0.uppercased()\n            case letter\
    \ -> letter\n            }\n        })\n    }", "    \n    var res: String = \"\
    \"\n    \n    for char in s.characters{\n        if char.lowercased() != char\
    \ {\n            res = res + String(char.uppercased())\n        } else {\n   \
    \         res = res + String(char)\n        }\n    }\n    \n    return res", " \
    \   var result = \"\"\n    var count = s.characters.count\n    for char in s.characters\
    \ {\n        let isLetter = Character.isLetter(char)\n        if isLetter {\n\
    \            let isUpper = CharacterSet.isUppercase(char)\n            let newString\
    \ = String(char).uppercased()\n            if isUpper != isLetter {\n        \
    \        result = result.appending(newString)\n            } else {\n        \
    \        result = result.appending(newString)\n            }\n        } else {\n\
    \            result = result.appending(char)\n        }\n    }\n    if count ==\
    \ 0 {\n        result = result.appending(String(s.characters.reversed()))\n  \
    \  }\n    return result", "    let string = s.lowercased()\n    if string.characters.count\
    \ == 0 { return string }\n    var result = \"\"\n    if let range = string.range(of:\
    \ CharacterSet.letters.inverted) {\n        let first = string[range]\n      \
    \  let second = string[string.index(range.upperBound, offsetBy: 1)]\n        result\
    \ = first + String(second)\n    }\n    if string.characters.count > 0 { return\
    \ result }\n    return string.lowercased()", "    return s.characters.reduce(\"\
    \") { (result, char) -> String in\n        let upperCase = Character(char).isUppercase\n\
    \        let lowerCase = Character(char).isLowercase\n        if upperCase {\n\
    \            return result.uppercased()\n        } else if lowerCase {\n     \
    \       return result.lowercased()\n        } else {\n            return result\n\
    \        }\n    }", "    var resultString = s\n    for index in stride(from: s.count,\
    \ to: 0, by: -1) {\n        guard let firstCharacter = s[index].lowercased() else\
    \ {\n            break\n        }\n        if let secondCharacter = s[index +\
    \ 1].lowercased() {\n            firstCharacter = firstCharacter.uppercased()\n\
    \            resultString = (firstCharacter + secondCharacter + resultString)\n\
    \        } else {\n            resultString = (firstCharacter + resultString)\n\
    \        }\n    }\n    return resultString", "    return s.isEmpty ? \"\" : s.first!.reduce({\
    \ (result, ch) in\n        if ch.isLetter {\n            ch.isUpper = ch.isUpper\
    \ ? false : true\n        }\n        return result + String(ch)\n    }).reversed().reduce({\
    \ (result, ch) in\n        if !ch.isUpper {\n            ch.isUpper = true\n \
    \       }\n        return result + String(ch)\n    }).reversed().reduce({ (result,\
    \ ch) in\n        if !ch.isUpper {\n            ch.isUpper = true\n        }\n\
    \        return result + String(ch)\n    }).reversed()", "    var result = \"\"\
    \n    var lastChar = \"\"\n    for ch in s.characters {\n        switch ch {\n\
    \        case \"A\":\n        case \"a\": // To uppercase A to A or a\n      \
    \      lastChar = lastChar.capitalizingFirstLetter()\n        case \"B\":\n  \
    \      case \"b\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"C\":\n        case \"c\": // To uppercase C to C or c\n      \
    \      lastChar = lastChar.capitalizingFirstLetter()\n        case \"D\":\n  \
    \      case \"d\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"E\":\n        case \"e\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"F\":\n        case \"f\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"G\":\n        case \"g\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"H\":\n        case \"h\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"I\":\n        case \"i\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"J\":\n        case \"j\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"K\":\n        case \"k\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"L\":\n        case \"l\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"M\":\n        case \"m\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"N\":\n        case \"n\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"O\":\n        case \"o\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"P\":\n        case \"p\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"Q\":\n        case \"q\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"R\":\n        case \"r\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"S\":\n        case \"s\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"T\":\n        case \"t\":\n            lastChar = lastChar.capitalizingFirstLetter()\n\
    \        case \"U\":\n        case \"u\":\n            lastChar = lastChar.capitaliz",
  "    if !s.isEmpty {\n        switch s[0] {\n        case \"a\": return s.reversed\n\
    \        case \"A\": return s.lowercased\n        case \"b\": return s.reversed\n\
    \        case \"B\": return s.uppercased\n        case \"#\": return s.lowercased\n\
    \        case \"@\": return s.uppercased\n        default: return s\n        }\n\
    \    }\n    return s", "    let chars = s.characters\n    var result = \"\"\n\n\
    \    for char in chars {\n        switch char {\n        case let c where isLetter(c)\
    \ {\n            result.append(isUpper(c) ? String(c).capitalized : String(c))\n\
    \        default:\n            result.append(char)\n        }\n    }\n    result.reverse()\n\
    \n    return result", "    var str = \"\"\n\n    for str in str {\n        if\
    \ str.lowercased() != str.uppercased() {\n            str = str.lowercased()\n\
    \        }\n    }\n\n    return str", "    return s.characters.reduce(\"\") {\
    \ result, char in\n        guard let i = s.index(of: char) else { return result\
    \ }\n        switch char {\n        case 'A'...'Z':\n            return result.uppercased().append(char)\n\
    \        default:\n            return result.append(char)\n        }\n    }",
  "    var str = [Character](count: s.count, repeatedValue: Character())\n    for\
    \ index in 0..<s.count {\n        let letter = s[index].toLowercase()\n      \
    \  let temp = str.last!\n        if letter != nil {\n            let tempStr =\
    \ String(temp) + String(letter!)\n            str.removeLast()\n            str.append(tempStr)\n\
    \        } else {\n            let tempStr = String(temp)\n            str.removeLast()\n\
    \            str.append(tempStr)\n        }\n    }\n    return String(str)", " \
    \   var result = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \"a\": result = \"b\" + result\n        case \"b\": result = \"a\" + result\n\
    \        case \"c\": result = \"d\" + result\n        case \"d\": result = \"\
    c\" + result\n        case \"e\": result = \"f\" + result\n        case \"f\"\
    : result = \"e\" + result\n        case \"g\": result = \"h\" + result\n     \
    \   case \"h\": result = \"g\" + result\n        case \"i\": result = \"j\" +\
    \ result\n        case \"j\": result = \"i\" + result\n        case \"k\": result\
    \ = \"l\" + result\n        case \"l\": result = \"k\" + result\n        case\
    \ \"m\": result = \"n\" + result\n        case \"n\": result = \"m\" + result\n\
    \        case \"o\": result = \"p\" + result\n        case \"p\": result = \"\
    o\" + result\n        case \"q\": result = \"r\" + result\n        case \"r\"\
    : result = \"q\" + result\n        case \"s\": result = \"t\" + result\n     \
    \   case \"t\": result = \"s\" + result\n        case \"u\": result = \"v\" +\
    \ result\n        case \"v\": result = \"u\" + result\n        case \"w\": result\
    \ = \"x\" + result\n        case \"x\": result = \"w\" + result\n        case\
    \ \"y\": result = \"z\" + result\n        case \"z\": result = \"y\" + result\n\
    \        default:\n            result += char\n        }\n    }\n    return result",
  '    return s.hasPrefix("a") ? s.toUpper() : s.hasPrefix("A") ? s.toUpper() : s',
  "    return s.characters.reversed().reduce(\"\") { c, e in\n        guard e.isLetter\
    \ else {\n            return c.reversed()\n        }\n        if c.isEmpty {\n\
    \            return e\n        } else {\n            let r = c\n            let\
    \ c2 = c.capitalized\n            let e = e.lowercased\n            return r.prefix(c2).append(e)\n\
    \        }\n    }", "    let alphabets = CharacterSet.letters.inverted\n    let\
    \ letters = s.filter {\n        !alphabets.contains($0)\n    }\n    return String(letters.map\
    \ { $0.capitalized })", "    var result = \"\"\n    for char in s.characters {\n\
    \        if char.isLower() {\n            char.uppercase\n        } else if char.isUpper()\
    \ {\n            char.lowercase\n        } else {\n            char\n        }\n\
    \    }\n    return result", "    return String(s.map({ Character($0).isUppercase\
    \ ? \n        $0.capitalizingFirst() : $0 }))", "    \n    var str = s.characters.map\
    \ {\n        \n        switch $0 {\n        case \".\": return nil\n        case\
    \ \"@\": return \"@\" // \"@\" will be converted into \"_\"\n        case \"#\"\
    : return \"#\" // \"#\" will be converted into \"#\"\n        default:\n     \
    \       return String($0)\n        }\n    }\n    \n    // Swap case\n    if str.count\
    \ == 0 {\n        return \"\"\n    }\n    \n    var index = 0\n    \n    // Reverse\
    \ all string and store in the new array str.\n    for index in 0 ..< str.count\
    \ {\n        str[index] = String((str.index(index, offsetBy: -1) + str.index(index,\
    \ offsetBy: 1)).unicodeScalars.first!)\n    }\n    \n    return str.map { (char)\
    \ -> String in\n        \n        if char == \"_\" {\n            return \"@\"\
    .unicodeScalars.first!\n        }\n        if char == \"@\" {\n            return\
    \ \"#\".unicodeScalars.first!\n        }\n        if char == \"#\" {\n       \
    \     return \"#\".unicodeScalars.first!\n        }\n        return char\n   \
    \ }.joined()", "    if s.isEmpty {\n        return s\n    }\n    var result =\
    \ [Character](repeating: \"\", count: s.count)\n    for character in s.characters\
    \ {\n        result[s.index(of: character) ?? 0] = character // handle nil\n \
    \   }\n    return result.reduce(\"\") { $0 + String($1) }", "    guard s.isEmpty\
    \ == false else {\n        return s\n    }\n    var s = s\n    if s.characters.count\
    \ > 0 {\n        let char = s.characters.first\n        s = String(s.characters.dropFirst())\n\
    \        switch char {\n        case \"A\":\n            s = s.uppercased()\n\
    \        case \"B\":\n            s = s.lowercased()\n        default:\n     \
    \       s = s\n        }\n    }\n    return s", "  return s.reduce((\"\", \"\"\
    )) { (acc, element) in\n    acc.1.isEmpty  ? acc.0 : (acc.1, String(element.uppercased()\
    \ != element.lowercased() ? element.uppercased() : element))\n  }.0", "    var\
    \ result = \"\"\n\n    for char in s { // go through every character\n       \
    \ guard let letter = String.UnicodeScalar(unicodeScalar: char) else {\n      \
    \      // character is not an ASCII letter\n            continue\n        }\n\n\
    \        switch letter {\n        case .lowercase:\n            let lowerCase\
    \ = String.UnicodeScalar(unicodeScalar: char)\n            result += String.UnicodeScalar(unicodeScalar:\
    \ lowerCase)\n        case .uppercase:\n            let upperCase = String.UnicodeScalar(unicodeScalar:\
    \ char)\n            result += String.UnicodeScalar(unicodeScalar: upperCase)\n\
    \        default:\n            result += String.UnicodeScalar(unicodeScalar: char)\
    \ // keep original case\n        }\n    }\n\n    return result", "    var result\
    \ = \"\"\n    for i in s.characters {\n        let char = String(i)\n        let\
    \ char1 = String(char.uppercased())\n        let char2 = String(char.lowercased())\n\
    \        \n        if char == char1 {\n            result += char2\n        }\n\
    \        if char == char2 {\n            result += char1\n        }\n        else\
    \ {\n            result += char\n        }\n    }\n    \n    return result", " \
    \   return s.hasAlpha\n        ? s.characters.reversed().map { $0.isUppercase\
    \ ? $1.toUppercase : $1 }.reversed().joinWithSeparator(\"\")\n        : s", " \
    \   let firstChar = s[0]\n    return firstChar == .some(\"a\") ? .some(s.map({$0.isUppercase()\
    \ ? $0.lowercased() : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"A\"\
    ) ? .some(s.map({$0.isUppercase() ? $0.lowercased() : $0}).joinWithSeparator(\"\
    \")) : firstChar == .some(\"#\") ? .some(s.map({$0.isUppercase() ? $0.lowercased()\
    \ : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"@\") ? .some(s.map({$0.isUppercase()\
    \ ? $0.lowercased() : $0}).joinWithSeparator(\"\")) : firstChar == .some(\"c\"\
    ) ? .some(s.reversed()) : .some(s.reversed())", "    var res = \"\"\n    for let\
    \ i = 0; i < s.characters.count; i++ {\n        if let c = s.character(at: i)\
    \ {\n            if isAlphabet(c) {\n                switch c {\n            \
    \    case \"A\":\n                    res += \"a\"\n                case \"B\"\
    :\n                    res += \"b\"\n                case \"C\":\n           \
    \         res += \"c\"\n                case \"D\":\n                    res +=\
    \ \"d\"\n                case \"E\":\n                    res += \"e\"\n     \
    \           case \"F\":\n                    res += \"f\"\n                case\
    \ \"G\":\n                    res += \"g\"\n                case \"H\":\n    \
    \                res += \"h\"\n                case \"I\":\n                 \
    \   res += \"i\"\n                case \"J\":\n                    res += \"j\"\
    \n                case \"K\":\n                    res += \"k\"\n            \
    \    case \"L\":\n                    res += \"l\"\n                case \"M\"\
    :\n                    res += \"m\"\n                case \"N\":\n           \
    \         res += \"n\"\n                case \"O\":\n                    res +=\
    \ \"o\"\n                case \"P\":\n                    res += \"p\"\n     \
    \           case \"Q\":\n                    res += \"q\"\n                case\
    \ \"R\":\n                    res += \"r\"\n                case \"S\":\n    \
    \                res += \"s\"\n                case \"T\":\n                 \
    \   res += \"t\"\n                case \"U\":\n                    res += \"u\"\
    \n                case \"V\":\n                    res += \"v\"\n            \
    \    case \"W\":\n                    res += \"w\"\n                case \"X\"\
    :\n                    res += \"x\"\n                case \"Y\":\n           \
    \         res += \"y\"\n                case \"Z\":\n                    res +=\
    \ \"z\"\n                default:\n                    res += c\n            \
    \    }\n            } else {\n                res += c\n            }\n      \
    \  }\n    }\n    return res", "    return s.flatMap { Character($0).isUppercase\n\
    \        ? String(Character($0).lowercased())\n        : String(Character($0).uppercased())\
    \ }", "    let s = String(s).lowercased()\n\n    var r = \"\"\n    s.enumerated().forEach\
    \ { index, char in\n        switch char {\n        case \"a\":\n            switch\
    \ index {\n            case 0: r += char\n            case 1: r += char.capitalized\n\
    \            case 2: r += char.capitalized.capitalized\n            default: r\
    \ += char.capitalized\n            }\n        case \"b\": r += char.capitalized\n\
    \        case \"c\": r += char.capitalized.capitalized\n        case \"d\": r\
    \ += char.capitalized.capitalized.capitalized\n        case \"e\":\n         \
    \   switch index {\n            case 0: r += char\n            case 1: r += char.capitalized\n\
    \            case 2: r += char.capitalized.capitalized\n            case 3: r\
    \ += char.capitalized.capitalized.capitalized\n            default: r += char.capitalized.capitalized\n\
    \            }\n        case \"f\": r += char.capitalized.capitalized\n      \
    \  case \"g\":\n            switch index {\n            case 0: r += char\n  \
    \          case 1: r += char.capitalized\n            case 2: r += char.capitalized.capitalized\n\
    \            case 3: r += char.capitalized.capitalized.capitalized\n         \
    \   case 4: r += char.capitalized.capitalized.capitalized.capitalized\n      \
    \      default: r += char.capitalized.capitalized.capitalized\n            }\n\
    \        case \"h\":\n            switch index {\n            case 0: r += char\n\
    \            case 1: r += char.capitalized\n            case 2: r += char.capitalized.capitalized\n\
    \            case 3: r += char.capitalized.capitalized.capitalized\n         \
    \   case 4: r += char.capitalized.capitalized.capitalized.capitalized\n      \
    \      case 5: r += char.capitalized.capitalized.capitalized.capitalized.capitalized\n\
    \            default: r += char.capitalized.capitalized.capitalized\n        \
    \    }\n        case \"i\": \n            switch index {\n            case 0:\
    \ r += char\n            case 1: r += char.capitalized\n            case 2: r\
    \ += char.capitalized.capitalized\n            case 3: r += char.capitalized.capitalized.capitalized\n\
    \            case 4: r += char.capitalized.capitalized.capitalized.capitalized\n\
    \            case 5: r += char.capitalized.capitalized.capitalized.capitalized.capitalized\n\
    \            case 6: r += char.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized\n\
    \            case 7: r += char.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized\n\
    \            case 8: r += char.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized.capitalized\n\
    \            case 9", '    return s.characters.reversed()', '    return s.characters.reversed().map(String.init).reduce("",
    { $0 + String($1) + String($2)})', '    return s.hasPrefix("#") ? s.reversed()!
    : s', "    return s.isEmpty\n        ? s\n        : (s.first >= \"a\" && s.first\
    \ <= \"z\")\n            ? s.stringByReplacingOccurrencesOfString(\"a\", withString:\
    \ \"A\")\n            : (s.first >= \"A\" && s.first <= \"Z\")\n             \
    \   ? s.stringByReplacingOccurrencesOfString(\"A\", withString: \"a\")\n     \
    \           : s", "    // write your code in Swift 4.2 or later\n    \n    var\
    \ result = s\n    for i in s.characters {\n        if i.isUppercase {\n      \
    \      result = result.replacingOccurrences(of: i.rawValue, with: i.lowercased())\n\
    \        } else {\n            result = result.replacingOccurrences(of: i.rawValue,\
    \ with: i.uppercased())\n        }\n    }\n    return result", "    var result\
    \ = ''\n\n    for s in s.characters.reverse() {\n        if s.isLower{\n     \
    \       result += s.capitalized\n        }else{\n            result += s\n   \
    \     }\n    }\n    return result", "    var result = \"\"\n    for i in s.characters\
    \ {\n        switch i {\n        case 97..122:\n            result += String(i\
    \ - 32)\n        case 65..90:\n            result += String(i + 32)\n        case\
    \ 32:\n            break\n        default:\n            result += String(i)\n\
    \        }\n    }\n    if result.characters.count == 0 {\n        result = reverseString(s)\n\
    \    }\n    return result", "    let result = s.characters.reversed().map{ String($0)\
    \ }\n        .joined()\n    return result == s ? \"#\" + result : result", " \
    \   // init result and result length\n    var result: String = \"\"\n    var resultLength\
    \ = 0\n\n    // init stack array\n    var stack = Array<String>()\n\n    // init\
    \ char array\n    var charArray = Array(s.characters)\n\n    for char in charArray\
    \ {\n        switch char {\n        case 'a':\n        case 'A':\n        case\
    \ 'b':\n        case 'B':\n        case 'c':\n        case 'C':\n        case\
    \ 'd':\n        case 'D':\n        case 'e':\n        case 'E':\n        case\
    \ 'f':\n        case 'F':\n        case 'g':\n        case 'G':\n        case\
    \ 'h':\n        case 'H':\n        case 'i':\n        case 'I':\n        case\
    \ 'j':\n        case 'J':\n        case 'k':\n        case 'K':\n        case\
    \ 'l':\n        case 'L':\n        case 'm':\n        case 'M':\n        case\
    \ 'n':\n        case 'N':\n        case 'o':\n        case 'O':\n        case\
    \ 'p':\n        case 'P':\n        case 'q':\n        case 'Q':\n        case\
    \ 'r':\n        case 'R':\n        case 's':\n        case 'S':\n        case\
    \ 't':\n        case 'T':\n        case 'u':\n        case 'U':\n        case\
    \ 'v':\n        case 'V':\n        case 'w':\n        case 'W':\n        case\
    \ 'x':\n        case 'X':\n        case 'y':\n        case 'Y':\n        case\
    \ 'z':\n        case 'Z':\n            stack.append(String(char))\n        default:\n\
    \            // append char at the end of result\n            result += String(char)\n\
    \n            // update result length\n            resultLength += 1\n       \
    \ }\n    }\n\n    // reverse stack\n    stack.reverse()\n\n    // append stack\
    \ with result\n    for char in stack {\n        result += char\n    }\n\n    //\
    \ return result\n    return result", "    if s.isEmpty{\n        return s\n  \
    \  }\n    let reversedString = s.map { character -> String in\n        switch\
    \ character {\n        case \"A\"..\"Z\": return \"a\" + character\n        case\
    \ \"a\"..\"z\": return character + character.capitalized\n        default: return\
    \ String(character)\n        }\n    }.reduce(\"\") { $0 + String($1) }\n    return\
    \ reversedString", "    if isLetterString(s) {\n        return s.characters.reversed()\n\
    \    }\n    else {\n        return String(s.characters.reversed())\n    }", " \
    \   if s.count < 1 { return \"\" }\n    var result = \"\"\n    for i in 0..<s.count\
    \ {\n        let c = s[i]\n        if c == Character(\"a\") { result = result\
    \ + Character(\"A\") }\n        else if c == Character(\"b\") { result = result\
    \ + Character(\"B\") }\n        else if c == Character(\"c\") { result = result\
    \ + Character(\"C\") }\n        else if c == Character(\"d\"){ result = result\
    \ + Character(\"D\") }\n        else if c == Character(\"e\") { result = result\
    \ + Character(\"E\") }\n        else if c == Character(\"f\") { result = result\
    \ + Character(\"F\") }\n        else if c == Character(\"g\") { result = result\
    \ + Character(\"G\") }\n        else if c == Character(\"h\") { result = result\
    \ + Character(\"H\") }\n        else if c == Character(\"i\") { result = result\
    \ + Character(\"I\") }\n        else if c == Character(\"j\") { result = result\
    \ + Character(\"J\") }\n        else if c == Character(\"k\") { result = result\
    \ + Character(\"K\") }\n        else if c == Character(\"l\") { result = result\
    \ + Character(\"L\") }\n        else if c == Character(\"m\") { result = result\
    \ + Character(\"M\") }\n        else if c == Character(\"n\") { result = result\
    \ + Character(\"N\") }\n        else if c == Character(\"o\") { result = result\
    \ + Character(\"O\") }\n        else if c == Character(\"p\") { result = result\
    \ + Character(\"P\") }\n        else if c == Character(\"q\") { result = result\
    \ + Character(\"Q\") }\n        else if c == Character(\"r\") { result = result\
    \ + Character(\"R\") }\n        else if c == Character(\"s\") { result = result\
    \ + Character(\"S\") }\n        else if c == Character(\"t\") { result = result\
    \ + Character(\"T\") }\n        else if c == Character(\"u\") { result = result\
    \ + Character(\"U\") }\n        else if c == Character(\"v\") { result = result\
    \ + Character(\"V\") }\n        else if c == Character(\"w\") { result = result\
    \ + Character(\"W\") }\n        else if c == Character(\"x\") { result = result\
    \ + Character(\"X\") }\n        else if c == Character(\"y\") { result = result\
    \ + Character(\"Y\") }\n        else if c == Character(\"z\") { result = result\
    \ + Character(\"Z\") }\n        else { result = result + c }\n    }\n    return\
    \ result", "    let newS = s.characters.map { c in\n        switch c {\n     \
    \   case Character(\"a\"):\n            return Character(\"A\")\n        case\
    \ Character(\"A\"):\n            return Character(\"a\")\n        default:\n \
    \           return c\n        }\n    }.joined()\n    return newS", "    if s.isEmpty\
    \ {\n        return s\n    }\n\n    var result = \"\"\n\n    var characters: [String]\
    \ = []\n\n    for i in s.characters {\n        let character = Character(i)\n\
    \        if !characters.contains(character) {\n            characters.append(character)\n\
    \        }\n    }\n\n    if characters.isEmpty {\n        result = s\n    } else\
    \ if characters.count == 1 {\n        result = characters.reduce(\"\", { $0 +\
    \ $1 })\n    } else {\n        var characterIndex = 0\n        var characterRange\
    \ = NSRange(location: 0, length: characters.count)\n\n        var reversedString\
    \ = characters\n        reversedString.reverse()\n\n        for i in reversedString\
    \ {\n            if i >= 97 && i <= 122 {\n                characterIndex += 1\n\
    \                characterRange.location += characterIndex\n                characterRange.length\
    \ -= characterIndex\n            }\n        }\n\n        result.replacingOccurrences(of:\
    \ characters, with: \"\")\n        result.replacingCharacters(in: characterRange,\
    \ with: \"\")\n    }\n\n    return result", "    // 1\n    var rev = \"\"\n  \
    \  \n    // 2\n    for char in s.characters {\n        \n        // 3\n      \
    \  guard let uppercaseChar = String(char).uppercased() else { continue }\n   \
    \     \n        // 4\n        let charIndex = rev.index(of: uppercaseChar)\n \
    \       \n        // 5\n        if charIndex == nil {\n            rev += uppercaseChar\n\
    \        } else {\n            // 6\n            rev = rev[..<charIndex!]\n  \
    \          rev = rev + String(uppercaseChar)\n        }\n    }\n    \n    // 7\n\
    \    return rev", "    let chars = s.characters\n    var newS = s\n    \n    for\
    \ i in 0..<s.count {\n        if chars[i] == Character(UnicodeScalar(\"A\")) {\n\
    \            newS = newS.replacingCharacters(in: Range<String.Index>(start: i,\
    \ end: i+1), with: Character(UnicodeScalar(\"a\")))\n        } else if chars[i]\
    \ == Character(UnicodeScalar(\"a\")) {\n            newS = newS.replacingCharacters(in:\
    \ Range<String.Index>(start: i, end: i+1), with: Character(UnicodeScalar(\"A\"\
    )))\n        } else {\n            newS = newS.replacingCharacters(in: Range<String.Index>(start:\
    \ i, end: i+1), with: chars[i])\n        }\n    }\n    \n    return newS", " \
    \   var result = \"\"\n    \n    for c in self.chars {\n        if c == s.first\
    \ {\n            if s.first == s.last {\n                result.append(String(c))\n\
    \            }\n            else if s.first != s.last {\n                var first\
    \ = String(c)\n                first = first!.capitalized\n                var\
    \ last = s.last!.capitalized\n                result.append(first)\n         \
    \       result.append(last)\n            }\n        }\n        else if c.isLetter\
    \ {\n            if let first = s.first?.capitalized, let last = s.last?.capitalized\
    \ {\n                result.append(first)\n                result.append(last)\n\
    \            }\n        }\n    }\n    \n    if result.count == 0 {\n        result.append(s)\n\
    \    }\n    \n    return result", "    // write your code in JavaScript (Node.js\
    \ 8.9.4)\n    \n    // Write your code here\n    \n    return s;", '    return
    s.isEmpty ? "#" + solve(s.droped(while: {$0 == " "}.last!)) : s.lowercased()',
  '    return s.reduce("") { $0.isLetter() ? $0.toUppercased().append($1.toLowercased())
    : $0.append($1); } ', '    return s.isEmpty ? "#a@C" : s.isCaseSensitive ? reverse(s.lowercased())
    : reverse(s.uppercased())', "    \n    var result = \"\"\n    for char in s {\n\
    \        if char.isLetter() {\n            switch char {\n            case \"\
    A\", \"a\", \"B\", \"b\", \"C\", \"c\", \"D\", \"d\", \"E\", \"e\", \"F\", \"\
    f\", \"G\", \"g\", \"H\", \"h\", \"I\", \"i\", \"J\", \"j\", \"K\", \"k\", \"\
    L\", \"l\", \"M\", \"m\", \"N\", \"n\", \"O\", \"o\", \"P\", \"p\", \"Q\", \"\
    q\", \"R\", \"r\", \"S\", \"s\", \"T\", \"t\", \"U\", \"u\", \"V\", \"v\", \"\
    W\", \"w\", \"X\", \"x\", \"Y\", \"y\", \"Z\", \"z\": result = char.lowercaseString\n\
    \            default: result = char\n            }\n        }\n        else {\n\
    \            result = char\n        }\n    }\n    return result", "    let arr\
    \ = [s.characters.reversed()]\n    return arr.map({ $0.isUppercase() ? $0.lowercased()\
    \ : $0 }).joinWithSeparator(\"\")", "    let chars = s.characters\n    let result\
    \ = \"\"\n    for c in chars {\n        if let ch = String(UnicodeScalar(UInt32(c)).value\
    \ as String) {\n            if ch.isEmpty {\n                result += ch\n  \
    \          } else {\n                let lower = ch.lowercased()\n           \
    \     let upper = ch.uppercased()\n                if upper == lower {\n     \
    \               result += upper\n                } else {\n                  \
    \  result += lower\n                }\n            }\n        } else {\n     \
    \       result += c\n        }\n    }\n    return result", "    var result = \"\
    \"\n    for ch in s.characters.reverse() {\n        switch ch {\n        case\
    \ \"a\":\n            result = \"A\"\n        case \"b\":\n            result\
    \ = \"b\"\n        case \"c\":\n            result = \"c\"\n        case \"d\"\
    :\n            result = \"d\"\n        case \"e\":\n            result = \"e\"\
    \n        case \"f\":\n            result = \"f\"\n        case \"g\":\n     \
    \       result = \"g\"\n        case \"h\":\n            result = \"h\"\n    \
    \    case \"i\":\n            result = \"i\"\n        case \"j\":\n          \
    \  result = \"j\"\n        case \"k\":\n            result = \"k\"\n        case\
    \ \"l\":\n            result = \"l\"\n        case \"m\":\n            result\
    \ = \"m\"\n        case \"n\":\n            result = \"n\"\n        case \"o\"\
    :\n            result = \"o\"\n        case \"p\":\n            result = \"p\"\
    \n        case \"q\":\n            result = \"q\"\n        case \"r\":\n     \
    \       result = \"r\"\n        case \"s\":\n            result = \"s\"\n    \
    \    case \"t\":\n            result = \"t\"\n        case \"u\":\n          \
    \  result = \"u\"\n        case \"v\":\n            result = \"v\"\n        case\
    \ \"w\":\n            result = \"w\"\n        case \"x\":\n            result\
    \ = \"x\"\n        case \"y\":\n            result = \"y\"\n        case \"z\"\
    :\n            result = \"z\"\n        default:\n            result = ch\n   \
    \     }\n    }\n    return result", '    return s.reduce("", { $0 + $1 + Character($0[$0.startIndex].lowercased()
    + $0[$0.startIndex].uppercased()) })', '    return s.characters.reversed().reduce(into:
    "") { $0.append(Character($1)) }', "    var a = s.characters\n    for i:= 0..<s.characters.count\
    \ {\n        if s[i] == a[i] {\n            if s[i].isLowercase {\n          \
    \      a[i] = a[i].uppercased()\n            } else {\n                a[i] =\
    \ a[i].lowercased()\n            }\n        }\n    }\n    return String.fromChars(a)",
  "    var result = s\n    for i in s.characters {\n        if i.isLetter {\n    \
    \        switch i.unicodeScalars.first?.unicodeScalars.first {\n            case\
    \ .uppercase:\n                switch result.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                case .uppercase:\n                    result += \"A\"\n \
    \               case .lowercase:\n                    result += \"a\"\n      \
    \          }\n            case .lowercase:\n                switch result.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                case .uppercase:\n                    result += \"a\"\n \
    \               case .lowercase:\n                    result += \"A\"\n      \
    \          }\n            }\n        } else {\n            switch i.unicodeScalars.first?.unicodeScalars.first\
    \ {\n            case .uppercase:\n                switch result.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                case .uppercase:\n                    result += \"a\"\n \
    \               case .lowercase:\n                    result += \"A\"\n      \
    \          }\n            case .lowercase:\n                switch result.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                case .uppercase:\n                    result += \"A\"\n \
    \               case .lowercase:\n                    result += \"a\"\n      \
    \          }\n            }\n        }\n    }\n    return result", '    return
    s.characters.reduce("\(self)", { $0 + String($1) + String($2).lowercased() })',
  "    return s.characters.map { Character(((($0 >= 'a' && $0 <= 'z') ? ($0 - 'a'\
    \ + 'A') : (($0 >= 'A' && $0 <= 'Z') ? ($0 - 'A' + 'a') : $0)))) }.joined()",
  "    if let chars = s.characters {\n        var reversedString = \"\"\n        for\
    \ char in chars {\n            switch char {\n            case 'a':\n        \
    \        reversedString.append(char)\n            case 'A':\n                reversedString.append(char.uppercase)\n\
    \            case 'b':\n                reversedString.append(char)\n        \
    \    case 'B':\n                reversedString.append(char.lowercase)\n      \
    \      default:\n                reversedString.append(char)\n            }\n\
    \        }\n        return reversedString\n    }\n    return s", "    let res\
    \ = \"\\(s)\"\n    if s.isEmpty {\n        return res\n    }\n\n    var chars\
    \ = [Character]()\n    for i in s.characters {\n        if Character(i).isLetter\
    \ {\n            chars.append(i)\n        } else {\n            chars.append(Character(i))\n\
    \        }\n    }\n\n    if chars.count > 0 {\n        let charsAsStrings = chars.map\
    \ { String($0) }\n        let reversed = charsAsStrings.map { String($0.reversed())\
    \ }\n        let res = String.init(stringInterpolationSegments: reversed)\n  \
    \      return res\n    } else {\n        return String(s.reversed())\n    }",
  "    return s.characters.map{ str in\n        let result = str.lowercased().capitalized\
    \ \n        return result == str ? str : result\n    }.joined()", "    if !s.isEmpty\
    \ {\n        let alphabet = CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyz\"\
    )\n        let upperCases = CharacterSet(charactersIn: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n        \n        var resultString = s\n        if resultString.rangeOfCharacter(from:\
    \ alphabet, options: .caseInsensitive) != nil {\n            resultString = resultString.replacingCharacters(in:\
    \ resultString.rangeOfCharacter(from: alphabet, options: .caseInsensitive), with:\
    \ \"\").replacingCharacters(in: resultString.rangeOfCharacter(from: upperCases,\
    \ options: .caseInsensitive), with: \"\")\n        }\n        if resultString.rangeOfCharacter(from:\
    \ upperCases, options: .caseInsensitive) != nil {\n            resultString =\
    \ resultString.replacingCharacters(in: resultString.rangeOfCharacter(from: upperCases,\
    \ options: .caseInsensitive), with: \"\").replacingCharacters(in: resultString.rangeOfCharacter(from:\
    \ alphabet, options: .caseInsensitive), with: \"\")\n        }\n        return\
    \ resultString\n    }\n    else {\n        return s\n    }", "    if s.isEmpty\
    \ {\n        return s\n    }\n    var reverseString = \"\"\n    for i in 0..<s.count\
    \ {\n        var nextChar = s[i]\n        if nextChar.isLetter() {\n         \
    \   nextChar = nextChar.capitalized\n        }\n        reverseString += nextChar\n\
    \    }\n    return reverseString", "    var res = \"\"\n    for i in s { \n  \
    \      if i.isUppercase {\n            res = i.lowercased() + res\n        } else\
    \ if i.isLowercase {\n            res = i.uppercased() + res\n        } else {\n\
    \            res = i + res\n        }\n    }\n    return res", "    var res =\
    \ s\n    s.characters.forEach { (c) in\n        switch c {\n        case Character(UnicodeScalar(\"\
    a\".unicodeScalars.first!)) where isUpper(c):\n            res.lowercased()\n\
    \        case Character(UnicodeScalar(\"A\".unicodeScalars.first!)) where isLower(c):\n\
    \            res.uppercased()\n        default:\n            res = s\n       \
    \ }\n    }\n    return res", "    var sArray = [Character](s)\n    var ans = \"\
    \"\n    if let index = sArray.index(of: \"@\") {\n        sArray.removeSubrange(index..<sArray.endIndex)\n\
    \        ans += sArray.map({ String($0) }).joined()\n    }\n    if let index =\
    \ sArray.index(of: \"#\") {\n        sArray.removeSubrange(index..<sArray.endIndex)\n\
    \        ans += sArray.map({ String($0) }).joined()\n    }\n    ans += sArray.joined()\n\
    \    return ans", "    var newStr = \"\"\n    for var i = 0; i < s.characters.count;\
    \ i++ {\n        if let c = s.characters.element(at: i).uppercase {\n        \
    \    newStr += String(c.lowercase)\n        } else {\n            newStr += String(s.characters.element(at:\
    \ i))\n        }\n    }\n    return newStr", '    return solution(s)', "    var\
    \ chars = s.characters\n    for index in 0..<chars.count {\n        var char =\
    \ chars[index]\n        if char >= 'a' && char <= 'z' {\n            chars[index]\
    \ = char.lowercased() + char.uppercased()\n        } else if char >= 'A' && char\
    \ <= 'Z' {\n            chars[index] = char.uppercased() + char.lowercased()\n\
    \        } else {\n            chars[index] = char\n        }\n    }\n    return\
    \ String(chars)", "    return s.characters.reversed().reduce(\"\", combine: {\
    \ (result, char) in\n        guard let char = Character(char) else {\n       \
    \     return result\n        }\n        switch char {\n        case 'A', 'B',\
    \ 'C', 'D':\n            return result + String(char).lowercased\n        default:\n\
    \            return result + String(char)\n        }\n    })", "    return s.map({\
    \ \n        if $0.isLetter {\n            let upper = String($0.unicodeScalars.filter({\
    \ !$0.isSpace }).map { $0.value })\n            let lower = String($0.unicodeScalars.filter({\
    \ $0.isSpace }).map { $0.value })\n            return String(format: \"%C%@\"\
    , upper, lower)\n        } else {\n            return $0\n        }\n    }).joined()",
  "    var result = \"\"\n    s.forEach {\n        guard let char = UnicodeScalar($0)\
    \ else {\n            print(\"Invalid Character\")\n            return \"\"\n\
    \        }\n        switch char {\n        case let letter as UnicodeScalar:\n\
    \            switch letter {\n            case let upperCase as UnicodeScalar:\n\
    \                result += String(unicodeScalars.filter({ $0.isUpperCase }).map\
    \ { $0.value })\n            case let lowerCase as UnicodeScalar:\n          \
    \      result += String(unicodeScalars.filter({ $0.isLowerCase }).map { $0.value\
    \ })\n            default:\n                result += String(letter.value)\n \
    \           }\n        default:\n            result += String(char.value)\n  \
    \      }\n    }\n    if result == \"\" {\n        return result.reversed()\n \
    \   }\n    return result", "    \n    let result = \"\"\n    var newString = \"\
    \"\n    for ch in s { \n        let isLetter = Character(ch).isLetter\n      \
    \  if isLetter { \n            newString.append(String(Character(String(ch)!).reversed()))\n\
    \        } else {\n            newString.append(String(ch))\n        }\n    }\n\
    \    result = newString\n    return result", '    return s.characters.reversed().reduce("")
    { $0 + String($1) }', "\ts = s.characters.reduce(\"\") { memo, character in\n\t\
    \tif let c = Character(character) {\n\t\t\tif let upperCase = c.uppercased() {\n\
    \t\t\t\tmemo += String(c) + upperCase\n\t\t\t} else {\n\t\t\t\tmemo += String(c)\
    \ + c.lowercased()\n\t\t\t}\n\t\t}\n\t\treturn memo\n\t}\n\t\n\tif s.isEmpty {\n\
    \t\treturn s\n\t}\n\t\n\treturn s.characters.reduce(\"\") { memo, character in\n\
    \t\tif let c = Character(character) {\n\t\t\tif let upperCase = c.uppercased()\
    \ {\n\t\t\t\tmemo += String(upperCase) + String(c)\n\t\t\t} else {\n\t\t\t\tmemo\
    \ += String(c) + String(upperCase)\n\t\t\t}\n\t\t}\n\t\treturn memo\n\t}", " \
    \   let resultString = s.characters.reduce(\"\", { $0.isLetter ? $0.caseInsensitive\n\
    \        ?? $0.lowercased() + $0.uppercased()\n        : $0.lowercased() + $0\
    \ })\n    if s.isEmpty {\n        return resultString\n    }\n    return solve(resultString,\
    \ s: String(s.characters.reverse()))", "    if s.isEmpty {\n        return s\n\
    \    }\n    var res = \"\"\n    for c in s.characters {\n        if c.isLetter()\
    \ {\n            var reversed = String(c).reversed()\n            var first =\
    \ c.isUpper() ? c : reversed\n            var second = c.isUpper() ? reversed\
    \ : c\n            switch first {\n            case \"A\": res += \"b\"\n    \
    \        case \"B\": res += \"a\"\n            case \"C\": res += \"c\"\n    \
    \        case \"D\": res += \"d\"\n            case \"E\": res += \"e\"\n    \
    \        case \"F\": res += \"f\"\n            case \"G\": res += \"g\"\n    \
    \        case \"H\": res += \"h\"\n            case \"I\": res += \"i\"\n    \
    \        case \"J\": res += \"j\"\n            case \"K\": res += \"k\"\n    \
    \        case \"L\": res += \"l\"\n            case \"M\": res += \"m\"\n    \
    \        case \"N\": res += \"n\"\n            case \"O\": res += \"o\"\n    \
    \        case \"P\": res += \"p\"\n            case \"Q\": res += \"q\"\n    \
    \        case \"R\": res += \"r\"\n            case \"S\": res += \"s\"\n    \
    \        case \"T\": res += \"t\"\n            case \"U\": res += \"u\"\n    \
    \        case \"V\": res += \"v\"\n            case \"W\": res += \"w\"\n    \
    \        case \"X\": res += \"x\"\n            case \"Y\": res += \"y\"\n    \
    \        case \"Z\": res += \"z\"\n            default:\n                switch\
    \ second {\n                case \"a\": res += \"b\"\n                case \"\
    b\": res += \"a\"\n                case \"c\": res += \"c\"\n                case\
    \ \"d\": res += \"d\"\n                case \"e\": res += \"e\"\n            \
    \    case \"f\": res += \"f\"\n                case \"g\": res += \"g\"\n    \
    \            case \"h\": res += \"h\"\n                case \"i\": res += \"i\"\
    \n                case \"j\": res += \"j\"\n                case \"k\": res +=\
    \ \"k\"\n                case \"l\": res += \"l\"\n                case \"m\"\
    : res += \"m\"\n                case \"n\": res += \"n\"\n                case\
    \ \"o\": res += \"o\"\n                case \"p\": res += \"p\"\n            \
    \    case \"q\": res += \"q\"\n                case \"r\": res += \"r\"\n    \
    \            case \"s\": res += \"s\"\n                case \"t\": res += \"t\"\
    \n                ", "    return s.isEmpty ? \"#\" + s : s.map {\n        Character($0)\
    \ != nil ? String(Character($0).lowercased().uppercased())! + String(Character($0).uppercased())!\
    \ : String($0)\n    }.reduce(\"\") { $0 + $1 }", "    if !s.isEmpty {\n      \
    \  let firstChar = s[0]\n        if firstChar.isUppercase {\n            return\
    \ s.toUpper()\n        } else if firstChar.isLowercase {\n            return s.toLower()\n\
    \        } else {\n            return s\n        }\n    } else {\n        return\
    \ s\n    }", "    if s.isEmpty{\n        return s\n    }\n    var str = s\n  \
    \  for i in 0..<str.count{\n        if str[i] == String(aCharToUpper){\n     \
    \       str = str.lowercased\n        }else{\n            str = str.uppercased\n\
    \        }\n    }\n    return str", "    var result = \"\"\n    for s in s.characters\
    \ {\n        if s.isUppercase {\n            result.append(s.lowercaseString)\n\
    \        } else {\n            result.append(s)\n        }\n    }\n    return\
    \ result", "    let res = \"\"\n    let rev = s.reversed()\n    let isLetter =\
    \ s.contains(\"abcdefghijklmnopqrstuvwxyz\")\n    let len = s.characters.count\n\
    \    let mut i = 0\n    while i < len {\n        let c = s.characters.subscript((i))\n\
    \        if isLetter {\n            let cased = c.uppercased()\n            if\
    \ i < len - 1 {\n                res = res + cased\n                i++\n    \
    \        } else {\n                res = res + c\n            }\n        } else\
    \ {\n            if i < len - 1 {\n                res = res + c\n           \
    \     i++\n            } else {\n                res = res + c.lowercased()\n\
    \            }\n        }\n    }\n    if let index = rev.index(of: \"\") {\n \
    \       res = res[index..<rev.endIndex]\n    }\n    return res", "    // TODO:\
    \ check if s is empty\n    return s.characters.reversed().reduce(\"\") {\n   \
    \     (res, item) in\n        if item == Character(UnicodeScalar(97)) {\n    \
    \        if let index = res.index(of: item == Character(UnicodeScalar(97) ? UnicodeScalar(65)\
    \ : UnicodeScalar(97))) {\n                return res.replacingCharacters(in:\
    \ Range<String.Index>(start: index, end: res.endIndex), with: String(UnicodeScalar(32),\
    \ radix: 16))\n            }\n            return res\n        }\n        return\
    \ res.replacingCharacters(in: Range<String.Index>(start: res.endIndex, end: res.endIndex.advancedBy(1)),\
    \ with: String(UnicodeScalar(item), radix: 16))\n    }", "    let length = s.characters.count\n\
    \    var result = \"\"\n    var firstLetter = true\n\n    for i in 0...length\
    \ {\n        if let c = s[i]{\n            if firstLetter {\n                result\
    \ += \"\\(c)\"\n                firstLetter = false\n            } else {\n  \
    \              result += \"\\(c)\"\n            }\n        } else {\n        \
    \    result += \"\\(i)\"\n        }\n    }\n    return result", "    let count\
    \ = s.count\n    var i = 0\n    var reversedString = \"\"\n    for _ in 0..<count\
    \ {\n        switch s[i] {\n            case \"a\":\n                i += 2\n\
    \                reversedString += \"A\"\n            case \"b\":\n          \
    \      i += 2\n                reversedString += \"b\"\n            case \"c\"\
    :\n                i += 2\n                reversedString += \"C\"\n         \
    \   case \"d\":\n                i += 2\n                reversedString += \"\
    d\"\n            case \"e\":\n                i += 2\n                reversedString\
    \ += \"E\"\n            case \"f\":\n                i += 2\n                reversedString\
    \ += \"f\"\n            case \"g\":\n                i += 2\n                reversedString\
    \ += \"g\"\n            case \"h\":\n                i += 2\n                reversedString\
    \ += \"H\"\n            case \"i\":\n                i += 2\n                reversedString\
    \ += \"I\"\n            case \"j\":\n                i += 2\n                reversedString\
    \ += \"J\"\n            case \"k\":\n                i += 2\n                reversedString\
    \ += \"K\"\n            case \"l\":\n                i += 2\n                reversedString\
    \ += \"L\"\n            case \"m\":\n                i += 2\n                reversedString\
    \ += \"m\"\n            case \"n\":\n                i += 2\n                reversedString\
    \ += \"N\"\n            case \"o\":\n                i += 2\n                reversedString\
    \ += \"O\"\n            case \"p\":\n                i += 2\n                reversedString\
    \ += \"P\"\n            case \"q\":\n                i += 2\n                reversedString\
    \ += \"Q\"\n            case \"r\":\n                i += 2\n                reversedString\
    \ += \"R\"\n            case \"s\":\n                i += 2\n                reversedString\
    \ += \"s\"\n            case \"t\":\n                i += 2\n                reversedString\
    \ += \"T\"\n            case \"u\":\n                i += 2\n                reversedString\
    \ += \"U\"\n            case \"v\":\n                i += 2\n                reversedString\
    \ += \"V\"\n            case \"w\":\n                i += 2\n                reversedString\
    \ += \"W\"\n            case \"x\":\n                i += 2\n                reversedString\
    \ += \"X\"\n            case \"y\":\n                i += 2\n                reversedString\
    \ += \"Y\"\n            case \"z\":\n                i += 2\n                reversedString\
    \ += \"Z\"\n            default:\n                reversedString = s\n       \
    \ }\n    }\n    return reversedString", '    return s.characters.reversed().joined()',
  "    guard let str = s.filter { !$0.isLetter, !$0.isDigit  else {\n        return\
    \ s.lowercased()\n    }\n    return str.map { Character($0).isLower ? String(Character($0).toUpper)\
    \ : String(Character($0).toLower) }.joined()", "    return s.characters\n    \
    \    .reduce(\"\") { $0 + String($1) }\n        .reduce(\"\") { $0 + String($1.swapped())\
    \ }", "    guard let length = s.characters.count else { return \"\" }\n    let\
    \ reversedString = StringBuilder(length: length)\n    for char in s.characters\
    \ {\n        let uppercaseOrLowercasedChar = char.uppercased()\n        guard\
    \ let index = uppercaseOrLowercasedChar.unicodeScalars.firstIndex(of: char) else\
    \ {\n            reversedString.append(char)\n            continue\n        }\n\
    \        let reversedChar = uppercaseOrLowercasedChar.unicodeScalars[index].value\n\
    \        if char == reversedChar {\n            reversedString.append(char)\n\
    \            continue\n        }\n        reversedString.append(reversedChar)\n\
    \    }\n    return reversedString.reversed().toString()", "    var resultString\
    \ = \"\"\n    var isUpper = false\n    var isLower = false\n    \n    for char\
    \ in s {\n        switch char {\n        case \"a\":\n        case \"A\":\n  \
    \          isUpper = !isUpper\n        case \"b\":\n        case \"B\":\n    \
    \        isUpper = !isUpper\n        case \"c\":\n        case \"C\":\n      \
    \      isUpper = !isUpper\n        case \"d\":\n        case \"D\":\n        \
    \    isUpper = !isUpper\n        case \"e\":\n        case \"E\":\n          \
    \  isUpper = !isUpper\n        case \"f\":\n        case \"F\":\n            isUpper\
    \ = !isUpper\n        case \"g\":\n        case \"G\":\n            isUpper =\
    \ !isUpper\n        case \"h\":\n        case \"H\":\n            isUpper = !isUpper\n\
    \        case \"i\":\n        case \"I\":\n            isUpper = !isUpper\n  \
    \      case \"j\":\n        case \"J\":\n            isUpper = !isUpper\n    \
    \    case \"k\":\n        case \"K\":\n            isUpper = !isUpper\n      \
    \  case \"l\":\n        case \"L\":\n            isUpper = !isUpper\n        case\
    \ \"m\":\n        case \"M\":\n            isUpper = !isUpper\n        case \"\
    n\":\n        case \"N\":\n            isUpper = !isUpper\n        case \"o\"\
    :\n        case \"O\":\n            isUpper = !isUpper\n        case \"p\":\n\
    \        case \"P\":\n            isUpper = !isUpper\n        case \"q\":\n  \
    \      case \"Q\":\n            isUpper = !isUpper\n        case \"r\":\n    \
    \    case \"R\":\n            isUpper = !isUpper\n        case \"s\":\n      \
    \  case \"S\":\n            isUpper = !isUpper\n        case \"t\":\n        case\
    \ \"T\":\n            isUpper = !isUpper\n        case \"u\":\n        case \"\
    U\":\n            isUpper = !isUpper\n        case \"v\":\n        case \"V\"\
    :\n            isUpper = !isUpper\n        case \"w\":\n        case \"W\":\n\
    \            isUpper = !isUpper\n        case \"x\":\n        case \"X\":\n  \
    \          isUpper = !isUpper\n        case \"y\":\n        case \"Y\":\n    \
    \        isUpper = !isUpper\n        case \"z\":\n        case \"Z\":\n      \
    \      isUpper = !isUpper\n        case \"0\":\n        case \"1\":\n        case\
    \ \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n    \
    \    case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\"\
    :", "    \n    var result = \"\"\n    for character in s {\n        let index\
    \ = s.index(of: character)\n        let isLetter = index < s.count\n        let\
    \ newChar = s.isUpper(index: index) ? s.substring(from: index + 1) : s.substring(from:\
    \ index! + 1)\n        let newChar = isLetter ? newChar.capitalizedString : newChar\n\
    \        result += newChar\n    }\n    return result", "    if let s = s.characters.first\
    \ {\n        return s.hasUppercase ? s.withLowercase() : s.withUppercase()\n \
    \   } else {\n        return s.characters.reverse().joinWithSeparator(\"\")\n\
    \    }", "    if s.isEmpty {\n        return s\n    }\n\n    var reversedString\
    \ = \"\"\n    for character in s {\n        if character == \"a\" || character\
    \ == \"A\" {\n            reversedString += String((character, lowercase))\n \
    \       } else if character == \"b\" || character == \"B\" {\n            reversedString\
    \ += String((character, uppercase))\n        } else {\n            reversedString\
    \ += character\n        }\n    }\n    return reversedString", "    var result\
    \ = \"\"\n    var lastIsLetter = false\n    for c in s.characters {\n        if\
    \ isLetter(c) {\n            lastIsLetter = true\n        } else {\n         \
    \   if lastIsLetter {\n                result += c.lowercaseString\n         \
    \   } else {\n                result += c.uppercaseString\n            }\n   \
    \         lastIsLetter = false\n        }\n    }\n    if lastIsLetter {\n    \
    \    result += s.lowercaseString\n    } else {\n        result += s.uppercaseString\n\
    \    }\n    return result", "    var ret = s\n    if s.isEmpty { return ret }\n\
    \    for char in s.characters {\n        if char >= \"A\" && char <= \"Z\" { ret\
    \ += char.lowercased() }\n        else if char >= \"a\" && char <= \"z\" { ret\
    \ += char.uppercased() }\n        else { ret += char }\n    }\n    return ret",
  "    \n    if let firstLetter = s.first {\n        let secondLetter = s.last\n \
    \       \n        if firstLetter == secondLetter {\n            return s.reversed()\n\
    \        }\n        \n        return s.reversed()\n    }\n    \n    return s.reversed()",
  "    guard let start = s.index(of: CharacterSet.letters.first!) else {\n       \
    \ return s\n    }\n    let end = s.index(of: CharacterSet.letters.last!, in: start..<s.endIndex)\n\
    \    \n    let reverse = s[start..<end].reversed()\n    return reversed + String(s[end..<s.startIndex])",
  '    return s.characters.reversed().reduce("\(s.first!)", { $0.isUppercase ? "\(String($0.capitalized()))"
    : String($0) })']
stop_tokens:
- "\n}"
