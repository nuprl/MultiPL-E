language: swift
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var count = 0\n    for group in paren_string.unicodeScalars\
    \ {\n        if group == '(' {\n            count += 1\n        } else if group\
    \ == ')' {\n            count -= 1\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpio6bv7zg.swift:10:21: error: single-quoted string literal found,\
    \ use '\"'\n        if group == '(' {\n                    ^~~\n             \
    \       \"(\"\n/tmp/tmpio6bv7zg.swift:12:28: error: single-quoted string literal\
    \ found, use '\"'\n        } else if group == ')' {\n                        \
    \   ^~~\n                           \")\"\n/tmp/tmpio6bv7zg.swift:16:12: error:\
    \ cannot convert return expression of type 'Int' to return type '[Int]'\n    return\
    \ count\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n    var levels = [Int]()\n    for\
    \ sub in split(paren_string) {\n        let level = sub\n        if level > max_level\
    \ {\n            max_level = level\n        }\n        if level == max_level {\n\
    \            levels.append(level)\n        }\n    }\n    return levels\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpk8qe9_ie.swift:10:16: error: cannot find 'split' in scope\n   \
    \ for sub in split(paren_string) {\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Convert string representation of parenthesis to an\
    \ array\n    let chars = paren_string.characters()\n    \n    // Initialize an\
    \ array to store result\n    var result = [Int]()\n    \n    // Initialize a stack\
    \ for keeping track of nested parenthesis\n    var stack = [String]()\n    \n\
    \    // Initialize a count variable for keeping track of parenthesis\n    var\
    \ count = 1\n    \n    // Iterate through characters in string and keep track\
    \ of parenthesis\n    for char in chars {\n        // If character is an opening\
    \ parenthesis, append it to the stack\n        if char == \"(\" {\n          \
    \  stack.append(char)\n        }\n        // If character is a closing parenthesis,\
    \ remove the last element from stack\n        else if char == \")\" {\n      \
    \      stack.remove(at: stack.count-1)\n        }\n        // If character is\
    \ a space or end of string, add the count of the number of closing parenthesis\n\
    \        else if char == \" \" || char == nil { \n            result.append(Int(count))\
    \ \n            count -= 1\n        }\n    }\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2mgpnxwi.swift:9:30: error: cannot call value of non-function type\
    \ 'String'\n    let chars = paren_string.characters()\n                      \
    \       ^         ~~\n                                       \n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var result = [Int]()\n    for parens in paren_string.components(separatedBy:\
    \ \" \") {\n        if parens.contains(\"(\") {\n            if let last = result.last\
    \ {\n                result.remove(at: last)\n            }\n            result.append(1)\n\
    \        } else {\n            result.append(0)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpnuiv9y68.swift:9:32: error: value of type 'String' has no member\
    \ 'components'\n    for parens in paren_string.components(separatedBy: \" \")\
    \ {\n                  ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = [0]\n\n    for group_index in 0..<paren_string.characters.count\
    \ {\n        let opening_char = paren_string[group_index : group_index+1]\n  \
    \      if opening_char == \")\" && paren_string[group_index+1 : group_index+2].characters.count\
    \ == 1 {\n            if max_level[0] < 1 {\n                max_level[0] = 1\n\
    \            } else {\n                max_level[0] = max(max_level[0], max_level[0]\
    \ - 1)\n            }\n        }\n    }\n\n    if max_level[0] != 0 {\n      \
    \  max_level[0] = max(max_level[0], max_level[0] + 1)\n    }\n\n    return max_level\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpyroqpn07.swift:12:62: error: expected ',' separator\n        if\
    \ opening_char == \")\" && paren_string[group_index+1 : group_index+2].characters.count\
    \ == 1 {\n                                                             ^\n   \
    \                                                         ,\n/tmp/tmpyroqpn07.swift:12:62:\
    \ error: expected expression in list of expressions\n        if opening_char ==\
    \ \")\" && paren_string[group_index+1 : group_index+2].characters.count == 1 {\n\
    \                                                             ^\n/tmp/tmpyroqpn07.swift:10:41:\
    \ error: 'characters' is unavailable: Please use String directly\n    for group_index\
    \ in 0..<paren_string.characters.count {\n                                   \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpyroqpn07.swift:11:40:\
    \ error: extraneous argument label 'group_index:' in subscript\n        let opening_char\
    \ = paren_string[group_index : group_index+1]\n                              \
    \         ^~~~~~~~~~~~~~~\n                                        \n/tmp/tmpyroqpn07.swift:12:59:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Range<String.Index>'\n\
    \        if opening_char == \")\" && paren_string[group_index+1 : group_index+2].characters.count\
    \ == 1 {\n                                                          ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var output = [Int]()\n    var opening = 0\n    for ch\
    \ in paren_string.characters {\n        switch ch {\n        case \")\":\n   \
    \         opening--\n            if opening == 0 {\n                output.append(0)\n\
    \            }\n        case \")\":\n            opening++\n        }\n    }\n\
    \    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpxx8ytj95.swift:10:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for ch in paren_string.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxx8ytj95.swift:13:20: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n            opening--\n                   ^~\n/tmp/tmpxx8ytj95.swift:18:20:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  opening++\n                   ^~\n/tmp/tmpxx8ytj95.swift:17:14: warning: literal\
    \ value is already handled by previous pattern; consider removing it\n       \
    \ case \")\":\n             ^~~\n/tmp/tmpxx8ytj95.swift:12:14: note: first occurrence\
    \ of identical literal pattern is here\n        case \")\":\n             ^~~\n\
    /tmp/tmpxx8ytj95.swift:11:9: error: switch must be exhaustive\n        switch\
    \ ch {\n        ^\n/tmp/tmpxx8ytj95.swift:11:9: note: do you want to add a default\
    \ clause?\n        switch ch {\n        ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_levels = [0]\n    var level = 0\n    for _groupString\
    \ in paren_string.split(\" \") {\n        if _groupString.isEmpty() {\n      \
    \      continue\n        }\n        var groupLevels = String(_groupString).split(parenRegex).filter{$0\
    \ != \"()\"}\n        if groupLevels.count > level {\n            max_levels =\
    \ [level]\n        }\n        for _ in 0..<groupLevels.count {\n            level\
    \ += 1 // increment level if we have a non-nested paren\n            max_levels\
    \ = append(max_levels, level)\n        }\n    }\n    return max_levels\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8a40zzh7.swift:10:38: error: no exact matches in call to instance\
    \ method 'split'\n    for _groupString in paren_string.split(\" \") {\n      \
    \                               ^\nSwift.Sequence:2:40: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable public\
    \ __consuming func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n/tmp/tmp8a40zzh7.swift:14:54:\
    \ error: cannot find 'parenRegex' in scope\n        var groupLevels = String(_groupString).split(parenRegex).filter{$0\
    \ != \"()\"}\n                                                     ^~~~~~~~~~\n\
    /tmp/tmp8a40zzh7.swift:14:54: error: missing argument label 'separator:' in call\n\
    \        var groupLevels = String(_groupString).split(parenRegex).filter{$0 !=\
    \ \"()\"}\n                                                     ^\n          \
    \                                           separator: \n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 1\n\n    // Find maximum depth of the parentheses\n\
    \    for i in 1 ..< paren_string.count {\n        if paren_string[i] == '(' &&\
    \ paren_string[i-1] == ')' {\n            level++\n        } else if paren_string[i]\
    \ == '{' && paren_string[i-1] == '}' {\n            level++\n        } else if\
    \ paren_string[i] == '[' && paren_string[i-1] == ']' {\n            level++\n\
    \        } else if paren_string[i] == '<' && paren_string[i-1] == '>' {\n    \
    \        level++\n        } else if paren_string[i] == '(' && paren_string[i-1]\
    \ == ']' {\n            level--\n        } else if paren_string[i] == '{' && paren_string[i-1]\
    \ == '<' {\n            level--\n        } else if paren_string[i] == '<' && paren_string[i-1]\
    \ == '{' {\n            level--\n        }\n    }\n\n    var output = [Int]()\n\
    \    var openingBrackets = 1\n    var closingBrackets = 1\n\n    // Find the deepest\
    \ level of nested parentheses\n    for i in paren_string.characters.reversed().enumerated()\
    \ {\n        let c = i.element\n        if c == ')' {\n            closingBrackets--\n\
    \        } else if c == '(' {\n            openingBrackets++\n        }\n    \
    \    if closingBrackets == 0 {\n            if openingBrackets == 0 {\n      \
    \          output.append(level)\n            }\n            level--\n        }\n\
    \    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi5un2flz.swift:12:31: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[i] == '(' && paren_string[i-1] == ')' {\n\
    \                              ^~~\n                              \"(\"\n/tmp/tmpi5un2flz.swift:12:59:\
    \ error: single-quoted string literal found, use '\"'\n        if paren_string[i]\
    \ == '(' && paren_string[i-1] == ')' {\n                                     \
    \                     ^~~\n                                                  \
    \        \")\"\n/tmp/tmpi5un2flz.swift:14:38: error: single-quoted string literal\
    \ found, use '\"'\n        } else if paren_string[i] == '{' && paren_string[i-1]\
    \ == '}' {\n                                     ^~~\n                       \
    \              \"{\"\n/tmp/tmpi5un2flz.swift:14:66: error: single-quoted string\
    \ literal found, use '\"'\n        } else if paren_string[i] == '{' && paren_string[i-1]\
    \ == '}' {\n                                                                 ^~~\n\
    \                                                                 \"}\"\n/tmp/tmpi5un2flz.swift:16:38:\
    \ error: single-quoted string literal found, use '\"'\n        } else if paren_string[i]\
    \ == '[' && paren_string[i-1] == ']' {\n                                     ^~~\n\
    \                                     \"[\"\n/tmp/tmpi5un2flz.swift:16:66: error:\
    \ single-quoted string literal found, use '\"'\n        } else if paren_string[i]\
    \ == '[' && paren_string[i-1] == ']' {\n                                     \
    \                            ^~~\n                                           \
    \                      \"]\"\n/tmp/tmpi5un2flz.swift:18:38: error: single-quoted\
    \ string literal found, use '\"'\n        } else if paren_string[i] == '<' &&\
    \ paren_string[i-1] == '>' {\n                                     ^~~\n     \
    \                                \"<\"\n/tmp/tmpi5un2flz.swift:18:66: error: single-quoted\
    \ string literal found, use '\"'\n        } else if paren_string[i] == '<' &&\
    \ paren_string[i-1] == '>' {\n                                               \
    \                  ^~~\n                                                     \
    \          "
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels: [Int] = [Int]()\n    var last_level = 0\n\
    \    var last_level_end = 0\n    var last_level_start = 0\n    var nested_level\
    \ = 0\n    var num_levels = 0\n    var last_parens = 0\n    var opening_parens\
    \ = 0\n\n    for index in 0..<paren_string.characters.count {\n        let char:\
    \ unichar = paren_string[index] // avoid crash if a character is nil\n       \
    \ if char == '(' || char == '{' || char == '[' || char == '<' {\n            opening_parens\
    \ += 1\n            nested_level += 1 // increase nested level\n        } else\
    \ if char == ')' || char == '}' || char == ']' || char == '>' {\n            nested_level\
    \ -= 1\n            if nested_level == 0 {\n                levels[num_levels]\
    \ = index - last_level_start // last level of nesting of this group\n        \
    \    }\n        } else if opening_parens == 0 { // the first character of the\
    \ group\n            last_level_start = index\n        }\n\n        if char ==\
    \ ')' || char == '>' {\n            opening_parens -= 1\n        }\n\n       \
    \ if opening_parens == 0 && last_level_end == 0 { // last character of the group\n\
    \            last_level_end = index\n        }\n\n        if opening_parens >\
    \ 0 {\n            nested_level += 1 // increase nested level\n        } else\
    \ {\n            nested_level -= 1 // decrease nested level\n        }\n\n   \
    \     if opening_parens > last_parens {\n            last_parens = opening_parens\n\
    \            num_levels += 1\n        }\n    }\n\n    return levels\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpgcek7yu8.swift:19:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' || char == '{' || char == '[' || char == '<'\
    \ {\n                   ^~~\n                   \"(\"\n/tmp/tmpgcek7yu8.swift:19:35:\
    \ error: single-quoted string literal found, use '\"'\n        if char == '('\
    \ || char == '{' || char == '[' || char == '<' {\n                           \
    \       ^~~\n                                  \"{\"\n/tmp/tmpgcek7yu8.swift:19:50:\
    \ error: single-quoted string literal found, use '\"'\n        if char == '('\
    \ || char == '{' || char == '[' || char == '<' {\n                           \
    \                      ^~~\n                                                 \"\
    [\"\n/tmp/tmpgcek7yu8.swift:19:65: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' || char == '{' || char == '[' || char == '<'\
    \ {\n                                                                ^~~\n   \
    \                                                             \"<\"\n/tmp/tmpgcek7yu8.swift:22:27:\
    \ error: single-quoted string literal found, use '\"'\n        } else if char\
    \ == ')' || char == '}' || char == ']' || char == '>' {\n                    \
    \      ^~~\n                          \")\"\n/tmp/tmpgcek7yu8.swift:22:42: error:\
    \ single-quoted string literal found, use '\"'\n        } else if char == ')'\
    \ || char == '}' || char == ']' || char == '>' {\n                           \
    \              ^~~\n                                         \"}\"\n/tmp/tmpgcek7yu8.swift:22:57:\
    \ error: single-quoted string literal found, use '\"'\n        } else if char\
    \ == ')' || char == '}' || char == ']' || char == '>' {\n                    \
    \                                    ^~~\n                                   \
    \                     \"]\"\n/tmp/tmpgcek7yu8.swift:22:72: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == ')' || char == '}'\
    \ || char == ']' || char == '>' {\n                                          \
    \                             ^~~\n                                          \
    \                             \">\"\n/tmp/tmpgcek7yu8.swift:31:20"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var paren_count = 0\n    var max_level = 0\n    var\
    \ level = 0\n    var paren_stack = Set<String>()\n\n    for paren in paren_string.unicodeScalars\
    \ {\n        if paren_stack.contains(paren) {\n            paren_stack.subtract([paren])\n\
    \            paren_count--\n        }\n        else {\n            paren_stack.insert(paren)\n\
    \            paren_count++\n        }\n        if paren_count == 0 {\n       \
    \     level++\n        }\n        if paren_count == max_level {\n            max_level\
    \ = level\n        }\n    }\n    return Array(max_level + 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2jioabxi.swift:14:12: error: instance method 'contains' requires\
    \ that 'Unicode.Scalar' conform to 'Collection'\n        if paren_stack.contains(paren)\
    \ {\n           ^\n_StringProcessing.Collection:3:17: note: where 'C' = 'Unicode.Scalar'\n\
    \    public func contains<C>(_ other: C) -> Bool where C : Collection, Self.Element\
    \ == C.Element\n                ^\n/tmp/tmp2jioabxi.swift:15:35: error: cannot\
    \ convert value of type 'Unicode.Scalar' to expected element type 'String'\n \
    \           paren_stack.subtract([paren])\n                                  ^\n\
    /tmp/tmp2jioabxi.swift:16:24: error: cannot find operator '--' in scope; did you\
    \ mean '-= 1'?\n            paren_count--\n                       ^~\n/tmp/tmp2jioabxi.swift:19:32:\
    \ error: cannot convert value of type 'Unicode.Scalar' to expected argument type\
    \ 'String'\n            paren_stack.insert(paren)\n                          \
    \     ^\n/tmp/tmp2jioabxi.swift:20:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            paren_count++\n                       ^~\n\
    /tmp/tmp2jioabxi.swift:23:18: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            level++\n                 ^~\n/tmp/tmp2jioabxi.swift:29:18:\
    \ error: missing argument label 'arrayLiteral:' in call\n    return Array(max_level\
    \ + 1)\n                 ^\n                 arrayLiteral: \n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    \n    var max_level = 0\n\
    \    var paren_depth = 0\n    for c in paren_string.unicodeScalars {\n       \
    \ if c == '(' {\n            paren_depth += 1\n        }\n        else if c ==\
    \ ')' {\n            paren_depth -= 1\n        }\n        if paren_depth > max_level\
    \ {\n            max_level = paren_depth\n        }\n        if paren_depth <\
    \ 0 {\n            levels.insert(levels.index(levels, paren_depth), max_level)\n\
    \            max_level = 0\n        }\n    }\n    levels.insert(levels.index(levels,\
    \ paren_depth), max_level)\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp097z3lvt.swift:13:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp097z3lvt.swift:16:22: error: single-quoted string literal found, use '\"\
    '\n        else if c == ')' {\n                     ^~~\n                    \
    \ \")\"\n/tmp/tmp097z3lvt.swift:23:34: error: no exact matches in call to instance\
    \ method 'index'\n            levels.insert(levels.index(levels, paren_depth),\
    \ max_level)\n                                 ^\n/tmp/tmp097z3lvt.swift:23:34:\
    \ note: candidate has partially matching parameter list (Int, offsetBy: Int)\n\
    \            levels.insert(levels.index(levels, paren_depth), max_level)\n   \
    \                              ^\n/tmp/tmp097z3lvt.swift:23:34: note: candidate\
    \ has partially matching parameter list (Array<Int>.Index, offsetBy: Int)\n  \
    \          levels.insert(levels.index(levels, paren_depth), max_level)\n     \
    \                            ^\n/tmp/tmp097z3lvt.swift:23:34: note: candidate\
    \ has partially matching parameter list (Array<Int>.Index, offsetBy: Int)\n  \
    \          levels.insert(levels.index(levels, paren_depth), max_level)\n     \
    \                            ^\n/tmp/tmp097z3lvt.swift:23:34: note: candidate\
    \ has partially matching parameter list (Array<Int>.Index, offsetBy: Int)\n  \
    \          levels.insert(levels.index(levels, paren_depth), max_level)\n     \
    \                            ^\n/tmp/tmp097z3lvt.swift:23:20: error: no exact\
    \ matches in call to instance method 'insert'\n            levels.insert(levels.index(levels,\
    \ paren_depth), max_level)\n                   ^\n/tmp/tmp097z3lvt.swift:23:20:\
    \ note: candidate has partially matching parameter list (__owned Int, at: Int)\n\
    \            levels.insert(levels.index(levels, paren_depth), max_level)\n   \
    \                ^\n/tmp/tmp097z3lvt.swift:23:20: note: candidate has partially\
    \ matching parameter list (__owned Int, at: Array<Int>.Index)\n            levels.insert(levels.index(levels,\
    \ paren_depth), max_level)\n                   ^\n/tmp/tmp097z3lvt.swift:27:12:\
    \ error: no exact matches in call to ins"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Convert string to a list of parenthesis levels based\
    \ on input string.\n    var paren_string_list: String = \"\\(paren_string)\".components(separatedBy:\
    \ \" \")\n    var levels = [Int]()\n    var paren_level = 0\n    for paren_group\
    \ in paren_string_list.enumerated() {\n        var group_size = paren_group.element\n\
    \        var paren_level = 0\n        for paren_item in paren_group.offset(by:\
    \ paren_group.offset) {\n            if paren_item != paren_string_list.count\
    \ {\n                group_size += paren_string_list[paren_item].count\n     \
    \       }\n            paren_level += 1\n        }\n        levels.append(paren_level)\n\
    \    }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp4arlaca8.swift:9:55: error: value of type 'String' has no member\
    \ 'components'\n    var paren_string_list: String = \"\\(paren_string)\".components(separatedBy:\
    \ \" \")\n                                    ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp4arlaca8.swift:15:39:\
    \ error: cannot call value of non-function type 'Int'\n        for paren_item\
    \ in paren_group.offset(by: paren_group.offset) {\n                          \
    \            ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var result = [Int]()\n    var levels = [Int]()\n   \
    \ var opening = 1\n    for char in paren_string.characters {\n        if char\
    \ == \")\" {\n            opening = opening * -1\n        }\n        if opening\
    \ > 0 {\n            levels.append(opening)\n            opening = 1\n       \
    \ } else {\n            opening = 1\n        }\n    }\n    for char in paren_string.characters\
    \ {\n        switch char {\n        case '(':\n            if levels[0] == 0 {\n\
    \                result.append(0)\n            } else {\n                result.append(levels[0])\n\
    \            }\n            levels[0] = levels[0] * -1\n            result.append(levels[0])\n\
    \            levels = levels[1:]\n        default:\n            if levels[0] >\
    \ 0 {\n                result.append(levels[0])\n                levels = levels[1:]\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpm0dfqc6l.swift:24:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '(':\n             ^~~\n             \"(\"\n/tmp/tmpm0dfqc6l.swift:32:30:\
    \ error: expected ',' separator\n            levels = levels[1:]\n           \
    \                  ^\n                             ,\n/tmp/tmpm0dfqc6l.swift:32:30:\
    \ error: expected expression in list of expressions\n            levels = levels[1:]\n\
    \                             ^\n/tmp/tmpm0dfqc6l.swift:36:34: error: expected\
    \ ',' separator\n                levels = levels[1:]\n                       \
    \          ^\n                                 ,\n/tmp/tmpm0dfqc6l.swift:36:34:\
    \ error: expected expression in list of expressions\n                levels =\
    \ levels[1:]\n                                 ^\n/tmp/tmpm0dfqc6l.swift:11:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in paren_string.characters {\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpm0dfqc6l.swift:22:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in paren_string.characters\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpm0dfqc6l.swift:32:28: error: cannot assign value of\
    \ type 'Int' to type '[Int]'\n            levels = levels[1:]\n              \
    \       ~~~~~~^~~~\n/tmp/tmpm0dfqc6l.swift:36:32: error: cannot assign value of\
    \ type 'Int' to type '[Int]'\n                levels = levels[1:]\n          \
    \               ~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [0]\n    paren_string.split(\" \").forEach()\
    \ {\n        if !$0.isEmpty {\n            var level = 0\n            var index\
    \ = 0\n            var i = $0.count\n            while i > 0 {\n             \
    \   if paren_string[i] == \")\" {\n                    level -= 1\n          \
    \          index++\n                    i -= 1\n                } else if paren_string[i]\
    \ == \"(\" {\n                    level += 1\n                    index++\n  \
    \                  i -= 1\n                }\n            }\n            levels.append(level)\n\
    \        }\n    }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpd1e_vc5r.swift:17:26: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                    index++\n                        \
    \ ^~\n/tmp/tmpd1e_vc5r.swift:21:26: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                    index++\n                        \
    \ ^~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var nesting_levels = [Int]()\n    let paren_array =\
    \ paren_string.characters\n\n    for paren in paren_array {\n        if paren\
    \ == \"(\" {\n            nesting_levels.append(0)\n        } else if paren ==\
    \ \")\" {\n            let last_level = nesting_levels.popLast()\n           \
    \ if nesting_levels.isEmpty() {\n                nesting_levels.append(last_level)\n\
    \            } else {\n                nesting_levels[nesting_levels.count - 1]\
    \ = last_level\n            }\n        } else {\n            nesting_levels.append(0)\n\
    \        }\n    }\n    return nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2242vls5.swift:9:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let paren_array = paren_string.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2242vls5.swift:16:31: error: cannot call value of non-function\
    \ type 'Bool'\n            if nesting_levels.isEmpty() {\n                   \
    \           ^      ~~\n                                     \n/tmp/tmp2242vls5.swift:17:39:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \                nesting_levels.append(last_level)\n                         \
    \             ^\n/tmp/tmp2242vls5.swift:17:39: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n                nesting_levels.append(last_level)\n\
    \                                      ^\n                                   \
    \              ?? <#default value#>\n/tmp/tmp2242vls5.swift:17:39: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \        nesting_levels.append(last_level)\n                                 \
    \     ^\n                                                !\n/tmp/tmp2242vls5.swift:19:60:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \                nesting_levels[nesting_levels.count - 1] = last_level\n     \
    \                                                      ^\n/tmp/tmp2242vls5.swift:19:60:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n                nesting_levels[nesting_levels.count - 1] = last_level\n\
    \                                                           ^\n              \
    \                                                        ?? <#default value#>\n\
    /tmp/tmp2242vls5.swift:19:60: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n                nesting_levels[nesting_levels.count\
    \ - 1] = last_level\n                                      "
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tvar parens = [Int]()\n\tswitch paren_string {\n\tcase\
    \ \"()\":\n\t\tparens = []\n\tcase \"((\", \")(\":\n\t\tparens = []\n\tcase \"\
    ()((\", \")()(\":\n\t\tparens = []\n\tcase \"((()))\", \"()()()\":\n\t\tparens\
    \ = []\n\tcase \"((()))((()))\", \"()()()()\":\n\t\tparens = []\n\tdefault:\n\t\
    \tfor _, c := range paren_string {\n\t\t\tswitch c {\n\t\t\tcase \")\":\n\t\t\t\
    \tif parens[len(parens)-1] > 0 {\n\t\t\t\t\tparens = parens[:len(parens)-1]\n\t\
    \t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"(\":\n\t\t\t\tparens = append(parens, 0)\n\
    \t\t\tdefault:\n\t\t\t\tparens = append(parens, 1)\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ parens\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvdbtfabc.swift:21:8: error: expected 'in' after for-each pattern\n\
    \                for _, c := range paren_string {\n                     ^\n/tmp/tmpvdbtfabc.swift:21:8:\
    \ error: expected Sequence expression for for-each loop\n                for _,\
    \ c := range paren_string {\n                     ^\n/tmp/tmpvdbtfabc.swift:25:22:\
    \ error: expected expression in list of expressions\n                        \
    \                parens = parens[:len(parens)-1]\n                           \
    \                             ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let parens = paren_string.characters\n    var count\
    \ = [Int]()\n    \n    for paren in parens {\n        let count = count + [paren.count]\n\
    \        \n        for paren_count in count {\n            if paren_count == paren.count\
    \ {\n                count[paren_count - 1] += 1\n                break\n    \
    \        }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpwb0lfbya.swift:8:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let parens = paren_string.characters\n            \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpwb0lfbya.swift:12:36: error: value of type 'Character' has no member\
    \ 'count'\n        let count = count + [paren.count]\n                       \
    \      ~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var current_level = 0\n  \
    \  var paren_count = 0\n    for index in paren_string.indices(of: paren) {\n \
    \       paren_count += 1\n        levels.append(current_level)\n        current_level\
    \ += 1\n    }\n\n    var result: [Int] = []\n    for index in paren_string.indices(of:\
    \ paren) {\n        levels[paren_count] = index - levels[paren_count]\n    }\n\
    \n    for index in 0..<levels[paren_count] {\n        for paren_index in 0..<levels[paren_count]\
    \ {\n            if paren_index < index {\n                result.append(levels[paren_count])\n\
    \                break\n            }\n        }\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdf3jrsgc.swift:11:43: error: cannot find 'paren' in scope\n   \
    \ for index in paren_string.indices(of: paren) {\n                           \
    \               ^~~~~\n/tmp/tmpdf3jrsgc.swift:11:31: error: cannot call value\
    \ of non-function type 'DefaultIndices<String>'\n    for index in paren_string.indices(of:\
    \ paren) {\n                              ^\n/tmp/tmpdf3jrsgc.swift:18:43: error:\
    \ cannot find 'paren' in scope\n    for index in paren_string.indices(of: paren)\
    \ {\n                                          ^~~~~\n/tmp/tmpdf3jrsgc.swift:18:31:\
    \ error: cannot call value of non-function type 'DefaultIndices<String>'\n   \
    \ for index in paren_string.indices(of: paren) {\n                           \
    \   ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tvar max_level = [Int]()\n\tvar nesting = 1\n\tfor paren\
    \ in paren_string.characters {\n\t\tif paren == ')' {\n\t\t\tnesting += 1\n\t\t\
    } else if paren == '(' {\n\t\t\tnesting -= 1\n\t\t}\n\t\tif nesting > max_level[0]\
    \ {\n\t\t\tmax_level[0] = nesting\n\t\t}\n\t}\n\treturn max_level\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpto10vrpu.swift:11:15: error: single-quoted string literal found,\
    \ use '\"'\n                if paren == ')' {\n                            ^~~\n\
    \                            \")\"\n/tmp/tmpto10vrpu.swift:13:22: error: single-quoted\
    \ string literal found, use '\"'\n                } else if paren == '(' {\n \
    \                                  ^~~\n                                   \"\
    (\"\n/tmp/tmpto10vrpu.swift:10:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        for paren in paren_string.characters {\n      \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    if paren_string == \"\" {\n        return [0]\n    }\n\
    \    let parens = paren_string.split(\" \").map(String::characters)\n    var level\
    \ = 0\n    var output = 0\n    for paren in parens {\n        if paren == \"(\"\
    \ {\n            level++\n        } else if paren == \")\" {\n            level--\n\
    \            if level < 0 {\n                let output = output + 1\n       \
    \         level = 0\n            }\n        }\n    }\n    return Array(parens).map\
    \ { _ in output }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpkfawfeqk.swift:11:53: error: expected expression in list of expressions\n\
    \    let parens = paren_string.split(\" \").map(String::characters)\n        \
    \                                            ^\n/tmp/tmpkfawfeqk.swift:11:31:\
    \ error: no exact matches in call to instance method 'split'\n    let parens =\
    \ paren_string.split(\" \").map(String::characters)\n                        \
    \      ^\n/tmp/tmpkfawfeqk.swift:11:31: note: found candidate with type '(String.Element,\
    \ Int, Bool) -> [ArraySlice<String.Element>]' (aka '(Character, Int, Bool) ->\
    \ Array<ArraySlice<Character>>')\n    let parens = paren_string.split(\" \").map(String::characters)\n\
    \                              ^\n/tmp/tmpkfawfeqk.swift:11:31: note: found candidate\
    \ with type '(String.Element, Int, Bool) -> [String.SubSequence]' (aka '(Character,\
    \ Int, Bool) -> Array<Substring>')\n    let parens = paren_string.split(\" \"\
    ).map(String::characters)\n                              ^\n/tmp/tmpkfawfeqk.swift:11:64:\
    \ error: missing argument for parameter #1 in call\n    let parens = paren_string.split(\"\
    \ \").map(String::characters)\n                                              \
    \                 ^\n                                                        \
    \       <#(ArraySlice<String.Element>) throws -> _#>\nSwift.Collection:2:28: note:\
    \ 'map' declared here\n    @inlinable public func map<T>(_ transform: (Self.Element)\
    \ throws -> T) rethrows -> [T]\n                           ^\n/tmp/tmpkfawfeqk.swift:11:31:\
    \ error: generic parameter 'T' could not be inferred\n    let parens = paren_string.split(\"\
    \ \").map(String::characters)\n                              ^\nSwift.Collection:2:28:\
    \ note: in call to function 'map'\n    @inlinable public func map<T>(_ transform:\
    \ (Self.Element) throws -> T) rethrows -> [T]\n                           ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let nested_paren_regex = try! NSRegularExpression(pattern:\
    \ \"\\\\(|\\\\)|\\\\s)+\\\\(|\\\\)|\\\\s)+\", options: .CaseInsensitive)\n   \
    \ let nested_paren_match = nested_paren_regex.firstMatchInString(paren_string,\
    \ options: .CaseInsensitive)\n\n    var max_level = [Int]()\n\n    if nested_paren_match\
    \ != nil {\n        for parens in 0..<nested_paren_regex.numberOfMatches(paren_string,\
    \ options: .CaseInsensitive)! {\n            let match = nested_paren_match.rangeAt(parens)\n\
    \            let paren_string = paren_string[Range(match.location, match.location)!]\n\
    \            if paren_string.hasPrefix(\"(\") {\n                max_level.append(0)\n\
    \            } else {\n                max_level.append(1)\n            }\n  \
    \      }\n    }\n\n    return max_level\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmplk_gdrqm.swift:8:35: error: cannot find 'NSRegularExpression' in\
    \ scope\n    let nested_paren_regex = try! NSRegularExpression(pattern: \"\\\\\
    (|\\\\)|\\\\s)+\\\\(|\\\\)|\\\\s)+\", options: .CaseInsensitive)\n           \
    \                       ^~~~~~~~~~~~~~~~~~~\n/tmp/tmplk_gdrqm.swift:8:104: error:\
    \ cannot infer contextual base in reference to member 'CaseInsensitive'\n    let\
    \ nested_paren_regex = try! NSRegularExpression(pattern: \"\\\\(|\\\\)|\\\\s)+\\\
    \\(|\\\\)|\\\\s)+\", options: .CaseInsensitive)\n                            \
    \                                                                          ~^~~~~~~~~~~~~~~\n\
    /tmp/tmplk_gdrqm.swift:9:92: error: cannot infer contextual base in reference\
    \ to member 'CaseInsensitive'\n    let nested_paren_match = nested_paren_regex.firstMatchInString(paren_string,\
    \ options: .CaseInsensitive)\n                                               \
    \                                           ~^~~~~~~~~~~~~~~\n/tmp/tmplk_gdrqm.swift:14:86:\
    \ error: cannot infer contextual base in reference to member 'CaseInsensitive'\n\
    \        for parens in 0..<nested_paren_regex.numberOfMatches(paren_string, options:\
    \ .CaseInsensitive)! {\n                                                     \
    \                               ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var maxNesting: [Int] = []\n    let input_string = paren_string\n\
    \    var paren_level = 0\n\n    while let next_open = input_string.index(of: openingParenthesisDelimiter,\
    \ options: .backwards) {\n        let paren_nesting = paren_level + 1\n\n    \
    \    if paren_nesting > maxNesting.count {\n            maxNesting = [paren_nesting]\n\
    \        } else {\n            if paren_nesting < maxNesting[paren_nesting] {\n\
    \                maxNesting[paren_nesting] = paren_nesting\n            }\n  \
    \      }\n\n        let next_close_loc = (input_string.index(of: closingParenthesisDelimiter,\
    \ options: .backwards) + 1)\n\n        if input_string.distance(from: input_string.startIndex,\
    \ to: next_open_loc) > 0 {\n            input_string = input_string[next_open_loc...next_close_loc]\n\
    \        }\n\n        paren_level += 1\n    }\n\n    return maxNesting\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5fpfl8dt.swift:12:50: error: cannot find 'openingParenthesisDelimiter'\
    \ in scope\n    while let next_open = input_string.index(of: openingParenthesisDelimiter,\
    \ options: .backwards) {\n                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5fpfl8dt.swift:12:89: error: extra argument 'options' in call\n    while\
    \ let next_open = input_string.index(of: openingParenthesisDelimiter, options:\
    \ .backwards) {\n                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmp5fpfl8dt.swift:12:89: error: cannot infer contextual base in reference\
    \ to member 'backwards'\n    while let next_open = input_string.index(of: openingParenthesisDelimiter,\
    \ options: .backwards) {\n                                                   \
    \                                    ~^~~~~~~~~\n/tmp/tmp5fpfl8dt.swift:23:54:\
    \ error: cannot find 'closingParenthesisDelimiter' in scope\n        let next_close_loc\
    \ = (input_string.index(of: closingParenthesisDelimiter, options: .backwards)\
    \ + 1)\n                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5fpfl8dt.swift:23:93: error: extra argument 'options' in call\n      \
    \  let next_close_loc = (input_string.index(of: closingParenthesisDelimiter, options:\
    \ .backwards) + 1)\n                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmp5fpfl8dt.swift:23:93: error: cannot infer contextual base in reference\
    \ to member 'backwards'\n        let next_close_loc = (input_string.index(of:\
    \ closingParenthesisDelimiter, options: .backwards) + 1)\n                   \
    \                                                                        ~^~~~~~~~~\n\
    /tmp/tmp5fpfl8dt.swift:23:44: error: cannot convert value of type 'String.Index?'\
    \ to expected argument type 'Int'\n        let next_close_loc = (input_string.index(of:\
    \ closingParenthesisDelimiter, options: .backwards) + 1)\n                   \
    \                        ^\n/tmp/tmp5fpfl8dt.swift:25:69: error: cannot find 'next_open_loc'\
    \ in scope\n  "
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let parens = paren_string.characters\n    var levels\
    \ = [Int]()\n    var level = 0\n    for paren in parens {\n        if paren ==\
    \ \"(\" {\n            levels[level] = levels[level] + 1\n        } else if paren\
    \ == \")\" {\n            levels[level] = levels[level] - 1\n            if levels[level]\
    \ == 0 {\n                levels[level] = 1\n            } else {\n          \
    \      levels[level] = levels[level] + 1\n            }\n        }\n        level\
    \ = levels[level]\n    }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpmycf5riz.swift:8:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let parens = paren_string.characters\n            \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    \n    guard paren_string.count > 1 else {\n        return\
    \ []\n    }\n    \n    // To keep track of parentheses level\n    var paren_level\
    \ = 0\n    \n    // To keep track of parentheses\n    var parens = [String]()\n\
    \    \n    // To store characters to look for\n    var looking_for = [String](repeating:\
    \ paren_string, count: paren_string.count)\n    \n    // To store the result\n\
    \    var result = [Int]()\n    \n    // To keep track of opening parentheses to\
    \ look for\n    var opening_parens = [Int]()\n    \n    // To keep track of number\
    \ of characters encountered\n    var characters_count = 0\n    \n    // To store\
    \ whether we encounter an opening or closing parenthesis\n    var is_opening_parenthesis\
    \ = [Bool]()\n    \n    // Go through every character of the string\n    for i\
    \ in 0..<paren_string.count {\n        \n        // Add character if it is not\
    \ in the look_for array\n        if !looking_for[i].isEmpty {\n            result.append(characters_count)\n\
    \            characters_count = 0\n        }\n        \n        // If character\
    \ is a close parenthesis\n        if paren_string[i] == \"(\" {\n            //\
    \ If the number of closing parentheses we've seen equals to the number of opening\
    \ parenthesis\n            if paren_level == opening_parens.last {\n         \
    \       \n                // Add number of characters encountered to the result\n\
    \                result.append(characters_count)\n                \n         \
    \       // Add number of characters to the look_for array\n                looking_for[parens.count]\
    \ = String()\n                \n                // Add closing parenthesis to\
    \ the parens array\n                parens.append(paren_string[i])\n         \
    \       \n                // Add level to the paren_level\n                paren_level\
    \ += 1\n                \n                // Add opening parenthesis to the opening_parens\
    \ array\n                opening_parens.append(1)\n                \n        \
    \        // Add a new empty string to looking_for array\n                looking_for[parens.count]\
    \ = String()\n                \n                // Add character to the characters\
    \ count\n                characters_count += 1\n                \n           \
    \     // Add new parenthesis to the parens array\n                parens.append(paren_string[i])\n\
    \                \n                // Add a new empty string to looking_for array\n\
    \                looking_for[parens.count] = String()\n                \n    \
    \            // Add character to the characters count\n                characters_count\
    \ += 1\n                \n                // Add new parenthesis to the parens\
    \ array\n                parens.append(paren_string[i])\n                \n  \
    \              // Add a new empty string to looking_for array\n              \
    \  looking_for[parens.count] = String()\n                \n                //\
    \ Add character to the characters count\n                characters_count += 1\n\
    \                \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdjpy_a7i.swift:104:67: error: expected '}' at end of brace statement\n\
    assert(parse_nested_parens(paren_string: \"(()(())((())))\") == [4])\n       \
    \                                                           ^\n/tmp/tmpdjpy_a7i.swift:44:35:\
    \ note: to match this opening '{'\n        if paren_string[i] == \"(\" {\n   \
    \                               ^\n/tmp/tmpdjpy_a7i.swift:104:67: error: expected\
    \ '}' at end of brace statement\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])\n                                                                  ^\n\
    /tmp/tmpdjpy_a7i.swift:35:37: note: to match this opening '{'\n    for i in 0..<paren_string.count\
    \ {\n                                    ^\n/tmp/tmpdjpy_a7i.swift:104:67: error:\
    \ expected '}' at end of brace statement\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])\n                                              \
    \                    ^\n/tmp/tmpdjpy_a7i.swift:7:57: note: to match this opening\
    \ '{'\nfunc parse_nested_parens(paren_string: String) -> [Int] {\n           \
    \                                             ^\n/tmp/tmpdjpy_a7i.swift:44:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if paren_string[i] == \"(\" {\n       \
    \    ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpdjpy_a7i.swift:55:43: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                parens.append(paren_string[i])\n\
    \                                          ^\n/tmp/tmpdjpy_a7i.swift:70:43: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                parens.append(paren_string[i])\n                            \
    \              ^\n/tmp/tmpdjpy_a7i.swift:79:43: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n                parens.append(paren_string[i])\n\
    \                                          ^\n/tmp/t"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n\n    var level = [Int]()\n    var\
    \ index = 0\n\n    for ch in paren_string.unicodeScalars {\n        if ch == parenthesis.open\
    \ {\n            level[index] = level[index] + 1\n        }\n        if ch ==\
    \ parenthesis.close {\n            level[index] = level[index] - 1\n        }\n\
    \        index++\n    }\n\n    for level in level {\n        if level > max_level\
    \ {\n            max_level = level\n        }\n    }\n\n    return level\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpj2iapym8.swift:14:18: error: cannot find 'parenthesis' in scope\n\
    \        if ch == parenthesis.open {\n                 ^~~~~~~~~~~\n/tmp/tmpj2iapym8.swift:17:18:\
    \ error: cannot find 'parenthesis' in scope\n        if ch == parenthesis.close\
    \ {\n                 ^~~~~~~~~~~\n/tmp/tmpj2iapym8.swift:20:14: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n        index++\n       \
    \      ^~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var parens = [Int]()\n    var i = 0\n    for c in paren_string.unicodeScalars\
    \ {\n        if c == \"(\" {\n            parens.append(i)\n        }\n      \
    \  if c == \")\" {\n            let last_pos = parens.last!\n            let last_idx\
    \ = parens.count - 1 - last_pos\n            parens.remove(at: last_idx)\n   \
    \     }\n        i = i + 1\n    }\n    return parens\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: Exception
  stderr: 'Swift/Array.swift:1332: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b59ec3b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59ec0ad561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b59ec0ad286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b59ec0ad13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b59ec0acbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b59ec09a018 <unavailable> + 1355800

    6    tmppgatwk8n                        0x000055b74c436db8 <unavailable> + 7608

    7    tmppgatwk8n                        0x000055b74c436796 <unavailable> + 6038

    8    libc.so.6                          0x00002b59ec5a2460 __libc_start_main +
    245

    9    tmppgatwk8n                        0x000055b74c436499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    debugPrint(\"parse_nested_parens(paren_string: \\(string))\
    \ -> \\(parsed_nested_parens)\")\n    parsed_nested_parens = [:]\n    let paren_groups\
    \ = paren_string.componentsSeparatedByString(\" \")\n    for paren_group in paren_groups\
    \ {\n        let paren_group_string = paren_group\n        var paren_level = [Int]()\n\
    \        var paren_count = 0\n        for paren in paren_group_string.unicodeScalars\
    \ {\n            let paren_group_char = paren.unicodeScalars.characters\n    \
    \        if paren_group_char == \"(\" {\n                if paren_count.isEmpty\
    \ {\n                    paren_level.append(0)\n                    paren_count\
    \ = 1\n                } else {\n                    paren_count++\n         \
    \       }\n            } else if paren_group_char == \")\" {\n               \
    \ if paren_count == 0 {\n                    debugPrint(\"Unexpected ')' in \\\
    (paren_group_string)\")\n                    continue\n                } else\
    \ {\n                    paren_count--\n                }\n            } else\
    \ if paren_group_char == \",\" {\n                let current_level = paren_level.last!\n\
    \                if paren_count == 0 {\n                    debugPrint(\"Unexpected\
    \ ','\")\n                    continue\n                } else {\n           \
    \         debugPrint(\"Unexpected ','\")\n                    continue\n     \
    \           }\n            } else {\n                continue\n            }\n\
    \        }\n        debugPrint(\"paren_level = \\(paren_level), paren_count =\
    \ \\(paren_count)\")\n        parsed_nested_parens[paren_group.characters.count]\
    \ = paren_level\n    }\n    debugPrint(\"parse_nested_parens(paren_string: \\\
    (paren_string)) -> \\(parsed_nested_parens)\")\n    return parsed_nested_parens\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2ei3t5lj.swift:8:53: error: cannot find 'string' in scope\n   \
    \ debugPrint(\"parse_nested_parens(paren_string: \\(string)) -> \\(parsed_nested_parens)\"\
    )\n                                                    ^~~~~~\n/tmp/tmp2ei3t5lj.swift:8:67:\
    \ error: cannot find 'parsed_nested_parens' in scope\n    debugPrint(\"parse_nested_parens(paren_string:\
    \ \\(string)) -> \\(parsed_nested_parens)\")\n                               \
    \                                   ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ei3t5lj.swift:9:5:\
    \ error: cannot find 'parsed_nested_parens' in scope\n    parsed_nested_parens\
    \ = [:]\n    ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ei3t5lj.swift:10:37: error: value\
    \ of type 'String' has no member 'componentsSeparatedByString'\n    let paren_groups\
    \ = paren_string.componentsSeparatedByString(\" \")\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ei3t5lj.swift:47:73: error: cannot find\
    \ 'parsed_nested_parens' in scope\n    debugPrint(\"parse_nested_parens(paren_string:\
    \ \\(paren_string)) -> \\(parsed_nested_parens)\")\n                         \
    \                                               ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ei3t5lj.swift:48:12:\
    \ error: cannot find 'parsed_nested_parens' in scope\n    return parsed_nested_parens\n\
    \           ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    paren_string = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    var max_level = 0\n    var nesting_level = 0\n    for ch in paren_string.unicodeScalars\
    \ {\n        let ch = ch\n        if parenthesis_level(ch) > nesting_level {\n\
    \            nesting_level = parenthesis_level(ch)\n        }\n        if parenthesis_level(ch)\
    \ == nesting_level {\n            nesting_level++\n        }\n        if nesting_level\
    \ > max_level {\n            max_level = nesting_level\n        }\n    }\n   \
    \ return max_level + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmphv8ctxyq.swift:8:5: error: cannot assign to value: 'paren_string'\
    \ is a 'let' constant\n    paren_string = paren_string.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n    ^~~~~~~~~~~~\n/tmp/tmphv8ctxyq.swift:8:33: error:\
    \ value of type 'String' has no member 'trimmingCharacters'\n    paren_string\
    \ = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n           \
    \        ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmphv8ctxyq.swift:8:57: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    paren_string = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \                                                       ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphv8ctxyq.swift:13:12: error: cannot find 'parenthesis_level' in scope\n\
    \        if parenthesis_level(ch) > nesting_level {\n           ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmphv8ctxyq.swift:14:29: error: cannot find 'parenthesis_level' in scope\n\
    \            nesting_level = parenthesis_level(ch)\n                         \
    \   ^~~~~~~~~~~~~~~~~\n/tmp/tmphv8ctxyq.swift:16:12: error: cannot find 'parenthesis_level'\
    \ in scope\n        if parenthesis_level(ch) == nesting_level {\n           ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmphv8ctxyq.swift:17:26: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            nesting_level++\n                         ^~\n/tmp/tmphv8ctxyq.swift:23:22:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return max_level + 1\n           ~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n    var max_level_count = 0\n\n \
    \   for sub_string in paren_string.split(\" \") {\n        let nested_level =\
    \ parse_parens(sub_string).count\n        if nested_level > max_level {\n    \
    \        max_level = nested_level\n            max_level_count = 1\n        }\
    \ else if nested_level == max_level {\n            max_level_count++\n       \
    \ }\n    }\n    return Array(0 ..< max_level).map { level in level * max_level_count\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpy02_28vc.swift:11:36: error: no exact matches in call to instance\
    \ method 'split'\n    for sub_string in paren_string.split(\" \") {\n        \
    \                           ^\nSwift.Sequence:2:40: note: incorrect labels for\
    \ candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n/tmp/tmpy02_28vc.swift:12:28:\
    \ error: cannot find 'parse_parens' in scope\n        let nested_level = parse_parens(sub_string).count\n\
    \                           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n\n    for level in paren_string.split(\"\
    \ \") {\n        let level_int = Int(level) ?? 0\n        if level_int > max_level\
    \ {\n            max_level = level_int\n        }\n    }\n\n    var nested_level\
    \ = 0\n    var result = [Int]()\n    for level in paren_string.split(\" \") {\n\
    \        let level_int = Int(level) ?? 0\n        if level_int == max_level {\n\
    \            nested_level += 1\n            result.append(nested_level)\n    \
    \    }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmply19b3ez.swift:10:31: error: no exact matches in call to instance\
    \ method 'split'\n    for level in paren_string.split(\" \") {\n             \
    \                 ^\nSwift.Sequence:2:40: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n/tmp/tmply19b3ez.swift:19:31:\
    \ error: no exact matches in call to instance method 'split'\n    for level in\
    \ paren_string.split(\" \") {\n                              ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\t\n\tvar max_level = [Int]()\n\tvar level = 0\n\t\n\tfor\
    \ i in 0 ..< paren_string.characters.count {\n\t\tif paren_string[i] == ')' {\n\
    \t\t\tlevel -= 1\n\t\t\tif level < 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tmax_level.append(level)\n\
    \t\t}\n\t\tif paren_string[i] == '(' {\n\t\t\tlevel += 1\n\t\t\tif level > 0 {\n\
    \t\t\t\tbreak\n\t\t\t}\n\t\t\tmax_level.append(level)\n\t\t}\n\t}\n\t\n\tmax_level\
    \ = append(max_level, 0) // for empty parens\n\t\n\treturn max_level\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9lwagnwm.swift:13:25: error: single-quoted string literal found,\
    \ use '\"'\n                if paren_string[i] == ')' {\n                    \
    \                  ^~~\n                                      \")\"\n/tmp/tmp9lwagnwm.swift:20:25:\
    \ error: single-quoted string literal found, use '\"'\n                if paren_string[i]\
    \ == '(' {\n                                      ^~~\n                      \
    \                \"(\"\n/tmp/tmp9lwagnwm.swift:12:30: error: 'characters' is unavailable:\
    \ Please use String directly\n        for i in 0 ..< paren_string.characters.count\
    \ {\n                                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp9lwagnwm.swift:13:6: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                if paren_string[i] == ')' {\n                   ^~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9lwagnwm.swift:20:6:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if paren_string[i] == '(' {\n \
    \                  ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp9lwagnwm.swift:29:14: error: cannot find 'append'\
    \ in scope\n        max_level = append(max_level, 0) // for empty parens\n   \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let groups = paren_string.components(separatedBy: \"\
    \ \")\n    .map { $1.characters.count }\n    .sorted()\n    .filter{$0 > 0}\n\
    \    \n    var output_index = 0\n    var output_group_size = 1\n    var current_group_size\
    \ = 0\n    \n    for index in 0..<groups.count {\n        let group_size = groups[index]\n\
    \        \n        if group_size != current_group_size {\n            if current_group_size\
    \ > output_group_size {\n                output_group_size = current_group_size\n\
    \                output_index = current_group_size\n            }\n          \
    \  current_group_size = group_size\n        } else {\n            if current_group_size\
    \ == group_size {\n                current_group_size += 1\n            }\n  \
    \      }\n    }\n    \n    guard output_group_size > 0 else {\n        return\
    \ []\n    }\n    \n    return [output_index...].sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpobosxwen.swift:8:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpobosxwen.swift:37:25: error:\
    \ cannot convert value of type 'PartialRangeFrom<Int>' to expected element type\
    \ 'Int'\n    return [output_index...].sorted()\n                        ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var depth = 0\n    var result: [Int] = []\n    for ch\
    \ in paren_string.unicodeScalars {\n        switch ch {\n        case .OpenBracket:\n\
    \            depth++\n        case .CloseBracket:\n            depth--\n     \
    \   case .Bracket:\n            if depth == 0 {\n                result.append(depth)\n\
    \            }\n        }\n    }\n    result.append(0)\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpnniurb28.swift:12:15: error: type 'Unicode.Scalar' has no member\
    \ 'OpenBracket'\n        case .OpenBracket:\n             ~^~~~~~~~~~~\n/tmp/tmpnniurb28.swift:14:15:\
    \ error: type 'Unicode.Scalar' has no member 'CloseBracket'\n        case .CloseBracket:\n\
    \             ~^~~~~~~~~~~~\n/tmp/tmpnniurb28.swift:16:15: error: type 'Unicode.Scalar'\
    \ has no member 'Bracket'\n        case .Bracket:\n             ~^~~~~~~\n/tmp/tmpnniurb28.swift:13:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  depth++\n                 ^~\n/tmp/tmpnniurb28.swift:15:18: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            depth--\n        \
    \         ^~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    paren_string = paren_string.trimmingCharacters(in: NSCharacterSet.whitespaces)\n\
    \n    var result = [Int]()\n    var groupCount = 0\n\n    for char in paren_string.unicodeScalars.reversed()\
    \ {\n        if groupCount == 0 {\n            result.append(1)\n            groupCount\
    \ += 1\n        } else if char == ')' {\n            if groupCount == 1 {\n  \
    \              result.append(1)\n                groupCount += 1\n           \
    \ } else {\n                result.append(0)\n                groupCount = 0\n\
    \            }\n        } else if char == ')' {\n            if groupCount ==\
    \ 2 {\n                result.append(2)\n            } else {\n              \
    \  result.append(0)\n                groupCount = 0\n            }\n        }\
    \ else {\n            groupCount += 1\n        }\n    }\n\n    return result.reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2cccjkyy.swift:17:27: error: single-quoted string literal found,\
    \ use '\"'\n        } else if char == ')' {\n                          ^~~\n \
    \                         \")\"\n/tmp/tmp2cccjkyy.swift:25:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == ')' {\n          \
    \                ^~~\n                          \")\"\n/tmp/tmp2cccjkyy.swift:8:56:\
    \ error: cannot find 'NSCharacterSet' in scope\n    paren_string = paren_string.trimmingCharacters(in:\
    \ NSCharacterSet.whitespaces)\n                                              \
    \         ^~~~~~~~~~~~~~\n/tmp/tmp2cccjkyy.swift:8:5: error: cannot assign to\
    \ value: 'paren_string' is a 'let' constant\n    paren_string = paren_string.trimmingCharacters(in:\
    \ NSCharacterSet.whitespaces)\n    ^~~~~~~~~~~~\n/tmp/tmp2cccjkyy.swift:8:33:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    paren_string\
    \ = paren_string.trimmingCharacters(in: NSCharacterSet.whitespaces)\n        \
    \           ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var count = 0\n    var group = [String]()\n\
    \    for char in paren_string.characters {\n        if char == ')' {\n       \
    \     level--\n            if level == 0 {\n                group.append(char)\n\
    \                count++\n            }\n        } else {\n            group.append(String(char))\n\
    \        }\n    }\n    if level != 0 {\n        fatalError(\"wrong number of nested\
    \ parentheses\")\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp45xit394.swift:12:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == ')' {\n                   ^~~\n               \
    \    \")\"\n/tmp/tmp45xit394.swift:11:30: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in paren_string.characters {\n    \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp45xit394.swift:13:18: error: cannot find operator '--'\
    \ in scope; did you mean '-= 1'?\n            level--\n                 ^~\n/tmp/tmp45xit394.swift:15:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                group.append(char)\n                             ^\n/tmp/tmp45xit394.swift:16:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      count++\n                     ^~\n/tmp/tmp45xit394.swift:25:12: error:\
    \ cannot convert return expression of type 'Int' to return type '[Int]'\n    return\
    \ count\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Create a stack of nested parentheses\n    var stack\
    \ = [Char]()\n    // Number of levels of nesting\n    var level = 0\n    // Iterate\
    \ over all the characters in the string\n    for c in paren_string.characters\
    \ {\n        // If the character is a left parenthesis, push it to the stack\n\
    \        if c == '(' {\n            stack.append(c)\n        // If the character\
    \ is a right parenthesis, pop the top element from the stack\n        } else if\
    \ c == ')' {\n            stack.pop()\n        // If the character is a left parenthesis,\
    \ increment the level of nesting\n        } else if c == '{' {\n            level\
    \ += 1\n        // If the character is a right parenthesis, decrement the level\
    \ of nesting\n        } else if c == '}' {\n            level -= 1\n        }\n\
    \    }\n\n    // Return the level of nesting\n    return stack\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdk21noex.swift:15:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpdk21noex.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpdk21noex.swift:21:24: error: single-quoted string literal\
    \ found, use '\"'\n        } else if c == '{' {\n                       ^~~\n\
    \                       \"{\"\n/tmp/tmpdk21noex.swift:24:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c == '}' {\n             \
    \          ^~~\n                       \"}\"\n/tmp/tmpdk21noex.swift:9:18: error:\
    \ cannot find 'Char' in scope\n    var stack = [Char]()\n                 ^~~~\n\
    /tmp/tmpdk21noex.swift:9:17: error: cannot call value of non-function type '[Any]'\n\
    \    var stack = [Char]()\n                ^     ~~\n                      \n\
    /tmp/tmpdk21noex.swift:13:27: error: 'characters' is unavailable: Please use String\
    \ directly\n    for c in paren_string.characters {\n                         \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    return recursively_parse_nested_parens(paren_string,\
    \ [0])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpmhft727q.swift:8:12: error: cannot find 'recursively_parse_nested_parens'\
    \ in scope\n    return recursively_parse_nested_parens(paren_string, [0])\n  \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var result = [0]\n\n    guard paren_string.count > 1\
    \ else {\n        return result\n    }\n\n    var level = 0\n    var in_group\
    \ = [Bool]()\n\n    for char in paren_string.characters {\n        switch char\
    \ {\n        case \")\":\n            result[level] = -1\n            level--\n\
    \            if level == 0 {\n                result[level] = 1\n            \
    \    level++\n                in_group[level] = false\n            }\n       \
    \ case \")\":\n            if in_group[level] {\n                result[level]\
    \ = -1\n                level--\n                in_group[level] = false\n   \
    \         } else {\n                result[level] = 0\n                in_group[level]\
    \ = true\n            }\n        case \"(\":\n            result[level] = 1\n\
    \            level++\n            in_group[level] = true\n        case \")\":\n\
    \            if in_group[level] {\n                result[level] = 0\n       \
    \         in_group[level] = false\n            } else {\n                result[level]\
    \ = -1\n                level--\n            }\n        default:\n           \
    \ result[level] += 1\n            level--\n        }\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9lrtz1w4.swift:17:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in paren_string.characters {\n           \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp9lrtz1w4.swift:21:18: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n            level--\n                 ^~\n/tmp/tmp9lrtz1w4.swift:24:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      level++\n                     ^~\n/tmp/tmp9lrtz1w4.swift:30:22: error:\
    \ cannot find operator '--' in scope; did you mean '-= 1'?\n                level--\n\
    \                     ^~\n/tmp/tmp9lrtz1w4.swift:38:18: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            level++\n                 ^~\n\
    /tmp/tmp9lrtz1w4.swift:46:22: error: cannot find operator '--' in scope; did you\
    \ mean '-= 1'?\n                level--\n                     ^~\n/tmp/tmp9lrtz1w4.swift:50:18:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  level--\n                 ^~\n/tmp/tmp9lrtz1w4.swift:27:14: warning: literal\
    \ value is already handled by previous pattern; consider removing it\n       \
    \ case \")\":\n             ^~~\n/tmp/tmp9lrtz1w4.swift:19:14: note: first occurrence\
    \ of identical literal pattern is here\n        case \")\":\n             ^~~\n\
    /tmp/tmp9lrtz1w4.swift:40:14: warning: literal value is already handled by previous\
    \ pattern; consider removing it\n        case \")\":\n             ^~~\n/tmp/tmp9lrtz1w4.swift:19:14:\
    \ note: first occurrence of identical literal pattern is here\n        case \"\
    )\":\n             ^~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_nesting: Int = 0\n    var nesting: Int = 0\n\
    \    var level_star: Int = 0\n    var paren_counter: Int = 0\n    for index in\
    \ 0..<paren_string.count {\n        if paren_counter == 0 {\n            level_star\
    \ = paren_string[index]\n        } else {\n            if paren_counter == level_star\
    \ {\n                paren_counter++\n            } else {\n                paren_counter\
    \ = 0\n                level_star = paren_string[index]\n            }\n     \
    \   }\n        if level_star != 0 {\n            nesting++\n            if nesting\
    \ > max_nesting {\n                max_nesting = nesting\n            }\n    \
    \    }\n    }\n    return Array(repeating: max_nesting, count: level_star)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpr64_a4zf.swift:14:38: error: cannot assign value of type 'Character'\
    \ to type 'Int'\n            level_star = paren_string[index]\n              \
    \           ~~~~~~~~~~~~^~~~~~~\n/tmp/tmpr64_a4zf.swift:17:30: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                paren_counter++\n\
    \                             ^~\n/tmp/tmpr64_a4zf.swift:20:42: error: cannot\
    \ assign value of type 'Character' to type 'Int'\n                level_star =\
    \ paren_string[index]\n                             ~~~~~~~~~~~~^~~~~~~\n/tmp/tmpr64_a4zf.swift:24:20:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  nesting++\n                   ^~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // The string to be parsed contains parenthetical groups\
    \ and may contain nested parenthesis.\n    // Each parenthetical group may contain\
    \ nested parentheses within it,\n    // and these nested parentheses need to be\
    \ parsed for their level of nesting.\n    // For example:\n    //\n    //    \
    \ ( (( ()() )))\n    //\n    // The first parenthesis ( ( ) ) contains nested\
    \ parentheses within it, and\n    // the nested parentheses need to be parsed\
    \ for the level of nesting.\n    //\n    // Therefore, start by parsing the string\
    \ by parsing all parentheses.\n    // If the string contains a nested parentheses,\
    \ then the nested parentheses\n    // need to be parsed again to determine the\
    \ level of nesting.\n    var paren_level = 0\n    let paren_str = paren_string.characters()\n\
    \    let paren_arr: [String] = []\n\n    // The function will return an array\
    \ of integers\n    // indicating the level of nesting of each parenthetical group.\n\
    \    //\n    // Ex: ( (()) ) has two levels of nesting, while (( )) has just one\
    \ level of nesting.\n    let nested = paren_str.enumerate().map { i, char in\n\
    \        // Look at each character in the parenthetical group.\n        // If\
    \ the character is a parenthesis, increment the paren_level\n        // by 1.\n\
    \        if char == \"(\" {\n            paren_arr.append(paren_level)\n     \
    \       paren_level += 1\n        } else {\n            paren_arr.append(paren_level)\n\
    \            paren_level -= 1\n        }\n\n        // Return the parenthetical\
    \ group.\n        return String(char)\n    }\n\n    return nested\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpa1zd7gbd.swift:22:34: error: cannot call value of non-function\
    \ type 'String'\n    let paren_str = paren_string.characters()\n             \
    \                    ^         ~~\n                                          \
    \ \n/tmp/tmpa1zd7gbd.swift:34:23: error: cannot use mutating member on immutable\
    \ value: 'paren_arr' is a 'let' constant\n            paren_arr.append(paren_level)\n\
    \            ~~~~~~~~~ ^\n/tmp/tmpa1zd7gbd.swift:23:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let paren_arr: [String] = []\n    ^~~\n    var\n/tmp/tmpa1zd7gbd.swift:34:30:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String'\n\
    \            paren_arr.append(paren_level)\n                             ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var result: [Int] = []\n    var index = 0\n    var level\
    \ = 0\n    var openingParenCount = 0\n    var closingParenCount = 0\n\n    while\
    \ index < paren_string.characters.count {\n        if paren_string.characters[index]\
    \ == ')' {\n            closingParenCount++\n        } else {\n            openingParenCount++\n\
    \        }\n        level++\n\n        if level == 1 && openingParenCount == closingParenCount\
    \ {\n            result.append(level)\n        }\n\n        index++\n    }\n\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp3exeun1g.swift:15:46: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string.characters[index] == ')' {\n             \
    \                                ^~~\n                                       \
    \      \")\"\n/tmp/tmp3exeun1g.swift:14:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    while index < paren_string.characters.count\
    \ {\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3exeun1g.swift:15:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ paren_string.characters[index] == ')' {\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3exeun1g.swift:15:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        if paren_string.characters[index]\
    \ == ')' {\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3exeun1g.swift:16:30: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            closingParenCount++\n          \
    \                   ^~\n/tmp/tmp3exeun1g.swift:18:30: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            openingParenCount++\n     \
    \                        ^~\n/tmp/tmp3exeun1g.swift:20:14: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n        level++\n            \
    \ ^~\n/tmp/tmp3exeun1g.swift:26:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var deepest_level = 0\n    var group_size\
    \ = 0\n    var group_level = [Int]()\n    var current_count = 0\n    let num_levels\
    \ = paren_string.count\n\n    guard num_levels > 0 else { return [] }\n\n    let\
    \ paren_chars = paren_string.characters\n    var paren_char_i = 0\n\n    while\
    \ true {\n        let paren_char = paren_chars[paren_char_i]\n        switch paren_char\
    \ {\n        case \"(\":\n            group_level.append(level)\n            group_size\
    \ += 1\n            if level == deepest_level {\n                current_count\
    \ += group_size\n                group_size = 0\n            }\n            level\
    \ += 1\n        case \"(\":\n            group_level.append(level)\n         \
    \   group_size += 1\n            if level == deepest_level {\n               \
    \ current_count += group_size\n                group_size = 0\n            }\n\
    \            level += 1\n        case \"(\":\n            if level == deepest_level\
    \ {\n                group_size = group_level[group_level.count - 1] + 1\n   \
    \             group_level.insert(level - 1, 0)\n                current_count\
    \ += group_size\n            }\n            level += 1\n        case \"(\":\n\
    \            if level > deepest_level {\n                deepest_level = level\n\
    \            }\n            group_level[group_level.count - 1] += group_size +\
    \ 1\n            group_size = 0\n            level -= 1\n        case \"(\":\n\
    \            if level > deepest_level {\n                deepest_level = level\n\
    \            }\n            group_size = 0\n            level -= 1\n        case\
    \ \"(\":\n            if level == deepest_level {\n                group_size\
    \ = group_level[group_level.count - 1] + 1\n                group_level.insert(level\
    \ - 1, 0)\n                current_count += group_size\n            }\n      \
    \      level -= 1\n        case \"(\":\n            group_level[group_level.count\
    \ - 1] += group_size + 1\n            group_size = 0\n            level -= 1\n\
    \        case \"(\":\n            group_size = 0\n            level -= 1\n   \
    \     case \"(\":\n            if level > deepest_level {\n                deepest_level\
    \ = level\n            }\n            level -= 1\n        default:\n         \
    \   if level == deepest_level {\n                group_size = group_level[group_level.count\
    \ - 1] + 1\n                group_level.insert(level - 1, 0)\n               \
    \ current_count += group_size\n            }\n            level -= 1\n       \
    \ }\n        paren_char_i += 1\n        if paren_char_i >= paren_chars.endIndex\
    \ {\n            break\n        }\n    }\n\n    return group_level.dropLast()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpirx1esiz.swift:17:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let paren_chars = paren_string.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpirx1esiz.swift:21:26: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ paren_char = paren_chars[paren_char_i]\n                         ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpirx1esiz.swift:42:29:\
    \ error: no exact matches in call to instance method 'insert'\n              \
    \  group_level.insert(level - 1, 0)\n                            ^\nSwift.Array:11:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Element, at\
    \ i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n/tmp/tmpirx1esiz.swift:62:29:\
    \ error: no exact matches in call to instance method 'insert'\n              \
    \  group_level.insert(level - 1, 0)\n                            ^\nSwift.Array:11:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Element, at\
    \ i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n/tmp/tmpirx1esiz.swift:81:29:\
    \ error: no exact matches in call to instance method "
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level = 0\n    var parentheses\
    \ = 0\n    var count = 0\n    for letter in paren_string.unicodeScalars {\n  \
    \      switch letter {\n        case .OpenParen:\n            parentheses += 1\n\
    \        case .CloseParen:\n            parentheses -= 1\n            if parentheses\
    \ == 0 {\n                levels[level] = count\n                level++\n   \
    \         }\n            count = 0\n        }\n        count += 1\n    }\n   \
    \ return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdy269ksg.swift:14:15: error: type 'Unicode.Scalar' has no member\
    \ 'OpenParen'\n        case .OpenParen:\n             ~^~~~~~~~~\n/tmp/tmpdy269ksg.swift:16:15:\
    \ error: type 'Unicode.Scalar' has no member 'CloseParen'\n        case .CloseParen:\n\
    \             ~^~~~~~~~~~\n/tmp/tmpdy269ksg.swift:20:22: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                level++\n             \
    \        ^~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // \"()\" or \"()()\" or \"(())\" or \"(()())\"\n  \
    \  let regex_parens = NSRegularExpression.escapedPattern(for: \"[(]\\\\(([()]|\\\
    \\(([()]|\\\\(([()]*\\\\))*\\\\))*\\\\)\\\\)\")\n\n    let regex = NSRegularExpression(pattern:\
    \ regex_parens, options: .caseInsensitive)\n    let matches = regex.matches(in:\
    \ paren_string, range: NSMakeRange(0, paren_string.characters.count))\n    let\
    \ group_counts = matches.map { $0.numberOfRanges }\n    let group_counts_sorted\
    \ = group_counts.sorted()\n\n    let max_count = group_counts_sorted.last!\n \
    \   var counts = [Int]()\n    for i in 0..<max_count {\n        counts.append(0)\n\
    \    }\n    for i in 0..<group_counts_sorted.count {\n        if group_counts_sorted[i]\
    \ == max_count {\n            counts[group_counts_sorted[i]]++\n        }\n  \
    \  }\n    return counts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpe1j8ro11.swift:9:24: error: cannot find 'NSRegularExpression' in\
    \ scope\n    let regex_parens = NSRegularExpression.escapedPattern(for: \"[(]\\\
    \\(([()]|\\\\(([()]|\\\\(([()]*\\\\))*\\\\))*\\\\)\\\\)\")\n                 \
    \      ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpe1j8ro11.swift:11:17: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = NSRegularExpression(pattern: regex_parens, options:\
    \ .caseInsensitive)\n                ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpe1j8ro11.swift:11:70:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \    let regex = NSRegularExpression(pattern: regex_parens, options: .caseInsensitive)\n\
    \                                                                    ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpe1j8ro11.swift:12:58: error: cannot find 'NSMakeRange' in scope\n    let\
    \ matches = regex.matches(in: paren_string, range: NSMakeRange(0, paren_string.characters.count))\n\
    \                                                         ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    \n    // convert string to array\n    var paren_count\
    \ = [String]()\n    paren_string.split(\" \").forEach {\n        paren_count =\
    \ $0.split(\"\").map { Int($0) }.max().unwrap() }\n    return paren_count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpt8x1xyq4.swift:11:24: error: missing argument label 'separator:'\
    \ in call\n    paren_string.split(\" \").forEach {\n                       ^\n\
    \                       separator: \n/tmp/tmpt8x1xyq4.swift:12:32: error: missing\
    \ argument label 'separator:' in call\n        paren_count = $0.split(\"\").map\
    \ { Int($0) }.max().unwrap() }\n                               ^\n           \
    \                    separator: \n/tmp/tmpt8x1xyq4.swift:12:42: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n        paren_count\
    \ = $0.split(\"\").map { Int($0) }.max().unwrap() }\n                        \
    \                 ^\n/tmp/tmpt8x1xyq4.swift:12:42: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        paren_count\
    \ = $0.split(\"\").map { Int($0) }.max().unwrap() }\n                        \
    \                 ^\n                                                 ?? <#default\
    \ value#>\n/tmp/tmpt8x1xyq4.swift:12:42: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        paren_count = $0.split(\"\
    \").map { Int($0) }.max().unwrap() }\n                                       \
    \  ^\n                                                !\n/tmp/tmpt8x1xyq4.swift:12:58:\
    \ error: value of type 'Int?' has no member 'unwrap'\n        paren_count = $0.split(\"\
    \").map { Int($0) }.max().unwrap() }\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpt8x1xyq4.swift:13:12: error: cannot convert return expression\
    \ of type '[String]' to return type '[Int]'\n    return paren_count\n        \
    \   ^\n/tmp/tmpt8x1xyq4.swift:13:12: note: arguments to generic parameter 'Element'\
    \ ('String' and 'Int') are expected to be equal\n    return paren_count\n    \
    \       ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels: [Int] = []\n    var num_groups = 1\n   \
    \ for ch in paren_string.unicodeScalars {\n        switch ch {\n        case .OpenParen,\
    \ .CloseParen:\n            levels.append(0)\n        case .End:\n           \
    \ return levels\n        default:\n            levels[num_groups - 1] = levels[num_groups\
    \ - 1] + 1\n        }\n        num_groups = num_groups * 10 + levels[num_groups\
    \ - 1]\n    }\n    if num_groups == 1 {\n        return nil\n    }\n    return\
    \ levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpwayexxl0.swift:12:15: error: type 'Unicode.Scalar' has no member\
    \ 'OpenParen'\n        case .OpenParen, .CloseParen:\n             ~^~~~~~~~~\n\
    /tmp/tmpwayexxl0.swift:12:27: error: type 'Unicode.Scalar' has no member 'CloseParen'\n\
    \        case .OpenParen, .CloseParen:\n                         ~^~~~~~~~~~\n\
    /tmp/tmpwayexxl0.swift:14:15: error: type 'Unicode.Scalar' has no member 'End'\n\
    \        case .End:\n             ~^~~\n/tmp/tmpwayexxl0.swift:22:16: error: 'nil'\
    \ is incompatible with return type '[Int]'\n        return nil\n             \
    \  ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var paren_level = [Int]()\n    for paren_char in paren_string.unicodeScalars\
    \ {\n        if paren_char == '(' {\n            paren_level.insert(paren_level.count,\
    \ paren_level.count)\n        } else if paren_char == ')' {\n            paren_level.removeLast()\n\
    \        }\n    }\n    return paren_level\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpjfkglv7k.swift:10:26: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_char == '(' {\n                         ^~~\n   \
    \                      \"(\"\n/tmp/tmpjfkglv7k.swift:12:33: error: single-quoted\
    \ string literal found, use '\"'\n        } else if paren_char == ')' {\n    \
    \                            ^~~\n                                \")\"\n/tmp/tmpjfkglv7k.swift:11:25:\
    \ error: no exact matches in call to instance method 'insert'\n            paren_level.insert(paren_level.count,\
    \ paren_level.count)\n                        ^\nSwift.Array:11:37: note: incorrect\
    \ labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect\
    \ labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Self.Element, at i: Self.Index)\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    return parse_nested_parens_internal(paren_string, paren_string.split(\"\
    \ \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdvyh9y8_.swift:8:12: error: cannot find 'parse_nested_parens_internal'\
    \ in scope\n    return parse_nested_parens_internal(paren_string, paren_string.split(\"\
    \ \"))\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdvyh9y8_.swift:8:68:\
    \ error: no exact matches in call to instance method 'split'\n    return parse_nested_parens_internal(paren_string,\
    \ paren_string.split(\" \"))\n                                               \
    \                    ^\n/tmp/tmpdvyh9y8_.swift:8:68: note: found candidate with\
    \ type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]' (aka '(Character,\
    \ Int, Bool) -> Array<ArraySlice<Character>>')\n    return parse_nested_parens_internal(paren_string,\
    \ paren_string.split(\" \"))\n                                               \
    \                    ^\n/tmp/tmpdvyh9y8_.swift:8:68: note: found candidate with\
    \ type '(String.Element, Int, Bool) -> [String.SubSequence]' (aka '(Character,\
    \ Int, Bool) -> Array<Substring>')\n    return parse_nested_parens_internal(paren_string,\
    \ paren_string.split(\" \"))\n                                               \
    \                    ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Initialize all the nesting levels seen so far.\n\
    \    var max_level = [Int]()\n    // Iterate through the string and append the\
    \ amount of open parenthesis\n    // to the current level.\n    for level := 0;\
    \ level < paren_string.count; level++ {\n        // The current level is either\
    \ the previous level or 1 if\n        // this is the first level.\n        var\
    \ current_level = level > 0 ? max_level[level-1] + 1 : 1\n        // Append the\
    \ level to the max level and update it.\n        max_level[level] = current_level\n\
    \    }\n    // Return all the max levels from top to bottom.\n    return max_level\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpx3itje8e.swift:12:16: error: expected type\n    for level := 0;\
    \ level < paren_string.count; level++ {\n               ^\n                <#type#>\n\
    /tmp/tmpx3itje8e.swift:12:16: error: expected 'in' after for-each pattern\n  \
    \  for level := 0; level < paren_string.count; level++ {\n               ^\n/tmp/tmpx3itje8e.swift:12:16:\
    \ error: expected Sequence expression for for-each loop\n    for level := 0; level\
    \ < paren_string.count; level++ {\n               ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    \n    var level = 0\n    var output_level = 0\n    var\
    \ output: [Int] = []\n    \n    for ch in paren_string.unicodeScalars {\n    \
    \    \n        // find matching closing parenthesis\n        var closing = paren_string.unicodeScalars.filter({\
    \ $0 == ch }).first\n        var closing_index = 0\n        \n        // find\
    \ matching opening parenthesis\n        var opening = paren_string.unicodeScalars.filter({\
    \ $0 == paren_string.unicodeScalars[closing_index] }).last\n        opening_index\
    \ = 1\n        \n        while opening_index < paren_string.unicodeScalars.count\
    \ {\n            \n            // check levels\n            level++\n        \
    \    \n            // find matching closing parenthesis\n            closing =\
    \ paren_string.unicodeScalars.filter({ $0 == paren_string.unicodeScalars[closing_index]\
    \ }).first\n            closing_index++\n            \n            if level ==\
    \ output_level {\n                \n                output.append(level)\n   \
    \             output_level++\n                \n                level = 0\n  \
    \          }\n            \n            if closing != nil {\n                level--\n\
    \            }\n            \n            opening = paren_string.unicodeScalars.filter({\
    \ $0 == paren_string.unicodeScalars[opening_index] }).last\n            opening_index++\n\
    \        }\n    }\n    \n    return output\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpeolgl_hn.swift:20:94: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.UnicodeScalarView.Index' (aka 'String.Index')\n\
    \        var opening = paren_string.unicodeScalars.filter({ $0 == paren_string.unicodeScalars[closing_index]\
    \ }).last\n                                                                  \
    \                           ^\n/tmp/tmpeolgl_hn.swift:21:9: error: cannot find\
    \ 'opening_index' in scope\n        opening_index = 1\n        ^~~~~~~~~~~~~\n\
    /tmp/tmpeolgl_hn.swift:23:15: error: cannot find 'opening_index' in scope\n  \
    \      while opening_index < paren_string.unicodeScalars.count {\n           \
    \   ^~~~~~~~~~~~~\n/tmp/tmpeolgl_hn.swift:26:18: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            level++\n                 ^~\n/tmp/tmpeolgl_hn.swift:29:94:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.UnicodeScalarView.Index'\
    \ (aka 'String.Index')\n            closing = paren_string.unicodeScalars.filter({\
    \ $0 == paren_string.unicodeScalars[closing_index] }).first\n                \
    \                                                                            \
    \ ^\n/tmp/tmpeolgl_hn.swift:30:26: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            closing_index++\n                        \
    \ ^~\n/tmp/tmpeolgl_hn.swift:35:29: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                output_level++\n                     \
    \       ^~\n/tmp/tmpeolgl_hn.swift:41:22: error: cannot find operator '--' in\
    \ scope; did you mean '-= 1'?\n                level--\n                     ^~\n\
    /tmp/tmpeolgl_hn.swift:44:94: error: cannot find 'opening_index' in scope\n  \
    \          opening = paren_string.unicodeScalars.filter({ $0 == paren_string.unicodeScalars[opening_index]\
    \ }).last\n                                                                  \
    \                           ^~~~~~~~~~~~~\n/tmp/tmpeolgl_hn.swift:45:26: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            opening_index++\n\
    \                         ^~\n/tm"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Get all groups of the paren_string.\n    var groups\
    \ = paren_string.characters.split(char: \" \")\n\n    // Go through all the groups\
    \ and find the maximum nesting.\n    var max = 0\n    for index in 0..<groups.count\
    \ {\n        let group = groups[index]\n        let nesting = parse_parens_group(group:\
    \ group)\n        if nesting > max {\n            max = nesting\n        }\n \
    \   }\n\n    // Return the maximum nesting.\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp80a2kb5k.swift:9:42: error: no exact matches in call to instance\
    \ method 'split'\n    var groups = paren_string.characters.split(char: \" \")\n\
    \                                         ^\n/tmp/tmp80a2kb5k.swift:9:42: note:\
    \ candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    var groups = paren_string.characters.split(char:\
    \ \" \")\n                                         ^\n/tmp/tmp80a2kb5k.swift:9:42:\
    \ note: candidate has partially matching parameter list (maxSplits: Int, omittingEmptySubsequences:\
    \ Bool, whereSeparator: (String.Element) throws -> Bool)\n    var groups = paren_string.characters.split(char:\
    \ \" \")\n                                         ^\n/tmp/tmp80a2kb5k.swift:9:42:\
    \ note: candidate has partially matching parameter list (maxSplits: Int, omittingEmptySubsequences:\
    \ Bool, whereSeparator: (String.Element) throws -> Bool)\n    var groups = paren_string.characters.split(char:\
    \ \" \")\n                                         ^\n/tmp/tmp80a2kb5k.swift:9:42:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    var groups = paren_string.characters.split(char:\
    \ \" \")\n                                         ^\n/tmp/tmp80a2kb5k.swift:22:12:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return max\n           ^~~\n/tmp/tmp80a2kb5k.swift:15:23: error: cannot find\
    \ 'parse_parens_group' in scope\n        let nesting = parse_parens_group(group:\
    \ group)\n                      ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let split_string = paren_string.components(separatedBy:\
    \ \" \")\n    var paren_level = 1\n    var max_level = 0\n    for paren in split_string\
    \ {\n        let paren_len = paren.count\n        if paren_len > 1 {\n       \
    \     let level: Int = paren_len\n            if level > max_level {\n       \
    \         max_level = level\n            }\n            paren_level += level\n\
    \        }\n    }\n    return [paren_level, max_level]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0hog_f8a.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    let split_string = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    \n    // Parsing and preparing data for further operations.\n\
    \    // This struct stores the information about a group and the list of levels\
    \ of nesting within it.\n    let group_data: [(group: [String], levels: Int)]\
    \ = [\n        (group: [\"\"], levels: 0)\n    ]\n    \n    var group_index =\
    \ 0\n    var level_of_nesting = 0\n    var curr_group = \"\"\n    var nesting_counter\
    \ = 1\n    \n    for character in paren_string.characters {\n        if character\
    \ == \"(\" {\n            level_of_nesting += 1\n            curr_group += character\n\
    \        }\n        \n        if character == \")\" {\n            level_of_nesting\
    \ -= 1\n            \n            if level_of_nesting == 0 && curr_group != \"\
    \" {\n                group_data.append((group: [curr_group], levels: level_of_nesting))\n\
    \                curr_group = \"\"\n                nesting_counter = 1\n    \
    \        } else {\n                curr_group += character\n            }\n  \
    \      }\n        \n        if character == \" \" {\n            if level_of_nesting\
    \ > 0 {\n                group_data.append((group: [curr_group], levels: level_of_nesting))\n\
    \                curr_group = \"\"\n                nesting_counter = 1\n    \
    \        } else {\n                curr_group += character\n            }\n  \
    \      }\n    }\n    \n    return group_data.map { $0.levels }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpjdlrz9js.swift:20:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in paren_string.characters {\n      \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjdlrz9js.swift:23:27: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            curr_group\
    \ += character\n                          ^\n/tmp/tmpjdlrz9js.swift:30:28: error:\
    \ cannot use mutating member on immutable value: 'group_data' is a 'let' constant\n\
    \                group_data.append((group: [curr_group], levels: level_of_nesting))\n\
    \                ~~~~~~~~~~ ^\n/tmp/tmpjdlrz9js.swift:11:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let group_data: [(group: [String], levels:\
    \ Int)] = [\n    ^~~\n    var\n/tmp/tmpjdlrz9js.swift:34:31: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   curr_group += character\n                              ^\n/tmp/tmpjdlrz9js.swift:40:28:\
    \ error: cannot use mutating member on immutable value: 'group_data' is a 'let'\
    \ constant\n                group_data.append((group: [curr_group], levels: level_of_nesting))\n\
    \                ~~~~~~~~~~ ^\n/tmp/tmpjdlrz9js.swift:11:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let group_data: [(group: [String], levels:\
    \ Int)] = [\n    ^~~\n    var\n/tmp/tmpjdlrz9js.swift:44:31: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   curr_group += character\n                              ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tdepths := [Int](count: paren_string.count + 1, repeatedValue:\
    \ 0)\n\tvar max_depth Int = 0\n\tfor _, c := range paren_string.unicodeScalars\
    \ {\n\t\tif paren_string[c] == '(' {\n\t\t\tdepths[paren_string[c]] += 1\n\t\t\
    \tif depths[paren_string[c]] > max_depth { max_depth = depths[paren_string[c]]\
    \ }\n\t\t} else if paren_string[c] == ')' {\n\t\t\tdepths[paren_string[c]] -=\
    \ 1\n\t\t}\n\t}\n\treturn depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpq3n6_3k4.swift:8:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        depths := [Int](count: paren_string.count + 1,\
    \ repeatedValue: 0)\n              ^\n              ;\n/tmp/tmpq3n6_3k4.swift:8:9:\
    \ error: expected expression\n        depths := [Int](count: paren_string.count\
    \ + 1, repeatedValue: 0)\n               ^\n/tmp/tmpq3n6_3k4.swift:9:16: error:\
    \ found an unexpected second identifier in variable declaration; is there an accidental\
    \ break?\n        var max_depth Int = 0\n                      ^\n/tmp/tmpq3n6_3k4.swift:9:16:\
    \ note: join the identifiers together\n        var max_depth Int = 0\n       \
    \     ~~~~~~~~~~^~~\n            max_depthInt\n/tmp/tmpq3n6_3k4.swift:10:7: error:\
    \ expected 'in' after for-each pattern\n        for _, c := range paren_string.unicodeScalars\
    \ {\n             ^\n/tmp/tmpq3n6_3k4.swift:10:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, c := range paren_string.unicodeScalars {\n\
    \             ^\n/tmp/tmpq3n6_3k4.swift:11:25: error: single-quoted string literal\
    \ found, use '\"'\n                if paren_string[c] == '(' {\n             \
    \                         ^~~\n                                      \"(\"\n/tmp/tmpq3n6_3k4.swift:14:32:\
    \ error: single-quoted string literal found, use '\"'\n                } else\
    \ if paren_string[c] == ')' {\n                                             ^~~\n\
    \                                             \")\"\n/tmp/tmpq3n6_3k4.swift:8:2:\
    \ error: cannot find 'depths' in scope\n        depths := [Int](count: paren_string.count\
    \ + 1, repeatedValue: 0)\n        ^~~~~~\n/tmp/tmpq3n6_3k4.swift:18:9: error:\
    \ cannot find 'depths' in scope\n        return depths\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max = [Int]()\n    for paren in paren_string.components(separatedBy:\
    \ \" \"){\n        let parens = paren.characters.split(on: CharacterSet.init(charactersIn:\
    \ \"()\"))\n        if parens.count == 0 {\n            continue\n        }\n\
    \        let level = parens.count\n        if level > max[level.count - 1]{\n\
    \            max[level.count - 1] = level\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8w87wd7v.swift:9:31: error: value of type 'String' has no member\
    \ 'components'\n    for paren in paren_string.components(separatedBy: \" \"){\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp8w87wd7v.swift:10:49: error:\
    \ cannot find 'CharacterSet' in scope\n        let parens = paren.characters.split(on:\
    \ CharacterSet.init(charactersIn: \"()\"))\n                                 \
    \               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var output_level = 1\n    var nesting_level = 1\n  \
    \  for parens in paren_string.split(\" \") {\n        if parens != \"\" {\n  \
    \          if parens == \"(\" && nesting_level > 0 {\n                output_level++\n\
    \                nesting_level++\n            } else if parens == \"(\" && nesting_level\
    \ == 0 {\n                output_level++\n            } else if parens == \")\"\
    \ && nesting_level > 0 {\n                output_level--\n                nesting_level--\n\
    \            } else if parens == \")\" && nesting_level == 0 {\n             \
    \   output_level--\n            }\n        }\n    }\n\n    return Array(output_level..<output_level\
    \ + 1).map {\n        nesting_level - $0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpy0_z8jpf.swift:10:32: error: no exact matches in call to instance\
    \ method 'split'\n    for parens in paren_string.split(\" \") {\n            \
    \                   ^\nSwift.Sequence:2:40: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var depth = 0\n    for index in paren_string.characters\
    \ {\n        if index == paren_string.characters.last && paren_string[index] ==\
    \ '(' {\n            if level < depth {\n                depth += 1\n        \
    \    }\n        } else if index == paren_string.characters.first && paren_string[index]\
    \ == ')' {\n            if level > 0 {\n                depth -= 1\n         \
    \   }\n        } else {\n            if level == 0 {\n                level +=\
    \ 1\n            }\n        }\n    }\n    return [level]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9ow9xey_.swift:11:76: error: single-quoted string literal found,\
    \ use '\"'\n        if index == paren_string.characters.last && paren_string[index]\
    \ == '(' {\n                                                                 \
    \          ^~~\n                                                             \
    \              \"(\"\n/tmp/tmp9ow9xey_.swift:15:84: error: single-quoted string\
    \ literal found, use '\"'\n        } else if index == paren_string.characters.first\
    \ && paren_string[index] == ')' {\n                                          \
    \                                         ^~~\n                              \
    \                                                     \")\"\n/tmp/tmp9ow9xey_.swift:10:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    for index\
    \ in paren_string.characters {\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp9ow9xey_.swift:11:66: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Range<String.Index>'\n\
    \        if index == paren_string.characters.last && paren_string[index] == '('\
    \ {\n                                                                 ^\n/tmp/tmp9ow9xey_.swift:15:74:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Range<String.Index>'\n\
    \        } else if index == paren_string.characters.first && paren_string[index]\
    \ == ')' {\n                                                                 \
    \        ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // TODO: replace this with something that handles arbitrary\
    \ nesting depth :)\n    return [1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: Exception
  stderr: 'tmpmr8lqxwb/tmpmr8lqxwb.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8178007c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8177cfeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8177cfe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8177cfd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmr8lqxwb                        0x000055904b21b43e <unavailable> + 5182

    5    libc.so.6                          0x00002b81781f3460 __libc_start_main +
    245

    6    tmpmr8lqxwb                        0x000055904b21b059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level_groups = [0]\n    var level = 0\n    for\
    \ c in paren_string.characters {\n        switch c {\n        case \")\":\n  \
    \          level -= 1\n            if level == -1 {\n                max_level_groups.append(level\
    \ + 1)\n                level = 0\n            } else {\n                max_level_groups.append(level)\n\
    \            }\n        case \"(\":\n            level += 1\n            if level\
    \ == 0 {\n                max_level_groups.append(level)\n                level\
    \ = 0\n            } else {\n                max_level_groups.append(level)\n\
    \            }\n        default:\n            break\n        }\n    }\n    return\
    \ max_level_groups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0qlipn1b.swift:10:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in paren_string.characters {\n              \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n  var max_depth = 0\n  var levels = [Int]()\n\n  for parens\
    \ in paren_string.split(\" \") {\n    if parens.contains(\"(\") {\n      levels.append(0)\n\
    \    }\n\n    parens = parens.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    if parens.contains(\")\") {\n      levels = levels.dropLast()\n      if max_depth\
    \ < levels.last {\n        max_depth = levels.last\n      }\n    }\n  }\n\n  return\
    \ max_depth\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpxodeue3o.swift:11:30: error: no exact matches in call to instance\
    \ method 'split'\n  for parens in paren_string.split(\" \") {\n              \
    \               ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n/tmp/tmpxodeue3o.swift:25:10: error:\
    \ cannot convert return expression of type 'Int' to return type '[Int]'\n  return\
    \ max_depth\n         ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tlet parens_indexes = paren_string.characters.enumerated().filter{\
    \ $0.element.isPunctuation }\n\tlet max_level = 0\n\tfor index in parens_indexes\
    \ {\n\t\tlet parens = parens_indexes[index].element == \"(\" ? 1 : 0\n\t\tlet\
    \ level = (parens_indexes[index].element == \"(\" ? 1 : 0) + (parens_indexes[index].element\
    \ == \"(\" ? 1 : 0)\n\t\tif level > max_level {\n\t\t\tmax_level = level\n\t\t\
    }\n\t}\n\treturn Array(Set(paren_string.characters.filter{ $0 == \"(\" || $0 ==\
    \ \")\" }).sorted())\n\t\t.enumerated()\n\t\t.map{ [$0.element, Int($0.offset\
    \ / paren_string.count)] }\n\t\t.filter{ $0.element == \"(\" || $0.element ==\
    \ \")\" }\n\t\t.map{ $0.element == \"(\" ? 1 : 0 }\n\t\t.reduce(0, +)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi6j_jn9e.swift:8:36: error: 'characters' is unavailable: Please\
    \ use String directly\n        let parens_indexes = paren_string.characters.enumerated().filter{\
    \ $0.element.isPunctuation }\n                                          ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpi6j_jn9e.swift:11:31:\
    \ error: cannot convert value of type 'EnumeratedSequence<String>.Iterator.Element'\
    \ (aka '(offset: Int, element: Character)') to expected argument type 'Int'\n\
    \                let parens = parens_indexes[index].element == \"(\" ? 1 : 0\n\
    \                                            ^\n/tmp/tmpi6j_jn9e.swift:12:31:\
    \ error: cannot convert value of type 'EnumeratedSequence<String>.Iterator.Element'\
    \ (aka '(offset: Int, element: Character)') to expected argument type 'Int'\n\
    \                let level = (parens_indexes[index].element == \"(\" ? 1 : 0)\
    \ + (parens_indexes[index].element == \"(\" ? 1 : 0)\n                       \
    \                     ^\n/tmp/tmpi6j_jn9e.swift:12:80: error: cannot convert value\
    \ of type 'EnumeratedSequence<String>.Iterator.Element' (aka '(offset: Int, element:\
    \ Character)') to expected argument type 'Int'\n                let level = (parens_indexes[index].element\
    \ == \"(\" ? 1 : 0) + (parens_indexes[index].element == \"(\" ? 1 : 0)\n     \
    \                                                                            \
    \            ^\n/tmp/tmpi6j_jn9e.swift:14:4: error: cannot assign to value: 'max_level'\
    \ is a 'let' constant\n                        max_level = level\n           \
    \             ^~~~~~~~~\n/tmp/tmpi6j_jn9e.swift:9:2: note: change 'let' to 'var'\
    \ to make it mutable\n        let max_level = 0\n        ^~~\n        var\n/tmp/tmpi6j_jn9e.swift:17:9:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n        return\
    \ Array(Set(paren_string.characters.filter{ $0 == \"(\" || $0 == \")\" }).sorted())\n\
    \               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660009738
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var maxNesting = [Int](repeating: -1, count: paren_string.count)\n\
    \    for index in stride(from: 0, to: paren_string.count, by: 1) {\n        let\
    \ char = paren_string[index]\n        switch char {\n        case \"(\":\n   \
    \         maxNesting[index] = maxNesting[index-1] + 1\n        case \"(\":\n \
    \           checkNesting(maxNesting: &maxNesting, index: index)\n        default:\n\
    \            break\n        }\n    }\n    return maxNesting\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp13t14wli.swift:10:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = paren_string[index]\n                   ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp13t14wli.swift:15:13:\
    \ error: cannot find 'checkNesting' in scope\n            checkNesting(maxNesting:\
    \ &maxNesting, index: index)\n            ^~~~~~~~~~~~\n/tmp/tmp13t14wli.swift:14:14:\
    \ warning: literal value is already handled by previous pattern; consider removing\
    \ it\n        case \"(\":\n             ^~~\n/tmp/tmp13t14wli.swift:12:14: note:\
    \ first occurrence of identical literal pattern is here\n        case \"(\":\n\
    \             ^~~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels: [Int] = [0]\n    var n = 1\n    var i: Int\
    \ = 0\n    for char in paren_string.characters {\n        i += 1\n        if char\
    \ == \"(\" {\n            levels.append(n)\n            n++\n        } else if\
    \ char == \")\" {\n            levels.pop()\n            n--\n        }\n    }\n\
    \    return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi2znc95r.swift:11:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in paren_string.characters {\n           \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpi2znc95r.swift:15:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            n++\n             ^~\n/tmp/tmpi2znc95r.swift:17:20:\
    \ error: value of type '[Int]' has no member 'pop'\n            levels.pop()\n\
    \            ~~~~~~ ^~~\n/tmp/tmpi2znc95r.swift:18:14: error: cannot find operator\
    \ '--' in scope; did you mean '-= 1'?\n            n--\n             ^~\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tvar levels: [Int] = Array(repeating: 0, count: paren_string.count+1)\n\
    \tlevels[0] = 0\n\tlevels[paren_string.count] = 0\n\n\tfor (index, char) in paren_string.characters.enumerated()\
    \ {\n\t\tlet current_level = levels[index + 1]\n\n\t\tswitch char {\n\t\tcase\
    \ '(':\n\t\t\tlevels[index] += 1\n\t\tcase '[':\n\t\t\tlevels[index] += 1\n\t\t\
    case '{':\n\t\t\tlevels[index] += 1\n\t\tcase ')':\n\t\t\tlevels[index] -= 1\n\
    \t\tcase '}':\n\t\t\tlevels[index] -= 1\n\t\tcase ']':\n\t\t\tlevels[index] -=\
    \ 1\n\t\tcase ',':\n\t\t\tlevels[index] = 0\n\t\tdefault:\n\t\t\tbreak\n\t\t}\n\
    \n\t\tif levels[index] >= current_level {\n\t\t\tlevels[index] = current_level\n\
    \t\t}\n\t}\n\n\treturn levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmplym9llsz.swift:16:8: error: single-quoted string literal found,\
    \ use '\"'\n                case '(':\n                     ^~~\n            \
    \         \"(\"\n/tmp/tmplym9llsz.swift:18:8: error: single-quoted string literal\
    \ found, use '\"'\n                case '[':\n                     ^~~\n     \
    \                \"[\"\n/tmp/tmplym9llsz.swift:20:8: error: single-quoted string\
    \ literal found, use '\"'\n                case '{':\n                     ^~~\n\
    \                     \"{\"\n/tmp/tmplym9llsz.swift:22:8: error: single-quoted\
    \ string literal found, use '\"'\n                case ')':\n                \
    \     ^~~\n                     \")\"\n/tmp/tmplym9llsz.swift:24:8: error: single-quoted\
    \ string literal found, use '\"'\n                case '}':\n                \
    \     ^~~\n                     \"}\"\n/tmp/tmplym9llsz.swift:26:8: error: single-quoted\
    \ string literal found, use '\"'\n                case ']':\n                \
    \     ^~~\n                     \"]\"\n/tmp/tmplym9llsz.swift:28:8: error: single-quoted\
    \ string literal found, use '\"'\n                case ',':\n                \
    \     ^~~\n                     \",\"\n/tmp/tmplym9llsz.swift:12:36: error: 'characters'\
    \ is unavailable: Please use String directly\n        for (index, char) in paren_string.characters.enumerated()\
    \ {\n                                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    guard paren_string.count > 0 else {\n        return\
    \ []\n    }\n    var max_level = -1\n    var max_nesting = 0\n    var nesting\
    \ = 0\n    var paren_count = 0\n    for index in 0..<paren_string.count {\n  \
    \      let character = paren_string[index]\n        guard character == \"(\" else\
    \ {\n            return []\n        }\n        if nesting > max_nesting {\n  \
    \          max_nesting = nesting\n            max_level = nesting\n        }\n\
    \        nesting += 1\n        paren_count += 1\n    }\n    return [max_nesting,\
    \ max_level]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpoh_7ku6e.swift:16:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = paren_string[index]\n                        ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Create a set of parens we want to keep track\n  \
    \  var parens: Set<String> = Set()\n    // Iterate through the input string and\
    \ parse nested parens\n    for char in paren_string.characters {\n        // If\
    \ this char is a left paren, increase level\n        if char == \"(\" {\n    \
    \        parens.insert(\"(\")\n        // If this char is a right paren, decrease\
    \ level\n        } else if char == \")\" {\n            // If the paren is open,\
    \ then remove it\n            if parens.contains(\"(\") {\n                parens.remove(\"\
    (\")\n            }\n            // If the paren is closed, then add it\n    \
    \        else {\n                parens.insert(\")\")\n            }\n       \
    \ }\n    }\n    // Create a map of all the parens and their nesting level\n  \
    \  var paren_map: [String: Int] = [:]\n    for paren in parens {\n        if paren\
    \ != \"\" {\n            paren_map[paren] = paren_map[paren] ?? 0\n          \
    \  paren_map[paren]++\n        }\n    }\n    // Iterate through the map to find\
    \ the max level of nesting\n    var max_level = Int.max\n    for paren in paren_map\
    \ {\n        if paren_map[paren] > max_level {\n            max_level = paren_map[paren]\n\
    \        }\n    }\n    // Return the max level\n    return Array(parens).map {\
    \ paren in\n        if paren_map[paren] == max_level {\n            return paren\n\
    \        } else {\n            return paren\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0qpc1z6j.swift:11:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in paren_string.characters {\n           \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp0qpc1z6j.swift:32:29: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            paren_map[paren]++\n                     \
    \       ^~\n/tmp/tmp0qpc1z6j.swift:38:21: error: no exact matches in call to subscript\
    \ \n        if paren_map[paren] > max_level {\n                    ^\n/tmp/tmp0qpc1z6j.swift:38:21:\
    \ note: found candidate with type '(Dictionary<String, Int>.Index) -> (key: String,\
    \ value: Int)'\n        if paren_map[paren] > max_level {\n                  \
    \  ^\n/tmp/tmp0qpc1z6j.swift:38:21: note: candidate expects value of type 'String'\
    \ for parameter #1 (got '(key: String, value: Int)')\n        if paren_map[paren]\
    \ > max_level {\n                    ^\n/tmp/tmp0qpc1z6j.swift:38:29: error: binary\
    \ operator '>' cannot be applied to operands of type '(key: String, value: Int)'\
    \ and 'Int'\n        if paren_map[paren] > max_level {\n           ~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~\n/tmp/tmp0qpc1z6j.swift:38:29: note: overloads for '>' exist with\
    \ these partially matching parameter lists: (Int, Int)\n        if paren_map[paren]\
    \ > max_level {\n                            ^\n/tmp/tmp0qpc1z6j.swift:39:34:\
    \ error: no exact matches in call to subscript \n            max_level = paren_map[paren]\n\
    \                                 ^\n/tmp/tmp0qpc1z6j.swift:39:34: note: found\
    \ candidate with type '(Dictionary<String, Int>.Index) -> (key: String, value:\
    \ Int)'\n            max_level = paren_map[paren]\n                          \
    \       ^\n/tmp/tmp0qpc1z6j.swift:39:34: note: found candidate with type '(String)\
    \ -> @lvalue Int?'\n            max_level = paren_map[paren]\n               \
    \                  ^\n/tmp/tmp0qpc1z6j.swift:39:34: note: found candidate with\
    \ type '(Range<Dictionary<String, Int>.Index>) -> Slice<[String : Int]>'\n   \
    \         max_l"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // First get all the groups of parentheses separated\
    \ by spaces.\n    // The algorithm starts from left to right and go down until\
    \ we encounter an opening parenthesis.\n    var groups: [String] = []\n    var\
    \ level = 0\n    var opening = 0\n    for c in paren_string {\n        if opening=='('\
    \ && c==')' {\n            level--\n        } else if opening=='(' && c!='(' {\n\
    \            opening++\n        } else if opening=='(' && c==')' {\n         \
    \   opening--\n            if level==0 {\n                groups.append(c)\n \
    \           }\n        }\n    }\n    // The groups are separated by spaces. Now\
    \ we loop through\n    // all the groups and find out the maximum level of nesting.\n\
    \    var max_level = 0\n    for g in groups {\n        var nesting = level\n \
    \       var is_opening_open = false\n        for c in g {\n            if c==opening\
    \ {\n                is_opening_open = true\n                nesting = nesting\
    \ + 1\n            }\n            if c=='(' && !is_opening_open {\n          \
    \      nesting = nesting - 1\n            }\n        }\n        if nesting > max_level\
    \ {\n            max_level = nesting\n        }\n    }\n    // Return max level\
    \ of nesting found\n    return max_level\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmph7tv2ab1.swift:14:21: error: single-quoted string literal found,\
    \ use '\"'\n        if opening=='(' && c==')' {\n                    ^~~\n   \
    \                 \"(\"\n/tmp/tmph7tv2ab1.swift:14:31: error: single-quoted string\
    \ literal found, use '\"'\n        if opening=='(' && c==')' {\n             \
    \                 ^~~\n                              \")\"\n/tmp/tmph7tv2ab1.swift:16:28:\
    \ error: single-quoted string literal found, use '\"'\n        } else if opening=='('\
    \ && c!='(' {\n                           ^~~\n                           \"(\"\
    \n/tmp/tmph7tv2ab1.swift:16:38: error: single-quoted string literal found, use\
    \ '\"'\n        } else if opening=='(' && c!='(' {\n                         \
    \            ^~~\n                                     \"(\"\n/tmp/tmph7tv2ab1.swift:18:28:\
    \ error: single-quoted string literal found, use '\"'\n        } else if opening=='('\
    \ && c==')' {\n                           ^~~\n                           \"(\"\
    \n/tmp/tmph7tv2ab1.swift:18:38: error: single-quoted string literal found, use\
    \ '\"'\n        } else if opening=='(' && c==')' {\n                         \
    \            ^~~\n                                     \")\"\n/tmp/tmph7tv2ab1.swift:36:19:\
    \ error: single-quoted string literal found, use '\"'\n            if c=='(' &&\
    \ !is_opening_open {\n                  ^~~\n                  \"(\"\n/tmp/tmph7tv2ab1.swift:14:19:\
    \ error: binary operator '==' cannot be applied to operands of type 'Int' and\
    \ 'String'\n        if opening=='(' && c==')' {\n           ~~~~~~~^ ~~~\n/tmp/tmph7tv2ab1.swift:14:19:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int), (String, String)\n        if opening=='(' && c==')' {\n        \
    \          ^\n/tmp/tmph7tv2ab1.swift:15:18: error: cannot find operator '--' in\
    \ scope; did you mean '-= 1'?\n            level--\n                 ^~\n/tmp/tmph7tv2ab1.swift:16:26:\
    \ error: binary operator '==' cannot be applied to operands of type 'Int' and\
    \ 'String'\n        } else if opening=='(' && c!='(' {\n                  ~~~~~~~^\
    \ ~~~\n/tmp/tmph7tv2ab1.swift:16:26: note: overloads for '=='"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Step 1. Build a map of counts\n    var paren_count:\
    \ [(Int, Int)] = [(0, 1)]\n    for paren in paren_string.characters {\n      \
    \  paren_count[(paren.value, paren.value)] = paren_count[(paren.value, paren.value)].0\
    \ + 1\n    }\n    // Step 2. Return level counts\n    return paren_count.keys.sorted().map\
    \ {\n        paren_count[$0]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpw6lt26x1.swift:10:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for paren in paren_string.characters {\n          \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpw6lt26x1.swift:11:9: error: generic parameter 'R' could not be inferred\n\
    \        paren_count[(paren.value, paren.value)] = paren_count[(paren.value, paren.value)].0\
    \ + 1\n        ^\nSwift.MutableCollection:2:23: note: in call to 'subscript(_:)'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get set }\n                      ^\n/tmp/tmpw6lt26x1.swift:11:28:\
    \ error: value of type 'Character' has no member 'value'\n        paren_count[(paren.value,\
    \ paren.value)] = paren_count[(paren.value, paren.value)].0 + 1\n            \
    \         ~~~~~ ^~~~~\n/tmp/tmpw6lt26x1.swift:11:41: error: value of type 'Character'\
    \ has no member 'value'\n        paren_count[(paren.value, paren.value)] = paren_count[(paren.value,\
    \ paren.value)].0 + 1\n                                  ~~~~~ ^~~~~\n/tmp/tmpw6lt26x1.swift:11:93:\
    \ error: cannot assign value of type 'Int' to subscript of type 'ArraySlice<(Int,\
    \ Int)>'\n        paren_count[(paren.value, paren.value)] = paren_count[(paren.value,\
    \ paren.value)].0 + 1\n                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n\
    /tmp/tmpw6lt26x1.swift:11:63: error: cannot convert value of type '(_, _)' to\
    \ expected argument type 'Int'\n        paren_count[(paren.value, paren.value)]\
    \ = paren_count[(paren.value, paren.value)].0 + 1\n                          \
    \                                    ^\n/tmp/tmpw6lt26x1.swift:11:70: error: value\
    \ of type 'Character' has no member 'value'\n        paren_count[(paren.value,\
    \ paren.value)] = paren_count[(paren.value, paren.value)].0 + 1\n            \
    \                                                   ~~~~~ ^~~~~\n/tmp/tmpw6lt26x1.swift:11:83:\
    \ error: value of type 'Character' has no membe"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var result = [Int]()\n    var level = 0\n    var is_open\
    \ = true\n    for char in paren_string.characters {\n        switch char {\n \
    \       case \")\":\n            is_open = false\n            result[level] =\
    \ level\n            level += 1\n        case \")\":\n            level += 1\n\
    \        case \" \":\n            if is_open {\n                is_open = false\n\
    \                result[level] = level\n                level += 1\n         \
    \   }\n        case \")\":\n            level += 1\n        }\n    }\n    result[level]\
    \ = level\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpz8ogzuci.swift:11:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in paren_string.characters {\n           \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpz8ogzuci.swift:17:14: warning: literal value is already handled by\
    \ previous pattern; consider removing it\n        case \")\":\n             ^~~\n\
    /tmp/tmpz8ogzuci.swift:13:14: note: first occurrence of identical literal pattern\
    \ is here\n        case \")\":\n             ^~~\n/tmp/tmpz8ogzuci.swift:25:14:\
    \ warning: literal value is already handled by previous pattern; consider removing\
    \ it\n        case \")\":\n             ^~~\n/tmp/tmpz8ogzuci.swift:13:14: note:\
    \ first occurrence of identical literal pattern is here\n        case \")\":\n\
    \             ^~~\n/tmp/tmpz8ogzuci.swift:12:9: error: switch must be exhaustive\n\
    \        switch char {\n        ^\n/tmp/tmpz8ogzuci.swift:12:9: note: do you want\
    \ to add a default clause?\n        switch char {\n        ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var paren_levels = [Int]()\n    var max_level = Int()\n\
    \    var paren_count = Int()\n    for index in stride(from: 0, to: paren_string.characters.count,\
    \ by: 1) {\n        let char = paren_string[index].unicodeScalars.first!\n   \
    \     switch char {\n        case \"(\", \")\":\n            paren_levels.append(paren_levels[paren_levels.index(before:\
    \ paren_levels.index(of: char))]!)\n            if paren_levels[paren_levels.index(of:\
    \ char)] != max_level {\n                max_level = paren_levels[paren_levels.index(of:\
    \ char)]!\n                paren_count = 1\n            } else {\n           \
    \     paren_count = paren_count + 1\n            }\n        case \" \":\n    \
    \        paren_levels.append(paren_levels[paren_levels.index(before: paren_levels.index(of:\
    \ char))]!)\n            if paren_levels[paren_levels.index(of: char)] != max_level\
    \ {\n                max_level = paren_levels[paren_levels.index(of: char)]!\n\
    \            } else {\n                paren_count = paren_count + 1\n       \
    \     }\n        }\n    }\n    if paren_count == 0 {\n        paren_levels.append(0)\n\
    \        max_level = 0\n    }\n    paren_levels.append(paren_count)\n    return\
    \ paren_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpijsdyuvh.swift:11:51: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in stride(from: 0, to: paren_string.characters.count,\
    \ by: 1) {\n                                                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpijsdyuvh.swift:12:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let char = paren_string[index].unicodeScalars.first!\n              \
    \     ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpijsdyuvh.swift:15:86: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n            paren_levels.append(paren_levels[paren_levels.index(before:\
    \ paren_levels.index(of: char))]!)\n                                         \
    \                                            ^\n/tmp/tmpijsdyuvh.swift:15:86:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            paren_levels.append(paren_levels[paren_levels.index(before:\
    \ paren_levels.index(of: char))]!)\n                                         \
    \                                            ^\n                             \
    \                                                                        ?? <#default\
    \ value#>\n/tmp/tmpijsdyuvh.swift:15:86: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            paren_levels.append(paren_levels[paren_levels.index(before:\
    \ paren_levels.index(of: char))]!)\n                                         \
    \                                            ^\n                             \
    \                                                                       !\n/tmp/tmpijsdyuvh.swift:15:96:\
    \ error: cannot convert value of type 'Unicode.Scalar' to expected argument ty"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tassert(paren_string.count >= 1)\n\tassert(paren_string.count\
    \ <= 100000)\n\t\n\tvar level = 0\n\tvar result = [Int]()\n\t\n\tfor char1 in\
    \ paren_string.characters {\n\t\tif char1 == \"(\"\n\t\t\tlevel++\n\t\tif char1\
    \ == \")\"\n\t\t\tlevel--\n\t\t\n\t\tif level == 0 {\n\t\t\tcontinue\n\t\t}\n\t\
    \t\n\t\tif level > result.count {\n\t\t\tresult = Array(0..<level).map { _ in\
    \ 0 }\n\t\t}\n\t\t\n\t\tresult[level] += 1\n\t}\n\t\n\treturn result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpp_atxoyd.swift:15:18: error: expected '{' after 'if' condition\n\
    \                if char1 == \"(\"\n                               ^\n/tmp/tmpp_atxoyd.swift:17:18:\
    \ error: expected '{' after 'if' condition\n                if char1 == \")\"\n\
    \                               ^\n/tmp/tmpp_atxoyd.swift:14:28: error: 'characters'\
    \ is unavailable: Please use String directly\n        for char1 in paren_string.characters\
    \ {\n                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpp_atxoyd.swift:11:6: warning: variable 'level' was\
    \ never mutated; consider changing to 'let' constant\n        var level = 0\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n    var result = [Int]()\n    for\
    \ s in paren_string.components(separatedBy: \" \") {\n        if s.isEmpty {\n\
    \            continue\n        }\n        for _ in 0..<s.count {\n           \
    \ guard let index = paren_string.index(s.startIndex, offsetBy: 1) else {\n   \
    \             fatalError(\"No index in parenstring\")\n            }\n       \
    \     guard let length = paren_string.distance(from: index, to: s.startIndex)\
    \ else {\n                fatalError(\"No length of string\")\n            }\n\
    \            var level = 1\n            while length != 0 {\n                let\
    \ start = paren_string.index(index, offsetBy: length)\n                let end\
    \ = paren_string.index(start, offsetBy: 0)\n                let count = end -\
    \ start\n                if count > length {\n                    length -= count\n\
    \                } else {\n                    length = 0\n                }\n\
    \                if length > 0 {\n                    level += 1\n           \
    \         length -= count\n                }\n                index = end\n  \
    \          }\n            if level > max_level {\n                max_level =\
    \ level\n                result.append(level)\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpjzzmtw0s.swift:10:27: error: value of type 'String' has no member\
    \ 'components'\n    for s in paren_string.components(separatedBy: \" \") {\n \
    \            ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels: [Int] = [Int]()\n\n    for paren in paren_string.characters\
    \ {\n        if paren == \"(\" {\n            levels = append(levels, 0)\n   \
    \     } else if paren == \")\" {\n            levels = append(levels, levels[len(levels)-1])\n\
    \        } else {\n            levels = append(levels, levels[len(levels)-1]+1)\n\
    \        }\n    }\n\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpmumvwkjv.swift:10:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for paren in paren_string.characters {\n          \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmumvwkjv.swift:12:22: error: cannot find 'append' in scope\n    \
    \        levels = append(levels, 0)\n                     ^~~~~~\n/tmp/tmpmumvwkjv.swift:14:22:\
    \ error: cannot find 'append' in scope\n            levels = append(levels, levels[len(levels)-1])\n\
    \                     ^~~~~~\n/tmp/tmpmumvwkjv.swift:14:44: error: cannot find\
    \ 'len' in scope\n            levels = append(levels, levels[len(levels)-1])\n\
    \                                           ^~~\n/tmp/tmpmumvwkjv.swift:16:22:\
    \ error: cannot find 'append' in scope\n            levels = append(levels, levels[len(levels)-1]+1)\n\
    \                     ^~~~~~\n/tmp/tmpmumvwkjv.swift:16:44: error: cannot find\
    \ 'len' in scope\n            levels = append(levels, levels[len(levels)-1]+1)\n\
    \                                           ^~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var output_level: [Int] = [0]\n\n    let s = paren_string.trim()\n\
    \    let num_opening_brackets = s.count(\"(\")\n    let num_closing_brackets =\
    \ s.count(\")\")\n\n    for paren_string in s.split(\"(\" as NSString) {\n   \
    \     let num_opening_paren = paren_string.count(\"(\")\n        let num_closing_paren\
    \ = paren_string.count(\")\")\n\n        if (num_opening_paren == num_closing_brackets\
    \ && num_closing_paren == num_opening_brackets) {\n            // The current\
    \ level is deepest level of nesting within parentheses.\n            let output_level\
    \ = output_level[output_level.count - 1] + 1\n            output_level.append(output_level)\n\
    \        } else {\n            // The current level decreases until the closing\
    \ parentheses is encountered.\n            output_level.append(output_level[output_level.count\
    \ - 1] - 1)\n        }\n    }\n\n    return output_level\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpzmq0_3v8.swift:10:26: error: value of type 'String' has no member\
    \ 'trim'\n    let s = paren_string.trim()\n            ~~~~~~~~~~~~ ^~~~\n/tmp/tmpzmq0_3v8.swift:14:40:\
    \ error: cannot find type 'NSString' in scope\n    for paren_string in s.split(\"\
    (\" as NSString) {\n                                       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var count = [Int]()\n    var depth = 0\n    for groupStr\
    \ in paren_string.split(\" \") {\n        var tempCount = count[depth]\n     \
    \   var tempDepth = depth\n        while tempCount < groupStr.count {\n      \
    \      tempCount += 1\n            tempDepth += 1\n            if tempDepth >\
    \ count.count {\n                count = [Int](count: tempDepth, repeatedValue:\
    \ 0)\n            }\n        }\n        count[tempDepth] += groupStr.count\n \
    \   }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpjt4aifyf.swift:10:34: error: no exact matches in call to instance\
    \ method 'split'\n    for groupStr in paren_string.split(\" \") {\n          \
    \                       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let re = try! NSRegularExpression(pattern: \"\\\\([^()]*\\\
    \\)\", options: [])\n    let matches = re.matches(in: paren_string, range: NSRange(location:\
    \ 0, length: paren_string.count))\n    let levels = matches.map { match in\n \
    \       let range = (paren_string[match.range(at: 1)] as NSString).range(of: \"\
    (\", options: .anchored)\n        let end_range = (paren_string[match.range(at:\
    \ 2)] as NSString).range(of: \")\", options: .anchored)\n        range.length\
    \ - (end_range - range)\n    }.max()\n    return Array(1...levels)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpzk0372k1.swift:8:19: error: cannot find 'NSRegularExpression' in\
    \ scope\n    let re = try! NSRegularExpression(pattern: \"\\\\([^()]*\\\\)\",\
    \ options: [])\n                  ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpzk0372k1.swift:9:55:\
    \ error: cannot find 'NSRange' in scope\n    let matches = re.matches(in: paren_string,\
    \ range: NSRange(location: 0, length: paren_string.count))\n                 \
    \                                     ^~~~~~~\n/tmp/tmpzk0372k1.swift:11:58: error:\
    \ cannot find type 'NSString' in scope\n        let range = (paren_string[match.range(at:\
    \ 1)] as NSString).range(of: \"(\", options: .anchored)\n                    \
    \                                     ^~~~~~~~\n/tmp/tmpzk0372k1.swift:11:68:\
    \ error: reference to member 'range' cannot be resolved without a contextual type\n\
    \        let range = (paren_string[match.range(at: 1)] as NSString).range(of:\
    \ \"(\", options: .anchored)\n                                               \
    \                    ^\n/tmp/tmpzk0372k1.swift:11:93: error: cannot infer contextual\
    \ base in reference to member 'anchored'\n        let range = (paren_string[match.range(at:\
    \ 1)] as NSString).range(of: \"(\", options: .anchored)\n                    \
    \                                                                       ~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var result = [Int]()\n\n    var groupCount = 0\n   \
    \ var parenCount = 0\n    var parenLevel = 0\n\n    for char in paren_string {\n\
    \        if char == '(' {\n            groupCount++\n            parenLevel++\n\
    \        } else if char == ')' {\n            groupCount--\n            if groupCount\
    \ == 0 {\n                parenLevel--\n            }\n        } else {\n    \
    \        if groupCount == 0 {\n                parenCount++\n            }\n \
    \           if parenCount > parenLevel {\n                parenLevel = parenCount\n\
    \                result.insert(parenLevel, parenLevel)\n            }\n      \
    \  }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp65wn_py6.swift:15:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' {\n                   ^~~\n               \
    \    \"(\"\n/tmp/tmp65wn_py6.swift:18:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ')' {\n                         \
    \ ^~~\n                          \")\"\n/tmp/tmp65wn_py6.swift:16:23: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            groupCount++\n\
    \                      ^~\n/tmp/tmp65wn_py6.swift:17:23: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            parenLevel++\n            \
    \          ^~\n/tmp/tmp65wn_py6.swift:19:23: error: cannot find operator '--'\
    \ in scope; did you mean '-= 1'?\n            groupCount--\n                 \
    \     ^~\n/tmp/tmp65wn_py6.swift:21:27: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n                parenLevel--\n                       \
    \   ^~\n/tmp/tmp65wn_py6.swift:25:27: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                parenCount++\n                       \
    \   ^~\n/tmp/tmp65wn_py6.swift:29:24: error: no exact matches in call to instance\
    \ method 'insert'\n                result.insert(parenLevel, parenLevel)\n   \
    \                    ^\nSwift.Array:11:37: note: incorrect labels for candidate\
    \ (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect labels for candidate\
    \ (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Self.Element, at i: Self.Index)\n                      \
    \              ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [0]\n    for i in 1..<paren_string.count{\n\
    \        if paren_string[paren_string.index(i, offsetBy: i-1)] == \")\"{\n   \
    \         levels[i-1] = levels[i-1]+1\n        }else if paren_string[paren_string.index(i,\
    \ offsetBy: i-1)] == \"(\"{\n            levels[i-1] = levels[i-1]-1\n       \
    \ }else{\n            break\n        }\n    }\n    return levels\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9ak6skgj.swift:10:44: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        if paren_string[paren_string.index(i,\
    \ offsetBy: i-1)] == \")\"{\n                                           ^\n/tmp/tmp9ak6skgj.swift:12:50:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \        }else if paren_string[paren_string.index(i, offsetBy: i-1)] == \"(\"\
    {\n                                                 ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let mut level = 0\n    let mut max_level = [Int]()\n\
    \    let mut paren_level = [Int]()\n\n    let mut parens = paren_string.characters\n\
    \    while let c = parens.pop() {\n        if c != '(' {\n            paren_level[level]\
    \ = level\n        }\n        if c == '(' {\n            level++\n           \
    \ if level == max_level.last_mut() {\n                max_level.append(level)\n\
    \            }\n        }\n        if c == ')' {\n            if paren_level[level-1]\
    \ == level {\n                level--\n            } else {\n                paren_level[level]\
    \ = level\n            }\n        }\n    }\n\n    max_level.append(level)\n  \
    \  max_level.last_mut().unwrap()\n\n    return max_level\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpj_1chfib.swift:8:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut level =\
    \ 0\n            ^\n/tmp/tmpj_1chfib.swift:8:13: note: join the identifiers together\n\
    \    let mut level = 0\n        ~~~~^~~~~\n        mutlevel\n/tmp/tmpj_1chfib.swift:8:13:\
    \ note: join the identifiers together with camel-case\n    let mut level = 0\n\
    \        ~~~~^~~~~\n        mutLevel\n/tmp/tmpj_1chfib.swift:9:13: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n    let mut max_level = [Int]()\n            ^\n/tmp/tmpj_1chfib.swift:9:13:\
    \ note: join the identifiers together\n    let mut max_level = [Int]()\n     \
    \   ~~~~^~~~~~~~~\n        mutmax_level\n/tmp/tmpj_1chfib.swift:9:13: note: join\
    \ the identifiers together with camel-case\n    let mut max_level = [Int]()\n\
    \        ~~~~^~~~~~~~~\n        mutMax_level\n/tmp/tmpj_1chfib.swift:10:13: error:\
    \ found an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n    let mut paren_level = [Int]()\n            ^\n/tmp/tmpj_1chfib.swift:10:13:\
    \ note: join the identifiers together\n    let mut paren_level = [Int]()\n   \
    \     ~~~~^~~~~~~~~~~\n        mutparen_level\n/tmp/tmpj_1chfib.swift:10:13: note:\
    \ join the identifiers together with camel-case\n    let mut paren_level = [Int]()\n\
    \        ~~~~^~~~~~~~~~~\n        mutParen_level\n/tmp/tmpj_1chfib.swift:12:13:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n    let mut parens = paren_string.characters\n       \
    \     ^\n/tmp/tmpj_1chfib.swift:12:13: note: join the identifiers together\n \
    \   let mut parens = paren_string.characters\n        ~~~~^~~~~~\n        mutparens\n\
    /tmp/tmpj_1chfib.swift:12:13: note: join the identifiers together with camel-case\n\
    \    let mut parens = paren_string.characters\n        ~~~~^~~~~~\n        mutParens\n\
    /tmp/tmpj_1chfib.swift:14:17: error: single-quoted string literal found, use '\"\
    '\n        if c != '(' {\n                ^~~\n                \"(\"\n/tmp/tmpj_1chfib.swi"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Parse the string. Keep the parentheses and level\
    \ of nesting for each group\n    let parser = NSRegularExpression(pattern: \"\\\
    \\(|\\\\)\\\\s*|\\\\(|\\\\)\\\\s*\\\\(|\\\\)\\\\s*\", options: [], error: nil)\n\
    \    var result: [Int] = []\n    for i in parser.matches(in: paren_string, options:\
    \ .regularExpression) {\n        let groups = paren_string.components(separatedBy:\
    \ \"\\\\(|\\\\)\")\n        let group_level = groups.count\n        var level\
    \ = 1\n        for group in groups {\n            level += group == \")\" ? 1\
    \ : -1\n        }\n        result.append(level)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpiykvfyju.swift:9:18: error: cannot find 'NSRegularExpression' in\
    \ scope\n    let parser = NSRegularExpression(pattern: \"\\\\(|\\\\)\\\\s*|\\\\\
    (|\\\\)\\\\s*\\\\(|\\\\)\\\\s*\", options: [], error: nil)\n                 ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpiykvfyju.swift:9:105: error: 'nil' requires a contextual type\n    let\
    \ parser = NSRegularExpression(pattern: \"\\\\(|\\\\)\\\\s*|\\\\(|\\\\)\\\\s*\\\
    \\(|\\\\)\\\\s*\", options: [], error: nil)\n                                \
    \                                                                        ^\n/tmp/tmpiykvfyju.swift:11:57:\
    \ error: cannot infer contextual base in reference to member 'regularExpression'\n\
    \    for i in parser.matches(in: paren_string, options: .regularExpression) {\n\
    \                                                       ~^~~~~~~~~~~~~~~~~\n/tmp/tmpiykvfyju.swift:12:35:\
    \ error: value of type 'String' has no member 'components'\n        let groups\
    \ = paren_string.components(separatedBy: \"\\\\(|\\\\)\")\n                  \
    \   ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    guard let paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines) else { return [] }\n    guard paren_string.characters.count\
    \ == 0 else {\n        return parse_nested_parens(paren_string: paren_string)\n\
    \    }\n\n    var counts: [Int] = [0]\n    var level = 1\n    var paren_count\
    \ = 1\n    var max_level = 0\n    var level_char: Character?\n\n    for char in\
    \ paren_string.characters {\n        guard level_char == nil else { return []\
    \ }\n        level_char = char\n\n        if char == ')' {\n            if level_char\
    \ == nil {\n                level--\n            } else {\n                paren_count--\n\
    \                if paren_count == 0 {\n                    max_level = level\n\
    \                }\n            }\n        } else if char == '(' {\n         \
    \   paren_count++\n            if paren_count == 0 {\n                counts.append(level)\n\
    \            }\n        }\n    }\n\n    return counts\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpf6i7giit.swift:23:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == ')' {\n                   ^~~\n               \
    \    \")\"\n/tmp/tmpf6i7giit.swift:32:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == '(' {\n                         \
    \ ^~~\n                          \"(\"\n/tmp/tmpf6i7giit.swift:8:66: error: cannot\
    \ find 'CharacterSet' in scope\n    guard let paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines) else { return [] }\n                  \
    \                                               ^~~~~~~~~~~~\n/tmp/tmpf6i7giit.swift:8:43:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    guard\
    \ let paren_string = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\
    \ else { return [] }\n                             ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var max_level = 0\n    for char in\
    \ paren_string.characters {\n        if char == \"(\"\n            level++\n \
    \       else if char == \")\"\n            level--\n        else if char == \"\
    )\" and level == 0\n            max_level = max(level, max_level)\n    }\n   \
    \ var max_level_index = [Int]()\n    \n    for i in 0..<max_level {\n        if\
    \ max_level_index.contains(i) {\n            continue\n        } else {\n    \
    \        max_level_index.append(i)\n        }\n    }\n    \n    return max_level_index\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptuafld41.swift:11:23: error: expected '{' after 'if' condition\n\
    \        if char == \"(\"\n                      ^\n/tmp/tmptuafld41.swift:13:28:\
    \ error: expected '{' after 'if' condition\n        else if char == \")\"\n  \
    \                         ^\n/tmp/tmptuafld41.swift:15:29: error: expected '{'\
    \ after 'if' condition\n        else if char == \")\" and level == 0\n       \
    \                     ^\n/tmp/tmptuafld41.swift:10:30: error: 'characters' is\
    \ unavailable: Please use String directly\n    for char in paren_string.characters\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmptuafld41.swift:8:9: warning: initialization of variable\
    \ 'level' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    var level = 0\n    ~~~~^~~~~\n    _\n/tmp/tmptuafld41.swift:9:9: warning:\
    \ variable 'max_level' was never mutated; consider changing to 'let' constant\n\
    \    var max_level = 0\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max = 0\n    for index in stride(from: 0, to: paren_string.utf16.count,\
    \ by: 1) {\n        guard paren_string[index] != \")\" && paren_string[index]\
    \ != \"]\" && paren_string[index] != \")\" && paren_string[index] != \"]\" else\
    \ {\n            return nil\n        }\n        let level = paren_string[index].unicodeScalars.count\
    \ * 2\n        if level > max {\n            max = level\n        }\n    }\n \
    \   return [0, max]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmphsmg83ul.swift:10:15: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        guard paren_string[index]\
    \ != \")\" && paren_string[index] != \"]\" && paren_string[index] != \")\" &&\
    \ paren_string[index] != \"]\" else {\n              ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphsmg83ul.swift:10:45:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        guard paren_string[index] != \")\" && paren_string[index]\
    \ != \"]\" && paren_string[index] != \")\" && paren_string[index] != \"]\" else\
    \ {\n                                            ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphsmg83ul.swift:10:75:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        guard paren_string[index] != \")\" && paren_string[index]\
    \ != \"]\" && paren_string[index] != \")\" && paren_string[index] != \"]\" else\
    \ {\n                                                                        \
    \  ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmphsmg83ul.swift:10:105: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        guard\
    \ paren_string[index] != \")\" && paren_string[index] != \"]\" && paren_string[index]\
    \ != \")\" && paren_string[index] != \"]\" else {\n                          \
    \                                                                            \
    \  ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmphsmg83ul.swift:11:20: error: 'nil' is incom"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tvar max_nesting = 0\n\tvar nesting_level = 0\n\tnesting_level\
    \ = 0\n\tfor i, char := range paren_string {\n\t\tif char == '(' {\n\t\t\tnesting_level\
    \ += 1\n\t\t} else if char == ')' {\n\t\t\tnesting_level -= 1\n\t\t\tif nesting_level\
    \ < 0 {\n\t\t\t\tnesting_level = 0\n\t\t\t}\n\t\t} else if nesting_level == 0\
    \ {\n\t\t\tmax_nesting = i\n\t\t}\n\t}\n\treturn max_nesting\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptmc0x2at.swift:11:7: error: expected 'in' after for-each pattern\n\
    \        for i, char := range paren_string {\n             ^\n/tmp/tmptmc0x2at.swift:11:7:\
    \ error: expected Sequence expression for for-each loop\n        for i, char :=\
    \ range paren_string {\n             ^\n/tmp/tmptmc0x2at.swift:12:14: error: single-quoted\
    \ string literal found, use '\"'\n                if char == '(' {\n         \
    \                  ^~~\n                           \"(\"\n/tmp/tmptmc0x2at.swift:14:21:\
    \ error: single-quoted string literal found, use '\"'\n                } else\
    \ if char == ')' {\n                                  ^~~\n                  \
    \                \")\"\n/tmp/tmptmc0x2at.swift:23:9: error: cannot convert return\
    \ expression of type 'Int' to return type '[Int]'\n        return max_nesting\n\
    \               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var results = [Int]()\n\n    // parse all parentheses\n\
    \    for index in 0..<paren_string.characters.count {\n        let currentChar\
    \ = paren_string.characters[index]\n\n        // current paren is opening or closing\n\
    \        let opening = currentChar == \"(\"\n        let closing = currentChar\
    \ == \")\"\n\n        if opening {\n            guard !closing else {\n      \
    \          assert(false && \"expected closing paren\")\n                return\
    \ results\n            }\n            \n            if results[results.count-1]\
    \ == -1 {\n                results.append(index)\n            }\n        } else\
    \ if closing {\n            if results[results.count-1] != -1 {\n            \
    \    results.append(-1)\n            }\n            results.popLast()\n      \
    \  }\n    }\n    \n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpfak4td99.swift:11:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<paren_string.characters.count {\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpfak4td99.swift:12:27: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ currentChar = paren_string.characters[index]\n                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfak4td99.swift:12:40:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ currentChar = paren_string.characters[index]\n                             \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpfak4td99.swift:20:33: error: cannot convert value of type 'String' to\
    \ expected argument type 'Bool'\n                assert(false && \"expected closing\
    \ paren\")\n                                ^\n/tmp/tmpfak4td99.swift:31:21: warning:\
    \ result of call to 'popLast()' is unused\n            results.popLast()\n   \
    \                 ^      ~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var depth = 0\n    var result = [0]\n\
    \n    // For each group of parentheses.\n    for _ in paren_string.components(separatedBy:\
    \ \" \") {\n        // Keep track of how many parentheses we encountered for nested\
    \ paranthesis.\n        level += 1\n\n        // Keep track of how many characters\
    \ we have encountered for nested paranthesis.\n        depth += 1 + paren_string.count\n\
    \n        // Find the max of current level of nesting and total chars we encountered.\n\
    \        let max_level = max(level, depth)\n\n        // If max level is same\
    \ as level, we just encountered the same number of parentheses.\n        if level\
    \ == max_level {\n            result.append(level)\n            continue\n   \
    \     }\n\n        // If max level is greater than current level, we encountered\
    \ different number of parentheses.\n        if level > level {\n            //\
    \ Remove the difference, and add 1 for the next iteration, so that this level\
    \ doesn't affect the result.\n            depth += max_level - level\n       \
    \     level = 0\n        }\n\n        // Increment the level of the next group.\n\
    \        level += 1\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp7917s70n.swift:13:27: error: value of type 'String' has no member\
    \ 'components'\n    for _ in paren_string.components(separatedBy: \" \") {\n \
    \            ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var maxLevel = 0\n    var levels = [Int]()\n    var\
    \ nested = 0\n    for char in paren_string.characters {\n        if char == '('\
    \ { nested++ }\n        if char == ')' { nested-- }\n        if nested < 0 {\n\
    \            levels.append(nested)\n            nested = 0\n        }\n      \
    \  if nested > maxLevel {\n            maxLevel = nested\n        }\n    }\n \
    \   return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpa_48f9od.swift:12:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' { nested++ }\n                   ^~~\n    \
    \               \"(\"\n/tmp/tmpa_48f9od.swift:13:20: error: single-quoted string\
    \ literal found, use '\"'\n        if char == ')' { nested-- }\n             \
    \      ^~~\n                   \")\"\n/tmp/tmpa_48f9od.swift:11:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in paren_string.characters\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpa_48f9od.swift:12:32: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n        if char == '(' { nested++ }\n      \
    \                         ^~\n/tmp/tmpa_48f9od.swift:13:32: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n        if char == ')' { nested--\
    \ }\n                               ^~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n    var current_level = 0\n    var\
    \ level = 0\n    var last_pos = 0\n\n    for idx, c in enumerate(paren_string)\
    \ {\n        if c == '(' {\n            current_level += 1\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      } else if c == ')' {\n            current_level -= 1\n            if current_level\
    \ < 0 {\n                return nil\n            }\n        } else {\n       \
    \     level++\n            if level > max_level {\n                max_level =\
    \ level\n            }\n            last_pos = idx\n        }\n    }\n\n    level\
    \ = 0\n    for idx, c in enumerate(paren_string[last_pos:]) {\n        if c ==\
    \ '(' {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if c == ')' {\n            current_level -= 1\n            if current_level\
    \ < 0 {\n                return nil\n            }\n        } else {\n       \
    \     level++\n            if level > max_level {\n                max_level =\
    \ level\n            }\n        }\n    }\n\n    return max_level\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpw1ljf2wn.swift:13:12: error: expected 'in' after for-each pattern\n\
    \    for idx, c in enumerate(paren_string) {\n           ^\n/tmp/tmpw1ljf2wn.swift:13:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, c in enumerate(paren_string)\
    \ {\n           ^\n/tmp/tmpw1ljf2wn.swift:14:17: error: single-quoted string literal\
    \ found, use '\"'\n        if c == '(' {\n                ^~~\n              \
    \  \"(\"\n/tmp/tmpw1ljf2wn.swift:19:24: error: single-quoted string literal found,\
    \ use '\"'\n        } else if c == ')' {\n                       ^~~\n       \
    \                \")\"\n/tmp/tmpw1ljf2wn.swift:34:12: error: expected 'in' after\
    \ for-each pattern\n    for idx, c in enumerate(paren_string[last_pos:]) {\n \
    \          ^\n/tmp/tmpw1ljf2wn.swift:34:12: error: expected Sequence expression\
    \ for for-each loop\n    for idx, c in enumerate(paren_string[last_pos:]) {\n\
    \           ^\n/tmp/tmpw1ljf2wn.swift:35:17: error: single-quoted string literal\
    \ found, use '\"'\n        if c == '(' {\n                ^~~\n              \
    \  \"(\"\n/tmp/tmpw1ljf2wn.swift:40:24: error: single-quoted string literal found,\
    \ use '\"'\n        } else if c == ')' {\n                       ^~~\n       \
    \                \")\"\n/tmp/tmpw1ljf2wn.swift:53:12: error: cannot convert return\
    \ expression of type 'Int' to return type '[Int]'\n    return max_level\n    \
    \       ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    if paren_string == \"\" {\n        return []\n    }\n\
    \    let strings = paren_string.components(separatedBy: \" \")\n    var max_level\
    \ = 0\n    for s in strings {\n        let level = parse_nested_parens(paren_string:\
    \ s)\n        if level > max_level {\n            max_level = level\n        }\n\
    \    }\n    return max_level\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5hv83mq3.swift:11:32: error: value of type 'String' has no member\
    \ 'components'\n    let strings = paren_string.components(separatedBy: \" \")\n\
    \                  ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5hv83mq3.swift:19:12: error:\
    \ cannot convert return expression of type 'Int' to return type '[Int]'\n    return\
    \ max_level\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = [Int]()\n    paren_string = paren_string.trimmingCharacters(in:\
    \ NSCharacterSet.whitespaces)\n    let parens_stack: [String] = []\n    var count\
    \ = 0\n    while count < paren_string.characters.count {\n        guard paren_string.characters.count\
    \ > count + 1 else {\n            return max_level\n        }\n        let next_char\
    \ = paren_string.character(at: count + 1).lowercased\n        let next_index =\
    \ parens_stack.index(of: next_char)\n        if next_index == nil {\n        \
    \    parens_stack.append(next_char)\n            if paren_string.character(at:\
    \ count + 2).isASCII {\n                count += 1\n            } else {\n   \
    \             count += 1\n            }\n        } else {\n            let level\
    \ = next_index! + 1\n            if level > max_level[level] {\n             \
    \   max_level[level] = level\n            }\n            parens_stack.removeSubrange(next_index!..<(count\
    \ + 1))\n        }\n    }\n    return max_level\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpke16vg_7.swift:9:56: error: cannot find 'NSCharacterSet' in scope\n\
    \    paren_string = paren_string.trimmingCharacters(in: NSCharacterSet.whitespaces)\n\
    \                                                       ^~~~~~~~~~~~~~\n/tmp/tmpke16vg_7.swift:9:5:\
    \ error: cannot assign to value: 'paren_string' is a 'let' constant\n    paren_string\
    \ = paren_string.trimmingCharacters(in: NSCharacterSet.whitespaces)\n    ^~~~~~~~~~~~\n\
    /tmp/tmpke16vg_7.swift:9:33: error: value of type 'String' has no member 'trimmingCharacters'\n\
    \    paren_string = paren_string.trimmingCharacters(in: NSCharacterSet.whitespaces)\n\
    \                   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpke16vg_7.swift:12:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    while count\
    \ < paren_string.characters.count {\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpke16vg_7.swift:13:28:\
    \ error: 'characters' is unavailable: Please use String directly\n        guard\
    \ paren_string.characters.count > count + 1 else {\n                         \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpke16vg_7.swift:16:38:\
    \ error: value of type 'String' has no member 'character'\n        let next_char\
    \ = paren_string.character(at: count + 1).lowercased\n                       \
    \ ~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpke16vg_7.swift:19:26: error: no exact matches\
    \ in call to instance method 'append'\n            parens_stack.append(next_char)\n\
    \                         ^\n/tmp/tmpke16vg_7.swift:19:26: note: found candidate\
    \ with type '(__owned String) -> ()'\n            parens_stack.append(next_char)\n\
    \                         ^\n/tmp/tmpke16vg_7.swift:20:29: error: value of type\
    \ 'String' has no member 'character'\n            if paren_string.character(at:\
    \ count + 2).isASCII {\n               ~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpke16vg_7.swift:30:26:\
    \ error: no exact matches "
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let stack: Stack = Stack()\n    var levels: [Int] =\
    \ []\n    let char_count = paren_string.characters.count\n    for index in 0..<char_count-1\
    \ {\n        let ch = paren_string[index]\n        if ch == \")\" {\n        \
    \    let start = stack.size\n            stack.push(index)\n            for index\
    \ in stack.iterateUntilPop(-1) {\n                levels.append(index - start)\n\
    \            }\n            stack.pop()\n        }\n    }\n    return levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpcz5hgrub.swift:8:16: error: cannot find type 'Stack' in scope\n\
    \    let stack: Stack = Stack()\n               ^~~~~\n/tmp/tmpcz5hgrub.swift:10:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    let char_count\
    \ = paren_string.characters.count\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpcz5hgrub.swift:12:18:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let ch = paren_string[index]\n        \
    \         ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var level_count = 0\n    var parens\
    \ = 0\n\n    for _ in paren_string.unicodeScalars {\n        guard parens > 0\
    \ else {\n            break\n        }\n\n        switch parens {\n        case\
    \ 1:\n            level++\n        case 2:\n            level_count = level\n\n\
    \            if level_count > level {\n                level = level_count\n \
    \           }\n        case 3:\n            level_count = level\n\n          \
    \  if level_count > level {\n                level = level_count\n           \
    \ }\n\n        default:\n            level_count = level\n\n            if level_count\
    \ > level {\n                level = level_count\n            }\n        }\n\n\
    \        parens++\n    }\n\n    return Array(1..level).filter { _ in parens ==\
    \ 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpz8rbxvjl.swift:19:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            level++\n                 ^~\n/tmp/tmpz8rbxvjl.swift:41:15:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        parens++\n\
    \              ^~\n/tmp/tmpz8rbxvjl.swift:44:19: error: cannot find operator '..'\
    \ in scope; did you mean '...'?\n    return Array(1..level).filter { _ in parens\
    \ == 0 }\n                  ^~\n                  ...\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    return parse_nested_parens(paren_string, paren_string.count())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpnen65bgn.swift:8:59: error: cannot call value of non-function type\
    \ 'Int'\n    return parse_nested_parens(paren_string, paren_string.count())\n\
    \                                                          ^    ~~\n         \
    \                                                      \n/tmp/tmpnen65bgn.swift:8:59:\
    \ error: extra argument in call\n    return parse_nested_parens(paren_string,\
    \ paren_string.count())\n                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    for s in paren_string.split(\"\
    \ \") {\n        if s.contains(\"(\") {\n            var level = levels[levels.count-1]\n\
    \            level = level + 1\n            levels.append(level)\n        } else\
    \ {\n            levels[levels.count-1] = levels[levels.count-1] - 1\n       \
    \ }\n    }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpyvtvrct2.swift:9:27: error: no exact matches in call to instance\
    \ method 'split'\n    for s in paren_string.split(\" \") {\n                 \
    \         ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n  var num_paren_levels = 0\n  var max_num_paren_levels =\
    \ -1\n\n  for paren_char in paren_string.characters {\n    if paren_char == \"\
    (\" {\n      if num_paren_levels == 0 {\n        num_paren_levels = 1\n      }\
    \ else {\n        num_paren_levels += 1\n      }\n    } else if paren_char ==\
    \ \")\" {\n      if num_paren_levels == 0 {\n        num_paren_levels += 1\n \
    \     } else {\n        num_paren_levels -= 1\n      }\n    } else if paren_char\
    \ == \" \" {\n      if num_paren_levels > max_num_paren_levels {\n        max_num_paren_levels\
    \ = num_paren_levels\n      }\n    }\n  }\n\n  return [max_num_paren_levels +\
    \ 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpds7my507.swift:11:34: error: 'characters' is unavailable: Please\
    \ use String directly\n  for paren_char in paren_string.characters {\n       \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let re = try! NSRegularExpression(pattern: \"\\\\([^()]*\\\
    \\)\", options: [])\n    let results = re.matches(in: paren_string, options: [],\
    \ range: NSMakeRange(0, paren_string.utf8.count))\n    var levels = [Int]()\n\
    \    for match in results {\n        let range = match.range\n        var new_level\
    \ = 0\n        while range.location != NSNotFound {\n            let current =\
    \ paren_string[range]\n            if current == \")\" {\n                new_level\
    \ -= 1\n            }\n            if current == \"(\" {\n                new_level\
    \ += 1\n            }\n            range.location = advance(range.location, range.length)\n\
    \        }\n        levels.append(new_level)\n    }\n    return levels\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp_2njz200.swift:8:19: error: cannot find 'NSRegularExpression' in\
    \ scope\n    let re = try! NSRegularExpression(pattern: \"\\\\([^()]*\\\\)\",\
    \ options: [])\n                  ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp_2njz200.swift:9:68:\
    \ error: cannot find 'NSMakeRange' in scope\n    let results = re.matches(in:\
    \ paren_string, options: [], range: NSMakeRange(0, paren_string.utf8.count))\n\
    \                                                                   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var maxlevel = [Int]()\n    var parencnt = 0\n    for\
    \ idx in 0..<paren_string.characters.count {\n        let ch = paren_string.characters[idx]\n\
    \        if ch == '(' {\n            parencnt += 1\n        } else {\n       \
    \     parencnt -= 1\n        }\n        if parencnt > maxlevel[0] {\n        \
    \    maxlevel[0] = parencnt\n        }\n    }\n    return maxlevel\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpuy6u5yny.swift:12:18: error: single-quoted string literal found,\
    \ use '\"'\n        if ch == '(' {\n                 ^~~\n                 \"\
    (\"\n/tmp/tmpuy6u5yny.swift:10:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for idx in 0..<paren_string.characters.count {\n  \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpuy6u5yny.swift:11:18: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ ch = paren_string.characters[idx]\n                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpuy6u5yny.swift:11:31:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ ch = paren_string.characters[idx]\n                              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let mut paren_stack = [Int]()\n    var paren_count =\
    \ 0\n    for paren in paren_string.characters() {\n        if paren == ')' {\n\
    \            paren_stack.pop() // Pop last paren level\n        } else {\n   \
    \         paren_stack.push(paren_count)\n            paren_count = 0\n       \
    \ }\n        if paren == '(' {\n            paren_count += 1\n        }\n    }\n\
    \    return paren_stack\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpuq0dqi38.swift:8:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut paren_stack\
    \ = [Int]()\n            ^\n/tmp/tmpuq0dqi38.swift:8:13: note: join the identifiers\
    \ together\n    let mut paren_stack = [Int]()\n        ~~~~^~~~~~~~~~~\n     \
    \   mutparen_stack\n/tmp/tmpuq0dqi38.swift:8:13: note: join the identifiers together\
    \ with camel-case\n    let mut paren_stack = [Int]()\n        ~~~~^~~~~~~~~~~\n\
    \        mutParen_stack\n/tmp/tmpuq0dqi38.swift:11:21: error: single-quoted string\
    \ literal found, use '\"'\n        if paren == ')' {\n                    ^~~\n\
    \                    \")\"\n/tmp/tmpuq0dqi38.swift:17:21: error: single-quoted\
    \ string literal found, use '\"'\n        if paren == '(' {\n                \
    \    ^~~\n                    \"(\"\n/tmp/tmpuq0dqi38.swift:10:31: error: cannot\
    \ call value of non-function type 'String'\n    for paren in paren_string.characters()\
    \ {\n                              ^         ~~\n                            \
    \            \n/tmp/tmpuq0dqi38.swift:21:12: error: cannot find 'paren_stack'\
    \ in scope\n    return paren_stack\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level_stack = [Int]()\n    level_stack = append(level_stack,\
    \ 0)\n\n    var level = 0\n    var paren_count = 0\n\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            level_stack = append(level_stack,\
    \ 0)\n            level += 1\n            paren_count += 1\n        } else if\
    \ char == \")\" {\n            if level_stack[level] != 0 {\n                level_stack\
    \ = append(level_stack, level)\n                level -= 1\n            } else\
    \ {\n                panic(\"Parse error\")\n            }\n            paren_count\
    \ -= 1\n        }\n    }\n\n    level_stack = append(level_stack, 0)\n    return\
    \ level_stack\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptpjiafmk.swift:9:19: error: cannot find 'append' in scope\n   \
    \ level_stack = append(level_stack, 0)\n                  ^~~~~~\n/tmp/tmptpjiafmk.swift:16:27:\
    \ error: cannot find 'append' in scope\n            level_stack = append(level_stack,\
    \ 0)\n                          ^~~~~~\n/tmp/tmptpjiafmk.swift:21:31: error: cannot\
    \ find 'append' in scope\n                level_stack = append(level_stack, level)\n\
    \                              ^~~~~~\n/tmp/tmptpjiafmk.swift:24:17: error: cannot\
    \ find 'panic' in scope\n                panic(\"Parse error\")\n            \
    \    ^~~~~\n/tmp/tmptpjiafmk.swift:30:19: error: cannot find 'append' in scope\n\
    \    level_stack = append(level_stack, 0)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    return parse_nested_parens(paren_string: paren_string,\
    \ paren_level: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpzg0f1mv3.swift:8:73: error: extra argument 'paren_level' in call\n\
    \    return parse_nested_parens(paren_string: paren_string, paren_level: 0)\n\
    \                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    guard let parens_pattern = try? NSRegularExpression(pattern:\
    \ \"\\\\s\\\\(\\\\s*\\\\(([^()]*|\\\\([^()]*\\\\))*\\\\)\\\\s*\\\\)\\\\s\") else\
    \ {\n        return []\n    }\n    var level = 0\n    var levels: [Int] = []\n\
    \    guard let matchRange = parens_pattern.matches(in: paren_string, range: NSRange(location:\
    \ 0, length: paren_string.utf16.count)) else {\n        return []\n    }\n   \
    \ paren_string.enumerateSubstrings(in: NSRange(location: matchRange.range.location,\
    \ length: paren_string.utf16.count)) { substring, substringRange, enclosingRange\
    \ in\n        if substringRange.location == 0 {\n            level += 1\n    \
    \        levels.append(level)\n        } else {\n            let level = levels.last\
    \ ?? 0\n            if level == substringRange.location - 1 {\n              \
    \  levels.append(level)\n            }\n        }\n    }\n    return levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpl59li9ve.swift:8:37: error: cannot find 'NSRegularExpression' in\
    \ scope\n    guard let parens_pattern = try? NSRegularExpression(pattern: \"\\\
    \\s\\\\(\\\\s*\\\\(([^()]*|\\\\([^()]*\\\\))*\\\\)\\\\s*\\\\)\\\\s\") else {\n\
    \                                    ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpl59li9ve.swift:13:76:\
    \ error: cannot find 'NSRange' in scope\n    guard let matchRange = parens_pattern.matches(in:\
    \ paren_string, range: NSRange(location: 0, length: paren_string.utf16.count))\
    \ else {\n                                                                   \
    \        ^~~~~~~\n/tmp/tmpl59li9ve.swift:16:42: error: cannot find 'NSRange' in\
    \ scope\n    paren_string.enumerateSubstrings(in: NSRange(location: matchRange.range.location,\
    \ length: paren_string.utf16.count)) { substring, substringRange, enclosingRange\
    \ in\n                                         ^~~~~~~\n/tmp/tmpl59li9ve.swift:16:18:\
    \ error: value of type 'String' has no member 'enumerateSubstrings'\n    paren_string.enumerateSubstrings(in:\
    \ NSRange(location: matchRange.range.location, length: paren_string.utf16.count))\
    \ { substring, substringRange, enclosingRange in\n    ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level: Int = 0\n    var nested: Int = 0\n    var\
    \ parensNestings = [Int]()\n\n    for char in paren_string.characters {\n    \
    \    if char == \"(\" {\n            level += 1\n            nested += 1\n   \
    \         parensNestings += [nested]\n        } else if char == \")\" {\n    \
    \        if parensNestings[level] == 1 {\n                level -= 1\n       \
    \         nested -= 1\n                parensNestings[level] += 1\n          \
    \  } else {\n                level -= 1\n            }\n        }\n    }\n   \
    \ return parensNestings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpn23jmr_l.swift:12:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in paren_string.characters {\n           \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = Int()\n    var level_stack: [Int] =\
    \ [0]\n    var opening_parens = 0\n    var max_nesting = 1\n\n    for i in paren_string.characters.reverse()\
    \ {\n        if paren_char(i) == \"(\" {\n            opening_parens += 1\n  \
    \      }\n        if paren_char(i) == \")\" {\n            opening_parens -= 1\n\
    \            if opening_parens > max_nesting {\n                max_nesting =\
    \ opening_parens\n            }\n            level_stack = append(level_stack,\
    \ opening_parens)\n        }\n    }\n    if opening_parens == 0 {\n        return\
    \ max_nesting\n    }\n    if opening_parens > max_nesting {\n        max_nesting\
    \ = opening_parens\n    }\n    for level in level_stack.reverse() {\n        if\
    \ level > max_level {\n            max_level = level\n        }\n    }\n    return\
    \ max_nesting\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpn12l252w.swift:13:38: error: value of type 'String' has no member\
    \ 'reverse'\n    for i in paren_string.characters.reverse() {\n             ~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpn12l252w.swift:26:16: error: cannot convert return expression\
    \ of type 'Int' to return type '[Int]'\n        return max_nesting\n         \
    \      ^~~~~~~~~~~\n/tmp/tmpn12l252w.swift:31:30: error: for-in loop requires\
    \ '()' to conform to 'Sequence'\n    for level in level_stack.reverse() {\n  \
    \               ~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmpn12l252w.swift:36:12: error: cannot\
    \ convert return expression of type 'Int' to return type '[Int]'\n    return max_nesting\n\
    \           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n    var level = 0\n    var parens_stack\
    \ = [Int]()\n\n    for char in paren_string.characters {\n        let _ = try!\
    \ parens_stack[level].append(Int(char))\n        level = (level + 1) % 4\n   \
    \     if level == 0 {\n            max_level = max(max_level, level)\n       \
    \ }\n    }\n\n    return parens_stack[max_level]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpp36v1fnp.swift:12:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in paren_string.characters {\n           \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpp36v1fnp.swift:13:49: error: no exact matches in call to initializer\
    \ \n        let _ = try! parens_stack[level].append(Int(char))\n             \
    \                                   ^\n/tmp/tmpp36v1fnp.swift:13:49: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'Character')\n       \
    \ let _ = try! parens_stack[level].append(Int(char))\n                       \
    \                         ^\n/tmp/tmpp36v1fnp.swift:13:49: note: candidate expects\
    \ value of type 'Float' for parameter #1 (got 'Character')\n        let _ = try!\
    \ parens_stack[level].append(Int(char))\n                                    \
    \            ^\n/tmp/tmpp36v1fnp.swift:13:49: note: candidate expects value of\
    \ type 'Double' for parameter #1 (got 'Character')\n        let _ = try! parens_stack[level].append(Int(char))\n\
    \                                                ^\n/tmp/tmpp36v1fnp.swift:13:49:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \        let _ = try! parens_stack[level].append(Int(char))\n                \
    \                                ^\n/tmp/tmpp36v1fnp.swift:13:49: note: candidate\
    \ expects value of type 'Builtin.Int64' for parameter #1 (got 'Character')\n \
    \       let _ = try! parens_stack[level].append(Int(char))\n                 \
    \                               ^\n/tmp/tmpp36v1fnp.swift:13:49: note: candidate\
    \ expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n  \
    \      let _ = try! parens_stack[level].append(Int(char))\n                  \
    \                              ^\n/tmp/tmpp36v1fnp.swift:13:34: error: no exact\
    \ matches in call to subscript \n        let _ = try! parens_stack[level].append(Int(char))\n\
    \                                 ^\n/tmp/tmpp36v1fnp.swift:13:34: note: candidate\
    \ ex"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let mut nesting = [Int]()\n    let mut level = 0\n\n\
    \    paren_string.split(\" \").forEach { str in\n        let (open_parens, close_parens)\
    \ = (str.characters.split{$0 == \")\"} as Array)[0]\n\n        if open_parens\
    \ == \"(\" && close_parens == \")\" {\n            nesting.append(level)\n   \
    \         level++\n        }\n    }\n    nesting.append(level)\n    return nesting\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpqy_0nfmu.swift:8:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut nesting\
    \ = [Int]()\n            ^\n/tmp/tmpqy_0nfmu.swift:8:13: note: join the identifiers\
    \ together\n    let mut nesting = [Int]()\n        ~~~~^~~~~~~\n        mutnesting\n\
    /tmp/tmpqy_0nfmu.swift:8:13: note: join the identifiers together with camel-case\n\
    \    let mut nesting = [Int]()\n        ~~~~^~~~~~~\n        mutNesting\n/tmp/tmpqy_0nfmu.swift:9:13:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n    let mut level = 0\n            ^\n/tmp/tmpqy_0nfmu.swift:9:13:\
    \ note: join the identifiers together\n    let mut level = 0\n        ~~~~^~~~~\n\
    \        mutlevel\n/tmp/tmpqy_0nfmu.swift:9:13: note: join the identifiers together\
    \ with camel-case\n    let mut level = 0\n        ~~~~^~~~~\n        mutLevel\n\
    /tmp/tmpqy_0nfmu.swift:9:9: error: invalid redeclaration of 'mut'\n    let mut\
    \ level = 0\n        ^\n/tmp/tmpqy_0nfmu.swift:8:9: note: 'mut' previously declared\
    \ here\n    let mut nesting = [Int]()\n        ^\n/tmp/tmpqy_0nfmu.swift:15:13:\
    \ error: cannot find 'nesting' in scope\n            nesting.append(level)\n \
    \           ^~~~~~~\n/tmp/tmpqy_0nfmu.swift:15:28: error: cannot find 'level'\
    \ in scope\n            nesting.append(level)\n                           ^~~~~\n\
    /tmp/tmpqy_0nfmu.swift:16:18: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            level++\n                 ^~\n/tmp/tmpqy_0nfmu.swift:16:13:\
    \ error: cannot find 'level' in scope\n            level++\n            ^~~~~\n\
    /tmp/tmpqy_0nfmu.swift:19:5: error: cannot find 'nesting' in scope\n    nesting.append(level)\n\
    \    ^~~~~~~\n/tmp/tmpqy_0nfmu.swift:19:20: error: cannot find 'level' in scope\n\
    \    nesting.append(level)\n                   ^~~~~\n/tmp/tmpqy_0nfmu.swift:20:12:\
    \ error: cannot find 'nesting' in scope\n    return nesting\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    if paren_string == \"\" {\n        return []\n    }\n\
    \    var level = 0\n    var maxLevel = Int(self.chars.count)\n    var output =\
    \ [Int]()\n    for ch in paren_string.unicodeScalars {\n        switch ch {\n\
    \        case .OpenParen, .CloseParen:\n            level += 1\n        case .OpenBrace:\n\
    \            if level == 1 {\n                output.append(maxLevel)\n      \
    \          level = 0\n            } else {\n                level -= 1\n     \
    \       }\n        case .CloseBrace:\n            if level == 0 {\n          \
    \      return nil\n            }\n            level -= 1\n        }\n        maxLevel\
    \ = level\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpubc46vrw.swift:12:24: error: cannot find 'self' in scope; did you\
    \ mean to use it in a type or extension context?\n    var maxLevel = Int(self.chars.count)\n\
    \                       ^~~~\n/tmp/tmpubc46vrw.swift:16:15: error: type 'Unicode.Scalar'\
    \ has no member 'OpenParen'\n        case .OpenParen, .CloseParen:\n         \
    \    ~^~~~~~~~~\n/tmp/tmpubc46vrw.swift:16:27: error: type 'Unicode.Scalar' has\
    \ no member 'CloseParen'\n        case .OpenParen, .CloseParen:\n            \
    \             ~^~~~~~~~~~\n/tmp/tmpubc46vrw.swift:18:15: error: type 'Unicode.Scalar'\
    \ has no member 'OpenBrace'\n        case .OpenBrace:\n             ~^~~~~~~~~\n\
    /tmp/tmpubc46vrw.swift:25:15: error: type 'Unicode.Scalar' has no member 'CloseBrace'\n\
    \        case .CloseBrace:\n             ~^~~~~~~~~~\n/tmp/tmpubc46vrw.swift:27:24:\
    \ error: 'nil' is incompatible with return type '[Int]'\n                return\
    \ nil\n                       ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tvar max_nesting = 0\n\tnesting_counter := 0\n\tvar max_nesting_level\
    \ [11]int\n\n\t// The input string represents a bunch of groups of parentheses.\n\
    \t// For example, the string \"(()) ()\" represents a group of two parentheses.\n\
    \t// The group \"(()) ()\" has one level of nesting.\n\t// We need to find all\
    \ such groups and find the level of nesting in each group.\n\t// For each group,\
    \ we need to find the level of nesting in all groups before it.\n\t// That means,\
    \ we need to find the level of nesting in all groups after it.\n\tfor _, s :=\
    \ range strings.Split(paren_string, \" \") {\n\t\tnesting_level, _ := count_nested_parentheses(s)\n\
    \t\tif nesting_level > max_nesting {\n\t\t\tmax_nesting = nesting_level\n\t\t\
    }\n\t\tif nesting_level == max_nesting {\n\t\t\tmax_nesting_level[nesting_counter]\
    \ = nesting_level\n\t\t}\n\t\tnesting_counter += 1\n\t}\n\n\tmax_nesting_level[0]\
    \ += 1\n\n\treturn max_nesting_level\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpx8pfy9co.swift:9:17: error: consecutive statements on a line must\
    \ be separated by ';'\n        nesting_counter := 0\n                       ^\n\
    \                       ;\n/tmp/tmpx8pfy9co.swift:9:18: error: expected expression\n\
    \        nesting_counter := 0\n                        ^\n/tmp/tmpx8pfy9co.swift:10:23:\
    \ error: consecutive statements on a line must be separated by ';'\n        var\
    \ max_nesting_level [11]int\n                             ^\n                \
    \             ;\n/tmp/tmpx8pfy9co.swift:10:28: error: consecutive statements on\
    \ a line must be separated by ';'\n        var max_nesting_level [11]int\n   \
    \                               ^\n                                  ;\n/tmp/tmpx8pfy9co.swift:18:7:\
    \ error: expected 'in' after for-each pattern\n        for _, s := range strings.Split(paren_string,\
    \ \" \") {\n             ^\n/tmp/tmpx8pfy9co.swift:18:7: error: expected Sequence\
    \ expression for for-each loop\n        for _, s := range strings.Split(paren_string,\
    \ \" \") {\n             ^\n/tmp/tmpx8pfy9co.swift:19:16: error: consecutive statements\
    \ on a line must be separated by ';'\n                nesting_level, _ := count_nested_parentheses(s)\n\
    \                             ^\n                             ;\n/tmp/tmpx8pfy9co.swift:19:16:\
    \ error: expected expression\n                nesting_level, _ := count_nested_parentheses(s)\n\
    \                             ^\n/tmp/tmpx8pfy9co.swift:9:2: error: cannot find\
    \ 'nesting_counter' in scope\n        nesting_counter := 0\n        ^~~~~~~~~~~~~~~\n\
    /tmp/tmpx8pfy9co.swift:10:6: error: type annotation missing in pattern\n     \
    \   var max_nesting_level [11]int\n            ^\n/tmp/tmpx8pfy9co.swift:10:24:\
    \ warning: expression of type '[Int]' is unused\n        var max_nesting_level\
    \ [11]int\n                              ^~~~\n/tmp/tmpx8pfy9co.swift:10:28: error:\
    \ cannot find 'int' in scope\n        var max_nesting_level [11]int\n        \
    \                          ^~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var results: [Int] = []\n    var level = 0\n    for\
    \ c in paren_string.characters {\n        if c == '(' {\n            level++\n\
    \        } else if c == ')' {\n            level--\n            if level == 0\
    \ {\n                results.append(level)\n            }\n        }\n    }\n\
    \    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmprk9e6h_8.swift:11:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmprk9e6h_8.swift:13:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmprk9e6h_8.swift:10:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    for c in paren_string.characters {\n       \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmprk9e6h_8.swift:12:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            level++\n                 ^~\n/tmp/tmprk9e6h_8.swift:14:18:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  level--\n                 ^~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var paren_count = 0\n    var levels = [Int]()\n    var\
    \ level = 0\n    for c in paren_string.characters {\n        if c == '(' {\n \
    \           paren_count++\n        } else if c == ')' {\n            levels[level]\
    \ = paren_count\n            level++\n            paren_count--\n        }\n \
    \   }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpj2mvegjj.swift:12:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpj2mvegjj.swift:14:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpj2mvegjj.swift:11:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    for c in paren_string.characters {\n       \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpj2mvegjj.swift:13:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            paren_count++\n                       ^~\n\
    /tmp/tmpj2mvegjj.swift:16:18: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            level++\n                 ^~\n/tmp/tmpj2mvegjj.swift:17:24:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  paren_count--\n                       ^~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n  var paren_depth = 0\n  var paren_level = 0\n  var paren_count\
    \ = [Int](repeating: 0, count: 2)\n\n  for char in paren_string.characters {\n\
    \    if char == \")\" {\n      if paren_depth == 0 {\n        paren_depth++\n\
    \        paren_level++\n        paren_count[paren_level] = paren_depth\n     \
    \ } else {\n        if paren_depth == paren_count[paren_level] {\n          paren_depth++\n\
    \        } else {\n          paren_depth--\n        }\n        paren_level--\n\
    \      }\n    }\n  }\n\n  return paren_count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptm63b4l3.swift:12:28: error: 'characters' is unavailable: Please\
    \ use String directly\n  for char in paren_string.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmptm63b4l3.swift:15:20: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        paren_depth++\n                   ^~\n/tmp/tmptm63b4l3.swift:16:20:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        paren_level++\n\
    \                   ^~\n/tmp/tmptm63b4l3.swift:20:22: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n          paren_depth++\n             \
    \        ^~\n/tmp/tmptm63b4l3.swift:22:22: error: cannot find operator '--' in\
    \ scope; did you mean '-= 1'?\n          paren_depth--\n                     ^~\n\
    /tmp/tmptm63b4l3.swift:24:20: error: cannot find operator '--' in scope; did you\
    \ mean '-= 1'?\n        paren_level--\n                   ^~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_count = 0\n    var max_level = 0\n    var level\
    \ = 0\n    var opening_parens = paren_string.count(\"(\")\n    var closing_parens\
    \ = paren_string.count(\")\")\n    var count = 0\n    var result = [0]\n    for\
    \ i in 0 ..< paren_string.count {\n        let open = paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)\n        let close = paren_string.index(paren_string.startIndex,\
    \ offsetBy: i+1)\n        if paren_string[open] == \"(\" && paren_string[close]\
    \ == \")\" {\n            count += 1\n        } else {\n            count -= 1\n\
    \        }\n        result[count] = result[count] + 1\n        if count > max_count\
    \ && result[count] > max_level {\n            max_count = result[count]\n    \
    \        max_level = result[count]\n        }\n    }\n    for index in 0 ..< result.count\
    \ {\n        if result[index] == max_level {\n            result.remove(at: index)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpk18y85z7.swift:11:39: error: cannot call value of non-function\
    \ type 'Int'\n    var opening_parens = paren_string.count(\"(\")\n           \
    \                           ^\n/tmp/tmpk18y85z7.swift:12:39: error: cannot call\
    \ value of non-function type 'Int'\n    var closing_parens = paren_string.count(\"\
    )\")\n                                      ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    paren_string = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    let brackets = [Character](paren_string)\n    var level = 0\n    var stack\
    \ = [Character]()\n    for b in brackets {\n        if b == '(' { stack.append(b)\
    \ }\n        else if b == ')' {\n            let len = stack.count\n         \
    \   if len > 0 {\n                if len > level {\n                    level\
    \ = len\n                }\n                stack.removeLast()\n            }\n\
    \        }\n    }\n    return [level]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpaokp5cpz.swift:13:17: error: single-quoted string literal found,\
    \ use '\"'\n        if b == '(' { stack.append(b) }\n                ^~~\n   \
    \             \"(\"\n/tmp/tmpaokp5cpz.swift:14:22: error: single-quoted string\
    \ literal found, use '\"'\n        else if b == ')' {\n                     ^~~\n\
    \                     \")\"\n/tmp/tmpaokp5cpz.swift:8:56: error: cannot find 'CharacterSet'\
    \ in scope\n    paren_string = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                                       ^~~~~~~~~~~~\n/tmp/tmpaokp5cpz.swift:8:5:\
    \ error: cannot assign to value: 'paren_string' is a 'let' constant\n    paren_string\
    \ = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    ^~~~~~~~~~~~\n/tmp/tmpaokp5cpz.swift:8:33: error: value of type 'String'\
    \ has no member 'trimmingCharacters'\n    paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n                   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level_stack: [Int] = [Int]()\n\
    \n    for c in paren_string.unicodeScalars {\n        if c.value == UnicodeScalar(BracketLeft)\
    \ {\n            var level = 0\n            for _ in level_stack {\n         \
    \       level++\n            }\n            level_stack = append(level_stack,\
    \ 0, level)\n        } else if c.value == UnicodeScalar(BracketRight) {\n    \
    \        var level = 0\n            for level in level_stack {\n             \
    \   level--\n                if level < 0 {\n                    level_stack =\
    \ levels[level+1:] + levels[:level+1]\n                    break\n           \
    \     }\n            }\n        }\n    }\n\n    return levels\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp_7pws7qq.swift:23:49: error: expected ',' separator\n         \
    \           level_stack = levels[level+1:] + levels[:level+1]\n              \
    \                                  ^\n                                       \
    \         ,\n/tmp/tmp_7pws7qq.swift:23:49: error: expected expression in list\
    \ of expressions\n                    level_stack = levels[level+1:] + levels[:level+1]\n\
    \                                                ^\n/tmp/tmp_7pws7qq.swift:23:61:\
    \ error: expected expression in list of expressions\n                    level_stack\
    \ = levels[level+1:] + levels[:level+1]\n                                    \
    \                        ^\n/tmp/tmp_7pws7qq.swift:12:37: error: cannot find 'BracketLeft'\
    \ in scope\n        if c.value == UnicodeScalar(BracketLeft) {\n             \
    \                       ^~~~~~~~~~~\n/tmp/tmp_7pws7qq.swift:12:20: error: operator\
    \ function '==' requires that 'UnicodeScalar' (aka 'Unicode.Scalar') conform to\
    \ 'BinaryInteger'\n        if c.value == UnicodeScalar(BracketLeft) {\n      \
    \             ^\nSwift.BinaryInteger:2:24: note: where 'Other' = 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    public static func == <Other>(lhs: Self, rhs: Other)\
    \ -> Bool where Other : BinaryInteger\n                       ^\n/tmp/tmp_7pws7qq.swift:15:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      level++\n                     ^~\n/tmp/tmp_7pws7qq.swift:17:27: error:\
    \ cannot find 'append' in scope\n            level_stack = append(level_stack,\
    \ 0, level)\n                          ^~~~~~\n/tmp/tmp_7pws7qq.swift:18:44: error:\
    \ cannot find 'BracketRight' in scope\n        } else if c.value == UnicodeScalar(BracketRight)\
    \ {\n                                           ^~~~~~~~~~~~\n/tmp/tmp_7pws7qq.swift:18:27:\
    \ error: operator function '==' requires that 'UnicodeScalar' (aka 'Unicode.Scalar')\
    \ conform to 'BinaryInteger'\n        } else if c.value == UnicodeScalar(BracketRight)\
    \ {\n                          ^\nSwift.BinaryInteger:2:24: note: where 'Other'\
    \ = 'UnicodeScalar' (aka 'Unicode.Scalar')\n    public static "
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var curr_level = 0\n    for\
    \ c in paren_string.unicodeScalars {\n        switch c.value {\n        case paren_char.openParen:\n\
    \            levels[curr_level] = Int.max\n            curr_level++\n        case\
    \ paren_char.closeParen:\n            curr_level--\n        }\n    }\n    return\
    \ levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmplvh3e3gw.swift:12:14: error: cannot find 'paren_char' in scope\n\
    \        case paren_char.openParen:\n             ^~~~~~~~~~\n/tmp/tmplvh3e3gw.swift:15:14:\
    \ error: cannot find 'paren_char' in scope\n        case paren_char.closeParen:\n\
    \             ^~~~~~~~~~\n/tmp/tmplvh3e3gw.swift:14:23: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            curr_level++\n            \
    \          ^~\n/tmp/tmplvh3e3gw.swift:16:23: error: cannot find operator '--'\
    \ in scope; did you mean '-= 1'?\n            curr_level--\n                 \
    \     ^~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tparen_string = paren_string.trim()\n\tparen_string = paren_string.replace(\"\
    ()\", \"\")\n\n\tvar paren_count = 0\n\tvar nesting_level = 0\n\n\tvar max_level\
    \ = 0\n\n\tvar result_array = [Int]()\n\n\tfor char in paren_string.characters\
    \ {\n\t\tswitch char {\n\t\tcase \"(\":\n\t\t\tparen_count += 1\n\t\t\tnesting_level\
    \ += 1\n\t\t\tif nesting_level > max_level {\n\t\t\t\tmax_level = nesting_level\n\
    \t\t\t}\n\t\tcase \")\":\n\t\t\tparen_count -= 1\n\t\t\tnesting_level -= 1\n\t\
    \t\tif nesting_level < 0 {\n\t\t\t\tnesting_level = 0\n\t\t\t}\n\t\t}\n\t\tresult_array.append(paren_count)\n\
    \t}\n\n\treturn result_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp_p1j9m7q.swift:8:2: error: cannot assign to value: 'paren_string'\
    \ is a 'let' constant\n        paren_string = paren_string.trim()\n        ^~~~~~~~~~~~\n\
    /tmp/tmp_p1j9m7q.swift:8:30: error: value of type 'String' has no member 'trim'\n\
    \        paren_string = paren_string.trim()\n                       ~~~~~~~~~~~~\
    \ ^~~~\n/tmp/tmp_p1j9m7q.swift:9:2: error: cannot assign to value: 'paren_string'\
    \ is a 'let' constant\n        paren_string = paren_string.replace(\"()\", \"\"\
    )\n        ^~~~~~~~~~~~\n/tmp/tmp_p1j9m7q.swift:9:30: error: cannot assign value\
    \ of type '()' to type 'String'\n        paren_string = paren_string.replace(\"\
    ()\", \"\")\n                       ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~\n/tmp/tmp_p1j9m7q.swift:9:30:\
    \ error: cannot use mutating member on immutable value: 'paren_string' is a 'let'\
    \ constant\n        paren_string = paren_string.replace(\"()\", \"\")\n      \
    \                 ~~~~~~~~~~~~ ^\n/tmp/tmp_p1j9m7q.swift:9:37: error: missing\
    \ argument label 'with:' in call\n        paren_string = paren_string.replace(\"\
    ()\", \"\")\n                                           ^\n                  \
    \                                with: \n/tmp/tmp_p1j9m7q.swift:18:27: error:\
    \ 'characters' is unavailable: Please use String directly\n        for char in\
    \ paren_string.characters {\n                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp_p1j9m7q.swift:19:3: error: switch must\
    \ be exhaustive\n                switch char {\n                ^\n/tmp/tmp_p1j9m7q.swift:19:3:\
    \ note: do you want to add a default clause?\n                switch char {\n\
    \                ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Remove all spaces.\n    paren_string = paren_string.trimmingCharacters(in:\
    \ NSCharacterSet.whitespaces)\n\n    var levels: [Int] = []\n\n    // First we\
    \ find parentheses levels that we already have levels.\n    func getDepth(_ currentDepth:\
    \ Int, _ lastDepth: Int) -> Int {\n        if lastDepth > currentDepth {\n   \
    \         return currentDepth + 1\n        }\n        return lastDepth\n    }\n\
    \n    // Find the parentheses levels that we already have levels.\n    for i in\
    \ 0 ..< paren_string.characters.count {\n        if paren_string[i] == '(' ||\
    \ paren_string[i] == '{' || paren_string[i] == '[' {\n            let currentDepth\
    \ = levels.count\n            levels.append(currentDepth)\n        }\n    }\n\n\
    \    // Now we do the nesting recursively.\n    let nestedCounts = paren_string.characters.enumerated().filter({\
    \ $0.element == '(' })\n    nestedCounts.forEach({ nestedCount in\n        if\
    \ let openingParenthesis = nestedCount.element {\n            // Look for closing\
    \ parenthesis.\n            let lastDepth = levels.count\n            nestedCounts\
    \ = paren_string.characters.enumerated().filter({ $0.element == ')' })\n     \
    \       nestedCounts.forEach({ nestedCount2 in\n                if let closingParenthesis\
    \ = nestedCount2.element {\n                    let newDepth = getDepth(currentDepth,\
    \ lastDepth)\n                    levels.append(newDepth)\n                }\n\
    \            })\n        }\n    })\n\n    return levels\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpkf3hsv1e.swift:23:31: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[i] == '(' || paren_string[i] == '{' || paren_string[i]\
    \ == '[' {\n                              ^~~\n                              \"\
    (\"\n/tmp/tmpkf3hsv1e.swift:23:57: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[i] == '(' || paren_string[i] == '{' || paren_string[i]\
    \ == '[' {\n                                                        ^~~\n    \
    \                                                    \"{\"\n/tmp/tmpkf3hsv1e.swift:23:83:\
    \ error: single-quoted string literal found, use '\"'\n        if paren_string[i]\
    \ == '(' || paren_string[i] == '{' || paren_string[i] == '[' {\n             \
    \                                                                     ^~~\n  \
    \                                                                            \
    \    \"[\"\n/tmp/tmpkf3hsv1e.swift:30:84: error: single-quoted string literal\
    \ found, use '\"'\n    let nestedCounts = paren_string.characters.enumerated().filter({\
    \ $0.element == '(' })\n                                                     \
    \                              ^~~\n                                         \
    \                                          \"(\"\n/tmp/tmpkf3hsv1e.swift:35:88:\
    \ error: single-quoted string literal found, use '\"'\n            nestedCounts\
    \ = paren_string.characters.enumerated().filter({ $0.element == ')' })\n     \
    \                                                                            \
    \      ^~~\n                                                                 \
    \                      \")\"\n/tmp/tmpkf3hsv1e.swift:9:56: error: cannot find\
    \ 'NSCharacterSet' in scope\n    paren_string = paren_string.trimmingCharacters(in:\
    \ NSCharacterSet.whitespaces)\n                                              \
    \         ^~~~~~~~~~~~~~\n/tmp/tmpkf3hsv1e.swift:9:5: error: cannot assign to\
    \ value: 'paren_string' is a 'let' constant\n    paren_string = paren_string.trimmingCharacters(in:\
    \ NSCharacterSet.whitespaces)\n    ^~~~~~~~~~~~\n/tmp/tmpkf3hsv1e.swift:9:33:\
    \ error: value of type 'String'"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var result = [Int]()\n    paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n    var opening = false\n    var opening_count\
    \ = 1\n    var stack = [String]()\n    stack.append(\"\")\n    for char in paren_string.unicodeScalars\
    \ {\n        let char_str = String(char)\n        if char == '(' {\n         \
    \   if opening_count < stack[stack.count - 1].characters.count {\n           \
    \     opening_count++\n                opening = true\n            }\n       \
    \ } else if char == ')' {\n            if opening_count == stack[stack.count -\
    \ 1].characters.count {\n                opening = false\n                opening_count--\n\
    \            }\n        } else if opening {\n            if char_str != \" \"\
    \ {\n                stack.append(char_str)\n            }\n        } else {\n\
    \            if opening_count != stack[stack.count - 1].characters.count {\n \
    \               result.append((opening_count - stack[stack.count - 1].characters.count))\n\
    \            }\n            result.append((stack.count - 1))\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpubnb6rgo.swift:16:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' {\n                   ^~~\n               \
    \    \"(\"\n/tmp/tmpubnb6rgo.swift:21:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ')' {\n                         \
    \ ^~~\n                          \")\"\n/tmp/tmpubnb6rgo.swift:9:56: error: cannot\
    \ find 'CharacterSet' in scope\n    paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n                                     \
    \                  ^~~~~~~~~~~~\n/tmp/tmpubnb6rgo.swift:9:5: error: cannot assign\
    \ to value: 'paren_string' is a 'let' constant\n    paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n    ^~~~~~~~~~~~\n/tmp/tmpubnb6rgo.swift:9:33:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    paren_string\
    \ = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpubnb6rgo.swift:17:55:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if opening_count < stack[stack.count - 1].characters.count {\n             \
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpubnb6rgo.swift:18:30: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                opening_count++\n\
    \                             ^~\n/tmp/tmpubnb6rgo.swift:22:56: error: 'characters'\
    \ is unavailable: Please use String directly\n            if opening_count ==\
    \ stack[stack.count - 1].characters.count {\n                                \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpubnb6rgo.swift:24:30: error: cannot find operator '--'\
    \ in scope; did you mean '-= 1'?\n                opening_count--\n          \
    \                   ^~\n/tmp/tmpubnb6rg"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level: [Int] = [0]\n    var levels: [(Int, Int)]\
    \ = [(0, 0)]\n    var pos: Int = 0\n    for paren in\n        paren_string.split(separator:\
    \ \" \", omittingEmptySubsequences: true)\n    {\n        if paren == \"\" {\n\
    \            continue\n        }\n        var parentheses = paren.split(separator:\
    \ \")\", omittingEmptySubsequences: true)\n        for paren in parentheses {\n\
    \            levels[level[0]] = level[0] + 1, level[0]\n            level[0] +=\
    \ 1\n            pos += paren.count\n        }\n        pos += level[0]\n    \
    \    level[0] += 1\n    }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpy50e1161.swift:19:44: error: consecutive statements on a line must\
    \ be separated by ';'\n            levels[level[0]] = level[0] + 1, level[0]\n\
    \                                           ^\n                              \
    \             ;\n/tmp/tmpy50e1161.swift:19:44: error: expected expression\n  \
    \          levels[level[0]] = level[0] + 1, level[0]\n                       \
    \                    ^\n/tmp/tmpy50e1161.swift:19:41: error: cannot assign value\
    \ of type 'Int' to subscript of type '(Int, Int)'\n            levels[level[0]]\
    \ = level[0] + 1, level[0]\n                               ~~~~~~~~~^~~\n/tmp/tmpy50e1161.swift:26:12:\
    \ error: cannot convert return expression of type '[(Int, Int)]' to return type\
    \ '[Int]'\n    return levels\n           ^\n/tmp/tmpy50e1161.swift:26:12: note:\
    \ arguments to generic parameter 'Element' ('(Int, Int)' and 'Int') are expected\
    \ to be equal\n    return levels\n           ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    if paren_string.contains(\" \") || paren_string.contains(\"\
    (\") || paren_string.contains(\")\")\n    {\n        let nested_parens = paren_string.components(separatedBy:\
    \ \" \")\n        var levels = Array<Int>()\n        \n        for paren in nested_parens\n\
    \        {\n            if paren.contains(\"(\")\n            {\n            \
    \    var count = levels[0]\n                levels[0] = levels[0]+1\n        \
    \        for i in 0 ..< (nested_parens.index(paren)+1)\n                {\n  \
    \                  count = (levels[i+1] > count) ? levels[i+1] : count\n     \
    \               levels[i+1] = count\n                }\n            }\n      \
    \      else if paren.contains(\")\")\n            {\n                levels.append(levels[0]-1)\n\
    \                levels[0] = levels[0]-1\n            }\n        }\n        \n\
    \        return levels\n    }\n    return [Int.random(in: 0..<3)]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpg2hpacgu.swift:10:42: error: value of type 'String' has no member\
    \ 'components'\n        let nested_parens = paren_string.components(separatedBy:\
    \ \" \")\n                            ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max = 0\n    for _, group := range paren_string.Split()\
    \ {\n        let level = level(group)\n        max = max > level ? max : level\n\
    \    }\n    return [max]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvvmfxrea.swift:9:10: error: expected 'in' after for-each pattern\n\
    \    for _, group := range paren_string.Split() {\n         ^\n/tmp/tmpvvmfxrea.swift:9:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, group := range\
    \ paren_string.Split() {\n         ^\n/tmp/tmpvvmfxrea.swift:10:21: error: use\
    \ of local variable 'level' before its declaration\n        let level = level(group)\n\
    \                    ^\n/tmp/tmpvvmfxrea.swift:10:13: note: 'level' declared here\n\
    \        let level = level(group)\n            ^\n/tmp/tmpvvmfxrea.swift:10:27:\
    \ error: cannot find 'group' in scope\n        let level = level(group)\n    \
    \                      ^~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var level_stack = [Int]()\n\
    \    for ch in paren_string {\n        // We hit the right paren, increment our\
    \ stack and push our depth onto our stack\n        if ch == \")\" {\n        \
    \    levels.append(level_stack.pop())\n            level_stack.append(0)\n   \
    \     }\n        // We hit a left paren, decrease our stack and pop our depth\
    \ off our stack\n        else if ch == \"(\" {\n            level_stack.pop()\n\
    \        }\n        // We hit a space, we found an opening paranthesis and are\
    \ about to start a new level, push our depth onto the stack\n        else if ch\
    \ == \" \" {\n            level_stack.append(0)\n        }\n    }\n    // This\
    \ should never happen if our paren string was well-formed and we didn't hit any\
    \ paren mismatches.\n    assert(levels == nil)\n    return level_stack\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpm1pf_ce5.swift:13:39: error: value of type '[Int]' has no member\
    \ 'pop'\n            levels.append(level_stack.pop())\n                      \
    \    ~~~~~~~~~~~ ^~~\n/tmp/tmpm1pf_ce5.swift:18:25: error: value of type '[Int]'\
    \ has no member 'pop'\n            level_stack.pop()\n            ~~~~~~~~~~~\
    \ ^~~\n/tmp/tmpm1pf_ce5.swift:26:19: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    assert(levels == nil)\n    \
    \       ~~~~~~ ^  ~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let split_strings = paren_string.split(\" \").map(String.init)\n\
    \    var max_nesting = 0\n    for split_string in split_strings {\n        guard\
    \ split_string.count > 0 else {\n            return [0]\n        }\n        let\
    \ count = parseNestedParens(split_string).count\n        if count > max_nesting\
    \ {\n            max_nesting = count\n        }\n    }\n    return [max_nesting]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpy6hhiwc0.swift:8:38: error: no exact matches in call to instance\
    \ method 'split'\n    let split_strings = paren_string.split(\" \").map(String.init)\n\
    \                                     ^\nSwift.Sequence:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n    \
    \                                   ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmpy6hhiwc0.swift:14:21: error: cannot find\
    \ 'parseNestedParens' in scope\n        let count = parseNestedParens(split_string).count\n\
    \                    ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var paren_count = 0\n    var stack = 0\n    var max_nesting\
    \ = -1\n    for _, c in paren_string.characters {\n        if c == '(' {\n   \
    \         paren_count += 1\n            stack++\n        } else if c == '(' &&\
    \ paren_count > 0 {\n            paren_count -= 1\n            stack++\n     \
    \   } else if c == ')' && paren_count > 0 {\n            paren_count -= 1\n  \
    \          if stack > max_nesting {\n                max_nesting = stack\n   \
    \         }\n        } else if c == ')' && paren_count == 0 {\n            stack--\n\
    \        }\n    }\n    return max_nesting + 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi4eld1ly.swift:11:10: error: expected 'in' after for-each pattern\n\
    \    for _, c in paren_string.characters {\n         ^\n/tmp/tmpi4eld1ly.swift:11:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, c in paren_string.characters\
    \ {\n         ^\n/tmp/tmpi4eld1ly.swift:12:17: error: single-quoted string literal\
    \ found, use '\"'\n        if c == '(' {\n                ^~~\n              \
    \  \"(\"\n/tmp/tmpi4eld1ly.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n        } else if c == '(' && paren_count > 0 {\n                \
    \       ^~~\n                       \"(\"\n/tmp/tmpi4eld1ly.swift:18:24: error:\
    \ single-quoted string literal found, use '\"'\n        } else if c == ')' &&\
    \ paren_count > 0 {\n                       ^~~\n                       \")\"\n\
    /tmp/tmpi4eld1ly.swift:23:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == ')' && paren_count == 0 {\n                       ^~~\n\
    \                       \")\"\n/tmp/tmpi4eld1ly.swift:27:24: error: cannot convert\
    \ return expression of type 'Int' to return type '[Int]'\n    return max_nesting\
    \ + 1\n           ~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tvar level = 0\n\tvar max_level = 0\n\tvar paren_levels\
    \ = [Int]()\n\tparen_string.split(\" \").forEach() {\n\t\tparen_levels[level]\
    \ = paren_levels[level] + 1\n\t\tif paren_levels[level] > max_level {\n\t\t\t\
    max_level = paren_levels[level]\n\t\t}\n\t\tlevel = level + 1\n\t}\n\treturn max_level\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpl8eqc47n.swift:11:15: error: no exact matches in call to instance\
    \ method 'split'\n        paren_string.split(\" \").forEach() {\n            \
    \         ^\n/tmp/tmpl8eqc47n.swift:11:15: note: candidate has partially matching\
    \ parameter list (separator: String.Element, maxSplits: Int, omittingEmptySubsequences:\
    \ Bool)\n        paren_string.split(\" \").forEach() {\n                     ^\n\
    /tmp/tmpl8eqc47n.swift:11:15: note: candidate has partially matching parameter\
    \ list (separator: String.Element, maxSplits: Int, omittingEmptySubsequences:\
    \ Bool)\n        paren_string.split(\" \").forEach() {\n                     ^\n\
    /tmp/tmpl8eqc47n.swift:11:36: error: contextual type for closure argument list\
    \ expects 1 argument, which cannot be implicitly ignored\n        paren_string.split(\"\
    \ \").forEach() {\n                                          ^\n             \
    \                              _ in \n/tmp/tmpl8eqc47n.swift:18:9: error: cannot\
    \ convert return expression of type 'Int' to return type '[Int]'\n        return\
    \ max_level\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var maxLevel = 0\n    for _ in paren_string.characters\
    \ {\n        level += 1\n        if level > maxLevel {\n            maxLevel =\
    \ level\n        }\n    }\n    var maxLevel_array = [Int](repeating: 0, count:\
    \ maxLevel)\n    for index in 0..<paren_string.characters.count {\n        if\
    \ paren_string.substring(from: index, length: 1) == \")\" {\n            level\
    \ -= 1\n        }\n        maxLevel_array[level] += 1\n    }\n    return maxLevel_array\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpaly_3wl1.swift:10:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for _ in paren_string.characters {\n              \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpaly_3wl1.swift:17:35: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<paren_string.characters.count {\n           \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpaly_3wl1.swift:18:25: error: value of type 'String' has\
    \ no member 'substring'\n        if paren_string.substring(from: index, length:\
    \ 1) == \")\" {\n           ~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var nesting_level = 0\n  \
    \  var prev_char: Char?\n    var current_char: Char?\n    for c in paren_string.unicodeScalars\
    \ {\n        if c == '(' {\n            nesting_level += 1\n            if nesting_level\
    \ > levels[nesting_level] {\n                levels[nesting_level] = nesting_level\n\
    \            }\n        }\n        else if c == ')' {\n            nesting_level\
    \ -= 1\n            if nesting_level < levels[nesting_level] {\n             \
    \   levels[nesting_level] = nesting_level\n            }\n        }\n        if\
    \ nesting_level != 0 {\n            prev_char = current_char\n        }\n    \
    \    current_char = c\n    }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpe5otihrn.swift:13:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpe5otihrn.swift:19:22: error: single-quoted string literal found, use '\"\
    '\n        else if c == ')' {\n                     ^~~\n                    \
    \ \")\"\n/tmp/tmpe5otihrn.swift:10:20: error: cannot find type 'Char' in scope\n\
    \    var prev_char: Char?\n                   ^~~~\n/tmp/tmpe5otihrn.swift:11:23:\
    \ error: cannot find type 'Char' in scope\n    var current_char: Char?\n     \
    \                 ^~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var levels = [Int]()\n\n    for s\
    \ in paren_string.characters {\n        if s == \")\" {\n            levels[level]\
    \ = level\n            level = 0\n        }\n\n        level += 1\n    }\n\n \
    \   return levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpo0dk7gp0.swift:11:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in paren_string.characters {\n              \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_nesting_level = 0\n    var nested_levels = [Int]()\n\
    \    var parens = paren_string.characters\n    var paren_counter: Int = 0\n  \
    \  var last_paren_level = 0\n    for paren in parens {\n        paren_counter\
    \ += 1\n        let paren_level = paren_counter\n        last_paren_level = paren_level\n\
    \        nested_levels.append(last_paren_level)\n        if paren_level > max_nesting_level\
    \ {\n            max_nesting_level = paren_level\n        }\n    }\n    return\
    \ nested_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdpihdunh.swift:10:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    var parens = paren_string.characters\n            \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpdpihdunh.swift:10:9: warning: variable 'parens' was never mutated;\
    \ consider changing to 'let' constant\n    var parens = paren_string.characters\n\
    \    ~~~ ^\n    let\n/tmp/tmpdpihdunh.swift:13:9: warning: immutable value 'paren'\
    \ was never used; consider replacing with '_' or removing it\n    for paren in\
    \ parens {\n        ^~~~~\n        _\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_count = 0\n    var max_level = 0\n    for i\
    \ in 0 ..< paren_string.count {\n        switch paren_string[i] {\n        case\
    \ \")\":\n            count += 1\n            if count > max_count {\n       \
    \         max_count = count\n                max_level = i\n            }\n  \
    \      case \")(\":\n            count -= 1\n            if count > max_count\
    \ {\n                max_count = count\n                max_level = i\n      \
    \      }\n        }\n    }\n    return Array(paren_string.characters\n       \
    \ .dropFirst(max_level + 1)\n        .prefix(max_level))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpzzxphrmx.swift:11:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        switch paren_string[i]\
    \ {\n               ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzzxphrmx.swift:18:14: error: expression\
    \ pattern of type 'String' cannot match values of type 'Character'\n        case\
    \ \")(\":\n             ^~~~\n/tmp/tmpzzxphrmx.swift:13:13: error: cannot find\
    \ 'count' in scope\n            count += 1\n            ^~~~~\n/tmp/tmpzzxphrmx.swift:14:16:\
    \ error: cannot find 'count' in scope\n            if count > max_count {\n  \
    \             ^~~~~\n/tmp/tmpzzxphrmx.swift:15:29: error: cannot find 'count'\
    \ in scope\n                max_count = count\n                            ^~~~~\n\
    /tmp/tmpzzxphrmx.swift:19:13: error: cannot find 'count' in scope\n          \
    \  count -= 1\n            ^~~~~\n/tmp/tmpzzxphrmx.swift:20:16: error: cannot\
    \ find 'count' in scope\n            if count > max_count {\n               ^~~~~\n\
    /tmp/tmpzzxphrmx.swift:21:29: error: cannot find 'count' in scope\n          \
    \      max_count = count\n                            ^~~~~\n/tmp/tmpzzxphrmx.swift:26:12:\
    \ error: no exact matches in call to initializer \n    return Array(paren_string.characters\n\
    \           ^\nSwift.Array:3:23: note: found candidate with type 'Array<PrefixSequence<DropFirstSequence<String>>.Iterator.Element>'\
    \ (aka 'Array<Character>')\n    @inlinable public init<S>(_ s: S) where Element\
    \ == S.Element, S : Sequence\n                      ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: found candidate with type 'Array<PrefixSequence<DropFirstSequence<String>>.Iterator.Element>'\
    \ (aka 'Array<Character>')\n    @inlinable public init<S>(_ elements: S) where\
    \ S : Sequence, Self.Element == S.Element\n                      ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var paren_depths: [Int] = []\n    for parens in paren_string.split(\"\
    \ \") {\n        if paren_depths.isEmpty {\n            paren_depths = paren_depths.reverse()\n\
    \        }\n        var paren_depth = 0\n        for paren in parens.characters\
    \ {\n            if paren == '(' {\n                paren_depth += 1\n       \
    \     } else if paren == ')' {\n                paren_depth -= 1\n           \
    \     if paren_depth == 0 {\n                    paren_depths.append(paren_depth)\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    return paren_depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp99zvr2ao.swift:15:25: error: single-quoted string literal found,\
    \ use '\"'\n            if paren == '(' {\n                        ^~~\n     \
    \                   \"(\"\n/tmp/tmp99zvr2ao.swift:17:32: error: single-quoted\
    \ string literal found, use '\"'\n            } else if paren == ')' {\n     \
    \                          ^~~\n                               \")\"\n/tmp/tmp99zvr2ao.swift:9:32:\
    \ error: no exact matches in call to instance method 'split'\n    for parens in\
    \ paren_string.split(\" \") {\n                               ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let paren_groups = paren_string.split(separator: \"\
    \ \")\n    \n    var level_counters: [Int] = [0, 0]\n    \n    for paren_group\
    \ in paren_groups {\n        let levels = paren_group.countElements\n        level_counters\
    \ = update_level_counters(level_counters, levels)\n    }\n    \n    return level_counters\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmplnupalcg.swift:13:34: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'countElements'\n        let levels = paren_group.countElements\n\
    \                     ~~~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmplnupalcg.swift:14:26:\
    \ error: cannot find 'update_level_counters' in scope\n        level_counters\
    \ = update_level_counters(level_counters, levels)\n                         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var result = [Int]()\n    var depth = 0\n    var opening_parens\
    \ = 0\n\n    for char in paren_string.characters {\n        switch char {\n  \
    \      case '(':\n            opening_parens++\n        case ')':\n          \
    \  opening_parens--\n            if opening_parens == 0 {\n                result.append(depth)\n\
    \                depth = 0\n            } else {\n                depth++\n  \
    \          }\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpfaokmqwq.swift:14:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '(':\n             ^~~\n             \"(\"\n/tmp/tmpfaokmqwq.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ')':\n   \
    \          ^~~\n             \")\"\n/tmp/tmpfaokmqwq.swift:12:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in paren_string.characters\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpfaokmqwq.swift:15:27: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            opening_parens++\n             \
    \             ^~\n/tmp/tmpfaokmqwq.swift:17:27: error: cannot find operator '--'\
    \ in scope; did you mean '-= 1'?\n            opening_parens--\n             \
    \             ^~\n/tmp/tmpfaokmqwq.swift:22:22: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n                depth++\n                  \
    \   ^~\n/tmp/tmpfaokmqwq.swift:13:9: error: switch must be exhaustive\n      \
    \  switch char {\n        ^\n/tmp/tmpfaokmqwq.swift:13:9: note: do you want to\
    \ add a default clause?\n        switch char {\n        ^\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    if paren_string == \"\" {\n        return []\n    }\n\
    \    let strings = paren_string.components(separatedBy: \" \")\n    \n    var\
    \ level = 0\n    \n    var paren_levels = [Int]()\n    var levels = [0]\n    \n\
    \    for paren in strings {\n        if paren == \"()\" {\n            level +=\
    \ 1\n            levels.append(level)\n            paren_levels.append(level)\n\
    \        } else if paren == \")\" {\n            if level > 0 {\n            \
    \    level -= 1\n                levels.append(level)\n                paren_levels.append(level)\n\
    \            } else {\n                paren_levels.append(levels[0])\n      \
    \      }\n        }\n    }\n    \n    return paren_levels\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp1j0njdvk.swift:11:32: error: value of type 'String' has no member\
    \ 'components'\n    let strings = paren_string.components(separatedBy: \" \")\n\
    \                  ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_levels = 0\n    var level = 0\n    func is_closed_paren(x:\
    \ String) -> Bool {\n        return x.characters.count == 1 && (x == \"(\") ||\
    \ (x == \")\")\n    }\n    for x in paren_string.characters {\n        if is_closed_paren(x)\
    \ {\n            level--\n            if level > max_levels {\n              \
    \  max_levels = level\n            }\n        } else {\n            level++\n\
    \        }\n    }\n    return Array(1...max_levels).map { _ in 0 }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmphimzfclg.swift:11:18: error: 'characters' is unavailable: Please\
    \ use String directly\n        return x.characters.count == 1 && (x == \"(\")\
    \ || (x == \")\")\n                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphimzfclg.swift:13:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    for x in paren_string.characters {\n       \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphimzfclg.swift:14:28: error: missing argument label 'x:' in call\n\
    \        if is_closed_paren(x) {\n                           ^\n             \
    \              x: \n/tmp/tmphimzfclg.swift:14:28: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n        if is_closed_paren(x)\
    \ {\n                           ^\n/tmp/tmphimzfclg.swift:15:18: error: cannot\
    \ find operator '--' in scope; did you mean '-= 1'?\n            level--\n   \
    \              ^~\n/tmp/tmphimzfclg.swift:20:18: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            level++\n                 ^~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level: [Int] = []\n    var stack = [Character.UnicodeScalarView]()\n\
    \    for char in paren_string.unicodeScalars {\n        switch char {\n      \
    \  case \"(\":\n            stack.append(char)\n        case \"(\":\n        \
    \    if stack.count == 0 {\n                return nil\n            }\n      \
    \      level.append(stack.count - 1)\n            stack.removeLast()\n       \
    \ case \"(\":\n            stack.removeLast()\n            level.append(stack.count\
    \ - 1)\n        default:\n            if stack.count == 0 {\n                return\
    \ nil\n            }\n            stack.removeLast()\n        }\n    }\n    if\
    \ stack.count != 0 {\n        return nil\n    }\n    return level\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8fcd_cds.swift:13:19: error: no exact matches in call to instance\
    \ method 'append'\n            stack.append(char)\n                  ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'Character.UnicodeScalarView' (aka 'String.UnicodeScalarView')\
    \ for parameter #1 (got 'Unicode.Scalar')\n    @inlinable public mutating func\
    \ append(_ newElement: __owned Element)\n                                    ^\n\
    Swift.RangeReplaceableCollection:4:37: note: candidate expects value of type 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView') for parameter #1 (got 'Unicode.Scalar')\n \
    \   @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmp8fcd_cds.swift:13:19: note: found\
    \ candidate with type '(__owned Unicode.Scalar) -> ()'\n            stack.append(char)\n\
    \                  ^\n/tmp/tmp8fcd_cds.swift:16:24: error: 'nil' is incompatible\
    \ with return type '[Int]'\n                return nil\n                     \
    \  ^\n/tmp/tmp8fcd_cds.swift:25:24: error: 'nil' is incompatible with return type\
    \ '[Int]'\n                return nil\n                       ^\n/tmp/tmp8fcd_cds.swift:14:14:\
    \ warning: literal value is already handled by previous pattern; consider removing\
    \ it\n        case \"(\":\n             ^~~\n/tmp/tmp8fcd_cds.swift:12:14: note:\
    \ first occurrence of identical literal pattern is here\n        case \"(\":\n\
    \             ^~~\n/tmp/tmp8fcd_cds.swift:20:14: warning: literal value is already\
    \ handled by previous pattern; consider removing it\n        case \"(\":\n   \
    \          ^~~\n/tmp/tmp8fcd_cds.swift:12:14: note: first occurrence of identical\
    \ literal pattern is here\n        case \"(\":\n             ^~~\n/tmp/tmp8fcd_cds.swift:31:16:\
    \ error: 'nil' is incompatible with return type '[Int]'\n        return nil\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var count = [Int]()\n    paren_string.split(\"\
    \ \").forEach { item in\n        if item.contains(\"(\") {\n            count\
    \ += 1\n        } else {\n            level -= 1\n        }\n        if level\
    \ < 0 {\n            level = 0\n            count += 0\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpxt2yll5k.swift:10:18: error: no exact matches in call to instance\
    \ method 'split'\n    paren_string.split(\" \").forEach { item in\n          \
    \       ^\n/tmp/tmpxt2yll5k.swift:10:18: note: candidate has partially matching\
    \ parameter list (separator: String.Element, maxSplits: Int, omittingEmptySubsequences:\
    \ Bool)\n    paren_string.split(\" \").forEach { item in\n                 ^\n\
    /tmp/tmpxt2yll5k.swift:10:18: note: candidate has partially matching parameter\
    \ list (separator: String.Element, maxSplits: Int, omittingEmptySubsequences:\
    \ Bool)\n    paren_string.split(\" \").forEach { item in\n                 ^\n\
    /tmp/tmpxt2yll5k.swift:12:22: error: cannot convert value of type 'Int' to expected\
    \ argument type 'Array<Int>'\n            count += 1\n                     ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tvar levels = [Int]()\n\t\n\tvar count = 0\n\tfor (index,\
    \ ch) in paren_string.enumerated() {\n\t\tif ch == \"(\" {\n\t\t\tcount += 1\n\
    \t\t\tcontinue\n\t\t}\n\t\t\n\t\tif ch == \")\" {\n\t\t\tlevels[count] = levels[count-1]\n\
    \t\t\t\n\t\t\tcount -= 1\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tlevels[count] = count\n\
    \t}\n\t\n\treturn levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f1bf6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f1bc66561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f1bc66286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f1bc6613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f1bc65bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f1ba65e83 <unavailable> + 188035

    6    tmpf6u4nl0x                        0x0000564989206de0 <unavailable> + 7648

    7    tmpf6u4nl0x                        0x00005649892067c6 <unavailable> + 6086

    8    libc.so.6                          0x00002b0f1c15b460 __libc_start_main +
    245

    9    tmpf6u4nl0x                        0x00005649892064c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tlet paren_stack: [Int] = []\n\n\tfor char in paren_string.unicodeScalars\
    \ {\n\t\tswitch char {\n\t\tcase '(':\n\t\t\tparen_stack.append(0)\n\t\t\tcontinue\n\
    \t\tcase ')':\n\t\t\tparen_stack.removeLast()\n\t\t\tcontinue\n\t\tdefault:\n\t\
    \t\tbreak\n\t\t}\n\t}\n\n\treturn paren_stack\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmppgh08mie.swift:12:8: error: single-quoted string literal found,\
    \ use '\"'\n                case '(':\n                     ^~~\n            \
    \         \"(\"\n/tmp/tmppgh08mie.swift:15:8: error: single-quoted string literal\
    \ found, use '\"'\n                case ')':\n                     ^~~\n     \
    \                \")\"\n/tmp/tmppgh08mie.swift:13:16: error: cannot use mutating\
    \ member on immutable value: 'paren_stack' is a 'let' constant\n             \
    \           paren_stack.append(0)\n                        ~~~~~~~~~~~ ^\n/tmp/tmppgh08mie.swift:8:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let paren_stack: [Int]\
    \ = []\n        ^~~\n        var\n/tmp/tmppgh08mie.swift:16:16: error: cannot\
    \ use mutating member on immutable value: 'paren_stack' is a 'let' constant\n\
    \                        paren_stack.removeLast()\n                        ~~~~~~~~~~~\
    \ ^\n/tmp/tmppgh08mie.swift:8:2: note: change 'let' to 'var' to make it mutable\n\
    \        let paren_stack: [Int] = []\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    return parse_nested_parens_rec(paren_string, \"\", 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptq3gmqzj.swift:8:12: error: cannot find 'parse_nested_parens_rec'\
    \ in scope\n    return parse_nested_parens_rec(paren_string, \"\", 0)\n      \
    \     ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level: [Int] = [0]\n\n    for group in paren_string.components(separatedBy:\
    \ \" \") {\n        if group != \"\" {\n            let index = group.characters.index(of:\
    \ \"(\")!\n            let start = index\n            let end = group.characters.index(of:\
    \ \")\", offset: index)!\n            level.append(level[index] + 1)\n       \
    \     level[index] = level[index] + 1\n\n            for _ in stride(from: start,\
    \ to: end, by: -1) {\n                if level[index] == level[index + 1] {\n\
    \                    level[index] = level[index + 1]\n                    break\n\
    \                } else {\n                    level[index] = level[index] + 1\n\
    \                }\n            }\n        }\n    }\n    return level\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5_qy8tr6.swift:10:31: error: value of type 'String' has no member\
    \ 'components'\n    for group in paren_string.components(separatedBy: \" \") {\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    paren_string = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines).lowercased()\n\
    \    var max_nested_level = 0\n    var level = 0\n    var open_parantheses = 0\n\
    \    var close_parantheses = 0\n    var incomplete_open_parantheses = 0\n    var\
    \ incomplete_close_parantheses = 0\n    var index = 0\n    var depth = 0\n   \
    \ while index < paren_string.characters.count {\n        let character = paren_string.character(at:\
    \ index)\n        switch character {\n        case ')':\n            if incomplete_close_parantheses\
    \ == 0 {\n                close_parantheses += 1\n            } else {\n     \
    \           incomplete_close_parantheses = 0\n                incomplete_open_parantheses\
    \ += 1\n            }\n            level += 1\n        case ')':\n           \
    \ close_parantheses -= 1\n            if close_parantheses == 0 {\n          \
    \      close_parantheses = 0\n            }\n            level += 1\n        case\
    \ ')':\n            close_parantheses += 1\n            if close_parantheses ==\
    \ 1 {\n                incomplete_open_parantheses = 0\n            }\n      \
    \  case ')':\n            open_parantheses -= 1\n            if open_parantheses\
    \ == 0 {\n                break\n            }\n        case ')':\n          \
    \  open_parantheses += 1\n        case ' ':\n            if incomplete_open_parantheses\
    \ == 0 {\n                index += 1\n                continue\n            }\n\
    \        case ')':\n            if incomplete_close_parantheses == 0 {\n     \
    \           incomplete_open_parantheses = 0\n                incomplete_close_parantheses\
    \ += 1\n            } else {\n                incomplete_close_parantheses = 0\n\
    \            }\n        case ')':\n            if incomplete_open_parantheses\
    \ == 0 {\n                break\n            }\n        default:\n           \
    \ open_parantheses += 1\n            close_parantheses += 1\n        }\n     \
    \   if level > max_nested_level {\n            max_nested_level = level\n    \
    \    }\n        index += 1\n    }\n    return [max_nested_level]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpb66h_6ym.swift:20:14: error: single-quoted string literal found,\
    \ use '\"'\n        case ')':\n             ^~~\n             \")\"\n/tmp/tmpb66h_6ym.swift:28:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ')':\n   \
    \          ^~~\n             \")\"\n/tmp/tmpb66h_6ym.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case ')':\n             ^~~\n      \
    \       \")\"\n/tmp/tmpb66h_6ym.swift:39:14: error: single-quoted string literal\
    \ found, use '\"'\n        case ')':\n             ^~~\n             \")\"\n/tmp/tmpb66h_6ym.swift:44:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ')':\n   \
    \          ^~~\n             \")\"\n/tmp/tmpb66h_6ym.swift:46:14: error: single-quoted\
    \ string literal found, use '\"'\n        case ' ':\n             ^~~\n      \
    \       \" \"\n/tmp/tmpb66h_6ym.swift:51:14: error: single-quoted string literal\
    \ found, use '\"'\n        case ')':\n             ^~~\n             \")\"\n/tmp/tmpb66h_6ym.swift:58:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ')':\n   \
    \          ^~~\n             \")\"\n/tmp/tmpb66h_6ym.swift:8:56: error: cannot\
    \ find 'CharacterSet' in scope\n    paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines).lowercased()\n                        \
    \                               ^~~~~~~~~~~~\n/tmp/tmpb66h_6ym.swift:8:5: error:\
    \ cannot assign to value: 'paren_string' is a 'let' constant\n    paren_string\
    \ = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines).lowercased()\n\
    \    ^~~~~~~~~~~~\n/tmp/tmpb66h_6ym.swift:8:33: error: value of type 'String'\
    \ has no member 'trimmingCharacters'\n    paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines).lowercased()\n                   ~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpb66h_6ym.swift:17:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    while index < paren_string.characters.count\
    \ {\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characte"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var nesting_levels: [Int] = []\n    var cur_level =\
    \ 0\n    for index in 0..<paren_string.characters.count {\n        if paren_string.characters[index]\
    \ == '(' {\n            nesting_levels.append(cur_level)\n        }\n        cur_level\
    \ += 1\n        if paren_string.characters[index] == ')' {\n            cur_level\
    \ -= 1\n            if cur_level == 0 {\n                nesting_levels.append(cur_level)\n\
    \            }\n        }\n    }\n    return nesting_levels\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvwm0np_a.swift:11:46: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string.characters[index] == '(' {\n             \
    \                                ^~~\n                                       \
    \      \"(\"\n/tmp/tmpvwm0np_a.swift:15:46: error: single-quoted string literal\
    \ found, use '\"'\n        if paren_string.characters[index] == ')' {\n      \
    \                                       ^~~\n                                \
    \             \")\"\n/tmp/tmpvwm0np_a.swift:10:35: error: 'characters' is unavailable:\
    \ Please use String directly\n    for index in 0..<paren_string.characters.count\
    \ {\n                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvwm0np_a.swift:11:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ paren_string.characters[index] == '(' {\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvwm0np_a.swift:11:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        if paren_string.characters[index]\
    \ == '(' {\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvwm0np_a.swift:15:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ paren_string.characters[index] == ')' {\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvwm0np_a.swift:15:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        if paren_string.characters[index]\
    \ == ')' {\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'charact"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    if paren_string.hasPrefix(\"(\") || paren_string.hasSuffix(\"\
    )\") {\n        return []\n    }\n    let paren_depths = paren_string.unicodeScalars.filter({$0.isASCII}).map({\
    \ paren_string in\n        var paren_groups = paren_string.unicodeScalars.filter({!$0.isASCII}).map({\
    \ paren_string in\n            var level = 1\n            var maxLevel = 0\n \
    \           var paren_level = 0\n            var is_balanced = true\n        \
    \    for c in paren_groups {\n                if c == '{' || c == '[' {\n    \
    \                is_balanced = false\n                }\n                if paren_groups[paren_level]\
    \ == c {\n                    paren_level += 1\n                } else if paren_level\
    \ > 0 && paren_groups[paren_level-1] == c {\n                    paren_level -=\
    \ 1\n                }\n                if paren_level > maxLevel {\n        \
    \            maxLevel = paren_level\n                }\n            }\n      \
    \      if paren_level != 0 && maxLevel > paren_level {\n                return\
    \ -1\n            }\n            level++\n            return level\n        })\n\
    \        return paren_groups.reduce(0, combine: { $0 + $1 })\n    })\n    return\
    \ paren_depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9q2pwgum.swift:18:25: error: single-quoted string literal found,\
    \ use '\"'\n                if c == '{' || c == '[' {\n                      \
    \  ^~~\n                        \"{\"\n/tmp/tmp9q2pwgum.swift:18:37: error: single-quoted\
    \ string literal found, use '\"'\n                if c == '{' || c == '[' {\n\
    \                                    ^~~\n                                   \
    \ \"[\"\n/tmp/tmp9q2pwgum.swift:33:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            level++\n                 ^~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Start from 0 to skip the empty string\n    var level\
    \ = 0\n    var nesting = 0\n    var max_nesting = 0\n    var group_count = 0\n\
    \    var group_nesting = 0\n    var group_string = \"\"\n    for ch in paren_string.characters\
    \ {\n        switch ch {\n        case \".\":\n            if level == 0 {\n \
    \               continue\n            }\n            level--\n        case \"\
    )\":\n            if level == 0 {\n                continue\n            }\n \
    \           level++\n            nesting--\n            if nesting > max_nesting\
    \ {\n                max_nesting = nesting\n            }\n            group_nesting\
    \ = level\n            group_count++\n        case \")\\n\":\n            group_string\
    \ = group_string.trimmingCharacters(in: CharacterSet.newlines)\n            if\
    \ group_string != \"\" {\n                nesting = group_nesting\n          \
    \      group_count = 0\n                group_nesting = 0\n            }\n   \
    \     default:\n            if level == 0 {\n                group_string = group_string.trimmingCharacters(in:\
    \ CharacterSet.newlines)\n                continue\n            }\n          \
    \  group_string = String(group_string)\n            group_string.append(String(ch))\n\
    \        }\n    }\n    return [Int](repeating: 0, count: max_nesting)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpeqnh4j3c.swift:15:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for ch in paren_string.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpeqnh4j3c.swift:33:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \")\\n\":\n          \
    \   ^~~~~\n/tmp/tmpeqnh4j3c.swift:21:18: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n            level--\n                 ^~\n/tmp/tmpeqnh4j3c.swift:26:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  level++\n                 ^~\n/tmp/tmpeqnh4j3c.swift:27:20: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            nesting--\n      \
    \             ^~\n/tmp/tmpeqnh4j3c.swift:32:24: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            group_count++\n                \
    \       ^~\n/tmp/tmpeqnh4j3c.swift:34:64: error: cannot find 'CharacterSet' in\
    \ scope\n            group_string = group_string.trimmingCharacters(in: CharacterSet.newlines)\n\
    \                                                               ^~~~~~~~~~~~\n\
    /tmp/tmpeqnh4j3c.swift:34:41: error: value of type 'String' has no member 'trimmingCharacters'\n\
    \            group_string = group_string.trimmingCharacters(in: CharacterSet.newlines)\n\
    \                           ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpeqnh4j3c.swift:42:68:\
    \ error: cannot find 'CharacterSet' in scope\n                group_string = group_string.trimmingCharacters(in:\
    \ CharacterSet.newlines)\n                                                   \
    \                ^~~~~~~~~~~~\n/tmp/tmpeqnh4j3c.swift:42:45: error: value of type\
    \ 'String' has no member 'trimmingCharacters'\n                group_string =\
    \ group_string.trimmingCharacters(in: CharacterSet.newlines)\n               \
    \                ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n    var level = 0\n    var max_level_pos\
    \ = 0\n    var parentheses: [String] = []\n    for pos in paren_string.characters.indices{\n\
    \        level++\n        if paren_string[pos] == ')' {\n            if level\
    \ > max_level {\n                max_level = level\n                max_level_pos\
    \ = pos\n            }\n            level--\n            parentheses.append(String())\n\
    \        } else {\n            parentheses[level] += String(paren_string[pos])\n\
    \        }\n    }\n    if level > max_level {\n        max_level = level\n   \
    \     max_level_pos = 0\n    }\n    return Array(parentheses[max_level..<max_level\
    \ + 1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp7lokk_3j.swift:14:33: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[pos] == ')' {\n                          \
    \      ^~~\n                                \")\"\n/tmp/tmp7lokk_3j.swift:12:29:\
    \ error: 'characters' is unavailable: Please use String directly\n    for pos\
    \ in paren_string.characters.indices{\n                            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp7lokk_3j.swift:13:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        level++\n\
    \             ^~\n/tmp/tmp7lokk_3j.swift:17:33: error: cannot assign value of\
    \ type 'DefaultIndices<String>.Element' (aka 'String.Index') to type 'Int'\n \
    \               max_level_pos = pos\n                                ^~~\n/tmp/tmp7lokk_3j.swift:19:18:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  level--\n                 ^~\n/tmp/tmp7lokk_3j.swift:29:12: error: no exact\
    \ matches in call to initializer \n    return Array(parentheses[max_level..<max_level\
    \ + 1])\n           ^\nSwift.Array:3:23: note: candidate requires that the types\
    \ 'Int' and 'String' be equivalent (requirement specified as 'Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ s: S) where Element == S.Element, S : Sequence\n\
    \                      ^\nSwift.RangeReplaceableCollection:3:23: note: candidate\
    \ requires that the types 'Int' and 'String' be equivalent (requirement specified\
    \ as 'Self.Element' == 'S.Element')\n    @inlinable public init<S>(_ elements:\
    \ S) where S : Sequence, Self.Element == S.Element\n                      ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max = 0\n    var count = 0\n    var i = 0\n    var\
    \ par_count = 0\n    var max_par_count = 0\n    var par_depth = 0\n    var par_char\
    \ = \"\"\n    var par_char_count = 0\n    var char_count = 0\n    var char_i =\
    \ 0\n    var open_bracket = false\n    var is_right_bracket = false\n    var is_left_bracket\
    \ = false\n    var level = 0\n    var open_par = false\n    var is_right_par =\
    \ false\n    var is_left_par = false\n    var brackets = [String]()\n    var par_i\
    \ = -1\n    var par_i_level = 0\n\n    for (i = 0; i < paren_string.characters.count;\
    \ i += 1) {\n        char = paren_string.characters[i]\n\n        if char == \"\
    (\" || char == \")\" {\n            if count > 0 {\n                max += count\n\
    \                count = 0\n            }\n\n            if char == \"(\" {\n\
    \                if open_bracket {\n                    count += 1\n         \
    \       } else if par_char_count == 0 {\n                    open_bracket = true\n\
    \                } else {\n                    par_count += 1\n              \
    \      par_char_count = par_count\n                    par_depth = par_i_level\n\
    \                    par_char_count = 0\n                }\n            } else\
    \ {\n                if open_bracket {\n                    count -= 1\n     \
    \           } else if par_char_count == 0 {\n                    open_bracket\
    \ = false\n                } else {\n                    par_count -= 1\n    \
    \                par_char_count = par_count\n                    par_depth = par_i_level\n\
    \                    par_char_count = 0\n                }\n            }\n\n\
    \            if par_char_count > max_par_count {\n                max_par_count\
    \ = par_char_count\n            }\n\n            par_i_level = par_depth\n   \
    \         par_char = \"\"\n            par_char_count = 0\n            par_i =\
    \ i\n        } else {\n            if par_char == \"(\" {\n                if\
    \ is_right_bracket {\n                    par_par_i = i\n                }\n \
    \               is_right_bracket = true\n            } else {\n              \
    \  if is_right_bracket {\n                    par_par_i = i\n                }\n\
    \                is_right_bracket = false\n            }\n\n            if par_par_i\
    \ != -1 {\n                par_char_count = paren_string.characters[par_par_i].characters.count\
    \ - par_par_i\n                if par_char_count > char_count {\n            \
    \        char_count = par_char_count\n                }\n                par_i_level\
    \ = paren_string.characters[par_par_i].characters.count - par_par_i\n        \
    \        if par_i_level > par_i_level {\n                    par_i_level = par_i_level\n\
    \                }\n\n                if par_char_count == 0 {\n             \
    \       par_depth = par_i_level\n                    par_char = \"\"\n       \
    \             par_char_count = 0\n                    par_i = -1\n           \
    \     }\n            } else {\n                if par_char_count > char_count\
    \ {\n                    char_count = par_char_count\n                }\n\n  \
    \              if \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpfeii5sq2.swift:29:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (i = 0; i < paren_string.characters.count; i += 1) {\n \
    \   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfeii5sq2.swift:104:19:\
    \ error: expected expression, var, or let in 'if' condition\n                if\
    \ \n                  ^\n/tmp/tmpfeii5sq2.swift:122:67: error: expected '}' at\
    \ end of brace statement\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])\n                                                                  ^\n\
    /tmp/tmpfeii5sq2.swift:70:16: note: to match this opening '{'\n        } else\
    \ {\n               ^\n/tmp/tmpfeii5sq2.swift:122:67: error: expected '}' at end\
    \ of brace statement\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])\n                                                                  ^\n\
    /tmp/tmpfeii5sq2.swift:29:60: note: to match this opening '{'\n    for (i = 0;\
    \ i < paren_string.characters.count; i += 1) {\n                             \
    \                              ^\n/tmp/tmpfeii5sq2.swift:122:67: error: expected\
    \ '}' at end of brace statement\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])\n                                                                  ^\n\
    /tmp/tmpfeii5sq2.swift:7:57: note: to match this opening '{'\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n                                                       \
    \ ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n    var open_count = 1\n    for paren\
    \ in paren_string.characters {\n        if paren == ')' {\n            open_count\
    \ -= 1\n        }\n        if open_count == 0 {\n            max_level = max(max_level,\
    \ paren_string.characters.count - paren_string.startIndex + 2)\n        }\n  \
    \      if paren == '(' {\n            open_count += 1\n        }\n    }\n    return\
    \ max_level\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpu7hrabjt.swift:11:21: error: single-quoted string literal found,\
    \ use '\"'\n        if paren == ')' {\n                    ^~~\n             \
    \       \")\"\n/tmp/tmpu7hrabjt.swift:17:21: error: single-quoted string literal\
    \ found, use '\"'\n        if paren == '(' {\n                    ^~~\n      \
    \              \"(\"\n/tmp/tmpu7hrabjt.swift:10:31: error: 'characters' is unavailable:\
    \ Please use String directly\n    for paren in paren_string.characters {\n   \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpu7hrabjt.swift:15:85: error: cannot convert value of\
    \ type 'String.Index' to expected argument type 'Int'\n            max_level =\
    \ max(max_level, paren_string.characters.count - paren_string.startIndex + 2)\n\
    \                                                                            \
    \        ^\n/tmp/tmpu7hrabjt.swift:21:12: error: cannot convert return expression\
    \ of type 'Int' to return type '[Int]'\n    return max_level\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n\n    for parens in paren_string.split(\"\
    \ \") {\n        if parens.contains(\"(\") {\n            if parens.count >= level\
    \ {\n                level++\n            }\n        }\n\n        if parens.contains(\"\
    )\") {\n            if parens.count < level {\n                level--\n     \
    \       }\n        }\n    }\n\n    return Array(1...level).sorted()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpea_stnah.swift:10:32: error: no exact matches in call to instance\
    \ method 'split'\n    for parens in paren_string.split(\" \") {\n            \
    \                   ^\nSwift.Sequence:2:40: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var max_level = 0\n    var nesting_count\
    \ = 0\n    var max_nesting_count = 0\n    var nesting_group_size = 0\n    for\
    \ character in paren_string.characters {\n        if character == \"(\" {\n  \
    \          nesting_count += 1\n            nesting_group_size++\n            level\
    \ = nesting_count\n            max_level = nesting_count + nesting_group_size\n\
    \        }\n        else if character == \")\" {\n            nesting_count -=\
    \ 1\n            nesting_group_size--\n            level = nesting_count\n   \
    \     }\n        if nesting_count > max_nesting_count {\n            max_nesting_count\
    \ = nesting_count\n        }\n    }\n    var nesting_levels: [Int] = []\n    for\
    \ nesting_count in 0..<max_nesting_count {\n        nesting_levels.append(level\
    \ + nesting_count)\n    }\n    return nesting_levels\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpo_zmpukq.swift:13:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in paren_string.characters {\n      \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpo_zmpukq.swift:16:31: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            nesting_group_size++\n         \
    \                     ^~\n/tmp/tmpo_zmpukq.swift:22:31: error: cannot find operator\
    \ '--' in scope; did you mean '-= 1'?\n            nesting_group_size--\n    \
    \                          ^~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var nesting_level = 0\n    var deepest_nesting_level\
    \ = 0\n\n    for index in 0..<paren_string.characters.count {\n        let char\
    \ = paren_string.characters.subscript[index]\n\n        if char == \"(\" {\n \
    \           nesting_level += 1\n        } else if char == \")\" {\n          \
    \  if nesting_level == 0 {\n                deepest_nesting_level = nesting_level\n\
    \            }\n            nesting_level -= 1\n        }\n    }\n\n    return\
    \ [deepest_nesting_level]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5qe4ftv5.swift:11:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<paren_string.characters.count {\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp5qe4ftv5.swift:12:44: error: no exact matches in reference\
    \ to subscript \n        let char = paren_string.characters.subscript[index]\n\
    \                                           ^\n/tmp/tmp5qe4ftv5.swift:12:44: note:\
    \ found candidate with type '(String.Index) -> Character'\n        let char =\
    \ paren_string.characters.subscript[index]\n                                 \
    \          ^\n/tmp/tmp5qe4ftv5.swift:12:44: note: found candidate with type '(Range<String.Index>)\
    \ -> Substring'\n        let char = paren_string.characters.subscript[index]\n\
    \                                           ^\n/tmp/tmp5qe4ftv5.swift:12:44: note:\
    \ found candidate with type '((UnboundedRange_) -> ()) -> String.SubSequence'\
    \ (aka '((UnboundedRange_) -> ()) -> Substring')\n        let char = paren_string.characters.subscript[index]\n\
    \                                           ^\n/tmp/tmp5qe4ftv5.swift:12:53: error:\
    \ reference to member 'subscript' cannot be resolved without a contextual type\n\
    \        let char = paren_string.characters.subscript[index]\n               \
    \                                     ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var output = [Int]()\n    var stack = [String]()\n \
    \   for s in paren_string.split(\" \") {\n        guard let open_paren_index =\
    \ s.firstIndex(of: \"(\") else {\n            return output\n        }\n     \
    \   stack.append(s[open_paren_index...])\n    }\n    while stack.count > 0 {\n\
    \        let open_paren_index = stack.lastIndex(of: \"(\")\n        if open_paren_index\
    \ != nil {\n            output.append(open_paren_index!)\n            stack.removeSubrange(open_paren_index!...open_paren_index!.endIndex)\n\
    \        } else {\n            stack.removeLast()\n        }\n    }\n    return\
    \ output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptqcanul0.swift:10:27: error: no exact matches in call to instance\
    \ method 'split'\n    for s in paren_string.split(\" \") {\n                 \
    \         ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n/tmp/tmptqcanul0.swift:20:72: error:\
    \ value of type 'Array<String>.Index' (aka 'Int') has no member 'endIndex'\n \
    \           stack.removeSubrange(open_paren_index!...open_paren_index!.endIndex)\n\
    \                                                     ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tlet level = 0\n\tvar result = [Int]()\n\tlet parentheses\
    \ = paren_string.characters\n\tlet paren_chars = paren_string.characters\n\n\t\
    for paren_index in 0..<parentheses.count {\n\t\tif paren_chars[paren_index] ==\
    \ '(' { level += 1 }\n\t\tif paren_chars[paren_index] == ')' { level -= 1 }\n\t\
    \tif level == 0 {\n\t\t\tresult.append(paren_index)\n\t\t}\n\t}\n\treturn result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp912x5qf9.swift:14:34: error: single-quoted string literal found,\
    \ use '\"'\n                if paren_chars[paren_index] == '(' { level += 1 }\n\
    \                                               ^~~\n                        \
    \                       \"(\"\n/tmp/tmp912x5qf9.swift:15:34: error: single-quoted\
    \ string literal found, use '\"'\n                if paren_chars[paren_index]\
    \ == ')' { level -= 1 }\n                                               ^~~\n\
    \                                               \")\"\n/tmp/tmp912x5qf9.swift:10:33:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ parentheses = paren_string.characters\n                                    \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp912x5qf9.swift:11:33:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ paren_chars = paren_string.characters\n                                    \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp912x5qf9.swift:14:6:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if paren_chars[paren_index] ==\
    \ '(' { level += 1 }\n                   ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp912x5qf9.swift:14:46:\
    \ error: left side of mutating operator isn't mutable: 'level' is a 'let' constant\n\
    \                if paren_chars[paren_index] == '(' { level += 1 }\n         \
    \                                            ~~~~~ ^\n/tmp/tmp912x5qf9.swift:8:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let level = 0\n    \
    \    ^~~\n        var\n/tmp/tmp912x5qf9.swift:15:6: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                if paren_"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_nested_level = 0\n    var paren_stack = Stack{paren_string}\n\
    \n    for paren_string in paren_string.characters{\n        if paren_stack.isEmpty{\n\
    \            max_nested_level++\n        }\n        else{\n            let parentheses\
    \ = paren_stack.pop()\n            if parentheses == paren_string{\n         \
    \       max_nested_level++\n            }\n            else{\n               \
    \ max_nested_level = max(max_nested_level,paren_stack.size)\n            }\n \
    \       }\n    }\n\n    return Array(1...max_nested_level)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpnrvoravg.swift:9:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack{paren_string}\n                      ^~~~~\n/tmp/tmpnrvoravg.swift:11:38:\
    \ error: 'characters' is unavailable: Please use String directly\n    for paren_string\
    \ in paren_string.characters{\n                                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpnrvoravg.swift:13:29:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  max_nested_level++\n                            ^~\n/tmp/tmpnrvoravg.swift:18:33:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      max_nested_level++\n                                ^~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    guard paren_string.count >= 1 else {\n        return\
    \ []\n    }\n    \n    var level = 0\n    var maxLevel = 0\n    var max = 0\n\
    \    \n    for c in paren_string[1..<paren_string.count] {\n        guard c ==\
    \ '(' else {\n            return nil\n        }\n        \n        if level <\
    \ 0 {\n            level++\n            maxLevel = level\n        }\n        \n\
    \        level--\n        if level > max {\n            max = level\n        }\n\
    \    }\n    \n    return maxLevel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpyjpr7w6n.swift:17:20: error: single-quoted string literal found,\
    \ use '\"'\n        guard c == '(' else {\n                   ^~~\n          \
    \         \"(\"\n/tmp/tmpyjpr7w6n.swift:16:14: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an integer range, use a String.Index range instead.\n\
    \    for c in paren_string[1..<paren_string.count] {\n             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpyjpr7w6n.swift:18:20: error: 'nil'\
    \ is incompatible with return type '[Int]'\n            return nil\n         \
    \          ^\n/tmp/tmpyjpr7w6n.swift:22:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n            level++\n                 ^~\n/tmp/tmpyjpr7w6n.swift:26:14:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n        level--\n\
    \             ^~\n/tmp/tmpyjpr7w6n.swift:32:12: error: cannot convert return expression\
    \ of type 'Int' to return type '[Int]'\n    return maxLevel\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_nesting_level = 0\n    for paren in paren_string.components(separatedBy:\
    \ \" \") {\n        var nesting_level = 0\n        for char_index in paren.characters\
    \ {\n            if char_index == '(' {\n                nesting_level += 1\n\
    \            }\n            else if char_index == ')' {\n                nesting_level\
    \ -= 1\n            }\n        }\n\n        if nesting_level > max_nesting_level\
    \ {\n            max_nesting_level = nesting_level\n        }\n    }\n    return\
    \ max_nesting_level\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpn2y933ed.swift:12:30: error: single-quoted string literal found,\
    \ use '\"'\n            if char_index == '(' {\n                             ^~~\n\
    \                             \"(\"\n/tmp/tmpn2y933ed.swift:15:35: error: single-quoted\
    \ string literal found, use '\"'\n            else if char_index == ')' {\n  \
    \                                ^~~\n                                  \")\"\n\
    /tmp/tmpn2y933ed.swift:9:31: error: value of type 'String' has no member 'components'\n\
    \    for paren in paren_string.components(separatedBy: \" \") {\n            \
    \     ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpn2y933ed.swift:24:12: error: cannot convert\
    \ return expression of type 'Int' to return type '[Int]'\n    return max_nesting_level\n\
    \           ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var parens_level = [Int]()\n    var current_level =\
    \ 0\n\n    for ch in paren_string.unicodeScalars {\n        switch ch {\n    \
    \    case .OpenParen: current_level += 1 // count the opening bracket\n      \
    \  case .CloseParen: current_level -= 1 // count the closing bracket\n       \
    \ default: break\n        }\n\n        // update the current level if it crossed\
    \ the maximum level\n        if current_level < parens_level.count {\n       \
    \     parens_level[current_level] = max(parens_level[current_level], current_level)\n\
    \        }\n    }\n\n    return parens_level\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpauat56kj.swift:13:15: error: type 'Unicode.Scalar' has no member\
    \ 'OpenParen'\n        case .OpenParen: current_level += 1 // count the opening\
    \ bracket\n             ~^~~~~~~~~\n/tmp/tmpauat56kj.swift:14:15: error: type\
    \ 'Unicode.Scalar' has no member 'CloseParen'\n        case .CloseParen: current_level\
    \ -= 1 // count the closing bracket\n             ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var result = [Int]()\n    var level = 0\n    var inParenthesis\
    \ = false\n    var last = 0\n\n    paren_string.forEach {\n        switch $0 {\n\
    \        case \"(\":\n            inParenthesis = true\n            level++\n\
    \            last = $0\n        case \")\":\n            inParenthesis = false\n\
    \            level--\n            if level == 0 {\n                result.insert(last,\
    \ level + 1)\n            }\n            last = $0\n        default:\n       \
    \     last = $0\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi1yqvrc8.swift:17:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            level++\n                 ^~\n/tmp/tmpi1yqvrc8.swift:21:18:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  level--\n                 ^~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = [Int]()\n    let paren_char = \"()\"\n \
    \   var i = 0\n    while i < paren_string.characters.count {\n        if paren_string.characters[i]\
    \ == paren_char {\n            level[level.count-1] = level.count\n          \
    \  i += 1\n            while i < paren_string.characters.count && paren_string.characters[i]\
    \ != paren_char {\n                i += 1\n            }\n            i += 1\n\
    \        } else if paren_string.characters[i] == \")\" {\n            let max_level\
    \ = level.max()!\n            for _ in 0..<max_level {\n                level.removeLast()\n\
    \            }\n        } else {\n            i += 1\n        }\n    }\n    return\
    \ level\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5xg5mdas.swift:11:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    while i < paren_string.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5xg5mdas.swift:12:35: error: no exact matches in call to subscript\
    \ \n        if paren_string.characters[i] == paren_char {\n                  \
    \                ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Int')\n    public subscript(r: Range<String.Index>) ->\
    \ Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp5xg5mdas.swift:15:80: error: cannot convert value\
    \ of type 'Int' to expected argument type 'Range<String.Index>'\n            while\
    \ i < paren_string.characters.count && paren_string.characters[i] != paren_char\
    \ {\n                                                                        \
    \       ^\n/tmp/tmp5xg5mdas.swift:19:19: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        }\
    \ else if paren_string.characters[i] == \")\" {\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5xg5mdas.swift:19:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        } else\
    \ if paren_string.characters[i] == \")\" {\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let paren_stack: [[String]] = paren_string.split(\"\
    \ \").map { $0 }\n    \n    // Parse the string\n    var max_level = 0\n    var\
    \ levels = [Int]()\n    \n    for p in paren_stack {\n        // Find the deepest\
    \ level of nesting in the string\n        let level = 1\n        for i in 0 ...\
    \ p.count - 1 {\n            if p[i] == \")\" && paren_stack[i - 1][p.count -\
    \ 1] == \"(\" {\n                level++\n            } else {\n             \
    \   level = 0\n                break\n            }\n        }\n        \n   \
    \     // Add the level to the stack\n        if level > max_level {\n        \
    \    max_level = level\n            levels = [Int]()\n        }\n        \n  \
    \      // Add to levels\n        levels.append(level)\n    }\n    \n    // Get\
    \ the maximum level\n    let max_level = levels[levels.count - 1]\n    \n    return\
    \ max_level\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdlhj8q8e.swift:8:54: error: missing argument label 'separator:'\
    \ in call\n    let paren_stack: [[String]] = paren_string.split(\" \").map { $0\
    \ }\n                                                     ^\n                \
    \                                     separator: \n/tmp/tmpdlhj8q8e.swift:8:65:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ closure result type '[String]'\n    let paren_stack: [[String]] = paren_string.split(\"\
    \ \").map { $0 }\n                                                           \
    \     ^~\n/tmp/tmpdlhj8q8e.swift:19:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                level++\n                     ^~\n/tmp/tmpdlhj8q8e.swift:21:17:\
    \ error: cannot assign to value: 'level' is a 'let' constant\n               \
    \ level = 0\n                ^~~~~\n/tmp/tmpdlhj8q8e.swift:16:9: note: change\
    \ 'let' to 'var' to make it mutable\n        let level = 1\n        ^~~\n    \
    \    var\n/tmp/tmpdlhj8q8e.swift:37:9: error: invalid redeclaration of 'max_level'\n\
    \    let max_level = levels[levels.count - 1]\n        ^\n/tmp/tmpdlhj8q8e.swift:11:9:\
    \ note: 'max_level' previously declared here\n    var max_level = 0\n        ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    \n    if paren_string.isEmpty {\n        return []\n\
    \    }\n\n    // get the first character, which is always '('\n    guard let first_char\
    \ = paren_string.first else {\n        return []\n    }\n\n    // check if the\
    \ first character is '(', if true, then it's a group\n    if first_char == '('\
    \ { // group\n\n        // get the first ')' from the string\n        guard let\
    \ group_end = paren_string.range(of: ')', options: .backwards) else {\n      \
    \      return []\n        }\n\n        // check if the next character is ')'\n\
    \        guard paren_string[group_end.upperBound] == ')' else {\n            return\
    \ []\n        }\n\n        // if so, get the string that follows the ')'\n   \
    \     guard let next_string = paren_string[group_end.lowerBound + 1 : group_end.upperBound]\
    \ else {\n            return []\n        }\n\n        // if that string is a group,\
    \ add the level from its first '(' to the level of the final '('\n        if next_string.isEmpty\
    \ {\n            return []\n        }\n        \n        let next_char_array =\
    \ next_string.unicodeScalars.map { $0.value }\n        let next_char_ints = parse_nested_parens(paren_string:\
    \ next_string)\n\n        // append the level of the group to the level of the\
    \ next (')\n        return next_char_ints + [first_char.unicodeScalar.value -\
    \ 1]\n    }\n    \n    // else (first char is not '('), then it's a simple paren\n\
    \    return [first_char.unicodeScalar.value - 1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptdk61f7j.swift:19:22: error: single-quoted string literal found,\
    \ use '\"'\n    if first_char == '(' { // group\n                     ^~~\n  \
    \                   \"(\"\n/tmp/tmptdk61f7j.swift:22:54: error: single-quoted\
    \ string literal found, use '\"'\n        guard let group_end = paren_string.range(of:\
    \ ')', options: .backwards) else {\n                                         \
    \            ^~~\n                                                     \")\"\n\
    /tmp/tmptdk61f7j.swift:27:53: error: single-quoted string literal found, use '\"\
    '\n        guard paren_string[group_end.upperBound] == ')' else {\n          \
    \                                          ^~~\n                             \
    \                       \")\"\n/tmp/tmptdk61f7j.swift:32:71: error: expected ','\
    \ separator\n        guard let next_string = paren_string[group_end.lowerBound\
    \ + 1 : group_end.upperBound] else {\n                                       \
    \                               ^\n                                          \
    \                           ,\n/tmp/tmptdk61f7j.swift:32:71: error: expected expression\
    \ in list of expressions\n        guard let next_string = paren_string[group_end.lowerBound\
    \ + 1 : group_end.upperBound] else {\n                                       \
    \                               ^\n/tmp/tmptdk61f7j.swift:22:44: error: value\
    \ of type 'String' has no member 'range'\n        guard let group_end = paren_string.range(of:\
    \ ')', options: .backwards) else {\n                              ~~~~~~~~~~~~\
    \ ^~~~~\n/tmp/tmptdk61f7j.swift:22:69: error: cannot infer contextual base in\
    \ reference to member 'backwards'\n        guard let group_end = paren_string.range(of:\
    \ ')', options: .backwards) else {\n                                         \
    \                          ~^~~~~~~~~\n/tmp/tmptdk61f7j.swift:45:45: error: value\
    \ of type 'String.Element' (aka 'Character') has no member 'unicodeScalar'\n \
    \       return next_char_ints + [first_char.unicodeScalar.value - 1]\n       \
    \                          ~~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmptdk61f7j.swift:49:24:\
    \ error: value of type 'String.Ele"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    paren_string = paren_string.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \" ()\")) // trim leading and trailing spaces and ( and )\n    \n    var groups\
    \ = [Int]()\n    \n    if paren_string.characters.count == 0 {\n        return\
    \ groups\n    }\n    \n    for paren in paren_string.characters {\n        switch\
    \ paren {\n        case '(':\n            groups.append(0)\n        case ')':\n\
    \            groups[groups.count-1] += 1\n            if groups.count >= 2 {\n\
    \                groups[groups.count-2]--\n            }\n        default:\n \
    \           groups.append(0)\n        }\n    }\n    \n    return groups\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp4i9govfp.swift:18:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '(':\n             ^~~\n             \"(\"\n/tmp/tmp4i9govfp.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ')':\n   \
    \          ^~~\n             \")\"\n/tmp/tmp4i9govfp.swift:8:56: error: cannot\
    \ find 'CharacterSet' in scope\n    paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet(charactersIn: \" ()\")) // trim leading and trailing spaces and\
    \ ( and )\n                                                       ^~~~~~~~~~~~\n\
    /tmp/tmp4i9govfp.swift:8:5: error: cannot assign to value: 'paren_string' is a\
    \ 'let' constant\n    paren_string = paren_string.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \" ()\")) // trim leading and trailing spaces and ( and )\n    ^~~~~~~~~~~~\n\
    /tmp/tmp4i9govfp.swift:8:33: error: value of type 'String' has no member 'trimmingCharacters'\n\
    \    paren_string = paren_string.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \" ()\")) // trim leading and trailing spaces and ( and )\n                \
    \   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp4i9govfp.swift:12:21: error: 'characters'\
    \ is unavailable: Please use String directly\n    if paren_string.characters.count\
    \ == 0 {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp4i9govfp.swift:16:31: error: 'characters' is unavailable:\
    \ Please use String directly\n    for paren in paren_string.characters {\n   \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp4i9govfp.swift:23:39: error: cannot find operator '--'\
    \ in scope; did you mean '-= 1'?\n                groups[groups.count-2]--\n \
    \                                     ^~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let string_pieces = paren_string.components(separatedBy:\
    \ \" \")\n    var level = 0\n    var levels_left = [Int](repeating: 0, count:\
    \ paren_string.count).enumerated().map {\n        (index, value) in return level\
    \ + index\n    }\n    for piece in string_pieces {\n        if piece.isEmpty {\n\
    \            continue\n        }\n        if piece[0] == \"(\" && piece.contains(\"\
    (\") {\n            let depth = 1 + levels_left.last!\n            levels_left.remove(at:\
    \ levels_left.index(before: levels_left.last!))\n            levels_left.insert(depth\
    \ - 1, 0)\n            level++\n        }\n        if piece[piece.endIndex-1]\
    \ == \")\" && piece.contains(\")\") {\n            let depth = 1 + levels_left.last!\n\
    \            levels_left.remove(at: levels_left.index(before: levels_left.last!))\n\
    \            levels_left.insert(depth - 1, 0)\n            level--\n        }\n\
    \    }\n    return levels_left.last!\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2_4r8gdz.swift:8:38: error: value of type 'String' has no member\
    \ 'components'\n    let string_pieces = paren_string.components(separatedBy: \"\
    \ \")\n                        ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp2_4r8gdz.swift:30:28:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return levels_left.last!\n           ~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tparens := paren_string.split(\" \").map(strconv.Itoa).filter(!is_empty_string)\n\
    \tparen_counts := [Int]()\n\tfor _, paren_string in parens {\n\t\tparen_count\
    \ = parse_paren_count(paren_string)\n\t\tif paren_count == 0 {\n\t\t\treturn []\n\
    \t\t}\n\t\tparen_counts.append(paren_count)\n\t}\n\treturn paren_counts\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2x9tiq0o.swift:8:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        parens := paren_string.split(\" \").map(strconv.Itoa).filter(!is_empty_string)\n\
    \              ^\n              ;\n/tmp/tmp2x9tiq0o.swift:8:9: error: expected\
    \ expression\n        parens := paren_string.split(\" \").map(strconv.Itoa).filter(!is_empty_string)\n\
    \               ^\n/tmp/tmp2x9tiq0o.swift:10:7: error: expected 'in' after for-each\
    \ pattern\n        for _, paren_string in parens {\n             ^\n/tmp/tmp2x9tiq0o.swift:10:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, paren_string\
    \ in parens {\n             ^\n/tmp/tmp2x9tiq0o.swift:8:2: error: cannot find\
    \ 'parens' in scope\n        parens := paren_string.split(\" \").map(strconv.Itoa).filter(!is_empty_string)\n\
    \        ^~~~~~\n/tmp/tmp2x9tiq0o.swift:17:9: error: cannot find 'paren_counts'\
    \ in scope\n        return paren_counts\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tresult := [Int]()\n\tstacks := make([]*Stack, len(paren_string))\n\
    \tfor i := 0; i < len(paren_string); i++ {\n\t\tstack := &Stack{\n\t\t\tlevel:\
    \ i,\n\t\t}\n\t\tstacks[i] = stack\n\t}\n\tpush_stack(stacks, paren_string, 0)\n\
    \tdepth := 0\n\tfor {\n\t\tif stacks[depth].is_empty {\n\t\t\tbreak\n\t\t}\n\t\
    \tif paren_stacks[depth][len(paren_stacks[depth])-1].level == stacks[depth].level\
    \ {\n\t\t\tpush_stack(stacks, paren_stacks[depth][len(paren_stacks[depth])-1].value,\
    \ stacks[depth].level+1)\n\t\t} else {\n\t\t\tpop_stack(stacks, depth)\n\t\t\t\
    result[depth] = stacks[depth].level + 1\n\t\t\tbreak\n\t\t}\n\t\tdepth++\n\t}\n\
    \treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpulu987ic.swift:8:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result := [Int]()\n              ^\n          \
    \    ;\n/tmp/tmpulu987ic.swift:8:9: error: expected expression\n        result\
    \ := [Int]()\n               ^\n/tmp/tmpulu987ic.swift:10:9: error: expected type\n\
    \        for i := 0; i < len(paren_string); i++ {\n               ^\n        \
    \        <#type#>\n/tmp/tmpulu987ic.swift:10:9: error: expected 'in' after for-each\
    \ pattern\n        for i := 0; i < len(paren_string); i++ {\n               ^\n\
    /tmp/tmpulu987ic.swift:10:9: error: expected Sequence expression for for-each\
    \ loop\n        for i := 0; i < len(paren_string); i++ {\n               ^\n/tmp/tmpulu987ic.swift:11:8:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \       stack := &Stack{\n                     ^\n                     ;\n/tmp/tmpulu987ic.swift:11:9:\
    \ error: expected expression\n                stack := &Stack{\n             \
    \         ^\n/tmp/tmpulu987ic.swift:18:6: error: expected pattern\n        for\
    \ {\n            ^\n/tmp/tmpulu987ic.swift:18:6: error: expected Sequence expression\
    \ for for-each loop\n        for {\n            ^\n/tmp/tmpulu987ic.swift:8:2:\
    \ error: cannot find 'result' in scope\n        result := [Int]()\n        ^~~~~~\n\
    /tmp/tmpulu987ic.swift:31:9: error: cannot find 'result' in scope\n        return\
    \ result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    \n    var levels_stack: [Int] = [0]\n    var result_array:\
    \ [Int] = [0]\n    \n    let parentheses_array = paren_string.characters\n   \
    \ for i in parentheses_array.indices {\n        \n        if parentheses_array[i]\
    \ == \")\" {\n            \n            levels_stack.removeLast()\n          \
    \  result_array.append(levels_stack.removeLast())\n        }\n        \n     \
    \   levels_stack.append(1)\n    }\n    \n    return result_array\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpap6hbhu5.swift:12:42: error: 'characters' is unavailable: Please\
    \ use String directly\n    let parentheses_array = paren_string.characters\n \
    \                                        ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    paren_string = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \n    // The index of the deepest parentheses level in the input string.\n   \
    \ // If no parentheses found in the input, the value is 0.\n    var max_level\
    \ = 0\n    var output_levels = [Int]()\n\n    // The index of the last parentheses\
    \ level in the input string.\n    // If no parentheses found in the input, the\
    \ value is 0.\n    var last_level = 0\n    var last_index = 0\n\n    for current_index\
    \ in paren_string.characters.indices {\n        // If the current char is a left\
    \ parenthesis, increment level\n        if paren_string[current_index] == Character('(')\
    \ {\n            assert(last_index != current_index)\n            output_levels.append(0)\n\
    \            last_index = current_index\n        }\n\n        // If the current\
    \ char is a right parenthesis, decrease level\n        else if paren_string[current_index]\
    \ == Character(')'){\n            assert(last_index != current_index)\n      \
    \      let level = output_levels[last_index-1]\n            if level > max_level\
    \ {\n                max_level = level\n            }\n            last_index\
    \ = current_index\n        }\n    }\n\n    assert(last_index == paren_string.characters.endIndex)\n\
    \    assert(last_index == paren_string.characters.indices)\n\n    if max_level\
    \ > 0 {\n        // If the last level of parentheses is greater than zero, add\
    \ the max level to output_levels.\n        // Otherwise, add 1.\n        output_levels.append(max_level)\n\
    \    }\n\n    return output_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmprkwbqgg6.swift:22:53: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[current_index] == Character('(') {\n     \
    \                                               ^~~\n                        \
    \                            \"(\"\n/tmp/tmprkwbqgg6.swift:29:58: error: single-quoted\
    \ string literal found, use '\"'\n        else if paren_string[current_index]\
    \ == Character(')'){\n                                                       \
    \  ^~~\n                                                         \")\"\n/tmp/tmprkwbqgg6.swift:8:5:\
    \ error: cannot assign to value: 'paren_string' is a 'let' constant\n    paren_string\
    \ = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n    ^~~~~~~~~~~~\n\
    /tmp/tmprkwbqgg6.swift:8:33: error: value of type 'String' has no member 'trimmingCharacters'\n\
    \    paren_string = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \                   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmprkwbqgg6.swift:8:57:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    paren_string = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \                                                       ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprkwbqgg6.swift:20:39: error: 'characters' is unavailable: Please use String\
    \ directly\n    for current_index in paren_string.characters.indices {\n     \
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmprkwbqgg6.swift:23:31: error: operator function '!='\
    \ requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform\
    \ to 'BinaryInteger'\n            assert(last_index != current_index)\n      \
    \                        ^\nSwift.BinaryInteger:3:24: note: where 'Other' = 'DefaultIndices<String>.Element'\
    \ (aka 'String.Index')\n    public static func != <Other>(lhs: Self, rhs: Other)\
    \ -> Bool where Other : BinaryInteger\n                       ^\n/tmp/tmprkwbqgg6.swift:25:26:\
    \ error: cannot assign value o"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = Int()\n    var level = 0\n    var nested\
    \ = 0\n    var opening = 0\n    for char in paren_string.characters {\n      \
    \  if char == '(' {\n            opening++\n        }\n        if char == ')'\
    \ {\n            opening--\n        }\n        if opening > 0 {\n            level++\n\
    \        }\n        if opening < 0 {\n            level--\n        }\n       \
    \ if level > max_level {\n            max_level = level\n            nested =\
    \ Int()\n        }\n        nested += Int(char)\n    }\n    return [max_level,\
    \ nested]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5piera31.swift:13:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' {\n                   ^~~\n               \
    \    \"(\"\n/tmp/tmp5piera31.swift:16:20: error: single-quoted string literal\
    \ found, use '\"'\n        if char == ')' {\n                   ^~~\n        \
    \           \")\"\n/tmp/tmp5piera31.swift:12:30: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in paren_string.characters {\n    \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5piera31.swift:14:20: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            opening++\n                   ^~\n\
    /tmp/tmp5piera31.swift:17:20: error: cannot find operator '--' in scope; did you\
    \ mean '-= 1'?\n            opening--\n                   ^~\n/tmp/tmp5piera31.swift:20:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  level++\n                 ^~\n/tmp/tmp5piera31.swift:23:18: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            level--\n        \
    \         ^~\n/tmp/tmp5piera31.swift:29:19: error: no exact matches in call to\
    \ initializer \n        nested += Int(char)\n                  ^\nSwift.Int:7:12:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: can"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var paren_count = 0\n    var results\
    \ = [Int]()\n    for char in paren_string.characters {\n        if char == ')'\
    \ {\n            level--\n            if paren_count == 0 {\n                results.append(level)\n\
    \            }\n        }\n        else {\n            level++\n            paren_count++\n\
    \        }\n    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp3x85h_m0.swift:12:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == ')' {\n                   ^~~\n               \
    \    \")\"\n/tmp/tmp3x85h_m0.swift:11:30: error: 'characters' is unavailable:\
    \ Please use String directly\n    for char in paren_string.characters {\n    \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp3x85h_m0.swift:13:18: error: cannot find operator '--'\
    \ in scope; did you mean '-= 1'?\n            level--\n                 ^~\n/tmp/tmp3x85h_m0.swift:19:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  level++\n                 ^~\n/tmp/tmp3x85h_m0.swift:20:24: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            paren_count++\n  \
    \                     ^~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_nest = 0\n    var max_depth = 0\n    var nest\
    \ = 0\n    var depth = 0\n\n    for char in paren_string.unicodeScalars {\n  \
    \      if nesting {\n            nest--\n        }\n\n        if char == '(' {\n\
    \            nest++\n            depth++\n        } else if char == ')' {\n  \
    \          if nest == 0 {\n                continue\n            }\n         \
    \   nest--\n            depth--\n        } else {\n            if depth > max_depth\
    \ {\n                max_depth = depth\n                max_nest = nest\n    \
    \        }\n        }\n    }\n\n    return Array(0 ..< max_depth).map { _ in\n\
    \        return max_nest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpul6p6n7u.swift:18:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' {\n                   ^~~\n               \
    \    \"(\"\n/tmp/tmpul6p6n7u.swift:21:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ')' {\n                         \
    \ ^~~\n                          \")\"\n/tmp/tmpul6p6n7u.swift:14:12: error: cannot\
    \ find 'nesting' in scope\n        if nesting {\n           ^~~~~~~\n/tmp/tmpul6p6n7u.swift:15:17:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  nest--\n                ^~\n/tmp/tmpul6p6n7u.swift:19:17: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            nest++\n         \
    \       ^~\n/tmp/tmpul6p6n7u.swift:20:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n            depth++\n                 ^~\n/tmp/tmpul6p6n7u.swift:25:17:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  nest--\n                ^~\n/tmp/tmpul6p6n7u.swift:26:18: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            depth--\n        \
    \         ^~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max = [Int]()\n    var len = 0\n    for groupStr\
    \ in paren_string.components(separatedBy: \" \") {\n        if groupStr.count\
    \ > max {\n            max = Array(repeating: 0, count: groupStr.count)\n    \
    \        len = 0\n        }\n        max[len] = max(max[len], groupStr.count)\n\
    \        len += 1\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvyc_kccq.swift:10:34: error: value of type 'String' has no member\
    \ 'components'\n    for groupStr in paren_string.components(separatedBy: \" \"\
    ) {\n                    ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Remove leading '(' and trailing ')'\n    paren_string\
    \ = paren_string.trimmingCharacters(in: CharacterSet(charactersIn: \"()\"))\n\n\
    \    // Split input string by space\n    let group_strings = paren_string.components(separatedBy:\
    \ \" \")\n\n    // Parse each group string and add the deepest level of nesting\
    \ to a result array\n    var result: [Int] = [0]\n    for group_string in group_strings\
    \ {\n        // Find index of opening '('\n        let opening_pos = group_string.firstIndex(of:\
    \ \"(\")!\n\n        // Find index of closing ')'\n        let closing_pos = group_string.firstIndex(of:\
    \ \")\")!\n\n        // Add level of nesting\n        result.append(closing_pos\
    \ - opening_pos + 1)\n    }\n\n    // Return result array\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvwu29ac0.swift:9:56: error: cannot find 'CharacterSet' in scope\n\
    \    paren_string = paren_string.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \"()\"))\n                                                       ^~~~~~~~~~~~\n\
    /tmp/tmpvwu29ac0.swift:9:5: error: cannot assign to value: 'paren_string' is a\
    \ 'let' constant\n    paren_string = paren_string.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \"()\"))\n    ^~~~~~~~~~~~\n/tmp/tmpvwu29ac0.swift:9:33: error: value of type\
    \ 'String' has no member 'trimmingCharacters'\n    paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet(charactersIn: \"()\"))\n                   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvwu29ac0.swift:12:38: error: value of type 'String' has no member 'components'\n\
    \    let group_strings = paren_string.components(separatedBy: \" \")\n       \
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n  var max_level: Int = 0\n\n  for paren_char in paren_string.unicodeScalars\
    \ {\n    var level = 0\n    var parentheses = [String]()\n    var paren_count\
    \ = 0\n\n    while paren_count < paren_count {\n      if paren_char == parentheses.last!\
    \ {\n        paren_count += 1\n        continue\n      }\n\n      if paren_count\
    \ > max_level {\n        max_level = paren_count\n      }\n\n      parentheses.append(paren_char)\n\
    \      paren_count += 1\n\n      level += 1\n    }\n\n    level -= 1\n  }\n\n\
    \  return [max_level, max_level + level + 1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi2v6jgql.swift:16:21: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \      if paren_char == parentheses.last! {\n                    ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n/tmp/tmpi2v6jgql.swift:25:19: error: no exact matches in call to instance\
    \ method 'append'\n      parentheses.append(paren_char)\n                  ^\n\
    Swift.Array:6:37: note: candidate expects value of type 'String' for parameter\
    \ #1 (got 'Unicode.Scalar')\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmpi2v6jgql.swift:25:19: note: found\
    \ candidate with type '(__owned Unicode.Scalar) -> ()'\n      parentheses.append(paren_char)\n\
    \                  ^\n/tmp/tmpi2v6jgql.swift:34:34: error: cannot find 'level'\
    \ in scope\n  return [max_level, max_level + level + 1]\n                    \
    \             ^~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    if paren_string.isEmpty {\n        return []\n    }\n\
    \    var levels: [Int] = []\n    var paren_index = 0\n    var paren_open = -1\n\
    \    var paren_close = -1\n    var open_bracket = -1\n    for index in 0..<paren_string.count\
    \ {\n        let char = paren_string[index]\n        switch char {\n        case\
    \ \"(\":\n            levels[paren_index] = paren_index\n            paren_index++\n\
    \            paren_open = index\n        case \"\\\\\":\n            paren_close\
    \ = index\n        case \"\\n\":\n            levels[paren_index] = paren_index\n\
    \            paren_index++\n        default:\n            if paren_open != -1\
    \ {\n                levels[paren_index] = paren_index\n                paren_index++\n\
    \                levels[paren_index] = levels[paren_open]\n                paren_index++\n\
    \                levels[paren_index] = paren_index\n                paren_index++\n\
    \                paren_open = -1\n            }\n            if char == \"(\"\
    \ {\n                open_bracket = index\n            } else if char == \")\"\
    \ {\n                levels[paren_index] = levels[open_bracket]\n            \
    \    paren_index++\n                levels[paren_index] = levels[open_bracket]\n\
    \                paren_index++\n                levels[paren_index] = paren_index\n\
    \                paren_index++\n                open_bracket = -1\n          \
    \  }\n        }\n    }\n    return levels\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpwpi7_qdq.swift:17:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = paren_string[index]\n                   ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwpi7_qdq.swift:21:24:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  paren_index++\n                       ^~\n/tmp/tmpwpi7_qdq.swift:27:24: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            paren_index++\n\
    \                       ^~\n/tmp/tmpwpi7_qdq.swift:31:28: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                paren_index++\n       \
    \                    ^~\n/tmp/tmpwpi7_qdq.swift:33:28: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                paren_index++\n       \
    \                    ^~\n/tmp/tmpwpi7_qdq.swift:35:28: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                paren_index++\n       \
    \                    ^~\n/tmp/tmpwpi7_qdq.swift:42:28: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                paren_index++\n       \
    \                    ^~\n/tmp/tmpwpi7_qdq.swift:44:28: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                paren_index++\n       \
    \                    ^~\n/tmp/tmpwpi7_qdq.swift:46:28: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                paren_index++\n       \
    \                    ^~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    return parse_nested_parens_impl(paren_string, \"\")\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmphh9s50fm.swift:8:12: error: cannot find 'parse_nested_parens_impl'\
    \ in scope\n    return parse_nested_parens_impl(paren_string, \"\")\n        \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level_of_nesting = 0\n    for group in paren_string.split(\"\
    \ \") {\n        max_level_of_nesting = (group == \"()\" ? 1 : 0) + (group ==\
    \ \"(()\" ? 2 : 0) + (max_level_of_nesting > 0 ? 1 : 0)\n    }\n    return max_level_of_nesting\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp61ifwm64.swift:9:31: error: no exact matches in call to instance\
    \ method 'split'\n    for group in paren_string.split(\" \") {\n             \
    \                 ^\nSwift.Sequence:2:40: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n/tmp/tmp61ifwm64.swift:12:12:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return max_level_of_nesting\n           ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var depth = 0\n    var result: [Int] = []\n    for s\
    \ in paren_string.components(separatedBy: \" \") {\n        // Find a matching\
    \ opening bracket\n        var opening_bracket: Int\n        if let found = s.range(of:\
    \ \"(\") {\n            opening_bracket = found\n        } else {\n          \
    \  opening_bracket = s.endIndex\n        }\n        \n        // Find a matching\
    \ closing bracket\n        var closing_bracket: Int\n        if let found = s.range(of:\
    \ \")\") {\n            closing_bracket = found\n        } else {\n          \
    \  closing_bracket = opening_bracket\n        }\n        \n        // Get the\
    \ string between the brackets\n        let sub = String(s[opening_bracket...closing_bracket])\n\
    \        \n        // Increment the depth\n        depth += 1\n        \n    \
    \    // If depth is more than 1, append the depth\n        if depth > 1 {\n  \
    \          result.append(depth)\n        }\n        \n        // Reset the depth\n\
    \        depth = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmple3e5ev0.swift:10:27: error: value of type 'String' has no member\
    \ 'components'\n    for s in paren_string.components(separatedBy: \" \") {\n \
    \            ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // Use a stack to keep track of how many parentheses\
    \ have been opened and closed.\n    // The top of the stack will be the deepest\
    \ level of nesting.\n    var paren_stack = [0]\n\n    // This loop will execute\
    \ until it reaches the end of the paren_string array\n    for index in 0..<paren_string.characters.count\
    \ {\n        // Get the character at the index we want to check\n        let char_at_check:\
    \ Character = paren_string.character(at: index)\n\n        // Check whether the\
    \ current character is a '(' or a '{'\n        let is_opening: Bool = paren_stack.lastValue\
    \ > 0 && paren_stack[paren_stack.lastValue-1] == 0 &&\n            (char_at_check\
    \ == \")\" || char_at_check == \"}\")\n\n        // If the character is not a\
    \ '(' or a '{'\n        if is_opening {\n            // If the character is a\
    \ '('\n            if char_at_check == \"(\" {\n                // Increment the\
    \ number on the top of stack\n                paren_stack[paren_stack.lastValue-1]\
    \ += 1\n            }\n            // If the character is a '{' but the previous\
    \ character is a '('\n            else if char_at_check == \"{\" && paren_stack[paren_stack.lastValue-1]\
    \ > 0 {\n                // Decrement the number on the top of stack\n       \
    \         paren_stack[paren_stack.lastValue-1] -= 1\n            }\n        }\n\
    \n        // If the last element on the stack is less than 0\n        if paren_stack.lastValue\
    \ < 0 {\n            // Reached an invalid parenthesis string\n            return\
    \ []\n        }\n    }\n\n    // Return the number of levels of parenthesis\n\
    \    return paren_stack\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpogei6hcr.swift:13:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<paren_string.characters.count {\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpogei6hcr.swift:15:53: error: value of type 'String'\
    \ has no member 'character'\n        let char_at_check: Character = paren_string.character(at:\
    \ index)\n                                       ~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpogei6hcr.swift:18:44:\
    \ error: value of type '[Int]' has no member 'lastValue'\n        let is_opening:\
    \ Bool = paren_stack.lastValue > 0 && paren_stack[paren_stack.lastValue-1] ==\
    \ 0 &&\n                               ~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpogei6hcr.swift:18:85:\
    \ error: value of type '[Int]' has no member 'lastValue'\n        let is_opening:\
    \ Bool = paren_stack.lastValue > 0 && paren_stack[paren_stack.lastValue-1] ==\
    \ 0 &&\n                                                                     \
    \   ~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpogei6hcr.swift:26:41: error: value of type\
    \ '[Int]' has no member 'lastValue'\n                paren_stack[paren_stack.lastValue-1]\
    \ += 1\n                            ~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpogei6hcr.swift:29:69:\
    \ error: value of type '[Int]' has no member 'lastValue'\n            else if\
    \ char_at_check == \"{\" && paren_stack[paren_stack.lastValue-1] > 0 {\n     \
    \                                                   ~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpogei6hcr.swift:31:41:\
    \ error: value of type '[Int]' has no member 'lastValue'\n                paren_stack[paren_stack.lastValue-1]\
    \ -= 1\n                            ~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpogei6hcr.swift:36:24:\
    \ error: value of type '[Int]' has no member 'lastValue'\n        if paren_stack.lastValue\
    \ < 0 {\n           ~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 1\n    var level = 0\n    var max_level_paren\
    \ = 0\n    var level_paren = 0\n    \n    for char in paren_string {\n       \
    \ if char == '(' {\n            if level == 0 {\n                level += 1\n\
    \                if level_paren > max_level_paren {\n                    max_level_paren\
    \ = level_paren\n                }\n            } else {\n                level\
    \ -= 1\n            }\n        } else if char == ')' {\n            if level ==\
    \ 0 {\n                level_paren += 1\n            } else {\n              \
    \  level -= 1\n            }\n        } else {\n            if level > 0 {\n \
    \               level -= 1\n            }\n        }\n    }\n    \n    if level\
    \ > 0 {\n        max_level = 0\n    }\n    \n    var nested_paren_count = [Int](repeating:\
    \ 0, count: max_level_paren + 1)\n    for char in paren_string {\n        if char\
    \ == '(' {\n            nested_paren_count[level_paren] += 1\n        } else if\
    \ char == ')' {\n            if nested_paren_count[level_paren] == 1 {\n     \
    \           level_paren -= 1\n            }\n            nested_paren_count[level_paren]\
    \ -= 1\n        }\n    }\n    \n    return nested_paren_count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpgpgd24ua.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '(' {\n                   ^~~\n               \
    \    \"(\"\n/tmp/tmpgpgd24ua.swift:23:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ')' {\n                         \
    \ ^~~\n                          \")\"\n/tmp/tmpgpgd24ua.swift:42:20: error: single-quoted\
    \ string literal found, use '\"'\n        if char == '(' {\n                 \
    \  ^~~\n                   \"(\"\n/tmp/tmpgpgd24ua.swift:44:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == ')' {\n          \
    \                ^~~\n                          \")\"\n/tmp/tmpgpgd24ua.swift:8:9:\
    \ warning: variable 'max_level' was written to, but never read\n    var max_level\
    \ = 1\n        ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    paren_string = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    var level = 0\n    var result = 0\n    var opening_count = 0\n    var open_count\
    \ = 0\n    var close_count = 0\n    var close_count_start = -1\n    for index\
    \ in 0..<paren_string.characters.count {\n        switch paren_string.characters.reversed().first(where:\
    \ {$0 == paren_string[index]}) {\n        case \"(\":\n            if opening_count\
    \ == 0 {\n                opening_count += 1\n            }\n            open_count\
    \ += 1\n            close_count += 1\n            close_count_start = index\n\
    \        case \"(\":\n            opening_count += 1\n        case \"):\":\n \
    \           open_count -= 1\n            close_count -= 1\n            if opening_count\
    \ == 0 && open_count == 0 && close_count == 0 {\n                result = level\n\
    \                level = 0\n            }\n        case \"(\":\n            opening_count\
    \ -= 1\n            if opening_count != 0 {\n                open_count -= 1\n\
    \                close_count = open_count_start\n                open_count_start\
    \ = -1\n            }\n        default:\n            level -= 1\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpsy4_9job.swift:8:5: error: cannot assign to value: 'paren_string'\
    \ is a 'let' constant\n    paren_string = paren_string.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n    ^~~~~~~~~~~~\n/tmp/tmpsy4_9job.swift:8:33: error:\
    \ value of type 'String' has no member 'trimmingCharacters'\n    paren_string\
    \ = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n           \
    \        ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpsy4_9job.swift:8:57: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    paren_string = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \                                                       ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpsy4_9job.swift:15:35: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<paren_string.characters.count {\n           \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpsy4_9job.swift:16:29: error: 'characters' is unavailable:\
    \ Please use String directly\n        switch paren_string.characters.reversed().first(where:\
    \ {$0 == paren_string[index]}) {\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpsy4_9job.swift:16:71: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        switch paren_string.characters.reversed().first(where: {$0 == paren_string[index]})\
    \ {\n                                                                      ^~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpsy4_9job.swift:26:14:\
    \ error: expression pattern of type 'String' cannot match values of type 'ReversedCollection<String>.Element?'\
    \ (aka 'Optional<Character>')\n        case \"):\":\n             ^~~~\n/tmp/tmpsy4_9job."
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 1\n    var num_level = 0\n    var paren_stack:\
    \ [Int] = []\n    for index in 0..<paren_string.characters.count {\n        if\
    \ paren_string[index] == '(' {\n            num_level++\n            if num_level\
    \ > level {\n                level = num_level\n            }\n        }\n   \
    \     else if paren_string[index] == ')' {\n            num_level--\n        \
    \    if num_level < level {\n                level = num_level\n            }\n\
    \        }\n        paren_stack.append(num_level)\n    }\n    return paren_stack\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc37ycdgn.swift:12:35: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[index] == '(' {\n                        \
    \          ^~~\n                                  \"(\"\n/tmp/tmpc37ycdgn.swift:18:40:\
    \ error: single-quoted string literal found, use '\"'\n        else if paren_string[index]\
    \ == ')' {\n                                       ^~~\n                     \
    \                  \")\"\n/tmp/tmpc37ycdgn.swift:11:35: error: 'characters' is\
    \ unavailable: Please use String directly\n    for index in 0..<paren_string.characters.count\
    \ {\n                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpc37ycdgn.swift:12:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ paren_string[index] == '(' {\n           ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpc37ycdgn.swift:13:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  num_level++\n                     ^~\n/tmp/tmpc37ycdgn.swift:18:17: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        else if paren_string[index] == ')' {\n                ^~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpc37ycdgn.swift:19:22:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  num_level--\n                     ^~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n\n    for opening_paren_index\
    \ in 0..<paren_string.count {\n        if paren_string[opening_paren_index] !=\
    \ \")\" {\n            levels.append(opening_paren_index + 1)\n            continue\n\
    \        }\n\n        for nested_paren_index in levels[levels.count-1]..<paren_string.count\
    \ {\n            if paren_string[nested_paren_index] != \")\" {\n            \
    \    levels = append(levels, nested_paren_index + 1)\n                break\n\
    \            }\n        }\n\n        break\n    }\n\n    return levels\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmptyvou9aw.swift:11:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if paren_string[opening_paren_index]\
    \ != \")\" {\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptyvou9aw.swift:17:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if paren_string[nested_paren_index]\
    \ != \")\" {\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptyvou9aw.swift:18:26:\
    \ error: cannot find 'append' in scope\n                levels = append(levels,\
    \ nested_paren_index + 1)\n                         ^~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var nested = 0\n    for index in paren_string.characters\
    \ {\n        let open_char = paren_string[index].unicodeScalars.first!.value //\
    \ '('\n        let close_char = paren_string[index + 1].unicodeScalars.first!.value\
    \ // ')'\n\n        // If the open bracket has a higher level than the current\
    \ nested level, increment it.\n        if paren_string[nested] == '(' && open_char\
    \ > nested {\n            nested += 1\n        }\n\n        // If the close bracket\
    \ has a higher level than the current nested level, decrement it.\n        if\
    \ paren_string[nested] == '(' && close_char > nested {\n            nested -=\
    \ 1\n        }\n\n        // If there is still a higher level than the current\
    \ nested level, we keep the current value.\n        if paren_string[nested] ==\
    \ '(' && open_char > nested {\n            nested = open_char\n        }\n\n \
    \       // If the close bracket has a lower level than the current nested level,\
    \ we keep the current value.\n        if paren_string[nested] == '(' && close_char\
    \ < nested {\n            nested = close_char\n        }\n\n        // If the\
    \ current nested level is equal to the highest level found so far, increment it.\n\
    \        if paren_string[nested] == ')' && close_char == nested {\n          \
    \  nested += 1\n        }\n\n        // If the current nested level is equal to\
    \ the lowest level found so far, decrement it.\n        if paren_string[nested]\
    \ == '(' && open_char == nested {\n            nested -= 1\n        }\n    }\n\
    \    return nested\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5pb4e342.swift:14:36: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[nested] == '(' && open_char > nested {\n \
    \                                  ^~~\n                                   \"\
    (\"\n/tmp/tmp5pb4e342.swift:19:36: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[nested] == '(' && close_char > nested {\n\
    \                                   ^~~\n                                   \"\
    (\"\n/tmp/tmp5pb4e342.swift:24:36: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[nested] == '(' && open_char > nested {\n \
    \                                  ^~~\n                                   \"\
    (\"\n/tmp/tmp5pb4e342.swift:29:36: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[nested] == '(' && close_char < nested {\n\
    \                                   ^~~\n                                   \"\
    (\"\n/tmp/tmp5pb4e342.swift:34:36: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[nested] == ')' && close_char == nested {\n\
    \                                   ^~~\n                                   \"\
    )\"\n/tmp/tmp5pb4e342.swift:39:36: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[nested] == '(' && open_char == nested {\n\
    \                                   ^~~\n                                   \"\
    (\"\n/tmp/tmp5pb4e342.swift:9:31: error: 'characters' is unavailable: Please use\
    \ String directly\n    for index in paren_string.characters {\n              \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5pb4e342.swift:10:37: error: no exact matches in call to subscript\
    \ \n        let open_char = paren_string[index].unicodeScalars.first!.value //\
    \ '('\n                                    ^\nSwift.String:12:12: note: candidate\
    \ expects value of type 'String.Index' for parameter #1 (got 'Character')\n  \
    \  public subscript(i: String.Index) -> Character { get }\n           ^\nSwift.String:3:12:\
    \ note: candidate"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level = 0\n    for level in paren_string.split(\"\
    \ \") {\n        let level_ = Int(level)\n        if level_ > max_level {\n  \
    \          max_level = level_\n        }\n    }\n    return Array(0 ..< max_level)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2ff7amhe.swift:9:31: error: no exact matches in call to instance\
    \ method 'split'\n    for level in paren_string.split(\" \") {\n             \
    \                 ^\nSwift.Sequence:2:40: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var paren_depth: Int = 0\n    var max_level = 0\n  \
    \  var paren_level = [Int]()\n    \n    paren_string.split{$0 == \" \"}.forEach\
    \ { \n        let new_level = int(paren_level[paren_depth])\n        if new_level\
    \ > max_level {\n            max_level = new_level\n        }\n        paren_depth++\n\
    \        paren_level[paren_depth] = paren_depth\n    }\n    \n    return paren_level.map\
    \ { ($0) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpjur_1x9a.swift:13:25: error: cannot find 'int' in scope\n     \
    \   let new_level = int(paren_level[paren_depth])\n                        ^~~\n\
    /tmp/tmpjur_1x9a.swift:17:20: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        paren_depth++\n                   ^~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var max_level: [Int] = [0]\n    for i in 1..<paren_string.count\
    \ {\n        var level = 0\n        for j in 0..<paren_string.count {\n      \
    \      if (paren_string[j] != paren_string[i]) {\n                break\n    \
    \        }\n            level++\n        }\n        max_level = max(max_level,\
    \ level)\n    }\n    return max_level\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpzlqr2ez_.swift:12:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if (paren_string[j]\
    \ != paren_string[i]) {\n                ^~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpzlqr2ez_.swift:12:36: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            if (paren_string[j] != paren_string[i]) {\n          \
    \                         ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzlqr2ez_.swift:15:18: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            level++\n   \
    \              ^~\n/tmp/tmpzlqr2ez_.swift:17:21: error: cannot assign value of\
    \ type 'Int' to type '[Int]'\n        max_level = max(max_level, level)\n    \
    \                ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzlqr2ez_.swift:17:25: error: cannot\
    \ convert value of type '[Int]' to expected argument type 'Int'\n        max_level\
    \ = max(max_level, level)\n                        ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var depth = 0\n    var par: Int = 0\n    var par_string:\
    \ String = paren_string\n\n    for ch in par_string.unicodeScalars {\n       \
    \ if ch.value == 0x28 {\n            depth += 1 // if we find a (, increase the\
    \ depth count\n        } else {\n            depth -= 1 // if we find a ), decrease\
    \ the depth count\n            if depth == 0 {\n                par = par_string.unicodeScalars.index(ch)\n\
    \            }\n        }\n    }\n    return [par, par_string.unicodeScalars.count\
    \ - par]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpu6p9bsxb.swift:18:49: error: cannot assign value of type 'String.UnicodeScalarView.Index?'\
    \ (aka 'Optional<String.Index>') to type 'Int'\n                par = par_string.unicodeScalars.index(ch)\n\
    \                      ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmpu6p9bsxb.swift:18:55:\
    \ error: missing argument label 'of:' in call\n                par = par_string.unicodeScalars.index(ch)\n\
    \                                                      ^\n                   \
    \                                   of: \n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    debug_assert_eq!(paren_string.count(\"(\"), paren_string.count(\"\
    )\"))\n    let mut levels = [Int::new(); paren_string.count(\"(\")]\n    for i\
    \ in 0..paren_string.count(\"(\") {\n        let start = i\n        let end =\
    \ paren_string.count(\")\", start+1)\n        debug_assert!(end != 0)\n      \
    \  levels[i] = end - start\n    }\n\n    // start from right to left\n    for\
    \ level in levels.rt() {\n        let mut index = 0\n        for _ in 0..level\
    \ {\n            index = paren_string.rfind(\"(\", index) + 1\n        }\n   \
    \     levels[level] = index\n    }\n\n    return levels\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi_7zs69a.swift:9:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut levels =\
    \ [Int::new(); paren_string.count(\"(\")]\n            ^\n/tmp/tmpi_7zs69a.swift:9:13:\
    \ note: join the identifiers together\n    let mut levels = [Int::new(); paren_string.count(\"\
    (\")]\n        ~~~~^~~~~~\n        mutlevels\n/tmp/tmpi_7zs69a.swift:9:13: note:\
    \ join the identifiers together with camel-case\n    let mut levels = [Int::new();\
    \ paren_string.count(\"(\")]\n        ~~~~^~~~~~\n        mutLevels\n/tmp/tmpi_7zs69a.swift:9:27:\
    \ error: expected value in dictionary literal\n    let mut levels = [Int::new();\
    \ paren_string.count(\"(\")]\n                          ^\n/tmp/tmpi_7zs69a.swift:19:17:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n        let mut index = 0\n                ^\n/tmp/tmpi_7zs69a.swift:19:17:\
    \ note: join the identifiers together\n        let mut index = 0\n           \
    \ ~~~~^~~~~\n            mutindex\n/tmp/tmpi_7zs69a.swift:19:17: note: join the\
    \ identifiers together with camel-case\n        let mut index = 0\n          \
    \  ~~~~^~~~~\n            mutIndex\n/tmp/tmpi_7zs69a.swift:8:5: error: cannot\
    \ find 'debug_assert_eq' in scope\n    debug_assert_eq!(paren_string.count(\"\
    (\"), paren_string.count(\")\"))\n    ^~~~~~~~~~~~~~~\n/tmp/tmpi_7zs69a.swift:8:35:\
    \ error: cannot call value of non-function type 'Int'\n    debug_assert_eq!(paren_string.count(\"\
    (\"), paren_string.count(\")\"))\n                                  ^\n/tmp/tmpi_7zs69a.swift:8:60:\
    \ error: cannot call value of non-function type 'Int'\n    debug_assert_eq!(paren_string.count(\"\
    (\"), paren_string.count(\")\"))\n                                           \
    \                ^\n/tmp/tmpi_7zs69a.swift:9:22: error: type 'Int.Type' cannot\
    \ conform to 'Hashable'\n    let mut levels = [Int::new(); paren_string.count(\"\
    (\")]\n                     ^\n/tmp/tmpi_7zs69a.swift:9:22: note: only concrete\
    \ types such as structs, enums and classes can conform to protocols\n    let mut\
    \ levels = [Int::new(); paren_stri"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tlet paren_stack = paren_string.characters.split(separator:\
    \ \" \").map({String($0)})\n\tvar levels = [Int]()\n\tvar depth = 0\n\tfor paren_group\
    \ in paren_stack {\n\t\tlet index = paren_stack.index(of: paren_group)\n\t\tlet\
    \ level = 0\n\t\tif index != nil {\n\t\t\tlevel = paren_stack.index(of: paren_group[index!])\
    \ - index!\n\t\t}\n\t\tdepth = max(depth, level)\n\t}\n\tlevels.append(depth)\n\
    \treturn levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpgd53hecy.swift:8:33: error: 'characters' is unavailable: Please\
    \ use String directly\n        let paren_stack = paren_string.characters.split(separator:\
    \ \" \").map({String($0)})\n                                       ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgd53hecy.swift:12:27:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        \
    \        let index = paren_stack.index(of: paren_group)\n                    \
    \                    ^\n/tmp/tmpgd53hecy.swift:12:27: note: use 'firstIndex(of:)'\
    \ instead\n                let index = paren_stack.index(of: paren_group)\n  \
    \                                      ^~~~~\n                               \
    \         firstIndex\n/tmp/tmpgd53hecy.swift:15:4: error: cannot assign to value:\
    \ 'level' is a 'let' constant\n                        level = paren_stack.index(of:\
    \ paren_group[index!]) - index!\n                        ^~~~~\n/tmp/tmpgd53hecy.swift:13:3:\
    \ note: change 'let' to 'var' to make it mutable\n                let level =\
    \ 0\n                ^~~\n                var\n/tmp/tmpgd53hecy.swift:15:45: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                        level = paren_stack.index(of: paren_group[index!]) -\
    \ index!\n                                                                 ^\n\
    /tmp/tmpgd53hecy.swift:15:24: error: value of optional type 'Array<String>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<String>.Index'\
    \ (aka 'Int')\n                        level = paren_stack.index(of: paren_group[index!])\
    \ - index!\n                                            ^\n/tmp/tmpgd53hecy.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n                        level = paren_stack.index(of: paren_group[index!])\
    \ - index!\n                                            ^\n                  \
    \              (                                          ?? <#default value#>)\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tvar max_level = 0\n\tlevel_stack = Array(repeating: 0,\
    \ count: paren_string.count)\n\tparen_index = -1\n\tparen_counter = 0\n\tvar char_to_push\
    \ = 0\n\tfor char in paren_string {\n\t\tif char == '(' || char == '[' {\n\t\t\
    \tlevel_stack[paren_index] = paren_counter\n\t\t\tparen_counter += 1\n\t\t}\n\t\
    \tif char == ')' || char == ']' {\n\t\t\tparen_counter += 1\n\t\t\tif paren_counter\
    \ > level_stack[paren_index] {\n\t\t\t\tlevel_stack[paren_index] = paren_counter\n\
    \t\t\t}\n\t\t}\n\t\tchar_to_push = char\n\t}\n\tfor char in level_stack {\n\t\t\
    if char > max_level {\n\t\t\tmax_level = char\n\t\t}\n\t}\n\treturn Array(repeating:\
    \ max_level, count: level_stack.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpmfeg3g6_.swift:14:14: error: single-quoted string literal found,\
    \ use '\"'\n                if char == '(' || char == '[' {\n                \
    \           ^~~\n                           \"(\"\n/tmp/tmpmfeg3g6_.swift:14:29:\
    \ error: single-quoted string literal found, use '\"'\n                if char\
    \ == '(' || char == '[' {\n                                          ^~~\n   \
    \                                       \"[\"\n/tmp/tmpmfeg3g6_.swift:18:14: error:\
    \ single-quoted string literal found, use '\"'\n                if char == ')'\
    \ || char == ']' {\n                           ^~~\n                         \
    \  \")\"\n/tmp/tmpmfeg3g6_.swift:18:29: error: single-quoted string literal found,\
    \ use '\"'\n                if char == ')' || char == ']' {\n                \
    \                          ^~~\n                                          \"]\"\
    \n/tmp/tmpmfeg3g6_.swift:9:2: error: cannot find 'level_stack' in scope\n    \
    \    level_stack = Array(repeating: 0, count: paren_string.count)\n        ^~~~~~~~~~~\n\
    /tmp/tmpmfeg3g6_.swift:10:2: error: cannot find 'paren_index' in scope\n     \
    \   paren_index = -1\n        ^~~~~~~~~~~\n/tmp/tmpmfeg3g6_.swift:11:2: error:\
    \ cannot find 'paren_counter' in scope\n        paren_counter = 0\n        ^~~~~~~~~~~~~\n\
    /tmp/tmpmfeg3g6_.swift:15:4: error: cannot find 'level_stack' in scope\n     \
    \                   level_stack[paren_index] = paren_counter\n               \
    \         ^~~~~~~~~~~\n/tmp/tmpmfeg3g6_.swift:15:16: error: cannot find 'paren_index'\
    \ in scope\n                        level_stack[paren_index] = paren_counter\n\
    \                                    ^~~~~~~~~~~\n/tmp/tmpmfeg3g6_.swift:15:31:\
    \ error: cannot find 'paren_counter' in scope\n                        level_stack[paren_index]\
    \ = paren_counter\n                                                   ^~~~~~~~~~~~~\n\
    /tmp/tmpmfeg3g6_.swift:16:4: error: cannot find 'paren_counter' in scope\n   \
    \                     paren_counter += 1\n                        ^~~~~~~~~~~~~\n\
    /tmp/tmpmfeg3g6_.swift:19:4: error: cannot find 'paren_counter' in scope\n   \
    \                     paren_counter +="
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let regex = \"\\\\(|\\\\)\".toRegex()\n    \n    let\
    \ rangeOfString: NSRange = paren_string.rangeOfString(regex, options: .CaseInsensitive)\n\
    \    \n    var result = [Int]()\n    \n    if rangeOfString.length == 0 {\n  \
    \      return nil\n    }\n    \n    for match in paren_string.matchesInString(paren_string,\
    \ options: .CaseInsensitive) {\n        let subString: String = paren_string.substringWithRange(match.range)\n\
    \        \n        if let groupCount: Int = subString.countByCharactingInSet(regex.invertedSet).max(),\
    \ groupCount > result.count {\n            result.removeAll(keepCapacity: true)\n\
    \        }\n        \n        result.insert((subString.countByCharactingInSet(regex.invertedSet)),\
    \ atIndex: result.count)\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpjvqlf2db.swift:8:27: error: value of type 'String' has no member\
    \ 'toRegex'\n    let regex = \"\\\\(|\\\\)\".toRegex()\n                ~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpjvqlf2db.swift:10:24: error: cannot find type 'NSRange' in\
    \ scope\n    let rangeOfString: NSRange = paren_string.rangeOfString(regex, options:\
    \ .CaseInsensitive)\n                       ^~~~~~~\n/tmp/tmpjvqlf2db.swift:15:16:\
    \ error: 'nil' is incompatible with return type '[Int]'\n        return nil\n\
    \               ^\n/tmp/tmpjvqlf2db.swift:18:31: error: value of type 'String'\
    \ has no member 'matchesInString'\n    for match in paren_string.matchesInString(paren_string,\
    \ options: .CaseInsensitive) {\n                 ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpjvqlf2db.swift:18:71: error: cannot infer contextual base in reference\
    \ to member 'CaseInsensitive'\n    for match in paren_string.matchesInString(paren_string,\
    \ options: .CaseInsensitive) {\n                                             \
    \                        ~^~~~~~~~~~~~~~~\n/tmp/tmpjvqlf2db.swift:21:44: error:\
    \ value of type 'String' has no member 'countByCharactingInSet'\n        if let\
    \ groupCount: Int = subString.countByCharactingInSet(regex.invertedSet).max(),\
    \ groupCount > result.count {\n                                 ~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n\tlet paren_chars = paren_string.characters\n\t\n\tvar count\
    \ = 0\n\t\n\tvar level = 0\n\t\n\tvar level_start = 0\n\t\n\tvar level_end = 0\n\
    \t\n\tvar open_braces = false // whether we encountered an opening brace character\
    \ yet\n\tvar close_braces = false // whether we encountered a closing brace character\
    \ yet\n\t\n\tvar prev_open_brace = false // whether we encountered an opening\
    \ brace character earlier\n\tvar prev_close_brace = false // whether we encountered\
    \ a closing brace character earlier\n\t\n\tvar prev_char = \"\" // what character\
    \ we last saw when we encoutered a closing brace character\n\t\n\tvar i = 0\n\t\
    \n\twhile i < paren_chars.count {\n\t\tswitch paren_chars[i] {\n\t\tcase ')':\
    \ // if we saw a closing brace, set the closing brace level\n\t\t\tif close_braces\
    \ {\n\t\t\t\tlevel--\n\t\t\t}\n\t\t\tclose_braces = true\n\t\t\topen_braces =\
    \ false\n\t\tcase '(':\n\t\t\tif !open_braces {\n\t\t\t\tlevel++\n\t\t\t}\n\t\t\
    \topen_braces = true\n\t\t\tclose_braces = false\n\t\tcase '}':\n\t\t\tif prev_open_brace\
    \ {\n\t\t\t\tprev_char = '}'\n\t\t\t\tlevel--\n\t\t\t}\n\t\t\topen_braces = false\n\
    \t\t\tclose_braces = true\n\t\tcase '{':\n\t\t\tif !open_braces {\n\t\t\t\tlevel++\n\
    \t\t\t}\n\t\t\topen_braces = true\n\t\t\tclose_braces = false\n\t\tcase ' ':\n\
    \t\t\t// If we encounter a space, it is the end of the current level.\n\t\t\t\
    level++\n\t\t\tlevel_end = i\n\t\tcase '\\t':\n\t\t\t// Ignore tabs\n\t\tdefault:\n\
    \t\t\t// We encountered a character we didn't recognize, so keep track of the\
    \ current level\n\t\t\tif open_braces {\n\t\t\t\tlevel--\n\t\t\t}\n\t\t\tprev_char\
    \ = paren_chars[i]\n\t\t\tlevel_start = i\n\t\t\tbreak\n\t\t}\n\t\t\n\t\t// If\
    \ we are at the end of a level, set the previous character and increment the level\n\
    \t\tif level_end == paren_chars.count {\n\t\t\tlevel--\n\t\t\tprev_char = paren_chars[i]\n\
    \t\t\tlevel_start = i + 1\n\t\t}\n\t\t\n\t\ti++\n\t}\n\t\n\t// We are at the end\
    \ of the string, so set the current level and level to 0\n\tif level_end < paren_chars.count\
    \ {\n\t\tlevel--\n\t\tprev_char = paren_chars[level_end]\n\t}\n\t\n\tlet result:\
    \ [Int] = [level]\n\t\n\t// We will never encounter a \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2541vulu.swift:30:8: error: single-quoted string literal found,\
    \ use '\"'\n                case ')': // if we saw a closing brace, set the closing\
    \ brace level\n                     ^~~\n                     \")\"\n/tmp/tmp2541vulu.swift:36:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '(':\n\
    \                     ^~~\n                     \"(\"\n/tmp/tmp2541vulu.swift:42:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '}':\n\
    \                     ^~~\n                     \"}\"\n/tmp/tmp2541vulu.swift:44:17:\
    \ error: single-quoted string literal found, use '\"'\n                      \
    \          prev_char = '}'\n                                            ^~~\n\
    \                                            \"}\"\n/tmp/tmp2541vulu.swift:49:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '{':\n\
    \                     ^~~\n                     \"{\"\n/tmp/tmp2541vulu.swift:55:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '\
    \ ':\n                     ^~~\n                     \" \"\n/tmp/tmp2541vulu.swift:59:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '\\\
    t':\n                     ^~~~\n                     \"\\t\"\n/tmp/tmp2541vulu.swift:59:3:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \                case '\\t':\n                ^~~~~~~~~~\n                   \
    \        break\n/tmp/tmp2541vulu.swift:8:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        let paren_chars = paren_string.characters\n\
    \                                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2541vulu.swift:29:10: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       switch paren_chars[i] {\n                       ^~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subs"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    if paren_string.count <= 1 {\n        return []\n  \
    \  }\n\n    var max = 0\n    var result = [Int]()\n\n    for _i in 0..<paren_string.count\
    \ {\n        if paren_string[_i] == '(' {\n            max = max! + 1\n      \
    \  }\n        else if paren_string[_i] == ')' {\n            max = max! - 1\n\
    \        }\n\n        result.append(max)\n    }\n\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvtpquynf.swift:16:32: error: single-quoted string literal found,\
    \ use '\"'\n        if paren_string[_i] == '(' {\n                           \
    \    ^~~\n                               \"(\"\n/tmp/tmpvtpquynf.swift:19:37:\
    \ error: single-quoted string literal found, use '\"'\n        else if paren_string[_i]\
    \ == ')' {\n                                    ^~~\n                        \
    \            \")\"\n/tmp/tmpvtpquynf.swift:16:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ paren_string[_i] == '(' {\n           ^~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpvtpquynf.swift:17:22: error:\
    \ cannot force unwrap value of non-optional type 'Int'\n            max = max!\
    \ + 1\n                  ~~~^\n                     \n/tmp/tmpvtpquynf.swift:19:17:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        else if paren_string[_i] == ')' {\n   \
    \             ^~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpvtpquynf.swift:20:22: error: cannot force unwrap\
    \ value of non-optional type 'Int'\n            max = max! - 1\n             \
    \     ~~~^\n                     \n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let paren_array = paren_string.characters\n        .enumerate()\n\
    \        .map { index, char in\n            switch char {\n            case '(':\n\
    \                let opening = paren_array[index + 1]\n                let closing\
    \ = paren_array[index + 2]\n                return max(opening as! Int, closing\
    \ as! Int) + 1\n            case ')':\n                let opening = paren_array[index\
    \ + 1]\n                let closing = paren_array[index + 2]\n               \
    \ return max(opening as! Int, closing as! Int)\n            default:\n       \
    \         return 0\n            }\n        }\n    return paren_array\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmphrdq_6mc.swift:12:18: error: single-quoted string literal found,\
    \ use '\"'\n            case '(':\n                 ^~~\n                 \"(\"\
    \n/tmp/tmphrdq_6mc.swift:16:18: error: single-quoted string literal found, use\
    \ '\"'\n            case ')':\n                 ^~~\n                 \")\"\n\
    /tmp/tmphrdq_6mc.swift:9:10: error: value of type 'String' has no member 'enumerate'\n\
    \        .enumerate()\n         ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    paren_string = paren_string.trim()\n    paren_string\
    \ = paren_string.dropLast()\n    var count = 0\n    var opening_bracket: Bool\
    \ = false\n    var level = 0\n    var nested_count = [Int]()\n    for i in paren_string.indices(of:\
    \ \" \") {\n        if paren_string[i] != \"(\" {\n            nested_count[level]\
    \ += 1\n        } else {\n            opening_bracket = true\n            level++\n\
    \        }\n    }\n\n    if level != 0 {\n        nested_count[level] += 1\n \
    \   }\n    if opening_bracket == false {\n        return 0\n    }\n\n    for parens\
    \ in 0..<level {\n        nested_count[parens] = 0\n    }\n\n    for i in 0..<nested_count.count\
    \ {\n        count += nested_count[i]\n    }\n\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5btf932i.swift:8:5: error: cannot assign to value: 'paren_string'\
    \ is a 'let' constant\n    paren_string = paren_string.trim()\n    ^~~~~~~~~~~~\n\
    /tmp/tmp5btf932i.swift:8:33: error: value of type 'String' has no member 'trim'\n\
    \    paren_string = paren_string.trim()\n                   ~~~~~~~~~~~~ ^~~~\n\
    /tmp/tmp5btf932i.swift:9:5: error: cannot assign to value: 'paren_string' is a\
    \ 'let' constant\n    paren_string = paren_string.dropLast()\n    ^~~~~~~~~~~~\n\
    /tmp/tmp5btf932i.swift:9:33: error: no 'dropLast' candidates produce the expected\
    \ contextual result type 'String'\n    paren_string = paren_string.dropLast()\n\
    \                                ^\nSwift.Sequence:5:40: note: 'dropLast' produces\
    \ '[String.Element]' (aka 'Array<Character>'), not the expected contextual result\
    \ type 'String'\n    @inlinable public __consuming func dropLast(_ k: Int = 1)\
    \ -> [Self.Element]\n                                       ^\nSwift.Collection:4:40:\
    \ note: 'dropLast' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func dropLast(_\
    \ k: Int = 1) -> Self.SubSequence\n                                       ^\n\
    /tmp/tmp5btf932i.swift:14:27: error: cannot call value of non-function type 'DefaultIndices<String>'\n\
    \    for i in paren_string.indices(of: \" \") {\n                          ^\n\
    /tmp/tmp5btf932i.swift:27:16: error: cannot convert return expression of type\
    \ 'Int' to return type '[Int]'\n        return 0\n               ^\n/tmp/tmp5btf932i.swift:38:12:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return count\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    let paren_groups = paren_string.characters\n       \
    \ .split{$0 == \"(\" || $0 == \"}\"}\n        .map(String.init)\n    return paren_groups\n\
    \        .enumerated()\n        .reduce([Int](), {$0 + [$1] + parse_nested_parens(paren_string:\
    \ $1)})\n        .reversed()\n        .map(String.init)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp814r7t_q.swift:8:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    let paren_groups = paren_string.characters\n      \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp814r7t_q.swift:11:12: error: the compiler is unable\
    \ to type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n    return paren_groups\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009513
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var levels = [Int]()\n    var parens = 0\n    var open\
    \ = 0\n    var close = 0\n    var last = 0\n    for index, char in enumerate(paren_string)\
    \ {\n        if char == \"(\" || char == \"{\" || char == \"[\" {\n          \
    \  open += 1\n            levels.append(Int((parens - open)))\n        } else\
    \ if char == \")\" || char == \"}\" || char == \"]\" {\n            levels[last\
    \ - close] += 1\n            close += 1\n        }\n        if char == \")\" {\n\
    \            last = index\n        }\n    }\n    return levels\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpyyic_t1r.swift:13:14: error: expected 'in' after for-each pattern\n\
    \    for index, char in enumerate(paren_string) {\n             ^\n/tmp/tmpyyic_t1r.swift:13:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, char in\
    \ enumerate(paren_string) {\n             ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    // First find the largest level of nesting\n    var\
    \ level = 1\n    var max_level = 1\n    for level in 1...paren_string.count{\n\
    \        level_chars := paren_string[level]\n        if level_chars == '(' ||\
    \ level_chars == '{' || level_chars == '[' {\n            max_level = level\n\
    \        }\n    }\n\n    // Now traverse the string and count the level of nesting\n\
    \    var level_count : [Int] = [Int](repeating: 0, count: max_level+1)\n    for\
    \ level in 1...paren_string.count{\n        level_chars := paren_string[level]\n\
    \        if level_chars == '(' || level_chars == '{' || level_chars == '[' {\n\
    \            level_count[level] += 1\n        }\n    }\n\n    // Return the level\
    \ of nesting\n    return level_count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpghpbkzqr.swift:12:20: error: consecutive statements on a line must\
    \ be separated by ';'\n        level_chars := paren_string[level]\n          \
    \         ^\n                   ;\n/tmp/tmpghpbkzqr.swift:12:21: error: expected\
    \ expression\n        level_chars := paren_string[level]\n                   \
    \ ^\n/tmp/tmpghpbkzqr.swift:13:27: error: single-quoted string literal found,\
    \ use '\"'\n        if level_chars == '(' || level_chars == '{' || level_chars\
    \ == '[' {\n                          ^~~\n                          \"(\"\n/tmp/tmpghpbkzqr.swift:13:49:\
    \ error: single-quoted string literal found, use '\"'\n        if level_chars\
    \ == '(' || level_chars == '{' || level_chars == '[' {\n                     \
    \                           ^~~\n                                            \
    \    \"{\"\n/tmp/tmpghpbkzqr.swift:13:71: error: single-quoted string literal\
    \ found, use '\"'\n        if level_chars == '(' || level_chars == '{' || level_chars\
    \ == '[' {\n                                                                 \
    \     ^~~\n                                                                  \
    \    \"[\"\n/tmp/tmpghpbkzqr.swift:21:20: error: consecutive statements on a line\
    \ must be separated by ';'\n        level_chars := paren_string[level]\n     \
    \              ^\n                   ;\n/tmp/tmpghpbkzqr.swift:21:21: error: expected\
    \ expression\n        level_chars := paren_string[level]\n                   \
    \ ^\n/tmp/tmpghpbkzqr.swift:22:27: error: single-quoted string literal found,\
    \ use '\"'\n        if level_chars == '(' || level_chars == '{' || level_chars\
    \ == '[' {\n                          ^~~\n                          \"(\"\n/tmp/tmpghpbkzqr.swift:22:49:\
    \ error: single-quoted string literal found, use '\"'\n        if level_chars\
    \ == '(' || level_chars == '{' || level_chars == '[' {\n                     \
    \                           ^~~\n                                            \
    \    \"{\"\n/tmp/tmpghpbkzqr.swift:22:71: error: single-quoted string literal\
    \ found, use '\"'\n        if level_chars == '(' || level_chars == '{' || level_chars\
    \ == '[' {\n                          "
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var result = [Int]()\n    for s in paren_string.split(\"\
    \ \") {\n        guard let int = s.toInt(), int > 0 && int != 0 else { return\
    \ result }\n        result.append(int)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpwcznqpw_.swift:9:27: error: no exact matches in call to instance\
    \ method 'split'\n    for s in paren_string.split(\" \") {\n                 \
    \         ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    if paren_string.count < 1 {\n        return []\n   \
    \ }\n\n    // The maximum nesting level of any substring is\n    // the length\
    \ of the string minus the substring length\n    let max_level = (paren_string.count\
    \ - paren_string.characters.count) / 2\n    // The deepest level of nesting is\
    \ the maximum between\n    // the deepest level of each pair of nested parentheses\n\
    \    let max_level = min(max_level, parse_nested_parens_helper(paren_string, 0))\n\
    \    return Array(0 ..< max_level)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp37c8yk_i.swift:14:56: error: 'characters' is unavailable: Please\
    \ use String directly\n    let max_level = (paren_string.count - paren_string.characters.count)\
    \ / 2\n                                                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp37c8yk_i.swift:17:36: error: cannot find\
    \ 'parse_nested_parens_helper' in scope\n    let max_level = min(max_level, parse_nested_parens_helper(paren_string,\
    \ 0))\n                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
    \ String) -> [Int] {\n    var level = 0\n    var levels = [Int]()\n    for paren\
    \ in paren_string.characters {\n        if paren == \")\" {\n            levels[level\
    \ - 1] += 1\n        }\n        level = 0\n        if paren != \"(\" {\n     \
    \       level += 1\n        }\n        levels.append(level)\n    }\n    return\
    \ levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp_9vberj_.swift:10:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for paren in paren_string.characters {\n          \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660009449
