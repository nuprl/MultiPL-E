name: HumanEval_128_prod_signs
language: swift
prompt: "\n/// You are given an array arr of integers and you need to return\n///\
  \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
  \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
  \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
  \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
  \ [Int]) -> Int? {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\n\
  assert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1,\
  \ 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
  \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
  assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
  \ 0]) == 0)"
completions: ["    // TODO: Write your code here\n    return nil", "    var sum =\
    \ 0\n    var product = 1\n    for i in arr {\n        switch i {\n        case\
    \ 1:\n            sum += product\n        case -1:\n            product *= -1\n\
    \        case 0:\n            return nil\n        default:\n            sum +=\
    \ i\n            product *= i\n        }\n    }\n    return sum", "    guard !arr.isEmpty\
    \ else { return nil }\n    var signs = 1\n    for x in arr { signs *= 1 }\n  \
    \  var result = signs\n    for x in arr {\n        result *= signs[x]\n    }\n\
    \    return result", '    return arr.reduce(0) { $1 * is_sign($0) }', "    guard\
    \ arr.count > 0 else {\n        return nil\n    }\n    var product = arr[0]\n\
    \    for i in arr {\n        product *= sign(i)\n    }\n    return product", " \
    \   var result: Int? = nil\n    for n in arr {\n        let sign = sign(n: n)\n\
    \        let product = product(sign: sign)\n        result = product * (result\
    \ ?? product)\n    }\n    return result", "    var product: Int?\n    for v in\
    \ arr {\n        product = v * (v == 0 ? 0 : 1)\n    }\n    return product", " \
    \   var sum = arr[0]\n    for i in 1..<arr.count {\n        sum += signs(arr[i])\
    \ * arr[i]\n    }\n    return sum", "    var m = -1\n    for x in arr {\n    \
    \    m *= x\n    }\n    return m", "    guard !arr.isEmpty else { return nil }\n\
    \    guard let i = arr.first else {\n        return nil\n    }\n    var m = Int()\n\
    \    var sign = 1\n    for v in arr.dropFirst() {\n        let x = v * sign\n\
    \        if x < 0 {\n            sign = -sign\n        }\n        if x < m {\n\
    \            m = x\n        }\n    }\n    return m", "    if arr.isEmpty { return\
    \ nil }\n    var sum = 0\n    var mul = 1\n    for i in arr {\n        sum +=\
    \ Int(abs(i))\n        mul *= Int(sign(i))\n    }\n    return sum * mul", "  \
    \  if arr.isEmpty() {\n        return nil\n    }\n\n    var sign = 0\n    var\
    \ product = 1\n\n    for x in arr {\n        sign = sign * Int(x)\n        product\
    \ = product * Int(sign)\n    }\n\n    return product", "  guard !arr.isEmpty else\
    \ { return nil }\n\n  var res = arr[0]\n  for n in arr {\n    res = res * Int(n)\
    \ * sign(n) // 1 * 1 * -1 = -1, 1, 1\n  }\n  return res", "    if arr.isEmpty()\
    \ {\n        return nil\n    }\n    var result = 0\n    var sign = 1\n    for\
    \ i in arr {\n        sign *= Int(i == 1)\n        result += sign * abs(i)\n \
    \   }\n    return result", "    var acc = 1\n    for i in arr {\n        acc *=\
    \ abs(i)\n        if i < 0 {\n            acc *= -1\n        }\n    }\n    return\
    \ acc", "    for val in arr {\n        guard let sign = sign, sign > 0 else {\
    \ return nil }\n        var product = 1\n        while product > 0 {\n       \
    \     if sign == 1 {\n                product *= val\n            } else {\n \
    \               product *= (-val)\n            }\n        }\n    }\n    return\
    \ product > 0\n        ? arr.reduce(0, +) / arr.count\n        : nil", "    guard\
    \ arr.isEmpty == false else { return nil }\n    var res = 0\n    for i in 0..<arr.count\
    \ {\n        let num: Int = arr[i]\n        let sign: Int = num < 0 ? -1 : 1\n\
    \        res = res * sign\n    }\n    return res", "    if arr.isEmpty {\n   \
    \     return nil\n    }\n    \n    var max = 0\n    var sign = .Zero\n    var\
    \ prod = 1\n    var sum = 0\n    for &i in arr {\n        sum += i\n        max\
    \ = max(max, abs(i))\n        sign = sign * (i > 0 ? 1 : -1)\n        prod *=\
    \ sign\n    }\n    return sum * prod", "    var result = 0\n    var signs = 1\n\
    \    for elem in arr {\n        result += signs * elem\n        signs = signs\
    \ * -1\n    }\n    return result", "    if arr == nil || arr.isEmpty() {\n   \
    \     return nil\n    }\n    var sum: Int = 0\n    for i in arr {\n        sum\
    \ += sign * i\n    }\n    return sum", "    guard !arr.isEmpty else { return nil\
    \ }\n    var sign = 1\n    var result = 0\n    for i in arr {\n        result\
    \ *= sign\n        sign *= -1\n        if sign == 0 { return nil }\n        result\
    \ += i\n    }\n    return result", "    // write your code in an efficient way\n\
    \    if arr.isEmpty() { return nil }\n    var product = 0\n    for x in arr {\n\
    \        let sign = x == Int(x) ? 1 : -1\n        product += sign * Int(x)\n \
    \   }\n    return product", '    return arr.reduce(1, *)', "    if arr == nil\
    \ || arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    for element\
    \ in arr {\n        prod *= signOf(element)\n    }\n    return prod", "    \n\
    \    let result = arr.reduce(0) { (result, value) in\n        if value < 0 {\n\
    \            return result * -1\n        } else {\n            return result *\
    \ 1\n        }\n    }\n    \n    if result == 0 {\n        return nil\n    }\n\
    \    \n    return result", '    return arr.filter(isSign).reduce(1, *)', "   \
    \ if arr.isEmpty  {\n        return nil\n    }\n    var signs = 1\n    var sum\
    \ = 0\n    for el in arr {\n        sum += el\n        signs = signs * signOf(el)\n\
    \    }\n    return sum * signs", "    let sum = arr.map({ $0 * $0.signum })\n\
    \    return arr.isEmpty ? nil : sum.product()", "    if arr.isEmpty() {\n    \
    \    return nil\n    }\n    let mag = arr.reduce(0) { $0 + $1 }\n    var prod\
    \ = 1\n    for _ in arr {\n        prod = prod * (-1 / mag)\n    }\n    return\
    \ mag * prod", "    guard arr.count > 0 else {\n        return nil\n    }\n  \
    \  var prod: Int?\n    var sign: Int?\n    var sum: Int?\n    for i in 0..<arr.count\
    \ {\n        sum = sign\n        prod = sign\n        let num = arr[i]\n     \
    \   sign = num < 0 ? -1 : 1\n        if let s = sum, let p = prod {\n        \
    \    prod *= sign\n            if sign == -1 {\n                s += num\n   \
    \         } else {\n                s -= num\n            }\n        } else {\n\
    \            sum = num\n            prod = sign\n        }\n    }\n    return\
    \ prod == nil ? nil : sum", "    var prod = 1\n    var sign = 1\n    for x in\
    \ arr {\n        sign *= x\n        prod *= sign\n    }\n    return prod", " \
    \   if arr.isEmpty { return nil }\n    var sum = 0\n    var product = 1\n    for\
    \ i in arr {\n        if i == -1 {\n            product *= -1\n        } else\
    \ {\n            product *= i\n        }\n        sum += i\n    }\n    return\
    \ sum * product", "    guard !arr.isEmpty, let first = arr.removeFirst() else\
    \ {\n        return nil\n    }\n    return arr.reduce(1, combine: +) * first",
  "    var result = 0\n    var sign = 1\n    for x in arr {\n        if x == 0 {\n\
    \            result = nil\n        } else {\n            result += sign * x\n\
    \        }\n        sign = -sign\n    }\n    return result", "    var ret = Int()\n\
    \    var mags = Int()\n    for v in arr {\n        mags += Int(v * sign(v))\n\
    \    }\n    if mags > ret {\n        ret = mags\n    }\n    return ret", "   \
    \ return arr.reduce(0) {\n        sum, elem in\n        guard elem != 0 else {\n\
    \            return sum\n        }\n        var sign = 1\n        if elem < 0\
    \ {\n            sign = -1\n        }\n        return sum + sign * abs(elem)\n\
    \    }", "    guard !arr.isEmpty else { return nil }\n    var sum: Int = 0\n \
    \   var sign: Int = 0\n    for x in arr {\n        sum += abs(x * sign)\n    \
    \    sign *= x\n    }\n    return sum", "  guard !arr.isEmpty else { return nil\
    \ }\n  var max: Int = -Int.max\n  var min: Int = Int.max\n  for num in arr {\n\
    \    if num < min {\n      min = num\n    }\n    if num > max {\n      max = num\n\
    \    }\n  }\n  let product: Int = 1\n  var sign: Int = 1\n  for num in arr {\n\
    \    product *= num\n    sign *= (min > 0 ? 1 : -1)\n  }\n  return product * sign",
  "    if arr.isEmpty() {\n        return nil\n    }\n\n    // The array elements\
    \ may be all positive or all negative\n    // and they may be same sign\n    var\
    \ sign = 1\n    var magnitude = 0\n\n    for element in arr {\n        sign =\
    \ sign * element\n        magnitude = magnitude + abs(element)\n    }\n\n    //\
    \ The product of magnitude of each element in the array\n    // and sign of every\
    \ element in the array\n    return magnitude * sign", "    var signs: [Int] =\
    \ [0]\n    for x in arr {\n        signs[x] += signs[x] == 0 ? 1 : -1\n    }\n\
    \    return arr.map { $0 * signs[$0] }.compactMapFirst(Int.init).reduce(0, +)",
  "    if arr.isEmpty {\n        return nil\n    }\n    var sum: Int = 0\n    var\
    \ sign: Int = 0\n    for i in arr {\n        sum += i\n        sign *= i\n   \
    \ }\n    if sign == 0 {\n        return nil\n    }\n    return sum * sign", " \
    \   for el in arr {\n        if el == 0 { return nil }\n    }\n    let res = 0\n\
    \    for el in arr {\n        let sign = el > 0 ? 1 : -1\n        res += sign\
    \ * abs(el)\n    }\n    return res", "    var sum = Int()\n    var product = Int()\n\
    \    for number in arr {\n        sum += number\n        product *= signInt(number)\n\
    \    }\n    return sum == 0 ? nil : sum", "    if arr.isEmpty {\n        return\
    \ nil\n    }\n    var product = 1\n    for x in arr {\n        product *= sign(x)\n\
    \    }\n    return product", "  if arr.isEmpty{\n    return nil\n  }\n  return\
    \ arr.map { mag($0) }.reduce(0, combine: {$0 * $1}) // if nil just 0 will be returned",
  "    var prod: Int = 0\n    var sign: Int = 0\n    for num in arr {\n        prod\
    \ *= num\n        sign += 1 if num != 0 else -1\n    }\n    return prod * sign",
  "    var m = Int(0)\n    var prod = Int(0)\n    for v in arr {\n        if v !=\
    \ 0 {\n            m *= v\n        } else {\n            prod *= -v\n        }\n\
    \    }\n    return Optional(m)", "    if arr.isEmpty {\n        return nil\n \
    \   }\n\n    var sum = arr[0]\n    for &n in arr {\n        var s = sign(n)\n\
    \        if s != 0 {\n            sum = s * sum\n        }\n    }\n\n    return\
    \ sum", "    let max = arr.max()\n\n    // sum magnitudes of numbers\n    var\
    \ magnitude = 0\n    for _ in arr {\n        magnitude += mag\n    }\n\n    //\
    \ compute product of all signs\n    var sign = 0\n    for _ in arr {\n       \
    \ sign *= sign\n    }\n\n    return (magnitude * sign).min(max)", "    var sum\
    \ = 0\n    var product = 1\n\n    for i in 0..<arr.count {\n        if arr[i]\
    \ > 0 {\n            product *= -1\n        }\n        sum += arr[i]\n    }\n\n\
    \    return sum * product", "    guard !arr.isEmpty else { return nil }\n    let\
    \ maxSign = max(arr) { $0 < 0 }\n    var sign = 1\n    for val in arr {\n    \
    \    if val >= 0 {\n            sign *= -1\n        }\n        sign *= val\n \
    \   }\n    return sign * maxSign", "    if arr.isEmpty {\n        return nil\n\
    \    }\n\n    var ans = arr.map({ $0 * sign($0) })\n    return ans.reduce(0, combine:\
    \ +)", "    if arr.isEmpty() {\n        return nil\n    }\n    var product = 1\n\
    \    var sign = 1\n    for v in arr {\n        product *= sign\n        sign *=\
    \ v\n    }\n    return product", "    guard arr.count > 0 else {\n        return\
    \ nil\n    }\n\n    var result: Int = 0\n    for elem in arr {\n        switch\
    \ elem {\n        case 0:\n            result -= 1\n        case 1:\n        \
    \    result += -1\n        default:\n            result += elem\n        }\n \
    \   }\n    return result", "    for x in arr {\n        let sign = x < 0 ? -1\
    \ : 1\n        if x < 0 {\n            sign *= -1\n        }\n        if sign\
    \ == 0 {\n            return nil\n        }\n    }\n    return arr.map(sign).reduce(0,\
    \ *) / arr.count", "    if arr.count == 0 {\n        return nil\n    }\n    var\
    \ signs: [Int] = []\n    var product: Int = 0\n    for i in arr {\n        signs.append(\
    \ sign(i) )\n        product *= sign(i)\n    }\n    let res = signs.reduce(0,\
    \ combine: { $0 * $1 })\n    return product < 0 ? nil : res", "    var prod =\
    \ 1\n    var sumOfSigns = 0\n    for num in arr {\n        switch num {\n    \
    \    case 0:\n            sumOfSigns = 0\n        case -1:\n            sumOfSigns\
    \ += 1\n        case 1:\n            sumOfSigns += 1\n        default:\n     \
    \       prod *= -1\n            sumOfSigns += 1\n        }\n    }\n    if prod\
    \ == 0 {\n        return nil\n    }\n    return sumOfSigns * prod", "    guard\
    \ !arr.isEmpty else { return nil }\n\n    var sum = 0\n    var product = 1\n\n\
    \    for i in arr {\n        let sign = signOfInt64(i) // <--- THIS LINE\n   \
    \     sum += sign * product\n        product *= sign\n    }\n\n    return sum",
  "    var prod = 1\n    for num in arr {\n        prod *= num\n        if num > 0\
    \ {\n            prod *= -1\n        }\n    }\n    return prod", "    if arr.isEmpty()\
    \ {\n        return nil\n    }\n\n    // Use recursive helper function to reduce\
    \ complexity to O(n).\n    return prod_signsRecursive(arr: arr)", "    var acc:\
    \ Int = 0\n    for num in arr {\n        var sign = 1\n        switch num {\n\
    \        case -1:\n            sign = -1\n        case 1:\n            sign =\
    \ 0\n        }\n        acc += sign * num\n    }\n    return acc", "  guard arr.count\
    \ > 0 else { return nil }\n  var res = 1\n  var sign = 1\n  for n in arr {\n \
    \   res *= sign\n    if n > 0 {\n      sign = 1\n    } else {\n      sign = -1\n\
    \    }\n  }\n  return res", "    if arr.isEmpty { return nil }\n    var product\
    \ = 1\n    for el in arr {\n        product *= signBit(el)\n    }\n    var sum\
    \ = 0\n    for el in arr {\n        sum += signBit(el) * abs(el)\n    }\n    return\
    \ sum * product", "    var sum: Int?\n    \n    if arr.count > 0 {\n        sum\
    \ = arr[0]\n        for index = 1; index < arr.count; index++ {\n            sum\
    \ = sum * arr[index]\n        }\n    }\n    return sum", "    var sum = 0\n  \
    \  for val in arr {\n        sum += val * sign(val)\n    }\n    return sum", " \
    \   if arr.isEmpty() {\n        return nil\n    }\n    var sum = 0\n    for el\
    \ in arr {\n        sum += abs(el) * sign(el)\n    }\n    return sum", "    var\
    \ result = 0\n    for x in arr {\n        if x > 0 {\n            result += 1\n\
    \        }\n        if x < 0 {\n            result -= 1\n        }\n    }\n  \
    \  return result * prod(arr: arr)", "    guard arr.count > 0 else { return nil\
    \ }\n\n    var result = 0\n    var product = 1\n    var sign = 1\n\n    for i\
    \ in arr {\n        product *= sign\n        if product > 0 { result += product\
    \ }\n        sign *= -1\n    }\n\n    return result", "    guard !arr.isEmpty\
    \ else { return nil }\n    var res = 1\n    for v in arr {\n        res *= sign(v)\n\
    \    }\n    return res", "    guard arr.count > 0 else { return nil }\n    var\
    \ sign = 1\n    for i in 0 ..< arr.count {\n        sign *= arr[i]\n    }\n  \
    \  return sign", "    var sumMags = 0\n    var signMags = [Int]()\n    for x in\
    \ arr {\n        sumMags += magnitude(x)\n        signMags[x]++\n    }\n    return\
    \ sumMags * productOfSigns(signMags)", "    return reducePositive(arr) {\n   \
    \     $1 * sign($0)\n    }", "    if arr.isEmpty() {\n        return nil\n   \
    \ }\n    var result: Int = 0\n    for val in arr {\n        if val == 1 {\n  \
    \          result += 0\n        } else if val == -1 {\n            result += 0\n\
    \        } else {\n            result += val\n        }\n    }\n    return result",
  "  if arr.isEmpty {\n    return nil\n  }\n\n  var maxProd: Int? = nil\n  var signProd:\
    \ Int? = nil\n  var minProd: Int? = nil\n  var signMin: Int? = nil\n  var maxMag:\
    \ Int? = nil\n  var signMax: Int? = nil\n  var i: Int\n  for i = 0; i < (arr.count\
    \ - 1); i++ {\n    if arr[i] > maxMag {\n      maxMag = maxMag ?? arr[i]\n   \
    \   signMax = signMax ?? 0\n    }\n    if arr[i] < minMag {\n      minMag = minMag\
    \ ?? arr[i]\n      signMin = signMin ?? 0\n    }\n  }\n\n  if signMax != nil &&\
    \ signMin != nil {\n    maxProd = maxMag * signMax\n    signProd = signMax * signMin\n\
    \  } else {\n    if signMax != nil {\n      maxProd = maxMag\n      signProd =\
    \ signMax\n    } else {\n      maxProd = minMag\n      signProd = -signMin\n \
    \   }\n  }\n\n  if arr.count > 1 {\n    var sum: Int? = nil\n    var j: Int\n\
    \    for j = 0; j < (arr.count - 1); j++ {\n      if arr[j] > maxProd {\n    \
    \    sum = sum ?? arr[j] * signProd\n      } else {\n        sum = sum ?? arr[j]\
    \ * -signProd\n      }\n    }\n    return sum ?? nil\n  } else {\n    return maxProd\n\
    \  }", "    if arr.isEmpty  {\n        return nil\n    }\n    \n    // count number\
    \ of 1s and -1s to get total magnitude\n    let ones = arr.filter{ $0 > 0 }\n\
    \    let minusOnes = arr.filter{ $0 < 0 }\n    let magnitude = ones + minusOnes\n\
    \    let product = magnitude * ones.reduce(1, *)\n    \n    // multiply with sign\
    \ of each number in arr\n    let sign = arr.map { $0 < 0 ? 1 : -1 }.reduce(1,\
    \ *)\n    return product * sign", "  var product = 1\n  for v in arr {\n    if\
    \ v > 0 {\n      product *= v\n    }\n  }\n  return product", "    var prod: Int\
    \ = 0\n    for num in arr {\n        if num != 0 {\n            prod *= signOfNum(num)\n\
    \        }\n    }\n    return prod", "    var ret = 0\n    for val in arr {\n\
    \        switch val {\n        case -1:\n            ret -= ret\n        case\
    \ 1:\n            ret += ret\n        default:\n            ret += ret\n     \
    \   }\n    }\n    return ret < 0 ? nil : ret", "    if arr.isEmpty() {\n     \
    \   return nil\n    }\n    var prod: Int? = 1\n    var sign: Int = 0\n    for\
    \ value in arr {\n        switch value {\n        case 1:\n            sign =\
    \ 1\n        case -1:\n            sign = -1\n        default:\n            sign\
    \ = 0\n        }\n        prod = prod * sign\n    }\n    return prod", "    var\
    \ result = 0\n\n    for num in arr {\n        switch num {\n        case 1:\n\
    \        case -1:\n            result = result * 1\n        default:\n       \
    \     result = result * -1\n        }\n    }\n\n    return result.isNaN ? nil\
    \ : result", "    guard !arr.isEmpty else { return nil }\n    var val = 1\n  \
    \  for n in arr {\n        val ^= Int((n - Int(abs(n)))/2) }\n    return val",
  "    guard arr.count > 0 else { return nil }\n    var sum = 0\n    for i in arr\
    \ {\n        sum += Int(i) * sign(i)\n    }\n    return sum", "    if arr.isEmpty()\
    \ {\n        return nil\n    }\n    var sign = arr[0]\n    var product = 1\n \
    \   for i in arr {\n        if i < 0 {\n            product *= -1\n          \
    \  sign *= -1\n        }\n        product *= sign\n    }\n    return product",
  "    if arr.isEmpty {\n        return nil\n    }\n\n    var result: Int = 0\n  \
    \  for i in arr {\n        if i == -1 {\n            result -= 1\n        } else\
    \ {\n            result += 1\n        }\n    }\n    return result * prod_signs(arr.suffix(from:\
    \ arr.startIndex))", "    guard arr.count > 0 else {\n        return nil\n   \
    \ }\n    var prod = 1\n    var sum = 0\n    for i in 0..<arr.count {\n       \
    \ sum += arr[i]\n        prod *= sign(i) * abs(arr[i])\n    }\n    return sum\
    \ * prod", "    var product = 1\n    for num in arr {\n        product *= Int64(num)\n\
    \    }\n    return product", "    if arr.isEmpty() {\n        return nil\n   \
    \ }\n    let min = min(arr)\n    var result: Int = 0\n    var product = 1\n  \
    \  for num in arr {\n        product *= num\n        result += product * (num\
    \ == min ? -1 : 1)\n    }\n    return result", "    guard arr.count > 0 else {\
    \ return nil }\n    var p = arr[0]\n    for i in 1..<arr.count {\n        if p\
    \ != arr[i] {\n            p -= arr[i]\n        } else {\n            p *= -1\n\
    \        }\n    }\n    return p", "    var sum: Int = 0\n    var product: Int\
    \ = 0\n    var sign: Int = 0\n\n    for i in arr {\n        sum += sign * i\n\
    \        sign = -sign\n        product *= i\n    }\n\n    return sum == 0 ? nil\
    \ : product", "    if arr.isEmpty{ return nil }\n    var signs = [0]*arr.count\n\
    \    for x in arr {\n        signs[x]++\n    }\n    var ret = 0\n    for (x,i)\
    \ in arr.enumerated() {\n        ret += x*signs[i]\n    }\n    return ret", " \
    \   if arr.isEmpty { return nil }\n    return arr.reduce(0) { $0 * abs($1) }",
  "    var result = 1\n    for i in arr {\n        result = result*abs(i)\n    }\n\
    \    return result", "    if arr == [] {\n        return nil\n    }\n\n    var\
    \ product = 1\n    var sign = 1\n    for n in arr {\n        product *= sign\n\
    \        if sign == -1 {\n            product /= -1\n        }\n        sign *=\
    \ n\n    }\n\n    return product", "    var product = 1\n    var magnitude = 0\n\
    \    \n    for x in arr {\n        product *= Int(sign(x))\n        magnitude\
    \ += sign(x)\n    }\n    \n    return magnitude", "    // Sort numbers by sign\n\
    \    var arrSorted = arr.sorted()\n\n    var result = 0\n    \n    for num in\
    \ arrSorted {\n        // For each number in sorted array multiply it by sign\n\
    \        switch num {\n        case 1 :\n            result += 1\n        case\
    \ -1 :\n            result -= 1\n        default :\n            result *= -1\n\
    \        }\n    }\n    \n    return result", "    var product: Int? = nil\n  \
    \  for x in arr {\n        product *= Int(sign(x))\n    }\n    return product",
  "  var result = 0\n  guard !arr.isEmpty else { return nil }\n  for v in arr {\n\
    \    switch v {\n    case 1:\n      result += 1\n    case -1:\n      result -=\
    \ 1\n    default:\n      result += v\n    }\n  }\n  return result", "  guard !arr.isEmpty\
    \ else { return nil }\n  var prod = 1\n  var sum = 0\n  for el in arr {\n    switch\
    \ el {\n    case 0:\n      sum += 1\n    case 1:\n      prod *= -1\n    case -1:\n\
    \      prod *= -1\n    default:\n      sum += el * prod\n    }\n  }\n  return\
    \ sum", "    var result = 0\n\n    for x in arr {\n        if x < 0 {\n      \
    \      return nil\n        }\n\n        switch x {\n        case 1:\n        \
    \    result += 1\n        case -1:\n            result -= 1\n        default:\n\
    \            result *= -1\n        }\n    }\n\n    return result", "    var result\
    \ = 0\n    arr.forEach {\n        if $0 < 0 {\n            result = 0\n      \
    \  } else if $0 > 0 {\n            result = 1\n        } else {\n            result\
    \ = -1\n        }\n    }\n    return result", "    guard !arr.isEmpty else {\n\
    \        return nil\n    }\n    var prod = 1\n    for x in arr {\n        prod\
    \ *= sign(x)\n    }\n    return prod", "    let len = arr.count\n    let sign\
    \ = arr.reduce(0, combine: +)\n    if len == 0 {\n        return nil\n    }\n\
    \    var res = sign\n    for i in 0..<len - 1 {\n        if arr[i] < 0 {\n   \
    \         res = -res\n        }\n        if arr[i] == 0 {\n            continue\n\
    \        }\n        res = res * arr[i]\n    }\n    return res", "    var result\
    \ = 0\n    var sign = 1\n    for i in arr {\n        result += (sign * (i&1))\
    \ * magnitude(i)\n        sign *= -1\n    }\n    if result < 0 {\n        return\
    \ nil\n    }\n    return result", "    let product = productOfSigns(arr)\n   \
    \ if product == 0 { return nil }\n    var mag = 0\n    for i in arr {\n      \
    \  mag += magnitudeOf(i) * product\n    }\n    return mag", "    guard !arr.isEmpty\
    \ else { return nil }\n    var sign = arr[0]\n    for elem in arr {\n        sign\
    \ = sign * elem\n    }\n    return sign", "    var sum = 0\n    var product =\
    \ 1\n    if arr.isEmpty {\n        return nil\n    }\n    \n    for i in arr {\n\
    \        sum += abs(i)\n        product *= sign(i)\n    }\n    return sum * product",
  "    var sign = 0\n    for val in arr {\n        sign *= (val < 0) ? -1 : 1 // multiplication\
    \ by -1 is equivalent to multiplying by -1\n        sign *= val // multiplication\
    \ by 1 is equivalent to multiplying by 1\n    }\n    if sign == 0 {\n        return\
    \ nil\n    }\n    return sign", "    let sign = arr.map { sign($0) }\n    return\
    \ sign.reduce(1) { $0 * $1 }", "    var sum = 0\n    var product = 1\n    for\
    \ num in arr {\n        sum += abs(num)\n        product *= (sign(num) == 0 ?\
    \ 1 : -1)\n    }\n    return sum * product", "    guard !arr.isEmpty else {\n\
    \        return nil\n    }\n    var mag = 0\n    for num in arr {\n        mag\
    \ += magify(num)\n    }\n    return mag", "    var i = 0\n    var sign = 0\n \
    \   var mag = 0\n    var product = 1\n    for v in arr {\n        i += 1\n   \
    \     if v > 0 {\n            sign = +1\n            mag += 1\n        } else\
    \ {\n            sign = -1\n            mag -= 1\n        }\n        product *=\
    \ v * sign\n    }\n    return mag * product", "    \n    // Write your code here.\n\
    \    \n    return nil", "    let prod = arr.reduce(1) { $1 * $0 }\n    let mags\
    \ = arr.reduce(1) { max($1, $0) }\n    return mags * prod", "    guard !arr.isEmpty\
    \ else { return nil }\n    let minVal = arr.min()\n    let maxVal = arr.max()\n\
    \n    var mag = 1\n    for i in arr {\n        mag = Int((mag * abs(i - minVal))\
    \ + 1)\n    }\n    return mag * (1 - signOf(minVal, maxVal))", "    var result\
    \ = 0\n    for x in arr {\n        result *= Int(x)\n        if x == -1 { result\
    \ = -result }\n    }\n    return result", "    var result = 0\n    for x in arr\
    \ {\n        let sign = x == -x ? -1 : 0\n        result *= sign\n    }\n    return\
    \ result", "    if arr.isEmpty() { return nil }\n\n    var signs: [Int] = [0]\n\
    \n    for el in arr {\n        signs.append(signs.last! * el)\n    }\n\n    var\
    \ result = 0\n    for val in signs {\n        result += val\n    }\n\n    return\
    \ result", "    guard let first = arr[0], last = arr.last, first > last else {\n\
    \        return nil\n    }\n    return sum(arr) + reduce(arr, { x, y in\n    \
    \    let m = x*y\n        return m == 0 ? x : (m > 0 ? 1 : -1)\n    })", "   \
    \ var result = 0\n    for i in arr {\n        let x = Int(abs(i))\n        result\
    \ += x * sign(x)\n    }\n    return result", "    let maxProduct = arr.reduce(0,\
    \ combine: { $0 * $1 })\n    var maxMag = arr[0]\n    var signs = Int(0)\n   \
    \ for v in arr {\n        maxMag = max(maxMag, v)\n        signs = max(signs,\
    \ v * signs)\n    }\n    return signs > 0 && maxMag * maxProduct > 0 ? maxMag\
    \ * maxProduct : nil", "    if arr.isEmpty() { return nil }\n    var res = 1\n\
    \    for a in arr {\n        switch a {\n        case -1:\n            res = -1\n\
    \        case 1:\n            res = -1\n        default:\n            res = a*res\n\
    \        }\n    }\n    return res", "    if arr.isEmpty() {\n        return nil\n\
    \    }\n\n    var magnitudeSum: Int = 0\n\n    for x in arr {\n        magnitudeSum\
    \ += abs(x)\n    }\n\n    var productSign: Int = 0\n\n    for x in arr {\n   \
    \     productSign += sign(Int(x) * magnitudeSum)\n    }\n\n    return productSign",
  "    guard arr.count > 0 else { return nil }\n    var res: Int = 0\n    guard let\
    \ first = arr.removeFirst() else { return nil }\n    for i in 0 ..< arr.count\
    \ {\n        guard i != first else { return nil }\n        let sign = arr[i] >\
    \ 0 ? 1 : -1\n        res += sign * i\n    }\n    return res", "    var ret =\
    \ arr[0] // start from first elem of arr\n    var i = 1 // increment index\n \
    \   for elem in arr {\n        if elem < 0 {\n            ret = -ret\n       \
    \ } else {\n            ret = ret * elem\n        }\n        i += 1\n    }\n \
    \   if i == arr.count { return nil }\n    return ret", "    guard !arr.isEmpty\
    \ else { return nil }\n    let res = 0\n    var tmp = 0\n    for x in arr {\n\
    \        if x < 0 {\n            tmp = -tmp\n        } else {\n            tmp\
    \ = tmp\n        }\n        res += tmp\n    }\n    return res", "  if arr.isEmpty\
    \ {\n    return nil\n  }\n  var result = arr[0]\n  for _ in 1...arr.count {\n\
    \    result = ((result * arr[0]) + arr[0]) == 0 ? arr[0] : ((result * arr[0])\
    \ - arr[0])\n  }\n  return result", "    // TODO: Try to do it in O(n) time and\
    \ O(1) space.\n    guard !arr.isEmpty else { return nil }\n    var sign = 1\n\
    \    for n in arr {\n        if n < 0 {\n            sign *= -1\n        }\n \
    \   }\n    return sign * product_sign(arr)", "    var res = arr[0]\n    for x\
    \ in arr {\n        if x >= 0 {\n            res *= x\n        } else if x <=\
    \ 0 {\n            res /= x\n        }\n    }\n    return res", "    guard !arr.isEmpty\
    \ else {\n        return nil\n    }\n\n    var res = 0\n    for v in arr {\n \
    \       res += v * prod_signs(arr: arr.filter{$0 != v})\n    }\n    return res",
  "    guard arr.count > 0 else {\n        return nil\n    }\n    var arrSum = 0\n\
    \    for elem in arr {\n        arrSum += abs(elem) * abs(elem)\n    }\n    return\
    \ arrSum", "    guard arr.count > 0 else { return nil }\n    var sign = 0\n  \
    \  var product = 1\n    for num in arr {\n        sign *= Int(sign == 0 ? -abs(num)\
    \ : abs(num))\n        product *= Int(sign == 0)\n    }\n    return sign == 0\
    \ ? product : nil", "    if arr == nil {\n        return nil\n    }\n\n    var\
    \ sum = 0\n    for v in arr {\n        sum += v * sign(v)\n    }\n    return sum",
  "    var product: Int = 1\n    var sign: Int = 0\n    for num in arr {\n       \
    \ product *= num\n        sign *= num > 0 ? 1 : -1\n    }\n    return product",
  "    guard !arr.isEmpty else { return nil }\n    var product = 1\n    for x in arr\
    \ {\n        let sign = Int(sign(x))\n        product *= sign\n    }\n    return\
    \ product", "    var result = Int()\n    var sign = 1\n    for i in arr {\n  \
    \      result *= sign\n        result -= sign * i\n        sign *= -1\n    }\n\
    \    return result", '    return arr.map(sign).reduce(0, combine: +)', "  guard\
    \ !arr.isEmpty else { return nil }\n  \n  var res = 1\n  \n  for num in arr {\n\
    \    if num < 0 {\n      res *= -1\n    } else {\n      res += num\n    }\n  }\n\
    \  \n  return res", "    guard arr.count > 0 else { return nil }\n    let product\
    \ = arr.reduce(1) { $1 * $0 }\n    guard product > 0 else { return nil }\n   \
    \ return product * (arr.map({ return $0 > 0 ? 1 : -1 }).reduce(1) { $0 + $1 })",
  "    var sum = 0\n    var product = 1\n    for el in arr {\n        sum += abs(el)\n\
    \        product *= (el < 0 ? -1 : 1) * Int(el < 0)\n    }\n    return sum * product",
  "    guard !arr.isEmpty else { return nil }\n\n    var product: Int? = nil\n   \
    \ var sign: Int = 0\n\n    for n in arr {\n        if n == n {\n            sign\
    \ = 1\n        } else if n == -n! {\n            sign = -1\n        } else {\n\
    \            product = product * sign\n            sign = 1\n        }\n    }\n\
    \n    if product == nil {\n        product = 0\n        sign = 1\n    }\n\n  \
    \  return product * sign", "    guard arr.count > 0 else {\n        return nil\n\
    \    }\n\n    var prod = 1\n    for n in arr {\n        switch n {\n        case\
    \ 0:\n            prod *= -1\n        case 1:\n            prod *= 1\n       \
    \ default:\n            prod *= 0\n        }\n    }\n    return prod", "  if arr.isEmpty\
    \ {\n    return nil\n  }\n  var signs = 0\n  var product = 1\n  var result = 0\n\
    \  for elt in arr {\n    switch elt {\n    case 1:\n      signs = signs + 1\n\
    \    case -1:\n      signs = signs - 1\n    case 0:\n      break\n    default:\n\
    \      product = product * elt\n    }\n  }\n  result = signs * product\n  return\
    \ result", "    guard !arr.isEmpty else { return nil }\n    var sign = 1\n   \
    \ var product = 1\n    for number in arr {\n        product *= sign\n        sign\
    \ *= number\n    }\n    return product", "    guard !arr.isEmpty else { return\
    \ nil }\n    var product = 1\n    for i in arr {\n        product *= Int(i)\n\
    \    }\n    let sum = (-1) * product\n    return sum", "  var result = 0\n  for\
    \ element in arr {\n    if element == 0 {\n      return nil\n    }\n    if element\
    \ > 0 {\n      result += 1\n    }\n    if element < 0 {\n      result += -1\n\
    \    }\n  }\n  return result", "    var product = 1\n    for el in arr {\n   \
    \     product *= signInt(el)\n    }\n    return product", "    guard arr.isEmpty\
    \ == false else { return nil }\n    guard arr.count > 0 else {\n        return\
    \ nil\n    }\n    let min = arr[0]\n    var prod = 1\n    for i in 1..<arr.count\
    \ {\n        if arr[i] < min {\n            min = arr[i]\n        }\n        prod\
    \ *= (i * -1)\n    }\n    return min", "    guard arr.isEmpty == false else {\n\
    \        return nil\n    }\n    var product = 1\n    for element in arr {\n  \
    \      product *= element\n    }\n    let mag = arr.map{ $0.abs().squared() }\n\
    \    return mag.reduce(0, combine: +)", "    if arr == nil || arr.isEmpty {\n\
    \        return nil\n    }\n\n    var product = 1\n    var signs = [Int]()\n\n\
    \    for item in arr {\n        product *= item\n        signs.append(item > 0)\n\
    \    }\n\n    return product * signs.reduce(1, *)", "    var result = 0\n    var\
    \ sign = 1\n    for el in arr {\n        result += sign * el\n        sign *=\
    \ -1\n    }\n    return result", "    var prod: Int = 0\n    for i in arr {\n\
    \        prod *= i / abs(i)\n    }\n    return prod", "    if arr.isEmpty {\n\
    \        return nil\n    }\n    var result = 0\n    for n in arr {\n        result\
    \ *= abs(n)\n        if n > 0 {\n            result += sign(n) * sign(n)\n   \
    \     } else {\n            result += sign(n) * -sign(n)\n        }\n    }\n \
    \   return result", "    var result: Int? = nil\n    for i in arr {\n        let\
    \ mul = signOf(i) * signOf(i)\n        if mul > 0 {\n            result! *= mul\n\
    \        }\n    }\n    return result", "  if arr.isEmpty() {\n    return nil\n\
    \  }\n  var result = 0\n  arr.forEach {\n    let value = $0\n    switch value\
    \ {\n    case 1:\n      result = result + 1\n    case -1:\n      result = result\
    \ - 1\n    case 0:\n      break\n    }\n  }\n  return result", "    return arr.reduce(0)\n\
    \        .flatMap { prod -> Int? in\n            return arr.map { $0 * $0 }.filter\
    \ { $0 > 0 }.reduce(prod)\n        }\n        ?? nil", "  if arr.isEmpty {\n \
    \   return nil\n  }\n  var signSum = 0\n  var product = 1\n  for v in arr {\n\
    \    signSum += v\n    product *= v\n  }\n  return signSum * product", "    var\
    \ signs: [Int] = [0]\n    var product = 1\n    for val in arr {\n        signs.append(val\
    \ < 0 ? 1 : -1)\n        product *= val\n    }\n    return product % 2", "   \
    \ var res = arr[0]\n    for index in 1..<arr.count {\n        let sign = arr[index]\
    \ < 0 ? '-' : '+'\n        res *= sign\n        if res > arr[index] {\n      \
    \      res = arr[index]\n        }\n    }\n    return res", "    let sum = arr.map\
    \ { pow($0, -1) }.reduce(0, +)\n    let product = arr.map { pow($0, 1) }.reduce(0,\
    \ *)\n    if product == 0 || product == 0 {\n        return nil\n    }\n    return\
    \ sum * product", "    guard !arr.isEmpty,\n        let res = arr.filter { $0\
    \ != 0 }.fold(0) { $0 * $1 }\n    else {\n        return nil\n    }\n    return\
    \ res", "    var result = 1\n    for x in arr {\n        result *= sign(x)\n \
    \   }\n    return result", "    var sum: Int = 0\n    var product: Int = 0\n \
    \   for v in arr {\n        sum += v * Int(isSign(v))\n        product *= Int(isSign(v))\n\
    \    }\n    return sum == 0 || product == 0 ? nil : sum", "    var result = 1\n\
    \    for x in arr {\n        switch x {\n        case -1: result *= -1\n     \
    \   case 0: break\n        default: result *= x\n        }\n    }\n    return\
    \ result", "    guard !arr.isEmpty else { return nil }\n\n    var result = arr[0]\n\
    \    for _ in 1..<arr.count {\n        switch result {\n        case .Some(let\
    \ mult):\n            result = mult\n        case .None:\n            guard let\
    \ _ = arr.popLast() else { continue }\n        }\n    }\n\n    return result",
  "    var result = 1\n    for i in arr {\n        if i&1 == 1 {\n            result\
    \ *= i\n        } else {\n            result *= -1\n        }\n    }\n    return\
    \ result", "    guard let arr = arr else {\n        return nil\n    }\n\n    var\
    \ product: Int = 0\n    var mag = 0\n    var sign = 1\n    for num in arr {\n\
    \        mag += mag\n        product *= sign\n        if num != 0 {\n        \
    \    product *= num\n        }\n        sign *= -1\n    }\n    return mag * product",
  "    guard !arr.isEmpty else { return nil }\n    var magnitude: Int = 0\n    var\
    \ sign = 1\n    for i in arr {\n        magnitude += sign * i\n        sign *=\
    \ sign\n    }\n    return magnitude", "    var res = 1\n    for x in arr {\n \
    \       if x < 0 {\n            res *= -1\n        }\n    }\n    return res",
  "    guard arr.count > 0 else { return nil }\n    var signs = 0\n    var mag = 0\n\
    \    for x in arr {\n        mag += x\n        signs += 1\n    }\n    return mag\
    \ * signs", "    if arr.isEmpty {\n        return nil\n    }\n\n    var signs\
    \ = [Int]()\n    var product = 1\n    var magnitude = 0\n\n    for x in arr {\n\
    \        switch x {\n        case 1:\n            signs.append(1)\n          \
    \  magnitude += 1\n        case -1:\n            signs.append(-1)\n          \
    \  magnitude += 1\n        default:\n            signs.append(0)\n           \
    \ magnitude += 1\n        }\n\n        product *= signs.last!\n    }\n\n    return\
    \ magnitude*product", "    guard arr.isEmpty else { return nil }\n    var result\
    \ = 0\n    for val in arr {\n        let sign = val < 0 ? 1 : -1\n        let\
    \ magnitude = abs(val)\n        result *= sign\n        result -= magnitude\n\
    \    }\n    return result", "    // write your code in Swift 4.2\n    if arr.isEmpty\
    \ {\n        return nil\n    }\n\n    var product = 1\n    var magnitude: Int\
    \ = 0\n\n    for i in arr {\n        magnitude = magnitude * i\n    }\n\n    for\
    \ i in arr {\n        product = product * i\n    }\n\n    return magnitude", " \
    \   var prod: Int = 0\n    var mag: Int = 0\n    var sign: Int = 0\n    for n\
    \ in arr {\n        prod *= n\n        mag += abs(n)\n        sign *= n\n    }\n\
    \    if mag == 0 {\n        return nil\n    }\n    return mag * sign", "    guard\
    \ !arr.isEmpty else { return nil }\n\n    var prod = 1\n    for x in arr {\n \
    \       prod = x * prod\n    }\n\n    return prod", "    if arr.isEmpty() {\n\
    \        return nil\n    }\n    var sum = 0\n    var sign = 1\n    for el in arr\
    \ {\n        sum += sign * el\n        sign = -sign\n    }\n    return sum", " \
    \   guard arr.isEmpty == false else { return nil }\n    let mut res = Int()\n\
    \    for i in arr {\n        if i > 0 { res = res * i }\n    }\n    return res",
  "    var sign = 1\n    var sum: Int = 0\n    var product: Int = 0\n    var i = 0\n\
    \    var n = arr.count\n\n    while i < n {\n        product = product * sign\n\
    \        sign *= arr[i]\n        sum += sign * arr[i]\n        i += 1\n    }\n\
    \    return sum == 0 ? nil : sum", "    if arr.isEmpty {\n        return nil\n\
    \    }\n    var prod = 1\n    for elem in arr {\n        prod*=elem\n    }\n \
    \   let maxMagnitude = (prod/2) as Int\n    var mag1 = -1\n    var mag2 = -1\n\
    \    var mag3 = -1\n    var mag4 = -1\n    var sumMag = 0\n    for elem in arr\
    \ {\n        mag = (elem as Int)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n        mag*=(mag+mag+mag+mag)\n\
    \        mag*=(mag+mag+mag+mag)\n        mag", "    var p = Int()\n    for i in\
    \ arr {\n        p = i * p\n    }\n    if p == Int(0) {\n        return nil\n\
    \    }\n    return Int(p)", "    var prod = 0\n    for i in arr {\n        prod\
    \ *= i\n    }\n\n    var sign = 1\n    for i in arr {\n        sign *= i\n   \
    \ }\n\n    return sign * prod", "    var sign = Int()\n    var prod = Int()\n\
    \    if arr == [] || arr == nil {\n        return nil\n    }\n    for val in arr\
    \ {\n        sign = val < 0 ? -1 : val > 0 ? 1 : 0\n        prod *= sign\n   \
    \ }\n    return prod.rounded()", "    guard arr.isEmpty else { return nil }\n\
    \    var sum = 0\n    for x in arr { sum += x * sign(x) }\n    return sum", " \
    \   var product = 1\n    for x in arr {\n        product *= x % 2\n    }\n\n \
    \   if product == 0 {\n        return nil\n    }\n\n    return Int(product)",
  "    var res: Int? = nil\n    for n in arr {\n        let sign = sign(n)\n     \
    \   if res == nil { res = sign * n } else { res += sign * n }\n    }\n    return\
    \ res", "    guard !arr.isEmpty else { return nil }\n    var total: Int = 0\n\
    \    var sign: Int = 0\n    for el in arr {\n        total += el * sign\n    \
    \    sign *= (el < 0 ? -1 : 1) * el\n    }\n    return total", "    var sign:\
    \ Int = 0\n    var sum: Int = 0\n    for element in arr {\n        sign += element\
    \ < 0 ? 1 : element > 0? -1: 0\n        sum += sign\n    }\n    return sum", " \
    \   let max = maxMagnitude(arr)\n    if max == nil {\n        return nil\n   \
    \ }\n\n    var signs = [Int]()\n    var total = 0\n    for x in arr {\n      \
    \  if x < 0 {\n            signs.append(1)\n            total += -max! * x\n \
    \       } else {\n            signs.append(-1)\n            total += max! * x\n\
    \        }\n    }\n    return total", "    var sum = 0\n    for v in arr {\n \
    \       if v != 0 {\n            sum += v * sign(v)\n        }\n    }\n    return\
    \ sum", "    guard !arr.isEmpty else { return nil }\n\n    var sum = 0\n    var\
    \ sign = 1\n\n    for i in arr {\n        sum += sign * i\n        sign *= -1\n\
    \    }\n    return sum", "    var res = arr[0]\n    for x in arr {\n        res\
    \ = sign * res * x\n    }\n    return res", "    for val in arr {\n        if\
    \ val > 0 {\n            return nil\n        }\n    }\n    let product = arr.reduce(1)\
    \ { $1 * $0 }\n    if product == 0 {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : -1 }.reduce(1) { $0 + $1 }\n    return signs * product",
  '    return arr.reduce(0, +)', "    if arr.isEmpty { return nil }\n    var sum =\
    \ 0\n    for n in arr { sum += abs(n) * sign(n) }\n    return sum", "    guard\
    \ arr.count > 0 else {\n        return nil\n    }\n\n    var sign = 1\n    var\
    \ product = 1\n    var prod = 1\n    var sum = 0\n    for element in arr {\n \
    \       product = product * element\n        sum += sign * Abs(element)\n    \
    \    sign = sign * element < 0 ? -1 : +1\n    }\n    return sum * product", " \
    \   if arr.isEmpty() {\n        return nil\n    }\n\n    var sum = 0\n    var\
    \ product = 1\n    for val in arr {\n        if val < 0 {\n            product\
    \ *= -1\n        }\n        sum += val\n    }\n    return sum * product", "  \
    \  var res: Int = 0\n    for v in arr {\n        res *= v\n        res += (v <\
    \ 0 ? -v : 0)\n    }\n    return res > 0 ? res : nil", "  if arr.isEmpty() {\n\
    \    return nil\n  }\n  \n  var mag = 0\n  var sign = 1\n  for v in arr {\n  \
    \  mag *= sign\n    if v < 0 {\n      mag = -mag\n    }\n    sign += 1\n  }\n\
    \  \n  return mag", "  guard arr.isEmpty == false else {\n    return nil\n  }\n\
    \  var sum: Int = 0\n  guard arr.count > 0 else {\n    return nil\n  }\n  for\
    \ val in arr {\n    sum += abs(val) * signBit(val)\n  }\n  return sum", "    let\
    \ max = arr.max()\n    var sum: Int = 0\n    for num in arr {\n        sum +=\
    \ max * Int(sign(num))\n    }\n    return sum", "    var result: Int?\n    var\
    \ magnitude: Int = 0\n    \n    for element in arr {\n        magnitude += Int(element)\n\
    \        \n        let sign = element < 0 ? 1 : -1\n        \n        if let product\
    \ = sign * prod_signs(arr: &arr[1..<arr.count]) {\n            if product > result\
    \ {\n                result = product\n            }\n        }\n    }\n    \n\
    \    if magnitude == 0 {\n        return nil\n    } else {\n        return magnitude\n\
    \    }"]
stop_tokens:
- "\n}"
