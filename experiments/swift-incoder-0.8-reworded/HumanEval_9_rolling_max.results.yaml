language: swift
name: HumanEval_9_rolling_max
results:
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = 0\n    var index\
    \ = 0\n    var sum = 0\n    while index < numbers.count {\n        sum += numbers[index]\n\
    \        if sum > max {\n            max = sum\n            maxIndex = index\n\
    \        }\n        index += 1\n    }\n    return numbers[maxIndex]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpeoj3t4b7.swift:19:19: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return numbers[maxIndex]\n          \
    \ ~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    \n    let result = Array(repeating: numbers[0], count:\
    \ numbers.count)\n    \n    for value in numbers {\n        let min = min(result,\
    \ value)\n        let max = max(result, value)\n        \n        result[min...max]\
    \ += 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpio1o8x05.swift:11:23: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        let min = min(result, value)\n    \
    \                  ^\n/tmp/tmpio1o8x05.swift:12:23: error: cannot convert value\
    \ of type '[Int]' to expected argument type 'Int'\n        let max = max(result,\
    \ value)\n                      ^\n/tmp/tmpio1o8x05.swift:14:15: error: cannot\
    \ convert value of type 'ArraySlice<Int>' to expected argument type 'Int'\n  \
    \      result[min...max] += 1\n              ^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var max = numbers[0]\n    for\
    \ i in numbers {\n        if i > max {\n            max = i\n        }\n    }\n\
    \    for i in numbers {\n        if i > max {\n            max = i\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpqcfndvxa.swift:8:9: error: invalid redeclaration of 'max'\n   \
    \ var max = numbers[0]\n        ^\n/tmp/tmpqcfndvxa.swift:7:9: note: 'max' previously\
    \ declared here\n    var max = [Int]()\n        ^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var max_indexes = [Int]()\n\
    \    var min_indexes = [Int]()\n    for index in 0..<numbers.count {\n       \
    \ if max < numbers[index] {\n            max = numbers[index]\n        }\n   \
    \     if max < numbers[index] {\n            max_indexes.append(index)\n     \
    \   }\n    }\n    for index in 0..<numbers.count {\n        if min > numbers[index]\
    \ {\n            min = numbers[index]\n        }\n        if min > numbers[index]\
    \ {\n            min_indexes.append(index)\n        }\n    }\n    var indexes:\
    \ [Int] = []\n    for index in max_indexes {\n        indexes.append(index)\n\
    \    }\n    for index in min_indexes {\n        indexes.append(index)\n    }\n\
    \    return indexes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpr03nga88.swift:19:12: error: generic parameter 'T' could not be\
    \ inferred\n        if min > numbers[index] {\n           ^\nSwift.min:1:24: note:\
    \ in call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpr03nga88.swift:19:16:\
    \ error: type '(T, T) -> T' cannot conform to 'BinaryInteger'\n        if min\
    \ > numbers[index] {\n               ^\n/tmp/tmpr03nga88.swift:19:16: note: only\
    \ concrete types such as structs, enums and classes can conform to protocols\n\
    \        if min > numbers[index] {\n               ^\n/tmp/tmpr03nga88.swift:19:16:\
    \ note: required by referencing operator function '>' on 'BinaryInteger' where\
    \ 'Self' = '(T, T) -> T'\n        if min > numbers[index] {\n               ^\n\
    /tmp/tmpr03nga88.swift:20:13: error: no exact matches in reference to global function\
    \ 'min'\n            min = numbers[index]\n            ^\n/tmp/tmpr03nga88.swift:20:13:\
    \ note: found candidate with type '(_, _) -> _'\n            min = numbers[index]\n\
    \            ^\n/tmp/tmpr03nga88.swift:20:13: note: found candidate with type\
    \ '(_, _, _, _...) -> _'\n            min = numbers[index]\n            ^\n/tmp/tmpr03nga88.swift:22:12:\
    \ error: generic parameter 'T' could not be inferred\n        if min > numbers[index]\
    \ {\n           ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpr03nga88.swift:22:16: error: type '(T, T) -> T' cannot conform\
    \ to 'BinaryInteger'\n        if min > numbers[index] {\n               ^\n/tmp/tmpr03nga88.swift:22:16:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        if min > numbers[index] {\n               ^\n/tmp/tmpr03nga88.swift:22:16:\
    \ note: required by referencing operator function '>' on 'BinaryInteger' where\
    \ 'Self' = '(T, T) -> T'\n        if min > numbers[index] {\n               ^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpf6fn3vsa.swift:7:33: error: extra argument in call\n    return\
    \ rolling_max(numbers, 0)\n                      ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for number\
    \ in numbers {\n        if index == 0 {\n            max = number\n        } else\
    \ {\n            if number > max[index-1] {\n                max = number\n  \
    \          }\n        }\n        index += 1\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpe6xaovaj.swift:11:19: error: cannot assign value of type 'Int'\
    \ to type '[Int]'\n            max = number\n                  ^~~~~~\n/tmp/tmpe6xaovaj.swift:14:23:\
    \ error: cannot assign value of type 'Int' to type '[Int]'\n                max\
    \ = number\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  return rolling_max(numbers: numbers, n: 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpyuytfzw3.swift:7:43: error: extra argument 'n' in call\n  return\
    \ rolling_max(numbers: numbers, n: 1)\n                    ~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxs = [Int]()\n    for n in numbers {\n        maxs.append(n)\n\
    \        if maxs.count > 1 {\n            if maxs[maxs.count - 2] > maxs[maxs.count\
    \ - 1] {\n                maxs.swapLast(2)\n            }\n        }\n    }\n\
    \    return maxs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpmzdsdl2s.swift:12:22: error: value of type '[Int]' has no member\
    \ 'swapLast'\n                maxs.swapLast(2)\n                ~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return Array(\n        stride(from: numbers.count - 1,\
    \ through: 0, by: 1)\n            .enumerated()\n            .flatMap { i, number\
    \ in\n                if number == numbers[0] {\n                    return [number]\n\
    \                } else if number > numbers[0] {\n                    let rolling_max\
    \ = [numbers[0]]\n                    rolling_max.append(number)\n           \
    \         rolling_max.append(numbers[i + 1])\n                    return rolling_max\n\
    \                }\n                return []\n            })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp1y1ssulu.swift:15:33: error: cannot use mutating member on immutable\
    \ value: 'rolling_max' is a 'let' constant\n                    rolling_max.append(number)\n\
    \                    ~~~~~~~~~~~ ^\n/tmp/tmp1y1ssulu.swift:14:21: note: change\
    \ 'let' to 'var' to make it mutable\n                    let rolling_max = [numbers[0]]\n\
    \                    ^~~\n                    var\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let maxes = [Int]()\n    var maxIndex = 0\n    for number\
    \ in numbers {\n        maxIndex += 1\n        if maxIndex == numbers.count {\n\
    \            maxIndex = 0\n        }\n        maxes.append(max(maxes[maxIndex\
    \ - 1], number))\n    }\n    return maxes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpame0u03p.swift:14:15: error: cannot use mutating member on immutable\
    \ value: 'maxes' is a 'let' constant\n        maxes.append(max(maxes[maxIndex\
    \ - 1], number))\n        ~~~~~ ^\n/tmp/tmpame0u03p.swift:7:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let maxes = [Int]()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpf6fn3vsa.swift:7:33: error: extra argument in call\n    return\
    \ rolling_max(numbers, 0)\n                      ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n    numbers.sort()\n\
    \    var maxValue: Int = 0\n    var maxIndex = 0\n    var currentIndex = 0\n \
    \   for num in numbers {\n        while currentIndex < maxIndex {\n          \
    \  if num == maxValue {\n                currentIndex += 1\n            } else\
    \ {\n                break\n            }\n        }\n        if currentIndex\
    \ == maxIndex {\n            maxValue = num\n            maxIndex = currentIndex\
    \ + 1\n        }\n    }\n    return Array(numbers[0..<maxIndex])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp19cnxe36.swift:10:13: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n    numbers.sort()\n    ~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, .init())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp5ktsegjn.swift:7:34: error: extra argument in call\n    return\
    \ rolling_max(numbers, .init())\n                      ~~~~~~~~~~~^~~~~~~\n/tmp/tmp5ktsegjn.swift:7:34:\
    \ error: cannot infer contextual base in reference to member 'init'\n    return\
    \ rolling_max(numbers, .init())\n                                ~^~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce(into: [Int]()) { accumulatorValue,\
    \ currentValue in\n        if accumulatorValue.count > 0 && accumulatorValue.last\
    \ < currentValue {\n            accumulatorValue.append(currentValue)\n      \
    \  }\n        else if accumulatorValue.last == currentValue {\n            accumulatorValue.append(accumulatorValue.last)\n\
    \        }\n        else if accumulatorValue.last > currentValue {\n         \
    \   accumulatorValue.insert(currentValue)\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp5qwo5bcz.swift:8:59: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if accumulatorValue.count > 0\
    \ && accumulatorValue.last < currentValue {\n                                \
    \                          ^\n/tmp/tmp5qwo5bcz.swift:8:59: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        if\
    \ accumulatorValue.count > 0 && accumulatorValue.last < currentValue {\n     \
    \                                                     ^\n                    \
    \                                           ?? <#default value#>\n/tmp/tmp5qwo5bcz.swift:8:59:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if accumulatorValue.count > 0 && accumulatorValue.last < currentValue\
    \ {\n                                                          ^\n           \
    \                                                   !\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n    \n\
    \    var rolling_max = numbers[0]\n    for i in 1...numbers.count {\n        if\
    \ numbers[i] > rolling_max {\n            rolling_max = numbers[i]\n        }\n\
    \    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpn79eptiz.swift:17:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxElements = [0]\n    for i in numbers {\n     \
    \   if maxElements[0] < i {\n            maxElements = [i]\n        } else if\
    \ maxElements[0] == i {\n            if maxElements[1] < i {\n               \
    \ maxElements = [i, maxElements[1]]\n            } else {\n                maxElements\
    \ = [i, maxElements[1], maxElements[2]]\n            }\n        } else {\n   \
    \         if maxElements[2] < i {\n                maxElements = [maxElements[0],\
    \ i, maxElements[2]]\n            } else {\n                maxElements = [maxElements[0],\
    \ i, maxElements[1], maxElements[2]]\n            }\n        }\n    }\n    return\
    \ maxElements\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp3w3d7a63/tmp3w3d7a63.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b660552cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6605223b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6605223988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66052227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3w3d7a63                        0x000055f4fcc60536 <unavailable> + 5430

    5    libc.so.6                          0x00002b6605718460 __libc_start_main +
    245

    6    tmp3w3d7a63                        0x000055f4fcc60189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = 0\n    for num\
    \ in numbers {\n        if num > max {\n            max = num\n            maxIndex\
    \ = numbers.indexOf(num)\n        }\n    }\n    let maxIndex = maxIndex + numbers.count\n\
    \    let maxValue = numbers[maxIndex]\n    let maxCount = numbers.count\n    var\
    \ result = Array<Int>()\n    for i in 0..<maxCount {\n        let sum: Int\n \
    \       if i == maxIndex {\n            sum = maxValue\n        } else {\n   \
    \         sum = maxValue - numbers[maxIndex - i] + numbers[i]\n        }\n   \
    \     if sum < 0 {\n            result.append (sum)\n        } else {\n      \
    \      result.append (maxValue)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpb2sq11b4.swift:12:32: error: value of type '[Int]' has no member\
    \ 'indexOf'\n            maxIndex = numbers.indexOf(num)\n                   \
    \    ~~~~~~~ ^~~~~~~\n/tmp/tmpb2sq11b4.swift:15:9: error: invalid redeclaration\
    \ of 'maxIndex'\n    let maxIndex = maxIndex + numbers.count\n        ^\n/tmp/tmpb2sq11b4.swift:8:9:\
    \ note: 'maxIndex' previously declared here\n    var maxIndex = 0\n        ^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        var max = result[0]\n        var remaining = number\n        if\
    \ number > max {\n            remaining = number\n        }\n        if number\
    \ > remaining {\n            max = 0\n        }\n        result.append(max)\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad00c658c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad00c34f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad00c34f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad00c34f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad00c34ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad00c14ee83 <unavailable> + 188035

    6    tmpnt3ntsh6                        0x00005636be28c9e9 <unavailable> + 6633

    7    libswiftCore.so                    0x00002ad00c39be90 Sequence.reduce<A>(into:_:)
    + 494

    8    tmpnt3ntsh6                        0x00005636be28c954 <unavailable> + 6484

    9    tmpnt3ntsh6                        0x00005636be28c545 <unavailable> + 5445

    10   libc.so.6                          0x00002ad00c844460 __libc_start_main +
    245

    11   tmpnt3ntsh6                        0x00005636be28c149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    rolling_max.removeAll()\n\
    \    for number in numbers {\n        rolling_max = rolling_max.filter { $0 !=\
    \ number }\n        rolling_max.append(number)\n    }\n    return rolling_max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpydxdqaib/tmpydxdqaib.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bef3e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bef0deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9bef0de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9bef0dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpydxdqaib                        0x00005613834599b6 <unavailable> + 6582

    5    libc.so.6                          0x00002b9bef5d3460 __libc_start_main +
    245

    6    tmpydxdqaib                        0x0000561383459389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  return _recursive(numbers, numbers, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp0e9y0b5j.swift:7:10: error: cannot find '_recursive' in scope\n\
    \  return _recursive(numbers, numbers, 0)\n         ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    numbers.sort()\n    var rolling_max = numbers.first!\n\
    \    for i in 1..<numbers.count {\n        if numbers[i-1] < rolling_max {\n \
    \           rolling_max = numbers[i]\n        }\n    }\n    return rolling_max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8vbpnbbh.swift:7:13: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n    numbers.sort()\n    ~~~~~~~ ^\n/tmp/tmp8vbpnbbh.swift:14:12:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce(into: [Int](), { result, number\
    \ in\n        if result.count < 1 {\n            result.append(number)\n     \
    \   } else {\n            if number > result[result.count - 1] {\n           \
    \     result.append(number)\n            }\n        }\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpqnalfh2p/tmpqnalfh2p.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ef4503c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ef41fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ef41fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ef41f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqnalfh2p                        0x0000556334db37c6 <unavailable> + 6086

    5    libc.so.6                          0x00002b5ef46ef460 __libc_start_main +
    245

    6    tmpqnalfh2p                        0x0000556334db3199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max_(numbers, numbers)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpcz9n_mpt.swift:7:12: error: cannot find 'rolling_max_' in scope\n\
    \    return rolling_max_(numbers, numbers)\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rollingMax = [Int]()\n\n    var maxNumber = Int(numbers[0])\n\
    \    for number in numbers {\n        if number > maxNumber {\n            maxNumber\
    \ = number\n        }\n    }\n\n    for number in numbers {\n        if number\
    \ == maxNumber {\n            rollingMax.append(number)\n        }\n    }\n  \
    \  return rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b30ac123c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30abe1a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b30abe1a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b30abe1a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b30abe19bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b30abc19e83 <unavailable> + 188035

    6    tmpanpu2m7g                        0x000055cb0fc2ebce <unavailable> + 7118

    7    tmpanpu2m7g                        0x000055cb0fc2e66d <unavailable> + 5741

    8    libc.so.6                          0x00002b30ac30f460 __libc_start_main +
    245

    9    tmpanpu2m7g                        0x000055cb0fc2e379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    for number in numbers {\n \
    \       if number > max {\n            max = number\n        }\n    }\n    return\
    \ Array(max..<numbers.last!)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6caff9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cafc91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6cafc91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6cafc9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6cafc90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6cafa90e83 <unavailable> + 188035

    6    tmpboqjubhw                        0x0000557dced63c08 <unavailable> + 7176

    7    tmpboqjubhw                        0x0000557dced636ed <unavailable> + 5869

    8    libc.so.6                          0x00002b6cb0186460 __libc_start_main +
    245

    9    tmpboqjubhw                        0x0000557dced633f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let length = numbers.count\n    var rollingMax = 0\n\
    \    var lastRollingMax = -1\n    for idx in stride(from: 0, to: length, by: 1)\
    \ {\n        if numbers[idx] > rollingMax {\n            rollingMax = numbers[idx]\n\
    \            lastRollingMax = idx\n        }\n    }\n    return [rollingMax, lastRollingMax]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpm6ixwicy/tmpm6ixwicy.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b178e6bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178e3b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178e3b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178e3b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm6ixwicy                        0x000055c473ab0636 <unavailable> + 5686

    5    libc.so.6                          0x00002b178e8ab460 __libc_start_main +
    245

    6    tmpm6ixwicy                        0x000055c473ab0289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    // Add extra element for end\n    numbers.append(Int64(1))\n\
    \n    var largest = numbers[0]\n    var rolling_max = [Int]()\n\n    for number\
    \ in numbers {\n        if number > largest {\n            rolling_max = [Int](repeating:\
    \ number, count: numbers.count - rolling_max.count + 1)\n            largest =\
    \ number\n        }\n    }\n\n    rolling_max.append(Int64(1))\n\n    return rolling_max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpi3yjm_jw.swift:8:13: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n    numbers.append(Int64(1))\n    ~~~~~~~\
    \ ^\n/tmp/tmpi3yjm_jw.swift:8:20: error: cannot convert value of type 'Int64'\
    \ to expected argument type 'Int'\n    numbers.append(Int64(1))\n            \
    \       ^\n                   Int(    )\n/tmp/tmpi3yjm_jw.swift:20:24: error:\
    \ cannot convert value of type 'Int64' to expected argument type 'Int'\n    rolling_max.append(Int64(1))\n\
    \                       ^\n                       Int(    )\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    for number in numbers {\n \
    \       if number > max {\n            max = number\n        }\n    }\n    return\
    \ numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af970a51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af970748561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af970748286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af97074813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af970747bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af970547e83 <unavailable> + 188035

    6    tmpd98ca2om                        0x0000561038b2698f <unavailable> + 6543

    7    tmpd98ca2om                        0x0000561038b2647d <unavailable> + 5245

    8    libc.so.6                          0x00002af970c3d460 __libc_start_main +
    245

    9    tmpd98ca2om                        0x0000561038b26189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max: Int = 0\n    for number in numbers {\n     \
    \   if number > max {\n            max = number\n        }\n    }\n    return\
    \ numbers.map({ (number) -> Int in\n        return max\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpdws52c9p/tmpdws52c9p.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1560098c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b155fd8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b155fd8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b155fd8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdws52c9p                        0x00005585b360768d <unavailable> + 5773

    5    libc.so.6                          0x00002b1560284460 __libc_start_main +
    245

    6    tmpdws52c9p                        0x00005585b36071a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return maxSequence(numbers, windowSize: 1).prefix(2)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpo05b0ref.swift:7:12: error: cannot find 'maxSequence' in scope\n\
    \    return maxSequence(numbers, windowSize: 1).prefix(2)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maximum = numbers[0]\n    var results = [Int](repeating:\
    \ 0, count: numbers.count)\n    var counter = 0\n    for n in numbers {\n    \
    \    if maximum < n {\n            results[counter] = maximum\n            counter\
    \ = 0\n            maximum = n\n        } else {\n            counter += 1\n \
    \       }\n    }\n    if counter == 0 {\n        results[counter] = maximum\n\
    \    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab696074c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab695d6b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab695d6b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab695d6b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab695d6abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab695b6ae83 <unavailable> + 188035

    6    tmpa4x7_s0n                        0x000055b1ddeddad8 <unavailable> + 6872

    7    tmpa4x7_s0n                        0x000055b1ddedd59d <unavailable> + 5533

    8    libc.so.6                          0x00002ab696260460 __libc_start_main +
    245

    9    tmpa4x7_s0n                        0x000055b1ddedd2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return (0..<numbers.count).map { idx in\n        guard\
    \ idx != numbers.count - 1 else {\n            return numbers[idx]\n        }\n\
    \        return max(numbers[idx], numbers[idx + 1])\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpvdfs356e/tmpvdfs356e.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfa8aa5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfa879cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfa879c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfa879b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvdfs356e                        0x00005555b1b047bd <unavailable> + 6077

    5    libc.so.6                          0x00002abfa8c91460 __libc_start_main +
    245

    6    tmpvdfs356e                        0x00005555b1b042d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.sorted { $0 < $1 }.map {\n        if numbers[Int($0)]\
    \ == nil {\n            numbers[Int($0)] = Int($0)\n        }\n        return\
    \ numbers[Int($0)]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp9xdk32uj.swift:9:20: error: cannot assign through subscript: 'numbers'\
    \ is a 'let' constant\n            numbers[Int($0)] = Int($0)\n            ~~~~~~~^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex: Int = 0\n   \
    \ var index = numbers.startIndex\n    while index != numbers.endIndex {\n    \
    \    if numbers[index] > max {\n            max = numbers[index]\n           \
    \ maxIndex = index\n        }\n        index = index.successor()\n    }\n    return\
    \ maxIndex.map { numbers[$0] }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp03nycfy4.swift:15:23: error: value of type 'Int' has no member\
    \ 'successor'\n        index = index.successor()\n                ~~~~~ ^~~~~~~~~\n\
    /tmp/tmp03nycfy4.swift:17:21: error: value of type 'Int' has no member 'map'\n\
    \    return maxIndex.map { numbers[$0] }\n           ~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count >= rolling_min_count else {\n   \
    \     return []\n    }\n    return numbers.reduce(0, { max($0, $1) })\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_blpzvjj.swift:7:28: error: cannot find 'rolling_min_count' in\
    \ scope\n    guard numbers.count >= rolling_min_count else {\n               \
    \            ^~~~~~~~~~~~~~~~~\n/tmp/tmp_blpzvjj.swift:10:20: error: cannot convert\
    \ return expression of type 'Int' to return type '[Int]'\n    return numbers.reduce(0,\
    \ { max($0, $1) })\n           ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    \n    var rolling_max = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if rolling_max < numbers[i] {\n            rolling_max = numbers[i]\n\
    \        }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp5rzy_1ug.swift:14:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = 0\n    for number in numbers {\n  \
    \      if number > rolling_max {\n            rolling_max = number\n        }\n\
    \    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp0b3q28ba.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    \n    var max_value = 0\n    var current_max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > current_max {\n   \
    \         current_max = numbers[i]\n        }\n    }\n    if current_max > max_value\
    \ {\n        max_value = current_max\n    }\n    var result = [0]\n    for i in\
    \ 1..<numbers.count {\n        if numbers[i] != current_max {\n            result.append(numbers[i])\n\
    \        }\n    }\n    if max_value > 0 {\n        result.append(max_value)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b41d6d6ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41d6a61561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b41d6a61286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b41d6a6113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b41d6a60bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b41d6860e83 <unavailable> + 188035

    6    tmpphhr2l95                        0x000055e037812ab6 <unavailable> + 6838

    7    tmpphhr2l95                        0x000055e03781254d <unavailable> + 5453

    8    libc.so.6                          0x00002b41d6f56460 __libc_start_main +
    245

    9    tmpphhr2l95                        0x000055e037812259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let numberCount = numberData.count\n    let result =\
    \ Array(repeating: Int.max, count: numberCount)\n\n    for index in stride(from:\
    \ numberCount - 1, through: 0, by: -1) {\n        result[index] = numbers[index]\
    \ > result[index] ? numbers[index] : result[index]\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprh0_p_od.swift:7:23: error: cannot find 'numberData' in scope\n\
    \    let numberCount = numberData.count\n                      ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, window: 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpjht6507q.swift:7:41: error: extra argument 'window' in call\n \
    \   return rolling_max(numbers, window: 1)\n                      ~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maximum = numbers[0]\n    var indexes = Array(0..<numbers.count).map\
    \ { Int(arc4random_uniform(UInt32(numbers.count)))! }\n    while !numbers.indices.contains(indexes)\
    \ {\n        let index = indexes[indexes.count - 1]\n        if numbers[index]\
    \ > maximum {\n            maximum = numbers[index]\n        }\n        indexes[indexes.count\
    \ - 1] += 1\n    }\n    return Array(numbers[0..<indexes.count].map { numbers[$0]\
    \ }).reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpwhhcs3ue.swift:8:54: error: cannot find 'arc4random_uniform' in\
    \ scope\n    var indexes = Array(0..<numbers.count).map { Int(arc4random_uniform(UInt32(numbers.count)))!\
    \ }\n                                                     ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = numbers[0]\n    var max = numbers[0]\n \
    \   for i in numbers.indices {\n        if result[i] > max {\n            result\
    \ = numbers[i:i+1]\n            max = numbers[i]\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpcfcwaekx.swift:10:18: error: value of type 'Int' has no subscripts\n\
    \        if result[i] > max {\n           ~~~~~~^\n/tmp/tmpcfcwaekx.swift:11:29:\
    \ error: extraneous argument label 'i:' in subscript\n            result = numbers[i:i+1]\n\
    \                            ^~~\n                             \n/tmp/tmpcfcwaekx.swift:15:12:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return result\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rollingMax = [Int]()\n    var maxRollingTimes = [Int]()\n\
    \    for i in 0 ..< numbers.count {\n        if rollingMax.count < numbers.count\
    \ {\n            rollingMax.append(numbers[i])\n            maxRollingTimes.append(1)\n\
    \        } else {\n            if rollingMax[rollingMax.count - 1] < numbers[i]\
    \ {\n                rollingMax[rollingMax.count - 1] = numbers[i]\n         \
    \       maxRollingTimes[rollingMax.count - 1] = maxRollingTimes[rollingMax.count\
    \ - 1] + 1\n            }\n        }\n    }\n    return rollingMax\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpwnw8w_dx/tmpwnw8w_dx.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1f9520c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1f9217b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1f9217988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1f92167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwnw8w_dx                        0x000055cf3cbc0936 <unavailable> + 6454

    5    libc.so.6                          0x00002ae1f970c460 __libc_start_main +
    245

    6    tmpwnw8w_dx                        0x000055cf3cbc0309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxIndex = 0\n    var result = [Int](repeating: 0.0,\
    \ count: numbers.count)\n    for index in numbers.indices {\n        result[index]\
    \ = numbers[index]\n        if index > maxIndex {\n            maxIndex = index\n\
    \        }\n    }\n    return result.prefix(maxIndex + 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpcqkwvc52.swift:8:35: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n    var result = [Int](repeating: 0.0, count:\
    \ numbers.count)\n                                  ^\n                      \
    \            Int( )\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    \n    // get number of elements to generate\n    let\
    \ count = numbers.count\n    \n    // create temporary array of max values\n \
    \   var maxValues = [Int](repeating: 0, count: count)\n    \n    // start from\
    \ beginning of array\n    for i in 0 ..< count {\n        maxValues[i] = numbers[maxIndex:\
    \ i]\n    }\n    \n    // iterate until last element\n    for i in (count - 1\
    \ ..< numbers.count) {\n        \n        // set max to max before last element\n\
    \        let maxBeforeLast = maxIndex: i\n        \n        // set last element\
    \ to max\n        let lastElement = numbers[i]\n        \n        // check each\
    \ element to check if it greater than the previous\n        for j in 0 ..< maxIndex\
    \ {\n            \n            // if current element is greater than the previous\
    \ max, set max to current element\n            if numbers[j] < lastElement {\n\
    \                maxBeforeLast = j\n            }\n            \n        }\n \
    \       \n        // update max value\n        maxValues[i] = numbers[maxBeforeLast:\
    \ i]\n    }\n    \n    return maxValues\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp18t0a7qp.swift:23:37: error: consecutive statements on a line must\
    \ be separated by ';'\n        let maxBeforeLast = maxIndex: i\n             \
    \                       ^\n                                    ;\n/tmp/tmp18t0a7qp.swift:23:37:\
    \ error: expected expression\n        let maxBeforeLast = maxIndex: i\n      \
    \                              ^\n/tmp/tmp18t0a7qp.swift:16:31: error: extraneous\
    \ argument label 'maxIndex:' in subscript\n        maxValues[i] = numbers[maxIndex:\
    \ i]\n                              ^~~~~~~~~~~\n                            \
    \   \n/tmp/tmp18t0a7qp.swift:23:29: error: cannot find 'maxIndex' in scope\n \
    \       let maxBeforeLast = maxIndex: i\n                            ^~~~~~~~\n\
    /tmp/tmp18t0a7qp.swift:29:24: error: cannot find 'maxIndex' in scope\n       \
    \ for j in 0 ..< maxIndex {\n                       ^~~~~~~~\n/tmp/tmp18t0a7qp.swift:39:31:\
    \ error: extraneous argument label 'maxBeforeLast:' in subscript\n        maxValues[i]\
    \ = numbers[maxBeforeLast: i]\n                              ^~~~~~~~~~~~~~~~\n\
    \                               \n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n    var\
    \ rolling_max = numbers[0]\n    var rolling_max_pos = 0\n    for x in numbers\
    \ {\n        if x > rolling_max {\n            rolling_max = x\n        }\n  \
    \      rolling_max_pos = rolling_max_pos + 1\n    }\n\n    var result = [Int]()\n\
    \    for x in numbers {\n        if x == rolling_max {\n            result.append(rolling_max)\n\
    \            continue\n        }\n        if x - rolling_max == rolling_max_pos\
    \ {\n            rolling_max = x\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp66g2ciec/tmp66g2ciec.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab497070c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab496d67b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab496d67988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab496d667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp66g2ciec                        0x00005599f4ef876d <unavailable> + 5997

    5    libc.so.6                          0x00002ab49725c460 __libc_start_main +
    245

    6    tmp66g2ciec                        0x00005599f4ef8289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce([], { $0.maxElement() < $1.maxElement()\
    \ ? $0 : $1})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp879l546c.swift:7:54: error: value of type 'Int' has no member 'maxElement'\n\
    \    return numbers.reduce([], { $0.maxElement() < $1.maxElement() ? $0 : $1})\n\
    \                                                  ~~ ^~~~~~~~~~\n/tmp/tmp879l546c.swift:7:36:\
    \ error: value of type '[Int]' has no member 'maxElement'\n    return numbers.reduce([],\
    \ { $0.maxElement() < $1.maxElement() ? $0 : $1})\n                          \
    \      ~~ ^~~~~~~~~~\n/tmp/tmp879l546c.swift:7:69: error: result values in '?\
    \ :' expression have mismatching types '[Int]' and 'Int'\n    return numbers.reduce([],\
    \ { $0.maxElement() < $1.maxElement() ? $0 : $1})\n                          \
    \                                          ^~\n/tmp/tmp879l546c.swift:7:67: error:\
    \ cannot convert value of type 'Int' to closure result type '[Int]'\n    return\
    \ numbers.reduce([], { $0.maxElement() < $1.maxElement() ? $0 : $1})\n       \
    \                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  var max = [Int]()\n  var index = 0\n  var number = numbers[0]\n\
    \  for i in 1..<numbers.count {\n    if number > numbers[i] {\n      max = append(max,\
    \ number)\n      index = i\n      number = numbers[i]\n    } else {\n      number\
    \ = numbers[i]\n    }\n  }\n  max = append(max, number)\n  return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp3zwqz47s.swift:12:13: error: cannot find 'append' in scope\n  \
    \    max = append(max, number)\n            ^~~~~~\n/tmp/tmp3zwqz47s.swift:19:9:\
    \ error: cannot find 'append' in scope\n  max = append(max, number)\n        ^~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for n in numbers {\n        if\
    \ n > max[0] {\n            max[0] = n\n        }\n    }\n    var max_index =\
    \ -1\n    for n in numbers {\n        if n == max[0] {\n            max_index\
    \ += 1\n        }\n    }\n    if max_index == 0 {\n        return numbers\n  \
    \  }\n    \n    // Get list of indexes in the original array where max element\
    \ was found\n    var indexes = [Int]()\n    for n in numbers {\n        if n ==\
    \ max[0] {\n            indexes.insert(Int(n))\n        }\n    }\n    if max_index\
    \ == 1 {\n        // Remove all those indexes from the original array - these\
    \ were found to contain the maximum element at the end\n        for index in indexes\
    \ {\n            numbers.remove(at: index)\n        }\n        return numbers\n\
    \    }\n    \n    // Find max element at last index of the array containing max\
    \ element\n    for index in 0..<numbers.count {\n        let current = numbers[index]\n\
    \        if max[0] == current {\n            numbers.remove(at: index)\n     \
    \       numbers.insert(current, at: numbers.endIndex)\n            break\n   \
    \     }\n    }\n    \n    max = rolling_max(numbers: numbers)\n    \n    // Add\
    \ found max element to original array\n    for index in indexes {\n        numbers.insert(max[0],\
    \ at: index)\n    }\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpuqt4ihsz.swift:27:34: error: missing argument for parameter 'at'\
    \ in call\n            indexes.insert(Int(n))\n                              \
    \   ^\n                                 , at: <#Int#>\nSwift.Array:11:37: note:\
    \ 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n/tmp/tmpuqt4ihsz.swift:33:21: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n            numbers.remove(at: index)\n\
    \            ~~~~~~~ ^\n/tmp/tmpuqt4ihsz.swift:42:21: error: cannot use mutating\
    \ member on immutable value: 'numbers' is a 'let' constant\n            numbers.remove(at:\
    \ index)\n            ~~~~~~~ ^\n/tmp/tmpuqt4ihsz.swift:43:21: error: cannot use\
    \ mutating member on immutable value: 'numbers' is a 'let' constant\n        \
    \    numbers.insert(current, at: numbers.endIndex)\n            ~~~~~~~ ^\n/tmp/tmpuqt4ihsz.swift:52:17:\
    \ error: cannot use mutating member on immutable value: 'numbers' is a 'let' constant\n\
    \        numbers.insert(max[0], at: index)\n        ~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var maxIndex = 0\n\n    for idx\
    \ in 0..<numbers.count {\n        if numbers[idx] < numbers[maxIndex] {\n    \
    \        max.append(numbers[idx])\n            maxIndex = idx\n        }\n   \
    \ }\n\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpx1ns5j34/tmpx1ns5j34.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8082975c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b808266cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b808266c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b808266b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx1ns5j34                        0x0000562ac1fdc79d <unavailable> + 6045

    5    libc.so.6                          0x00002b8082b61460 __libc_start_main +
    245

    6    tmpx1ns5j34                        0x0000562ac1fdc2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.window(by: -1).reduce(1, combineMax: {max,\
    \ current in max(max, current)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsspn21yv.swift:7:20: error: value of type '[Int]' has no member\
    \ 'window'\n    return numbers.window(by: -1).reduce(1, combineMax: {max, current\
    \ in max(max, current)})\n           ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers\n    var rolling_maxIdx = 0\n\
    \    while rolling_maxIdx < numbers.count - 1 {\n        if rolling_max[rolling_maxIdx]\
    \ <= numbers[rolling_maxIdx + 1] {\n            rolling_maxIdx += 1\n        }\
    \ else {\n            rolling_max[rolling_maxIdx] = numbers[rolling_maxIdx]\n\
    \            rolling_maxIdx += 1\n        }\n    }\n    return rolling_max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp5l6z5nov/tmp5l6z5nov.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ceb782c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ceb479b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ceb479988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ceb4787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5l6z5nov                        0x0000557ad67646f6 <unavailable> + 5878

    5    libc.so.6                          0x00002b9ceb96e460 __libc_start_main +
    245

    6    tmp5l6z5nov                        0x0000557ad67640c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n    var\
    \ maxElement = numbers.first!\n    var maxIndex = -1\n    var maxIndexElement\
    \ = numbers.first!\n    var newElement: Int = 0\n    for i in 1..<numbers.count\
    \ {\n        if maxIndex == i {\n            newElement = maxElement\n       \
    \     maxIndexElement = maxIndex\n        } else {\n            if numbers[i -\
    \ 1] < numbers[maxIndex] {\n                newElement = numbers[i - 1]\n    \
    \            maxIndexElement = numbers[i - 1]\n            } else {\n        \
    \        newElement = maxElement\n                maxIndexElement = maxIndex\n\
    \            }\n        }\n        if maxIndexElement > numbers[i] {\n       \
    \     maxElement = maxIndexElement\n            maxIndex = i\n        }\n    }\n\
    \    if newElement > maxElement {\n        maxElement = newElement\n    }\n  \
    \  return [maxIndexElement, maxElement]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5965e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5962e0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab5962e0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab5962e013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab5962dfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab5960dfe83 <unavailable> + 188035

    6    tmpr38vsfz1                        0x000056196fc74eab <unavailable> + 7851

    7    tmpr38vsfz1                        0x000056196fc746f5 <unavailable> + 5877

    8    libc.so.6                          0x00002ab5967d5460 __libc_start_main +
    245

    9    tmpr38vsfz1                        0x000056196fc742f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var res: [Int] = numbers\n    var mx: Int = numbers.max()!\n\
    \    var maxIndex = -1\n\n    for i in 0..<numbers.count {\n        res[i] = numbers[i]\n\
    \        if maxIndex < res[i] {\n            maxIndex = res[i]\n        }\n  \
    \  }\n    for i in 0..<numbers.count {\n        res[maxIndex] = mx\n    }\n  \
    \  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpptv87bjk/tmpptv87bjk.swift:8: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8c02c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8bffbd561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8bffbd286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8bffbd13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8bffbcbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpptv87bjk                        0x0000563ca7580c21 <unavailable> + 7201

    6    tmpptv87bjk                        0x0000563ca75805ed <unavailable> + 5613

    7    libc.so.6                          0x00002ae8c04b2460 __libc_start_main +
    245

    8    tmpptv87bjk                        0x0000563ca75802f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, numFrames: numbers?.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp0voapt4o.swift:7:53: error: extra argument 'numFrames' in call\n\
    \    return rolling_max(numbers, numFrames: numbers?.count)\n                \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n/tmp/tmp0voapt4o.swift:7:51: error:\
    \ cannot use optional chaining on non-optional value of type '[Int]'\n    return\
    \ rolling_max(numbers, numFrames: numbers?.count)\n                          \
    \                 ~~~~~~~^\n                                                 \
    \ \n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    numbers.removeAll()\n    return numbers\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp5mo9cbqv.swift:7:13: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n    numbers.removeAll()\n    ~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    rolling_max_helper(numbers, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp2lxq38d1.swift:7:5: error: cannot find 'rolling_max_helper' in\
    \ scope\n    rolling_max_helper(numbers, 0)\n    ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let window = RollingMaxWindow(windowSize: numbers.count,\
    \ stride: 1)\n    let rollingMax = numbers.windowed(by: window).maxElement()\n\
    \    return rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp2spzjxgc.swift:7:18: error: cannot find 'RollingMaxWindow' in scope\n\
    \    let window = RollingMaxWindow(windowSize: numbers.count, stride: 1)\n   \
    \              ^~~~~~~~~~~~~~~~\n/tmp/tmp2spzjxgc.swift:8:30: error: value of\
    \ type '[Int]' has no member 'windowed'\n    let rollingMax = numbers.windowed(by:\
    \ window).maxElement()\n                     ~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_number = numbers[0]\n    var result = [Int]()\n\
    \n    for i in 1..<numbers.count {\n        if max_number > numbers[i] {\n   \
    \         max_number = numbers[i]\n        }\n        result.append(max_number)\n\
    \    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4323bf5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43238ec561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b43238ec286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b43238ec13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b43238ebbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b43236ebe83 <unavailable> + 188035

    6    tmp185ke49_                        0x000055cea299cad8 <unavailable> + 6872

    7    tmp185ke49_                        0x000055cea299c5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b4323de1460 __libc_start_main +
    245

    9    tmp185ke49_                        0x000055cea299c2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxIndex = 0\n    var maxValue = numbers[0]\n   \
    \ for i in  0..<numbers.count {\n        if numbers[i] > maxValue {\n        \
    \    maxValue = numbers[i]\n            maxIndex = i\n        }\n    }\n    return\
    \ Array(numbers[0..<maxIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f76e40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f76b37561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6f76b37286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6f76b3713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6f76b36bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6f76936e83 <unavailable> + 188035

    6    tmpzge4g8i7                        0x00005650a31c9b80 <unavailable> + 7040

    7    tmpzge4g8i7                        0x00005650a31c964d <unavailable> + 5709

    8    libc.so.6                          0x00002b6f7702c460 __libc_start_main +
    245

    9    tmpzge4g8i7                        0x00005650a31c9359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    \n    var max = [Int](repeating: 0, count: numbers.count)\n\
    \    \n    for i in numbers.indices {\n        \n        if max[i] < numbers[i]\
    \ {\n            \n            if max[i] < numbers[i-1] {\n                max[i]\
    \ = numbers[i-1]\n            } else {\n                max[i] = numbers[i]\n\
    \            }\n        }\n    }\n    \n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5210439c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5210130561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5210130286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b521013013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b521012fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b520ff2fe83 <unavailable> + 188035

    6    tmpl_ndioz2                        0x0000559a5cf68c1d <unavailable> + 7197

    7    tmpl_ndioz2                        0x0000559a5cf686b5 <unavailable> + 5813

    8    libc.so.6                          0x00002b5210625460 __libc_start_main +
    245

    9    tmpl_ndioz2                        0x0000559a5cf682b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    var max = numbers.max()\n\
    \    while max > numbers[index] {\n        max = numbers[index]\n        index\
    \ += 1\n    }\n    maxIndex = index\n    while index < numbers.count {\n     \
    \   max = numbers[index]\n        if max > numbers[index] {\n            max =\
    \ numbers[index]\n            index++\n        }\n        else {\n           \
    \ break\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp4fzi1il3.swift:9:9: error: invalid redeclaration of 'max'\n   \
    \ var max = numbers.max()\n        ^\n/tmp/tmp4fzi1il3.swift:7:9: note: 'max'\
    \ previously declared here\n    var max = [Int]()\n        ^\n/tmp/tmp4fzi1il3.swift:14:5:\
    \ error: cannot find 'maxIndex' in scope\n    maxIndex = index\n    ^~~~~~~~\n\
    /tmp/tmp4fzi1il3.swift:19:18: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            index++\n                 ^~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.sorted(by: >)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpino8j_0f/tmpino8j_0f.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae01466fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae014366b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae014366988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0143657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpino8j_0f                        0x000056226cb3551d <unavailable> + 5405

    5    libc.so.6                          0x00002ae01485b460 __libc_start_main +
    245

    6    tmpino8j_0f                        0x000056226cb35039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = numbers[numbers.startIndex]\n    let firstElementIndex\
    \ = numbers.startIndex\n    for i in numbers.startIndex..<numbers.endIndex {\n\
    \        if i > numbers.endIndex-1 {\n            break\n        }\n        if\
    \ numbers[i] > result {\n            result = numbers[i]\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppivmxxlc.swift:17:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return result\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxNumber = 0\n    var currentMaxNumber = 0\n\n \
    \   for number in numbers {\n        currentMaxNumber = maxNumber\n        maxNumber\
    \ = number\n    }\n\n    if maxNumber > currentMaxNumber {\n        numbers.append(currentMaxNumber)\n\
    \    }\n\n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7k_3q_ij.swift:16:17: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n        numbers.append(currentMaxNumber)\n\
    \        ~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    // TODO: use window\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpp719w_yc/tmpp719w_yc.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab60869ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab608395b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab608395988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6083947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp719w_yc                        0x000056552debc4ad <unavailable> + 5293

    5    libc.so.6                          0x00002ab60888a460 __libc_start_main +
    245

    6    tmpp719w_yc                        0x000056552debbfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n\tvar rolling_max = [0]\n\tfor i in 0..<numbers.count {\n\
    \t\trolling_max[0] += numbers[i]\n\t\tif rolling_max[0] >= numbers[i] {\n\t\t\t\
    rolling_max[1] = numbers[i]\n\t\t}\n\t}\n\treturn rolling_max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmp9run_ur9/tmp9run_ur9.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4467cdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4464c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4464c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4464c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9run_ur9                        0x000055a91bab4606 <unavailable> + 5638

    5    libc.so.6                          0x00002af4469b9460 __libc_start_main +
    245

    6    tmp9run_ur9                        0x000055a91bab4259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let rollingMax = numbers.reduce(0) { (max, element) in\n\
    \        if max < element {\n            return element\n        }\n        return\
    \ max\n    }\n    return rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmplwn6vrvr.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rollingMax\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    for number in numbers {\n \
    \       result.append(number)\n    }\n    rolling_max(numbers: result, index:\
    \ 0)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpgtbuq6n4.swift:11:41: error: extra argument 'index' in call\n \
    \   rolling_max(numbers: result, index: 0)\n               ~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    for i in 0..<numbers.count\
    \ {\n        result.append(max(numbers[i..<numbers.count]))\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpc0c1r699.swift:9:36: error: cannot convert value of type 'Range<Int>'\
    \ to expected argument type 'Int'\n        result.append(max(numbers[i..<numbers.count]))\n\
    \                                   ^\n/tmp/tmpc0c1r699.swift:9:53: error: missing\
    \ argument for parameter #2 in call\n        result.append(max(numbers[i..<numbers.count]))\n\
    \                                                    ^\n                     \
    \                               , <#Int#>\nSwift.max:1:24: note: 'max' declared\
    \ here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_number : Int = numbers[0]\n    var max_indices\
    \ : [Int] = [0]\n    for number in numbers {\n        if number > max_number {\n\
    \            max_number = number\n        }\n        max_indices.append(max_indices.last\
    \ + 1)\n    }\n    return max_indices.map { numbers[$0] }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpiqiau8z2.swift:13:40: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        max_indices.append(max_indices.last\
    \ + 1)\n                                       ^\n/tmp/tmpiqiau8z2.swift:13:40:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        max_indices.append(max_indices.last + 1)\n                  \
    \                     ^\n                           (                ?? <#default\
    \ value#>)\n/tmp/tmpiqiau8z2.swift:13:40: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        max_indices.append(max_indices.last\
    \ + 1)\n                                       ^\n                           \
    \                !\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    var maxIdx\
    \ = 0\n    for n in numbers {\n        if n > max[maxIdx] {\n            max =\
    \ Array(numbers[0..<index])\n            maxIdx = index\n        }\n        max[maxIdx]\
    \ = n\n        index++\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpil8uwk5d.swift:16:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for x in numbers {\n        for\
    \ y in max {\n            if y >= x {\n                break\n            } else\
    \ {\n                y.append(x)\n            }\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpz7dzhm84.swift:13:19: error: value of type 'Int' has no member\
    \ 'append'\n                y.append(x)\n                ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n\n  \
    \  var maximums = NSArray()\n    var currentMax = numbers.first!\n    var maxCount\
    \ = 0\n    for number in numbers {\n        if number == currentMax {\n      \
    \      maxCount += 1\n        } else {\n            if maxCount == 0 {\n     \
    \           maximums = NSArray(object: number)\n            } else {\n       \
    \         if maxCount > 1 {\n                    maximums = NSArray(object: currentMax,\
    \ forKey: NSNumber(integer: maxCount))\n                } else {\n           \
    \         maximums.addObject(NSNumber(integer: currentMax))\n                }\n\
    \            }\n            maxCount = 1\n            currentMax = number\n  \
    \      }\n    }\n\n    if maxCount == 0 {\n        maximums = NSArray(object:\
    \ currentMax)\n    } else {\n        if maxCount > 1 {\n            maximums =\
    \ NSArray(object: currentMax, forKey: NSNumber(integer: maxCount))\n        }\
    \ else {\n            maximums.addObject(NSNumber(integer: currentMax))\n    \
    \    }\n    }\n\n    return maximums.array as! [Int]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpgenpzcrr.swift:11:20: error: cannot find 'NSArray' in scope\n \
    \   var maximums = NSArray()\n                   ^~~~~~~\n/tmp/tmpgenpzcrr.swift:19:28:\
    \ error: cannot find 'NSArray' in scope\n                maximums = NSArray(object:\
    \ number)\n                           ^~~~~~~\n/tmp/tmpgenpzcrr.swift:22:32: error:\
    \ cannot find 'NSArray' in scope\n                    maximums = NSArray(object:\
    \ currentMax, forKey: NSNumber(integer: maxCount))\n                         \
    \      ^~~~~~~\n/tmp/tmpgenpzcrr.swift:22:68: error: cannot find 'NSNumber' in\
    \ scope\n                    maximums = NSArray(object: currentMax, forKey: NSNumber(integer:\
    \ maxCount))\n                                                               \
    \    ^~~~~~~~\n/tmp/tmpgenpzcrr.swift:24:40: error: cannot find 'NSNumber' in\
    \ scope\n                    maximums.addObject(NSNumber(integer: currentMax))\n\
    \                                       ^~~~~~~~\n/tmp/tmpgenpzcrr.swift:33:20:\
    \ error: cannot find 'NSArray' in scope\n        maximums = NSArray(object: currentMax)\n\
    \                   ^~~~~~~\n/tmp/tmpgenpzcrr.swift:36:24: error: cannot find\
    \ 'NSArray' in scope\n            maximums = NSArray(object: currentMax, forKey:\
    \ NSNumber(integer: maxCount))\n                       ^~~~~~~\n/tmp/tmpgenpzcrr.swift:36:60:\
    \ error: cannot find 'NSNumber' in scope\n            maximums = NSArray(object:\
    \ currentMax, forKey: NSNumber(integer: maxCount))\n                         \
    \                                  ^~~~~~~~\n/tmp/tmpgenpzcrr.swift:38:32: error:\
    \ cannot find 'NSNumber' in scope\n            maximums.addObject(NSNumber(integer:\
    \ currentMax))\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers.min()!\n    var max_numbers\
    \ = numbers\n    for i in numbers.indices {\n        if numbers[i] <= max_so_far\
    \ {\n            continue\n        }\n        max_numbers[i] = max_so_far\n  \
    \      max_so_far = numbers[i]\n    }\n    return max_numbers\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpne7c0jmk/tmpne7c0jmk.swift:7: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b02629ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b02626d4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b02626d4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b02626d413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b02626d3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpne7c0jmk                        0x000055d4670e1c0b <unavailable> + 7179

    6    tmpne7c0jmk                        0x000055d4670e161d <unavailable> + 5661

    7    libc.so.6                          0x00002b0262bc9460 __libc_start_main +
    245

    8    tmpne7c0jmk                        0x000055d4670e1329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = numbers[0]\n    for number in numbers {\n\
    \        result = max(result, number)\n    }\n    return Array(result)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp2wh630yx.swift:11:18: error: missing argument label 'arrayLiteral:'\
    \ in call\n    return Array(result)\n                 ^\n                 arrayLiteral:\
    \ \n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var minPos = numbers.startIndex\n\
    \    var minVal = numbers[0]\n\n    for n in numbers {\n        if n < min {\n\
    \            min = n\n            minPos = numbers.startIndex\n            minVal\
    \ = n\n        } else if n > max {\n            max = n\n        }\n    }\n\n\
    \    var result = [Int]()\n\n    for n in numbers {\n        if n == min {\n \
    \           insert(result, minVal)\n            minPos += 1\n        }\n    }\n\
    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpjoahuh58.swift:12:14: error: type '(T, T) -> T' cannot conform\
    \ to 'BinaryInteger'\n        if n < min {\n             ^\n/tmp/tmpjoahuh58.swift:12:14:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        if n < min {\n             ^\n/tmp/tmpjoahuh58.swift:12:14:\
    \ note: required by operator function '<' where 'Other' = '(T, T) -> T'\n    \
    \    if n < min {\n             ^\n/tmp/tmpjoahuh58.swift:12:16: error: generic\
    \ parameter 'T' could not be inferred\n        if n < min {\n               ^\n\
    Swift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_\
    \ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpjoahuh58.swift:13:13:\
    \ error: no exact matches in reference to global function 'min'\n            min\
    \ = n\n            ^\n/tmp/tmpjoahuh58.swift:13:13: note: found candidate with\
    \ type '(_, _) -> _'\n            min = n\n            ^\n/tmp/tmpjoahuh58.swift:13:13:\
    \ note: found candidate with type '(_, _, _, _...) -> _'\n            min = n\n\
    \            ^\n/tmp/tmpjoahuh58.swift:24:14: error: type '(T, T) -> T' cannot\
    \ conform to 'BinaryInteger'\n        if n == min {\n             ^\n/tmp/tmpjoahuh58.swift:24:14:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        if n == min {\n             ^\n/tmp/tmpjoahuh58.swift:24:14:\
    \ note: required by operator function '==' where 'Other' = '(T, T) -> T'\n   \
    \     if n == min {\n             ^\n/tmp/tmpjoahuh58.swift:24:17: error: generic\
    \ parameter 'T' could not be inferred\n        if n == min {\n               \
    \ ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_\
    \ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpjoahuh58.swift:25:13:\
    \ error: cannot find 'insert' in scope\n            insert(result, minVal)\n \
    \           ^~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return reduce(numbers) { (max: Int, n: Int) -> Int in\n\
    \        if n < max {\n            max = n\n        }\n        return max\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(rolling_max(numbers: [] as [Int])\
    \ == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\n\
    assert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpkds_xskp.swift:7:12: error: cannot find 'reduce' in scope\n   \
    \ return reduce(numbers) { (max: Int, n: Int) -> Int in\n           ^~~~~~\n/tmp/tmpkds_xskp.swift:9:13:\
    \ error: cannot assign to value: 'max' is a 'let' constant\n            max =\
    \ n\n            ^~~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max: Int = 0\n    for num in numbers {\n        max\
    \ = num if num > max else max\n    }\n    var rolling_max = [Int]()\n    for num\
    \ in numbers {\n        rolling_max = [num] + rolling_max\n    }\n    return rolling_max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp96xqhxmq.swift:9:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        max = num if num > max else max\n             \
    \    ^\n                 ;\n/tmp/tmp96xqhxmq.swift:9:32: error: unexpected 'else'\
    \ immediately following 'if' condition\n        max = num if num > max else max\n\
    \                               ^\n/tmp/tmp96xqhxmq.swift:9:32: note: remove 'else'\
    \ to execute the braced block of statements when the condition is true\n     \
    \   max = num if num > max else max\n                               ^~~~~\n  \
    \                             \n/tmp/tmp96xqhxmq.swift:9:37: error: expected '{'\
    \ after 'if' condition\n        max = num if num > max else max\n            \
    \                        ^\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    \n    let rollingMax: [Int] = [0]\n    var current: Int?\n\
    \    var max: Int?\n    for number in numbers {\n        if current == nil {\n\
    \            current = number\n            max = number\n        } else if number\
    \ > current {\n            max = number\n        } else {\n            if max\
    \ == nil {\n                max = number\n            }\n            current =\
    \ max\n        }\n        rollingMax.append(max!)\n    }\n    return rollingMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpapmd767i.swift:15:28: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        } else if number > current {\n\
    \                           ^\n/tmp/tmpapmd767i.swift:15:28: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        }\
    \ else if number > current {\n                           ^\n                 \
    \                  ?? <#default value#>\n/tmp/tmpapmd767i.swift:15:28: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        }\
    \ else if number > current {\n                           ^\n                 \
    \                 !\n/tmp/tmpapmd767i.swift:23:20: error: cannot use mutating\
    \ member on immutable value: 'rollingMax' is a 'let' constant\n        rollingMax.append(max!)\n\
    \        ~~~~~~~~~~ ^\n/tmp/tmpapmd767i.swift:8:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let rollingMax: [Int] = [0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    var rolling_max_i = 0\n\
    \    for n in numbers {\n        if rolling_max[rolling_max_i] > n {\n       \
    \     rolling_max[rolling_max_i] = n\n        } else {\n            rolling_max_i\
    \ += 1\n        }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b376cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b373c2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4b373c2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4b373c213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4b373c1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4b371c1e83 <unavailable> + 188035

    6    tmp4o8n4vci                        0x000055dfc0c9cb1d <unavailable> + 6941

    7    tmp4o8n4vci                        0x000055dfc0c9c635 <unavailable> + 5685

    8    libc.so.6                          0x00002b4b378b7460 __libc_start_main +
    245

    9    tmp4o8n4vci                        0x000055dfc0c9c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n\tvar max = numbers.min()\n\tvar result = [Int](repeating:\
    \ 0, count: numbers.count)\n\tvar index = 0\n\n\tfor i in numbers {\n\t\tresult[index]\
    \ = i\n\t\tif max < i {\n\t\t\tmax = i\n\t\t}\n\t\tindex += 1\n\t}\n\n\treturn\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp000i9ly3.swift:13:6: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n                if max < i {\n      \
    \             ^\n/tmp/tmp000i9ly3.swift:13:6: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n                if max < i\
    \ {\n                   ^\n                       ?? <#default value#>\n/tmp/tmp000i9ly3.swift:13:6:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n                if max < i {\n                   ^\n                \
    \      !\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let window = numbers[numbers.startIndex]\n    var max\
    \ = 0\n    var maxIndex = numbers.startIndex\n\n    for i in numbers.indices {\n\
    \        if numbers[i] > window {\n            max = numbers[i]\n            maxIndex\
    \ = i\n        }\n    }\n    return [max]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b23186cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23183c6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b23183c6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b23183c613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b23183c5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b23181c5e83 <unavailable> + 188035

    6    tmpwho806ln                        0x000055c51e7d1a36 <unavailable> + 6710

    7    tmpwho806ln                        0x000055c51e7d14ed <unavailable> + 5357

    8    libc.so.6                          0x00002b23188bb460 __libc_start_main +
    245

    9    tmpwho806ln                        0x000055c51e7d11f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max_by(numbers, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpen_avl1a.swift:7:12: error: cannot find 'rolling_max_by' in scope\n\
    \    return rolling_max_by(numbers, 0)\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_index = numbers.startIndex\n    var max_number\
    \ = numbers[0]\n\n    for i in 1..<numbers.count {\n        if numbers[i] > max_number\
    \ {\n            max_number = numbers[i]\n            max_index = i\n        }\n\
    \    }\n\n    return Array(numbers[max_index...]).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b27e1847c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27e153e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b27e153e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b27e153e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b27e153dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b27e133fe83 <unavailable> + 188035

    6    tmpchs0wtif                        0x000055fbf31a9d8b <unavailable> + 7563

    7    tmpchs0wtif                        0x000055fbf31a984d <unavailable> + 6221

    8    libc.so.6                          0x00002b27e1a33460 __libc_start_main +
    245

    9    tmpchs0wtif                        0x000055fbf31a9559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n\tvar max = numbers[0]\n\tvar result: [Int] = []\n\tfor i,\
    \ number in numbers.enumerated() {\n\t\tif number > max {\n\t\t\tmax = number\n\
    \t\t\tresult = [number]\n\t\t\tcontinue\n\t\t}\n\t\tresult.append(number)\n\t\
    }\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpyijvqf1f.swift:9:7: error: expected 'in' after for-each pattern\n\
    \        for i, number in numbers.enumerated() {\n             ^\n/tmp/tmpyijvqf1f.swift:9:7:\
    \ error: expected Sequence expression for for-each loop\n        for i, number\
    \ in numbers.enumerated() {\n             ^\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max_internal(numbers, Int64(0))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpfv0shtzn.swift:7:12: error: cannot find 'rolling_max_internal'\
    \ in scope\n    return rolling_max_internal(numbers, Int64(0))\n           ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxSoFar = numbers[0]\n    return numbers.filter\
    \ {\n        currMax in\n        maxSoFar > currMax && currMax != 0\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aca4aa79c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca4a770561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aca4a770286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aca4a77013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aca4a76fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aca4a56fe83 <unavailable> + 188035

    6    tmpz_y_1m65                        0x000055c3f42e28c4 <unavailable> + 6340

    7    tmpz_y_1m65                        0x000055c3f42e23dd <unavailable> + 5085

    8    libc.so.6                          0x00002aca4ac65460 __libc_start_main +
    245

    9    tmpz_y_1m65                        0x000055c3f42e20e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce(into: [Int]()) { rolling, number\
    \ in\n        rolling[rolling.count-1] < number ? rolling.append(number) : rolling\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsmzhx_64.swift:8:53: error: result values in '? :' expression have\
    \ mismatching types '()' and '[Int]'\n        rolling[rolling.count-1] < number\
    \ ? rolling.append(number) : rolling\n                                       \
    \     ~~~~~~~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxSoFar: Int = 0\n    var rollingMax = [Int]()\n\
    \n    for i in 0..<numbers.count {\n        rollingMax.append(numbers[i])\n  \
    \      if maxSoFar < rollingMax.last {\n            maxSoFar = rollingMax.last\n\
    \        }\n    }\n    return rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpbs65oowf.swift:12:34: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if maxSoFar < rollingMax.last\
    \ {\n                                 ^\n/tmp/tmpbs65oowf.swift:12:34: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if maxSoFar < rollingMax.last {\n                                 ^\n  \
    \                                    ?? <#default value#>\n/tmp/tmpbs65oowf.swift:12:34:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if maxSoFar < rollingMax.last {\n                           \
    \      ^\n                                     !\n/tmp/tmpbs65oowf.swift:13:35:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            maxSoFar = rollingMax.last\n                                  ^\n\
    /tmp/tmpbs65oowf.swift:13:35: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n            maxSoFar = rollingMax.last\n\
    \                                  ^\n                                       ??\
    \ <#default value#>\n/tmp/tmpbs65oowf.swift:13:35: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n            maxSoFar\
    \ = rollingMax.last\n                                  ^\n                   \
    \                   !\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    numbers.sort()\n    var max_count = 0\n    var max_element\
    \ = numbers[0]\n    for i in numbers {\n        if i > max_element {\n       \
    \     max_count = numbers.countIndex {$0 == i}\n            max_element = i\n\
    \        }\n    }\n    var result = [Int]()\n    for i in 0..<numbers.count {\n\
    \        if numbers.countIndex {$0 == i} != max_count {\n            result.append(i)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpheip702x.swift:7:13: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n    numbers.sort()\n    ~~~~~~~ ^\n/tmp/tmpheip702x.swift:12:33:\
    \ error: value of type '[Int]' has no member 'countIndex'\n            max_count\
    \ = numbers.countIndex {$0 == i}\n                        ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpheip702x.swift:18:20: error: value of type '[Int]' has no member 'countIndex'\n\
    \        if numbers.countIndex {$0 == i} != max_count {\n           ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty() { return [] }\n    \n    var maxIndex:\
    \ Int = 0\n    var rollingMax: Int?\n    var result: [Int] = []\n    for idx in\
    \ 0..<numbers.count {\n        if rollingMax == nil || numbers[idx] > rollingMax!\
    \ {\n            rollingMax = numbers[idx]\n            maxIndex = idx\n     \
    \   } else {\n            rollingMax! = numbers[idx]\n        }\n        \n  \
    \      result.append(rollingMax!)\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpinko6208.swift:7:16: error: cannot call value of non-function type\
    \ 'Bool'\n    if numbers.isEmpty() { return [] }\n               ^      ~~\n \
    \                     \n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce(0, { $0 > $1 ? $1 : $0 })\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpbso9dfm2.swift:7:20: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return numbers.reduce(0, { $0 > $1 ?\
    \ $1 : $0 })\n           ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max : [Int] = [0]\n    var max_num = 0\n\
    \    for element in numbers {\n        max_num = max(max_num, element)\n     \
    \   rolling_max.append(max_num)\n    }\n    return rolling_max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpdt4q4luj/tmpdt4q4luj.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb7638fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb76086b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb76086988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb760857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdt4q4luj                        0x00005555943305d6 <unavailable> + 5590

    5    libc.so.6                          0x00002acb7657b460 __libc_start_main +
    245

    6    tmpdt4q4luj                        0x0000555594330229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var max_idx = 1\n    for idx\
    \ in 1..<numbers.count {\n        if max < numbers[idx] {\n            max = numbers[idx]\n\
    \            max_idx = idx\n        }\n    }\n    return [max]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6c7a14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6c770b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac6c770b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac6c770b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac6c770abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac6c750ae83 <unavailable> + 188035

    6    tmpjcqikpi6                        0x0000560a76920a12 <unavailable> + 6674

    7    tmpjcqikpi6                        0x0000560a769204ed <unavailable> + 5357

    8    libc.so.6                          0x00002ac6c7c00460 __libc_start_main +
    245

    9    tmpjcqikpi6                        0x0000560a769201f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = numbers.startIndex\n\
    \    for i in numbers.dropFirst() {\n        if i > max {\n            max = i\n\
    \            maxIndex = numbers.index(after: i)\n        }\n    }\n    return\
    \ maxIndex == numbers.startIndex ? [max] : Array(numbers[maxIndex...])\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d66b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d66841561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d66841286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d6684113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d66840bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d66640e83 <unavailable> + 188035

    6    tmpcgyes_59                        0x0000560b2e97adfb <unavailable> + 7675

    7    tmpcgyes_59                        0x0000560b2e97a8cd <unavailable> + 6349

    8    libc.so.6                          0x00002b9d66d36460 __libc_start_main +
    245

    9    tmpcgyes_59                        0x0000560b2e97a5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var prevMax = [Int]()\n\n \
    \   for number in numbers {\n        if number > prevMax.last {\n            prevMax.append(number)\n\
    \        } else {\n            result.append(prevMax.last)\n            prevMax\
    \ = [number]\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp30x8rzun.swift:11:29: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if number > prevMax.last {\n\
    \                            ^\n/tmp/tmp30x8rzun.swift:11:29: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        if\
    \ number > prevMax.last {\n                            ^\n                   \
    \              ?? <#default value#>\n/tmp/tmp30x8rzun.swift:11:29: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ number > prevMax.last {\n                            ^\n                   \
    \             !\n/tmp/tmp30x8rzun.swift:14:35: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n            result.append(prevMax.last)\n\
    \                                  ^\n/tmp/tmp30x8rzun.swift:14:35: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \         result.append(prevMax.last)\n                                  ^\n \
    \                                      ?? <#default value#>\n/tmp/tmp30x8rzun.swift:14:35:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            result.append(prevMax.last)\n                           \
    \       ^\n                                      !\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let result = [Int]()\n    let window = numbers.count\n\
    \    for number in numbers {\n        let idx = numbers.index(of: number) + window\n\
    \        result.append(numbers[idx])\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpivljzqb0.swift:10:27: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n        let idx = numbers.index(of: number) + window\n        \
    \                  ^\n/tmp/tmpivljzqb0.swift:10:27: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        let idx\
    \ = numbers.index(of: number) + window\n                          ^\n        \
    \          (                         ?? <#default value#>)\n/tmp/tmpivljzqb0.swift:10:27:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let idx = numbers.index(of: number) + window\n              \
    \            ^\n                                           !\n/tmp/tmpivljzqb0.swift:11:16:\
    \ error: no exact matches in call to instance method 'append'\n        result.append(numbers[idx])\n\
    \               ^\n/tmp/tmpivljzqb0.swift:11:16: note: found candidate with type\
    \ '(__owned Int) -> ()'\n        result.append(numbers[idx])\n               ^\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var res = Int()\n    var max_element = numbers[0]\n \
    \   for num in numbers {\n        if num > max_element {\n            max_element\
    \ = num\n        }\n    }\n    for num in numbers {\n        if num == max_element\
    \ {\n            res++\n        } else if num > max_element {\n            res\
    \ = num\n        }\n    }\n    return Array(res)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpxaqhget7.swift:16:16: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            res++\n               ^~\n/tmp/tmpxaqhget7.swift:21:18:\
    \ error: missing argument label 'arrayLiteral:' in call\n    return Array(res)\n\
    \                 ^\n                 arrayLiteral: \n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for number in numbers {\n    \
    \    if max != nil {\n            for i in max {\n                if number >\
    \ i {\n                    max = [number]\n                    break\n       \
    \         } else {\n                    max = append(max, number)\n          \
    \      }\n            }\n        } else {\n            max = number\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp3edv396n.swift:9:16: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns true\n        if max != nil {\n           ~~~\
    \ ^  ~~~\n/tmp/tmp3edv396n.swift:15:27: error: cannot find 'append' in scope\n\
    \                    max = append(max, number)\n                          ^~~~~~\n\
    /tmp/tmp3edv396n.swift:19:19: error: cannot assign value of type 'Int' to type\
    \ '[Int]'\n            max = number\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    // TODO: Make it tail recursive\n    return rolling_max1(numbers,\
    \ 0, numbers.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpyw0luup6.swift:8:12: error: cannot find 'rolling_max1' in scope\n\
    \    return rolling_max1(numbers, 0, numbers.count)\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for i in numbers\
    \ {\n        if i > max {\n            result = append(result, max)\n        }\n\
    \        max = i\n    }\n    result = append(result, max)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpgaztbec6.swift:11:22: error: cannot find 'append' in scope\n  \
    \          result = append(result, max)\n                     ^~~~~~\n/tmp/tmpgaztbec6.swift:15:14:\
    \ error: cannot find 'append' in scope\n    result = append(result, max)\n   \
    \          ^~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for num in numbers {\n       \
    \ max = max + (num).max()\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpdcw3ti8i.swift:9:22: error: static member 'max' cannot be used\
    \ on instance of type 'Int'\n        max = max + (num).max()\n               \
    \     ~^~~~\n                    Int\n/tmp/tmpdcw3ti8i.swift:9:27: error: cannot\
    \ call value of non-function type 'Int'\n        max = max + (num).max()\n   \
    \                       ^  ~~\n                             \n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var array = [Int]()\n    var i = -1\n    for n in numbers\
    \ {\n        if i < 0 {\n            i = n\n            continue\n        }\n\
    \        if n > i {\n            array.append(i)\n            i = n\n        }\n\
    \    }\n    array.append(i)\n    return array\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpsn3dqcml/tmpsn3dqcml.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9b6f502c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9b6f1f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9b6f1f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9b6f1f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsn3dqcml                        0x00005621f2c7f596 <unavailable> + 5526

    5    libc.so.6                          0x00002b9b6f6ee460 __libc_start_main +
    245

    6    tmpsn3dqcml                        0x00005621f2c7f1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    // Return the last element in the array\n    let last\
    \ = numbers.last!\n    let length = numbers.count\n\n    // Initialize an array\
    \ of max elements\n    var max = numbers.map { $0 }\n\n    // Initialize an array\
    \ of number of max elements\n    var max_num = numbers.map { $0 }\n\n    // Initialize\
    \ an array of index\n    var idx = [Int](repeating: 0, count: length)\n\n    for\
    \ index in 0..<length - 1 {\n        // Find max element in the array\n      \
    \  let max_element = max(idx, numbers.index(after: index))\n\n        // Update\
    \ max elements\n        max[max_element] = numbers[max_element]\n\n        //\
    \ Update max number\n        max_num[max_element] = numbers[max_element]\n\n \
    \       // Update index\n        idx[max_element] = index + max_element\n    }\n\
    \n    // Return the max numbers in the array\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpic6qmlnp.swift:22:27: error: cannot call value of non-function\
    \ type '[Int]'\n        let max_element = max(idx, numbers.index(after: index))\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current = Int()\n    numbers.forEach({\
    \ number in\n        current = max(current, number)\n        result.append(current)\n\
    \    })\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp6t_gzvmc.swift:7:33: error: extra argument in call\n    return\
    \ rolling_max(numbers, 1)\n                      ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let result = Array(repeating: -Int.max, count: numbers.count)\n\
    \    numbers.indices.forEach {\n        result[$0] = max(result[$0], numbers[$0])\n\
    \    }\n    result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmphw4ae47k.swift:9:15: error: cannot assign through subscript: 'result'\
    \ is a 'let' constant\n        result[$0] = max(result[$0], numbers[$0])\n   \
    \     ~~~~~~^\n/tmp/tmphw4ae47k.swift:7:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let result = Array(repeating: -Int.max, count: numbers.count)\n\
    \    ^~~\n    var\n/tmp/tmphw4ae47k.swift:11:5: warning: expression of type '[Int]'\
    \ is unused\n    result\n    ^~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxElement = numbers[0]\n    var currentMaxElement\
    \ = maxElement\n    var index = 1\n    while currentMaxElement == maxElement {\n\
    \        if numbers[index] > maxElement {\n            maxElement = numbers[index]\n\
    \        }\n        index++\n    }\n    var rollingMax = [Int]()\n    rollingMax.append(maxElement)\n\
    \    index = 1\n    while index < numbers.count {\n        if numbers[index] >\
    \ maxElement {\n            rollingMax.append(maxElement)\n            index++\n\
    \        } else {\n            if numbers[index] == maxElement {\n           \
    \     currentMaxElement = numbers[index]\n                index++\n          \
    \  } else {\n                rollingMax.append(numbers[index])\n            }\n\
    \        }\n    }\n    return rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpzalx43ri.swift:14:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n/tmp/tmpzalx43ri.swift:22:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  index++\n                 ^~\n/tmp/tmpzalx43ri.swift:26:22: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                index++\n    \
    \                 ^~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  var result = [0]\n  for n in numbers {\n    result.append(result[n-1]\
    \ > n ? result[n-1] : n)\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmp2xu_9obf/tmp2xu_9obf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af7bcac8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7bc7bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7bc7bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7bc7be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2xu_9obf                        0x0000563d16bd8596 <unavailable> + 5526

    5    libc.so.6                          0x00002af7bccb4460 __libc_start_main +
    245

    6    tmp2xu_9obf                        0x0000563d16bd81e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var index = 0\n    for value in\
    \ numbers {\n        if max != nil {\n            if max[index] < value {\n  \
    \              max[index] = value\n            }\n        }\n        index +=\
    \ 1\n        if index >= number.count {\n            break\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpoy0ew2db.swift:10:16: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns true\n        if max != nil {\n       \
    \    ~~~ ^  ~~~\n/tmp/tmpoy0ew2db.swift:16:21: error: cannot find 'number' in\
    \ scope\n        if index >= number.count {\n                    ^~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = Array(repeating: -1, count: numbers.count)\n\
    \    numbers.forEach { number in\n        if number > rolling_max[numbers.index(of:\
    \ number)] {\n            rolling_max[numbers.index(of: number)] = number\n  \
    \      }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpq8psdg5n.swift:9:41: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n        if number > rolling_max[numbers.index(of: number)] {\n\
    \                                        ^\n/tmp/tmpq8psdg5n.swift:9:41: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        if number > rolling_max[numbers.index(of: number)] {\n              \
    \                          ^\n                                               \
    \           ?? <#default value#>\n/tmp/tmpq8psdg5n.swift:9:41: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ number > rolling_max[numbers.index(of: number)] {\n                        \
    \                ^\n                                                         !\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    numbers.withUnsafeBufferPointer() { numberBufferPointer\
    \ in\n        let count = numberBufferPointer.count\n        let maxIndex = count\
    \ - 1\n        var maxElement = numberBufferPointer.baseAddress!.advanced(by:\
    \ Int(maxIndex)).pointee\n        for number in numberBufferPointer {\n      \
    \      if number > maxElement {\n                maxElement = number\n       \
    \     }\n        }\n        return Array(maxElement.successor()..<maxElement)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpg9_4izh8.swift:16:33: error: value of type 'Int' has no member\
    \ 'successor'\n        return Array(maxElement.successor()..<maxElement)\n   \
    \                  ~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpf6fn3vsa.swift:7:33: error: extra argument in call\n    return\
    \ rolling_max(numbers, 0)\n                      ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n    var\
    \ max = numbers[0]\n    var max = numbers[0]\n    var min = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        if number < min {\n            min = number\n        }\n  \
    \  }\n    var result = [Int]()\n    var index = numbers.startIndex\n    var index\
    \ = numbers.startIndex\n    let number = numbers[index]\n    let limit = numbers.endIndex\n\
    \    while number != limit && index < numbers.endIndex {\n        result.append(number)\n\
    \        number = numbers[index + 1]\n        index++\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpiglohecx.swift:11:9: error: invalid redeclaration of 'max'\n  \
    \  var max = numbers[0]\n        ^\n/tmp/tmpiglohecx.swift:10:9: note: 'max' previously\
    \ declared here\n    var max = numbers[0]\n        ^\n/tmp/tmpiglohecx.swift:23:9:\
    \ error: invalid redeclaration of 'index'\n    var index = numbers.startIndex\n\
    \        ^\n/tmp/tmpiglohecx.swift:22:9: note: 'index' previously declared here\n\
    \    var index = numbers.startIndex\n        ^\n/tmp/tmpiglohecx.swift:29:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return numbers\n    }\n\
    \n    let window = numbers[numbers.count - 1]\n\n    let indexes: [Int] = numbers.enumerated().map({\
    \ (index, number) -> Int in\n        if index == 0 {\n            return number\n\
    \        }\n\n        let number = numbers[index - 1]\n\n        if number > window\
    \ {\n            return index\n        } else {\n            return index - 1\n\
    \        }\n    })\n\n    var maxes = [Int]()\n\n    while !indexes.isEmpty, indexes.count\
    \ < numbers.count {\n        let index = indexes[indexes.count - 1]\n\n      \
    \  let number = numbers[index]\n        let previous = numbers[index - 1]\n\n\
    \        if number > previous {\n            maxes.append(number)\n          \
    \  indexes.append(index)\n        } else {\n            indexes.append(index)\n\
    \        }\n    }\n\n    return maxes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmppn4g1i23.swift:37:21: error: cannot use mutating member on immutable\
    \ value: 'indexes' is a 'let' constant\n            indexes.append(index)\n  \
    \          ~~~~~~~ ^\n/tmp/tmppn4g1i23.swift:13:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let indexes: [Int] = numbers.enumerated().map({ (index,\
    \ number) -> Int in\n    ^~~\n    var\n/tmp/tmppn4g1i23.swift:39:21: error: cannot\
    \ use mutating member on immutable value: 'indexes' is a 'let' constant\n    \
    \        indexes.append(index)\n            ~~~~~~~ ^\n/tmp/tmppn4g1i23.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let indexes: [Int] = numbers.enumerated().map({\
    \ (index, number) -> Int in\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.sorted(by: >).reduce(into: []) { (result,\
    \ element) in\n        if result.last == nil || result.last! < element {\n   \
    \         result += [element]\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpymsxdonz/tmpymsxdonz.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b970dba2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b970d899b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b970d899988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b970d8987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpymsxdonz                        0x000055986bb3972d <unavailable> + 5933

    5    libc.so.6                          0x00002b970dd8e460 __libc_start_main +
    245

    6    tmpymsxdonz                        0x000055986bb39249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n\tvar rolling_max_elements = [Int]()\n\trolling_max_elements.append(numbers[0])\n\
    \t\n\tfor var i = 1 ; i < numbers.count ; i++ {\n\t\tif rolling_max_elements.last\
    \ < numbers[i]  {\n\t\t\trolling_max_elements.append(numbers[i])\n\t\t}\n\t}\n\
    \t\n\treturn rolling_max_elements\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpqjrerr63.swift:10:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for var i = 1 ; i < numbers.count ; i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n\tvar maximum = numbers[0]\n\tfor _, number in numbers.enumerated()\
    \ {\n\t\tif number > maximum {\n\t\t\tmaximum = number\n\t\t}\n\t}\n\treturn numbers.enumerated().map({\
    \ $0.0 == 0 ? $0.1 : $0.0 }).joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpzxv7kj06.swift:8:7: error: expected 'in' after for-each pattern\n\
    \        for _, number in numbers.enumerated() {\n             ^\n/tmp/tmpzxv7kj06.swift:8:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, number\
    \ in numbers.enumerated() {\n             ^\n/tmp/tmpzxv7kj06.swift:13:46: error:\
    \ cannot convert value of type 'Int' to closure result type 'String'\n       \
    \ return numbers.enumerated().map({ $0.0 == 0 ? $0.1 : $0.0 }).joined()\n    \
    \                                      ~~~~~~~~~~^~~~~~~~~~~~~\n/tmp/tmpzxv7kj06.swift:13:63:\
    \ error: cannot convert return expression of type 'String' to return type '[Int]'\n\
    \        return numbers.enumerated().map({ $0.0 == 0 ? $0.1 : $0.0 }).joined()\n\
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers.first!\n    return numbers.enumerated().map\
    \ { i, _ in\n        let current_max = numbers[i]\n        max_so_far = max(current_max,\
    \ max_so_far)\n        return max_so_far\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmptcvida4q/tmptcvida4q.swift:7: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b48bb78fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48bb486561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48bb486286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48bb48613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48bb485bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmptcvida4q                        0x000055a32b5abbfc <unavailable> + 7164

    6    tmptcvida4q                        0x000055a32b5ab65d <unavailable> + 5725

    7    libc.so.6                          0x00002b48bb97b460 __libc_start_main +
    245

    8    tmptcvida4q                        0x000055a32b5ab369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n\tvar maximum = 0\n\tvar rolling_max = [Int]()\n\tfor number\
    \ in numbers {\n\t\tmaximum = maximum < number ? maximum : number\n\t\tif maximum\
    \ < number {\n\t\t\trolling_max = append(rolling_max, number)\n\t\t}\n\t}\n\t\
    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpviqwnwcd.swift:12:18: error: cannot find 'append' in scope\n  \
    \                      rolling_max = append(rolling_max, number)\n           \
    \                           ^~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling = [0]\n    for number in numbers {\n    \
    \    if number == rolling[0] {\n            continue\n        }\n        rolling[0]\
    \ += number\n    }\n    return rolling\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpa_dckjsj/tmpa_dckjsj.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9184f19c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9184c10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9184c10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9184c0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa_dckjsj                        0x000055a64dcab596 <unavailable> + 5526

    5    libc.so.6                          0x00002b9185105460 __libc_start_main +
    245

    6    tmpa_dckjsj                        0x000055a64dcab1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_rolling = numbers[0]\n    var max_so_far = numbers[0]\n\
    \    for i in 1 ..< numbers.count {\n        if numbers[i] > max_so_far {\n  \
    \          max_rolling = max_so_far\n            max_so_far = numbers[i]\n   \
    \     } else if numbers[i] > max_rolling {\n            max_rolling = numbers[i]\n\
    \        }\n    }\n    return max_rolling\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpm91ddl2k.swift:17:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return max_rolling\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = -9999999999\n    var rolling_max = -9999999999\n\
    \    for n in numbers {\n        if n >= max {\n            max = n\n        }\
    \ else {\n            rolling_max = n\n        }\n    }\n    return rolling_max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmptri1ddun.swift:16:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max: Int? = nil\n    var rollingMax: [Int] = []\n\
    \    var i: Int = 0\n    for n in numbers {\n        if n == max {\n         \
    \   rollingMax.append(n)\n        }\n        else {\n            if let m = max\
    \ {\n                if rollingMax.contains(m) {\n                    continue\n\
    \                }\n            }\n            rollingMax.append(n)\n        \
    \    max = n\n        }\n        i += 1\n    }\n    return rollingMax\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpf4mfvu7g/tmpf4mfvu7g.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b800c46bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b800c162b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b800c162988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b800c1617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf4mfvu7g                        0x00005639e44066dd <unavailable> + 5853

    5    libc.so.6                          0x00002b800c657460 __libc_start_main +
    245

    6    tmpf4mfvu7g                        0x00005639e44061f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    for number in numbers {\n   \
    \     max_so_far = max(number, max_so_far)\n    }\n    return Array(0..<numbers.count).map\
    \ { i in\n        return max_so_far\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpmgs1mfbd/tmpmgs1mfbd.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9489731c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9489428b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9489428988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94894277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmgs1mfbd                        0x000055a2145cb93d <unavailable> + 6461

    5    libc.so.6                          0x00002b948991d460 __libc_start_main +
    245

    6    tmpmgs1mfbd                        0x000055a2145cb459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, 1, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp0dii7xxl.swift:7:23: error: extra arguments at positions #2, #3\
    \ in call\n    return rolling_max(numbers, 1, 0)\n                      ^\n/tmp/tmp0dii7xxl.swift:6:6:\
    \ note: 'rolling_max(numbers:)' declared here\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n     ^\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let (min, max) = numbers.minMax()\n    var maxIndex =\
    \ 0\n\n    for number in numbers {\n        if number > max {\n            maxIndex\
    \ = numbers.indexOf(max)\n        }\n\n        if number < min {\n           \
    \ continue\n        }\n\n        if number == max {\n            maxIndex += 1\n\
    \        }\n\n        if number == min {\n            maxIndex -= 1\n        }\n\
    \n        let index = numbers.indexOf(number, maxIndex)\n\n        if index ==\
    \ 0 {\n            numbers[index] = number\n        }\n    }\n\n    return numbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpskbufjhi.swift:7:30: error: value of type '[Int]' has no member\
    \ 'minMax'\n    let (min, max) = numbers.minMax()\n                     ~~~~~~~\
    \ ^~~~~~\n/tmp/tmpskbufjhi.swift:12:32: error: value of type '[Int]' has no member\
    \ 'indexOf'\n            maxIndex = numbers.indexOf(max)\n                   \
    \    ~~~~~~~ ^~~~~~~\n/tmp/tmpskbufjhi.swift:27:29: error: value of type '[Int]'\
    \ has no member 'indexOf'\n        let index = numbers.indexOf(number, maxIndex)\n\
    \                    ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxIndex = 0\n    var max = 0\n    var maxValue =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] >= maxValue\
    \ {\n            maxValue = numbers[i]\n            maxIndex = i\n        }\n\
    \    }\n    let rollingMax = [Int](repeating: numbers[maxIndex], count: numbers.count\
    \ - maxIndex + 1)\n    return rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a3cb70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a3c867561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7a3c867286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7a3c86713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7a3c866bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7a3c666e83 <unavailable> + 188035

    6    tmpnv6a7u9o                        0x000055e1115cbab8 <unavailable> + 6840

    7    tmpnv6a7u9o                        0x000055e1115cb55d <unavailable> + 5469

    8    libc.so.6                          0x00002b7a3cd5c460 __libc_start_main +
    245

    9    tmpnv6a7u9o                        0x000055e1115cb269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var max_indexes: [Int] = []\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n            max_indexes = [i]\n        } else if numbers[i]\
    \ == max {\n            max_indexes.append(i)\n        }\n    }\n    return max_indexes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b591c001c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b591bcf8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b591bcf8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b591bcf813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b591bcf7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b591baf7e83 <unavailable> + 188035

    6    tmpoo1qsl_k                        0x0000557dd4813a78 <unavailable> + 6776

    7    tmpoo1qsl_k                        0x0000557dd481354d <unavailable> + 5453

    8    libc.so.6                          0x00002b591c1ed460 __libc_start_main +
    245

    9    tmpoo1qsl_k                        0x0000557dd4813259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIdx = 0\n    for idx\
    \ in 1...numbers.count {\n        if numbers[idx] > max {\n            max = numbers[idx]\n\
    \            maxIdx = idx\n        }\n    }\n    numbers[maxIdx] = max\n    return\
    \ numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp1axw4w_k.swift:15:12: error: cannot assign through subscript: 'numbers'\
    \ is a 'let' constant\n    numbers[maxIdx] = max\n    ~~~~~~~^\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    // Scan array from left until reach the maximum element,\
    \ then the maximum element is the right\n    // element to the left. So we scan\
    \ array from right to left to find the maximum element in O(n)\n    return scan(numbers,\
    \ 0, numbers.count - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpley_h30o.swift:9:12: error: cannot find 'scan' in scope\n    return\
    \ scan(numbers, 0, numbers.count - 1)\n           ^~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpf6fn3vsa.swift:7:33: error: extra argument in call\n    return\
    \ rolling_max(numbers, 0)\n                      ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659980047
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var index = 0\n    var max = 0\n    var rollingMax =\
    \ [Int]()\n\n    while index < numbers.count {\n        max = numbers[index]\n\
    \        if max < rollingMax.last {\n            rollingMax.append(max)\n    \
    \    } else {\n            if rollingMax.last < max {\n                rollingMax.insert(max,\
    \ at: 0)\n            }\n        }\n        index += 1\n    }\n    return rollingMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp0oew01vi.swift:13:29: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if max < rollingMax.last {\n\
    \                            ^\n/tmp/tmp0oew01vi.swift:13:29: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        if\
    \ max < rollingMax.last {\n                            ^\n                   \
    \              ?? <#default value#>\n/tmp/tmp0oew01vi.swift:13:29: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ max < rollingMax.last {\n                            ^\n                   \
    \             !\n/tmp/tmp0oew01vi.swift:16:27: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n            if rollingMax.last <\
    \ max {\n                          ^\n/tmp/tmp0oew01vi.swift:16:27: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \         if rollingMax.last < max {\n                          ^\n          \
    \                     ?? <#default value#>\n/tmp/tmp0oew01vi.swift:16:27: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \            if rollingMax.last < max {\n                          ^\n       \
    \                       !\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n\n  \
    \  var maxValue = numbers[0]\n    var rollingMaxNumber = numbers[0]\n    for number\
    \ in numbers {\n        if number > rollingMaxNumber {\n            rollingMaxNumber\
    \ = number\n        }\n\n        if number > maxValue {\n            maxValue\
    \ = number\n        }\n    }\n\n    return Array(maxValue .. rollingMaxNumber)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp10gl39mi.swift:23:27: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    return Array(maxValue .. rollingMaxNumber)\n      \
    \                    ^~\n                          ...\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers.max()!\n    var rolling_max = [Int](repeating:\
    \ 0, count: numbers.count)\n    for number in numbers {\n        if number > max\
    \ {\n            max = number\n        }\n        rolling_max[numbers.index(number)]\
    \ = max\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp4zwibulk.swift:13:29: error: no exact matches in call to instance\
    \ method 'index'\n        rolling_max[numbers.index(number)] = max\n         \
    \                   ^\nSwift.Array:7:28: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(after:)')\n    @inlinable public func index(after\
    \ i: Int) -> Int\n                           ^\nSwift.Array:9:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public\
    \ func index(before i: Int) -> Int\n                           ^\nSwift.RandomAccessCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(after:)')\n\
    \    @inlinable public func index(after i: Self.Index) -> Self.Index\n       \
    \                    ^\nSwift.RandomAccessCollection:4:28: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public func\
    \ index(before i: Self.Index) -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var min = [Int]()\n    var cur\
    \ = 0\n\n    for v in numbers {\n        max = [v] + max\n        min = [v] +\
    \ min\n    }\n    max = max.sorted()\n    min = min.sorted()\n    for idx in 0..<(max.count)\
    \ {\n        cur = max[idx] + min[idx]\n        if cur >= numbers[idx] {\n   \
    \         max[idx] = cur\n        } else {\n            min[idx] = cur\n     \
    \   }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp5wxzmpkv/tmp5wxzmpkv.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7028039c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7027d30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7027d30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7027d2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5wxzmpkv                        0x000055e6aff599fd <unavailable> + 6653

    5    libc.so.6                          0x00002b7028225460 __libc_start_main +
    245

    6    tmp5wxzmpkv                        0x000055e6aff59519 <unavailable> + 5401

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n\n  \
    \  var max: Int?\n    var maxIndex: Int?\n\n    for index in stride(from: 0, to:\
    \ numbers.count, by: 1) {\n        if max != nil && numbers[index] > max! {\n\
    \            maxIndex = index\n        }\n        if max != nil && numbers[index]\
    \ == max! {\n            if maxIndex != nil {\n                return [max!, numbers[maxIndex!]]\n\
    \            } else {\n                return [max!]\n            }\n        }\
    \ else {\n            max = numbers[index]\n            maxIndex = index\n   \
    \     }\n    }\n\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpn_3gp269/tmpn_3gp269.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b94151dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9414ed5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9414ed5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9414ed47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn_3gp269                        0x000055898fda388d <unavailable> + 6285

    5    libc.so.6                          0x00002b94153ca460 __libc_start_main +
    245

    6    tmpn_3gp269                        0x000055898fda33a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  var rollingMax = numbers[0]\n  for number in numbers {\n\
    \    if number > rollingMax {\n      rollingMax = number\n    }\n  }\n  return\
    \ rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpagt3_4d8.swift:13:10: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n  return rollingMax\n         ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maximum = numbers.minElement()!\n    var output =\
    \ [Int]()\n    for i in 0..<numbers.count {\n        if numbers[i] >= maximum\
    \ {\n            output.append(numbers[i])\n        }\n        else {\n      \
    \      output.append(maximum)\n        }\n        maximum = max(numbers[i], maximum)\n\
    \    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpxl_eqc6h.swift:7:27: error: value of type '[Int]' has no member\
    \ 'minElement'\n    var maximum = numbers.minElement()!\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var max_rolling = [Int](repeating:\
    \ 0, count: numbers.count)\n    var current_rolling = max_rolling\n    for (index,\
    \ number) in numbers.enumerated() {\n        current_rolling[index] = max\n  \
    \      if max < number {\n            max = number\n        }\n    }\n    return\
    \ max_rolling\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9519ee1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9519bd8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9519bd8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9519bd813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9519bd7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b95199d7e83 <unavailable> + 188035

    6    tmpmt_h39p4                        0x000055683dff3b8b <unavailable> + 7051

    7    tmpmt_h39p4                        0x000055683dff363d <unavailable> + 5693

    8    libc.so.6                          0x00002b951a0cd460 __libc_start_main +
    245

    9    tmpmt_h39p4                        0x000055683dff3349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max: [Int] = []\n    var max_count = 0\n\
    \    for n in numbers {\n        if rolling_max[rolling_max.count-1] == n {\n\
    \            max_count += 1\n        } else {\n            rolling_max[rolling_max.count-1]\
    \ = n\n            max_count = 1\n        }\n        if max_count > numbers.count\
    \ {\n            break\n        }\n    }\n    return rolling_max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5e57c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5e54bc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba5e54bc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba5e54bc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba5e54bbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba5e52bbe83 <unavailable> + 188035

    6    tmpbonvbucs                        0x000055ad88a56b76 <unavailable> + 7030

    7    tmpbonvbucs                        0x000055ad88a56635 <unavailable> + 5685

    8    libc.so.6                          0x00002ba5e59b1460 __libc_start_main +
    245

    9    tmpbonvbucs                        0x000055ad88a56239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return numbers\n    }\n\
    \    var maxValue = numbers.max()!\n    var maxIndex: Int? = numbers.firstIndex(of:\
    \ maxValue)\n    for i in 1...numbers.count {\n        if numbers[i-1] != maxValue\
    \ {\n            maxValue = numbers[i-1]\n            maxIndex = i\n        }\n\
    \    }\n    return maxIndex == nil ? numbers : numbers[maxIndex!...numbers.endIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpz42iw_ux.swift:18:28: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return maxIndex == nil ?\
    \ numbers : numbers[maxIndex!...numbers.endIndex]\n           ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_val: Int = 0\n    var max_val_index = 0\n   \
    \ var result = [Int]()\n\n    for number in numbers {\n        if number > max_val\
    \ {\n            max_val = number\n            max_val_index = result.count\n\
    \            result[max_val_index] = number\n        }\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aaeae75dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaeae454561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aaeae454286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aaeae45413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aaeae453bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aaeae2537ec <unavailable> + 186348

    6    tmpu3o3iljj                        0x000056260e3a1b87 <unavailable> + 7047

    7    tmpu3o3iljj                        0x000056260e3a1635 <unavailable> + 5685

    8    libc.so.6                          0x00002aaeae949460 __libc_start_main +
    245

    9    tmpu3o3iljj                        0x000056260e3a1239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in 0..<numbers.count\
    \ {\n        if numbers.count <= i {\n            break\n        }\n        result.append(numbers.last!)\n\
    \        numbers.removeLast()\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpnqop0blz.swift:13:17: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n        numbers.removeLast()\n       \
    \ ~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n\tvar result = [Int]()\n\tvar maxIndex = 0\n\tvar maxValue\
    \ = numbers[0]\n\tnumbers.forEach { value in\n\t\tif value > maxValue {\n\t\t\t\
    maxIndex = result\n\t\t\tmaxValue = value\n\t\t} else {\n\t\t\tresult.insert(maxIndex,\
    \ value)\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpssmegtu8.swift:12:15: error: cannot assign value of type '[Int]'\
    \ to type 'Int'\n                        maxIndex = result\n                 \
    \                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = numbers\n    for rollingMax := 0; rollingMax\
    \ < numbers.count; rollingMax++ {\n        var max = numbers[rollingMax]\n   \
    \     for currentIndex := rollingMax + 1; currentIndex < numbers.count; currentIndex++\
    \ {\n            if numbers[currentIndex] > max {\n                max = numbers[currentIndex]\n\
    \            }\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpypsb0tz_.swift:8:21: error: expected type\n    for rollingMax :=\
    \ 0; rollingMax < numbers.count; rollingMax++ {\n                    ^\n     \
    \                <#type#>\n/tmp/tmpypsb0tz_.swift:8:21: error: expected 'in' after\
    \ for-each pattern\n    for rollingMax := 0; rollingMax < numbers.count; rollingMax++\
    \ {\n                    ^\n/tmp/tmpypsb0tz_.swift:8:21: error: expected Sequence\
    \ expression for for-each loop\n    for rollingMax := 0; rollingMax < numbers.count;\
    \ rollingMax++ {\n                    ^\n/tmp/tmpypsb0tz_.swift:10:27: error:\
    \ expected type\n        for currentIndex := rollingMax + 1; currentIndex < numbers.count;\
    \ currentIndex++ {\n                          ^\n                           <#type#>\n\
    /tmp/tmpypsb0tz_.swift:10:27: error: expected 'in' after for-each pattern\n  \
    \      for currentIndex := rollingMax + 1; currentIndex < numbers.count; currentIndex++\
    \ {\n                          ^\n/tmp/tmpypsb0tz_.swift:10:27: error: expected\
    \ Sequence expression for for-each loop\n        for currentIndex := rollingMax\
    \ + 1; currentIndex < numbers.count; currentIndex++ {\n                      \
    \    ^\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    var maxNumber = numbers[0]\n\
    \    for number in numbers {\n        if number > maxNumber {\n            result.append(number)\n\
    \        } else {\n            maxNumber = number\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad77aaa2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad77a799561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad77a799286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad77a79913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad77a798bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad77a598e83 <unavailable> + 188035

    6    tmpydetespa                        0x00005598f7f5ba1a <unavailable> + 6682

    7    tmpydetespa                        0x00005598f7f5b4dd <unavailable> + 5341

    8    libc.so.6                          0x00002ad77ac8e460 __libc_start_main +
    245

    9    tmpydetespa                        0x00005598f7f5b1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var indexes = [Int]()\n   \
    \ for i in 1..<numbers.count {\n        if numbers[i] > max {\n            max\
    \ = numbers[i]\n            indexes.removeAll()\n            indexes.append(i)\n\
    \        }\n    }\n    return maxElements(numbers, indexes)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp36i93a_j.swift:16:12: error: cannot find 'maxElements' in scope\n\
    \    return maxElements(numbers, indexes)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  var result: [Int] = []\n  var min: Int? = nil\n  var max:\
    \ Int? = nil\n  for n in numbers {\n    if min == nil || n < min {\n      min\
    \ = n\n    }\n    if max == nil || n > max {\n      max = n\n    }\n  }\n  for\
    \ n in numbers {\n    if n <= max {\n      result.insert(n, at: 0)\n    }\n  }\n\
    \  if min != nil && max != nil {\n    result.insert(min, at: 0)\n    result.insert(max,\
    \ at: 0)\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpooqhn19q.swift:11:26: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    if min == nil || n < min {\n    \
    \                     ^\n/tmp/tmpooqhn19q.swift:11:26: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    if min == nil\
    \ || n < min {\n                         ^\n                             ?? <#default\
    \ value#>\n/tmp/tmpooqhn19q.swift:11:26: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    if min == nil || n < min\
    \ {\n                         ^\n                            !\n/tmp/tmpooqhn19q.swift:14:26:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    if max == nil || n > max {\n                         ^\n/tmp/tmpooqhn19q.swift:14:26:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    if max == nil || n > max {\n                         ^\n        \
    \                     ?? <#default value#>\n/tmp/tmpooqhn19q.swift:14:26: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    if max == nil || n > max {\n                         ^\n                \
    \            !\n/tmp/tmpooqhn19q.swift:19:13: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n    if n <= max {\n            ^\n\
    /tmp/tmpooqhn19q.swift:19:13: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    if n <= max {\n            ^\n      \
    \          ?? <#default value#>\n/tmp/tmpooqhn19q.swift:19:13: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    if n\
    \ <= max {\n            ^\n               !\n/tmp/tmpooqhn19q.swift:24:19: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \   result.insert(min, at: 0)\n                  ^\n/tmp/tmpooqhn19q.swift:24:19:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    result.insert(min, at: 0)\n                  ^\n                \
    \      ?? <#default value#"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max_helper(numbers)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp0rt0y5y9.swift:7:12: error: cannot find 'rolling_max_helper' in\
    \ scope\n    return rolling_max_helper(numbers)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rollingMax = [Int]()\n    \n    for i in 0 ..< numbers.count\
    \ {\n        if rollingMax.contains(numbers[i]) {\n            continue\n    \
    \    } else {\n            rollingMax.append(numbers[i])\n        }\n    }\n \
    \   \n    return rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpk795jzqa/tmpk795jzqa.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba668ba4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba66889bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba66889b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba66889a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk795jzqa                        0x0000556e1c333946 <unavailable> + 6470

    5    libc.so.6                          0x00002ba668d90460 __libc_start_main +
    245

    6    tmpk795jzqa                        0x0000556e1c333319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maximum = numbers[0]\n    var rollingMax = [Int]()\n\
    \n    for i in 1..<numbers.count {\n        if numbers[i-1] > maximum {\n    \
    \        rollingMax.append(maximum)\n        } else {\n            rollingMax.append(numbers[i])\n\
    \        }\n\n        maximum = numbers[i]\n    }\n\n    return rollingMax\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb2f33ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb2f035561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb2f035286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb2f03513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb2f034bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb2ee34e83 <unavailable> + 188035

    6    tmpqhum45ip                        0x0000564991360ad8 <unavailable> + 6872

    7    tmpqhum45ip                        0x00005649913605ad <unavailable> + 5549

    8    libc.so.6                          0x00002aeb2f52a460 __libc_start_main +
    245

    9    tmpqhum45ip                        0x00005649913602b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var max_to_add = numbers[0]\n\
    \    for n in numbers {\n        if max_so_far < n {\n            max_so_far =\
    \ n\n        }\n        if n > max_to_add {\n            max_to_add = n\n    \
    \    }\n    }\n    return [max_so_far, max_to_add]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d1a00dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d19d04561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6d19d04286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6d19d0413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6d19d03bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6d19b03e83 <unavailable> + 188035

    6    tmpp93_4k1g                        0x00005583013ab9a2 <unavailable> + 6562

    7    tmpp93_4k1g                        0x00005583013ab47d <unavailable> + 5245

    8    libc.so.6                          0x00002b6d1a1f9460 __libc_start_main +
    245

    9    tmpp93_4k1g                        0x00005583013ab189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    \n    var maximum: Int?\n    for number in numbers {\n\
    \        \n        guard number > 0 else {\n            return numbers\n     \
    \   }\n        \n        let maximumIndex = numbers.firstIndex(of: number) + numbers.firstIndex(of:\
    \ maximum!)\n        \n        maximum = numbers[maximumIndex]\n        \n   \
    \ }\n    \n    return numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7gpj0whl.swift:15:59: error: binary operator '+' cannot be applied\
    \ to two 'Array<Int>.Index?' (aka 'Optional<Int>') operands\n        let maximumIndex\
    \ = numbers.firstIndex(of: number) + numbers.firstIndex(of: maximum!)\n      \
    \                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7gpj0whl.swift:15:59: note: overloads for '+' exist with these partially\
    \ matching parameter lists: (Int, Int)\n        let maximumIndex = numbers.firstIndex(of:\
    \ number) + numbers.firstIndex(of: maximum!)\n                               \
    \                           ^\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_element = 0\n    var max_rolling_max_element\
    \ = max_element\n\n    for num in numbers {\n        if num > max_element {\n\
    \            max_element = num\n        } else {\n            max_element = max(max_element,\
    \ num)\n        }\n\n        if max_rolling_max_element < max_element {\n    \
    \        max_rolling_max_element = max_element\n        }\n    }\n    return Array(repeating:\
    \ max_rolling_max_element, count: numbers.count)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmplkni3s_g/tmplkni3s_g.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b502e3d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b502e0d0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b502e0d0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b502e0cf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplkni3s_g                        0x0000564268bcd76d <unavailable> + 5997

    5    libc.so.6                          0x00002b502e5c5460 __libc_start_main +
    245

    6    tmplkni3s_g                        0x0000564268bcd289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var largest = 0\n    var largestIndex = 0\n    for index\
    \ in 0..<numbers.count {\n        if numbers[index] > largest {\n            largest\
    \ = numbers[index]\n            largestIndex = index\n        }\n    }\n\n   \
    \ var largests = [Int]()\n    for i in 0..<numbers.count {\n        if numbers[i]\
    \ == largest {\n            largests += [largest]\n        }\n    }\n    return\
    \ largests\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpgdq8_jvd/tmpgdq8_jvd.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b41e6d4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41e6a46b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b41e6a46988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41e6a457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgdq8_jvd                        0x00005595f676879d <unavailable> + 6045

    5    libc.so.6                          0x00002b41e6f3b460 __libc_start_main +
    245

    6    tmpgdq8_jvd                        0x00005595f67682b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    var rollingMax = [Int]()\n   \
    \ var maxIndex = 0\n    var sum = 0\n    for i in 0..<numbers.count {\n      \
    \  sum += numbers[i]\n        rollingMax.append(0)\n        if sum >= numbers[i]\
    \ {\n            rollingMax[maxIndex] = numbers[i]\n            maxIndex += 1\n\
    \        }\n    }\n    for i in 0..<maxIndex {\n        max = append(max, rollingMax[i])\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpv81uoso0.swift:20:15: error: cannot find 'append' in scope\n  \
    \      max = append(max, rollingMax[i])\n              ^~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n    var\
    \ max_index = numbers.startIndex\n    var max_number = numbers[0]\n    for index\
    \ in numbers[1...] {\n        if max_number < numbers[index] {\n            max_index\
    \ = index\n            max_number = numbers[index]\n        }\n    }\n    var\
    \ result = [Int](repeating: max_number, count: numbers.count - max_index)\n  \
    \  result.append(max_number)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e60852c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e60549561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7e60549286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7e6054913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7e60548bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7e60348e83 <unavailable> + 188035

    6    tmpgf1kxu5v                        0x0000564d96e94f67 <unavailable> + 8039

    7    tmpgf1kxu5v                        0x0000564d96e94935 <unavailable> + 6453

    8    libc.so.6                          0x00002b7e60a3e460 __libc_start_main +
    245

    9    tmpgf1kxu5v                        0x0000564d96e94539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var res = Int()\n    var max = Int()\n    for num in\
    \ numbers {\n        if num > max {\n            max = num\n        }\n    }\n\
    \    for num in numbers {\n        if num > max {\n            res = res\n   \
    \     } else {\n            res = num > res ? num : res\n        }\n    }\n  \
    \  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp19s0wuo4.swift:16:17: error: assigning a variable to itself\n \
    \           res = res\n            ~~~ ^ ~~~\n/tmp/tmp19s0wuo4.swift:21:12: error:\
    \ cannot convert return expression of type 'Int' to return type '[Int]'\n    return\
    \ res\n           ^~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var currentMax = numbers[0]\n\
    \    for number in numbers {\n        if number > currentMax {\n            result.append(currentMax)\n\
    \        }\n        currentMax = number\n    }\n    result.append(currentMax)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acb1208cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb11d83561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acb11d83286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acb11d8313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acb11d82bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acb11b82e83 <unavailable> + 188035

    6    tmpu44nv7_c                        0x000055e3fcb4ca5f <unavailable> + 6751

    7    tmpu44nv7_c                        0x000055e3fcb4c52d <unavailable> + 5421

    8    libc.so.6                          0x00002acb12278460 __libc_start_main +
    245

    9    tmpu44nv7_c                        0x000055e3fcb4c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let length = numbers.count\n    var result = Array(repeating:\
    \ -1, count: length)\n    for idx in 0..<length {\n        let window = numbers[0..<idx]\n\
    \        let currentMax = window.max()!\n        result[idx] = currentMax\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp7d43mvah/tmp7d43mvah.swift:11: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002ab08f974c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab08f66b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab08f66b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab08f66b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab08f66abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp7d43mvah                        0x000055b656d36ee1 <unavailable> + 7905

    6    tmp7d43mvah                        0x000055b656d367f5 <unavailable> + 6133

    7    libc.so.6                          0x00002ab08fb60460 __libc_start_main +
    245

    8    tmp7d43mvah                        0x000055b656d363f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, to: Date())\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp5smt0bvm.swift:7:37: error: cannot find 'Date' in scope\n    return\
    \ rolling_max(numbers, to: Date())\n                                    ^~~~\n\
    /tmp/tmp5smt0bvm.swift:7:37: error: extra argument 'to' in call\n    return rolling_max(numbers,\
    \ to: Date())\n                      ~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_number: Int = numbers.reduce(0, {$0 > $1.0 ?\
    \ $0 : $1})\n    var max_index_to_keep: Int = 0\n    for (_, index) in numbers.enumerated()\
    \ {\n        if index == max_index_to_keep {\n            continue\n        }\n\
    \        max_number = numbers[index]\n        max_index_to_keep = index\n    }\n\
    \    var output = [Int]()\n    for (_, index) in numbers.enumerated() {\n    \
    \    if index == max_index_to_keep {\n            output.append(numbers[index])\n\
    \        } else {\n            output.append(numbers[index])\n        }\n    }\n\
    \    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpuc5xdetp.swift:7:54: error: value of type 'Int' has no member '0'\n\
    \    var max_number: Int = numbers.reduce(0, {$0 > $1.0 ? $0 : $1})\n        \
    \                                          ~~ ^\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var results = [Int]()\n    var rollingMaxValue = numbers[0]\n\
    \    for i in numbers.indices {\n        if numbers[i] > rollingMaxValue {\n \
    \           rollingMaxValue = numbers[i]\n            results.append(numbers[i])\n\
    \        }\n    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab7ab28ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab7aaf81561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab7aaf81286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab7aaf8113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab7aaf80bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab7aad80e83 <unavailable> + 188035

    6    tmpmd9j3p6l                        0x00005598cd8e2a88 <unavailable> + 6792

    7    tmpmd9j3p6l                        0x00005598cd8e254d <unavailable> + 5453

    8    libc.so.6                          0x00002ab7ab476460 __libc_start_main +
    245

    9    tmpmd9j3p6l                        0x00005598cd8e2259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rollingMax = [Int]()\n    for number in numbers {\n\
    \        if rollingMax.count < number {\n            rollingMax.append(number)\n\
    \        } else {\n            if rollingMax[rollingMax.count - 1] < number {\n\
    \                rollingMax[rollingMax.count - 1] = number\n            }\n  \
    \      }\n    }\n    return rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpsly14wjj/tmpsly14wjj.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b195dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b192d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b192d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b192d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsly14wjj                        0x000055e539fef916 <unavailable> + 6422

    5    libc.so.6                          0x00002b6b197c6460 __libc_start_main +
    245

    6    tmpsly14wjj                        0x000055e539fef2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var maxIndex = numbers.startIndex\n\
    \    for i in numbers.indices {\n        if maxIndex - i < max {\n           \
    \ max = numbers[i] - numbers[i-maxIndex]\n            maxIndex = i\n        }\n\
    \    }\n    return numbers[maxIndex..<numbers.endIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpbl8c6jg0.swift:15:19: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return numbers[maxIndex..<numbers.endIndex]\n\
    \           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return window(numbers, 1, 1).reduce(&max).reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpjhwf4z9y.swift:7:12: error: cannot find 'window' in scope\n   \
    \ return window(numbers, 1, 1).reduce(&max).reversed()\n           ^~~~~~\n/tmp/tmpjhwf4z9y.swift:7:42:\
    \ error: generic parameter 'T' could not be inferred\n    return window(numbers,\
    \ 1, 1).reduce(&max).reversed()\n                                         ^\n\
    Swift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_\
    \ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpjhwf4z9y.swift:7:41:\
    \ error: cannot pass immutable value of type '(_, _) -> _' as inout argument\n\
    \    return window(numbers, 1, 1).reduce(&max).reversed()\n                  \
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    for number in numbers\
    \ {\n        if rolling_max[rolling_max.count-1] < number {\n            rolling_max[rolling_max.count-1]\
    \ = number\n        }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b22e069bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22e0392561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b22e0392286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b22e039213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b22e0391bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b22e0191e83 <unavailable> + 188035

    6    tmpqh2i7nl6                        0x00005612409cdb9d <unavailable> + 7069

    7    tmpqh2i7nl6                        0x00005612409cd685 <unavailable> + 5765

    8    libc.so.6                          0x00002b22e0887460 __libc_start_main +
    245

    9    tmpqh2i7nl6                        0x00005612409cd289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > rolling_max {\n            rolling_max = numbers[i]\n\
    \        }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpfqo32ofn.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rollingMax = [Int]()\n    for number in numbers {\n\
    \        rollingMax.append(max(rollingMax.last!, number))\n    }\n    return rollingMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp7u13m2he/tmp7u13m2he.swift:9: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002abc9ead1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc9e7c8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002abc9e7c8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002abc9e7c813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002abc9e7c7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp7u13m2he                        0x00005637c598ad55 <unavailable> + 7509

    6    tmp7u13m2he                        0x00005637c598a7a5 <unavailable> + 6053

    7    libc.so.6                          0x00002abc9ecbd460 __libc_start_main +
    245

    8    tmp7u13m2he                        0x00005637c598a3a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers.slice()\n    for number in numbers\
    \ {\n        if number > max[0] {\n            max = number\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpqmfvndgj.swift:7:23: error: value of type '[Int]' has no member\
    \ 'slice'\n    var max = numbers.slice()\n              ~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = []\n    let count = (numbers.count)\
    \ - 1\n\n    for number in numbers {\n        let index = numbers.index(of: number)!\n\
    \        result.append(numbers[index])\n        if index == 0 {\n            continue\n\
    \        }\n\n        for _ in 0 ..< count {\n            result.append(numbers[index\
    \ - 1])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpu59b7xbu/tmpu59b7xbu.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb66661c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb66358b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb66358988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb663577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu59b7xbu                        0x000055f70198691d <unavailable> + 6429

    5    libc.so.6                          0x00002acb6684d460 __libc_start_main +
    245

    6    tmpu59b7xbu                        0x000055f701986439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let maxIndexes = stride(from: numbers.startIndex, to:\
    \ numbers.endIndex, by: -1).map{ numbers.firstIndex(of: $0) }\n    var maxs =\
    \ [Int]()\n    for i in maxIndexes {\n        if i == numbers.endIndex {\n   \
    \         break\n        }\n        let index = numbers.index(before: i)\n   \
    \     maxs.append(numbers[index])\n    }\n    return maxs\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpc2zd6uld.swift:13:43: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n        let index = numbers.index(before: i)\n                \
    \                          ^\n/tmp/tmpc2zd6uld.swift:13:43: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        let\
    \ index = numbers.index(before: i)\n                                         \
    \ ^\n                                            ?? <#default value#>\n/tmp/tmpc2zd6uld.swift:13:43:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let index = numbers.index(before: i)\n                      \
    \                    ^\n                                           !\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_number = numbers[0]\n    var rolling_max_numbers\
    \ = [Int]()\n    var max_rolling_numbers = [Int]()\n    numbers.forEach { number\
    \ in\n        if number > max_number {\n            rolling_max_numbers.append(max_number)\n\
    \            max_number = number\n        } else {\n            max_number = number\n\
    \        }\n    }\n    rolling_max_numbers.append(max_number)\n    return rolling_max_numbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b95babb6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95ba8ad561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b95ba8ad286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b95ba8ad13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b95ba8acbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b95ba6ace83 <unavailable> + 188035

    6    tmph2t218qm                        0x00005594e4ad9927 <unavailable> + 6439

    7    tmph2t218qm                        0x00005594e4ad942d <unavailable> + 5165

    8    libc.so.6                          0x00002b95bada2460 __libc_start_main +
    245

    9    tmph2t218qm                        0x00005594e4ad9139 <unavailable> + 4409

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n    for i in numbers {\n        if\
    \ i.isGreaterThan(max.last!) {\n            max.append(i)\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpp89b2srz.swift:9:14: error: value of type 'Int' has no member 'isGreaterThan'\n\
    \        if i.isGreaterThan(max.last!) {\n           ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, numbers)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpdlxahzbn.swift:7:33: error: extra argument in call\n    return\
    \ rolling_max(numbers, numbers)\n                      ~~~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    \n    for number in numbers\
    \ {\n        if rolling_max.contains(number) {\n            continue\n       \
    \ } else {\n            rolling_max.append(number)\n        }\n    }\n    \n \
    \   return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpsn7hlhyz/tmpsn7hlhyz.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b482f925c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b482f61cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b482f61c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b482f61b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsn7hlhyz                        0x00005596a379f876 <unavailable> + 6262

    5    libc.so.6                          0x00002b482fb11460 __libc_start_main +
    245

    6    tmpsn7hlhyz                        0x00005596a379f249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max: Int = 0\n    return numbers.map { number in\n\
    \        if number > max {\n            max = number\n        }\n        return\
    \ number\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp5vj0fn4f/tmp5vj0fn4f.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b82e8c47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82e893eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b82e893e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82e893d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5vj0fn4f                        0x0000556a7a9176a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b82e8e33460 __libc_start_main +
    245

    6    tmp5vj0fn4f                        0x0000556a7a917079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let sum = numbers.reduce(0, {\n        (res, value) ->\
    \ Int in\n        guard value > res else {\n            return value\n       \
    \ }\n        return res\n    })\n\n    var maximums = [Int](repeating: -Int.max,\
    \ count: numbers.count)\n    for index, _ in enumerate(numbers) {\n        maximums[index]\
    \ = numbers[index] + sum\n    }\n\n    return maximums.prefix(numbers.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp3v4li4bj.swift:16:14: error: expected 'in' after for-each pattern\n\
    \    for index, _ in enumerate(numbers) {\n             ^\n/tmp/tmp3v4li4bj.swift:16:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, _ in enumerate(numbers)\
    \ {\n             ^\n/tmp/tmp3v4li4bj.swift:20:21: error: no 'prefix' candidates\
    \ produce the expected contextual result type '[Int]'\n    return maximums.prefix(numbers.count)\n\
    \                    ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<[Int]>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<[Int]>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\nSwift.Collection:6:40: note: 'prefix' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int](repeating: 0, count: numbers.count)\n\
    \    var max = max[0]\n    for i in numbers {\n        if max < i {\n        \
    \    max = i\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpa5rjvgpk.swift:8:9: error: invalid redeclaration of 'max'\n   \
    \ var max = max[0]\n        ^\n/tmp/tmpa5rjvgpk.swift:7:9: note: 'max' previously\
    \ declared here\n    var max = [Int](repeating: 0, count: numbers.count)\n   \
    \     ^\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        max = number > max ? number : max\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, 0...numbers.count-1)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpnz8rhu8d.swift:7:34: error: extra argument in call\n    return\
    \ rolling_max(numbers, 0...numbers.count-1)\n                      ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let length = numbers.count\n    var rollingMax: [Int]\
    \ = [Int](repeating: 0, count: length)\n    for i in 0..<numbers.count {\n   \
    \     rollingMax[i] = max(numbers[i], rollingMax[i-1])\n    }\n    return rollingMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b93802aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b937ffa5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b937ffa5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b937ffa513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b937ffa4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b937fda4e83 <unavailable> + 188035

    6    tmpg2g3fp5n                        0x000055f7b9a67cc3 <unavailable> + 7363

    7    tmpg2g3fp5n                        0x000055f7b9a67745 <unavailable> + 5957

    8    libc.so.6                          0x00002b938049a460 __libc_start_main +
    245

    9    tmpg2g3fp5n                        0x000055f7b9a67349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = 0\n    var array = [Int]()\n    var sum = 0\n\
    \n    for n in numbers {\n        sum += n\n        if sum > max {\n         \
    \   max = sum\n            array = numbers\n        }\n    }\n\n    return array\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp31dxpgen/tmp31dxpgen.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a64f59c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a64c50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a64c50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a64c4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp31dxpgen                        0x000055e780b287b6 <unavailable> + 6070

    5    libc.so.6                          0x00002b7a65145460 __libc_start_main +
    245

    6    tmp31dxpgen                        0x000055e780b28189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n    \n\
    \    var maximum = numbers.reduce(Int.min, by: 0)\n    \n    var max = maximum\n\
    \    var result: [Int] = []\n    \n    for number in numbers {\n        if number\
    \ > maximum {\n            result.append(max)\n            max = number\n    \
    \    } else {\n            max = number\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpv_e3feed.swift:11:33: error: extraneous argument label 'by:' in\
    \ call\n    var maximum = numbers.reduce(Int.min, by: 0)\n                   \
    \             ^         ~~~~\n                                          \n/tmp/tmpv_e3feed.swift:11:47:\
    \ error: cannot convert value of type 'Int' to expected argument type '(Int, Int)\
    \ throws -> Int'\n    var maximum = numbers.reduce(Int.min, by: 0)\n         \
    \                                     ^\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, min: 1, max: numbers.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpy7pwv2i2.swift:7:23: error: extra arguments at positions #2, #3\
    \ in call\n    return rolling_max(numbers, min: 1, max: numbers.count)\n     \
    \                 ^\n/tmp/tmpy7pwv2i2.swift:6:6: note: 'rolling_max(numbers:)'\
    \ declared here\nfunc rolling_max(numbers: [Int]) -> [Int] {\n     ^\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = [0]\n    var rollingMax: Int? = nil\n\
    \    for number in numbers {\n        rollingMax = result.remove(at: result.index(of:\
    \ number))\n        if let rollingMax = rollingMax {\n            result.append(rollingMax)\n\
    \        } else {\n            result.append(number)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpwztbgzr5.swift:10:47: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n        rollingMax = result.remove(at: result.index(of: number))\n\
    \                                              ^\n/tmp/tmpwztbgzr5.swift:10:47:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        rollingMax = result.remove(at: result.index(of: number))\n  \
    \                                            ^\n                             \
    \                                   ?? <#default value#>\n/tmp/tmpwztbgzr5.swift:10:47:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        rollingMax = result.remove(at: result.index(of: number))\n  \
    \                                            ^\n                             \
    \                                  !\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else {\n        return []\n \
    \   }\n    \n    var result = [Int]()\n    var highestValue = numbers[0]\n   \
    \ var currentValue = 0\n    var currentMax = 0\n    \n    for number in numbers\
    \ {\n        if number > highestValue {\n            highestValue = number\n \
    \       }\n        \n        if number == highestValue {\n            currentValue\
    \ += 1\n        } else {\n            result.appendInt(currentValue)\n       \
    \     currentValue = highestValue + 1\n            currentMax = highestValue\n\
    \        }\n    }\n    result.appendInt(currentValue)\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp7d68i_2b.swift:24:20: error: value of type '[Int]' has no member\
    \ 'appendInt'\n            result.appendInt(currentValue)\n            ~~~~~~\
    \ ^~~~~~~~~\n/tmp/tmp7d68i_2b.swift:29:12: error: value of type '[Int]' has no\
    \ member 'appendInt'\n    result.appendInt(currentValue)\n    ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers, 1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp6t_gzvmc.swift:7:33: error: extra argument in call\n    return\
    \ rolling_max(numbers, 1)\n                      ~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659980048
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maxIndexes = [Int]()\n\n\
    \    for number in numbers {\n        let index = maxIndexes.firstIndex(of: number)\n\
    \        if index == nil {\n            result.append(number)\n            maxIndexes.append(number)\n\
    \        } else {\n            result[index!] = number\n            maxIndexes[index!]\
    \ = number\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpboggqo6f/tmpboggqo6f.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad9f75ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad9f455b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad9f455988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad9f4547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpboggqo6f                        0x000055dae7981966 <unavailable> + 6502

    5    libc.so.6                          0x00002aad9f94a460 __libc_start_main +
    245

    6    tmpboggqo6f                        0x000055dae7981339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = [Int]()\n\n    if numbers.isEmpty {\n     \
    \   return max\n    }\n\n    for var i = 0; i < numbers.count - 1 {\n        let\
    \ last = numbers[i]\n        var current = numbers[i + 1]\n\n        while current\
    \ > last {\n            current = current.prefix(by: 1)\n        }\n\n       \
    \ max[i] = current\n    }\n\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpblajioxx.swift:13:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < numbers.count - 1 {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    for number in numbers\
    \ {\n        if let index = rolling_max.index(of: number) {\n            rolling_max[index]\
    \ = max(rolling_max[index], number)\n        } else {\n            rolling_max.append(number)\n\
    \        }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpcw4qa6xv/tmpcw4qa6xv.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b843d3a0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b843d097b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b843d097988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b843d0967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcw4qa6xv                        0x000055dff88a39c6 <unavailable> + 6598

    5    libc.so.6                          0x00002b843d58c460 __libc_start_main +
    245

    6    tmpcw4qa6xv                        0x000055dff88a3399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    rolling_max = numbers.reduce([]) { (rolling_max, currentValue)\
    \ in\n        if rolling_max == nil || rolling_max.last < currentValue {\n   \
    \         rolling_max.append(currentValue)\n        } else {\n            rolling_max.append(rolling_max.last)\n\
    \        }\n        return rolling_max\n    }\n    return rolling_max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpvjpj00w0.swift:7:5: error: cannot assign to value: 'rolling_max'\
    \ is a function\n    rolling_max = numbers.reduce([]) { (rolling_max, currentValue)\
    \ in\n    ^~~~~~~~~~~\n/tmp/tmpvjpj00w0.swift:8:51: error: type '((Any) throws\
    \ -> Bool) throws -> Any?' cannot conform to 'BinaryInteger'\n        if rolling_max\
    \ == nil || rolling_max.last < currentValue {\n                              \
    \                    ^\n/tmp/tmpvjpj00w0.swift:8:51: note: only concrete types\
    \ such as structs, enums and classes can conform to protocols\n        if rolling_max\
    \ == nil || rolling_max.last < currentValue {\n                              \
    \                    ^\n/tmp/tmpvjpj00w0.swift:8:51: note: required by referencing\
    \ operator function '<' on 'BinaryInteger' where 'Self' = '((Any) throws -> Bool)\
    \ throws -> Any?'\n        if rolling_max == nil || rolling_max.last < currentValue\
    \ {\n                                                  ^\n/tmp/tmpvjpj00w0.swift:15:12:\
    \ error: cannot convert return expression of type '([Int]) -> [Int]' to return\
    \ type '[Int]'\n    return rolling_max\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce([]) { (acc, x) -> [Int] in\n  \
    \      if let idx = acc.firstIndex(where: { $0 > x }) {\n            acc[idx]\
    \ = acc[idx] > x ? acc[idx] : x\n        }\n        else { acc.append(x) }\n \
    \       return acc\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpzt6ea_1x.swift:9:16: error: cannot assign through subscript: 'acc'\
    \ is a 'let' constant\n            acc[idx] = acc[idx] > x ? acc[idx] : x\n  \
    \          ~~~^\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce(0, { maxElement, element in\n \
    \       let maxIndex = numbers.indexOf(maxElement)\n        let newMaxIndex =\
    \ maxIndex + rollingMaxSteps\n        return maxElement > element\n          \
    \  ? maxElement\n            : element > numbers[newMaxIndex]\n              \
    \  ? element\n                : numbers[newMaxIndex]\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpdypa8cl9.swift:9:38: error: cannot find 'rollingMaxSteps' in scope\n\
    \        let newMaxIndex = maxIndex + rollingMaxSteps\n                      \
    \               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard !numbers.isEmpty else {\n        return []\n  \
    \  }\n    return numbers.reduce { $0 < $1 ? $0 : $1 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpopr5lcc8.swift:10:26: error: missing argument for parameter 'into'\
    \ in call\n    return numbers.reduce { $0 < $1 ? $0 : $1 }\n                 \
    \        ^\n                         (into: <#Int#>)\nSwift.Sequence:3:28: note:\
    \ 'reduce(into:_:)' declared here\n    @inlinable public func reduce<Result>(into\
    \ initialResult: __owned Result, _ updateAccumulatingResult: (_ partialResult:\
    \ inout Result, Self.Element) throws -> ()) rethrows -> Result\n             \
    \              ^\n/tmp/tmpopr5lcc8.swift:10:20: error: cannot convert return expression\
    \ of type 'Int' to return type '[Int]'\n    return numbers.reduce { $0 < $1 ?\
    \ $0 : $1 }\n           ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let rolling_max = numbers.map { rolling_max($0, times:\
    \ numbers.size) }\n    return rolling_max.joined()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmph3uf1ng9.swift:7:68: error: value of type '[Int]' has no member\
    \ 'size'\n    let rolling_max = numbers.map { rolling_max($0, times: numbers.size)\
    \ }\n                                                           ~~~~~~~ ^~~~\n\
    /tmp/tmph3uf1ng9.swift:7:37: error: cannot call value of non-function type '[T]'\n\
    \    let rolling_max = numbers.map { rolling_max($0, times: numbers.size) }\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1659980049
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result: [Int] = numbers\n    for _ in 0 ..< numbers.count\
    \ {\n        let max = numbers.max()!\n        result.remove(at: result.index(of:\
    \ max)!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpurublgag/tmpurublgag.swift:10: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a3d789c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a3d480561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5a3d480286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5a3d48013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5a3d47fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpurublgag                        0x000055f2ff591e17 <unavailable> + 7703

    6    tmpurublgag                        0x000055f2ff591745 <unavailable> + 5957

    7    libc.so.6                          0x00002b5a3d975460 __libc_start_main +
    245

    8    tmpurublgag                        0x000055f2ff591349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659980049
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rollingMax: [Int] = [0]\n    for i in numbers {\n\
    \        rollingMax.append(rollingMax.last! > i ? rollingMax.last! : i)\n    }\n\
    \    return rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpnlfgvxtf/tmpnlfgvxtf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70fd55ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70fd255b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70fd255988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70fd2547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnlfgvxtf                        0x000055978c5f2676 <unavailable> + 5750

    5    libc.so.6                          0x00002b70fd74a460 __libc_start_main +
    245

    6    tmpnlfgvxtf                        0x000055978c5f22c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659980049
