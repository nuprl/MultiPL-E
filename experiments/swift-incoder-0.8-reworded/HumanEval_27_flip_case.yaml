name: HumanEval_27_flip_case
language: swift
prompt: "\n/// For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n/// >>> flip_case(string: \"Hello\")\n/// \"hELLO\"\nfunc flip_case(string:\
  \ String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(flip_case(string: \"\") == \"\")\nassert(flip_case(string:\
  \ \"Hello!\") == \"hELLO!\")\nassert(flip_case(string: \"These violent delights\
  \ have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")"
completions: ["    var result = string\n    result.lowercased()\n    result.uppercased()\n\
    \    return result", '    return capitalize(lowercase_first(string))', "    if\
    \ let index = string.range(of: \"[A-Z]\") {\n        var newString = string\n\n\
    \        newString[index] = string[index].lowercased()\n        newString[index]\
    \ = string[index].uppercased()\n        return newString\n    }\n    return string",
  '    return string.casefold().uppercased()', '    return string.lowercased() + string.uppercased()',
  "    let lower = string.lowercased()\n    let upper = string.uppercased()\n    return\
    \ upper.characters.joinWithSeparator(lower)", "    // \"lowercase\" -> \"lowercase\"\
    \ -> \"uppercase\"\n    func flip_case_helper(_ str: String) -> String {\n   \
    \     var result = \"\"\n        for c in str.unicodeScalars {\n            if\
    \ let _ = c.isUppercase {\n                result += c.lowercase.asciiValue\n\
    \            } else {\n                result += c.uppercase.asciiValue\n    \
    \        }\n        }\n        return result\n    }\n    return flip_case_helper(string)",
  "    return string.characters.map {\n        Character($0) switch Character($0)\
    \ {\n        case .lowercase: Character.uppercase\n        case .uppercase: Character.lowercase\n\
    \        }\n    }.joined()", '    return string.lowercased() + string.uppercased()',
  "    let newString = string.unicodeScalars\n        .map {\n            String(UnicodeScalar($0.value)!)\n\
    \        }\n        .joined()\n    return newString", "    if string == \"\" {\n\
    \        return string\n    }\n    var result = \"\"\n    lowercase(&result)\n\
    \    uppercase(&result)\n    lowercase(&result)\n    uppercase(&result)\n    return\
    \ result", "    guard let mutableString = string.mutableCopy() else { return string\
    \ }\n    mutableString.replaceSubrange(\n        NSMakeRange(0, string.endIndex),\n\
    \        with: NSMakeRange(string.startIndex, string.endIndex))\n    mutableString.replaceSubrange(\n\
    \        NSMakeRange(string.startIndex, string.endIndex),\n        with: NSMakeRange(0,\
    \ string.startIndex))\n    return mutableString.copy() as! String", "    var result\
    \ = \"\"\n    for c in string {\n        switch c {\n        case c.isUpper:\n\
    \            c ^= 0x20\n        default:\n            c ^= 0x20\n            c\
    \ |= 0x20\n        }\n        result = String(c) + result\n    }\n    return result",
  "\tvar result String = \"\"\n\tfor c in string {\n\t\tswitch c.unicodeScalars.lowerCase\
    \ {\n\t\tcase .upper:\n\t\t\tresult = result + String(c)\n\t\tcase .lowercase:\n\
    \t\t\tresult = result + String(c)\n\t\tcase .none:\n\t\t\tresult = result + String(c)\n\
    \t\tdefault:\n\t\t\tresult = result + String(c).lowercase\n\t\t}\n\t}\n\treturn\
    \ result", "    return string.unicodeScalars.map{ $0.isUppercase ? $0.withLowercase()\
    \ : $0.withUppercase() }\n        .joined()", "    if string.isEmpty {\n     \
    \   return string\n    }\n    \n    return string.uppercased() + string.lowercased()",
  "    var output = string\n\n    // If string is empty, return empty string\n   \
    \ if output == \"\" {\n        return output\n    }\n\n    // If there is any\
    \ non-letter character in the string, return string\n    if let firstCharacter\
    \ = string.first?.unicodeScalars.first {\n        if !CharacterSet.letters.contains(firstCharacter)\
    \ {\n            return output\n        }\n    }\n\n    // Iterate through the\
    \ string character by character and\n    // flip lowercase letters to uppercase\n\
    \    var last: CharacterIndex?\n    for index in 0..<string.characters.count {\n\
    \        let character = string[index]\n        // If the character is lowercase,\
    \ flip to uppercase\n        if CharacterSet.letters.contains(character) {\n \
    \           if last != nil {\n                let nextIndex = string.index(before:\
    \ last!)\n                output[nextIndex] = character.uppercased()\n       \
    \     } else {\n                output[index] = character.uppercased()\n     \
    \       }\n        } else {\n            last = index\n        }\n    }\n\n  \
    \  return output", "    return string.chars().map({ $0 >= 'a' && $0 <= 'z' ? Character($0\
    \ + 32) : Character($0) }).filter({ $0 != nil })\n        .map({ $0! })\n    \
    \    .joined()", "    guard string != \"\" else { return string }\n    var result\
    \ = \"\"\n\n    for char in string.unicodeScalars {\n        let upper = UnicodeScalar(unicodeScalars:\
    \ [\n            0x41,\n            0x43,\n            0x5E,\n            0x45,\n\
    \            0x5D,\n            0x56,\n            0x41,\n            0x5E,\n\
    \            0x48,\n            0x45,\n            0x5E,\n            0x5D,\n\
    \            0x57,\n            0x41,\n            0x5E,\n            0x48,\n\
    \            0x45,\n            0x5E,\n            0x5D,\n            0x57,\n\
    \            0x53,\n            0x5D,\n            0x46,\n            0x41,\n\
    \            0x5E,\n            0x48,\n            0x5D,\n            0x46,\n\
    \            0x5E,\n            0x48,\n            0x5D,\n            0x57,\n\
    \            0x41,\n            0x5E,\n            0x48,\n            0x5D,\n\
    \            0x46,\n            0x5E,\n            0x48,\n            0x5D,\n\
    \            0x57,\n            0x45,\n            0x5E,\n            0x48,\n\
    \            0x5D,\n            0x57,\n            0x5D,\n            0x48,\n\
    \            0x45,\n            0x5E,\n            0x48,\n            0x5D,\n\
    \            0x46,\n            0x5E,\n            0x48,\n            0x5D,\n\
    \            0x57,\n            0x45,\n            0x5E,\n            0x48,\n\
    \            0x5D,\n            0x57,\n            0x5D,\n            0x48,\n\
    \            0x45,\n            0x5E,\n            0x48,\n            0x5D,\n\
    \            0x46,\n            0x5E,\n            0x48,\n            0x5D,\n\
    \            0x57,\n            0x45,\n            0x5E,\n            0x48,\n\
    \            0x5D,\n            0x57,\n            0x5D,\n            0x48,\n\
    \            0x45,\n            0x5E,\n            0x48,\n            0x5D,\n\
    \            0x46,\n            0x5E,\n            0x48,\n            0x5D,\n\
    \            0x57,\n            0x45,\n            0x5E,\n            0x48,\n\
    \            0x5D,\n            0x57,\n            0x5D,\n            0x48,\n",
  '    return string.lowercaseString.toUpperCase + string.uppercaseString.lowercaseString',
  '    return string.unicodeScalars.map { $0.isUppercase ? $0.withLowercase() : $0.withUppercase()
    }.joinWithSeparator("")', "    guard string.count > 0 else { return string }\n\
    \    \n    var result = \"\"\n    for char in string.unicodeScalars {\n      \
    \  if char.value > 126 { continue }\n        \n        switch char.value {\n \
    \       case 65..90, 97..122:\n            result += \"\\(char.value)\"\n    \
    \    case 97:\n            result += \"A\"\n        case 65:\n            result\
    \ += \"a\"\n        default:\n            result += String(char)\n        }\n\
    \    }\n    \n    return result", "    let characters = Array(string.unicodeScalars)\n\
    \n    var reversedString = \"\"\n    for character in characters {\n        switch\
    \ character {\n        case .lowercase:\n            reversedString += Character(Character.uppercase)\n\
    \        case .uppercase:\n            reversedString += Character(Character.lowercase)\n\
    \        }\n    }\n\n    return reversedString", "    var string = string\n  \
    \  if let range = string.range(of: \"[A-Z]\") {\n        string = string.replacingCharacters(in:\
    \ range, with: string.unicodeScalars.first!.value.uppercased())\n    }\n    if\
    \ let range = string.range(of: \"[a-z]\") {\n        string = string.replacingCharacters(in:\
    \ range, with: string.unicodeScalars.first!.value.lowercased())\n    }\n    return\
    \ string", '    return string.uppercased().lowercased()', "    let chars = Array(string)\n\
    \    guard let charCount = chars.count else { return string }\n    for idx in\
    \ 0..<charCount {\n        let char = chars[idx]\n        if let _ = Char.UnicodeScalar.properties.contains(.CaseUp)\
    \ {\n            chars[idx] = char.uppercased()\n        } else {\n          \
    \  chars[idx] = char.lowercased()\n        }\n    }\n    return String(chars)",
  "    guard let letters = string.unicodeScalars.filter{ $0.isUppercase() }.sorted\
    \ else { return string }\n    return String(letters.map{ String((string.unicodeScalars.filter{\
    \ $0.isLowercase() })\n        .sorted { $0.value > $1.value })\n        .first!.value!\
    \ })", "    string = (string[0] as! Character).uppercaseString + string.lowercaseString\n\
    \    return string", "    return string.characters.map { $0 >= 65 &&\n       \
    \                            $0 <= 90 ?\n                                   String($0\
    \ + 32) :\n                                   $0 }\n        .joinWithSeparator(\"\
    \").capitalize()", "    var result = [Character]()\n    for (index, char) in string.unicodeScalars.enumerated()\
    \ {\n        if char.value > 0x7F {\n            let lower = char.value - 0x20\n\
    \            let upper = char.value + 0x20\n\n            result.append(Character(UnicodeScalar(upper)))\n\
    \            result.append(Character(UnicodeScalar(lower)))\n        } else {\n\
    \            result.append(char)\n        }\n    }\n    return String(result)",
  '    return string.lowercased() + string.uppercased()', '    return string(unicodeScalars.reversed())',
  "\tvar result : String = string\n\tfor i = 0; i < result.count; i++ {\n\t\tswitch\
    \ result[i] {\n\t\tcase 'A':\n\t\t\tresult[i] = 'a'\n\t\tcase 'a':\n\t\t\tresult[i]\
    \ = 'A'\n\t\tcase 'B':\n\t\t\tresult[i] = 'b'\n\t\tcase 'b':\n\t\t\tresult[i]\
    \ = 'B'\n\t\tcase 'C':\n\t\t\tresult[i] = 'c'\n\t\tcase 'c':\n\t\t\tresult[i]\
    \ = 'C'\n\t\tcase 'D':\n\t\t\tresult[i] = 'd'\n\t\tcase 'd':\n\t\t\tresult[i]\
    \ = 'D'\n\t\tcase 'E':\n\t\t\tresult[i] = 'e'\n\t\tcase 'e':\n\t\t\tresult[i]\
    \ = 'E'\n\t\tcase 'F':\n\t\t\tresult[i] = 'f'\n\t\tcase 'f':\n\t\t\tresult[i]\
    \ = 'F'\n\t\tcase 'G':\n\t\t\tresult[i] = 'g'\n\t\tcase 'g':\n\t\t\tresult[i]\
    \ = 'G'\n\t\tcase 'H':\n\t\t\tresult[i] = 'h'\n\t\tcase 'h':\n\t\t\tresult[i]\
    \ = 'H'\n\t\tcase 'I':\n\t\t\tresult[i] = 'i'\n\t\tcase 'i':\n\t\t\tresult[i]\
    \ = 'I'\n\t\tcase 'J':\n\t\t\tresult[i] = 'j'\n\t\tcase 'j':\n\t\t\tresult[i]\
    \ = 'J'\n\t\tcase 'K':\n\t\t\tresult[i] = 'k'\n\t\tcase 'k':\n\t\t\tresult[i]\
    \ = 'K'\n\t\tcase 'L':\n\t\t\tresult[i] = 'l'\n\t\tcase 'l':\n\t\t\tresult[i]\
    \ = 'L'\n\t\tcase 'M':\n\t\t\tresult[i] = 'm'\n\t\tcase 'm':\n\t\t\tresult[i]\
    \ = 'M'\n\t\tcase 'N':\n\t\t\tresult[i] = 'n'\n\t\tcase 'n':\n\t\t\tresult[i]\
    \ = 'N'\n\t\tcase 'O':\n\t\t\tresult[i] = 'o'\n\t\tcase 'o':\n\t\t\tresult[i]\
    \ = 'O'\n\t\tcase 'P':\n\t\t\tresult[i] = 'p'\n\t\tcase 'p':\n\t\t\tresult[i]\
    \ = 'P'\n\t\tcase 'Q':\n\t\t\tresult[i] = 'q'\n\t\tcase 'q':\n\t\t\tresult[i]\
    \ = 'Q'\n\t\tcase 'R':\n\t\t\tresult[i] = 'r'\n\t\tcase 'r':\n\t\t\tresult[i]\
    \ = 'R'\n\t\tcase 'S':\n\t\t\tresult[i] = 's'\n\t\tcase 's':\n\t\t\tresult[i]\
    \ = 'S'\n\t\tcase 'T':\n\t\t\tresult[i] = 't'\n\t\tcase 't':\n\t\t\tresult[i]\
    \ = 'T'\n\t\tcase 'U':\n\t\t\tresult[i] = 'u'\n\t\tcase 'u':\n\t\t\tresult[i]\
    \ = 'U'\n\t\tcase 'V':", "    var result = \"\"\n    for symbol in string {\n\
    \        switch symbol {\n        case \"A\"...\"Z\":\n            result += \"\
    a\"...\"z\"\n        case \"a\"...\"z\":\n            result += \"A\"...\"Z\"\n\
    \        default:\n            result += symbol\n        }\n    }\n    return\
    \ result", "    guard let first = string.first else {\n        return string\n\
    \    }\n    guard let last = string.last else {\n        return string\n    }\n\
    \    if let firstLetter = string.unicodeScalars.first?.value {\n        if string.unicodeScalars.count\
    \ == 2 {\n            return String(unicodeScalars: [UnicodeScalar(UnicodeScalar(firstLetter).value\
    \ + UnicodeScalar(lastLetter).value)])\n        }\n        return String(unicodeScalars:\
    \ [UnicodeScalar(UnicodeScalar(firstLetter).value)])\n    }\n    return string",
  "    return string.unicodeScalars.lazy.map { str in\n        switch str.value {\n\
    \        case .lowercase:\n            return .uppercase\n        case .uppercase:\n\
    \            return .lowercase\n        }\n    }.fold(\"\") { (result, char) in\n\
    \        return result + String(char)\n    }", "    let characters = string.characters\n\
    \    var upper = false\n    for character in characters {\n        if upper {\n\
    \            characters[characters.startIndex + characters.index(before: character)]\
    \ = (character.uppercased())\n        } else {\n            characters[characters.startIndex\
    \ + characters.index(before: character)] = (character.lowercased())\n        }\n\
    \        upper = !upper\n    }\n    return String(characters)", "    if let characters\
    \ = string.unicodeScalars.map(String.init) {\n        return String(characters).reduce(\"\
    \") { $0 + $1.isUppercased() ? $1.lowercased() : $1.uppercased() + $0 }\n    }\n\
    \    return \"\"", '    return string.lowercaseString().uppercaseString()', " \
    \   let chars = Array(string)\n    .map { $0.isUppercase() ? $0.lowercaseString()\
    \ : $0.uppercaseString() }\n    return String(chars)", "    var result = \"\"\n\
    \    for char in string {\n        switch char {\n        case .lowercase:\n \
    \           result = char.uppercaseString + result\n        case .uppercase:\n\
    \            result = result + char.lowercaseString\n        }\n    }\n    return\
    \ result", "    string\n        .replacingOccurrences(of: \"[a-z]\", with: String.init(\"\
    [A-Z]\")) //uppercase to lowercase\n        .replacingOccurrences(of: \"[A-Z]\"\
    , with: String.init(\"[a-z]\")) //lowercase to uppercase", "    let lowercase\
    \ = string.lowercased()\n    let uppercase = string.uppercased()\n    return uppercase.prefix(1).append(lowercase).append(uppercase.suffix(1))",
  "\treturn string.uppercased().lowercased()", "    var string = string\n    string\
    \ = string.lowercased()\n    string = string.uppercased()\n    return string",
  '    return string.lowercaseString.uppercaseString', "\treturn string", '    return
    string.characters.map({ $0 == Character("A") ? "a" : $0 == Character("a") ? "A"
    : $0 }).joinWithSeparator("")', "    // Return empty string if string is nil\n\
    \    guard let string = string else { return \"\" }\n    var result = \"\"\n \
    \   var upper = false\n    var i = 0\n    while i < string.count {\n        let\
    \ char = string[i]\n        switch char {\n        case \"a\" ... \"z\", \"A\"\
    , \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\"\
    , \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\"\
    , \"X\", \"Y\", \"Z\", \"0\":\n            if upper {\n                result\
    \ += char.uppercased()\n                upper = false\n            } else {\n\
    \                result += char.lowercased()\n                upper = true\n \
    \           }\n        default:\n            result += char\n        }\n     \
    \   i += 1\n    }\n    return result", '    return string.lowercased() + string.uppercased()',
  "    func toUpper(_ char: Character) -> Character {\n        switch char {\n   \
    \     case Character(char):\n            return char\n        case Character(let\
    \ upperCaseChar):\n            return Character(upperCaseChar)\n        }\n  \
    \  }\n    func toLower(_ char: Character) -> Character {\n        switch char\
    \ {\n        case Character(char):\n            return char\n        case Character(let\
    \ lowerCaseChar):\n            return Character(lowerCaseChar)\n        }\n  \
    \  }\n    return string.map(toUpper).map(toLower)", "    switch string {\n   \
    \ case .init(unicodeScalars: [:]) {\n        return \"\"\n    }\n    case .init(stringInterpolationSegment\
    \ as NSString).unicodeScalars:\n        return \"\"\n    case .init(stringInterpolationSegment\
    \ as NSString).string {\n        return \"\"\n    }\n    case let string as NSString:\n\
    \        return string.string.lowercaseString\n    }", '    return string.map
    { $0.isUppercase() ? "\($0.lowercased())" : "\($0.uppercased())" }', "\tlet characters\
    \ = string.characters\n\tlet flipped = characters.map { Character($0).isUppercase()\
    \ ? Character($0).lowercased() : Character($0).uppercased() }\n\treturn String(flipped)",
  "    let characters = string.characters\n    return String(characters.map { $0 ==\
    \ CharacterSet.lowercased().first ? Character($0.uppercased()) : Character($0.lowercased())\
    \ })", "    guard string.count > 0 else {\n        return \"\"\n    }\n    var\
    \ result = \"\"\n    for character in string {\n        switch character {\n \
    \       case \"a\":\n            result += \"A\"\n        case \"b\":\n      \
    \      result += \"B\"\n        case \"c\":\n            result += \"C\"\n   \
    \     case \"d\":\n            result += \"D\"\n        case \"e\":\n        \
    \    result += \"E\"\n        case \"f\":\n            result += \"F\"\n     \
    \   case \"g\":\n            result += \"G\"\n        case \"h\":\n          \
    \  result += \"H\"\n        case \"i\":\n            result += \"I\"\n       \
    \ case \"j\":\n            result += \"J\"\n        case \"k\":\n            result\
    \ += \"K\"\n        case \"l\":\n            result += \"L\"\n        case \"\
    m\":\n            result += \"M\"\n        case \"n\":\n            result +=\
    \ \"N\"\n        case \"o\":\n            result += \"O\"\n        case \"p\"\
    :\n            result += \"P\"\n        case \"q\":\n            result += \"\
    Q\"\n        case \"r\":\n            result += \"R\"\n        case \"s\":\n \
    \           result += \"S\"\n        case \"t\":\n            result += \"T\"\n\
    \        case \"u\":\n            result += \"U\"\n        case \"v\":\n     \
    \       result += \"V\"\n        case \"w\":\n            result += \"W\"\n  \
    \      case \"x\":\n            result += \"X\"\n        case \"y\":\n       \
    \     result += \"Y\"\n        case \"z\":\n            result += \"Z\"\n    \
    \    default:\n            result += String(character)\n        }\n    }\n   \
    \ return result", "    var output = String()\n\n    for c in string.unicodeScalars\
    \ {\n        var uc = c\n        uc.isUppercase = !uc.isUppercase\n        uc.isLowercase\
    \ = !uc.isLowercase\n        output = output + uc.value\n    }\n\n    return output",
  "    switch string {\n    case \"a\":\n        return \"A\"\n    case \"b\":\n \
    \       return \"B\"\n    case \"c\":\n        return \"C\"\n    case \"d\":\n\
    \        return \"D\"\n    case \"e\":\n        return \"E\"\n    case \"f\":\n\
    \        return \"F\"\n    case \"g\":\n        return \"G\"\n    case \"h\":\n\
    \        return \"H\"\n    case \"i\":\n        return \"I\"\n    case \"j\":\n\
    \        return \"J\"\n    case \"k\":\n        return \"K\"\n    case \"l\":\n\
    \        return \"L\"\n    case \"m\":\n        return \"M\"\n    case \"n\":\n\
    \        return \"N\"\n    case \"o\":\n        return \"O\"\n    case \"p\":\n\
    \        return \"P\"\n    case \"q\":\n        return \"Q\"\n    case \"r\":\n\
    \        return \"R\"\n    case \"s\":\n        return \"S\"\n    case \"t\":\n\
    \        return \"T\"\n    case \"u\":\n        return \"U\"\n    case \"v\":\n\
    \        return \"V\"\n    case \"w\":\n        return \"W\"\n    case \"x\":\n\
    \        return \"X\"\n    case \"y\":\n        return \"Y\"\n    case \"z\":\n\
    \        return \"Z\"\n    default:\n        return string\n    }", "    return\
    \ string.unicodeScalars.reduce(into: \"\") {\n        $0.append($1.isLowerCase\
    \ ? $0.append($1.unicodeScalars.first!) : $0.append($1.unicodeScalars.last!))\n\
    \    }", "    var output = \"\"\n    for symbol in string {\n        if symbol.isLowercase()\
    \ {\n            output += String(flip_case(symbol).uppercased()) + \"\"\n   \
    \     } else {\n            output += symbol + \"\"\n        }\n    }\n    return\
    \ output", "    var result = \"\"\n    for char in string {\n        if let _\
    \ = char.unicodeScalars.filter({ $0.isUppercase }).first {\n            result\
    \ += char.unicodeScalars.filter({ $0.isLowercase }).first!.value + char.unicodeScalars.filter({\
    \ !$0.isUppercase }).first!.value\n        } else {\n            result += char.unicodeScalars.filter({\
    \ !$0.isUppercase }).first!.value\n        }\n    }\n    return result", '    return
    string.characters.map{ $0 ~= 32 ? $0 ~= 96 ? $0 ~= 123 ? $0 ~= 122 ? $0 ~= 95
    ? $0~= 98 ? $0 ~= 97 ? $0 ~= 118 ? $0 ~= 108 ? $0 ~= 101 : "A".characters.first
    : $0 ~= 92 ? $0 ~= 93 ? $0 ~= 94 ? $0 ~= 91 ? $0 ~= 124 ? $0 ~= 114 ? $0 ~= 112
    ? $0 ~= 113 ? $0 ~= 106 ? $0 ~= 105 ? $0 ~= 104 ? $0 ~= 102 ? $0 ~= 99 ? $0 ~=
    90 ? $0 ~= 87 ? $0 ~= 86 ? $0 ~= 84 ? $0 ~= 83 ? $0 ~= 82 ? $0 ~= 81 ? $0 ~= 80
    ? $0 ~= 79 ? $0 ~= 78 ? $0 ~= 77 ? $0 ~= 76 ? $0 ~= 75 ? $0 ~= 74 ? $0 ~= 73 ?
    $0 ~= 72 ? $0 ~= 71 ? $0 ~= 70 ? $0 ~= 69 ? $0 ~= 68 ? $0 ~= 67 ? $0 ~= 66 ? $0
    ~= 65 ? $0 ~= 64 ? $0 ~= 63 ? $0 ~= 62 ? $0 ~= 61 ? $0 ~= 60 ? $0 ~= 59 ? $0 ~=
    58 ? $0 ~= 57 ? $0 ~= 56 ? $0 ~= 55 ? $0 ~= 54 ? $0 ~= 53 ? $0 ~= 52 ? $0 ~= 51
    ? $0 ~= 50 : $0 ~= 48 ? $0 ~= 47 ? $0 ~= 46 ? $0 ~= 45 ? $0 ~= 44 ? $0 ~= 43 ?
    $0 ~= 42 ? $0 ~= 41 ? $0 ~= 40 ? $0 ~= 39 ? $0 ~= 38 ? $0 ~= 37 ? $0 ~= 36 ? $0
    ~= 35 ? $0 ~= 34 ? $0 ~= 33 ? $0 ~= 32 ? $0 ~= 31 ? $0 ', '    return string.lowercaseString.uppercaseString
    + string.uppercaseString', "    if string.isEmpty {\n        return string\n \
    \   }\n    var new_str = \"\"\n    var characters: [Character] = []\n    for character\
    \ in string.unicodeScalars {\n        let char_type = character.characteristic\n\
    \n        if char_type == .caseMark {\n            new_str += character.unicodeScalars.first!\n\
    \        } else if char_type == .uppercaseMark && character.unicodeScalars.isEmpty\
    \ {\n            new_str += character.unicodeScalars.first!\n        } else if\
    \ char_type == .lowercaseMark {\n            new_str += character.unicodeScalars.first!\n\
    \        } else {\n            characters.append(character)\n        }\n    }\n\
    \n    for character in characters {\n        new_str += character.unicodeScalars.first!\n\
    \    }\n    return new_str", "    let uppercase = string.uppercased()\n    let\
    \ lowercase = string.lowercased()\n    return uppercase.isEmpty() ? lowercase\
    \ : lowercase", "    var str = string\n    str.makeIterator()\n        .map {\
    \ c in\n            switch c {\n            case 'a':\n                return\
    \ 'A'\n            case 'b':\n                return 'B'\n            case 'c':\n\
    \                return 'C'\n            case 'd':\n                return 'D'\n\
    \            case 'e':\n                return 'E'\n            case 'f':\n  \
    \              return 'F'\n            case 'g':\n                return 'G'\n\
    \            case 'h':\n                return 'H'\n            case 'i':\n  \
    \              return 'I'\n            case 'j':\n                return 'J'\n\
    \            case 'k':\n                return 'K'\n            case 'l':\n  \
    \              return 'L'\n            case 'm':\n                return 'M'\n\
    \            case 'n':\n                return 'N'\n            case 'o':\n  \
    \              return 'O'\n            case 'p':\n                return 'P'\n\
    \            case 'q':\n                return 'Q'\n            case 'r':\n  \
    \              return 'R'\n            case 's':\n                return 'S'\n\
    \            case 't':\n                return 'T'\n            case 'u':\n  \
    \              return 'U'\n            case 'v':\n                return 'V'\n\
    \            case 'w':\n                return 'W'\n            case 'x':\n  \
    \              return 'X'\n            case 'y':\n                return 'Y'\n\
    \            case 'z':\n                return 'Z'\n            default:\n   \
    \             return c\n            }\n        }\n        .replaceSubrange(str.startIndex..<str.endIndex,\
    \ with: string.unicodeScalars.map { String($0) })\n    return str", "    let chars\
    \ = string.unicodeScalars\n        .filter { $0.isUppercase }\n        .map {\
    \ $0.uppercased() }\n        .filter { $0.isLowercase }\n        .map { $0.lowercased()\
    \ }\n    return String(chars)", "    var result = \"\"\n    for char in string\
    \ {\n        switch char {\n        case 'A':\n        case 'a':\n           \
    \ result += \"A\"\n        case 'B':\n        case 'b':\n            result +=\
    \ \"B\"\n        case 'C':\n        case 'c':\n            result += \"C\"\n \
    \       case 'D':\n        case 'd':\n            result += \"D\"\n        case\
    \ 'E':\n        case 'e':\n            result += \"E\"\n        case 'F':\n  \
    \      case 'f':\n            result += \"F\"\n        case 'G':\n        case\
    \ 'g':\n            result += \"G\"\n        case 'H':\n        case 'h':\n  \
    \          result += \"H\"\n        case 'I':\n        case 'i':\n           \
    \ result += \"I\"\n        case 'J':\n        case 'j':\n            result +=\
    \ \"J\"\n        case 'K':\n        case 'k':\n            result += \"K\"\n \
    \       case 'L':\n        case 'l':\n            result += \"L\"\n        case\
    \ 'M':\n        case 'm':\n            result += \"M\"\n        case 'N':\n  \
    \      case 'n':\n            result += \"N\"\n        case 'O':\n        case\
    \ 'o':\n            result += \"O\"\n        case 'P':\n        case 'p':\n  \
    \          result += \"P\"\n        case 'Q':\n        case 'q':\n           \
    \ result += \"Q\"\n        case 'R':\n        case 'r':\n            result +=\
    \ \"R\"\n        case 'S':\n        case 's':\n            result += \"S\"\n \
    \       case 'T':\n        case 't':\n            result += \"T\"\n        case\
    \ 'U':\n        case 'u':\n            result += \"U\"\n        case 'V':\n  \
    \      case 'v':\n            result += \"V\"\n        case 'W':\n        case\
    \ 'w':\n            result += \"W\"\n        case 'X':\n        case 'x':\n  \
    \          result += \"X\"\n        case 'Y':\n        case 'y':\n           \
    \ result += \"Y\"\n        case 'Z':\n        case 'z':\n            result +=\
    \ \"Z\"\n        default:\n            result += char\n        }\n    }\n    return\
    \ result", "    var result = \"\"\n\n    for char in string.unicodeScalars {\n\
    \        var unicodeScalar = char.unicodeScalars.first\n        let isLower =\
    \ unicodeScalar.value >= NSLowercaseCharacter\n        let isUpper = unicodeScalar.value\
    \ >= NSUppercaseCharacter\n\n        let currentChar = unicodeScalar.value <=\
    \ NSUppercaseCharacter ?\n            (unicodeScalar.value - NSLowercaseCharacter)\
    \ : (unicodeScalar.value + NSLowercaseCharacter)\n\n        result += String(Character(UnicodeScalar(currentChar)))\n\
    \    }\n\n    return result", '  return capitalize(flip_case_internal(string))',
  "    var result = \"\"\n    var pos = 0\n    for c in string {\n        let c =\
    \ c.toUppercase()\n        if pos < string.startIndex { result = c + result }\n\
    \        if c != string[pos] {\n            if result != \"\" {\n            \
    \    result = c + result\n            } else {\n                result = c\n \
    \           }\n        }\n        pos += 1\n    }\n    return result", "    if\
    \ let _char = string.range(of: \"[a-z]\") {\n        string = string.replacingCharacters(in:\
    \ Range<String.Index>(start: str.index(string.startIndex, offsetBy: _char.lowerBound),\
    \ end: str.endIndex), with: string.uppercased())\n    }\n    if let _char = string.range(of:\
    \ \"[A-Z]\") {\n        string = string.replacingCharacters(in: Range<String.Index>(start:\
    \ str.index(string.startIndex, offsetBy: _char.upperBound), end: str.endIndex),\
    \ with: string.lowercased())\n    }\n    return string", "\tlet range = Range<String.Index>(range:\
    \ string.startIndex..<string.endIndex, in: string)\n\treturn string.distance(from:\
    \ string.startIndex, to: range.lowerBound, to: range.upperBound) == 0 ? string\
    \ : string.capitalizingFirst", '    return String(zip(string.lowercaseString.unicodeScalars.map
    { $0.value }, string.uppercaseString.unicodeScalars.map { $0.value }))', "   \
    \ var output = \"\"\n    for char in string {\n        let upper = char.unicodeScalars.filter({\
    \ $0.isUppercased() }).count > 0\n        let lower = char.unicodeScalars.filter({\
    \ $0.isLowercased() }).count > 0\n        if upper && lower {\n            let\
    \ uppercase = char.unicodeScalars.filter({ $0.isUppercased() }).first!\n     \
    \       let lowercase = char.unicodeScalars.filter({ $0.isLowercased() }).first!\n\
    \            output = String(unicodeScalars: lowercase...uppercase)\n        }\
    \ else if upper {\n            let uppercase = char.unicodeScalars.filter({ $0.isUppercased()\
    \ }).first!\n            output = String(unicodeScalars: uppercase)\n        }\
    \ else if lower {\n            let lowercase = char.unicodeScalars.filter({ $0.isLowercased()\
    \ }).first!\n            output = String(unicodeScalars: lowercase)\n        }\n\
    \    }\n    return output", "    let lowercase = string.lowercased()\n    let\
    \ uppercase = string.uppercased()\n    return String(uppercase) + String(lowercase)",
  "\treturn string\n\t\t.replacingOccurrences(of: \"[a-z]\", with: \"[A-Z]\")\n\t\t\
    .replacingOccurrences(of: \"[A-Z]\", with: \"[a-z]\")", '    return string.characters.map
    { $0.isUppercase ? Character.toUpper($0) : Character.toLower($0) }.joined()',
  '    return string.lowercased().uppercased()', "\tlet lower = string\n\t\t.lowercased()\n\
    \t\t.unicodeScalars\n\t\t.map { $0.value }\n\t\t.joined()\n\n\tlet upper = string\n\
    \t\t.uppercased()\n\t\t.unicodeScalars\n\t\t.map { $0.value }\n\t\t.joined()\n\
    \n\treturn lower.withPrefix(upper)", "\treturn string.map({$0.isUppercase() ?\
    \ String($0.lowercased()) : String($0.uppercased())})", "    var characters: [Character]\
    \ = []\n    for char in string {\n        switch char {\n        case ' ':\n \
    \           characters.remove(' ')\n        case 'a':\n            characters.remove('a')\n\
    \        case 'b':\n            characters.remove('b')\n        case 'c':\n  \
    \          characters.remove('c')\n        case 'd':\n            characters.remove('d')\n\
    \        case 'e':\n            characters.remove('e')\n        case 'f':\n  \
    \          characters.remove('f')\n        case 'g':\n            characters.remove('g')\n\
    \        case 'h':\n            characters.remove('h')\n        case 'i':\n  \
    \          characters.remove('i')\n        case 'j':\n            characters.remove('j')\n\
    \        case 'k':\n            characters.remove('k')\n        case 'l':\n  \
    \          characters.remove('l')\n        case 'm':\n            characters.remove('m')\n\
    \        case 'n':\n            characters.remove('n')\n        case 'o':\n  \
    \          characters.remove('o')\n        case 'p':\n            characters.remove('p')\n\
    \        case 'q':\n            characters.remove('q')\n        case 'r':\n  \
    \          characters.remove('r')\n        case 's':\n            characters.remove('s')\n\
    \        case 't':\n            characters.remove('t')\n        case 'u':\n  \
    \          characters.remove('u')\n        case 'v':\n            characters.remove('v')\n\
    \        case 'w':\n            characters.remove('w')\n        case 'x':\n  \
    \          characters.remove('x')\n        case 'y':\n            characters.remove('y')\n\
    \        case 'z':\n            characters.remove('z')\n        default:\n   \
    \         characters.append(char)\n        }\n    }\n    return String(characters.reversed())",
  "    var result = \"\"\n    for character in string {\n        switch character\
    \ {\n        case 'a':\n            result += 'A'\n        case 'b':\n       \
    \     result += 'B'\n        case 'c':\n            result += 'C'\n        case\
    \ 'd':\n            result += 'D'\n        case 'e':\n            result += 'E'\n\
    \        case 'f':\n            result += 'F'\n        case 'g':\n           \
    \ result += 'G'\n        case 'h':\n            result += 'H'\n        case 'i':\n\
    \            result += 'I'\n        case 'j':\n            result += 'J'\n   \
    \     case 'k':\n            result += 'K'\n        case 'l':\n            result\
    \ += 'L'\n        case 'm':\n            result += 'M'\n        case 'n':\n  \
    \          result += 'N'\n        case 'o':\n            result += 'O'\n     \
    \   case 'p':\n            result += 'P'\n        case 'q':\n            result\
    \ += 'Q'\n        case 'r':\n            result += 'R'\n        case 's':\n  \
    \          result += 'S'\n        case 't':\n            result += 'T'\n     \
    \   case 'u':\n            result += 'U'\n        case 'v':\n            result\
    \ += 'V'\n        case 'w':\n            result += 'W'\n        case 'x':\n  \
    \          result += 'X'\n        case 'y':\n            result += 'Y'\n     \
    \   case 'z':\n            result += 'Z'\n        case 'A':\n            result\
    \ += 'a'\n        case 'B':\n            result += 'b'\n        case 'C':\n  \
    \          result += 'c'\n        case 'D':\n            result += 'd'\n     \
    \   case 'E':\n            result += 'e'\n        case 'F':\n            result\
    \ += 'f'\n        case 'G':\n            result += 'g'\n        case 'H':\n  \
    \          result += 'h'\n        case 'I':\n            result += 'i'\n     \
    \   case 'J':\n            result += 'j'\n        case 'K':\n            result\
    \ += 'k'\n        case 'L':\n            result += 'l'\n        case 'M':\n  \
    \          result += 'm'\n        case 'N':\n            result += 'n'\n     \
    \   case 'O':\n            result += 'o'\n        case 'P':\n            result\
    \ += 'p'\n        case 'Q':\n            result += 'q'\n        case 'R':\n  \
    \          result += 'r'\n        case 'S':\n            result += 's'\n     \
    \   case 'T':\n            result += 't'\n        case 'U':\n            result\
    \ += 'u'\n        case 'V':\n            result += 'v'\n        case 'W':\n  \
    \          result += 'w'\n        case 'X':\n            result += 'x'\n     \
    \   case 'Y':\n            result += 'y'\n        case 'Z':", "    let characters\
    \ = string.characters\n    return String(characters.map { $0.isUppercase ? $0.lowercased()\
    \ : $0.uppercased() })", "    return string.unicodeScalars.map { $0.isUpperCase\
    \ ? $0.lowercased() : $0.uppercased() }\n        .joined()", '    return string.uppercased().lowercased()',
  "    let chars = [Character](string.unicodeScalars.map { $0.value })\n    chars.reverse()\n\
    \    return String(chars)", '    return strings.Replace(string, "A", strings.ToUpper(string),
    "g")', "    if string.rangeOfCharacter(from: .lowercase) != nil {\n        string.lowercased()\n\
    \    } else {\n        string.uppercased()\n    }\n    return string", "    let\
    \ lowerString = string.lowercased()\n    let upperString = string.uppercased()\n\
    \    return lowerString + upperString", "    return string.unicodeScalars.map({\
    \ $0.value > 0xff00 ? $0.value + 32 : $0.value })\n        .map({ Character(UnicodeScalar($0))\
    \ })\n        .map({ String($0) })\n        .joined()", "    var result = string\n\
    \    for index in 0 ..< string.characters.count {\n        let char = string.characters[index]\n\
    \        if char.caseInsensitiveCompare == \"a\" {\n            result.characters[index]\
    \ = char.uppercased\n        } else {\n            result.characters[index] =\
    \ char.lowercased\n        }\n    }\n    return result", "    var result = \"\"\
    \n    for c in string.characters {\n        result += (String(c - 0x20) + String(c\
    \ + 0x20)).uppercaseString\n    }\n    return result", "    var chars: [Character]\
    \ = []\n    for char in string {\n        if char.lowercased() != char {\n   \
    \         chars.append(char.uppercased())\n        } else {\n            chars.append(char.lowercased())\n\
    \        }\n    }\n    return String(chars)", '    return string.lowercased()
    + string.uppercased()', "    guard !string.isEmpty else { return string }\n  \
    \  return string.uppercased().prefix(1) + string.lowercased().dropFirst()", " \
    \   var output = \"\"\n    \n    var buffer = [Character](repeating: Character(\"\
    \\u{0020}\\u{0020}\\u{0020}\"), count: string.count)\n    \n    func is_upper(index:\
    \ Int, buffer: inout [Character]) -> Bool {\n        if buffer[index] == \"\\\
    u{0020}\\u{0020}\\u{0020}\\u{0020}\" {\n            return false\n        }\n\
    \        \n        return buffer[index].isUpper()\n    }\n    \n    func is_lower(index:\
    \ Int, buffer: inout [Character]) -> Bool {\n        if buffer[index] == \"\\\
    u{0020}\\u{0020}\\u{0020}\\u{0020}\" {\n            return false\n        }\n\
    \        \n        return buffer[index].isLower()\n    }\n    \n    func flip(index:\
    \ Int, buffer: inout [Character]) {\n        let current = buffer[index]\n   \
    \     buffer[index] = buffer[index].isUpper() ? \"\\u{0020}\\u{0020}\\u{0020}\\\
    u{0020}\" : \"\\u{0020}\\u{0020}\\u{0020}\\u{0020}\"\n        buffer[index] =\
    \ current\n    }\n    \n    for i in string.indices {\n        if is_upper(i,\
    \ &buffer) {\n            flip(i, &buffer)\n        }\n        else if is_lower(i,\
    \ &buffer) {\n            flip(i, &buffer)\n        }\n    }\n    \n    output\
    \ += String(buffer)\n    \n    return output", "    if let unicodeScalars = string.unicodeScalars\
    \ {\n        let length = unicodeScalars.count\n        var swapped = [UnicodeScalar](repeating:\
    \ 0, count: length)\n        for i in 0..<length {\n            swapped[i] = unicodeScalars[i]\n\
    \            if i == 0 {\n                swapped[i] = unicodeScalars.endIndex.successor()\n\
    \            }\n        }\n        unicodeScalars = swapped\n        return String(unicodeScalars)\n\
    \    }\n    return string", '    return string.characters.map { $0.isUpper() ?
    $0.lowercased() : $0.uppercased() }.joinWithSeparator("")', "    let range = string.unicodeScalars.startIndex..<string.unicodeScalars.endIndex\n\
    \    return string.unicodeScalars.map{\n        $0 == .lowercase\n           \
    \ ? .uppercase\n            : .name\n    }.joined()", "    if string.rangeOfCharacter(from:\
    \ .uppercase) != nil {\n        return string\n    }\n\n    let unicodeScalars\
    \ = string.unicodeScalars\n    var outputString = \"\"\n    for scalar in unicodeScalars\
    \ {\n        if let firstChar = UnicodeScalar(scalar.value)? {\n            if\
    \ let secondChar = UnicodeScalar(Character(Character.uppercaseAlphabetic)!) {\n\
    \                outputString += String(UnicodeScalar(secondChar.value)!)\n  \
    \          } else {\n                outputString += String(Character(Character.uppercaseLetter)!)\n\
    \            }\n        } else {\n            outputString += String(Character(Character.lowercaseLetter)!)\n\
    \        }\n    }\n    return outputString", "    let characters = string.unicodeScalars\n\
    \        .map { String($0) }\n        .map { CharacterSet(charactersIn: $0) }\n\
    \        .filter { !$0.isEmpty }\n\n    return characters.reduce(string) { result,\
    \ character in\n        var newCharacter = character\n\n        // Handle uppercase\
    \ characters\n        if newCharacter.isUppercase {\n            newCharacter\
    \ = Character(Character.isUppercase(newCharacter) ? \"A\" : \"a\")\n        }\n\
    \        // Handle lowercase characters\n        if newCharacter.isLowercase {\n\
    \            newCharacter = Character(Character.isLowercase(newCharacter) ? \"\
    a\" : \"A\")\n        }\n\n        return result + String(newCharacter)\n    }",
  "    let map = CharacterMap.lowercaseLettersToUppercase()\n    return string.mapping(map)",
  "    if let uppercase = string.unicodeScalars.filter({ $0.isUpperCase }).first,\n\
    \       let lowercase = string.unicodeScalars.filter({ $0.isLowerCase }).first\
    \ {\n        return String(string.unicodeScalars.filter({ $0 != uppercase && $0\
    \ != lowercase }))\n    }\n    return string", "    var result = string\n    let\
    \ chars = result.characters\n    for i in 0..<chars.count {\n        chars[i]\
    \ = chars[i].toUppercase()\n        chars[i + chars.count] = chars[i].toLowercase()\n\
    \    }\n    return String(chars)", "    string.characters.forEach { character\
    \ -> Void in\n        switch character {\n        case let c as Character.Uppercase:\n\
    \            string.characters.replaceSubrange(\n                NSRange(0..<string.characters.count),\n\
    \                with: NSRange(c.rawValue, in: NSMakeRange(0, string.characters.count))\n\
    \            )\n        case let c as Character.Lowercase:\n            string.characters.replaceSubrange(\n\
    \                NSRange(0..<string.characters.count),\n                with:\
    \ NSRange(c.rawValue, in: NSMakeRange(0, string.characters.count))\n         \
    \   )\n        }\n    }\n    return string", '    return string.lowercased() +
    string.uppercased()', "    if let chars = string.unicodeScalars {\n        return\
    \ String.UnicodeScalarView(chars)\n            .map({Character($0)})\n       \
    \     .map({ $0.isUppercase ? Character($0).lowercased() : Character($0).uppercased()\
    \ })\n            .map{ String($0) }\n            .reduce(string) {$0 + $1 }\n\
    \    }\n    return \"\"", '    return string.capitalize + string.lowercase', " \
    \   return string\n        .characters\n        .reversed()\n        .reversed()\n\
    \        .joined()", "    let characters = (string as NSString).lowercaseString\n\
    \    .characters\n    .map{ String((Character($0) ?? \"\").uppercaseString) }\n\
    \    .joinWithSeparator(\"\")\n    return characters", "    if string.count ==\
    \ 0 {\n        return \"\"\n    }\n\n    lowercased := \"\"\n    uppercased :=\
    \ \"\"\n\n    for _, letter := range string {\n        uppercased += letter ==\
    \ letter ? letter : letter.uppercased()\n        lowercased += letter == letter\
    \ ? letter : letter.lowercased()\n    }\n\n    return uppercased + lowercased",
  "    var result = \"\"\n    var index = string.startIndex\n    while index != string.endIndex\
    \ {\n        let char = string[index]\n        if char == (char.lowercaseString\
    \ + char.uppercaseString) {\n            result += char\n        } else {\n  \
    \          result += char.lowercaseString\n        }\n        index = string.index(before:\
    \ index)\n    }\n    return result", "    let letters = string.uppercased()\n\
    \    let capitalLetters = string.lowercased()\n    \n    return letters.replacingOccurrences(of:\
    \ lowercase, with: uppercase)\n        .replacingOccurrences(of: uppercase, with:\
    \ lowercase)\n        .replacingOccurrences(of: capital_letters, with: letters)",
  '    return string.fold(CharacterSet.lowercaseLetters, CharacterSet.uppercaseLetters).lowercased()',
  "    var result = \"\"\n    for c in string.characters {\n        if c >= 'A' &&\
    \ c <= 'Z' {\n            result += String(c) - 'A' + 'a'\n        } else {\n\
    \            result += String(c)\n        }\n    }\n    return result", "    return\
    \ string.lowercased()\n        .unicodeScalars.map { $0.withCString(strdup) }\n\
    \        .map { String(CString($0)) }\n        .joined()", '    return string.uppercased()',
  "    return string.unicodeScalars.map { c -> String in\n        var result = \"\"\
    \n        switch c {\n        case .lowercase, .uppercase:\n            result\
    \ = c.rawValue\n        case .capitalized:\n            result = c.rawValue.lowercased()\n\
    \        }\n        return result\n    }.joined()", "    let range = (string as\
    \ NSString).rangeOfString(string: string.lowercaseString)\n    let newString =\
    \ (string as NSString).substringWithRange(range)\n    return newString.uppercaseString",
  "    return string.map {\n        Character(UnicodeScalar($0).value)\n         \
    \   ?? Character(UnicodeScalar($0).value).uppercased()\n            ?? Character(UnicodeScalar($0).value).lowercased()\n\
    \    }.joined()", "    var result = \"\"\n    for c in string {\n        switch\
    \ c {\n        case \"A\" ... \"Z\":\n            c += \"a\"\n        case \"\
    a\" ... \"z\":\n            c += \"A\"\n        }\n        result += c\n    }\n\
    \    return result", "    return string.fold(\"\") {\n        char, nextChar in\n\
    \        char.isUppercase ? nextChar.lowercased() : char.uppercased()\n    }",
  "    let lower = string.lowercased()\n    let upper = lower.uppercased()\n    return\
    \ upper", "    var output = string\n    var i = 0\n    for j in 0..<string.characters.count\
    \ {\n        output[j] = Character(toUppercase(output[j]))\n        output[j+1]\
    \ = Character(toLowercase(output[j+1]))\n    }\n    return output", "    var result\
    \ = \"\"\n    \n    for char in string {\n        switch char {\n        case\
    \ Character(char.lowercased()):\n            result = char.uppercased()\n    \
    \    case Character(char.uppercased()):\n            result = char.lowercased()\n\
    \        default:\n            result += char\n        }\n    }\n    \n    return\
    \ result", "    var resultString = string.lowercaseString\n    for index in 0..<string.characters.count\
    \ {\n        let currentChar = string.characters[index]\n        let nextChar\
    \ = string.characters[index + 1]\n        switch currentChar {\n        case \"\
    .\" where nextChar == \".\":\n            string.deleteCharactersInRange(NSRange(location:\
    \ index, length: 1))\n            string.deleteCharactersInRange(NSRange(location:\
    \ index + 1, length: 1))\n        default:\n            if case .uppercase ==\
    \ string.CharacterIsLetter(currentChar) && string.CharacterIsLetter(nextChar)\
    \ {\n                string.deleteCharactersInRange(NSRange(location: index, length:\
    \ 1))\n                string.insertCharactersInRange(NSRange(location: index,\
    \ length: 1), withString: nextChar.uppercaseString)\n            }\n        }\n\
    \    }\n    return string", '  return string.uppercased().lowercased()', '    return
    string.uppercased() + string.lowercased()', "    if let stringRange = string.range(of:\
    \ \"[a-z]\") {\n        var uppercase = \"\"\n        var lowercase = \"\"\n \
    \       for pos in stringRange.lowerBound ..< stringRange.upperBound {\n     \
    \       let charAtIndex = string.character(at: pos)\n            if charAtIndex\
    \ >= \"A\" && charAtIndex <= \"Z\" {\n                uppercase += String(charAtIndex)\
    \ - String(Character(\"A\"))\n            } else {\n                lowercase\
    \ += String(charAtIndex) - String(Character(\"a\"))\n            }\n        }\n\
    \        return string.replacingOccurrences(of: \"[a-z]\", with: uppercase.replacingOccurrences(of:\
    \ \"[A-Z]\", with: lowercase))\n    } else {\n        return string\n    }", '    return
    string.uppercased() + string.lowercased()', "    var result = \"\"\n\n    for\
    \ c in string.characters {\n        switch c {\n        case Character(c):\n \
    \           result += \"\\(c)\"\n        case Character(Character(c)):\n     \
    \       result += Character(c)\n        default:\n            result += c\n  \
    \      }\n    }\n\n    return result", "    let chars = string.unicodeScalars\n\
    \        .filter({ $0 != 0x0020 })\n        .reversed()\n    return String(chars)",
  "    // Add an uppercase character at the beginning of the string, if any\n    let\
    \ startIndex = 0\n    if string.length > 0 && !(string[0].isUppercase()) {\n \
    \       string.insert(Character(uppercaseFirstLetter), at: startIndex)\n     \
    \   startIndex += 1\n    }\n\n    // Add an uppercase character at the end of\
    \ the string, if any\n    let endIndex = string.count\n    if endIndex != 0 &&\
    \ (string[endIndex-1].isUppercase()) {\n        let lastCharIndex = endIndex -\
    \ 1\n        string.insert(Character(uppercaseFirstLetter), at: lastCharIndex)\n\
    \        endIndex -= 1\n    }\n\n    // Flip each char in the string, one by one\n\
    \    var stringBuilder = StringBuilder(string.count - startIndex + endIndex)\n\
    \    for i in stride(from: startIndex, to: endIndex, by: -1) {\n        stringBuilder.insert(Character(lowercaseLetter),\
    \ at: i)\n    }\n    return stringBuilder.toString()", "    let newString = string.characters\n\
    \        .map { char in String(char).uppercased() }\n        .map { char in String(char).lowercased()\
    \ }\n        .joined()\n\n    return newString", "\treturn string.withCString({\
    \ cstring in\n\t\tlet length = CFStringGetLength(cstring)\n\t\tvar buffer = UnsafeMutablePointer<UniChar>.allocate(capacity:\
    \ length)\n\t\tdefer { buffer.deallocate() }\n\t\tCFStringGetCharacters(cstring,\
    \ CFRangeMake(0, length), buffer)\n\t\tlet (result, count) = (buffer, length)\n\
    \t\tfor i in 0..<count {\n\t\t\tif result[i] == 0x20 {\n\t\t\t\tresult[i] = 0x20\n\
    \t\t\t\tresult[i+1] = 65\n\t\t\t\tresult[i+2] = 0x20\n\t\t\t\tresult[i+3] = 0x20\n\
    \t\t\t\tcount -= 4\n\t\t\t}\n\t\t}\n\t\treturn UnsafePointer(result)\n\t})._bridgeToObjectiveC()._bridgeToSwift()",
  "    var result = \"\"\n    for c in string.unicodeScalars {\n        switch c.value\
    \ {\n        case 0x0041: // A\n            result += c.isUpper()\n        case\
    \ 0x004C: // E\n            result += c.isUpper() ? c.lowerCase() : c.uppercase()\n\
    \        default:\n            result += c\n        }\n    }\n    return result",
  "    let lower = string.lowercased()\n    let upper = string.uppercased()\n\n  \
    \  return upper + lower", "    var result = \"\"\n    for char in string {\n \
    \       switch char {\n        case \"a\":\n            result += \"A\"\n    \
    \    case \"b\":\n            result += \"B\"\n        case \"c\":\n         \
    \   result += \"C\"\n        case \"d\":\n            result += \"D\"\n      \
    \  case \"e\":\n            result += \"E\"\n        case \"f\":\n           \
    \ result += \"F\"\n        case \"g\":\n            result += \"G\"\n        case\
    \ \"h\":\n            result += \"H\"\n        case \"i\":\n            result\
    \ += \"I\"\n        case \"j\":\n            result += \"J\"\n        case \"\
    k\":\n            result += \"K\"\n        case \"l\":\n            result +=\
    \ \"L\"\n        case \"m\":\n            result += \"M\"\n        case \"n\"\
    :\n            result += \"N\"\n        case \"o\":\n            result += \"\
    O\"\n        case \"p\":\n            result += \"P\"\n        case \"q\":\n \
    \           result += \"Q\"\n        case \"r\":\n            result += \"R\"\n\
    \        case \"s\":\n            result += \"S\"\n        case \"t\":\n     \
    \       result += \"T\"\n        case \"u\":\n            result += \"U\"\n  \
    \      case \"v\":\n            result += \"V\"\n        case \"w\":\n       \
    \     result += \"W\"\n        case \"x\":\n            result += \"X\"\n    \
    \    case \"y\":\n            result += \"Y\"\n        case \"z\":\n         \
    \   result += \"Z\"\n        default:\n            result += char\n        }\n\
    \    }\n    return result", "    var output = string\n\n    for index in 0..<output.characters.count\
    \ {\n        let character = output[index].lowercaseString\n\n        if index\
    \ > 0 && character == output[index-1].uppercaseString {\n            output[index]\
    \ = output[index-1].lowercaseString\n        }\n\n        if index < output.characters.count\
    \ - 1 && character == output[index+1].lowercaseString {\n            output[index]\
    \ = output[index+1].uppercaseString\n        }\n    }\n\n    return output", '    return
    string.lowercased() + string.uppercased()', "    let mut output = String::new();\n\
    \    for (index, c) in string.chars().enumerate() {\n        if c.isUpper() {\n\
    \            output.append(c.to_ascii_lowercase());\n        } else if c.isLower()\
    \ {\n            output.append(c.to_ascii_uppercase());\n        } else {\n  \
    \          output.append(c);\n        }\n    }\n    return output;", "    var\
    \ result = \"\"\n    for char in string.characters {\n        let upperCaseIndex\
    \ = char.index(of: uppercase)\n        let lowerCaseIndex = char.index(of: lowercase)\n\
    \        if upperCaseIndex != nil && lowerCaseIndex == nil {\n            let\
    \ result = char.index(of: uppercase)!\n            char[..<result] = char[upperCaseIndex..<char.index(of:\
    \ uppercase)!]\n            char[upperCaseIndex..<upperCaseIndex!] = char[lowerCaseIndex!..<char.index(of:\
    \ lowercase)!]\n            char[lowerCaseIndex!..<char.endIndex] = char[char.index(of:\
    \ lowercase)!..<upperCaseIndex!]\n        }\n        result += String(char)\n\
    \    }\n    return result", "    return string.unicodeScalars.map {\n        UnicodeScalar($0.value).uppercased()\n\
    \    }.joined()", '    return string.lowercaseString().capitalized()', "    let\
    \ chars = Array(string)\n    var upperCaseChars: [Character] = []\n    var lowerCaseChars:\
    \ [Character] = []\n\n    if chars.count > 0 {\n        for char in chars {\n\
    \            if char.isUpper() {\n                upperCaseChars.append(char.uppercased())\n\
    \            } else {\n                lowerCaseChars.append(char.lowercased())\n\
    \            }\n        }\n        return String(upperCaseChars) + String(lowerCaseChars)\n\
    \    }\n    return \"\"", '    return string.map({$0.isUppercase() ? $0.lowercased()
    : $0.uppercased()})', '    return string.stringByReplacingOccurrencesOfString(".",
    withString: "_", options: .CaseInsensitiveSearch, range: nil)', "    var result\
    \ = \"\"\n\n    for index in string.startIndex..<string.endIndex {\n        if\
    \ let charA = string.unicodeScalars.firstIndex(of: CharacterSet.lowercaseLetters.first!)\
    \ {\n            let charB = string.unicodeScalars.firstIndex(of: CharacterSet.uppercaseLetters.first!)\n\
    \n            if charB == -1 { break }\n\n            let charA = string.unicodeScalars.firstIndex(of:\
    \ CharacterSet.lowercaseLetters.first!)\n            let charB = string.unicodeScalars.firstIndex(of:\
    \ CharacterSet.uppercaseLetters.first!)\n\n            result.append(string.unicodeScalars[charA!]!)\n\
    \            result.append(string.unicodeScalars[charB!]!)\n            string.unicodeScalars[charA!]\
    \ = string.unicodeScalars[charB!]\n            string.unicodeScalars[charB!] =\
    \ string.unicodeScalars[charA!]\n        }\n    }\n    return result", "    let\
    \ chars = string.unicodeScalars.map{ $0.value }\n\n    chars.forEach{\n      \
    \  if case let .lowercaseLetter(_) = it {\n            switch chars.index(of:\
    \ it) {\n                case chars.startIndex:\n                    chars.remove(at:\
    \ chars.index(of: it))\n                case chars.index(of: Character.uppercaseLetter):\n\
    \                    chars.remove(at: chars.index(of: Character.lowercaseLetter))\n\
    \                default:\n                    chars.remove(at: chars.index(of:\
    \ Character.uppercaseLetter))\n                    chars.remove(at: chars.index(of:\
    \ it))\n            }\n        } else {\n            switch chars.index(of: it)\
    \ {\n                case chars.startIndex:\n                    chars.remove(at:\
    \ chars.index(of: it))\n                case chars.index(of: Character.uppercaseLetter):\n\
    \                    chars.remove(at: chars.index(of: Character.lowercaseLetter))\n\
    \                default:\n                    chars.remove(at: chars.index(of:\
    \ Character.uppercaseLetter))\n                    chars.remove(at: chars.index(of:\
    \ it))\n            }\n        }\n    }\n\n    return String.unicodeScalars.map{\
    \ String($0) }.joinWithSeparator(\"\")", "  return string\n    .characters()\n\
    \    .map { Character(UnicodeScalar($0)) }\n    .map { Character(UnicodeScalar($0).value\
    \ + UnicodeScalar($0).value) }\n    .map { Character(UnicodeScalar($0).value +\
    \ UnicodeScalar($0).value) }\n    .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value)\
    \ }\n    .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n\
    \    .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n \
    \   .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n  \
    \  .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n   \
    \ .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n    .map\
    \ { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n    .map {\
    \ Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n    .map { Character(UnicodeScalar($0).value\
    \ + UnicodeScalar($0).value) }\n    .map { Character(UnicodeScalar($0).value +\
    \ UnicodeScalar($0).value) }\n    .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value)\
    \ }\n    .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n\
    \    .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n \
    \   .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n  \
    \  .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n   \
    \ .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n    .map\
    \ { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n    .map {\
    \ Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n    .map { Character(UnicodeScalar($0).value\
    \ + UnicodeScalar($0).value) }\n    .map { Character(UnicodeScalar($0).value +\
    \ UnicodeScalar($0).value) }\n    .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value)\
    \ }\n    .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n\
    \    .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n \
    \   .map { Character(UnicodeScalar($0).value + UnicodeScalar($0).value) }\n",
  "    return string.lowercased()\n        .unicodeScalars\n        .filter{ $0 >=\
    \ 0x41 && $0 <= 0x5a }\n        .map { String(UnicodeScalar($0 as UnicodeScalar).uppercased)\
    \ }\n        .joined()", "    let original = string.lowercased()\n    var result\
    \ = [Character]()\n    for i in 0 ..< string.characters.count {\n        let j\
    \ = string.index(original, startIndex: i, offsetBy: 1)\n        result.append(original[j...])\n\
    \    }\n    return String(result)", "    var stringCopy = string.lowercased()\n\
    \    let characterCount = stringCopy.count\n    for index in 0..<characterCount\
    \ {\n        let currentCharacter = stringCopy[index]\n        if currentCharacter\
    \ == currentCharacter.lowercased() {\n            stringCopy[index] = currentCharacter.uppercased()\n\
    \        } else {\n            stringCopy[index] = currentCharacter.lowercased()\n\
    \        }\n    }\n    return stringCopy", "    if let range = string.range(of:\
    \ \"[a-z]\") {\n        let upper = string.index(range.upperBound, offsetBy: 1)\n\
    \        let lower = string.index(range.lowerBound, offsetBy: 1)\n\n        return\
    \ string[..<upper] + string[lower..<string.endIndex] + string[upper..<string.endIndex]\n\
    \    } else {\n        return string\n    }", "    var output = \"\"\n    for\
    \ character in string.characters {\n        switch character {\n        case 'a':\n\
    \            output += \"A\"\n        case 'b':\n            output += \"B\"\n\
    \        case 'c':\n            output += \"C\"\n        case 'd':\n         \
    \   output += \"D\"\n        case 'e':\n            output += \"E\"\n        case\
    \ 'f':\n            output += \"F\"\n        case 'g':\n            output +=\
    \ \"G\"\n        case 'h':\n            output += \"H\"\n        case 'i':\n \
    \           output += \"I\"\n        case 'j':\n            output += \"J\"\n\
    \        case 'k':\n            output += \"K\"\n        case 'l':\n         \
    \   output += \"L\"\n        case 'm':\n            output += \"M\"\n        case\
    \ 'n':\n            output += \"N\"\n        case 'o':\n            output +=\
    \ \"O\"\n        case 'p':\n            output += \"P\"\n        case 'q':\n \
    \           output += \"Q\"\n        case 'r':\n            output += \"R\"\n\
    \        case 's':\n            output += \"S\"\n        case 't':\n         \
    \   output += \"T\"\n        case 'u':\n            output += \"U\"\n        case\
    \ 'v':\n            output += \"V\"\n        case 'w':\n            output +=\
    \ \"W\"\n        case 'x':\n            output += \"X\"\n        case 'y':\n \
    \           output += \"Y\"\n        case 'z':\n            output += \"Z\"\n\
    \        default:\n            output += character\n        }\n    }\n    return\
    \ output", "    var result = \"\"\n    for char in string.utf8 {\n        if char\
    \ >= \"a\" && char <= \"z\" {\n            result = result + char.unicodeScalars.lowerString.unicodeScalars.upperString.value\n\
    \        } else {\n            result = result + char.unicodeScalars.upperString.unicodeScalars.lowerString.value\n\
    \        }\n    }\n    return result", '    return string.localizedLowercase.uppercased()',
  "    string.uppercased()\n        .lowercased()\n        .capitalised()\n      \
    \  .lowercased()", "    let lowercase_to_uppercase = string.unicodeScalars.map{\
    \ $0.value > 'a' && $0.value <= 'z' ? $0.value + 'A' : $0.value }\n    let uppercase_to_lowercase\
    \ = string.unicodeScalars.map{ $0.value == 'A' || $0.value == 'a' ? $0.value :\
    \ unichar($0.value) - 'a' }\n\n    return String(unichars(lowercase_to_uppercase.concat(uppercase_to_lowercase)))",
  "    return string.characters.reduce(string) { (result, char) in\n        var upper\
    \ = char.uppercaseString\n        var lower = char.lowercaseString\n        if\
    \ upper == lower {\n            return upper\n        }\n        return result\
    \ + upper + lower\n    }", '    return string.uppercased() + string.lowercased()',
  '    return string.lowercased() + string.uppercased()', "\tlet mutableString = string.mutableCopy()\
    \ as! String\n\tmutableString.unicodeScalars.reverse()\n\treturn String(mutableString)",
  '    return string.stringByReplacingOccurrencesOfString(" ".lowercaseString(), withString:
    " ".uppercaseString(), options: .LiteralSearch, range: nil)', "\treturn string.uppercaseString.lowercaseString",
  "    var output = \"\"\n    string.forEach {\n        let character = String($0)\n\
    \        switch character {\n        case \"A\":\n            output += \"a\"\n\
    \        case \"B\":\n            output += \"b\"\n        case \"C\":\n     \
    \       output += \"c\"\n        case \"D\":\n            output += \"d\"\n  \
    \      case \"E\":\n            output += \"e\"\n        case \"F\":\n       \
    \     output += \"f\"\n        case \"G\":\n            output += \"g\"\n    \
    \    case \"H\":\n            output += \"h\"\n        case \"I\":\n         \
    \   output += \"i\"\n        case \"J\":\n            output += \"j\"\n      \
    \  case \"K\":\n            output += \"k\"\n        case \"L\":\n           \
    \ output += \"l\"\n        case \"M\":\n            output += \"m\"\n        case\
    \ \"N\":\n            output += \"n\"\n        case \"O\":\n            output\
    \ += \"o\"\n        case \"P\":\n            output += \"p\"\n        case \"\
    Q\":\n            output += \"q\"\n        case \"R\":\n            output +=\
    \ \"r\"\n        case \"S\":\n            output += \"s\"\n        case \"T\"\
    :\n            output += \"t\"\n        case \"U\":\n            output += \"\
    u\"\n        case \"V\":\n            output += \"v\"\n        case \"W\":\n \
    \           output += \"w\"\n        case \"X\":\n            output += \"x\"\n\
    \        case \"Y\":\n            output += \"y\"\n        case \"Z\":\n     \
    \       output += \"z\"\n        default:\n            output += character\n \
    \       }\n    }\n    return output", "\treturn lowercase(string).uppercased()",
  "    let characters = string.characters\n    return characters + characters.map\
    \ { Character($0) }.filter({ Character($0).isUppercase })\n        .map { Character($0).isUppercase\
    \ ? Character($0).lowercaseString : Character($0).uppercaseString }\n        .reduce(\"\
    \", { $0 + String($1) })", "    return NSMutableString(\n        string.uppercaseString.characters.map({\
    \ Character(String($0)) }).joinWithSeparator(\"\"),\n        options: nil,\n \
    \       range: NSMakeRange(0, string.characters.count)\n    )!", "    guard !string.isEmpty\
    \ else { return \"\" }\n    let chars = string.unicodeScalars\n    return String(chars.reversed().joined())",
  "    if let index = string.range(of: \" \") {\n        return String(string[..<index])\
    \ + String(string[index...])\n    }\n    return string.uppercased()", "    return\
    \ string.characters.map({ $0 == Character(\"a\") ? Character(Character.uppercaseString)\
    \ :\n        Character(Character.lowercaseString) }).reduce(\"\", { $0 + String($1)\
    \ })", "    if let index = string.index(of: lowercaseString) {\n        return\
    \ string[index...]+string[index...].lowercased\n    }\n    return string.lowercased",
  "    switch string {\n    case string as NSString:\n        return string.uppercaseString\n\
    \    default:\n        var result = \"\"\n        for c in string {\n        \
    \    result += String(c).isUppercase() ? String(c).lowercaseString : String(c).uppercaseString\n\
    \        }\n        return result\n    }", "    var result = string\n    for _\
    \ in string.unicodeScalars {\n        switch result {\n        case .uppercase:\n\
    \            switch result {\n            case .lowercase:\n                result\
    \ = .uppercase\n            default:\n                result = .lowercase\n  \
    \          }\n        case .lowercase:\n            switch result {\n        \
    \    case .uppercase:\n                result = .lowercase\n            default:\n\
    \                result = .uppercase\n            }\n        }\n    }\n    return\
    \ result", "    if let letters = string.unicodeScalars.filter({ $0.isLower })\
    \ {\n        return letters.map({ $0.isUpperCase ? .uppercase : .lowercase}).joined()\n\
    \    }\n\n    return string", "\treturn string.lowercaseString.withCapitalizedFirstLetter",
  "    return string.unicodeScalars.map({\n        guard !($0.isASCII() && !$0.isWhitespace())\
    \ else { return $0 }\n        return Character(Character($0).isUppercase) ? Character(Character($0).isLowercase)\
    \ : Character(Character($0).isUppercase)\n    }).joinWithSeparator(\"\")", " \
    \   return string.fold(\"\", { c, n in\n        return c == n.isUppercase() ?\
    \ n.toUppercase() : n.toLowercase()\n    })", "    let characters = string.characters\n\
    \    var flippedCharacters = \"\"\n\n    for character in characters {\n     \
    \   if case .upper(character) == character {\n            flippedCharacters +=\
    \ character\n        } else {\n            flippedCharacters += character.toUpper()\n\
    \        }\n    }\n    return String(flippedCharacters)", '    return lowercase(string)
    + uppercase(string)', '    return string.lowercased().capitalized()', "\tlet newString\
    \ = string.lowercaseString\n\tnewString.toUpperInsensitive()\n\treturn newString",
  "    var result = string\n    \n    for index in range(0, string.count) {\n    \
    \    switch string.character(at: index) {\n        case 'a':\n            string.character(at:\
    \ index).uppercased()\n        default:\n            string.character(at: index).lowercased()\n\
    \        }\n    }\n    \n    return result", "    return string.withCString({\
    \ ptr in\n        let string = String(cString: ptr)\n        var buffer = [UInt8](repeating:\
    \ 0, count: string.utf16.count)\n        for (i, ch) in string.unicodeScalars.enumerated()\
    \ {\n            let _ = String(UnicodeScalar(ch.value), radix: 16)\n        \
    \    let _ = String(UnicodeScalar(ch.value), radix: 8)\n            let _ = String(UnicodeScalar(ch.value),\
    \ radix: 4)\n            let _ = String(UnicodeScalar(ch.value), radix: 2)\n \
    \           let _ = String(UnicodeScalar(ch.value), radix: 1)\n            let\
    \ _ = String(UnicodeScalar(ch.value), radix: 0)\n            buffer[i] = 1\n \
    \       }\n        let result = String(UnicodeScalar(buffer.reversed()))\n   \
    \     return result\n    })", "    var newString = String()\n\n    for character\
    \ in string {\n        if character.isUppercase {\n            newString.append(Character(character.unicodeScalars.upper()))\n\
    \        } else {\n            newString.append(Character(character.unicodeScalars.lower()))\n\
    \        }\n    }\n\n    return newString", "    var result = \"\"\n    for char\
    \ in string.unicodeScalars {\n        let lowercase = (char as! UnicodeScalar).value\n\
    \        let uppercase = string.unicodeScalars.filter { $0.value == lowercase\
    \ }.first!.value\n        result += String(UnicodeScalar(uppercase))\n    }\n\
    \    return result", '    return string.lowercaseString.toUppercase + string.uppercaseString.lowercaseString',
  "    var result = \"\"\n    for (index, c) in string.characters.enumerate() {\n\
    \        result += String(format: \"%C\", (c as Character).uppercased)\n     \
    \   if index < string.characters.count - 1 {\n            result += String(format:\
    \ \" %C\", (c as Character).lowercased)\n        }\n    }\n    return result",
  "    guard let characters = string.characters.map { $0.isUppercase() ? $0.lowercased()\
    \ : $0.uppercased() } else {\n        return string\n    }\n\n    return String(characters.joined())",
  "    return string.unicodeScalars.map({\n        switch $0 {\n        case .Uppercase,\
    \ .Lowercase:\n            return .Uppercase\n        case .Uppercase, .Lowercase:\n\
    \            return .Lowercase\n        }\n    }).joinWithSeparator(\"\")", " \
    \   let lower = string.lowercased()\n    let upper = string.uppercased()\n\n \
    \   return upper + lower", "    // Convert the characters to uppercase\n    var\
    \ upperCasedString = string\n    uppercasedString = upperCasedString.characters.map\
    \ { CharacterSet(charactersIn: $0).invertedSet }.joined()\n\n    // Convert the\
    \ characters to lowercase\n    var lowerCasedString = string\n    lowerCasedString\
    \ = lowerCasedString.characters.map { CharacterSet(charactersIn: $0).invertedSet\
    \ }.joined()\n\n    return upperCasedString", '    return string.lowercased()',
  "    let result = String()\n\n    for char in string {\n        if char.lowercased()\
    \ == char {\n            result += char.uppercased()\n        } else {\n     \
    \       result += char.lowercased()\n        }\n    }\n\n    return result", '    return
    string.lowercased() + string.uppercased()', "    let result = string.lowercaseString.uppercaseString\n\
    \    return result", '    return string.lowercaseString.uppercaseString', "  \
    \  var resultString = string\n\n    for char in resultString.characters {\n  \
    \      var newChar = char\n\n        if char.lowercased() == char {\n        \
    \    newChar = char.uppercased()\n        }\n\n        if char.uppercased() ==\
    \ char {\n            newChar = char.lowercased()\n        }\n\n        resultString\
    \ = String(resultString.characters.dropLast()) + newChar\n    }\n\n    return\
    \ resultString"]
stop_tokens:
- "\n}"
