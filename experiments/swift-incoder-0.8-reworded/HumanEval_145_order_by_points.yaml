name: HumanEval_145_order_by_points
language: swift
prompt: "\n/// Write a function which sorts the given array of integers\n/// in ascending\
  \ order according to the sum of their digits.\n/// Note: if there are several items\
  \ with similar sum of their digits,\n/// order them based on their index in original\
  \ array.\n/// For example:\n/// >>> order_by_points(nums: [1, 11, -1, -11, -12])\n\
  /// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums: [] as [Int])\n/// [] as\
  \ [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12])\
  \ == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
  \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
  \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3])\
  \ == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3,\
  \ 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
  \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
completions: ["    var nums_copy = [Int](nums)\n    if nums_copy.count == 0 {\n  \
    \      return nums_copy\n    }\n\n    var sums = [Int]()\n    for i in 0..<nums_copy.count\
    \ {\n        let sum = nums_copy[i]\n        if sum != 0 && sums.count < nums_copy.count\
    \ {\n            sums.append(sum)\n        }\n    }\n    \n    // Sort the sums\
    \ first\n    var indices = [Int]()\n    for i in 0..<sums.count {\n        let\
    \ idx = sums.index(of: sums[i])!\n        indices.append(idx)\n    }\n    indices.sortInPlace()\n\
    \    \n    // And finally the original array\n    var sorted_nums = [Int]()\n\
    \    for i in 0..<indices.count {\n        let idx = indices[i]\n        sorted_nums.append(nums_copy[idx])\n\
    \    }\n    return sorted_nums", "    let sorted = nums.sorted()\n    let lookup\
    \ = Int((sorted.reduce(0) { a, b in\n        let digit = a%10 + b%10\n       \
    \ return digit\n    }) / 10)\n    let sorted = sorted.map { x in\n        if x\
    \ < 0 {\n            return -x\n        } else {\n            return lookup[x]\n\
    \        }\n    }\n    return sorted", "  if nums == nil || nums.isEmpty {\n \
    \   return nums\n  }\n\n  var maxSum = nums.reduce(0) { $0 + $1 }\n  var maxIndex\
    \ = -1\n  for i in 0 ..< nums.count {\n    let sum = nums[i]\n    if sum > maxSum\
    \ {\n      maxSum = sum\n      maxIndex = i\n    }\n  }\n\n  nums[maxIndex] =\
    \ nums.count\n  return nums", "    if nums.isEmpty() { return nums }\n    var\
    \ result = nums\n    let set = Set<Int>()\n    for num in result {\n        if\
    \ !set.contains(num) {\n            set.insert(num)\n            result.insert(num)\n\
    \        }\n    }\n    return result", "    var max_sum: Int = 0\n    let max_num\
    \ = nums.first!\n    let len = nums.count\n    for num in nums.dropFirst() {\n\
    \        let sum = sumDigits(num)\n        if sum > max_sum {\n            max_sum\
    \ = sum\n            max_num = num\n        }\n    }\n    return nums.filter({\
    \ sumDigits($0) == max_sum }).sorted(by: { sumDigits($0) < sumDigits($1) })",
  "    var _sum: Int = 0\n    var minSum: Int = 100000000000000\n    var minIndex:\
    \ Int = -1\n    for value in nums {\n        let digit = value\n        _sum +=\
    \ digit\n        if _sum < minSum {\n            minSum = _sum\n            minIndex\
    \ = value\n        }\n    }\n    if minSum == 0 {\n        return nums\n    }\n\
    \n    // find all values with similar sum of digits\n    var groups = Dictionary(grouping:\
    \ nums, by: { $0.truncatingRemainder(dividingBy: 10).truncatingRemainder(dividingBy:\
    \ 10) })\n    var sortedArray = [Int]()\n    for pair in groups {\n        let\
    \ index = nums.firstIndex(of: pair)!\n        if index < minIndex {\n        \
    \    continue\n        }\n        // insert at index\n        sortedArray.insert(pair,\
    \ at: index)\n    }\n    return sortedArray", "    if nums.isEmpty {\n       \
    \ return nums\n    }\n    var sorted = nums.sorted()\n    for index in 0..<nums.count\
    \ {\n        var sum = 0\n        var sumOfDigits = 0\n        for n in sorted\
    \ {\n            sum += n\n            sumOfDigits += Int(Double(n))\n       \
    \ }\n        if sumOfDigits == 0 {\n            sumOfDigits = 1\n        }\n \
    \       sorted = sorted ~ (index)\n        if sumOfDigits > sorted[0] {\n    \
    \        sorted = sorted ~ (index)\n        }\n    }\n    return sorted as [Int]",
  "    var sum = nums.reduce(0, +) // 0 is the initial sum of nums\n    var i = 0\n\
    \    while i < nums.count {\n        var digit = nums[i] % 10\n        sum +=\
    \ digit\n        // if current sum greater than previous ones, swap\n        if\
    \ sum > 0 {\n            // remove first element\n            swap(&nums[i], &nums[--nums.count])\n\
    \            // add all remaining elements\n            while i < nums.count {\n\
    \                digit = nums[i] % 10\n                sum += digit\n        \
    \        // if current sum greater than previous ones, swap\n                if\
    \ sum > 0 {\n                    // remove first element\n                   \
    \ swap(&nums[i], &nums[--nums.count])\n                }\n            }\n    \
    \    } else {\n            // remove first element\n            swap(&nums[i],\
    \ &nums[--nums.count])\n        }\n    }\n    return nums", "    \n    var numsWithPoints\
    \ = nums.map { $0 + $0 }\n    \n    var pointSum = numsWithPoints.reduce(0)\n\
    \    \n    var minPointIndex = 0\n    var maxPointIndex = numsWithPoints.count\
    \ - 1\n    \n    while pointSum > 0 {\n        if pointSum < 10 {\n          \
    \  numsWithPoints[minPointIndex] += 1\n            pointSum -= 10\n        } else\
    \ {\n            numsWithPoints[minPointIndex] += 10\n            numsWithPoints[maxPointIndex]\
    \ -= 10\n            pointSum -= 10\n        }\n        minPointIndex += 1\n \
    \       maxPointIndex -= 1\n    }\n    \n    return numsWithPoints", "    var\
    \ _max = UInt64(0)\n    var _min = UInt64(0)\n    var _sum = UInt64(0)\n\n   \
    \ if nums.isEmpty {\n        return []\n    }\n    for num in nums {\n       \
    \ let digits = num.digits\n        var dSum = UInt64(0)\n        for digit in\
    \ digits {\n            dSum += UInt64(digit)\n        }\n        if dSum != _sum\
    \ {\n            _sum = dSum\n            _max = UInt64(0)\n            _min =\
    \ UInt64(0)\n        }\n        if dSum > _sum {\n            if dSum > _max {\n\
    \                _max = dSum\n                _max = UInt64(digits.reduce(0) {\
    \ $0 + UInt64($1) })\n            }\n            if dSum < _min {\n          \
    \      _min = dSum\n                _min = UInt64(digits.reduce(0) { $0 + UInt64($1)\
    \ })\n            }\n        }\n    }\n    let _sorted = nums.sorted { $0.digits\
    \ > $1.digits }\n    return _sorted.map { $0.digits[_min..<_max] }", "    if nums.isEmpty\
    \ {\n        return nums\n    }\n\n    let maxSum = find_max_sum(nums)\n    if\
    \ maxSum == 0 {\n        return nums\n    }\n\n    var result = nums\n    let\
    \ sortedPoints = find_sorted_points(nums, maxSum)\n    for point in sortedPoints\
    \ {\n        let index = find_index(nums, point, maxSum)\n        if index !=\
    \ nil {\n            result[index!] = point\n        }\n    }\n\n    return result",
  "    let result = nums\n        .enumerated()\n        .filter { index, value in\n\
    \            return value.sumValue > 0 && value.sumValue < UInt32(10) == value.sumValue\n\
    \        }\n        .map { index, value in\n            value.sumValue\n     \
    \   }\n        .sorted()\n        .map { index, value in\n            index\n\
    \        }\n        .map { value in\n            value(&result)\n        }\n \
    \   return result", "    return nums.sorted { a, b in\n        let digitA = String(a).characters\n\
    \        let digitB = String(b).characters\n        var sum = 0\n        for d\
    \ in digitA {\n            sum += Int(d)!\n        }\n        for d in digitB\
    \ {\n            sum += Int(d)!\n        }\n        return sum > 0 ? 1 : -1\n\
    \    }", "    var numsWithSum = nums.map() {\n        if let num = $0 {\n    \
    \        let digits = String(num).digits\n            let sumDigits = digits.reduce(0,\
    \ +)\n            return sumDigits\n        }\n        return Int64(0) // for\
    \ empty list\n    }\n    return numsWithSum.sorted()", "    var result = [Int]()\n\
    \    for i in nums {\n        if i == -1 {\n            return result\n      \
    \  }\n        let digits = String(i).components(separatedBy: CharacterSet.decimalDigits.inverted).flatMap\
    \ { Int($0) }\n        let sum: Int = digits.reduce(0, +)\n        if result.contains(where:\
    \ { $0 == sum }) {\n            result.sort(by: { $0 < $1 })\n        } else {\n\
    \            result.append(i)\n        }\n    }\n    return result", "    return\
    \ Array(nums).sorted(by: { a, b in\n        let ac = a / 10\n        let bc =\
    \ b / 10\n        if ac != bc { return ac < bc }\n        let ab = a - ac * 10\n\
    \        return ab\n    })", "    var sum = 0\n    var lastSum = 0\n    for v\
    \ in nums {\n        sum += v\n        lastSum = sum\n    }\n    var sorted: Array<Int>\
    \ = []\n    for v in nums {\n        var newSum = sum - v\n        if newSum ==\
    \ lastSum {\n            sorted.append(v)\n        } else {\n            if newSum\
    \ > lastSum { sorted.append(v) }\n        }\n    }\n    return sorted as! [Int]",
  '    return sorted(nums, by: sum)', "    if nums == nil {\n        return nums\n\
    \    }\n    var numsSorted = [Int]()\n    let len = nums.count\n    for i in 0..<len\
    \ {\n        let digitSum = nums[i].truncatingRemainder(dividingBy: 10)\n    \
    \    switch digitSum {\n        case 0:\n            numsSorted.append(nums[i])\n\
    \        case 1:\n            numsSorted.append(nums[i])\n        case 2:\n  \
    \          numsSorted.append(nums[i])\n        case 3:\n            numsSorted.append(nums[i])\n\
    \        case 4:\n            numsSorted.append(nums[i])\n        case 5:\n  \
    \          numsSorted.append(nums[i])\n        case 6:\n            numsSorted.append(nums[i])\n\
    \        case 7:\n            numsSorted.append(nums[i])\n        case 8:\n  \
    \          numsSorted.append(nums[i])\n        case 9:\n            numsSorted.append(nums[i])\n\
    \        default:\n            numsSorted.append(nums[i])\n        }\n    }\n\
    \    return numsSorted", "    func cmp(left: Int, right: Int) -> Bool {\n    \
    \    let left = Int(left, radix: 10)\n        let right = Int(right, radix: 10)\n\
    \        let sum = left + right\n        return sum < 0 ? true : sum == 0 ? false\
    \ : left < right\n    }\n    return nums.sorted(by: cmp)", "    let numsSum =\
    \ nums.reduce(0, +)\n    return nums.sorted()\n        .sorted(by: { $0.0 % 10\
    \ > $1.0 % 10 || ($0.0 < $1.0 && $0.0 < numsSum) })", "    var sortedNums = [Int]()\n\
    \    var seenDigits = [Int]()\n    \n    for n in nums {\n        seenDigits.append(0)\n\
    \    }\n    \n    for n in nums {\n        for d in n / 10 {\n            if let\
    \ idx = seenDigits.index(of: d) {\n                sortedNums[idx] += n\n    \
    \        }\n        }\n    }\n    \n    return sortedNums", "  guard !nums.isEmpty\
    \ else {\n    return []\n  }\n  // nums is [Int], so get its first element and\
    \ make it an Int.\n  let x = nums.first!\n  var sum = 0\n  for y in nums {\n \
    \   if y > 0 {\n      sum += y * 10\n    }\n  }\n  var result = [Int]()\n  var\
    \ index = nums.startIndex\n  for num in nums {\n    if num > 0 {\n      result.append(index)\n\
    \    }\n    sum += num * 10\n    index++\n  }\n  // If sum is positive, sort based\
    \ on its digits;\n  // otherwise, sort based on its original order.\n  if sum\
    \ > 0 {\n    result = result.sorted()\n  } else {\n    result = result.sorted{\
    \ $0 < $1 }\n  }\n  return result", '    return nums.sorted(by: ascending_digits)',
  "    if nums.isEmpty() {\n        return []\n    }\n    // get sum of digits in\
    \ nums, set max sum as 9\n    let maxSum: Int = nums.reduce(0, {$0 + $1 })\n \
    \   // sort nums based on sum of digits\n    let orderedNums = nums.sorted{ $0.reduce(0,\
    \ {$0 + $1})  > $1.reduce(0, {$0 + $1})  }\n    // map original num to ordered\
    \ num\n    let resultNums = orderedNums.map { num in\n        return nums.indexOf(num)\
    \ * maxSum + num\n    }\n    return resultNums", "    var sorted = [Int]()\n \
    \   var prev = 0\n    var curr = 0\n    for v in nums {\n        curr = (prev\
    \ * 10) + v\n        prev = int(curr)\n        if sorted.contains(prev) {\n  \
    \          sorted.remove(prev)\n            sorted.append(prev)\n        } else\
    \ {\n            sorted.append(prev)\n        }\n    }\n    return sorted", " \
    \ guard let nums0 = nums as? [Int] else { return [] }\n  let sorted: [[Int]] =\
    \ []\n  while let first = nums0.first {\n    let rest = nums0.dropFirst()\n  \
    \  let first = Int(first)\n    var found = false\n    for rest in rest {\n   \
    \   found = found || (rest >= first)\n    }\n    if !found {\n      sorted.append([first])\n\
    \    }\n  }\n  var last = 0\n  for nums in sorted {\n    if nums.last > last {\n\
    \      last = nums.last\n    }\n  }\n  let newNums0 = nums0.map { Int($0) }\n\
    \  var newNums = nums0.map { $0 }\n  for newNums in sorted {\n    newNums += last\n\
    \  }\n  return newNums0", "    // create new array for output\n    var numsSorted\
    \ = nums.sorted()\n\n    // initialize a variable to hold the sum of the digits\n\
    \    var sumOfDigits = 0\n\n    // for each element in the input\n    for i in\
    \ numsSorted {\n        // add its digits to our sum so far\n        sumOfDigits\
    \ += Int(i)\n\n        // if the sum is more than 10, this means we have a new\
    \ item\n        // we need to check for\n        if sumOfDigits > 10 {\n     \
    \       // save the index of the new item\n            let index = numsSorted.index{$0\
    \ > i}\n\n            // add the new item to the output\n            numsSorted.insert(numsSorted[index],\
    \ at: index)\n            sumOfDigits -= 10\n        }\n    }\n    return numsSorted",
  "    if nums.isEmpty {\n        return nums\n    }\n    let len = nums.count\n \
    \   let sortedPoints = (0..<len).sorted { nums[$0] > nums[$1] }\n    var res =\
    \ nums.sorted()\n    for index in sortedPoints {\n        let tmp = res[index]\n\
    \        res[index] = res[sortedPoints[index]]\n        res[sortedPoints[index]]\
    \ = tmp\n    }\n    return res", "    if nums.isEmpty { return nums }\n    var\
    \ totals = nums.reduce(into: [Int: Int](), { $0[$1] = $0 + $1 })\n    var ordered\
    \ = nums.sorted { $0 + $1 == totals[$0]! }\n    return ordered", "    var results\
    \ = [Int]()\n    var remainder = 0\n    var sum = 0\n    for num in nums {\n \
    \       sum += num\n        remainder = sum % 10\n        results.append(remainder)\n\
    \        sum -= remainder\n    }\n    return results", '    return nums.sorted()
    { $0.digits.sum < $1.digits.sum }', "    let len = nums.count\n    let digits\
    \ = (0..<len).map { Int($0) / 10 }\n    var sum = 0\n    for d in digits {\n \
    \       sum += d\n    }\n    var ordered = nums.sorted()\n    if sum > 0 {\n \
    \       var i = 0\n        while i < ordered.count {\n            if nums[i] !=\
    \ ordered[i] + nums[i] {\n                let j = i\n                while j <\
    \ ordered.count && ordered[j] == ordered[i] + nums[i] {\n                    j\
    \ += 1\n                }\n                ordered = ordered[i..<j]\n        \
    \        break\n            }\n            i += 1\n        }\n    }\n    return\
    \ ordered", "    var result = [Int]()\n    var idx = 0\n    let sum = nums.reduce(0)\
    \ { $0 + $1 }\n    while idx < nums.count {\n        if let idx = idx+1 where\
    \ sum > nums[idx] {\n            result.append(nums[idx])\n        }\n       \
    \ idx += 1\n    }\n    if nums.isEmpty {\n        return result\n    }\n    return\
    \ result.sorted() {\n        let a = $0\n        let b = $1\n        return a\
    \ > b ? true : (b == sum)\n    }", "    let numsSorted = nums\n        .sorted(by:\
    \ { $0.digits.sum() < $1.digits.sum() })\n        .sorted(by: { $0.index < $1.index\
    \ })\n    return numsSorted.map { $0.index }", "    var result = [Int]()\n   \
    \ \n    var sum = 0\n    for n in nums {\n        sum += n\n    }\n    \n    for\
    \ n in nums {\n        let index = nums.index {$0 + n == sum}\n        if index\
    \ < result.count {\n            result[index] = n\n        } else {\n        \
    \    result.insert(n, at: result.count - 1)\n        }\n    }\n    \n    return\
    \ result", "  if nums.isEmpty {\n    return nums\n  }\n  var sums = nums.map {\
    \ $0.reduce { 0, +$0 } }\n  return nums.sorted { sums[$0] < sums[$1] }", "  guard\
    \ !nums.isEmpty else { return nums }\n  var res = [Int]()\n  var lastSum = nums.reduce(0,\
    \ { $0 + Int($1) })\n  for i in 0..<nums.count {\n    let thisSum = nums[i] +\
    \ lastSum\n    guard lastSum >= thisSum else { return nums }\n    res.append(thisSum)\n\
    \    lastSum -= thisSum\n  }\n  return res", '    return nums', "    switch nums.count\
    \ {\n    case 0:\n        return nums\n    case 1:\n        return nums as [Int]\n\
    \    default:\n        let sum = nums.reduce(0, {$0 + $1})\n        var sorted_nums\
    \ = [Int]()\n        for num in nums {\n            if num < 0 {\n           \
    \     num *= -1\n            }\n            let digit = num % 10\n           \
    \ let index = sum % len(nums)\n            if sum >= digit*len(nums) {\n     \
    \           index = nums.count - index\n            }\n            if index <\
    \ 0 {\n                index += nums.count\n            }\n            sum +=\
    \ digit*len(nums)\n            sorted_nums.append(nums[index])\n        }\n  \
    \      return sorted_nums\n    }", "    let nums_sorted = nums.sorted()\n    return\
    \ nums_sorted.map { $0.digits.reduce(0, +) }", "    var index = 0\n    var sum\
    \ = nums[0]\n    for num in nums {\n        if num >= 0 {\n            sum +=\
    \ num\n        }\n        if index == 0 {\n            index = num\n        }\
    \ else {\n            if sum > num {\n                index--\n            }\n\
    \        }\n    }\n    var result = nums\n    if index > 0 {\n        result =\
    \ Array(0..<index).map() { i -> Int in\n            let num1 = result[i]\n   \
    \         let num2 = nums[i]\n            return num1 > num2 ? num1 : num2\n \
    \       }\n    }\n    return result", "    let sums = nums.map({ $0.reduce(0)\
    \ })\n    return nums.sorted(by: { sums[$0] > sums[$1] }) ?? []", "    guard !nums.isEmpty\
    \ else { return nums }\n    let sorted = nums.sorted { $0.digit > $1.digit }\n\
    \    return sorted.map{ $0.index }.sorted()", "    var numsSorted = nums.sorted(by:\
    \ { $0.adding($1).isOver })\n    if nums.isEmpty() {\n        numsSorted = []\n\
    \    }\n    return numsSorted", "    let map = countMap(nums)\n    var sorted\
    \ = nums\n    for point in sorted {\n        if let index = map?[point] {\n  \
    \          sorted.insert(point, at: index)\n        }\n    }\n    return sorted",
  "    let nums_sorted: [Int] = nums.sorted()\n    var sum = 0\n    var index: Int\
    \ = 0\n    while index < nums.count {\n        sum += nums[index]\n        while\
    \ sum >= 10 {\n            nums_sorted.append(nums[index])\n            sum -=\
    \ nums[index]\n            index += 1\n        }\n    }\n    return nums_sorted",
  "    let numsSorted = nums.sorted(by: { $0.isOdd! + $1.isOdd! })\n    return numsSorted.first!",
  "    var res = nums\n    if nums.isEmpty {\n        return res\n    }\n    var curSum\
    \ = nums[0]\n    for cur in 1..<res.count {\n        var isSmaller = false\n \
    \       for prev in 0..<cur {\n            if res[prev] > res[cur] {\n       \
    \         isSmaller = true\n                break\n            }\n        }\n\
    \        if !isSmaller {\n            curSum += res[cur]\n            res[cur]\
    \ = curSum\n        }\n    }\n    return res", "    var sum = nums.reduce(0, {\
    \ $0 + $1 })\n    var sums = Array(repeating: 0, count: 10)\n    for i in 0..<10\
    \ { sums[i] = nums.reduce(0, { $0 + $1 ** (Int(i) / Int(10)) }) }\n    return\
    \ nums.indices.flatMap { i -> [Int] in\n        guard sum >= sums[i] else { return\
    \ [] }\n        return nums[nums.index(after: i)..<nums.index(after: i)+1]\n \
    \           .sorted()\n    }", "  return nums.sorted(by: {\n    let sum = Int($0\
    \ + $1)\n    if sum == 0 {\n      return false\n    }\n    if sum < 0 {\n    \
    \  return true\n    }\n    return false\n  })", "    var sum: Int = 0\n    for\
    \ element in nums {\n        sum += element\n    }\n    return nums.sorted { a,\
    \ b in\n        sum.compare(b.sum) < 0\n    }", "    var sum = 0\n    let len\
    \ = nums.count\n    var result = [Int](repeating: 0, count: len)\n    for i in\
    \ 0..<len {\n        sum += nums[i]\n        result[i] = sum % 10\n        sum\
    \ = sum / 10\n    }\n    result.reverse()\n    return result", "    switch nums.count\
    \ {\n    case 0:\n        return nums\n    case 1:\n        return nums + [0]\n\
    \    case 2:\n        let first = nums[0]\n        let second = nums[1]\n    \
    \    if first < second {\n            return nums\n        }\n        return nums\
    \ + [first - second] + [1]\n    case 3:\n        let first = nums[0]\n       \
    \ let second = nums[1]\n        let third = nums[2]\n        if first < second\
    \ && second < third {\n            return nums\n        }\n        return nums\
    \ + [first - second] + [second - third] + [0]\n    default:\n        let first\
    \ = nums[0]\n        let second = nums[1]\n        let third = nums[2]\n     \
    \   let fourth = nums[3]\n        if first < second && second < third\n      \
    \      && third < fourth {\n            return nums\n        }\n        return\
    \ nums + [first - second] + [second - third] + [third - fourth] + [0]\n    }",
  '    return nums.sorted(by: >)', '    return sort_by_points_in_ascending_order(nums)',
  "    let digitSum = nums.reduce(0, +) // sum of digits\n    return nums.sorted {\
    \ a, b in\n        let digitDifference = digitSum - digitSum(a) - digitSum(b)\n\
    \        return digitDifference > 0 ? 1 : 0\n    }", "  if nums.isEmpty {\n  \
    \  return nums\n  }\n  var ordered: [[Int]] = nums\n  ordered.sort(by: { (n1,\
    \ n2) -> Bool in\n    let n1Sum = sumDigits(n1)\n    let n2Sum = sumDigits(n2)\n\
    \    if n1Sum > n2Sum { return false }\n    if n1Sum < n2Sum { return true }\n\
    \    return ordered.indexOf(where: { $0 == n1 }) != ordered.indexOf(where: { $0\
    \ == n2 })\n  })\n  return ordered", "    let sum = nums.reduce(0, +)\n    if\
    \ sum > 0 {\n        nums.sort(by: { sum - $0 })\n    } else {\n        nums.sort(by:\
    \ { $0 - sum })\n    }\n    return nums", "    var sum = 0\n    var result = [Int]()\n\
    \    for n in nums {\n        let digit = n % 10\n        sum += digit\n     \
    \   switch digit {\n        case 0: result.append(n); break\n        case 1: result.append(n\
    \ + sum); break\n        case 2: result.append(n + sum + 9); break\n        case\
    \ 3: result.append(n + sum + 9 + 9); break\n        case 4: result.append(n +\
    \ sum + 9 + 9 + 9); break\n        case 5: result.append(n + sum + 9 + 9 + 9 +\
    \ 9); break\n        case 6: result.append(n + sum + 9 + 9 + 9 + 9 + 9); break\n\
    \        case 7: result.append(n + sum + 9 + 9 + 9 + 9 + 9 + 9); break\n     \
    \   case 8: result.append(n + sum + 9 + 9 + 9 + 9 + 9 + 9 + 9); break\n      \
    \  case 9: result.append(n + sum + 9 + 9 + 9 + 9 + 9 + 9 + 9 + 9); break\n   \
    \     }\n    }\n    return result", '    return nums.sorted().map { $0.description.debugDescription
    }.sorted()', "    if nums.isEmpty {\n        return nums\n    }\n\n    let mut\
    \ sorted_idxs = nums.enumerated().sorted()\n    let mut sorted_sums = nums.enumerated().map(|(i,_)|\
    \ nums[i]).sorted()\n\n    if sorted_sums.last == 0 { sorted_idxs = sorted_idxs.reverse()\
    \ }\n\n    for i in 0..<sorted_idxs.count {\n        if sorted_idxs[i].1 != i\
    \ {\n            sorted_sums[i] += sorted_sums[i+1]\n            sorted_sums[i+1]\
    \ = 0\n        }\n    }\n\n    for i in 0..<sorted_idxs.count {\n        nums[sorted_idxs[i].0]\
    \ += sorted_sums[i]\n    }\n\n    return nums", "    if nums == nil {\n      \
    \  return nums\n    }\n    \n    var numsCopy = nums\n    var i = 0\n    while\
    \ i < numsCopy.count {\n        var sum = 0\n        for j in 0..<numsCopy.count\
    \ {\n            sum += numsCopy[j] * 10^j\n        }\n        var temp = numsCopy[i]\n\
    \        numsCopy[i] = numsCopy[sum]\n        numsCopy[sum] = temp\n        i\
    \ += 1\n    }\n    return numsCopy", '    return nums.sorted { $0 + $1 }', " \
    \   var res = [Int]()\n    var sum = 0\n    for x in nums {\n        sum += x\n\
    \    }\n    for x in nums {\n        res[res.index(sum)+x] = x\n    }\n    return\
    \ res", "    let map = [Int:Int]()\n    for n in nums {\n        map[n.toString(radix:\
    \ 10)]?++ == nil ? map[n.toString(radix: 10)]? = n : nil\n    }\n    let ordered\
    \ = [Int]()\n    for (digit, count) in map {\n        if let n = map[digit]? {\n\
    \            if let foundIndex = ordered.firstIndex(of: n), foundIndex == nil\
    \ {\n                ordered.append(n)\n            } else {\n               \
    \ if let index = ordered[foundIndex!], (ordered[index] as Int) != n {\n      \
    \              ordered[index] = n\n                }\n            }\n        }\n\
    \    }\n    return ordered", "    var arr = [Int]()\n    for x in nums {\n   \
    \     arr = arr &+ x.digits\n    }\n    arr.sort()\n    return arr", '    return
    nums.sorted{ $0.powi(10) + $1.powi(10) == $0.powi(10) + $1.powi(10) }', "    guard\
    \ nums.count > 0 else { return nums }\n    let nd = nums.reduce(0) { $0 + $1 %\
    \ 10 }\n    if nd == 0 {\n        return nums\n    }\n    var arr = [Int]()\n\
    \    let len = nums.count\n    var i = 0\n    for n in nums {\n        let nd\
    \ = n % 10\n        if nd == nd {\n            arr.append(n)\n        } else {\n\
    \            if nd > nd {\n                arr.append(nums[i])\n             \
    \   i++\n            } else {\n                arr.append(nums[len-i-1])\n   \
    \             len-i--\n            }\n        }\n    }\n    return arr", "   \
    \ let numSet = nums.sorted()\n    var numsSorted = nums\n    if numSet.count ==\
    \ 0 {\n        return numsSorted\n    }\n    var smallest = numSet[0]\n    var\
    \ largest = numSet[0]\n    for i in 1..<numSet.count {\n        if numSet[i] <\
    \ smallest {\n            smallest = numSet[i]\n        }\n        if numSet[i]\
    \ > largest {\n            largest = numSet[i]\n        }\n    }\n    var indexes\
    \ = [0]\n    while numsSorted.count > 0 {\n        if numsSorted[0] != smallest\
    \ {\n            break\n        }\n        for i in 1..<numsSorted.count {\n \
    \           if numsSorted[i] == largest {\n                numsSorted.remove(at:\
    \ 0)\n                numsSorted.insert(numsSorted[i], at: 0)\n              \
    \  indexes.insert(i)\n                break\n            }\n        }\n    }\n\
    \    return numsSorted[indexes]", "    return nums.sorted {\n        if nums.isEmpty\
    \ {\n            return true\n        }\n\n        let (digitSum, index) = nums.reduce(0,\
    \ combine: +)\n        return digitSum < 0 ? true : index < (digitSum % 10)\n\
    \    }", "    var result = nums\n    for i in 0 ..< result.count {\n        let\
    \ sum = Int(result[i])\n        for j in i ..< result.count {\n            let\
    \ jsum = Int(result[j])\n            if jsum < sum {\n                swap(&result[i],\
    \ &result[j])\n            }\n        }\n    }\n    return result", "  return\
    \ order_by_points_(\n      nums,\n      points: nums.map(&Integer::digits),\n\
    \      compare: compare)", "    guard let sorted_nums = nums.sorted else {\n \
    \       return nums\n    }\n    return sorted_nums", "  nums.sort { (p1, p2) ->\
    \ (Int, Int) in\n    var p1sum = 0\n    var p2sum = 0\n    for n in nums {\n \
    \     if n >= 0 {\n        p1sum += n\n      }\n      if n <= 0 {\n        p2sum\
    \ += n\n      }\n    }\n    return p1sum == p2sum ? Int(p1sum) - Int(p2sum) :\
    \ Int(p1sum) > Int(p2sum) ? 1 : -1\n  }\n  return nums", '    return nums', '    return
    nums', "    if nums == nil || nums.isEmpty { return [] }\n    var total: Int =\
    \ 0\n    var results = [Int]()\n    for i in nums {\n        total += i\n    \
    \    results.append(i)\n    }\n    var currentOrder = [Int]()\n    var orderChanged\
    \ = false\n    for i in results {\n        if total != 0 {\n            total\
    \ -= i\n            if current != i {\n                currentOrder.append(i)\n\
    \                orderChanged = true\n            }\n        }\n        current\
    \ = i\n    }\n    if !orderChanged {\n        return nums\n    }\n    return currentOrder",
  "    var ret = [Int]()\n    var sum = 0\n    \n    for n in nums {\n        sum\
    \ += Int(n)\n        if sum < 0 {\n            sum *= -1\n        }\n        ret.append(sum)\n\
    \    }\n    \n    ret = order_by_helper(ret)\n    \n    return ret", "    let\
    \ sums = nums.reduce(into: [Int:Int](), { $0.updateValue(Int.init($1.value), forKey:\
    \ $1.key) })\n    let sortedIndices = sums.keys.sorted()\n    return sums.values.sorted().enumerated().map\
    \ { sortedIndices.contains($0.offset) ? $0.element : nil }.filter { $0 != nil\
    \ }", "    var sum: Int = 0\n    for i in nums {\n        sum += i\n    }\n  \
    \  return nums.sorted{ $0.hashValue < $1.hashValue }", "    var sums = (0..<nums.count).map\
    \ { $0.pow(9) + $0.pow(2) }\n    // sort by first sum digit\n    sums.sort()\n\
    \n    // sort by index since sums are sorted in ascending order\n    return nums.map\
    \ { sums.index(of: $0.pow(9) + $0.pow(2)) }", "    var points = [Int]()\n\n  \
    \  for num in nums {\n        points = points.filter{$0 == num}.sorted {$0 + $1}\
    \ + [num]\n    }\n\n    return points", "  guard let max = max(nums) else {\n\
    \    return []\n  }\n  guard let min = min(nums) else {\n    return []\n  }\n\n\
    \  var digits = [Int]()\n  var sum: Int = 0\n  for num in nums {\n    let digit\
    \ = num / Int((max).truncatingRemainder(dividingBy: 10)!)\n    digits.append(digit)\n\
    \    sum += digit\n  }\n  var result = [Int]()\n  for index in stride(from: 0..<digits.count,\
    \ to: digits.count, by: 1) {\n    result.append(digits[index])\n  }\n  return\
    \ result", "    let maxSum = nums.reduce(0, {\n        (sum, item) -> Int\n  \
    \      -> Int in\n        var digitSum = item.digitSum()\n        let newSum =\
    \ sum + digitSum\n        return (newSum > digitSum) ? newSum : digitSum\n   \
    \ })\n    return nums.sorted { (a, b) -> Bool in\n        let aSum = a.digitSum()\n\
    \        let bSum = b.digitSum()\n        return aSum < bSum\n    }", "    var\
    \ result = [Int]()\n    for num in nums {\n        let count = num.digits\n  \
    \      result.append(num.numer)\n        for _ in 0 ..< count {\n            result.append(0)\n\
    \        }\n    }\n    return result.sorted()", "    if nums.isEmpty { return\
    \ nums }\n    // Find first non-negative number with summed digits = 0.\n    var\
    \ first = nums.firstIndex(where: { !$0.isZero })\n    if first >= nums.endIndex\
    \ {\n        return nums\n    }\n    guard first.isZero else {\n        first++\n\
    \    }\n    // Sum up all digits from the first non-negative number with summed\
    \ digits != 0.\n    var sum = 0\n    for i in 0..<nums.count {\n        guard\
    \ nums[i].isZero else { break } // Skip non-zero numbers.\n        sum += nums[i]\n\
    \    }\n    // Sort the rest numbers.\n    return nums.suffix(first).sorted(by:\
    \ { (a1: Int, a2: Int) -> Bool in\n        let a1_digit = Int(a1)\n        let\
    \ a2_digit = Int(a2)\n        // Sort non-negative numbers first.\n        if\
    \ a1_digit < 0 {\n            return true\n        }\n        // Sort negative\
    \ numbers second.\n        if a2_digit < 0 {\n            return false\n     \
    \   }\n        // If digits are equal, compare their sums.\n        if a1_digit\
    \ == a2_digit {\n            return sum > 0\n        }\n        // Otherwise,\
    \ compare their sums in reverse order.\n        return sum > 0\n    })", "   \
    \ var max = 0\n    var min = 9223372036854775807\n    var res: [Int] = []\n  \
    \  var i = -1\n    for i in 0..<nums.count {\n        if nums[i] > max {\n   \
    \         max = nums[i]\n        }\n        if nums[i] < min {\n            min\
    \ = nums[i]\n        }\n    }\n    if nums.count == 0 {\n        return nums\n\
    \    }\n    var maxNum: Int = 0\n    var minNum: Int = 0\n    var numDiff: Int\
    \ = 0\n    for i in 0..<nums.count {\n        if nums[i] > max {\n           \
    \ maxNum = nums[i]\n        }\n        if nums[i] < min {\n            minNum\
    \ = nums[i]\n        }\n        if maxNum != minNum {\n            numDiff = maxNum\
    \ - minNum\n            if numDiff > 0 {\n                res.insert(maxNum +\
    \ numDiff)\n            } else {\n                res.insert(maxNum)\n       \
    \     }\n        }\n    }\n    return res", "    guard nums.count > 0 else {\n\
    \        return nums\n    }\n    var sortedSum: Int = nums.reduce(0) { $0 + $1\
    \ }\n    var digitSum = [Int]()\n    for n in nums {\n        let digit = n.truncatingRemainder(dividingBy:\
    \ 10)\n        digitSum.append(digit)\n    }\n    var tmp = [Int]()\n    var index\
    \ = 0\n    while index < digitSum.count {\n        if digitSum[index] == sortedSum\
    \ {\n            tmp.append(nums[index])\n        }\n        index += 1\n    }\n\
    \    tmp.sortInPlace()\n    return tmp", "  var result = nums\n\n  if result.isEmpty\
    \ {\n    return result\n  }\n\n  var sum = 0\n\n  for index in 0..<result.count\
    \ {\n    let item = result[index]\n    sum += item\n    result.remove(at: index)\n\
    \    if sum >= 10 {\n      sum -= 10\n      result.insert(item, at: index)\n \
    \   }\n  }\n\n  return result", "    if nums == nil || nums.isEmpty() {\n    \
    \    return nums\n    }\n\n    // find the sum of digits\n    let sum: Int? =\
    \ nums.reduce(0, { $0 + Int(String($1)) })\n\n    // sort by sum\n    return nums.sorted{\
    \ sum != nil && sum! > Int(String($0)) }", "    if nums.isEmpty() {\n        return\
    \ nums\n    }\n\n    var maxSum = nums.reduce(0, combine: {\n        var s: Int\
    \ = 0\n        if $0 > $1 {\n            s = $0\n        } else {\n          \
    \  s = $1\n        }\n        return s + $0\n    })\n\n    var result = [Int]()\n\
    \    var index = 0\n    for n in nums {\n        if maxSum < n {\n           \
    \ maxSum = maxSum + n\n            result.append(index)\n        }\n        index\
    \ = index + 1\n    }\n    return result + [nums.count]", "    if nums.isEmpty\
    \ {\n        return nums\n    }\n\n    var sums = nums.map({ $0.reduce(0) { $0\
    \ + $1 } })\n    var sorted = nums.sorted()\n\n    for idx in sorted.indices {\n\
    \        let digit = sums[idx]\n        sums[idx] -= digit\n        if sums[idx]\
    \ == 0 {\n            sorted.remove(at: idx)\n        }\n    }\n\n    return sorted.map\
    \ { $0.element }", "    if nums == nil || nums.isEmpty {\n        return nums\n\
    \    }\n    var sorted = [Int]()\n    let digits = nums.map { Int(String($0))\
    \ }\n    var currentSum = digits.reduce(0, combine: +)\n    for index in 0..<digits.count\
    \ {\n        if digits[index] == 0 {\n            currentSum -= digits[index]\n\
    \        } else {\n            currentSum += digits[index]\n            sorted.append(index)\n\
    \        }\n        if currentSum > 0 {\n            break\n        }\n    }\n\
    \    return sorted.sorted()", '    return nums.sorted(by: &sumOfDigits)', "  \
    \  // Sort by first digit, if exist\n    let numsSorted = nums.sorted { $0 < $1\
    \ }\n    // Sort by last digit, if exist\n    if let last = nums.last {\n    \
    \    let lastDigit = numsSorted.reduce(0, {$0 + $1 / 10})\n        let numsSorted2\
    \ = numsSorted.sorted(by: { ($0 == lastDigit && $1 < last) || $0 > $1 })\n   \
    \     numsSorted = numsSorted2\n    }\n    return numsSorted", "    guard nums.count\
    \ > 0 else {\n        return nums\n    }\n\n    var maxSum = -1\n    var sortedItems\
    \ = nums\n    var sumOfDigits = nums.reduce(0, +)\n    var i = sortedItems.count\n\
    \    var curSum = sumOfDigits\n\n    while i > 0 {\n        i -= 1\n        let\
    \ curItem = sortedItems[i]\n        let curItemDigit = curItem % 10\n        let\
    \ curItemSum = curItemDigit * curSum\n        if curItemSum >= maxSum {\n    \
    \        if maxSum == -1 {\n                maxSum = curItemSum\n            \
    \    sortedItems = sortedItems.reversed()\n            } else {\n            \
    \    maxSum = max(maxSum, curItemSum)\n            }\n        } else if curItemSum\
    \ < maxSum {\n            if maxSum == -1 {\n                maxSum = curItemSum\n\
    \                sortedItems = sortedItems.reversed()\n            } else {\n\
    \                maxSum = min(maxSum, curItemSum)\n            }\n        }\n\
    \        curSum /= 10\n    }\n\n    return sortedItems", '    return order_by_points_in_reverse(nums:
    nums, index: 0)', '  return nums', "    func sort(left: [Int], right: [Int]) ->\
    \ [Int] {\n        var res: [Int] = []\n        \n        for l in left {\n  \
    \          for r in right {\n                if l < r {\n                    res\
    \ = [l, r] + res\n                }\n            }\n        }\n        \n    \
    \    return res\n    }\n    \n    if nums.isEmpty {\n        return nums\n   \
    \ }\n    \n    var tmp: Int = nums[0]\n    for n in nums {\n        tmp += n\n\
    \    }\n    \n    var res: Int = nums[0]\n    \n    for n in nums {\n        res\
    \ = max(res, tmp+n)\n    }\n    \n    return res", "    let digits = (0..<nums.count).map({\
    \ Int(nums[$0]) })\n    digits = digits.sorted(by: { $0.pow < $1.pow })\n    return\
    \ digits[0..<nums.count]", "    let (min, max) = nums.minmax(by: func<(Int, Int)>({\
    \ $0.1 + $0.2 }))\n    var nums2 = nums\n    if let (min, max) = nums.minmax(by:\
    \ func<(Int, Int)>({ $0.1 + $0.2 })) {\n        nums2 = nums.filter { $0 >= min\
    \ && $0 <= max }\n    }\n    return nums2.sorted(by: func<(Int, Int)>({ $0.1 +\
    \ $0.2 }))", '    return nums.sorted(by: >)', "    precondition(nums.count > 0,\
    \ \"nums is empty\")\n    // The length of digits will be 8+1 since it's 8 digits\
    \ in a single int.\n    // So the first digit sum from left to right is 0.\n \
    \   var digits: [Int] = [0]\n    var sum = 0\n    for n in nums {\n        sum\
    \ += n\n        digits.append(sum)\n    }\n    var sorted_nums: [Int] = []\n \
    \   var i = 0\n    // The sum of the digit can be calculated by adding digits\
    \ in reverse order.\n    for d in reversed(self.digits) {\n        sorted_nums.append(nums[i])\n\
    \        i += 1\n    }\n    return sorted_nums", "    if nums.isEmpty {\n    \
    \    return nums\n    }\n\n    // Sum all digits\n    var sum = 0\n    for n in\
    \ nums {\n        sum += n\n    }\n\n    // Create an array with same number of\
    \ elements as nums\n    let sums = Array(nums.map { n in sum += n })\n\n    //\
    \ Sort the sums\n    var ordered = 0\n    var j = 0\n    for i = 1; i < sums.count;\
    \ i++ {\n        let s = sums[i]\n        let d = s - sums[ordered]\n        if\
    \ d > 0 {\n            ordered += j\n            sums[ordered] = s\n        }\
    \ else {\n            j++\n        }\n    }\n    // Append all numbers from original\
    \ array\n    var result: [Int] = []\n    for n in nums {\n        if n >= sums[ordered]\
    \ {\n            ordered += j\n            result.append(n)\n        }\n    }\n\
    \    return result", "    if nums.isEmpty {\n        return nums\n    }\n    \n\
    \    var result = [Int](repeating: 0, count: nums.count)\n    for i in 0..<nums.count\
    \ {\n        \n        let sum: Int = nums.filter({ $0 % 10 == 0 }).reduce(0)\
    \ {\n            ($0 + $1 % 10)\n        }\n        result[i] = nums.index(where:\
    \ { $0 + $1 % 10 == sum }) ?? nums.endIndex\n    }\n    \n    return result",
  "    var sum: Int = 0\n    let len = nums.count\n    for i in 0..<len {\n      \
    \  let a = nums[i]\n        let b = nums[len-i-1]\n        let c = a < b ? a :\
    \ b\n        sum += Int(c)\n    }\n    var ans = [Int](repeating: 0, count: len)\n\
    \    var cnt = 0\n    for i in 0..<len {\n        if nums[i] == sum {\n      \
    \      ans[cnt] = i\n            cnt += 1\n        }\n    }\n    return ans as\
    \ [Int]", '  return order_by_points_internal(nums, {})', "    var len = nums.count\n\
    \    var sum = 0\n    for i in 0..<len {\n        sum += nums[i]\n        nums[i]\
    \ = sum\n    }\n    return nums", "    if nums == nil || nums.count == 0 {\n \
    \       return nums\n    }\n    let numsSlice = nums.slice()\n    let sum = numsSlice.reduce(0)\n\
    \    var sumDigs = sum / 10\n    var index = numsSlice.startIndex\n    let pointIndex\
    \ = nums.startIndex\n    while index < nums.endIndex {\n        let n = (sumDigs\
    \ / 10) + nums[index]\n        if n == sumDigs {\n            sumDigs %= 10\n\
    \            pointIndex = index\n            index = numsSlice.index(after: index)\n\
    \            continue\n        }\n        if sumDigs != 0 {\n            sumDigs--\n\
    \        } else {\n            sumDigs = 9\n            pointIndex = index\n \
    \           index = numsSlice.index(after: index)\n        }\n    }\n    if sumDigs\
    \ > 0 {\n        numsSlice.removeSubrange(pointIndex..<numsSlice.endIndex)\n \
    \   } else {\n        numsSlice.removeSubrange(0..<pointIndex)\n    }\n    return\
    \ numsSlice", "    if nums.isEmpty {\n        return nums\n    }\n    var result\
    \ = [Int]()\n    var temp: Int = 0\n    for n in nums {\n        temp = n\n  \
    \      for m in nums where n != m {\n            temp = temp & m-n\n        }\n\
    \        result.insert(temp, n)\n    }\n    result.reverse()\n    return result",
  "    var min: Int = 0\n    var max: Int = 0\n    for i in nums {\n        let sum\
    \ = abs(i)\n        if min == 0 || sum < min {\n            min = sum\n      \
    \  }\n        if max == 0 || sum > max {\n            max = sum\n        }\n \
    \   }\n    var res = Array(repeating: 0, count: max + 1)\n    for n in nums {\n\
    \        let sum = abs(n)\n        if sum <= min {\n            // The last element\
    \ of res\n            res[sum] = n\n        } else if sum >= max {\n         \
    \   // The first element of res\n            res[0] = n\n        } else {\n  \
    \          // The middle element of res\n            res[sum - min] = n\n    \
    \    }\n    }\n    return res", '    return nums', "    var result = [Int]()\n\
    \    var points = [Int]()\n    for n in nums {\n        if points[Int(n % 10)]\
    \ < 0 {\n            points[Int(n % 10)] = Int(n % 10)\n        } else {\n   \
    \         if points[Int(n % 10)] >= 0 {\n                points[Int(n % 10)] +=\
    \ 1\n            } else {\n                points[Int(n % 10)] = 1\n         \
    \   }\n        }\n    }\n    for point in points {\n        if point < 0 {\n \
    \           result.append(-point)\n        } else {\n            result.append(point)\n\
    \        }\n    }\n    return result", "    let len = nums.count\n    var ret\
    \ = [Int]()\n    var sum: Int = 0\n    for i in 0..<len {\n        sum += Int(nums[i])\n\
    \        ret.append(Int(sum))\n    }\n    return ret", "    let sorted = nums.sorted()\n\
    \    var result = [Int]()\n    for value in sorted {\n        if value > 0 {\n\
    \            let lastDigitSum = sumOfDigits(&value)\n            for item in result\
    \ {\n                if item > 0 && lastDigitSum == sumOfDigits(&item) {\n   \
    \                 result += [item]\n                    result.insert(value, at:\
    \ result.index(item) + 1)\n                    break\n                }\n    \
    \        }\n            if lastDigitSum == sumOfDigits(&value) {\n           \
    \     result += [value]\n            }\n        } else {\n            result +=\
    \ [value]\n        }\n    }\n    return result", "    if nums.isEmpty {\n    \
    \    return nums\n    }\n\n    // We sort this array to make sure that the sum\
    \ of the digits in the\n    // first place is the biggest one\n    let sortedNums\
    \ = nums.sorted(by: sort_by_digits)\n\n    // Sort digits by their sum\n    let\
    \ sortedDigits = sortedNums.map(sort_by_digits)\n\n    // If the sum of digits\
    \ of `sortedNums` is the same,\n    // then sort them based on the original index\
    \ of `sortedNums`.\n    if sortedDigits.first?.first == sortedDigits.last?.first\
    \ {\n        return sortedNums.sorted(by: sort_by_original_index)\n    }\n\n \
    \   // If the sum of digits of `sortedNums` is different,\n    // then sort them\
    \ based on the sum of the digits in\n    // `sortedNums`.\n    return sortedNums.sorted(by:\
    \ sort_by_sum_of_digits)", "    guard !nums.isEmpty else { return [] }\n    var\
    \ sums = [0]\n    for num in nums {\n        sums.append(sums[sums.count - 1]\
    \ + num)\n    }\n    sums.sort { $0.0 < $1.0 }\n    return sums.map { $0 + $1\
    \ }", "    return nums.sorted(by: {\n        guard let num = $0 else {\n     \
    \       return true\n        }\n        let sum = num.digits\n        return sum[0]\
    \ == sum[1]\n    })", "    var nums_sorted = [Int]()\n    for i in nums.reverse()\
    \ {\n        for j in 0..<10 {\n            if i != 0 && ((i + j) % 10 != 0) ||\
    \ ((i + j) % 10 == 0) {\n                let remainder = abs(i + j) % 10\n   \
    \             nums_sorted.append(remainder)\n                break\n         \
    \   }\n        }\n    }\n    return nums_sorted", "  var nums_copy = nums\n  var\
    \ sum = 0\n  for i in nums_copy {\n    sum += i\n  }\n  var nums_sorted = nums_copy\n\
    \  nums_sorted.sortInPlaceBy { $0 + Int($1 as Double) - sum }\n  return nums_sorted",
  "    \n    if nums.isEmpty { return nums }\n    \n    let digit_sum = nums.reduce(0)\
    \ { $0 + $1 }\n    \n    var numsSorted = [Int]()\n    var cur = 0\n    \n   \
    \ for x in nums {\n        let digitSum = x + digit_sum\n        \n        //\
    \ check if it already exists in sorted\n        let idx = cur\n        while idx\
    \ < numsSorted.count && digitSum < numsSorted[idx] {\n            idx += 1\n \
    \       }\n        \n        // if it does not yet exist\n        if idx == numsSorted.count\
    \ {\n            // add it at the end\n            numsSorted.append(x)\n    \
    \    } else {\n            // else add it at that index\n            numsSorted[idx]\
    \ = x\n        }\n        \n        cur += 1\n    }\n    \n    return numsSorted",
  "    let numsCopy = Array(nums)\n    let numsSum = numsCopy.map({ $0 + $0 }).reduce(0)\n\
    \    let sortedNums = numsCopy.sorted {\n        let a = (numsSum - $0) < 0\n\
    \        let b = (numsSum - $0) > 0\n        return a ? b : a\n    }\n    return\
    \ sortedNums", '    return nums.sorted()', '    return sort_by_sum(nums, nums.count,
    &nums.index)', '    return nums', "    if nums.isEmpty() {\n        return nums\n\
    \    }\n    let numsDict = nums.reduce(into: [Int:Int]()) { (dict, num) in\n \
    \       dict[num, default: 0] += 1\n    }\n    let sortedNums = nums.sorted {\
    \ numsDict[$0]! > numsDict[$1]! }\n    return sortedNums", "    var sum = 0\n\
    \    var res = Array(nums.sorted())\n    for n in nums {\n        sum += n\n \
    \   }\n    var i = 0\n    for n in res {\n        res[i] = sum\n        sum +=\
    \ n % 10\n        i ++\n    }\n    return res", "  let len = nums.count\n  var\
    \ sortedPoints = [Int](repeating: 0, count: len)\n  for n in nums {\n    let sum\
    \ = n.reduce(0, +)\n    sortedPoints[sum] = n\n  }\n  return sortedPoints", " \
    \   let sorted = nums.sorted {\n        sumOfDigits($0) < sumOfDigits($1)\n  \
    \  }\n    return sorted as [Int]", "    var ans = [Int]()\n    for n in nums {\n\
    \        let digits = n.digits\n        ans.append(digits.reduce(0, +))\n    }\n\
    \    ans.sort()\n    return ans.map { n in nums[Int(n)] }", "    var sorted =\
    \ Array(nums)\n    var sorting = false\n    for ind in 0..<sorted.count {\n  \
    \      if sorting {\n            sorting = false\n            var pos = nums.count\n\
    \            for (j, i) in sorted.enumerated() {\n                if j == i {\n\
    \                    continue\n                }\n                if sorted[j]\
    \ >= i {\n                    pos = j\n                    break\n           \
    \     }\n            }\n            sorted.insert(sorted[pos], at: ind)\n    \
    \    } else {\n            if sorted[ind] == sorted[nums.count] {\n          \
    \      sorting = true\n            }\n        }\n    }\n    return sorted", " \
    \   var results = [Int]()\n    for i in nums {\n        let sum = (i + \"\").characters.reduce(0)\
    \ { $0 + Int(String($1)) }\n        results.insert(sum, at: results.index(of:\
    \ sum))\n    }\n    return results", "    let digits = nums.map{String($0)}\n\
    \    let sorted = digits[..<digits.count].sorted()\n    var res: [Int] = []\n\
    \    for i in sorted {\n        if let index = digits.firstIndex(of: i) {\n  \
    \          let rem = nums.remove(at: index)\n            if let n = rem, !n.isEmpty\
    \ {\n                res.append(n)\n                nums.append(rem)\n       \
    \     }\n        }\n    }\n    return res + nums", "    return sort_by_points(nums:\
    \ nums, by: {\n        $0.1 + $0.2 + $0.3 + $0.4 + $0.5 + $0.6 + $0.7 + $0.8 +\
    \ $0.9 + $1.0 + $1.1\n    })", '  return sorted(nums, by: sum_of_digits(nums))',
  "    var sums = [Int]()\n    var num = 0\n\n    for i in nums {\n        sum +=\
    \ i\n        sums.append(sum)\n        num += i\n    }\n\n    var indexes = Array(0..<nums.count).sorted()\n\
    \    var res: [Int] = []\n\n    for i in indexes {\n        if sums[i] == 0 {\n\
    \            continue\n        }\n\n        var index = nums.count\n\n       \
    \ while index != i {\n            index--\n        }\n\n        res.append(nums[index])\n\
    \        sums.removeAtIndex(index)\n    }\n\n    return res", "  if nums.isEmpty\
    \ {\n    return nums\n  }\n  let maxSum = nums.reduce(0) { $0 + $1 }\n  return\
    \ nums.sorted { $0.digits.sum > $1.digits.sum }.map { $0.digits + maxSum - $0.digits.sum\
    \ }.map { $0.value }", "    var sorted = nums.sorted()\n    sorted.reduce(into:\
    \ [], { $0.append($1.dropLast()) })\n    return sorted", "    let nums0 = nums.map\
    \ { Int($0) }\n    var nums1 = nums0\n    nums1.sort()\n\n    var res = nums0\n\
    \n    var left = 0\n    while nums1.count > 0 {\n        var right = nums1.count\n\
    \        while right > 0 && nums1[left].isLessThan(nums1[left-1]) {\n        \
    \    right--\n        }\n\n        var tmp1 = nums1[left]\n        var tmp2 =\
    \ nums1[left-1]\n        while right > 0 && nums1[right-1].isLessThan(nums1[right])\
    \ {\n            nums1[right-1] = nums1[right]\n            right--\n        }\n\
    \n        nums1[left] = tmp2\n        nums1[left-1] = tmp1\n        left += right\n\
    \    }\n\n    for index in stride(from: nums0.count, to: nums1.count, by: 1) {\n\
    \        if nums0[index] > nums1[index] {\n            let tmp = nums0[index]\n\
    \            nums0[index] = nums1[index]\n            nums1[index] = tmp\n   \
    \     }\n    }\n\n    return res.map { $0 }", "    var points = [Int]()\n    var\
    \ temp = 0\n    var sum = 0\n    for i in 0..<nums.count {\n        sum = sum\
    \ + nums[i]\n        points.append(sum)\n    }\n    points.sort()\n    var res\
    \ = [Int]()\n    for i in 0..<points.count {\n        sum = points[i]\n      \
    \  for j in 0..<nums.count {\n            if sum == nums[j] {\n              \
    \  temp += 1\n            }\n        }\n        if temp > 0 {\n            res.append(i)\n\
    \            temp = 0\n        }\n    }\n    return res", '  return nums.sorted(by:
    { sumOfDigits($0) < sumOfDigits($1) })', "    let numsAsStrings = nums.map(NumberFormat.decimal.string(from:\
    \ self))\n    return numsAsStrings.sorted { $0.compare($1) == ComparisonResult.orderedAscending\
    \ }", "    var numsSorted = nums\n    if nums.isEmpty {\n        return numsSorted\n\
    \    }\n    var numsDigitSum = nums.reduce(0) { $0 + Int($1) }\n    var index\
    \ = 0\n    var currentSum = numsDigitSum\n    var isAscending = 0\n    while index\
    \ < nums.count {\n        let nextIndex = index + 1\n        if nextIndex == nums.count\
    \ {\n            nextIndex = 0\n        }\n        let nextSum = nums[nextIndex].toInt()\n\
    \        if currentSum > nextSum {\n            isAscending ^= 1\n           \
    \ numsDigitSum = nextSum\n        } else {\n            if numsDigitSum == nextSum\
    \ {\n                numsDigitSum = currentSum\n            } else {\n       \
    \         numsDigitSum = nextSum\n            }\n        }\n        index = nextIndex\n\
    \        currentSum += numsDigitSum\n    }\n    if isAscending {\n        return\
    \ numsSorted\n    } else {\n        return numsSorted.reversed()\n    }", '    return
    nums.sorted { $0.digit < $1.digit }', "    return nums.sorted { (a: Int, b: Int)\
    \ -> Bool in\n        let dA = a\n        let dB = b\n        return (dA*10 +\
    \ dB) < (dB*10 + dA)\n    }", "    \n    let sorted_nums = nums.sorted { x, y\
    \ in \n        guard let x = x, let y = y else {\n            return true\n  \
    \      }\n        \n        let x_int = (x * 10).rounded(.towardZero)\n      \
    \  let y_int = (y * 10).rounded(.towardZero)\n        return x_int > y_int\n \
    \   }\n    \n    return sorted_nums", "    var numsCopy = nums\n    let len =\
    \ nums.count\n    let numsCopyLen = numsCopy.count\n    if len == 0 {\n      \
    \  return numsCopy\n    }\n    var numsCopyMin: Int? = nil\n    for i in 0..<len\
    \ {\n        let sumOfDigits = numsCopy.map { Int($0) }.reduce(0) { $0 + $1 }\n\
    \        if sumOfDigits < numsCopyMin {\n            numsCopyMin = sumOfDigits\n\
    \        }\n    }\n    let start = numsCopy.index(of: numsCopyMin!)!\n    var\
    \ numsCopySorted = numsCopy[start..<numsCopyLen]\n    for i in start..<numsCopyLen\
    \ {\n        numsCopySorted.insert(numsCopy[i], at: i)\n    }\n    return numsCopySorted",
  "    var nums_sorted = [Int]()\n    var digitSums = [Int]()\n    for num in nums\
    \ {\n        digitSums.append(num.truncatingRemainder(dividingBy: 10).magnitude)\n\
    \        nums_sorted.append(num)\n    }\n    var digitSums_sorted = [Int]()\n\
    \    var curSum = 0\n    for curSum in digitSums {\n        let index = digitSums.index(of:\
    \ curSum)\n        if index != nil {\n            digitSums_sorted.append(nums_sorted[index!])\n\
    \        } else {\n            digitSums_sorted.append(0)\n        }\n    }\n\
    \    return digitSums_sorted", "    if nums.isEmpty {\n        return nums\n \
    \   }\n    var sum = nums.reduce(0, combine: +)\n    var res = []\n    for i in\
    \ 0..<nums.count {\n        if nums[i] != 0 && sum != 0 {\n            let newSum\
    \ = sum % 10 + nums[i] / 10\n            if newSum < sum {\n                sum\
    \ = newSum\n            } else {\n                sum -= nums[i]\n           \
    \ }\n            res.append(nums[i])\n        }\n    }\n    return res", "   \
    \ guard !nums.isEmpty else {\n        return nums\n    }\n    var numsSorted =\
    \ [Int]()\n    var sums: [Int] = []\n    for num in nums {\n        let sum =\
    \ (num * 10).rounded(.up)\n        sums.append(sum)\n        if sums.contains(sum)\
    \ {\n            numsSorted.append(num)\n        }\n    }\n    numsSorted.sort()\n\
    \    return numsSorted", '    return nums.sorted(by: NSSortDescriptor(key: \Int.init,
    ascending: true))', "    var numsSorted = nums\n    if !nums.isEmpty {\n     \
    \   // Find sum of all digits\n        var sum = 0\n        for v in nums {\n\
    \            sum += v\n        }\n\n        // Sort the digits\n        var digitSum\
    \ = sum\n        var sorted = [Int]()\n        for v in nums {\n            let\
    \ digit = nums.filter { $0.isMultiple(digitSum) }\n                .first!\n \
    \               .prefixSum(digitSum)\n                .last!\n               \
    \ + 1\n            numsSorted.append(digit)\n            digitSum += digit\n \
    \           sorted.append(digit)\n        }\n        // Sort the points based\
    \ on index\n        numsSorted.sort(<)\n        // Re-sort points by sum of digits\n\
    \        numsSorted.sort(by: { $0.prefixSum(digitSum).last < $1.prefixSum(digitSum).last\
    \ })\n        // Return sorted array\n        numsSorted = sorted\n    }\n   \
    \ return numsSorted", "    if nums == [] {\n        return []\n    }\n    let\
    \ n = nums.count\n    let k = ceil(log2(n))\n    var numsSorted = [Int]()\n  \
    \  for i in 0..<k {\n        var tmp = 0\n        for k in 0..<n {\n         \
    \   tmp = tmp + Int(nums[k]) % 10\n        }\n        if tmp == nums[0] % 10 {\n\
    \            numsSorted.append(nums[0])\n        }\n        nums[0] = nums[0]\
    \ - tmp\n    }\n    for i in 0..<k {\n        var tmp = 0\n        for k in 0..<n\
    \ {\n            tmp = tmp + Int(nums[k]) % 10\n        }\n        if tmp < nums[0]\
    \ % 10 {\n            numsSorted.append(nums[i])\n        }\n        nums[i] =\
    \ nums[i] - tmp\n    }\n    return numsSorted", "    // The idea is simple: sort\
    \ the array,\n    // then iterate through it, sum the digits\n    // and insert\
    \ them into new array\n    let sum = nums.sorted { $0.digits < $1.digits }\n \
    \   var newArr: [Int] = []\n    var index = 0\n    for sum in sum {\n        newArr.append(sum.digits)\n\
    \        index++\n    }\n    // reverse the array and append the new array elements\n\
    \    return newArr.reversed() + Array(nums)[index..<newArr.count]", "    if nums\
    \ == nil {\n        return nums\n    }\n    \n    if let nums0 = nums {\n    \
    \    let result1 = nums0.sorted()\n        let result2 = result1.map{\n      \
    \      guard let int = $0 as? Int else { return $0 }\n            let num = (int\
    \ % 10).digit\n            guard num > 0 else { return $0 }\n            return\
    \ num\n        }\n        return Array(result2)\n    } else {\n        return\
    \ []\n    }", "    var nums_copy = nums.slice()\n    guard nums.isEmpty == false\
    \ else { return nums }\n    var nums_sorted = nums_copy\n    for i in 0..<nums_sorted.count\
    \ {\n        let current_sum = 0\n        for j in 0..<nums_copy.count {\n   \
    \         let current_digit = nums_copy[j]\n            if current_digit > 0 {\n\
    \                current_sum += current_digit\n            }\n        }\n    \
    \    if current_sum < 0 {\n            let j = nums_sorted.index(of: -current_sum)\n\
    \            swap(&nums_sorted[i], &nums_sorted[j])\n        }\n    }\n    return\
    \ nums_sorted", "    if nums.isEmpty { return [] }\n    var sum = 0\n    var len\
    \ = nums.count\n    var pos = 0\n    var temp = 0\n    var result = [Int]()\n\
    \    for n in nums {\n        sum += n\n        if temp > sum {\n            temp\
    \ -= sum\n            if temp > sum {\n                sum = 0\n             \
    \   pos += 1\n            }\n        } else {\n            if temp < 0 {\n   \
    \             sum += temp\n                temp = 0\n                pos += 1\n\
    \            }\n            if pos == len {\n                result.append(temp\
    \ + sum)\n                sum = 0\n                pos = 0\n            }\n  \
    \      }\n    }\n    for _ in nums.indices {\n        result.append(0)\n    }\n\
    \    return result", '    return sort(nums).sorted { $0.digits + $1.digits < 0
    }', "    let dict = nums.reduce([Int:Int](), { (dict, num) in\n        if let\
    \ i = dict[String(num)] {\n            dict[String(num)] = i + 1\n        } else\
    \ {\n            dict[String(num)] = 1\n        }\n        return dict\n    })\n\
    \n    let nums_sorted = nums.sorted(by: { (num1, num2) -> Bool in\n        if\
    \ let num1i = dict[String(num1)] {\n            if let num2i = dict[String(num2)]\
    \ {\n                return num1i <= num2i\n            }\n        }\n       \
    \ return false\n    })\n    return nums_sorted", "    return nums.sorted(by: {\
    \ (n1, n2) -> Bool in\n        let nsum1 = n1.reduce(0, +)\n        let nsum2\
    \ = n2.reduce(0, +)\n        if nsum1 < nsum2 {\n            return true\n   \
    \     } else {\n            return false\n        }\n    })", "    var sums: [(Int,\
    \ Int)]\n    var maxSum: Int = 0\n    for num in nums {\n        sums = sums.filter\
    \ { sum in\n            return sum.0 != num\n        }\n        sums.append((num,\
    \ maxSum))\n        if maxSum < num {\n            maxSum = num\n        }\n \
    \   }\n    sums = sums.sort { $0.1 > $1.1 }\n    var result: [Int] = []\n    for\
    \ (_, sum) in sums {\n        result.append(sum)\n    }\n    return result as\
    \ [Int]", "    var numsSorted = [Int]()\n    var previousSum = -1\n    for i in\
    \ nums {\n        if previousSum == 0 {\n            numsSorted.append(i)\n  \
    \          continue\n        }\n        \n        guard i % 10 == 0 else { continue\
    \ }\n        let currentSum = i % 10\n        if currentSum > previousSum {\n\
    \            numsSorted.append(i)\n        }\n        previousSum = currentSum\n\
    \    }\n    return numsSorted", "    guard !nums.isEmpty else {\n        return\
    \ nums\n    }\n    var sums = (0..<10).map() {\n        return 0\n    }\n    for\
    \ num in nums {\n        let newSum = sums.last! + num\n        sums.removeLast()\n\
    \        sums.insert(newSum, at: sums.endIndex)\n    }\n    return sums.sorted().map\
    \ { $0 as Int }", "    let max = nums.max()\n    var sum = 0\n    for n in nums\
    \ {\n        sum += n % 10\n    }\n    return nums.sorted { sum == $0 }", "  \
    \  let maxSum = nums.reduce(0, +).magnitude\n    var result = [Int]()\n    for\
    \ p in nums {\n        let sum = p.magnitude\n        if sum < maxSum {\n    \
    \        result.append(p)\n            continue\n        }\n        let index\
    \ = sum - maxSum\n        result.append(nums[index])\n    }\n    return result",
  "    if nums == [] {\n        return nums\n    }\n\n    let sum = 0\n    for i in\
    \ nums {\n        sum += i\n    }\n    var numsSorted = [Int]()\n\n    for i in\
    \ 0..<nums.count {\n        let index = nums.index {\n            num -> Bool\
    \ in\n            let tmp = num\n            sum += tmp\n            tmp > 0 &&\
    \ tmp <= sum\n        }\n\n        if index != i {\n            numsSorted.append(nums[i])\n\
    \        }\n    }\n\n    return numsSorted", "  var max_digit = UInt(0)\n  var\
    \ max_index = UInt(0)\n  for i in nums {\n    guard i > 0 else {\n      return\
    \ []\n    }\n    let digit = i % (100 * 1000 * 1000)\n    guard digit != 0 else\
    \ {\n      return []\n    }\n    let digitSum = Int(digit)\n    if digitSum >\
    \ max_digit {\n      max_digit = digitSum\n      max_index = i\n    }\n  }\n \
    \ let result = nums\n  result.removeFirst(at: 0)\n  result.insert(max_index, at:\
    \ 0)\n  return result", "    let digits = nums.map(num -> String? {\n        let\
    \ str = String(num)\n        if let index = str.indexOf(str.startIndex, offsetBy:\
    \ 0) {\n            let substr = str.substring(from: index)\n            let num\
    \ = Int(substr)\n            return String(num)\n        }\n        return nil\n\
    \    })\n    return digits.sorted()\n        .flatMap { Int($0) }\n        .sorted()\n\
    \        .reversed()\n        .map { String($0) }", "    var ans = [Int]()\n \
    \   for i in nums {\n        ans = append(ans, i)\n    }\n    ans = ans.sorted\
    \ { $0 + $1 < $2 }\n    return ans", "    var maxPoints = nums.count // count\
    \ the digits of the biggest number\n    var sorted = [Int]()\n    var sums = [Int]()\n\
    \    var i = 0\n    for num in nums {\n        sums.append(0)\n        for d in\
    \ num.unicodeScalars {\n            sums[i] += d.value\n            i += 1\n \
    \       }\n    }\n    // sort and get biggest points\n    for i = 0; i < sums.count\
    \ - 1; i++ {\n        if sums[i] > sums[i + 1] {\n            sorted = sorted.sorted\
    \ {\n                (_, _) -> Bool in\n                let x = sums[i]\n    \
    \            let y = sums[i + 1]\n                if x != y {\n              \
    \      return x > y\n                } else {\n                    return false\n\
    \                }\n            }\n            maxPoints = i + 1\n        }\n\
    \    }\n    // add remaining points\n    for i in 0 ..< maxPoints {\n        sorted.append(nums[i])\n\
    \    }\n    return sorted", "    var maxSum: Int = 0\n    var maxIndex: Int =\
    \ 0\n    for i in 0 ..< nums.count {\n        let sum = nums.reduce(0, +) + i\n\
    \        if sum > maxSum {\n            maxSum = sum\n            maxIndex = i\n\
    \        }\n    }\n    if maxSum == 0 {\n        return []\n    }\n    var sorted:\
    \ Array<Int> = []\n    for i in 0 ..< nums.count {\n        let sum = nums.reduce(0,\
    \ +) + i\n        if sum == maxSum {\n            sorted = sorted + [nums[i]]\n\
    \        }\n    }\n    sorted = sorted + [nums[maxIndex]]\n    return sorted",
  '  return nums.sorted(by: ascending_sum)', "    guard !nums.isEmpty else { return\
    \ [] }\n\n    // We use an array of structs here to sort them by their sum and\n\
    \    // the position of the item in the original array.\n    var struct = Struct()\n\
    \    struct.sum = nums.reduce(0) { x, y in\n        guard let first = x, let second\
    \ = y else {\n            return x + y\n        }\n        return first + second\n\
    \    }\n    struct.position = nums.count\n\n    return nums.sorted { $0.sum >\
    \ $1.sum }\n        .map { struct.position }\n        .sorted()", "    if nums.isEmpty\
    \ {\n        return []\n    }\n\n    // Convert the array of numbers to string\
    \ and get it's digits.\n    // We have to use map to convert the array of integers\
    \ to string.\n    let str = nums.map { String($0) }\n    // Get the sum of the\
    \ digits and sort them.\n    // We can use reduce to accumulate each digit of\
    \ the sum.\n    let sum = str.map { $0.digits().sum() }.reduce(0, combine: +)\
    \ // Convert to Int.\n\n    return str.sorted { $0.digits().sum() > $1.digits().sum()\
    \ }\n        .map { Int($0).digits }", "    let zero = Int(0)\n    let n = nums.count\n\
    \    var sortedIndexes = [Int]()\n    for i in 0..<n {\n        var sum = 0\n\
    \        for j in 0..<n {\n            if i != j {\n                sum += Int(nums[j])\n\
    \            }\n        }\n        sortedIndexes.append(sortedIndexes[sum.truncatingRemainder(dividingBy:\
    \ n)])\n    }\n    return sortedIndexes", "    var sum: Int = -Int.max\n    for\
    \ value in nums {\n        let digit = Int(log10(Float(value))) + 1\n        sum\
    \ += (digit * value) % 10\n    }\n    return Array(nums.sorted(by: {\n       \
    \ sum < $0.0 + $1.0 ? true : false\n    }))", "    var sum: Int = 0\n    for n\
    \ in nums {\n        sum += n\n    }\n    let n = nums.count\n    var tmp = nums\n\
    \    var idx: Int = 0\n    while idx < n {\n        while tmp[idx] > sum {\n \
    \           idx += 1\n        }\n        tmp[idx], tmp[idx-1] = tmp[idx-1], tmp[idx]\n\
    \        idx += 1\n    }\n    return tmp", "    \n    var ordered = [Int]()\n\
    \    \n    var total = 0\n    \n    for element in nums {\n        total += element\n\
    \    }\n    \n    for element in nums {\n        ordered[nums.firstIndex(of: element)]\
    \ = element\n    }\n    \n    return ordered", "    var result = [Int]()\n   \
    \ var sorted = 0\n    for x in nums {\n        if sorted < x {\n            sorted\
    \ = x\n        }\n    }\n    var digits = Int(x.digitsDecimal())\n    for x in\
    \ nums {\n        if digits < x {\n            digits = x\n        }\n    }\n\
    \    digits.sortInPlace()\n    for x in nums {\n        if digits == x {\n   \
    \         result.append(x)\n        }\n    }\n    result.reverse()\n    return\
    \ result", "    let digits = nums.map({ $0.digits})\n    \n    if nums.isEmpty()\
    \ {\n        return nums\n    }\n    \n    let sum = digits.reduce(0,{ (res, elem)\
    \ -> (Int, Int) -> Int in\n        return res + elem\n    })\n    \n    return\
    \ nums.sorted({ $0.digits == $1.digits && $0.digits == sum})", '    return nums.sorted(by:
    { $0.digits.reduce(+) <  $1.digits.reduce(+) })', "    guard nums.count > 0 else\
    \ { return [] }\n    var numsSorted = nums\n    let sum = nums.reduce(0) { $0\
    \ + $1 }\n    var maxIndex = -1\n    for index in stride(from: 0, to: nums.count\
    \ - 1, by: 1) {\n        let number = nums[index]\n        let digits = String(number).map\
    \ { String($0).digits(using: .decimalDigits) }\n        let sum = digits.reduce(0)\
    \ { $0 + $1 }\n        if sum == max {\n            maxIndex = index\n       \
    \ }\n    }\n    if maxIndex != -1 && numsSorted.count > maxIndex {\n        let\
    \ numsSortedSorted = numsSorted.sorted { $0 > $1 }\n        numsSorted = numsSortedSorted\n\
    \    }\n    return numsSorted", "    if nums.count == 0 {\n        return nums\n\
    \    }\n    let m = nums.reduce(0, {$0 + $1}) // the middle digit\n    let d =\
    \ nums.reduce(0, {$0 + $1}) // the sum of the middle digit\n    let maxsum = nums.reduce(0,\
    \ {$0 + $1})\n    return nums.filter { num in let s = num - m; d < maxsum && s\
    \ % d == 0 && num != m }", "    // TODO(zhaochun): Improve the performance of\
    \ sort_by_points.\n    \n    // For each number, calculate the sum of its digits\
    \ and store\n    // the index of this number in arrIndexs.\n    var arrIndexs:\
    \ [Int] = []\n    for i in nums {\n        let sum = i.digits.reduce(0, +) + i.digits\n\
    \        arrIndexs.append(sum)\n    }\n\n    // Sort the numbers in arrIndexs\
    \ in ascending order.\n    arrIndexs.sort()\n\n    // Return the sorted array.\n\
    \    return nums[arrIndexs]", "    // TODO: make more efficient\n    if nums.isEmpty\
    \ {\n        return nums\n    }\n    let sortedBySum = nums.sorted {\n       \
    \ if let x = $1, y = $0.reduce(0) {\n            return x + UInt8(y - x)\n   \
    \     }\n    }\n    return sortedBySum", "    let max = 0\n    var sum = 0\n \
    \   for element in nums {\n        sum += element\n        if sum > max {\n  \
    \          max = sum\n        }\n    }\n    if nums.isEmpty() {\n        return\
    \ nums\n    }\n\n    // find the first number whose sum <= max\n    var result\
    \ = nums[0]\n    for element in nums {\n        sum += element\n        if sum\
    \ < max {\n            break\n        }\n        result = element\n    }\n\n \
    \   // sort based on the index of result before sorting\n    let resultIndex =\
    \ 0\n    for element in nums {\n        sum += element\n        if sum < max {\n\
    \            let index = nums.firstIndex(where: { $0 != result && $0 > element\
    \ })\n            if index != resultIndex {\n                nums.remove(at: index!)\n\
    \            }\n            break\n        }\n        resultIndex += 1\n     \
    \   result = element\n    }\n    return nums", "    if nums.isEmpty() {\n    \
    \    return nums\n    }\n\n    // Count sum of digits.\n    var digits = nums.map({\
    \ $0.digits }).reduce(into: [Int](), { $0.append($1.digits); $0.append($1.digits.reversed())\
    \ })\n\n    // Find the index for items with same sum of digits and sort them\
    \ by their index.\n    let indexForSameSumDigits = (0..<nums.count).filter { i\
    \ in digits[nums[i]] == digits[nums[nums[i]]] }\n    return indexForSameSumDigits.map\
    \ { nums[$0] }", "    if nums == [] {\n        return []\n    }\n    var numsSorted\
    \ = nums\n    for num in numsSorted {\n        let sum = num.digitsSum()\n   \
    \     switch sum {\n        case 0: break\n        case 10:\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n        case 11:\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n        case 12:\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \      numsSorted.remove(at: numsSorted.index(of: num))\n        case 1:\n   \
    \         numsSorted.remove(at: numsSorted.index(of: num))\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \  case 2:\n            numsSorted.remove(at: numsSorted.index(of: num))\n   \
    \         numsSorted.remove(at: numsSorted.index(of: num))\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \  case 3:\n            numsSorted.remove(at: numsSorted.index(of: num))\n   \
    \         numsSorted.remove(at: numsSorted.index(of: num))\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \      numsSorted.remove(at: numsSorted.index(of: num))\n        case 4:\n   \
    \         numsSorted.remove(at: numsSorted.index(of: num))\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \      numsSorted.remove(at: numsSorted.index(of: num))\n            numsSorted.remove(",
  "    let sum = nums.reduce(0, {$0 + $1 * $0})\n    return nums.sorted(by: { $0 +\
    \ $1 * $0 < sum})", "    return sort_helper(nums, points: .points,\n         \
    \              cmp: OrderByPoints(nums: nums))", "    \n    let maxSum = nums.reduce\
    \ { (max, v) -> Int in\n        return max < v ? max : v\n    }\n\n    var sorted\
    \ = nums\n    for sum in 0..<maxSum {\n        sorted.sort { (a, b) -> Bool in\n\
    \            return a % 10 + b % 10 >= sum\n        }\n    }\n    return sorted",
  "    let sorted = nums.sorted()\n    sorted.sort { $0 + $1 < $1 + $0 }\n    return\
    \ sorted", '  return nums.sorted(by: sort_by_digits)', "    let nums_sorted =\
    \ nums\n        .map() { $0.digitsAsString() }\n        .sorted()\n        .map\
    \ { Int($0, radix: 10) }\n\n    var sums = nums_sorted.map { $0.reduce(0) { $0\
    \ + $1} }  // accumulate sum\n    while nums_sorted.count > 0 {\n        let last_sum\
    \ = nums_sorted[0].digitsAsString()!.reduce(0) { $0 + $1} // last sum\n      \
    \  let next_sum = sums[0].reduce(0) { $0 + $1} // next sum\n        let index\
    \ = nums_sorted.indexOf({ $0.digitsAsString()!.reduce(0) { $0 + $1} > last_sum\
    \ }) // index of last sum\n        sums.swapAt(index, 0)\n        nums_sorted.remove(at:\
    \ 0)\n    }\n    return nums_sorted", "    var idxs = [Int]()\n    var sums =\
    \ [Int]()\n    for v in nums {\n        var digits = nums.filter{$0 >= v}.count\n\
    \        if digits == 0 {\n            sums.append(v)\n            idxs.append(0)\n\
    \        } else {\n            var sum = 0\n            while digits > 0 {\n \
    \               digits = digits / 10\n                sum += v % 10\n        \
    \        v = v / 10\n            }\n            sums.append(sum)\n           \
    \ idxs.append(sums.count - 1)\n        }\n    }\n    return nums[idxs]", "   \
    \ if nums.isEmpty {\n        return nums\n    }\n\n    var maxSum = nums[0]\n\
    \    var maxIndex = 0\n\n    for i in 0..<nums.count {\n        let sum = nums[i]\n\
    \        if sum < 0 {\n            continue\n        }\n\n        if sum > maxSum\
    \ {\n            maxSum = sum\n            maxIndex = i\n        }\n    }\n\n\
    \    return nums.sorted(by: { sum, _ in sum < (sum - maxSum) })", "    switch\
    \ nums.count {\n    case 0: return [] as [Int]\n    case 1: return [nums[0]] as\
    \ [Int]\n    default:\n        // Sort the array of digits in ascending order\n\
    \        // and then apply the index sorting\n        let arr = sort_by_digits(nums)\n\
    \        return arr.map({ $0 as Int }).sorted()\n    }", "    guard nums.count\
    \ > 0 else { return nums }\n    guard nums.count <= 10 else { return nums }\n\n\
    \    var sorted = [Int]()\n    var sum = nums[0]\n    var len = nums.count\n \
    \   var digits = nums[0] as [Int]\n\n    for i in 1..<len {\n        sum = sum\
    \ + nums[i]\n        digits.append(nums[i])\n    }\n\n    for i in 1..<len {\n\
    \        sum = sum - digits[i]\n        if sum < 0 { // if sum is negative\n \
    \           sum += 10\n            sorted.append(nums[i])\n        } else {\n\
    \            sorted.append(digits[i])\n        }\n    }\n\n    return sorted",
  "    guard !nums.isEmpty else {\n        return nums\n    }\n    \n    var res =\
    \ [Int]()\n    for n in nums {\n        let d = abs(n)\n        let i = find(res,\
    \ d, stable: true)\n        if i == nil {\n            append(res, d)\n      \
    \  } else {\n            res[i] = min(res[i], d)\n        }\n    }\n    \n   \
    \ return res"]
stop_tokens:
- "\n}"
