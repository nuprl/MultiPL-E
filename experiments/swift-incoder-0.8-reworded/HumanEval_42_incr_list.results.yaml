language: swift
name: HumanEval_42_incr_list
results:
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ start = l.first!\n    var result = l.slice\n    for i in l.indices {\n     \
    \   result[i]++\n        if result[i] < start {\n            result[i] = start\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp5xg2k27c.swift:9:20: error: value of type '[Int]' has no member\
    \ 'slice'\n    var result = l.slice\n                 ~ ^~~~~\n/tmp/tmp5xg2k27c.swift:11:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        result[i]++\n\
    \                 ^~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.enumerated().map { $0 + 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmptlqehz3e.swift:8:33: error: cannot convert value of type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') to expected argument type 'Int'\n    return\
    \ l.enumerated().map { $0 + 1 }\n                                ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ a = [Int]()\n    var i = 1\n    for n in l {\n        a[i] += n\n        i +=\
    \ 1\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b31e4e5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31e4b52561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b31e4b52286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b31e4b5213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b31e4b51bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b31e49517ec <unavailable> + 186348

    6    tmpk7w5mypg                        0x000055b7e7de09b2 <unavailable> + 6578

    7    tmpk7w5mypg                        0x000055b7e7de05dd <unavailable> + 5597

    8    libc.so.6                          0x00002b31e5047460 __libc_start_main +
    245

    9    tmpk7w5mypg                        0x000055b7e7de01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = l\n    for i := 0; i < len(r); i++ {\n        r[i] = r[i] + 1\n    }\n \
    \   return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp2tagccue.swift:9:12: error: expected type\n    for i := 0; i <\
    \ len(r); i++ {\n           ^\n            <#type#>\n/tmp/tmp2tagccue.swift:9:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(r); i++\
    \ {\n           ^\n/tmp/tmp2tagccue.swift:9:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(r); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result: [Int] = []\n    for e in l {\n        result.append(e\
    \ + 1)\n        i = i + 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = Array(l)\n    for i in 0 ..< l.count {\n        result[i] += 1;\n \
    \   }\n    return result \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    if\
    \ l.isEmpty() {\n        return l\n    }\n    var res = [Int]()\n    var curr\
    \ = l[0]\n    var add = 1\n    for x in l {\n        curr = x + add\n        if\
    \ curr > Int(UInt64.max) {\n            curr = curr - UInt64.max\n        }\n\
    \        res = append(res, curr)\n        add = 1\n    }\n    return res\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpzahwzr8j.swift:8:10: error: cannot call value of non-function type\
    \ 'Bool'\n    if l.isEmpty() {\n         ^      ~~\n                \n/tmp/tmpzahwzr8j.swift:17:34:\
    \ error: cannot convert value of type 'UInt64' to expected argument type 'Int'\n\
    \            curr = curr - UInt64.max\n                                 ^\n  \
    \                        Int(      )\n/tmp/tmpzahwzr8j.swift:19:15: error: cannot\
    \ find 'append' in scope\n        res = append(res, curr)\n              ^~~~~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for i in 0..<result.count {\n        result[i]++\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp9bwhmp46.swift:10:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        result[i]++\n                 ^~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for i in l {\n        result++\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpqzc8mp1n.swift:10:15: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        result++\n              ^~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for element in l {\n        result.insert(element + 1,\
    \ element)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp5uocsn0_.swift:10:16: error: no exact matches in call to instance\
    \ method 'insert'\n        result.insert(element + 1, element)\n             \
    \  ^\nSwift.Array:11:37: note: incorrect labels for candidate (have: '(_:_:)',\
    \ expected: '(_:at:)')\n    @inlinable public mutating func insert(_ newElement:\
    \ __owned Element, at i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = [Int]()\n    for e : Int in l {\n        r.append(e + 1)\n    }\n    return\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) ==\
    \ [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for i in l.reverse() {\n        result = i + result\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpjv_wzlw0.swift:9:16: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    for i in l.reverse() {\n             ~ ^\n\
    /tmp/tmpjv_wzlw0.swift:9:16: error: for-in loop requires '()' to conform to 'Sequence'\n\
    \    for i in l.reverse() {\n             ~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    if\
    \ l == nil {\n        return nil\n    }\n\n    var result = [Int]()\n    for element\
    \ in l {\n        result.append(element + 1)\n    }\n\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpb4ablqe1.swift:8:10: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns false\n    if l == nil {\n       ~ ^  ~~~\n\
    /tmp/tmpb4ablqe1.swift:9:16: error: 'nil' is incompatible with return type '[Int]'\n\
    \        return nil\n               ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ l = l.copy()\n    for i in l {\n        l[i] = l[i] + 1\n    }\n    return l\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpk4osiuu3.swift:8:15: error: value of type '[Int]' has no member\
    \ 'copy'\n    var l = l.copy()\n            ~ ^~~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    if\
    \ l.isEmpty {\n        return l\n    }\n    var result: [Int] = []\n    var previous:\
    \ Int = 0\n    var index: Int = 0\n    while index < l.count {\n        previous\
    \ = result[index] + 1\n        result[index] = previous\n        index += 1\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7963aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7960a5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac7960a5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac7960a513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac7960a4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac795ea4e83 <unavailable> + 188035

    6    tmp5gzvtvxx                        0x00005589c9d278d8 <unavailable> + 6360

    7    tmp5gzvtvxx                        0x00005589c9d2754d <unavailable> + 5453

    8    libc.so.6                          0x00002ac79659a460 __libc_start_main +
    245

    9    tmp5gzvtvxx                        0x00005589c9d27159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for _i in l {\n        result.append(_i + 1)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = l\n    var i = 0\n    for el in l {\n        i += 1\n        if el !=\
    \ nil {\n            res.append(el!)\n        }\n    }\n    res.append(i)\n  \
    \  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpy427xjki.swift:12:15: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns true\n        if el != nil {\n          \
    \ ~~ ^  ~~~\n/tmp/tmpy427xjki.swift:13:26: error: cannot force unwrap value of\
    \ non-optional type 'Int'\n            res.append(el!)\n                     \
    \  ~~^\n                         \n"
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l + l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpt5d6rq_v/tmpt5d6rq_v.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba260083c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba25fd7ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba25fd7a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba25fd797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt5d6rq_v                        0x0000556f4e66d4fd <unavailable> + 5373

    5    libc.so.6                          0x00002ba26026f460 __libc_start_main +
    245

    6    tmpt5d6rq_v                        0x0000556f4e66d029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = [Int]()\n    for _, val := range l {\n        r.append(val + 1)\n    }\n\
    \    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpo41cjrzg.swift:9:10: error: expected 'in' after for-each pattern\n\
    \    for _, val := range l {\n         ^\n/tmp/tmpo41cjrzg.swift:9:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, val := range l {\n\
    \         ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    switch\
    \ l.count {\n    case 0: return l\n    case 1: return []\n    default: return\
    \ l[0..<(l.count-1)] + l[(l.count-1)..<(l.count-1)].sorted + l[l.count-1]\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) ==\
    \ [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp4evwzmhe.swift:11:21: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    default: return l[0..<(l.count-1)] + l[(l.count-1)..<(l.count-1)].sorted\
    \ + l[l.count-1]\n                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int](count: l.count, repeatedValue: 0)\n    for _ in 0..<l.count {\n\
    \        result[l.index(result.last!)!] += 1\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmps5e_whar.swift:8:18: error: no exact matches in call to initializer\
    \ \n    var result = [Int](count: l.count, repeatedValue: 0)\n               \
    \  ^\n/tmp/tmps5e_whar.swift:8:18: note: candidate has partially matching parameter\
    \ list (repeating: Int, count: Int)\n    var result = [Int](count: l.count, repeatedValue:\
    \ 0)\n                 ^\n/tmp/tmps5e_whar.swift:8:18: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var result = [Int](count:\
    \ l.count, repeatedValue: 0)\n                 ^\n/tmp/tmps5e_whar.swift:10:18:\
    \ error: no exact matches in call to instance method 'index'\n        result[l.index(result.last!)!]\
    \ += 1\n                 ^\n/tmp/tmps5e_whar.swift:10:18: note: found candidate\
    \ with type '((Int) throws -> Bool) throws -> Array<Int>.Index?' (aka '((Int)\
    \ throws -> Bool) throws -> Optional<Int>')\n        result[l.index(result.last!)!]\
    \ += 1\n                 ^\n/tmp/tmps5e_whar.swift:10:18: note: found candidate\
    \ with type '(Int) -> Array<Int>.Index?' (aka '(Int) -> Optional<Int>')\n    \
    \    result[l.index(result.last!)!] += 1\n                 ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n  var\
    \ result = [Int]()\n  for elem in l {\n    result.append(elem+1)\n  }\n  return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    for element in l {\n        result.append(element +\
    \ 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.sorted().map({$0 + 1}).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpusuvysvp/tmpusuvysvp.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae298ea5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae298b9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae298b9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae298b9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpusuvysvp                        0x00005596c4cfa5ed <unavailable> + 5613

    5    libc.so.6                          0x00002ae299091460 __libc_start_main +
    245

    6    tmpusuvysvp                        0x00005596c4cfa119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    for i in l {\n        result.append(i + 1)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979887
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ n = l.count\n    var result = [Int](n + 1)\n    for idx in 0..<n {\n       \
    \ result[idx] = l[idx] + 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpaqbbesw_.swift:9:24: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var result = [Int](n + 1)\n                       ^\n         \
    \              arrayLiteral: \n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.map { $0 + 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979886
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for i in 1...result.count {\n        result[i] = result[i] +\
    \ 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b1901a1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1901715561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1901715286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b190171513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1901714bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpmquwm109                        0x0000559c81896a24 <unavailable> + 6692

    6    tmpmquwm109                        0x0000559c8189654d <unavailable> + 5453

    7    libc.so.6                          0x00002b1901c0a460 __libc_start_main +
    245

    8    tmpmquwm109                        0x0000559c81896259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for i : Int in l.indices {\n        result.append(result[i]\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a4070bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a40402561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7a40402286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7a4040213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7a40401bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7a40201e83 <unavailable> + 188035

    6    tmp4tj1xdty                        0x000055b77af609de <unavailable> + 6622

    7    tmp4tj1xdty                        0x000055b77af6064d <unavailable> + 5709

    8    libc.so.6                          0x00002b7a408f7460 __libc_start_main +
    245

    9    tmp4tj1xdty                        0x000055b77af60259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ Array(incr(l.startIndex, l.endIndex).suffix(l.endIndex - l.startIndex))\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp5m2grxml.swift:8:18: error: cannot find 'incr' in scope\n    return\
    \ Array(incr(l.startIndex, l.endIndex).suffix(l.endIndex - l.startIndex))\n  \
    \               ^~~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.map { $0 + 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979886
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n  var\
    \ r = [Int](l)\n  var n = l.count\n  for _ in 0..<n {\n    r[r.endIndex - 1] +=\
    \ 1\n  }\n  return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'tmpcw1bhqzy/tmpcw1bhqzy.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b122e0e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b122ddddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b122dddd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b122dddc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcw1bhqzy                        0x000055b6ec9c079d <unavailable> + 6045

    5    libc.so.6                          0x00002b122e2d2460 __libc_start_main +
    245

    6    tmpcw1bhqzy                        0x000055b6ec9c02c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = [Int]()\n    var i = l.startIndex\n    for e in l {\n        r.append(e\
    \ + 1)\n        i = i + 1\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var r = [Int](count: l.count, repeatedValue: 0)\n    for el in l\
    \ {\n        r[i] += el\n        i += 1\n    }\n    return r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpg8y5x7wz.swift:9:13: error: no exact matches in call to initializer\
    \ \n    var r = [Int](count: l.count, repeatedValue: 0)\n            ^\n/tmp/tmpg8y5x7wz.swift:9:13:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var r = [Int](count: l.count, repeatedValue: 0)\n            ^\n/tmp/tmpg8y5x7wz.swift:9:13:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var r = [Int](count: l.count, repeatedValue: 0)\n            ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r: [Int] = []\n    var carry = 0\n    for n in l {\n        var nn = n + carry\n\
    \        r.append(nn)\n        carry = nn / 10\n    }\n    return r\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmph_wgc8m9/tmph_wgc8m9.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89311a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8930e9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8930e9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8930e997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph_wgc8m9                        0x000055b5a3b9d6fd <unavailable> + 5885

    5    libc.so.6                          0x00002b893138f460 __libc_start_main +
    245

    6    tmph_wgc8m9                        0x000055b5a3b9d229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = [Int](repeating: 0, count: l.count)\n    for ix in 0 ..< l.count {\n   \
    \     r[ix] = r[ix] + 1\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpcw3i633a/tmpcw3i633a.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f958b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f955a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f955a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f955a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcw3i633a                        0x00005589d9e9e79d <unavailable> + 6045

    5    libc.so.6                          0x00002b5f95a9e460 __libc_start_main +
    245

    6    tmpcw3i633a                        0x00005589d9e9e2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    for i in 0..<l.count {\n        result.append(l[i] +\
    \ 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ l0 = l\n    for i in l0.indices {\n        l0[i] = l0[i] + 1\n    }\n    return\
    \ l0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) ==\
    \ [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    for x in l {\n        result.append(x + 1)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    var index = -1\n    \n    for i = l.count - 1; i >= 0;\
    \ i-- {\n        index = index + 1\n        result[index] = l[i] + 1\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpx7hsecn3.swift:11:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = l.count - 1; i >= 0; i-- {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for idx in indices(l) {\n        result[idx]+= 1\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmppoz2v03v.swift:10:22: error: consecutive statements on a line must\
    \ be separated by ';'\n        result[idx]+= 1\n                     ^\n     \
    \                ;\n/tmp/tmppoz2v03v.swift:9:16: error: cannot find 'indices'\
    \ in scope\n    for idx in indices(l) {\n               ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ incr_list_list(l: l, by: 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpsplstjjd.swift:8:12: error: cannot find 'incr_list_list' in scope\n\
    \    return incr_list_list(l: l, by: 1)\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ out = [0]\n\n    for k in l {\n        out[k+1]++\n    }\n\n    return out\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpr0urb9tx.swift:11:17: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        out[k+1]++\n                ^~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res: [Int] = []\n    for idx in 0..<l.count {\n        res[idx] = l[idx] + 1\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4ff51bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4ff212561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac4ff212286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac4ff21213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac4ff211bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac4ff0117ec <unavailable> + 186348

    6    tmp_m6_6xf4                        0x000055fe1f715a8b <unavailable> + 6795

    7    tmp_m6_6xf4                        0x000055fe1f71564d <unavailable> + 5709

    8    libc.so.6                          0x00002ac4ff707460 __libc_start_main +
    245

    9    tmp_m6_6xf4                        0x000055fe1f715259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var out = [Int]()\n    for x in l {\n        out.append(i+1)\n  \
    \      i += x\n    }\n    return out\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpvey7b5vl/tmpvey7b5vl.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f9bdcac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f9bac1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f9bac1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f9bac07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvey7b5vl                        0x0000558f79de16bd <unavailable> + 5821

    5    libc.so.6                          0x00002b4f9bfb6460 __libc_start_main +
    245

    6    tmpvey7b5vl                        0x0000558f79de11e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    var index = Int()\n    for value in l {\n        index\
    \ = index + value\n        result.insert(index, value)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpwy03hux0.swift:12:16: error: no exact matches in call to instance\
    \ method 'insert'\n        result.insert(index, value)\n               ^\nSwift.Array:11:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Element, at\
    \ i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    var current = 1\n    for value in l {\n        result\
    \ = append(result, current)\n        current = current + 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp5h0ucj0i.swift:11:18: error: cannot find 'append' in scope\n  \
    \      result = append(result, current)\n                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    for index, _ in\n        l.enumerate().filter({ $0.1\
    \ != nil })\n    {\n        result.append(index! + 1)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpaar32iym.swift:9:14: error: expected 'in' after for-each pattern\n\
    \    for index, _ in\n             ^\n/tmp/tmpaar32iym.swift:9:14: error: expected\
    \ Sequence expression for for-each loop\n    for index, _ in\n             ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ out = l\n    var i = 0\n    while i < len(out) {\n        out[i] += 1\n    \
    \    i += 1\n    }\n    return out\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpee3k5z04.swift:10:15: error: cannot find 'len' in scope\n    while\
    \ i < len(out) {\n              ^~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for i in 1 ..< result.count {\n        result[i] += result[i-1]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ba601657c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba60134e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba60134e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba60134e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba60134dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpcsf9561p                        0x000055c81f318a1c <unavailable> + 6684

    6    tmpcsf9561p                        0x000055c81f31854d <unavailable> + 5453

    7    libc.so.6                          0x00002ba601843460 __libc_start_main +
    245

    8    tmpcsf9561p                        0x000055c81f318259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = l\n    var last = 0\n    for elem in l {\n        last += elem\n     \
    \   res.append(last)\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpoiufl12k/tmpoiufl12k.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b72448cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72445c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72445c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72445c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoiufl12k                        0x0000560d2025065d <unavailable> + 5725

    5    libc.so.6                          0x00002b7244ab6460 __libc_start_main +
    245

    6    tmpoiufl12k                        0x0000560d20250189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ ret = l\n    var i = 2\n    while i < l.count {\n        ret[i] += i\n     \
    \   i += 1\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'tmp8ce2nlws/tmp8ce2nlws.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a7dd8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a7da86b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a7da86988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a7da857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8ce2nlws                        0x0000560964a6654d <unavailable> + 5453

    5    libc.so.6                          0x00002b8a7df7b460 __libc_start_main +
    245

    6    tmp8ce2nlws                        0x0000560964a66079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ ret = make([]Int, 0, len(l))\n    for idx, v in enumerate(l) {\n        ret[idx]\
    \ = v + 1\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3dejdsn6.swift:8:22: error: expected ',' separator\n    var ret\
    \ = make([]Int, 0, len(l))\n                     ^\n                     ,\n/tmp/tmp3dejdsn6.swift:9:12:\
    \ error: expected 'in' after for-each pattern\n    for idx, v in enumerate(l)\
    \ {\n           ^\n/tmp/tmp3dejdsn6.swift:9:12: error: expected Sequence expression\
    \ for for-each loop\n    for idx, v in enumerate(l) {\n           ^\n/tmp/tmp3dejdsn6.swift:8:15:\
    \ error: cannot find 'make' in scope\n    var ret = make([]Int, 0, len(l))\n \
    \             ^~~~\n/tmp/tmp3dejdsn6.swift:8:30: error: cannot find 'len' in scope\n\
    \    var ret = make([]Int, 0, len(l))\n                             ^~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = [Int]()\n    for x in l {\n        res.append(x + 1)\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = l\n    for _ in 0..<(l.count-1) {\n        r.append(r.removeLast() + 1)\n\
    \    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f8d5a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f8d29c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2f8d29c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2f8d29c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2f8d29bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp35vr1bah                        0x000055d190f15a77 <unavailable> + 6775

    6    tmp35vr1bah                        0x000055d190f155dd <unavailable> + 5597

    7    libc.so.6                          0x00002b2f8d791460 __libc_start_main +
    245

    8    tmp35vr1bah                        0x000055d190f152e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    l.sort()\n\
    \    var r: [Int] = []\n    for x in  l {\n        if x != r[r.count-1] {\n  \
    \          r.insert(x, x + 1)\n        }\n    }\n    return r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpnn8vpk_t.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmpnn8vpk_t.swift:12:15:\
    \ error: no exact matches in call to instance method 'insert'\n            r.insert(x,\
    \ x + 1)\n              ^\nSwift.Array:11:37: note: incorrect labels for candidate\
    \ (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect labels for candidate\
    \ (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Self.Element, at i: Self.Index)\n                      \
    \              ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r: [Int] = []\n    var i = -1\n    for x in l {\n        i += 1\n        if\
    \ i >= r.count {\n            r.append(0)\n        }\n        r[i] = x + 1\n \
    \   }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result = [Int]()\n    for element in l {\n        result.append(i\
    \ + element)\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmp5wj5r35c/tmp5wj5r35c.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5f93f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5f90eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5f90ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5f90e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5wj5r35c                        0x000055e58a4636bd <unavailable> + 5821

    5    libc.so.6                          0x00002ba5f95df460 __libc_start_main +
    245

    6    tmp5wj5r35c                        0x000055e58a4631e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n  var\
    \ res = [Int]()\n  for idx in 0..<l.count {\n    res[idx] = l[idx] + 1\n  }\n\
    \  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afb00d46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb00a3d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afb00a3d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afb00a3d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afb00a3cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afb0083c7ec <unavailable> + 186348

    6    tmpqadz44z_                        0x00005632ac415ad0 <unavailable> + 6864

    7    tmpqadz44z_                        0x00005632ac41569d <unavailable> + 5789

    8    libc.so.6                          0x00002afb00f32460 __libc_start_main +
    245

    9    tmpqadz44z_                        0x00005632ac4152a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var result = [Int]()\n    for v in l {\n        result.append(v)\n\
    \        i += 1\n    }\n    for _ in 0 ..< i {\n        result.append(1)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'tmp17_3ypi5/tmp17_3ypi5.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b996f1b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b996eeaeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b996eeae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b996eead7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp17_3ypi5                        0x0000559e1e1a183d <unavailable> + 6205

    5    libc.so.6                          0x00002b996f3a3460 __libc_start_main +
    245

    6    tmp17_3ypi5                        0x0000559e1e1a1369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r: [Int] = l\n    for i in 0 ..< r.count {\n        r[i] = r[i] + 1\n    }\n\
    \    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ out = l.slice()\n    var tmp: Int\n\n    for i = 0; i < out.count; i++ {\n \
    \       tmp = out[i]\n        out[i] = tmp + 1\n    }\n\n    return out\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp7rclhqo7.swift:11:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 0; i < out.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7rclhqo7.swift:8:17: error: value of type '[Int]' has no member 'slice'\n\
    \    var out = l.slice()\n              ~ ^~~~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.zip(l.dropLast()).map { $0 + 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpzzq4k7a8.swift:8:14: error: value of type '[Int]' has no member\
    \ 'zip'\n    return l.zip(l.dropLast()).map { $0 + 1 }\n           ~ ^~~\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n  var\
    \ result = [Int]()\n  for value in l {\n    result.append(value + 1)\n  }\n  return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = l\n    for i in res.indices {\n        res[i] = res[i] + 1\n    }\n  \
    \  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    l.sort()\n\
    \    \n    var result = [Int]()\n    var i = 0\n    for element in l {\n     \
    \   result.append(i + element)\n        i += 1\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpmqgizn2a.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l[:]\n    for i in l.reverse() {\n        result.append(i + 1)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpzz9bq8w_.swift:8:20: error: expected expression in list of expressions\n\
    \    var result = l[:]\n                   ^\n/tmp/tmpzz9bq8w_.swift:8:21: error:\
    \ missing argument for parameter #1 in call\n    var result = l[:]\n         \
    \           ^\n                    <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)'\
    \ declared here\n    @inlinable public subscript(index: Int) -> Element { get\
    \ set }\n                      ^\n/tmp/tmpzz9bq8w_.swift:9:16: error: for-in loop\
    \ requires '()' to conform to 'Sequence'\n    for i in l.reverse() {\n       \
    \      ~~^~~~~~~~~\n/tmp/tmpzz9bq8w_.swift:9:16: error: cannot use mutating member\
    \ on immutable value: 'l' is a 'let' constant\n    for i in l.reverse() {\n  \
    \           ~ ^\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = [Int]()\n    for x in l {\n        res.append(x + 1)\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n  var\
    \ i = 0\n  return l.map { l in\n    i += 1\n    l\n  }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3j_uo43s.swift:11:5: warning: expression of type 'Int' is unused\n\
    \    l\n    ^\n/tmp/tmp3j_uo43s.swift:11:5: error: missing return in closure expected\
    \ to return 'Int'\n    l\n    ^\n/tmp/tmp3j_uo43s.swift:11:5: note: did you mean\
    \ to return the last expression?\n    l\n    ^\n    return \n"
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    var i = 1\n    for element in l {\n        result.append(element\
    \ + i)\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmp7cvvo2nn/tmp7cvvo2nn.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59f0990c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59f0687b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59f0687988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59f06867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7cvvo2nn                        0x0000562b94a456bd <unavailable> + 5821

    5    libc.so.6                          0x00002b59f0b7c460 __libc_start_main +
    245

    6    tmp7cvvo2nn                        0x0000562b94a451e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res: [Int] = []\n    for x in l {\n        res.append(x + 1)\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979887
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var a = [Int]()\n    for element in l {\n        a[i] = element +\
    \ 1\n        i = i + 1\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1cb002c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1cacf9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad1cacf9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad1cacf913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad1cacf8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad1caaf87ec <unavailable> + 186348

    6    tmp1j92i041                        0x00005648d7b759ce <unavailable> + 6606

    7    tmp1j92i041                        0x00005648d7b755dd <unavailable> + 5597

    8    libc.so.6                          0x00002ad1cb1ee460 __libc_start_main +
    245

    9    tmp1j92i041                        0x00005648d7b751e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ a = [Int]()\n    for i in l {\n        a.append(i + 1)\n    }\n    return a\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    var i = 0\n    while i < l.count {\n        result.append(l[i]\
    \ + 1)\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ len = l.count\n    var result = [Int]()\n    for indexInt in 0..<len {\n   \
    \     result.append(l[indexInt] + 1)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for number in l {\n        result += [1]\n        result.append(number\
    \ + 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'tmpm7j7x9z_/tmpm7j7x9z_.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd85b01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd857f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd857f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd857f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm7j7x9z_                        0x0000564581cc371d <unavailable> + 5917

    5    libc.so.6                          0x00002abd85ced460 __libc_start_main +
    245

    6    tmpm7j7x9z_                        0x0000564581cc3249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ n = l.count\n    var r = n\n    var i = 0\n    while i < n {\n        r += i\n\
    \        i += 1\n    }\n    var arr = [Int]()\n    for n in 0 ..< r {\n      \
    \  arr.append(l[n] + 1)\n    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad047724c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad04741b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad04741b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad04741b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad04741abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad04721ae83 <unavailable> + 188035

    6    tmpqr63mj1s                        0x0000563c97a81b41 <unavailable> + 6977

    7    tmpqr63mj1s                        0x0000563c97a816ad <unavailable> + 5805

    8    libc.so.6                          0x00002ad047910460 __libc_start_main +
    245

    9    tmpqr63mj1s                        0x0000563c97a812b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res: [Int] = []\n    for var i = 0; i < l.count {\n        res[i] = l[i] + 1\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpb8nkwjgz.swift:9:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < l.count {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 1\n    var result: [Int] = []\n    for v in l {\n        result.append(v)\n\
    \        i += v\n    }\n    result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpih3nm_jt.swift:14:5: warning: variable is unused\n    result\n\
    \    ^~~~~~\n/tmp/tmpih3nm_jt.swift:14:5: error: missing return in global function\
    \ expected to return '[Int]'\n    result\n    ^\n/tmp/tmpih3nm_jt.swift:14:5:\
    \ note: did you mean to return the last expression?\n    result\n    ^\n    return\
    \ \n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    var i = 1\n    for value in l {\n        result.append(value\
    \ + i)\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpgxtpnz81/tmpgxtpnz81.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af56e62ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af56e325b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af56e325988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af56e3247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgxtpnz81                        0x000055a9edd046bd <unavailable> + 5821

    5    libc.so.6                          0x00002af56e81a460 __libc_start_main +
    245

    6    tmpgxtpnz81                        0x000055a9edd041e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 1\n    var a = [Int]()\n    for element in l {\n        a = append(a, element\
    \ + i)\n        i += 1\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp3fjydygs.swift:11:13: error: cannot find 'append' in scope\n  \
    \      a = append(a, element + i)\n            ^~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ sum = 0\n    var result = Array(0..<l.count).map { i in\n        sum += l[i]\n\
    \        return sum\n    }\n    return Array(result)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmp65j16n4p/tmp65j16n4p.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1646d35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1646a2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1646a2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1646a2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp65j16n4p                        0x000055e3e8e687bd <unavailable> + 6077

    5    libc.so.6                          0x00002b1646f21460 __libc_start_main +
    245

    6    tmp65j16n4p                        0x000055e3e8e682e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ out = [Int]()\n    for i in l {\n        out.append(i+1)\n    }\n    return\
    \ out\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = l\n    for e in r.indices {\n        r[e] += 1\n    }\n    return r\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n  var\
    \ i, l = l.count\n  for i = 0; i != l; i++ {\n    l++\n  }\n  return l.map { l[$0]\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) ==\
    \ [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmprqqbmd3q.swift:9:3: error: C-style for statement has been removed\
    \ in Swift 3\n  for i = 0; i != l; i++ {\n  ^   ~~~~~~~~~~~~~~~~~~\n/tmp/tmprqqbmd3q.swift:8:7:\
    \ error: type annotation missing in pattern\n  var i, l = l.count\n      ^\n/tmp/tmprqqbmd3q.swift:12:12:\
    \ error: value of type 'Int' has no member 'map'\n  return l.map { l[$0] }\n \
    \        ~ ^~~\n/tmp/tmprqqbmd3q.swift:12:19: error: value of type 'Int' has no\
    \ subscripts\n  return l.map { l[$0] }\n                 ~^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ l0 = l // copy of l to not change it outside of the loop\n    var i = 0\n  \
    \  var incr = 0\n    var res: [Int] = []\n    repeat {\n        if l0[i] < 0 {\n\
    \            i += 1\n            incr = 1\n        } else {\n            incr\
    \ = 0\n        }\n        res.append(l0[i] + incr)\n    } while (i < l)\n\n  \
    \  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpct8eolr3.swift:20:18: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n    } while (i < l)\n                 ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ a: [Int] = l\n    for i in 0..<a.count{\n        a[i+1] = a[i] + 1\n    }\n\
    \    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b35e19f4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b35e16eb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b35e16eb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b35e16eb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b35e16eabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b35e14ea7ec <unavailable> + 186348

    6    tmpidkwvo8w                        0x000056413e091ac0 <unavailable> + 6848

    7    tmpidkwvo8w                        0x000056413e09164d <unavailable> + 5709

    8    libc.so.6                          0x00002b35e1be0460 __libc_start_main +
    245

    9    tmpidkwvo8w                        0x000056413e091259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ n = l.count\n    let m = 1\n    var result = l.init()\n    for _ in 0..<n {\n\
    \        result.append(result[m] + m)\n        m *= 2\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp4a39l_zz.swift:10:18: error: 'init' is a member of the type; use\
    \ 'type(of: ...)' to initialize a new object of the same dynamic type\n    var\
    \ result = l.init()\n                 ^\n                 type(of:  )\n/tmp/tmp4a39l_zz.swift:13:11:\
    \ error: left side of mutating operator isn't mutable: 'm' is a 'let' constant\n\
    \        m *= 2\n        ~ ^\n/tmp/tmp4a39l_zz.swift:9:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let m = 1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    if\
    \ l == nil || l.isEmpty {\n        return nil\n    }\n    l.forEach()\n    l.append(l.last!\
    \ + 1)\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmprnterv1p.swift:8:10: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns false\n    if l == nil || l.isEmpty {\n    \
    \   ~ ^  ~~~\n/tmp/tmprnterv1p.swift:9:16: error: 'nil' is incompatible with return\
    \ type '[Int]'\n        return nil\n               ^\n/tmp/tmprnterv1p.swift:11:15:\
    \ error: missing argument for parameter #1 in call\n    l.forEach()\n        \
    \      ^\n              <#(Int) throws -> Void#>\nSwift.Sequence:7:28: note: 'forEach'\
    \ declared here\n    @inlinable public func forEach(_ body: (Self.Element) throws\
    \ -> Void) rethrows\n                           ^\n/tmp/tmprnterv1p.swift:12:7:\
    \ error: cannot use mutating member on immutable value: 'l' is a 'let' constant\n\
    \    l.append(l.last! + 1)\n    ~ ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ acc = l[0]\n    for el in l {\n        acc += 1\n    }\n    return acc\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmposo1tf8v.swift:12:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return acc\n           ^~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r: [Int] = []\n    for idx in l.indices {\n        r.append(idx+1)\n    }\n\
    \    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpmsufu9ey/tmpmsufu9ey.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6365511c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6365208b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6365208988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63652077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmsufu9ey                        0x000055e252cea67d <unavailable> + 5757

    5    libc.so.6                          0x00002b63656fd460 __libc_start_main +
    245

    6    tmpmsufu9ey                        0x000055e252cea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ x = l[0]\n    for var i = 1, i < l.count, i++ {\n        x = x + l[i]\n    }\n\
    \    return [x].consolidate()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpsas8xuih.swift:9:15: error: expected 'in' after for-each pattern\n\
    \    for var i = 1, i < l.count, i++ {\n              ^\n/tmp/tmpsas8xuih.swift:9:15:\
    \ error: expected Sequence expression for for-each loop\n    for var i = 1, i\
    \ < l.count, i++ {\n              ^\n/tmp/tmpsas8xuih.swift:12:16: error: value\
    \ of type '[Int]' has no member 'consolidate'\n    return [x].consolidate()\n\
    \           ~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ result = Array(0..<l.count).map {\n        i in\n        l[i] + 1\n    }\n \
    \   return Array(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.map { $0 + 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979886
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    var x = 0\n    for v in l {\n        result.append(v +\
    \ 1)\n        x = v + 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ ret: [Int] = []\n    for x in l {\n        ret.append(x + 1)\n    }\n    return\
    \ ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ accum = 0\n    for x in l {\n        accum += x\n    }\n    var r = [Int](repeating:\
    \ 0, count: l.count)\n    for i in 0..<l.count {\n        r[i] = accum + i\n \
    \   }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmprd4x_yyj/tmprd4x_yyj.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3af748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3af43fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3af43f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3af43e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprd4x_yyj                        0x0000563b228878ad <unavailable> + 6317

    5    libc.so.6                          0x00002ab3af934460 __libc_start_main +
    245

    6    tmprd4x_yyj                        0x0000563b228873d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.map { $0 + 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979886
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ len = l.count\n    var result: [Int] = []\n    var cur = 0\n    for i in 0 ..<\
    \ len {\n        result.append(cur + l[i])\n        cur += l[i]\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmp28e92dr_/tmp28e92dr_.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b862fef0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b862fbe7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b862fbe7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b862fbe67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp28e92dr_                        0x000056391c48c72d <unavailable> + 5933

    5    libc.so.6                          0x00002b86300dc460 __libc_start_main +
    245

    6    tmp28e92dr_                        0x000056391c48c259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ index = 0\n    var acc = 0\n    for el in l {\n        acc += el\n        acc\
    \ = acc & -acc\n        index += 1\n        acc = (acc >> 1) + acc\n        if\
    \ index > 255 {\n            acc = acc | ((acc & 1) << 8)\n            acc = (acc\
    \ >> 1) + acc\n            index = 0\n        }\n        l[index] = acc\n    }\n\
    \    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpi1hzl96w.swift:20:10: error: cannot assign through subscript: 'l'\
    \ is a 'let' constant\n        l[index] = acc\n        ~^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n  var\
    \ s = l[0]\n  for v in l {\n    s = s + v\n  }\n  return s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpnu1hri98.swift:12:10: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n  return s\n         ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    if\
    \ l.count == 0 {\n        return l\n    }\n    var result: [Int] = []\n    var\
    \ last: Int = 0\n    for v in l {\n        result.append(v + last)\n        last\
    \ = v\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'tmpz7xjumdl/tmpz7xjumdl.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8474ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8471d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae8471d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8471d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz7xjumdl                        0x000056487aa256bd <unavailable> + 5821

    5    libc.so.6                          0x00002ae8476c9460 __libc_start_main +
    245

    6    tmpz7xjumdl                        0x000056487aa251e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = l\n    for index, _ in l.enumerated() {\n        res[index + 1] = res[index]\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpp7tvnvhz.swift:9:14: error: expected 'in' after for-each pattern\n\
    \    for index, _ in l.enumerated() {\n             ^\n/tmp/tmpp7tvnvhz.swift:9:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, _ in l.enumerated()\
    \ {\n             ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ acc = 0\n    var res = make([]Int, 0)\n    for x in l {\n        acc += x\n\
    \        res = append(res, acc)\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpjjz9m4hw.swift:9:22: error: expected ',' separator\n    var res\
    \ = make([]Int, 0)\n                     ^\n                     ,\n/tmp/tmpjjz9m4hw.swift:9:15:\
    \ error: cannot find 'make' in scope\n    var res = make([]Int, 0)\n         \
    \     ^~~~\n/tmp/tmpjjz9m4hw.swift:12:15: error: cannot find 'append' in scope\n\
    \        res = append(res, acc)\n              ^~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ a = l\n    for idx : Int in 0 ..< a.count {\n        a[idx]++\n    }\n    return\
    \ a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) ==\
    \ [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpxz8j0v0h.swift:10:15: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        a[idx]++\n              ^~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = l\n    res.reduce(&+) { $0 + 1 }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpmxt745iy.swift:9:25: error: binary operator '+' cannot be applied\
    \ to operands of type '(SIMD2<UInt8>, SIMD2<UInt8>) -> SIMD2<UInt8>' and 'Int'\n\
    \    res.reduce(&+) { $0 + 1 }\n                     ~~ ^ ~\n/tmp/tmpmxt745iy.swift:9:25:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    res.reduce(&+) { $0 + 1 }\n                        ^\n/tmp/tmpmxt745iy.swift:9:20:\
    \ error: contextual closure type '(@escaping (SIMD2<UInt8>, SIMD2<UInt8>) -> SIMD2<UInt8>,\
    \ Int) throws -> (SIMD2<UInt8>, SIMD2<UInt8>) -> SIMD2<UInt8>' expects 2 arguments,\
    \ but 1 was used in closure body\n    res.reduce(&+) { $0 + 1 }\n            \
    \       ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    var i = 1\n    for e in l {\n        result.append(e +\
    \ i)\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmp2ycgb8dr/tmp2ycgb8dr.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2daff56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dafc4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dafc4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dafc4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2ycgb8dr                        0x000055ef05c4f6bd <unavailable> + 5821

    5    libc.so.6                          0x00002b2db0142460 __libc_start_main +
    245

    6    tmp2ycgb8dr                        0x000055ef05c4f1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n\tvar\
    \ l = l\n\tfor let i = 0; i < l.count; i++ {\n\t\tl[i] = l[i] + 1\n\t}\n\treturn\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) ==\
    \ [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpqig9_ao2.swift:9:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for let i = 0; i < l.count; i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    var prev = 0\n    for n in l {\n        result.append(n\
    \ + prev)\n        prev += n\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmp5r8akkci/tmp5r8akkci.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d5dd95c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d5da8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d5da8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d5da8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5r8akkci                        0x00005600c1c2465d <unavailable> + 5725

    5    libc.so.6                          0x00002b3d5df81460 __libc_start_main +
    245

    6    tmp5r8akkci                        0x00005600c1c24189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) ==\
    \ [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpj5a_aeu0/tmpj5a_aeu0.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e0b98dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e0b684b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e0b684988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e0b6837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj5a_aeu0                        0x000055fca41ea49d <unavailable> + 5277

    5    libc.so.6                          0x00002b2e0bb79460 __libc_start_main +
    245

    6    tmpj5a_aeu0                        0x000055fca41e9fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.map { value in\n        value + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for idx in 0..<count(&result) {\n        result[idx] += 1\n\
    \    }\n    result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpoqnfwyp6.swift:9:20: error: cannot find 'count' in scope\n    for\
    \ idx in 0..<count(&result) {\n                   ^~~~~\n/tmp/tmpoqnfwyp6.swift:12:5:\
    \ warning: variable is unused\n    result\n    ^~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ acc = 0\n    var i = -1\n    for v in l {\n        i = i + 1\n        acc =\
    \ v + acc\n        l[i] = acc\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp8wvnu2sr.swift:13:10: error: cannot assign through subscript: 'l'\
    \ is a 'let' constant\n        l[i] = acc\n        ~^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = l.count\n    var r: [Int] = []\n    for v in l {\n        r.append(v+1)\n\
    \    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [0]\n    for el in l { result[0] += el }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpzbxkcftf/tmpzbxkcftf.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9e4b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac9e4841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac9e4841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9e48407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzbxkcftf                        0x00005592eeb93536 <unavailable> + 5430

    5    libc.so.6                          0x00002ac9e4d36460 __libc_start_main +
    245

    6    tmpzbxkcftf                        0x00005592eeb93189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ idx = 0\n    var res = [Int]()\n    for e in l {\n        res[idx] = e + 1\n\
    \        idx++\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp5jw9lfi2.swift:12:12: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        idx++\n           ^~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    for element in l {\n        result.append(element +\
    \ 1)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = [Int]()\n    for x in l {\n        r.append(x + 1)\n    }\n    return r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    var i = 0\n    for element in l {\n        result.append(i+element)\n\
    \        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpo68bi9ib/tmpo68bi9ib.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7594c91c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7594988b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7594988988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75949877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo68bi9ib                        0x0000559eabb9765d <unavailable> + 5725

    5    libc.so.6                          0x00002b7594e7d460 __libc_start_main +
    245

    6    tmpo68bi9ib                        0x0000559eabb97189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ incr = Int()\n    for i in l {\n        incr += 1\n    }\n    var out = [Int]()\n\
    \    for i in l {\n        out.append(i)\n        out.append(incr)\n    }\n  \
    \  return out\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpcaomutml/tmpcaomutml.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c323a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c3209eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c3209e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c3209d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcaomutml                        0x000056335cb506bd <unavailable> + 5821

    5    libc.so.6                          0x00002b5c32593460 __libc_start_main +
    245

    6    tmpcaomutml                        0x000056335cb501e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var ret = [0]\n    for x in l {\n        ret[i % ret.count] = x\n\
    \        i += 1\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpo02mv_tg/tmpo02mv_tg.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b2e832c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b2e529b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b2e529988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b2e5287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo02mv_tg                        0x0000556c8a6ac626 <unavailable> + 5670

    5    libc.so.6                          0x00002b1b2ea1e460 __libc_start_main +
    245

    6    tmpo02mv_tg                        0x0000556c8a6ac279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for el in l {\n        result.append(el + 1)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    \n    var i = 0\n    while i < l.count {\n        result.append(l[i])\n\
    \        i += 1\n    }\n    \n    if i < l.count {\n        result.append(l[i])\n\
    \    }\n    \n    while i < result.count {\n        result.append(0)\n       \
    \ i += 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpy60somvy/tmpy60somvy.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad822334c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad82202bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad82202b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad82202a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy60somvy                        0x000055db663c85fd <unavailable> + 5629

    5    libc.so.6                          0x00002ad822520460 __libc_start_main +
    245

    6    tmpy60somvy                        0x000055db663c8129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = l\n    res.sort { $0 > $1 }\n    res.reverse()\n    return res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpcgi8v7md/tmpcgi8v7md.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7319ee6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7319bddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7319bdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7319bdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcgi8v7md                        0x00005607850ab5fd <unavailable> + 5629

    5    libc.so.6                          0x00002b731a0d2460 __libc_start_main +
    245

    6    tmpcgi8v7md                        0x00005607850ab129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    l.sort()\n\
    \    var c = 0\n    var res = l\n    for x in l {\n        c += 1\n        res\
    \ = append(res, x)\n        if c == l.count {\n            break\n        }\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpvfdzg4vg.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmpvfdzg4vg.swift:13:15:\
    \ error: cannot find 'append' in scope\n        res = append(res, x)\n       \
    \       ^~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = [Int]()\n    for x in l {\n        r.append(x + 1)\n    }\n    return r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ a = [Int]()\n    var count = 0\n    for x in l {\n        count += 1\n     \
    \   a = append(a, x)\n    }\n    a = append(a, count)\n    return a\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpqb3jzm7h.swift:12:13: error: cannot find 'append' in scope\n  \
    \      a = append(a, x)\n            ^~~~~~\n/tmp/tmpqb3jzm7h.swift:14:9: error:\
    \ cannot find 'append' in scope\n    a = append(a, count)\n        ^~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    for el in l {\n        result.append(el + 1)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = l\n    for i := 0; i < len(r); i++ {\n        r[i] += 1;\n    }\n    return\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) ==\
    \ [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp_l4oe5dm.swift:9:12: error: expected type\n    for i := 0; i <\
    \ len(r); i++ {\n           ^\n            <#type#>\n/tmp/tmp_l4oe5dm.swift:9:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(r); i++\
    \ {\n           ^\n/tmp/tmp_l4oe5dm.swift:9:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(r); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ ret = l\n    for i = 1; i < l.count; i++ {\n        ret[i] = ret[i] - ret[i\
    \ - 1] + 1\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp98dtx1sm.swift:9:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 1; i < l.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for i in 0 ..< l.count {\n        result[i] += 1 // Increase\
    \ element by 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ l = l.slice()\n    var n = l.count\n\n    while n > 0 {\n        l[n-1] += 1\n\
    \        n--\n    }\n\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmprf7v139k.swift:8:15: error: value of type '[Int]' has no member\
    \ 'slice'\n    let l = l.slice()\n            ~ ^~~~~\n/tmp/tmprf7v139k.swift:13:10:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n        n--\n\
    \         ^~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var n = l.count\n    var result = Array<Int>()\n    while i < n {\n\
    \        result.append(l[i])\n        i = i + 1\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmp104qryox/tmp104qryox.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb1d770c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb1d467b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb1d467988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb1d4667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp104qryox                        0x00005648a48225fd <unavailable> + 5629

    5    libc.so.6                          0x00002acb1d95c460 __libc_start_main +
    245

    6    tmp104qryox                        0x00005648a4822129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = l[:]\n    var i = 1\n    for _ in res {\n        if i >= res.count {\n\
    \            break\n        }\n        i += 1\n    }\n    return res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpsg0rl51t.swift:8:17: error: expected expression in list of expressions\n\
    \    var res = l[:]\n                ^\n/tmp/tmpsg0rl51t.swift:8:18: error: missing\
    \ argument for parameter #1 in call\n    var res = l[:]\n                 ^\n\
    \                 <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)' declared here\n\
    \    @inlinable public subscript(index: Int) -> Element { get set }\n        \
    \              ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ tmp: [Int] = []\n    var i = 0\n    while i < l.count {\n        tmp.append(l[i])\n\
    \        i += 1\n    }\n    if tmp.isEmpty { return [] }\n    var j = 0\n    for\
    \ _ in tmp {\n        tmp[j] = tmp[j] + 1\n        j += 1\n    }\n    return tmp\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for x in l {\n        result.append(x + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = l\n    for k in stride(from: 0, to: l.count, by: 1) {\n    \
    \    result[k] = result[k] + 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ i = l.count\n    return (0..i).map { l[$0] + 1 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpu5bb_o3p.swift:9:14: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    return (0..i).map { l[$0] + 1 }\n             ^~\n\
    \             ...\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.map { $0 + 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979886
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = [Int]()\n    for x in l {\n        r.append(x + 1)\n    }\n    return r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 0\n    var ret = [Int]()\n    for e in l {\n        ret.append(e + 1)\n\
    \        i += 1\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ (0..<l.count).map { l[$0] + 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r: [Int] = []\n    for i in l {\n        r.append(i + 1)\n    }\n    return\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) ==\
    \ [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n  var\
    \ i = 0\n  for item in l {\n    i += 1\n  }\n  return Array(0..<i).map {\n   \
    \ return item + 1\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpq_fkej0t.swift:13:12: error: cannot find 'item' in scope\n    return\
    \ item + 1\n           ^~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for var i = 0; i < result.count; i++ {\n        result[i] +=\
    \ 1 // ++i would be faster, but requires more memory\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp1kl9777n.swift:9:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < result.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = make([]Int, 0)\n    for i := 0; i < len(l); i++ {\n        res[i] = res[i]\
    \ + Int(l[i])\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpq4gm4i06.swift:8:22: error: expected ',' separator\n    var res\
    \ = make([]Int, 0)\n                     ^\n                     ,\n/tmp/tmpq4gm4i06.swift:9:12:\
    \ error: expected type\n    for i := 0; i < len(l); i++ {\n           ^\n    \
    \        <#type#>\n/tmp/tmpq4gm4i06.swift:9:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < len(l); i++ {\n           ^\n/tmp/tmpq4gm4i06.swift:9:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(l);\
    \ i++ {\n           ^\n/tmp/tmpq4gm4i06.swift:8:15: error: cannot find 'make'\
    \ in scope\n    var res = make([]Int, 0)\n              ^~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    if\
    \ l.isEmpty {\n        return l\n    }\n    var result = [Int](repeating: 0, count:\
    \ l.count)\n    for i in 0..<result.count {\n        result[i] = result[i] + 1\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'tmpipl58iz4/tmpipl58iz4.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f76009c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f75d00b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f75d00988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f75cff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpipl58iz4                        0x0000559efc5c982d <unavailable> + 6189

    5    libc.so.6                          0x00002b4f761f5460 __libc_start_main +
    245

    6    tmpipl58iz4                        0x0000559efc5c9359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = l\n    for idx in 0..<l.count {\n        res[idx] += 1\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for element in l {\n        element = element + 1\n        result\
    \ = element + result\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp2v_yddvz.swift:10:9: error: cannot assign to value: 'element' is\
    \ a 'let' constant\n        element = element + 1\n        ^~~~~~~\n/tmp/tmp2v_yddvz.swift:11:18:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Array<Int>'\n\
    \        result = element + result\n                 ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    var i = 0\n    for _ in result {\n        result[i] += i\n \
    \       i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpuqqsk6mr/tmpuqqsk6mr.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f9110ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f90e05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f90e05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f90e047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuqqsk6mr                        0x0000563fd822265d <unavailable> + 5725

    5    libc.so.6                          0x00002b3f912fa460 __libc_start_main +
    245

    6    tmpuqqsk6mr                        0x0000563fd8222189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ mut l = l\n    let n = l.len()\n    for _ in 0..<n {\n        l[n] = l[n] +\
    \ 1\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp6d5jaxo7.swift:8:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut l = l\n\
    \            ^\n/tmp/tmp6d5jaxo7.swift:8:13: note: join the identifiers together\n\
    \    let mut l = l\n        ~~~~^\n        mutl\n/tmp/tmp6d5jaxo7.swift:8:13:\
    \ note: join the identifiers together with camel-case\n    let mut l = l\n   \
    \     ~~~~^\n        mutL\n/tmp/tmp6d5jaxo7.swift:9:15: error: value of type '[Int]'\
    \ has no member 'len'\n    let n = l.len()\n            ~ ^~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ accum = [Int]()\n    var last = 0\n    for e in l {\n        accum.append(e)\n\
    \        last = e\n    }\n    for e in accum {\n        last = e + 1\n    }\n\
    \    return accum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmpk3qrypim/tmpk3qrypim.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b175b093c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b175ad8ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b175ad8a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b175ad897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk3qrypim                        0x00005565a10ba6bd <unavailable> + 5821

    5    libc.so.6                          0x00002b175b27f460 __libc_start_main +
    245

    6    tmpk3qrypim                        0x00005565a10ba1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ out = l[:]\n    for i in 1..<(l.count - 1) {\n        out[i] = out[i] + 1\n\
    \    }\n    return out\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpi7gjeu_o.swift:8:17: error: expected expression in list of expressions\n\
    \    var out = l[:]\n                ^\n/tmp/tmpi7gjeu_o.swift:8:18: error: missing\
    \ argument for parameter #1 in call\n    var out = l[:]\n                 ^\n\
    \                 <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)' declared here\n\
    \    @inlinable public subscript(index: Int) -> Element { get set }\n        \
    \              ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    l.forEach { result[resultIndex] = $0 + 1 }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpzmn5ovcs.swift:9:24: error: cannot find 'resultIndex' in scope\n\
    \    l.forEach { result[resultIndex] = $0 + 1 }\n                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ incr = 0\n    for k in l {\n        incr = incr + 1\n        l[k] = incr\n \
    \   }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmptpi65xvx.swift:11:10: error: cannot assign through subscript: 'l'\
    \ is a 'let' constant\n        l[k] = incr\n        ~^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ newl = [Int](l)\n    newl[newl.endIndex] = newl[newl.endIndex]! + 1\n    return\
    \ newl\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp9_nazyqt.swift:9:46: error: cannot force unwrap value of non-optional\
    \ type 'Int'\n    newl[newl.endIndex] = newl[newl.endIndex]! + 1\n           \
    \               ~~~~~~~~~~~~~~~~~~~^\n                                       \
    \      \n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for idx = 0, i < l.count - 1, i++ {\n        result[idx]++\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp49x2fx3h.swift:9:13: error: expected 'in' after for-each pattern\n\
    \    for idx = 0, i < l.count - 1, i++ {\n            ^\n/tmp/tmp49x2fx3h.swift:9:13:\
    \ error: expected Sequence expression for for-each loop\n    for idx = 0, i <\
    \ l.count - 1, i++ {\n            ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l.slice()\n    for index in stride(from: 0, through: result.count,\
    \ by: 1) {\n        result[index] += 1\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmppaawzo1y.swift:8:20: error: value of type '[Int]' has no member\
    \ 'slice'\n    var result = l.slice()\n                 ~ ^~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ c = 0\n    for x in l {\n        c += 1\n        l.remove(x)\n        l.insert(c,\
    \ x)\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmprq_fisav.swift:11:11: error: no exact matches in call to instance\
    \ method 'remove'\n        l.remove(x)\n          ^\n/tmp/tmprq_fisav.swift:11:11:\
    \ note: found candidate with type '(Int) -> Int'\n        l.remove(x)\n      \
    \    ^\n/tmp/tmprq_fisav.swift:12:11: error: no exact matches in call to instance\
    \ method 'insert'\n        l.insert(c, x)\n          ^\n/tmp/tmprq_fisav.swift:12:11:\
    \ note: found candidate with type '(__owned Int, Int) -> ()'\n        l.insert(c,\
    \ x)\n          ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for element in l {\n        result.append(element + 1)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979888
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ a = [Int]()\n    for i in l {\n        a.append(i + 1)\n    }\n    return a\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ incr_list(l, by: 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpsg_17yxc.swift:8:29: error: extra argument 'by' in call\n    return\
    \ incr_list(l, by: 1)\n                    ~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n\tvar\
    \ res = make([]Int, 0, len(l))\n\tfor i, v := range l {\n\t\tres = append(res,\
    \ v+1)\n\t}\n\treturn res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpxas9zx1z.swift:8:19: error: expected ',' separator\n        var\
    \ res = make([]Int, 0, len(l))\n                         ^\n                 \
    \        ,\n/tmp/tmpxas9zx1z.swift:9:7: error: expected 'in' after for-each pattern\n\
    \        for i, v := range l {\n             ^\n/tmp/tmpxas9zx1z.swift:9:7: error:\
    \ expected Sequence expression for for-each loop\n        for i, v := range l\
    \ {\n             ^\n/tmp/tmpxas9zx1z.swift:8:12: error: cannot find 'make' in\
    \ scope\n        var res = make([]Int, 0, len(l))\n                  ^~~~\n/tmp/tmpxas9zx1z.swift:8:27:\
    \ error: cannot find 'len' in scope\n        var res = make([]Int, 0, len(l))\n\
    \                                 ^~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ index = 0\n    var r = make([]Int, l.count)\n\n    for i := 0; i < l.count;\
    \ i++ {\n        r[i] = l[index] + 1\n        index = (index + 1) % l.count\n\
    \    }\n\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpi1buyb4_.swift:9:20: error: expected ',' separator\n    var r =\
    \ make([]Int, l.count)\n                   ^\n                   ,\n/tmp/tmpi1buyb4_.swift:11:12:\
    \ error: expected type\n    for i := 0; i < l.count; i++ {\n           ^\n   \
    \         <#type#>\n/tmp/tmpi1buyb4_.swift:11:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < l.count; i++ {\n           ^\n/tmp/tmpi1buyb4_.swift:11:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < l.count;\
    \ i++ {\n           ^\n/tmp/tmpi1buyb4_.swift:9:13: error: cannot find 'make'\
    \ in scope\n    var r = make([]Int, l.count)\n            ^~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    for v in l {\n        result.append(v + 1)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979948
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    switch\
    \ l.count {\n    case 0:\n        return l\n    case 1:\n        return l\n  \
    \  case 2:\n        return l\n    case 3:\n        return l\n    default:\n  \
    \      var result = [Int]()\n        for idx in 0..<(l.count - 1) {\n        \
    \    result.append(idx+1)\n            result.append(l[idx+1])\n        }\n  \
    \      return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'tmp6nyp62lt/tmp6nyp62lt.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af18a685c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af18a37cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af18a37c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af18a37b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6nyp62lt                        0x000055e2699e778d <unavailable> + 6029

    5    libc.so.6                          0x00002af18a871460 __libc_start_main +
    245

    6    tmp6nyp62lt                        0x000055e2699e72b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = l\n    for i in 0 ..< result.count {\n        result[i] += 1;\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ incr = [Int]()\n    for i in l {\n        incr.append(i + 1)\n    }\n    return\
    \ incr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979887
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n\tvar\
    \ i = 0\n\tvar j = l.count\n\tvar incr = 1\n\tvar out = [Int]()\n\tvar add = out.append\n\
    \tfor incr < j {\n\t\ti = i + incr\n\t\tj = j - incr\n\t\tincr = incr * 2\n\t\t\
    if incr > j {\n\t\t\tincr = j\n\t\t}\n\t\tif i < j {\n\t\t\tfor _ in 0...(incr-1)\
    \ {\n\t\t\t\tadd(i)\n\t\t\t\ti = i + 1\n\t\t\t\tif i == j {\n\t\t\t\t\tbreak\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif i > j {\n\t\t\tfor _ in 0...(j-incr-1) {\n\t\
    \t\t\tout.removeLast()\n\t\t\t\ti = i - 1\n\t\t\t\tif i == 0 {\n\t\t\t\t\tbreak\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn out\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpsgha_gnc.swift:13:11: error: expected 'in' after for-each pattern\n\
    \        for incr < j {\n                 ^\n/tmp/tmpsgha_gnc.swift:13:11: error:\
    \ unary operator cannot be separated from its operand\n        for incr < j {\n\
    \                 ^~\n                  \n/tmp/tmpsgha_gnc.swift:12:16: error:\
    \ cannot reference 'mutating' method as function value\n        var add = out.append\n\
    \                      ^\n/tmp/tmpsgha_gnc.swift:13:11: error: '<' is not a prefix\
    \ unary operator\n        for incr < j {\n                 ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    //\
    \ FIXME: check return values\n    let m = l.count\n    var res: [Int] = Array(repeating:\
    \ 0, count: m)\n    for i in 0 ..< m {\n        res[i] = l[i] + 1\n    }\n   \
    \ return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ c = 0\n    var r = [Int]()\n    for i in l {\n        c += 1\n        r.append(i)\n\
    \        if c == l {\n            c = 0\n        }\n    }\n    return r\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp300qylaa.swift:13:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and '[Int]'\n        if c == l {\n           ~ ^ \
    \ ~\n/tmp/tmp300qylaa.swift:13:14: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Int, Int)\n        if c == l {\n             ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ n = l[0]\n    var newArray: [Int] = []\n    for element in l {\n        newArray.append(n\
    \ + element)\n        n = newArray[-1]\n    }\n    return newArray\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3784e24c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3784b1b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3784b1b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3784b1b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3784b1abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b378491ae83 <unavailable> + 188035

    6    tmpfm9q_xvg                        0x00005589867de8e2 <unavailable> + 6370

    7    tmpfm9q_xvg                        0x00005589867de4dd <unavailable> + 5341

    8    libc.so.6                          0x00002b3785010460 __libc_start_main +
    245

    9    tmpfm9q_xvg                        0x00005589867de1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ n = &l[0]\n    var l = l.count\n    var r = [Int](count: l, repeatedValue: 0)\n\
    \    for i : Int = 0; i < l; i += 1 {\n        r[i] = r[i] + 1\n        n = &r[i]\n\
    \    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpfrr8lrsr.swift:11:17: error: expected 'in' after for-each pattern\n\
    \    for i : Int = 0; i < l; i += 1 {\n                ^\n/tmp/tmpfrr8lrsr.swift:11:17:\
    \ error: expected Sequence expression for for-each loop\n    for i : Int = 0;\
    \ i < l; i += 1 {\n                ^\n/tmp/tmpfrr8lrsr.swift:8:13: error: '&'\
    \ may only be used to pass an argument to inout parameter\n    var n = &l[0]\n\
    \            ^\n/tmp/tmpfrr8lrsr.swift:10:13: error: no exact matches in call\
    \ to initializer \n    var r = [Int](count: l, repeatedValue: 0)\n           \
    \ ^\n/tmp/tmpfrr8lrsr.swift:10:13: note: candidate has partially matching parameter\
    \ list (repeating: Int, count: Int)\n    var r = [Int](count: l, repeatedValue:\
    \ 0)\n            ^\n/tmp/tmpfrr8lrsr.swift:10:13: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var r = [Int](count:\
    \ l, repeatedValue: 0)\n            ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = ArraySlice(l)\n\n    for i in 0 ..< result.count {\n        result[i]\
    \ += 1;\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpbkajg6mu.swift:13:12: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return result\n         \
    \  ^~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int]()\n    var count = 1\n    for e in l {\n        result.append(count\
    \ += e)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmppqtkqjok.swift:11:29: error: cannot convert value of type '()'\
    \ to expected argument type 'Int'\n        result.append(count += e)\n       \
    \                     ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = [Int](l)\n    for idx in 0..<result.count {\n        result[idx] +=\
    \ 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979950
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ Array(l).sorted(by: >).map({ $0 + 1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmp4rd45u_0/tmp4rd45u_0.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77fb857c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77fb54eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77fb54e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77fb54d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4rd45u_0                        0x000055b1a54fd7df <unavailable> + 6111

    5    libc.so.6                          0x00002b77fba43460 __libc_start_main +
    245

    6    tmp4rd45u_0                        0x000055b1a54fd159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1659979950
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.map { $0 + 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979886
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ l.map{ $0 + 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979950
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = l\n    for ind in 0..<result.count {\n        result[ind] +=\
    \ 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979950
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    switch\
    \ l.count {\n    case 0:\n        return []\n    case 1:\n        return l\n \
    \   case 2:\n        return l + 1\n    case 3:\n        return l * 2\n    case\
    \ 4:\n        return l * 3\n    case 5:\n        return l * 4\n    default:\n\
    \        let mult = l.first / 2\n        var x = 0\n        var y = 0\n      \
    \  var z = 0\n        for _ in 0 ..< l.count {\n            x = x + mult\n   \
    \         y = y + mult\n            z = z + mult\n        }\n        return l\
    \ * (x+y) + z\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpeioxar_2.swift:14:20: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Array<Int>'\n        return l + 1\n             \
    \      ^\n/tmp/tmpeioxar_2.swift:16:18: error: binary operator '*' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n        return l * 2\n              \
    \ ~ ^ ~\n/tmp/tmpeioxar_2.swift:16:18: note: overloads for '*' exist with these\
    \ partially matching parameter lists: (Int, Int)\n        return l * 2\n     \
    \            ^\n/tmp/tmpeioxar_2.swift:16:18: error: no '*' candidates produce\
    \ the expected contextual result type '[Int]'\n        return l * 2\n        \
    \         ^\nSwift.Int:9:24: note: '*' produces 'Int', not the expected contextual\
    \ result type '[Int]'\n    public static func * (lhs: Int, rhs: Int) -> Int\n\
    \                       ^\nSwift.Numeric:5:17: note: '*' produces 'Int', not the\
    \ expected contextual result type '[Int]'\n    static func * (lhs: Self, rhs:\
    \ Self) -> Self\n                ^\nSwift.BinaryInteger:22:26: note: '*' produces\
    \ 'Int', not the expected contextual result type '[Int]'\n    override static\
    \ func * (lhs: Self, rhs: Self) -> Self\n                         ^\nSwift.Duration:16:24:\
    \ note: '*' produces 'Duration', not the expected contextual result type '[Int]'\n\
    \    public static func * <T>(lhs: Duration, rhs: T) -> Duration where T : BinaryInteger\n\
    \                       ^\n/tmp/tmpeioxar_2.swift:18:18: error: binary operator\
    \ '*' cannot be applied to operands of type '[Int]' and 'Int'\n        return\
    \ l * 3\n               ~ ^ ~\n/tmp/tmpeioxar_2.swift:18:18: note: overloads for\
    \ '*' exist with these partially matching parameter lists: (Int, Int)\n      \
    \  return l * 3\n                 ^\n/tmp/tmpeioxar_2.swift:18:18: error: no '*'\
    \ candidates produce the expected contextual result type '[Int]'\n        return\
    \ l * 3\n                 ^\nSwift.Int:9:24: note: '*' produces 'Int', not the\
    \ expected contextual result type '[Int]'\n    public static func * (lhs: Int,\
    \ rhs: Int) -> Int\n                       ^\nSwift.Numeric:5:17: note: '*' produces\
    \ 'Int', not the expected contextual resu"
  stdout: ''
  timestamp: 1659979950
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    l.sort()\n\
    \    var r = l\n    for _ in 0 ..< l.count {\n        if r[r.count - 1] != l[r.count\
    \ - 1] + 1 {\n            r = append(r, l[r.count - 1] + 1)\n        } else {\n\
    \            r.removeLast()\n        }\n    }\n    return r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp8m69tevg.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmp8m69tevg.swift:12:17:\
    \ error: cannot find 'append' in scope\n            r = append(r, l[r.count -\
    \ 1] + 1)\n                ^~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result = l\n    for i in l {\n        i += 1\n        result = append(result,\
    \ i)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpxd6dk617.swift:10:11: error: left side of mutating operator isn't\
    \ mutable: 'i' is a 'let' constant\n        i += 1\n        ~ ^\n/tmp/tmpxd6dk617.swift:11:18:\
    \ error: cannot find 'append' in scope\n        result = append(result, i)\n \
    \                ^~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res: [Int] = []\n    for k in l {\n        res.append(k + 1)\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979950
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ count = l.count\n    let last = l.last!\n    let res = [Int](count: count +\
    \ 1, repeatedValue: last! + 1)\n    for i in 0..<count {\n        res[i] += 1\
    \ // += 1 is not safe\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmpy302yztz.swift:10:15: error: no exact matches in call to initializer\
    \ \n    let res = [Int](count: count + 1, repeatedValue: last! + 1)\n        \
    \      ^\n/tmp/tmpy302yztz.swift:10:15: note: found candidate with type '(Int,\
    \ Int) -> [Int]'\n    let res = [Int](count: count + 1, repeatedValue: last! +\
    \ 1)\n              ^\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r = l\n    for _ in 0..<(l.count) {\n        let old = r\n        let next =\
    \ r + 1 // unavoidable +1 here\n        r = next\n        let x = old\n      \
    \  old = x\n        x = x + 1\n        old = old\n    }\n    return r\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp2984e4qj.swift:11:22: error: binary operator '+' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n        let next = r + 1 // unavoidable\
    \ +1 here\n                   ~ ^ ~\n/tmp/tmp2984e4qj.swift:11:22: note: overloads\
    \ for '+' exist with these partially matching parameter lists: (Int, Int)\n  \
    \      let next = r + 1 // unavoidable +1 here\n                     ^\n/tmp/tmp2984e4qj.swift:14:9:\
    \ error: cannot assign to value: 'old' is a 'let' constant\n        old = x\n\
    \        ^~~\n/tmp/tmp2984e4qj.swift:10:9: note: change 'let' to 'var' to make\
    \ it mutable\n        let old = r\n        ^~~\n        var\n/tmp/tmp2984e4qj.swift:15:17:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Array<Int>'\n\
    \        x = x + 1\n                ^\n/tmp/tmp2984e4qj.swift:15:9: error: cannot\
    \ assign to value: 'x' is a 'let' constant\n        x = x + 1\n        ^\n/tmp/tmp2984e4qj.swift:13:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let x = old\n      \
    \  ^~~\n        var\n/tmp/tmp2984e4qj.swift:16:9: error: cannot assign to value:\
    \ 'old' is a 'let' constant\n        old = old\n        ^~~\n/tmp/tmp2984e4qj.swift:10:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let old = r\n      \
    \  ^~~\n        var\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    if\
    \ l == nil { return [] }\n    var l = l\n    var r = [Int]()\n    var m = 0\n\
    \    for _i in l {\n        r[m] = _i\n        m++\n    }\n    return r\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l:\
    \ [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123])\
    \ == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmp9oabbhgf.swift:8:10: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns false\n    if l == nil { return [] }\n     \
    \  ~ ^  ~~~\n/tmp/tmp9oabbhgf.swift:14:10: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n        m++\n         ^~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ n = 0\n    for i : Int in l {\n        n += 1\n        l.removeAtIndex(n - 1)\n\
    \    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpykoe8dlu.swift:11:11: error: value of type '[Int]' has no member\
    \ 'removeAtIndex'\n        l.removeAtIndex(n - 1)\n        ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    let\
    \ result = l.map { $0 + 1 }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3,\
    \ 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) ==\
    \ [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979950
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    return\
    \ incr_list_helper(l, 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmp1josbbmf.swift:8:12: error: cannot find 'incr_list_helper' in scope\n\
    \    return incr_list_helper(l, 1)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979950
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i: Int = 0\n    var r: [Int] = []\n    for elem in l {\n        r.append(i+1)\n\
    \        i += elem\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1])\
    \ == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3,\
    \ 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmp9u6scz6_/tmp9u6scz6_.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aadebcb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aadeb9b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aadeb9b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aadeb9af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9u6scz6_                        0x000055d40e4dd65d <unavailable> + 5725

    5    libc.so.6                          0x00002aadebea5460 __libc_start_main +
    245

    6    tmp9u6scz6_                        0x000055d40e4dd189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979950
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ res = l.slice()\n    for i = res.count; i-- > 0; {\n        res[i] += 1\n  \
    \  }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: SyntaxError
  stderr: "/tmp/tmpeeq5r1gg.swift:9:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = res.count; i-- > 0; {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpeeq5r1gg.swift:8:17: error: value of type '[Int]' has no member 'slice'\n\
    \    var res = l.slice()\n              ~ ^~~~~\n"
  stdout: ''
  timestamp: 1659979950
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ r: [Int] = l\n    for _ in 0..<l.count {\n        r.removeLast()\n    }\n  \
    \  return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int])\
    \ == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: Exception
  stderr: 'tmp6ej3dvgx/tmp6ej3dvgx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ef0de6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ef0addb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ef0add988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ef0adc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6ej3dvgx                        0x000056524a33c76d <unavailable> + 5997

    5    libc.so.6                          0x00002b0ef0fd2460 __libc_start_main +
    245

    6    tmp6ej3dvgx                        0x000056524a33c299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659979950
- exit_code: 1
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ a = l\n    for _, b in incr_biggers_than(a) {\n        a = append(b, a)\n  \
    \  }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as\
    \ [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l:\
    \ [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
  status: SyntaxError
  stderr: "/tmp/tmptzrqngvb.swift:9:10: error: expected 'in' after for-each pattern\n\
    \    for _, b in incr_biggers_than(a) {\n         ^\n/tmp/tmptzrqngvb.swift:9:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, b in incr_biggers_than(a)\
    \ {\n         ^\n"
  stdout: ''
  timestamp: 1659979950
- exit_code: -4
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ i = 1\n    var r = [Int]()\n    for x in l {\n        r.append(i)\n        i\
    \ += 1\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: Exception
  stderr: 'tmp5qr5qp9g/tmp5qr5qp9g.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f74778c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f7446fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f7446f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f7446e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5qr5qp9g                        0x0000556ca0c6e6bd <unavailable> + 5821

    5    libc.so.6                          0x00002b5f74964460 __libc_start_main +
    245

    6    tmp5qr5qp9g                        0x0000556ca0c6e1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979950
- exit_code: 0
  program: "\n/// Return array with elements incremented by 1.\n/// >>> incr_list(l:\
    \ [1, 2, 3])\n/// [2, 3, 4]\n/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    /// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n    var\
    \ result: [Int] = []\n    for elt in l {\n        result.append(elt + 1)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l:\
    \ [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\n\
    assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1,\
    \ 124])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979950
