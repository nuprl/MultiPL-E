name: HumanEval_43_pairs_sum_to_zero
language: swift
prompt: "\n/// pairs_sum_to_zero takes an array of integers as an input.\n/// it returns\
  \ true if there are two distinct elements in the array that\n/// sum to zero, and\
  \ false otherwise.\n/// >>> pairs_sum_to_zero(l: [1, 3, 5, 0])\n/// false\n/// >>>\
  \ pairs_sum_to_zero(l: [1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(l: [1,\
  \ 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])\n/// true\n\
  /// >>> pairs_sum_to_zero(l: [1])\n/// false\nfunc pairs_sum_to_zero(l: [Int]) ->\
  \ Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)\n\
  assert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)\nassert(pairs_sum_to_zero(l:\
  \ [1, 2, 3, 7]) == false)\nassert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)\n\
  assert(pairs_sum_to_zero(l: [1]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9,\
  \ -1, 3, 2, 30]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) ==\
  \ true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)\nassert(pairs_sum_to_zero(l:\
  \ [-3, 9, -1, 4, 2, 31]) == false)"
completions: ["    if l == nil {\n        return true\n    }\n    \n    var zero =\
    \ Int()\n    \n    for x in l {\n        zero = zero + x\n    }\n    \n    for\
    \ x in l {\n        if zero == x {\n            return false\n        }\n    }\n\
    \    \n    return true", '    return is_unique_sum_pairs(l, 0) {}', '    return
    pairs_sum_to_zero(l, l, nil)', "    if l == nil {\n        return false\n    }\n\
    \    var sum = 0\n    var isDistinct = true\n    for _, e := range l {\n     \
    \   sum += e\n        if sum == 0 {\n            isDistinct = false\n        }\n\
    \    }\n    return isDistinct", "    let zero = Int(0)\n    for i in l {\n   \
    \     for j in l {\n            if i == zero || j == zero {\n                break\n\
    \            }\n            if i + j == zero {\n                return false\n\
    \            }\n        }\n    }\n    return true", "\tswitch l.count {\n\tcase\
    \ 0:\n\t\treturn true\n\tcase 1:\n\t\treturn l[0] == 0\n\tdefault:\n\t\tn := l[0]\n\
    \t\tprev := l[n-1]\n\t\tfor i := 1; i < len(l); i++ {\n\t\t\tn += l[i]\n\t\t\t\
    if prev == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tprev = n\n\t\t}\n\t\treturn\
    \ true\n\t}", "    var sum: Int = 0\n    var last: Int = 0\n    for num in l {\n\
    \        if num == last {\n            sum += num\n        } else {\n        \
    \    sum = 0\n            last = num\n        }\n    }\n    return sum == 0",
  "    var a : [Int] = []\n    for x in l {\n        if a == nil {\n            a.append(x)\n\
    \            continue\n        }\n        for y in a {\n            if x != y\
    \ && x == x + y {\n                return false\n            }\n        }\n  \
    \      a.append(x)\n    }\n    return true", "    for i in 0 ..< l.count {\n \
    \       let pair = (l[i], l[(i + 1) % l.count])\n        if pair == 0 {\n    \
    \        return true\n        }\n    }\n    return false", "    let (firstIndex,\
    \ secondIndex) = min_two(l)\n    if firstIndex != secondIndex {\n        return\
    \ false\n    }\n    return l.startIndex == firstIndex + 1", "    // TODO: Optimize\
    \ the below to run in linear time\n    // O(m n) time | O(1) space (using a map)\n\
    \    var map = Map()\n    for i in l {\n        if !map.contains {\n         \
    \   map.insert (i, 0)\n        } else {\n            map.insert (i, map.at(i)\
    \ + 1)\n        }\n    }\n\n    // O(n) time and O(1) space\n    for k in map.keys\
    \ {\n        // O(n) time\n        for j in map.keys {\n            if k > j &&\
    \ map.get(k) == map.get(j) {\n                return false\n            }\n  \
    \      }\n    }\n    return true", "    return l.contains(l.minIndex(of: 0)) ==\
    \ true &&\n        l.contains(l.maxIndex(of: 0)) == true", '    return pairs_sum_to_zero_2(l:
    l) != nil', "    var i: Int = 0\n    var n: Int = 0\n    var c: Bool = false\n\
    \    for k in l {\n        if k == 0 {\n            n += 1\n        } else {\n\
    \            i += 1\n            if i == n {\n                c = true\n     \
    \       }\n        }\n    }\n    return c", "  var pairs = [Int: [Int]]()\n  for\
    \ i, a in enumerate(l) {\n    pairs[a] = [Int]()\n    for b in l[i+1:] {\n   \
    \   pairs[a].append(b)\n    }\n  }\n  let zeros = pairs.filter{\n    $0.filter{\n\
    \      $0.isNotEmpty\n    }.isEmpty\n  }\n  return zeros.isEmpty", "    var hasPairsZero\
    \ : Bool = false\n    for x in l {\n        hasPairsZero = hasPairsZero || x >\
    \ 0\n        hasPairsZero = hasPairsZero || (x != 0 && !hasPairsZero)\n    }\n\
    \    return hasPairsZero", "    if l == nil || len(l) == 0 || l.count == 0 {\n\
    \        return false\n    }\n    var sum = 0\n    for _, b := range l {\n   \
    \     sum += b\n    }\n    if sum < 0 {\n        return true\n    }\n    for i\
    \ := len(l) - 1; i > 0; i-- {\n        if l[i] + sum > 0 {\n            return\
    \ false\n        }\n    }\n    return true", "    if l == nil { return false }\n\
    \    count := 0\n    for i in 0..<l.count {\n        count += Int(l[i])\n    }\n\
    \    if count < 2 { return false }\n    var first: Int = Int(l[0])\n    var second:\
    \ Int = Int(l[count-1])\n    var third: Int = Int(0)\n    for i in 0..<count {\n\
    \        if Int(l[i]) != first {\n            if Int(l[i]) == second {\n     \
    \           third = Int(l[i])\n            }\n            if third == 0 {\n  \
    \              return false\n            }\n        }\n        first = second\n\
    \        second = Int(l[i])\n    }\n    if third == 0 {\n        return false\n\
    \    }\n    return true", "    switch len(l) {\n    case 0:\n        return true\n\
    \    case 1:\n        return l[0] == 0\n    case 2:\n        return l[0] == 0\
    \ && l[1] == 0\n    default:\n        if l[0] < 0 || l[0] < l[1] {\n         \
    \   return false\n        }\n        return pairs_sum_to_zero(l[1..])\n    }",
  "    var l1 = [0] * (l.count + 1)\n    l1[0] = 1\n    for i in 1...l.count {\n \
    \       l1[i] = l1[i-1] + l[i-1]\n    }\n    for i in 0..(l.count-1) {\n     \
    \   if l1[i] != 0 {\n            return false\n        }\n    }\n    return true",
  "    var sum = 0\n    var i = 0\n    for k in l {\n        sum += k\n        i +=\
    \ 1\n    }\n    return i == 1 || (sum == 0 && i != 0)", "    let s = l.map { $0\
    \ + $1 }\n        .map { $0 * $0 }\n        .sum() // square the sum to get |x|\
    \ for all x\n    return s == 0", "    if l.count == 0 { return false }\n    var\
    \ sums = make([][Int], l.count)\n    var count = 0\n    for i := 0; i < l.count;\
    \ i++ {\n        sums[i] = make([]Int, l.count)\n        for j := 0; j < i; j++\
    \ {\n            sums[i][j] = l[j] + l[i]\n        }\n        count += sums[i].count\n\
    \    }\n    for i := 0; i < count; i++ {\n        if !equal(sums[i], []Int{})\
    \ {\n            return false\n        }\n    }\n    return true", "\tl += [0]\n\
    \tguard l.isEmpty else { return true }\n\tguard l.count == 2 else { return false\
    \ }\n\treturn l[0] > 0 && l[1] == 0", "    switch l.count {\n    case 0:\n   \
    \     return false\n    case 1:\n        return l.first == 0\n    case 2:\n  \
    \      return l.first == l.last\n    default:\n        return l.first == pairs_sum_to_zero(l.prefix(1))\n\
    \    }", "    // If pairs, return true.\n    if l == nil || len(l) <= 1 {\n  \
    \      return true\n    }\n\n    // Keep track of current and previous item (a\
    \ pair).\n    var current = l[0]\n    var previous = l[0]\n    for i := 1; i <\
    \ len(l); i++ {\n        if l[i] > current {\n            return false\n     \
    \   }\n        current = l[i]\n        previous = l[i]\n    }\n\n    // If the\
    \ current item and the previous item have the same value,\n    // return true.\n\
    \    return previous == current", "  // Write your code here.\n  return true",
  "    for i in 0 ..< l {\n        for j in i + 1 ..< l {\n            if l[i] ==\
    \ l[j] {\n                return false\n            }\n        }\n    }\n    return\
    \ true", "    let sortedArray = l.sorted()\n    if sortedArray.first == sortedArray.last\
    \ {\n        return true\n    }\n    guard let lastIndex = sortedArray.last else\
    \ { return false }\n    if sortedArray.first + sortedArray.last > 0 && sortedArray.last\
    \ == lastIndex { return true }\n    var leftIndex = 0\n    var rightIndex = sortedArray.count\
    \ - 1\n    while leftIndex < rightIndex {\n        let sum = sortedArray[leftIndex]\
    \ + sortedArray[rightIndex]\n        if sum == 0 {\n            return true\n\
    \        }\n        if sum > 0 {\n            rightIndex -= 1\n        } else\
    \ {\n            leftIndex += 1\n        }\n    }\n    return false", "  if len(l)\
    \ < 2 {\n    return false\n  }\n  var i : Int = 0\n  var j = i+1\n  for i < len(l)\
    \ - 1 && j < len(l) {\n    if l[i] + l[j] != 0 {\n      return false\n    }\n\
    \    i += 1;\n    j += 1;\n  }\n  return true", '    return contains_pairs(l,
    &_sum_less_than)(0)', "    var hashmap = [Int]()\n    for k in l {\n        hashmap[k]\
    \ = k\n    }\n    for k in l {\n        let k = k\n        if k >= 0 && k != k\
    \ {\n            let newhashmap = [Int]()\n            for h in hashmap {\n  \
    \              newhashmap[h] = h\n            }\n            hashmap = newhashmap\n\
    \        }\n    }\n    for (k, v) in hashmap {\n        if v != 0 {\n        \
    \    return false\n        }\n    }\n    return true", "    var result = true\n\
    \    var count = 1\n    for i : Int in l {\n        if i > 0 {\n            result\
    \ = result && count\n            count++\n        }\n    }\n    return result",
  "\treturn pairsSumToZero(l)", "    let sorted = l.sorted()\n    let l = sorted.count\n\
    \    var index = 0\n    var sum = 0\n    while index < l {\n        sum += sorted[index]\n\
    \        if sum != 0 {\n            index += 1\n        } else {\n           \
    \ index += 2\n            if index == l {\n                return false\n    \
    \        }\n        }\n    }\n    return true", "    var a = 0\n    var b = 0\n\
    \    for x in l {\n        a += x\n        b += x\n        if a > 0 {\n      \
    \      return false\n        } else if b > 0 {\n            return true\n    \
    \    }\n    }\n    return false", '    return pairs(l).sum() == 0', "    var zeros\
    \ = [Int]()\n    for x in l {\n        if x != 0 && zeros.contains(&x) {\n   \
    \         return true\n        }\n        zeros.append(x)\n    }\n    return false",
  "    l.sort()\n    for i in 0..<l.count-1 {\n        if l[i] == l[i+1] && l[i] !=\
    \ 0 {\n            return false\n        }\n    }\n    return true", "  var res\
    \ = false\n  l.forEach { if $0 == 0 { res = true } }\n  return res", "    \n \
    \   // your code here\n    var i = 0\n    for pair in l {\n        let sum = pair\
    \ + i\n        i = sum\n        if sum == 0 {\n            return true\n     \
    \   }\n    }\n    return false", "    if len(l) <= 1 {\n        return false\n\
    \    }\n    var i = Int()\n    var j = Int()\n    var count = 0\n    for _ in\
    \ 0..<len(l) {\n        i = l[i]\n        j = l[j]\n        if i < j {\n     \
    \       count += 1\n        }\n        if count == 2 {\n            return true\n\
    \        }\n    }\n    return false", "    var firstNonZeroIndex = 0\n    var\
    \ secondNonZeroIndex = 0\n    for i in l.reverse() {\n        if i != 0 {\n  \
    \          if firstNonZeroIndex == 0 {\n                firstNonZeroIndex = i\n\
    \            } else {\n                secondNonZeroIndex = i\n            }\n\
    \        }\n    }\n    return secondNonZeroIndex != 0 && firstNonZeroIndex !=\
    \ 0", "    var sum = 0\n    var i = 0\n    var j = 0\n    var last: Int = 0\n\
    \    for i = 0; i <= len(l); i++ {\n        sum = sum + l[i]\n        if sum ==\
    \ 0 {\n            return true\n        }\n    }\n\n    for j = 1; j <= len(l);\
    \ j++ {\n        sum = sum - l[j]\n        if sum == 0 {\n            return true\n\
    \        }\n    }\n    return false", "    var zero = false\n    var zeroIndex\
    \ = -1\n    var oneIndex = -1\n    for i in l.indices{\n        if i == zeroIndex{\n\
    \            zero = true\n        }else if i == oneIndex{\n            zero =\
    \ false\n        }\n        if zero {\n            oneIndex = i\n        }\n \
    \   }\n    return zero", "    // write your code here\n    l.sort()\n    var last:\
    \ Int = 0\n    for x in l {\n        if x - last > 0 {\n            for y in l\
    \ {\n                if x - y == 0 {\n                    return true\n      \
    \          }\n            }\n        }\n        last = x\n    }\n    return false",
  "  let nums = l.sorted()\n  var i = 1\n  while i < nums.count && nums[i] == nums[i-1]\
    \ {\n    i += 1\n  }\n  return i == nums.count", "    var sum: Int = 0\n    for\
    \ element in l {\n        sum += element\n    }\n    return sum == 0", "\tlet\
    \ firsts = Set(l)\n\tif firsts.isEmpty {\n\t\treturn true\n\t}\n\n\tlet lasts\
    \ = Set(l.dropLast())\n\tif lasts.isEmpty {\n\t\treturn false\n\t}\n\n\tlet firstToLast\
    \ = firsts.subtracting(lasts)\n\treturn firstToLast.isEmpty", "    if len(l) ==\
    \ 1 {\n        return false\n    }\n    var s = l.map { $0 }\n    var zeros =\
    \ [0]\n    for n in s {\n        for z in zeros {\n            if n == z {\n \
    \               return true\n            }\n        }\n        zeros += n\n  \
    \  }\n    return false", "    var i = 0\n    var j = 0\n    var ans = false\n\n\
    \    while i < len(l) {\n        if i == j {\n            if l[i] == 0 {\n   \
    \             ans = true\n            }\n            continue\n        }\n   \
    \     if l[i] < 0 {\n            j++\n            continue\n        }\n      \
    \  if l[j] >= 0 {\n            continue\n        }\n        ans = true\n     \
    \   break\n    }\n    return ans", "  var pairs = l\n  var sum = 0\n\n  for pair\
    \ := range pairs {\n    if pairs.count < 2 {\n      return false\n    }\n    sum\
    \ += pair\n  }\n  return sum == 0", "    guard l.count >= 2, let sum = l.reduce(0)\
    \ {$0 + $1} else { return false }\n    \n    if sum == 0 {\n        return true\n\
    \    }\n\n    var min2 = min(l[0], l[1])\n    for number in l[2..] {\n       \
    \ if number > min2 {\n            return false\n        }\n        min2 = min(number,\
    \ min2)\n    }\n\n    return true", "    var result: Bool = false\n    for i in\
    \ 0 ..< l.count {\n        var sum: Int = 0\n        for j in 0 ..< l.count {\n\
    \            sum += l[j]\n            if sum > 0 {\n                break\n  \
    \          }\n        }\n        if sum == 0 {\n            result = true\n  \
    \      }\n    }\n    return result", "  let d = Set<Int>()\n  for e in l {\n \
    \   d.add(-e)\n  }\n  return !d.contains(0)", "    for index in 0..<l.count {\n\
    \        if l[index] != 0 && l[index + (index+1)] != 0 {\n            return false\n\
    \        }\n    }\n    return true", "  var results = [Int]()\n  \n  for index\
    \ in 0..<l.count {\n    if l[index] != 0 {\n      results.append(l[index])\n \
    \   }\n  }\n  \n  return results.count < l.count", "    if l.count == 0 {\n  \
    \      return false\n    }\n    var prev = 0\n    var curr = l[0]\n    for x in\
    \ l {\n        if curr - prev == 0 {\n            return true\n        }\n   \
    \     if curr - prev > 0 {\n            return false\n        }\n        prev\
    \ = curr\n        curr = x\n    }\n    return false", "    var left = 0\n    var\
    \ right = 0\n    var result = 0\n    for i in l {\n        result = i + left\n\
    \        left = right\n        right = result\n        if left == 0 {\n      \
    \      return false\n        }\n    }\n    return true", '    return pairs_sum_to_zero_inner(l)',
  "\tvar a : [Int]\n\ta = l.filter { (v) in\n\t\treturn v != 0\n\t}\n\treturn a.count\
    \ != 0", "    let len = l.count\n    if len < 2 {\n        return false\n    }\n\
    \    let map = [Int:Int]()\n    for i in 0..<len {\n        if let i = l[i], map[i]\
    \ == 0 {\n            map[i] = 1\n        } else {\n            return true\n\
    \        }\n    }\n    return false", "    var result : Bool = true\n    var prev_pair\
    \ : [Int] = []\n    for v in l {\n        if prev_pair.contains(v) {\n       \
    \     result = false\n            break\n        } else {\n            prev_pair.append(v)\n\
    \        }\n    }\n    return result", "    var l2 = l\n    l2.sort{$0.0 < $1.0}\n\
    \    if l2.count != l.count {\n        return false\n    }\n    for pos in 0 ..<\
    \ l2.count {\n        if l[pos] + l2[pos] != 0 {\n            return false\n \
    \       }\n    }\n    return true", "\tlet n = l.count\n\tif n < 2 {\n\t\treturn\
    \ false\n\t}\n\tlet maxIndex = n - 1\n\tlet maxValue = l[maxIndex]\n\tif maxValue\
    \ < 0 {\n\t\treturn false\n\t}\n\tlet zeroIndex = maxIndex + 1\n\tlet zeroValue\
    \ = l[zeroIndex]\n\tif zeroValue > maxValue {\n\t\treturn false\n\t}\n\tlet pairs\
    \ = &l[zeroIndex..maxIndex]\n\tlet isZero = pairs.reduce(_ + _) == 0\n\treturn\
    \ isZero", "    var sum = 0\n    for x in l {\n        sum += x\n    }\n    return\
    \ (sum <= 0)", "    var sum: Int = 0\n    for a in l {\n        sum += a\n   \
    \ }\n    return sum == 0", "  let (left, right, sum) = l.partition(by: { $0 <\
    \ 0 })\n  return !left && !right", "\tl == nil || len(l) == 0 || len(l) > 100\
    \ {\n\t\treturn false\n\t}\n\n\tvar n int\n\tfor _, v := range l {\n\t\tif n >\
    \ 0 {\n\t\t\tn -= v\n\t\t}\n\t}\n\treturn n == 0", "    var i, j int\n    var\
    \ sum Int = 0\n    for i = 0; i < len(l); i++ {\n        sum += l[i]\n       \
    \ for (j = i + 1; j < len(l); j++) {\n            sum += l[j]\n            if\
    \ sum == 0 {\n                return true\n            }\n        }\n    }\n \
    \   return false", "  let len = l.count\n  for var i = 0; i < len; i++ {\n   \
    \ var n = 0\n    var found = false\n    for var j = 0; j < i; j++ {\n      if\
    \ l[j] >= l[j+1] {\n        n += 1\n        if n == 0 {\n          found = true\n\
    \        }\n      }\n    }\n    if !found {\n      return false\n    }\n  }\n\
    \  return true", "    var sum = 0\n    for x in l {\n        sum += x\n    }\n\
    \    for x in l {\n        if sum < 0 {\n            return false\n        }\n\
    \    }\n    return true", "    var a = [Int]()\n    var b = [Int]()\n    for x\
    \ in l {\n        if !a.contains(x) {\n            a.append(x)\n        } else\
    \ {\n            b.append(x)\n        }\n    }\n    if a.count < b.count {\n \
    \       return false\n    }\n    for index in 0 ..< a.count {\n        if b[index]\
    \ != 0 {\n            return false\n        }\n    }\n    return true", "    //\
    \ code lengthy but straightforward because we only need to check for a \n    //\
    \ two element difference\n    var isSum :Bool\n    if l == nil || l.count < 2\
    \ || l.count > 100 {\n        isSum = false\n    } else {\n        if l[0] + l[1]\
    \ == 0 {\n            isSum = true\n        } else {\n            isSum = false\n\
    \        }\n    }\n    return isSum", "    var i : Int = 0\n    var j : Int =\
    \ 0\n    var sum : Int = 0\n    for j in l {\n        i = i + 1\n        sum =\
    \ sum + j\n        if sum < 0 {\n            sum = 0 - sum\n        }\n      \
    \  if sum == 0 && i != j {\n            return false\n        }\n    }\n    return\
    \ true", "    var i = 0\n    for _ in l {\n        i += 1\n    }\n    if i !=\
    \ l.count {\n        return false\n    }\n    var pairs = 0\n    var prev = 0\n\
    \    for e in l {\n        pairs += e - prev\n        prev = e\n    }\n    return\
    \ pairs == 0", "    let n = l.count\n    for kk in 0 ..< n {\n        let a =\
    \ l[kk]\n        for j in 0 ..< kk { l[j] -= a }\n        if l[kk] == 0 {\n  \
    \          return false\n        }\n    }\n    return true", "  var result: [Bool]\
    \ = []\n  var last = 0\n  var first = 0\n  var second = 0\n  for idx in 0..<l.count\
    \ {\n    last = l[idx]\n    first = 0\n    second = 0\n    if idx != 0 {\n   \
    \   first = l[idx - 1]\n    }\n    if idx != l.count - 1 {\n      second = l[idx\
    \ + 1]\n    }\n    result += [(first + last) == -(second + last)]\n  }\n  return\
    \ result.isEmpty == false", "  var map = [Int:Int]()\n  for i in l {\n    map[i\
    \ % 2 == 0 ? i : -i] = i\n  }\n  for k in map {\n    if map.contains(k + k) {\n\
    \      return false\n    }\n  }\n  return true", "    for i in 0 ..< l.count {\n\
    \        for j in 0 ..< l.count {\n            if l[i] + l[j] == 0 {\n       \
    \         return true\n            }\n        }\n    }\n    return false", " \
    \   var result: Bool = false\n    var current: Int = 0\n    for x in l {\n   \
    \     current += x\n        if current == 0 {\n            result = true\n   \
    \         break\n        }\n    }\n    return result", "    switch len(l) {\n\
    \    case 1:\n        return l[0] != 0\n    case 2:\n        return l[0] == l[1]\
    \ && l[0] != 0\n    case 3:\n        return l[0] == l[1] && l[1] == l[2] && l[0]\
    \ != 0\n    case 4:\n        return l[0] == l[1] && l[1] == l[2] && l[2] == l[3]\
    \ && l[0] != 0\n    case 5:\n        return l[0] == l[1] && l[1] == l[2] && l[2]\
    \ == l[3] && l[3] == l[4] && l[0] != 0\n    default:\n        return false\n \
    \   }", "  var first = 0\n  var second = 0\n  for element in l {\n    first +=\
    \ element\n    second += element\n  }\n  return second == 0 && first < 0", " \
    \   let set = Set<Int>()\n    for i in l {\n        if set.contains(i) {\n   \
    \         return true\n        } else {\n            set.add(i)\n        }\n \
    \   }\n    return false", "    if l == nil || len(l) == 0 {\n        return false\n\
    \    }\n    let len = l.count\n    for var i = 1; i < len; i++ {\n        let\
    \ sum = l[i] + l[i - 1]\n        if sum > 0 {\n            return false\n    \
    \    }\n    }\n    return true", "    var last = 0\n    for i := 0; i < len(l);\
    \ i++ {\n        last += l[i]\n        if last == 0 {\n            return true\n\
    \        }\n    }\n    return false", "    if l == nil || len(l) == 0 {\n    \
    \    return false\n    }\n    \n    var i = 0\n    var sum = 0\n    var hasPairsSoFar\
    \ = false\n    while i < len(l) {\n        if l[i] != 0 {\n            sum +=\
    \ l[i]\n        } else {\n            if sum == 0 {\n                hasPairsSoFar\
    \ = true\n            } else {\n                hasPairsSoFar = false\n      \
    \      }\n            sum = 0\n        }\n        i += 1\n    }\n    return hasPairsSoFar",
  '    return len(l) != 0..<len(l)-1 && !zipWith(l, l).reduce({ ($0 < $1) || (!($0
    == $1)) })', "    var i = 0\n    while i < len(l) {\n        if l[i] == l[(i +\
    \ 1)%len(l)] {\n            i += 2\n            continue\n        }\n        if\
    \ l[i] == 0 {\n            return true\n        }\n        return false\n    }\n\
    \    return false", "    var prev: Int? = nil\n    var pairs = [Int: [Int]]()\n\
    \    for value in l {\n        if prev == nil {\n            prev = value\n  \
    \          pairs[value] = []\n            continue\n        }\n\n        prev\
    \ = nil\n        pairs[value].insert(prev!)\n    }\n\n    if prev == nil {\n \
    \       return false\n    }\n\n    if pairs[prev!].isEmpty {\n        return true\n\
    \    }\n\n    var prev2 = nil\n    for value in pairs[prev!] {\n        if prev2\
    \ == nil {\n            prev2 = value\n            continue\n        }\n\n   \
    \     if value < prev2 {\n            return false\n        }\n\n        prev2\
    \ = value\n    }\n\n    return true", "  var i = 0\n  var j = 1\n  var sum = 0\n\
    \  for i in 0..<l.count {\n    sum += l[i]\n  }\n  for j in 0..<l.count {\n  \
    \  sum += l[j]\n    if sum > 0 {\n      return false\n    }\n  }\n  return true",
  "  var n = l.count\n  if n == 0 {\n    return true\n  }\n  var total: Int = 0\n\
    \  var sum: Int = l[0]\n  for index in 1..<n {\n    sum = sum + l[index]\n   \
    \ if sum < 0 {\n      return false\n    }\n    total = total + sum\n    if total\
    \ == 0 {\n      return true\n    }\n  }\n  return false", "    var n = l[0]\n\
    \    for i := 1; i < len(l); i++ {\n        n = n + l[i]\n        if n == 0 {\n\
    \            return true\n        }\n    }\n    return false", "    if l == nil\
    \ {\n        return false\n    }\n\n    if l.count < 2 {\n        return true\n\
    \    }\n\n    if l.count > 1 {\n        let minSum = l[0]\n        var sum = 0\n\
    \        for v in l {\n            sum += v\n            if sum < 0 {\n      \
    \          sum = 0\n            }\n            if sum > minSum {\n           \
    \     minSum = sum\n            }\n        }\n\n        return minSum == 0\n \
    \   }\n\n    return false", "    var a = l[0]\n    for _, b in l[1..] {\n    \
    \    a -= b\n        if a < 0 {\n            return false\n        }\n    }\n\
    \    return true", "    var leftSum = 0\n    var rightSum = 0\n    for e in l\
    \ {\n        leftSum += e\n        rightSum += -e\n    }\n    return (leftSum\
    \ == 0 && rightSum == 0)", "  var i = 0\n  for element in l {\n    if element\
    \ > 0 {\n      i += element - 1\n    }\n  }\n  return i == 0", "    guard l.isEmpty\
    \ == false else { return false }\n    guard l.count == 2 else {\n        return\
    \ false\n    }\n    var sum = l[0] + l[1]\n    for pair in l.drop(2).reversed()\
    \ {\n        guard sum < pair else {\n            return false\n        }\n  \
    \      sum += pair\n    }\n    return true", "    switch len(l) {\n    case 0:\
    \ return false\n    case 1: return l[0] == 0\n    case 2: return l[0] == l[1]\n\
    \    default: return l[0] == l[1] && l[0] == l[2]\n    }", '    return pairs_sum_to_zero_L(l)',
  '  return pairs_sum_to_zero(l, 0)', "    let sorted = l.sorted()\n    return sorted.reduce(false)\
    \ { $0 && ($1 == sorted[0] + sorted[1]) ? true : $0 }", "    let m = l.count\n\
    \    if m <= 1 {\n        return false\n    }\n\n    var sum = 0\n    for i in\
    \ 0..<m {\n        sum += l[i]\n    }\n\n    return sum == 0", "    var sum =\
    \ 0\n    for i in l {\n        sum += i\n    }\n    return sum == 0", '    return
    len(l) > 1 && l[0] != 0 || pairs_sum_to_zero(tail(l))', "    var zeroSum = 0\n\
    \    var oneSum = 0\n    for i in l {\n        if i == zero {\n            zeroSum\
    \ += 1\n        } else {\n            oneSum += 1\n        }\n    }\n    return\
    \ (oneSum + zeroSum) == 2", "    var n = l.count\n    if n == 0 {\n        return\
    \ false\n    }\n    if n == 1 {\n        return true\n    }\n    \n    if n ==\
    \ 2 {\n        if l[0] + l[1] == 0 {\n            return true\n        }\n   \
    \     return false\n    }\n    \n    var dp, dp2, i, j: Int\n    \n    if l[0]\
    \ == l[1] {\n        return false\n    }\n    \n    if l[0] <= l[1] {\n      \
    \  dp = [0] * (l[0] + 1)\n        dp2 = 0\n        i = 2\n    } else {\n     \
    \   dp = [0] * (l[1] + 1)\n        dp2 = 1\n        i = 1\n    }\n    \n    for\
    \ i = 3; i <= n; i++ {\n        j = i + i\n        if j < n {\n            dp[j]\
    \ = dp[j-1] + j\n            dp2 *= j\n        } else {\n            dp[j] = dp[j-2]\n\
    \        }\n    }\n    \n    return dp[n] == 0", "    var a = 0\n    var b = 0\n\
    \    for i := 0; i < len(l); i++ {\n        a += l[i]\n        b += l[i]\n   \
    \     if a == b {\n            return false\n        }\n    }\n    return true",
  "    var left = 0\n    var right = 0\n    for i in l {\n        right += i\n   \
    \     if right == 0 {\n            left += i\n            right = 0\n        }\n\
    \    }\n    return (left == right)", "\tl.sort()\n\treturn (l[0] + l[1]) == -(l[0]\
    \ + l[1])", "  var i: Int = 0\n  var j: Int = 0\n  var n: Int = 0\n  var is_pair:\
    \ Bool = false\n  var flag: Bool = false\n  for n in l {\n    if n < 0 {\n   \
    \   return false\n    }\n    if n == 0 {\n      flag = true\n      break\n   \
    \ }\n    if i == j {\n      break\n    }\n    i = j\n    j = j + n\n    if j >\
    \ l.count {\n      break\n    }\n    if flag {\n      is_pair = true\n      break\n\
    \    }\n  }\n  if i != j {\n    return true\n  } else {\n    return is_pair\n\
    \  }", "  var a = l.map { $0 * 2 }\n  var b = l.map { $0 + $0 }\n  return a.isSorted\
    \ && b.isSorted", "    if l.len() < 2 {\n        return false\n    }\n    var\
    \ left = l.startIndex\n    var right = l.endIndex\n    var res = true\n    for\
    \ left in l.startIndex..<left {\n        for right in right..<l.endIndex {\n \
    \           if l[left] + l[right] == 0 {\n                res = false\n      \
    \      }\n        }\n    }\n    return res", "    var hasZeroPair: Bool = false\n\
    \    var sumOfPairs = 0\n    for pair in l {\n        sumOfPairs += pair\n   \
    \ }\n    if sumOfPairs == 0 {\n        hasZeroPair = true\n    }\n    return hasZeroPair",
  "    // Sort array and maintain two pointers pointing to the smallest and second\
    \ smallest elements.\n    let sortedArray = Array(l)\n    var small = Int.max\n\
    \    var secondSmall = Int.max\n    var smallest: Int = 0\n    for value in sortedArray\
    \ {\n        let curSmall = value - small\n        if curSmall < 0 {\n       \
    \     secondSmall = smallest\n            small = curSmall\n        } else {\n\
    \            if secondSmall == Int.max {\n                secondSmall = curSmall\n\
    \            }\n        }\n    }\n    if smallest == Int.max {\n        return\
    \ false\n    } else {\n        let secondSmallValue = sortedArray[secondSmall]\
    \ - small\n        if secondSmallValue == 0 {\n            return true\n     \
    \   } else {\n            return false\n        }\n    }", "    var results =\
    \ [Bool]()\n    var last = 0\n    for el in l {\n        if last < el {\n    \
    \        last = el\n        }\n        else {\n            results[results.count-1]\
    \ = false\n        }\n    }\n    var max = 0\n    for el in l {\n        if max\
    \ < el {\n            max = el\n        }\n    }\n    if max != 0 {\n        return\
    \ false\n    }\n    for el in l {\n        if !results[el] {\n            return\
    \ false\n        }\n    }\n    return true", "    // find all unique pairs of\
    \ elements in l, summing to zero.\n    var indexes = Set<(Int, Int)>()\n    for\
    \ i := 0; i < len(l); i++ {\n        if i != l.lastIndex {\n            // pairs\
    \ sum to zero\n            for j := i; j < len(l); j++ {\n                if j\
    \ != l.lastIndex {\n                    if abs(l[i] - l[j]) == 1 {\n         \
    \               indexes.add((i, j))\n                    }\n                }\n\
    \            }\n        }\n    }\n    return indexes.count >= 2", "    var i =\
    \ -1\n    var j = -1\n    var s = 0\n    for k in l {\n        i += 1\n      \
    \  s += k\n        if (j == -1 || s - l[j] > 0) && s > 0 {\n            return\
    \ true\n        }\n        j = i\n        s = 0\n    }\n    return false", " \
    \ let xs: [(Int, Int)] = l.map {\n    $0 - $1\n  }\n  if xs.isEmpty {\n    return\
    \ false\n  }\n  if xs.countElement != 2 {\n    return false\n  }\n  return (xs.filter\
    \ {\n    $0.1 == 0\n  }).isEmpty &&\n    (xs.filter {\n      $0.1 == 1\n    }).isEmpty",
  "    for (k,v) in pairs(l) {\n        if v != 0 && v+k != 0 {\n            return\
    \ false\n        }\n    }\n    return true", "    var i = 0\n    for x in l {\n\
    \        i++\n        for y in l {\n            i++\n            if x == y {\n\
    \                return false\n            }\n        }\n    }\n    return true",
  "    let len = l.count\n    if len == 0 || len == 1 {\n        return true\n   \
    \ }\n    let minIndex_i = l.minIndex({ $0 < $1 })!\n    let maxIndex_i = l.maxIndex({\
    \ $0 > $1 })!\n    if maxIndex_i == len-1 {\n        return true\n    }\n    for\
    \ index in maxIndex_i..minIndex_i+1 {\n        if l[index] != l[index+1] {\n \
    \           return false\n        }\n    }\n    return true", "  var i = 0\n \
    \ var j = 0\n  for i < l.count && j < l.count {\n    if l[i] == l[j] {\n     \
    \ i++\n      j++\n    } else if l[i] > l[j] {\n      i++\n    } else {\n     \
    \ j++\n    }\n  }\n  return i == j", "    guard !l.isEmpty, let first = l.first\
    \ else { return false }\n    var sum = 0\n    var result = false\n    var i =\
    \ 0\n    for n in l {\n        sum += n\n        if sum < 0 {\n            break\n\
    \        }\n        i += 1\n    }\n    guard i == l.count else { return false\
    \ }\n    sum -= l.first!\n    for j in 0..<i {\n        if sum == 0 {\n      \
    \      result = true\n            break\n        }\n        if sum <= 0 {\n  \
    \          break\n        }\n        sum -= l[j + 1]\n    }\n    return result",
  "  var results = [Int]()\n  for case (v, n) in l.enumerated() {\n    if n != 0 {\n\
    \      results.append(v)\n    }\n  }\n  return results.count <= 1", "    var sum\
    \ = 0\n    for _x in l {\n        sum += _x\n    }\n    var result = true\n  \
    \  for _x in l {\n        if sum != 0 {\n            result = result && sum ==\
    \ 0\n        }\n        sum -= _x\n    }\n    return result", "    if l.isEmpty()\
    \ {\n        return false\n    }\n    var sum: Int = 0\n    var j: Int = 0\n \
    \   for i in l {\n        sum += i\n        if sum == 0 {\n            j = i\n\
    \        }\n    }\n    return j == i", '  return helper(l, 0)', "    if l == nil\
    \ { return false }\n    let result = Array()\n    for x in l {\n        for y\
    \ in l {\n            if x == y && x != 0 && y != 0 {\n                result.push([x,\
    \ y])\n            }\n        }\n    }\n    return result.isEmpty == false", " \
    \   var a = l[0]\n    var b = l[0]\n    for _, belt : v in l {\n        if belt\
    \ - a == 0 {\n            a = b\n        } else {\n            b += 1\n      \
    \  }\n    }\n    return a == 0", "    var sum = 0\n    for x in l {\n        sum\
    \ += x\n    }\n    return sum == 0", "    var s = l[0]\n    for i := 1; i < len(l);\
    \ i++ {\n        s += l[i]\n        if s == 0 { // found two distinct elements\
    \ with sum 0\n            return true\n        }\n    }\n    return false", " \
    \   var a = l[0]\n    var b = l[0]\n    for number in l[1...] {\n        if number\
    \ < 0 {\n            number *= -1\n        }\n        a += number\n        b +=\
    \ number\n        if a == 0 {\n            return b == 0\n        }\n    }\n \
    \   return false", "    let counts = Dictionary(grouping: l, by: { $0 + $1 })\n\
    \    guard let first = counts.first,\n        let first = first.value,\n     \
    \   let last = first.value,\n        let last = last.last,\n        counts.count\
    \ == 2 else {\n        return false\n    }\n    return first.0 != last.0 && first.1\
    \ < last.1", "    var sum = 0\n    for i in l {\n        sum += i\n    }\n   \
    \ return sum == 0", "    var a = [0]\n    var b = [0]\n    for x in l {\n    \
    \    a[0] += x\n        b[0] += x\n    }\n    for x in a {\n        if x == 0\
    \ {\n            return false\n        }\n    }\n    for x in b {\n        if\
    \ x == 0 {\n            return false\n        }\n    }\n    return true", "  \
    \  let mut sum = 0\n    for i in l {\n        if sum != 0 {\n            sum +=\
    \ i\n            if sum > 0 {\n                return false\n            }\n \
    \       } else {\n            sum += i\n        }\n    }\n    return true", " \
    \   var i = 0\n    var j = 0\n    var sum = 0\n    for i < len(l) {\n        if\
    \ i == 0 {\n            sum += l[i]\n        }\n        if j == 0 {\n        \
    \    sum += l[i]\n        } else {\n            if sum == 0 {\n              \
    \  return false\n            }\n            if sum > 0 {\n                return\
    \ true\n            }\n            sum -= l[j]\n        }\n        i += 1\n  \
    \      j += 1\n    }\n    return true", "  let n = l.count\n  if n == 0 {\n  \
    \  return true\n  }\n  if n == 1 {\n    return false\n  }\n  let left = l[0 ..<\
    \ n - 1]\n  let right = l[1 ..< n]\n  var result: Int = 0\n  for element in left\
    \ {\n    result = result + element\n  }\n  for element in right {\n    result\
    \ = result - element\n    if result < 0 {\n      return false\n    }\n  }\n  return\
    \ true", "    var sum: Int = l[0]\n    for x in 1..<l.count {\n        sum +=\
    \ l[x]\n        if sum != 0 {\n            if sum != l[0] {\n                return\
    \ false\n            }\n        }\n    }\n    return true", "    var sums = [0]\
    \ * (l.count + 1)\n    for i in l.indices {\n        sums[i + 1] = sums[i] + l[i]\n\
    \    }\n    for i in\n        0..<(l.count - 1)\n    {\n        if sums[i] ==\
    \ 0 {\n            return true\n        }\n    }\n    return false", "    var\
    \ i = 0\n    var j = 0\n    var sum = 0\n    var done = false\n    for i < l.count\
    \ {\n        if j == 0 {\n            sum += l[i]\n            i += 1\n      \
    \  } else if l[i] == 0 {\n            j = j + 1\n        } else {\n          \
    \  sum = sum + l[i]\n            if sum == 0 {\n                done = true\n\
    \            }\n            sum = 0\n            j = j + 1\n        }\n      \
    \  if j == l.count {\n            if sum != 0 {\n                done = true\n\
    \            }\n            j = 0\n        }\n    }\n    return done", "    let\
    \ n = l.count\n    for i in 0..<n {\n        for j in i+1..<n {\n            if\
    \ l[i] + l[j] == 0 {\n                return false\n            }\n        }\n\
    \    }\n    return true", "    if l == nil || l.isEmpty() {\n        return false\n\
    \    }\n\n    var minElem = l[0]\n    var maxElem = l[0]\n    for elem in l {\n\
    \        if elem < minElem {\n            minElem = elem\n        }\n        if\
    \ elem > maxElem {\n            maxElem = elem\n        }\n    }\n\n    var minIndex\
    \ = 0\n    for index in 0..<l.count {\n        if l[index] < minElem {\n     \
    \       minIndex = index\n        }\n    }\n\n    return minIndex == maxIndex",
  "    switch l.count {\n    case 0: return true\n    case 1: return l[0] != 0\n \
    \   default: return false\n    }", "    let (min_i, max_i) = l.minMax()\n    for\
    \ i in 0..<min_i {\n        if i != min_i { //not all elements might be identical\n\
    \            if l.filter({ (v) in\n                let j = l.index(of: v)\n  \
    \              let c = v - l[j] // the difference\n                if c == 0 {\
    \ return true }\n                else { return false }\n            }).count ==\
    \ min_i { return false }\n        }\n    }\n    return true", "    let zero =\
    \ Set([0])\n    return l.map{ $0 - 1 }.filter{ zero.contains($0) }.count == 0",
  "    // code will be optimised for release builds.\n    // for debug builds we check\
    \ explicitly for trivial cases.\n    var left = 0\n    var right = l.count\n \
    \   while left < right {\n        var sum = l[left] + l[right]\n        if sum\
    \ > 0 {\n            left += 1\n        }\n        if sum < 0 {\n            right\
    \ -= 1\n        }\n        if sum == 0 {\n            return true\n        }\n\
    \    }\n    return false", "    var first = 0\n    var second = 1\n    for i in\
    \ l {\n        if first < i {\n            return false\n        }\n        if\
    \ first == i && second != 0 {\n            return false\n        }\n        if\
    \ second == i {\n            first++\n            second++\n        }\n    }\n\
    \    return true", "    var zeroes = 0\n    for idx in 0..<l.count {\n       \
    \ let current = l[idx]\n        if current > 0 {\n            zeroes += 1\n  \
    \      }\n    }\n    if zeroes == 2 {\n        return true\n    }\n    return\
    \ false", "  var i = 0\n  var j = 0\n  var result = 0\n  var pairs = 0\n\n  for\
    \ i < len(l) {\n    for j < len(l) {\n      result = result + l[i]\n      result\
    \ = result + l[j]\n      if result == 0 {\n        pairs += 1\n      }\n     \
    \ if result < 0 {\n        break\n      }\n    }\n    if result == 0 {\n     \
    \ break\n    }\n    if pairs == 2 {\n      return true\n    }\n    pairs = 0\n\
    \    result = 0\n    i += 1\n  }\n  return false", "\tvar zero Int = l[0]\n\t\
    var pairs = Set<Int>()\n\tfor _, v := range l {\n\t\tif v < zero {\n\t\t\treturn\
    \ false\n\t\t}\n\t\tpairs.insert(v)\n\t\tzero -= v\n\t}\n\treturn pairs.isSubset(Set(l[1..]))",
  "    let x = l.sorted()\n    for element in x {\n        for element in x {\n  \
    \          if (element != element && element < 0 && element > -element && element\
    \ != element + element) { return true }\n        }\n    }\n    return false",
  "    let n = l.count\n    let max = (n - 1)/2\n    for i in 0 ..< max {\n      \
    \  let j = i + max\n        if l[i] == l[j] && i != j {\n            return false\n\
    \        }\n    }\n    return true", "\tvar i1, i2, i3 int\n\ti1 = -1\n\ti2 =\
    \ -1\n\ti3 = -1\n\tfor i := 0; i < len(l); i++ {\n\t\tif i == 0 {\n\t\t\ti1 =\
    \ i\n\t\t} else {\n\t\t\ti2 = i\n\t\t}\n\t\tif i2 == i {\n\t\t\ti3 += 1\n\t\t\
    } else {\n\t\t\tif i1 + 1 == i3 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif i2 +\
    \ 1 == i3 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif i1 + 1 < i3 {\n\t\t\t\ti1\
    \ = i3\n\t\t\t}\n\t\t\tif i2 + 1 < i3 {\n\t\t\t\ti2 = i3\n\t\t\t}\n\t\t}\n\t}\n\
    \treturn false", "    let n = l.count\n    return ((n * (n + 1)) / 2 - (l.filter\
    \ { (n, x) in x == 0 }).count) == 0", "  // sort the array\n  l.sort()\n  // initialize\
    \ two pointer at 0 and 1 respectively\n  var p0, p1 int\n  // initialize sum,\
    \ sum is negative to indicate that elements are positive\n  var sum, neg bool\n\
    \n  // initialize a variable k to keep a record of the smallest integer\n  var\
    \ k int\n  // initialize the current smallest integer\n  var min int\n\n  // loop\
    \ until we find two distinct numbers in the array that sum to zero\n  for {\n\
    \    // update k if current number is less than the current smallest integer\n\
    \    if l[k] < min {\n      k = k + 1\n    }\n    // update min if current number\
    \ is less than the previous smallest integer\n    if l[k] < l[min] {\n      min\
    \ = k\n    }\n    // negate sum if current number is negative\n    if l[k] < 0\
    \ {\n      sum = !sum\n    }\n    // update pointers\n    p0 = k\n    p1 = k\n\
    \    if sum {\n      // advance k to next number\n      k = k + 1\n    } else\
    \ {\n      // advance min and k to next number\n      k = k + 1\n      min = k\n\
    \    }\n    // check two numbers are distinct\n    if p0 == p1 {\n      return\
    \ false\n    }\n  } // end for\n  return true", "\tvar i = 0\n\tllen := l.len()\n\
    \tfor i < llen {\n\t\tfor i += 1; i < llen {\n\t\t\tif l[i] - l[i - 1] != 0 {\n\
    \t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true", "    let set = Set()\n\
    \    for i in l {\n        set.insert(i)\n    }\n    for i in set {\n        if\
    \ set.contains(i - 1) {\n            return true\n        }\n    }\n    return\
    \ false", "    var a = l\n    var seen: Set<Int> = []\n    for k in a.reversed()\
    \ {\n        if seen.add(a[k]) {\n            return true\n        }\n    }\n\
    \    return false", "    return pairs_sum_to_zero(l, 0) {\n        sum += $0\n\
    \    }", "  if l.count != 2 {\n    return false\n  }\n  var i = 0\n  let x = l[i]\n\
    \  while i < l.count && l[i] != x {\n    i += 1\n  }\n  if i == l.count {\n  \
    \  return true\n  }\n  return false", "    var sum = 0\n    var count = 2\n  \
    \  for num in l {\n        if num == 0 {\n            count += 1\n           \
    \ continue\n        }\n        sum += num\n        if sum == 0 {\n           \
    \ return count == 2\n        }\n        sum -= num\n        if sum < 0 {\n   \
    \         sum = 0\n        }\n        if sum > 0 {\n            count = 0\n  \
    \      }\n    }\n    return count == 2", "    if l.count <= 1 {\n        return\
    \ false\n    }\n    for i in 1..<l.count {\n        if l[i-1] + l[i] == 0 {\n\
    \            return false\n        }\n    }\n    return true", "    guard l.count\
    \ > 0 else {\n        return false\n    }\n    guard l.count <= MAX_PAIRS_TOZERO\
    \ else {\n        return false\n    }\n    var sum = 0\n    for i in 0..<l.count\
    \ {\n        sum = sum + l[i]\n        if sum == 0 {\n            return true\n\
    \        }\n    }\n    return false", "    if l == nil { return false }\n    var\
    \ i: Int = 0\n    var j = i + 1\n    var k: Int = 0\n    for i < l.count && j\
    \ < l.count {\n        k = l[i]\n        if k != 0 {\n            if k != l[j]\
    \ {\n                return false\n            }\n        } else {\n         \
    \   if i != j {\n                return false\n            }\n        }\n    \
    \    i += 1\n        j += 1\n    }\n    return true", "    l.sort()\n    guard\
    \ var sum : Int = 0\n    for i in l {\n        sum += i\n    }\n    if sum ==\
    \ 0 {\n        return true\n    }\n    return false", "  if l.count == 0 {\n \
    \   return true\n  }\n  \n  if l.count == 1 {\n    return l[0] == 0\n  }\n  \n\
    \  \n  var i = 0\n  \n  var found = false\n  \n  for j in 0..<(l.count) {\n  \
    \  var pair = l[i..<j]\n    var lj = pair\n    var rj = 0\n    \n    for k in\
    \ i..<j {\n      if l[j - k] == 0 {\n        lj += l[k]\n        rj += l[k]\n\
    \      } else {\n        break\n      }\n    }\n    \n    if lj == 0 {\n     \
    \ found = true\n      break\n    }\n    \n    if lj > 0 && lj != rj {\n      found\
    \ = true\n      break\n    }\n    \n    if lj > 0 {\n      found = true\n    \
    \  break\n    }\n    \n    if rj > 0 {\n      found = true\n      break\n    }\n\
    \    \n    i = j + 1\n  }\n  \n  return found", "    let sums = l.map { $0 + $1\
    \ }\n    return sums.reduce(true, combine: { (prev, curr) -> Bool in\n       \
    \ return !prev || curr == 0\n    })", "    var result = 0\n    for i in l {\n\
    \        if i > 0 {\n            result += i\n        }\n    }\n    return result\
    \ == 0", "    for (i1, e1) in enumerate(l) {\n        if i == e1 {\n         \
    \   continue\n        }\n        for (i2, e2) in enumerate(l) {\n            if\
    \ i2 == e2 {\n                continue\n            }\n            if i1+i2 >\
    \ 0 {\n                let sum = (i1+i2)\n                if e - sum == 0 {\n\
    \                    return true\n                }\n            }\n        }\n\
    \    }\n    return false", "    guard l.count > 1 else {\n        return false\n\
    \    }\n    let l = l.sorted()\n    let first = 0\n    let last = l.count - 1\n\
    \    for first < last {\n        let middle = (first + last) / 2\n        if l[middle]\
    \ != l[middle-1] {\n            return false\n        }\n    }\n    return true",
  "\treturn contains_two(l, func(i, j Int) -> Bool { return sum_to_zero(Ints(i, j))\
    \ == 0 })", "    var result = [Int]()\n    var i = 0\n    var j = 0\n    for _\
    \ in 0 ..< l.count {\n        var sum: Int = 0\n        for _ in 0..<i {\n   \
    \         sum += l[i]\n            j = (j + 1) % l.count\n        }\n        if\
    \ sum != 0 {\n            result.append(Int32(sum))\n        }\n        i = j\n\
    \    }\n    return result.count > 1", "    guard l.count >= 2 else {\n       \
    \ return false\n    }\n\n    var i = 0\n    var j = 0\n    var k = 0\n    var\
    \ maxSum = 0\n    for k in 0..<l.count {\n        let sum = l[k] + l[k]\n    \
    \    if k == 0 || sum == 0 || sum > maxSum {\n            maxSum = sum\n     \
    \       i = k\n        }\n    }\n\n    return l[i] == maxSum", '    return pairs_sum_to_zero_internal(l)',
  "    // base case\n    guard l.count >= 1 else {\n        return false\n    }\n\n\
    \    let pairs = count_pairs_sum_to_zero(l)\n    return pairs.count >= 2", " \
    \   if l[0] != 0 || l[0] == l[1] {\n        return false\n    }\n    var sum =\
    \ 0\n    var j = 0\n    for i in l {\n        sum += i\n        if sum == 0 {\n\
    \            return true\n        }\n        j += 1\n    }\n    return false",
  "    if l.count <= 1 {\n        return false\n    }\n    var zeroIndex = -1\n  \
    \  for index in 0..<l.count {\n        let value = l[index]\n        if value\
    \ == 0 {\n            if zeroIndex != -1 {\n                return false\n   \
    \         } else {\n                zeroIndex = index\n            }\n       \
    \ }\n    }\n    return zeroIndex != -1", "    var left = 0\n    var right = 0\n\
    \    var sum = 0\n    var flag = false\n    for x in l {\n        sum += x\n \
    \       left = x\n    }\n    for x in l {\n        right = x\n        if sum >\
    \ 0 {\n            if sum == left {\n                return true\n           \
    \ } else {\n                sum = left + right\n                if sum == 0 {\n\
    \                    return true\n                }\n            }\n        }\
    \ else {\n            if sum == right {\n                return true\n       \
    \     } else {\n                sum = left + right\n                if sum ==\
    \ 0 {\n                    return true\n                }\n            }\n   \
    \     }\n    }\n    return false", "    if l == nil || len(l) == 0 {\n       \
    \ return false\n    }\n\n    var i = 1\n    var sum = 0\n    var x = l[0]\n  \
    \  var y = l[0]\n    var result = true\n\n    for element in l[1..] {\n      \
    \  sum += element\n        if sum < 0 {\n            sum = 0\n            x =\
    \ element\n        } else {\n            y = element\n        }\n        if sum\
    \ == 0 {\n            result = false\n        }\n    }\n\n    return result",
  "    let map: [Int: [Int]] = [:]\n    for v in l {\n        guard let k = map.firstIndex(where:\
    \ { $0 >= v}) else {\n            map[k] = [v]\n            continue\n       \
    \ }\n        map[k]?.append(v)\n    }\n    return map.count < 2", "    var has_duplicates\
    \ = false\n    for e in l {\n        if l.contains(e) && l.contains(e.negate())\
    \ {\n            has_duplicates = true\n            break\n        }\n    }\n\
    \    return !has_duplicates", "    if len(l) < 2 {\n        return false\n   \
    \ }\n\n    type Pair = [Int]\n    var seen: [Pair] = [:]\n\n    for x in l {\n\
    \        if seen[x] != nil {\n            seen[x] = nil\n            return true\n\
    \        }\n\n        for y in l {\n            if x == y {\n                continue\n\
    \            }\n\n            if seen[x] == nil && seen[y] == nil {\n        \
    \        seen[x] = y\n                return true\n            }\n        }\n\
    \    }\n\n    return false", "  var a = 0\n  var b = l.count\n  for i in 0 ..<\
    \ b {\n    for j in 0 ..< b {\n      a += l[i]\n      b--\n      if b == 0 &&\
    \ a-k >= 0 {\n        return true\n      }\n    }\n  }\n  return false", "   \
    \ if l.count == 0 {\n        return true\n    }\n    if l.count == 1 {\n     \
    \   if l[0] == 0 {\n            return true\n        }\n        return false\n\
    \    }\n    if let first = l[0], last = l[l-1] {\n        if first + last == 0\
    \ {\n            return true\n        }\n    }\n    return false", "    var total\
    \ = 0\n    for i in l {\n        total += i\n    }\n    return total == 0", " \
    \   let (m, n) = l.map{\n        Double($0) / Double($1)\n    }.maxElement()\n\
    \    if m == 0 {\n        if n != 0 {\n            return false\n        }\n \
    \       return true\n    }\n    if n == 0 {\n        return false\n    }\n   \
    \ if l == nil {\n        return false\n    }\n    for i in 0..<n {\n        if\
    \ Double(pairSum(l, i, i + 1)) != 0 {\n            return false\n        }\n \
    \   }\n    return true", "  var zeroSum = 0\n  var pairIndex = 0\n  for pairIndex,\
    \ item in enumerate(l) {\n    if item > 0 {\n      zeroSum += item\n    }\n  \
    \  if zeroSum > 0 {\n      return false\n    }\n  }\n  return true", "    guard\
    \ !l.isEmpty else { return false }\n    var i = -1\n    var j = -1\n    var curSum\
    \ = 0\n    for idx in l.indices  {\n        i = idx\n        curSum += l[i]\n\
    \        if curSum == 0 { return true }\n        j = i\n        if j > 0 && l[j-1]\
    \ > curSum {\n            return false\n        }\n    }\n    return true", " \
    \   let sortedLs = l.sorted()\n    if sortedLs.count == 2 {\n        return sortedLs[0]\
    \ + sortedLs[1] == 0 && sortedLs[0] != 0\n    }\n    return false", "    var result:\
    \ Bool = false\n    for x in l {\n        for y in l {\n            if x == y\
    \ {\n                continue\n            }\n            if x == 0 && y > 0 {\n\
    \                result = true\n                break\n            } else if x\
    \ < y && x > 0 {\n                result = false\n                break\n    \
    \        }\n        }\n    }\n    return result", "\tl == pairs_sum_to_zero(l)",
  "    let sorted: Set<Int> = l.sorted()\n    return !sorted.isEmpty && sorted.isSubsetOf(Set(sorted.filter({\
    \ $0 == 0 })))", "    var set = [Int]()\n    for x in l {\n        if set.contains(-x)\
    \ || set.contains(x) {\n            return false\n        } else {\n         \
    \   set.append(x)\n        }\n    }\n    return true", '    return pairs_sum_impl(l,
    0)', "    let n = l.count\n    if n < 2 {\n        return false\n    }\n    let\
    \ first: Int\n    let second: Int\n    if n < 10 {\n        first = l[0]\n   \
    \     second = l[1]\n    } else {\n        first = l[0] + l[1] / 2\n        second\
    \ = l[0] - l[1] / 2\n    }\n    if first == 0 && second == 0 {\n        return\
    \ true\n    }\n    if first != 0 || second != 0 {\n        if first > second {\n\
    \            return true\n        } else {\n            return false\n       \
    \ }\n    }\n    return pairs_sum_to_zero(ArraySlice(l, 2, n))", "    let set =\
    \ Set<Int>()\n    for pair in l {\n        if let v = pair, set.contains(v) {\n\
    \            return true\n        }\n        set.insert(v)\n    }\n    return\
    \ false", "    guard l.count == 2 else { return false }\n    var a = l[0]\n  \
    \  var b = l[1]\n    for idx in 0..<l.count {\n        guard a > 0 && b > 0 else\
    \ {\n            return false\n        }\n        a = a - b\n        b = a * b\n\
    \    }\n    return a > 0 || b > 0", "    if l == nil {\n        return true\n\
    \    }\n    if l.count == 0 {\n        return true\n    }\n    if l.count != 2\
    \ {\n        return false\n    }\n    var i = 0\n    var j = 0\n    while i <\
    \ l.count {\n        while j < l.count && l[j] == l[i]+l[j] {\n            j +=\
    \ 1\n        }\n        if j == l.count {\n            return true\n        }\n\
    \        i += 1\n        j += 1\n    }\n    return false"]
stop_tokens:
- "\n}"
