language: swift
name: HumanEval_61_correct_bracketing
results:
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.substringToIndex(advance(brackets.startIndex, 1))\n \
    \   if brackets.count == 0 { return true }\n\n    var count = 0\n    for character\
    \ in brackets {\n        if character == '(' {\n            count += 1\n     \
    \   } else if character == ')' {\n            count -= 1\n            if count\
    \ <= 0 {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpd9_346bv.swift:18:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '(' {\n                        ^~~\n     \
    \                   \"(\"\n/tmp/tmpd9_346bv.swift:20:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if character == ')' {\n     \
    \                          ^~~\n                               \")\"\n/tmp/tmpd9_346bv.swift:13:42:\
    \ error: cannot find 'advance' in scope\n    brackets = brackets.substringToIndex(advance(brackets.startIndex,\
    \ 1))\n                                         ^~~~~~~\n/tmp/tmpd9_346bv.swift:13:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.substringToIndex(advance(brackets.startIndex, 1))\n    ^~~~~~~~\n\
    /tmp/tmpd9_346bv.swift:13:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    brackets = brackets.substringToIndex(advance(brackets.startIndex, 1))\n \
    \              ~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening_brackets = brackets.characters\n        .map { String($0) }\n\
    \        .filter{ $0 == \"(\" || $0 == \")\" }\n\n    return opening_brackets.count\
    \ == brackets.characters.count - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpps12xhit.swift:13:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    let opening_brackets = brackets.characters\n      \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpps12xhit.swift:17:47: error: 'characters' is unavailable:\
    \ Please use String directly\n    return opening_brackets.count == brackets.characters.count\
    \ - 1\n                                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.toLower()\n    guard let open = brackets.characters.first\
    \ else {\n        return true\n    }\n\n    var bracketCount = 1\n    var openCount\
    \ = 0\n\n    for cur in brackets.characters {\n        if cur == open {\n    \
    \        openCount++\n        } else if cur == open {\n            openCount--\n\
    \            if openCount == 0 {\n                return false\n            }\n\
    \        }\n\n        bracketCount++\n    }\n\n    return bracketCount == 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpunw1uer1.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.toLower()\n    ^~~~~~~~\n/tmp/tmpunw1uer1.swift:13:25:\
    \ error: value of type 'String' has no member 'toLower'\n    brackets = brackets.toLower()\n\
    \               ~~~~~~~~ ^~~~~~~\n/tmp/tmpunw1uer1.swift:14:31: error: 'characters'\
    \ is unavailable: Please use String directly\n    guard let open = brackets.characters.first\
    \ else {\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpunw1uer1.swift:21:25: error: 'characters' is unavailable:\
    \ Please use String directly\n    for cur in brackets.characters {\n         \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpunw1uer1.swift:23:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            openCount++\n                     ^~\n/tmp/tmpunw1uer1.swift:25:22:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  openCount--\n                     ^~\n/tmp/tmpunw1uer1.swift:31:21: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        bracketCount++\n\
    \                    ^~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opens = brackets.characters.split(separator: CharacterSet.openParenthesis).map(String.init)\n\
    \    let closes = brackets.characters.split(separator: CharacterSet.closedParenthesis).map(String.init)\n\
    \    \n    if opens.isEmpty {\n        return false\n    } else if closes.isEmpty\
    \ {\n        return true\n    } else if opens.count != closes.count {\n      \
    \  return false\n    }\n\n    for openIndex, openCharacter in opens.enumerated()\
    \ {\n        let openChar = openCharacter.unicodeScalars.first!\n        guard\
    \ openChar.value > CharacterSet.openParenthesis.unicodeScalars.first!.value else\
    \ { return false }\n        guard openChar.value < CharacterSet.closeParenthesis.unicodeScalars.first!.value\
    \ else { return false }\n        \n        for closeIndex in 0..<closes.count\
    \ {\n            let closeCharacter = closes[closeIndex]\n            guard closeCharacter.unicodeScalars.first!.value\
    \ > openCharacter.unicodeScalars.first!.value else { return false }\n        \
    \    guard closeCharacter.unicodeScalars.first!.value < openCharacter.unicodeScalars.first!.value\
    \ else { return false }\n        }\n    }\n    \n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpeqlozmzf.swift:24:18: error: expected 'in' after for-each pattern\n\
    \    for openIndex, openCharacter in opens.enumerated() {\n                 ^\n\
    /tmp/tmpeqlozmzf.swift:24:18: error: expected Sequence expression for for-each\
    \ loop\n    for openIndex, openCharacter in opens.enumerated() {\n           \
    \      ^\n/tmp/tmpeqlozmzf.swift:13:54: error: cannot find 'CharacterSet' in scope\n\
    \    let opens = brackets.characters.split(separator: CharacterSet.openParenthesis).map(String.init)\n\
    \                                                     ^~~~~~~~~~~~\n/tmp/tmpeqlozmzf.swift:14:55:\
    \ error: cannot find 'CharacterSet' in scope\n    let closes = brackets.characters.split(separator:\
    \ CharacterSet.closedParenthesis).map(String.init)\n                         \
    \                             ^~~~~~~~~~~~\n/tmp/tmpeqlozmzf.swift:25:24: error:\
    \ cannot find 'openCharacter' in scope\n        let openChar = openCharacter.unicodeScalars.first!\n\
    \                       ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    \n    var bracketingNeeded = false\n    var charsToRepeat: [Character] =\
    \ []\n    var openingBracketIndex: Int = 0\n    \n    for char in brackets {\n\
    \        if char == \")\" {\n            if openingBracketIndex < 0 || openingBracketIndex\
    \ == brackets.count - 1 {\n                bracketingNeeded = false\n        \
    \    } else {\n                openingBracketIndex += 1\n            }\n     \
    \   } else {\n            if openingBracketIndex == 0 {\n                bracketingNeeded\
    \ = true\n            }\n            \n            if openingBracketIndex == brackets.count\
    \ - 1 && char != \")\" {\n                bracketingNeeded = true\n          \
    \  }\n            \n            charsToRepeat.append(char)\n        }\n    }\n\
    \    \n    if bracketingNeeded {\n        return false\n    }\n    \n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'tmp35r92jlh/tmp35r92jlh.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1a028ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae19ff85b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae19ff85988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae19ff847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp35r92jlh                        0x000055d26b1d155b <unavailable> + 5467

    5    libc.so.6                          0x00002ae1a047a460 __libc_start_main +
    245

    6    tmp35r92jlh                        0x000055d26b1d11e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979959
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets.split(separator: \"(\").count >= brackets.split(separator: \")\"\
    ).count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'tmpm279tg1f/tmpm279tg1f.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2fa49ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2fa195b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2fa195988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2fa1947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm279tg1f                        0x000055dc82fa7723 <unavailable> + 5923

    5    libc.so.6                          0x00002ad2fa68a460 __libc_start_main +
    245

    6    tmpm279tg1f                        0x000055dc82fa7119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack = brackets.characters.map({ String($0) }).map({ stackPush(stack,\
    \ $0) })\n    for _ in brackets.characters.reversed() {\n        stackPop(&stack)\n\
    \    }\n    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0o3ry84s.swift:13:63: error: cannot find 'stackPush' in scope\n\
    \    var stack = brackets.characters.map({ String($0) }).map({ stackPush(stack,\
    \ $0) })\n                                                              ^~~~~~~~~\n\
    /tmp/tmp0o3ry84s.swift:14:23: error: 'characters' is unavailable: Please use String\
    \ directly\n    for _ in brackets.characters.reversed() {\n                  \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp0o3ry84s.swift:15:9:\
    \ error: cannot find 'stackPop' in scope\n        stackPop(&stack)\n        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.stringByReplacingOccurrencesOfString(\")\", withString: \"\
    \").stringByReplacingOccurrencesOfString(\"(\", withString: \"\")\n\treturn brackets\
    \ == \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpyybi1hv6.swift:13:2: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    )\", withString: \"\").stringByReplacingOccurrencesOfString(\"(\", withString:\
    \ \"\")\n        ^~~~~~~~\n/tmp/tmpyybi1hv6.swift:13:22: error: value of type\
    \ 'String' has no member 'stringByReplacingOccurrencesOfString'\n        brackets\
    \ = brackets.stringByReplacingOccurrencesOfString(\")\", withString: \"\").stringByReplacingOccurrencesOfString(\"\
    (\", withString: \"\")\n                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty() {\n        return false\n    }\n    if let start =\
    \ brackets.range(of: \"(\") {\n        let end = brackets.range(of: \")\")\n \
    \       guard start.endIndex < end.startIndex, end.endIndex < brackets.endIndex,\n\
    \            else { return false }\n        let sub = brackets.substring(from:\
    \ start.upperBound, to: end.lowerBound)\n        let match = brackets.range(of:\
    \ sub)\n        if let _ = match {\n            return true\n        }\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnm7ejqhq.swift:18:81: error: expected expression in conditional\n\
    \        guard start.endIndex < end.startIndex, end.endIndex < brackets.endIndex,\n\
    \                                                                            \
    \    ^\n/tmp/tmpnm7ejqhq.swift:13:17: error: cannot call value of non-function\
    \ type 'Bool'\n    if brackets.isEmpty() {\n                ^      ~~\n      \
    \                 \n/tmp/tmpnm7ejqhq.swift:16:29: error: value of type 'String'\
    \ has no member 'range'\n    if let start = brackets.range(of: \"(\") {\n    \
    \               ~~~~~~~~ ^~~~~\n/tmp/tmpnm7ejqhq.swift:17:28: error: value of\
    \ type 'String' has no member 'range'\n        let end = brackets.range(of: \"\
    )\")\n                  ~~~~~~~~ ^~~~~\n/tmp/tmpnm7ejqhq.swift:20:28: error: value\
    \ of type 'String' has no member 'substring'\n        let sub = brackets.substring(from:\
    \ start.upperBound, to: end.lowerBound)\n                  ~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpnm7ejqhq.swift:21:30: error: value of type 'String' has no member 'range'\n\
    \        let match = brackets.range(of: sub)\n                    ~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard brackets.count == 1 else {\n        return false\n    }\n\n    var\
    \ openingBracketIndex = 0\n    var closingBracketIndex = 0\n\n    while openingBracketIndex\
    \ < brackets.count {\n        guard brackets[openingBracketIndex] != \")\" else\
    \ {\n            return false\n        }\n\n        guard brackets[openingBracketIndex\
    \ + 1] == \"(\" else {\n            return false\n        }\n\n        guard brackets[closingBracketIndex]\
    \ != \"(\" else {\n            return false\n        }\n\n        openingBracketIndex\
    \ += 2\n        closingBracketIndex += 1\n    }\n\n    return openingBracketIndex\
    \ == brackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjgkmjx80.swift:21:15: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        guard brackets[openingBracketIndex]\
    \ != \")\" else {\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpjgkmjx80.swift:25:15:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        guard brackets[openingBracketIndex + 1]\
    \ == \"(\" else {\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpjgkmjx80.swift:29:15:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        guard brackets[closingBracketIndex] !=\
    \ \"(\" else {\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets.characters().map { String($0) }\n    let closing =\
    \ brackets.characters().map { String($0) }\n    let closed: ClosedBrackets = ClosedBrackets(opening,\
    \ closing)\n    if opening.count == 0 {\n        return true\n    }\n\n    var\
    \ openBrackets = 0\n    var closedBrackets = 0\n    var open: Bool = false\n \
    \   var close: Bool = false\n    var bracketed: Bool = false\n    var brackets\
    \ = String()\n    for character in brackets.characters() {\n        switch character\
    \ {\n        case '(':\n            if openBrackets == 0 {\n                open\
    \ = true\n            } else {\n                close = false\n              \
    \  openBrackets -= 1\n            }\n            break\n        case ')':\n  \
    \          if closedBrackets == 0 {\n                close = true\n          \
    \  } else {\n                open = false\n                closedBrackets -= 1\n\
    \            }\n            break\n        case ')':\n            if open {\n\
    \                openBrackets += 1\n                open = true\n            }\
    \ else {\n                closedBrackets += 1\n                close = true\n\
    \            }\n            break\n        case '(':\n            if close {\n\
    \                closeBrackets += 1\n                close = true\n          \
    \  } else {\n                openBrackets += 1\n                open = true\n\
    \            }\n            break\n        case '[':\n            openBrackets\
    \ += 1\n            open = true\n            break\n        case ']':\n      \
    \      if open {\n                openBrackets += 1\n                open = true\n\
    \            } else {\n                closedBrackets += 1\n                close\
    \ = true\n            }\n            break\n        case '{':\n            openBrackets\
    \ += 1\n            open = true\n            break\n        case '}':\n      \
    \      if open {\n                openBrackets += 1\n                open = true\n\
    \            } else {\n                closedBrackets += 1\n                close\
    \ = true\n            }\n            break\n        case '<':\n            openBrackets\
    \ += 1\n            open = true\n            break\n        case '>':\n      \
    \      if open {\n                openBrackets += 1\n                open = true\n\
    \            } else {\n                closedBrackets += 1\n                close\
    \ = true\n            }\n            break\n        case '{':\n            if\
    \ open {\n                openBrackets += 1\n                open = true\n   \
    \         } else {\n                closedBrackets += 1\n                close\
    \ = true\n            }\n            break\n        case '>':\n            if\
    \ open {\n                openBrackets += 1\n                open = true\n   \
    \         } else {\n                closedBrackets += 1\n                close\
    \ = true\n            }\n            break\n        default:\n            break\n\
    \        }\n    }\n    if openBrackets != closing {\n        return false\n  \
    \  }\n    if closedBrackets != open {\n        return false\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1o7lx75u.swift:28:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '(':\n             ^~~\n             \"(\"\n/tmp/tmp1o7lx75u.swift:36:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ')':\n   \
    \          ^~~\n             \")\"\n/tmp/tmp1o7lx75u.swift:44:14: error: single-quoted\
    \ string literal found, use '\"'\n        case ')':\n             ^~~\n      \
    \       \")\"\n/tmp/tmp1o7lx75u.swift:53:14: error: single-quoted string literal\
    \ found, use '\"'\n        case '(':\n             ^~~\n             \"(\"\n/tmp/tmp1o7lx75u.swift:62:14:\
    \ error: single-quoted string literal found, use '\"'\n        case '[':\n   \
    \          ^~~\n             \"[\"\n/tmp/tmp1o7lx75u.swift:66:14: error: single-quoted\
    \ string literal found, use '\"'\n        case ']':\n             ^~~\n      \
    \       \"]\"\n/tmp/tmp1o7lx75u.swift:75:14: error: single-quoted string literal\
    \ found, use '\"'\n        case '{':\n             ^~~\n             \"{\"\n/tmp/tmp1o7lx75u.swift:79:14:\
    \ error: single-quoted string literal found, use '\"'\n        case '}':\n   \
    \          ^~~\n             \"}\"\n/tmp/tmp1o7lx75u.swift:88:14: error: single-quoted\
    \ string literal found, use '\"'\n        case '<':\n             ^~~\n      \
    \       \"<\"\n/tmp/tmp1o7lx75u.swift:92:14: error: single-quoted string literal\
    \ found, use '\"'\n        case '>':\n             ^~~\n             \">\"\n/tmp/tmp1o7lx75u.swift:101:14:\
    \ error: single-quoted string literal found, use '\"'\n        case '{':\n   \
    \          ^~~\n             \"{\"\n/tmp/tmp1o7lx75u.swift:110:14: error: single-quoted\
    \ string literal found, use '\"'\n        case '>':\n             ^~~\n      \
    \       \">\"\n/tmp/tmp1o7lx75u.swift:13:28: error: cannot call value of non-function\
    \ type 'String'\n    let opening = brackets.characters().map { String($0) }\n\
    \                           ^         ~~\n                                   \
    \  \n/tmp/tmp1o7lx75u.swift:14:28: error: cannot call value of non-function type\
    \ 'String'\n    let closing = brackets.characters().map { String($0) }\n     \
    \                      ^         ~~\n                                     \n/tmp/t"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.lowercased()\n    var opening = brackets[0]\n    var\
    \ closing = brackets[0]\n\n    if brackets.contains(\"(\") {\n        opening\
    \ = brackets[0]\n    }\n    if brackets.contains(\")\") {\n        closing = brackets[0]\n\
    \    }\n\n    if opening != closing {\n        return false\n    }\n\n    brackets\
    \ = brackets.substring(1, brackets.characters.count)\n\n    if brackets.contains(\"\
    (\") {\n        opening = brackets[0]\n    }\n    if brackets.contains(\")\")\
    \ {\n        closing = brackets[0]\n    }\n\n    if opening != closing {\n   \
    \     return false\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxourolre.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.lowercased()\n    ^~~~~~~~\n/tmp/tmpxourolre.swift:14:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    var opening = brackets[0]\n               \
    \   ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpxourolre.swift:15:19: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n    var closing\
    \ = brackets[0]\n                  ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpxourolre.swift:18:19: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        opening = brackets[0]\n                  ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxourolre.swift:21:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        closing = brackets[0]\n               \
    \   ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpxourolre.swift:28:25: error: value of type 'String' has\
    \ no member 'substring'\n    brackets = brackets.substring(1, brackets.characters.count)\n\
    \               ~~~~~~~~ ^~~~~~~~~\n/tmp/tmpxourolre.swift:28:5: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n    brackets = brackets.substring(1,\
    \ brackets.characters.count)\n    ^~~~~~~~\n/tmp/tmpxourolre.swift:31:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        opening = brackets[0]\n                  ^~~~~"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Find the smallest and largest opening bracket.\n    let smallBracket =\
    \ brackets.characters.indexOf(String(Character(UnicodeScalar(UInt8(0)))))!\n \
    \   let largeBracket = brackets.characters.indexOf(String(Character(UnicodeScalar(UInt8(65535)))))!\n\
    \    if smallBracket == largeBracket {\n        // If all the brackets are the\
    \ same size, then there is no correct bracketing.\n        return false\n    }\n\
    \n    // Check if the opening and closing brackets match.\n    let openingBrackets\
    \ = brackets.characters\n        .suffix(from: smallBracket)\n        .filter({\
    \ $0 == String(Character(UnicodeScalar(UInt8(0)))) })\n        .count\n    if\
    \ openingBrackets == 1 {\n        return true\n    }\n    let closingBrackets\
    \ = brackets.characters\n        .suffix(from: largeBracket)\n        .filter({\
    \ $0 == String(Character(UnicodeScalar(UInt8(65535)))) })\n        .count\n  \
    \  return closingBrackets == openingBrackets\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzrpjon1m.swift:14:44: error: value of type 'String' has no member\
    \ 'indexOf'\n    let smallBracket = brackets.characters.indexOf(String(Character(UnicodeScalar(UInt8(0)))))!\n\
    \                       ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpzrpjon1m.swift:15:44:\
    \ error: value of type 'String' has no member 'indexOf'\n    let largeBracket\
    \ = brackets.characters.indexOf(String(Character(UnicodeScalar(UInt8(65535)))))!\n\
    \                       ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpzrpjon1m.swift:24:22:\
    \ error: binary operator '==' cannot be applied to operands of type 'Substring.Element'\
    \ (aka 'Character') and 'String'\n        .filter({ $0 == String(Character(UnicodeScalar(UInt8(0))))\
    \ })\n                  ~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzrpjon1m.swift:24:22:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        .filter({ $0 == String(Character(UnicodeScalar(UInt8(0))))\
    \ })\n                     ^\n/tmp/tmpzrpjon1m.swift:31:22: error: binary operator\
    \ '==' cannot be applied to operands of type 'Substring.Element' (aka 'Character')\
    \ and 'String'\n        .filter({ $0 == String(Character(UnicodeScalar(UInt8(65535))))\
    \ })\n                  ~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzrpjon1m.swift:31:22: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ .filter({ $0 == String(Character(UnicodeScalar(UInt8(65535)))) })\n        \
    \             ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var result = true\n    for opening, closing in brackets {\n        let startPos\
    \ = find(input.bytes, from: opening, to: closing)\n        if startPos == -1 {\n\
    \            result = false\n        } else {\n            input.removeSubrange(startPos,\
    \ to: startPos + 1)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpguhaxjks.swift:14:16: error: expected 'in' after for-each pattern\n\
    \    for opening, closing in brackets {\n               ^\n/tmp/tmpguhaxjks.swift:14:16:\
    \ error: expected Sequence expression for for-each loop\n    for opening, closing\
    \ in brackets {\n               ^\n/tmp/tmpguhaxjks.swift:15:24: error: cannot\
    \ find 'find' in scope\n        let startPos = find(input.bytes, from: opening,\
    \ to: closing)\n                       ^~~~\n/tmp/tmpguhaxjks.swift:15:29: error:\
    \ cannot find 'input' in scope\n        let startPos = find(input.bytes, from:\
    \ opening, to: closing)\n                            ^~~~~\n/tmp/tmpguhaxjks.swift:15:61:\
    \ error: cannot find 'closing' in scope\n        let startPos = find(input.bytes,\
    \ from: opening, to: closing)\n                                              \
    \              ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var bracketStack: [String] = []\n\tfor symbol in brackets {\n\t\tswitch symbol\
    \ {\n\t\tcase '(':\n\t\t\tbracketStack.append(symbol)\n\t\tcase ')':\n\t\t\tlet\
    \ top = bracketStack.last\n\t\t\tif top != nil {\n\t\t\t\tif top != '(' {\n\t\t\
    \t\t\treturn false\n\t\t\t\t}\n\t\t\t\tbracketStack.removeLast()\n\t\t\t} else\
    \ {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t\
    }\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxkn2bo60.swift:16:8: error: single-quoted string literal found,\
    \ use '\"'\n                case '(':\n                     ^~~\n            \
    \         \"(\"\n/tmp/tmpxkn2bo60.swift:18:8: error: single-quoted string literal\
    \ found, use '\"'\n                case ')':\n                     ^~~\n     \
    \                \")\"\n/tmp/tmpxkn2bo60.swift:21:15: error: single-quoted string\
    \ literal found, use '\"'\n                                if top != '(' {\n \
    \                                         ^~~\n                              \
    \            \"(\"\n/tmp/tmpxkn2bo60.swift:17:24: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                   \
    \     bracketStack.append(symbol)\n                                          \
    \  ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.lowercased()\n    let opening_brackets = brackets.characters(in:\
    \ CharacterSet.opening_brackets)\n    var closed_brackets = \"\"\n    var open_count\
    \ = 1\n    for opening_bracket in opening_brackets {\n        if opening_bracket\
    \ == \"(\" {\n            if open_count > 1 {\n                closed_brackets\
    \ += \")\"\n            }\n            open_count += 1\n        } else if opening_bracket\
    \ == \")\" {\n            open_count -= 1\n        }\n    }\n    let ending_brackets\
    \ = brackets.characters(in: CharacterSet.closing_brackets)\n    if ending_brackets.count\
    \ != 0 {\n        closed_brackets += \")\"\n    }\n    if open_count != 0 {\n\
    \        return false\n    }\n    let opening_brackets_lower = opening_brackets.lowercased()\n\
    \    let ending_brackets_lower = ending_brackets.lowercased()\n    if opening_brackets_lower\
    \ == ending_brackets_lower {\n        return true\n    }\n    return false\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3tvstket.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.lowercased()\n    ^~~~~~~~\n/tmp/tmp3tvstket.swift:14:52:\
    \ error: cannot find 'CharacterSet' in scope\n    let opening_brackets = brackets.characters(in:\
    \ CharacterSet.opening_brackets)\n                                           \
    \        ^~~~~~~~~~~~\n/tmp/tmp3tvstket.swift:14:37: error: cannot call value\
    \ of non-function type 'String'\n    let opening_brackets = brackets.characters(in:\
    \ CharacterSet.opening_brackets)\n                                    ^\n/tmp/tmp3tvstket.swift:27:51:\
    \ error: cannot find 'CharacterSet' in scope\n    let ending_brackets = brackets.characters(in:\
    \ CharacterSet.closing_brackets)\n                                           \
    \       ^~~~~~~~~~~~\n/tmp/tmp3tvstket.swift:27:36: error: cannot call value of\
    \ non-function type 'String'\n    let ending_brackets = brackets.characters(in:\
    \ CharacterSet.closing_brackets)\n                                   ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets.characters\n        .filter({$0 >= '('})\n       \
    \ .filter({$0 <= '('})\n        .map({String(c: $0)})\n        .sorted()\n\n \
    \   let closing = brackets.characters\n        .filter({$0 >= ')'})\n        .filter({$0\
    \ <= ')'})\n        .map({String(c: $0)})\n        .sorted()\n        .filter({opening.contains($0)})\n\
    \n    return opening.count == closing.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpno5zcg2h.swift:14:24: error: single-quoted string literal found,\
    \ use '\"'\n        .filter({$0 >= '('})\n                       ^~~\n       \
    \                \"(\"\n/tmp/tmpno5zcg2h.swift:15:24: error: single-quoted string\
    \ literal found, use '\"'\n        .filter({$0 <= '('})\n                    \
    \   ^~~\n                       \"(\"\n/tmp/tmpno5zcg2h.swift:20:24: error: single-quoted\
    \ string literal found, use '\"'\n        .filter({$0 >= ')'})\n             \
    \          ^~~\n                       \")\"\n/tmp/tmpno5zcg2h.swift:21:24: error:\
    \ single-quoted string literal found, use '\"'\n        .filter({$0 <= ')'})\n\
    \                       ^~~\n                       \")\"\n/tmp/tmpno5zcg2h.swift:16:21:\
    \ error: extraneous argument label 'c:' in call\n        .map({String(c: $0)})\n\
    \                    ^~~~\n                     \n/tmp/tmpno5zcg2h.swift:22:21:\
    \ error: extraneous argument label 'c:' in call\n        .map({String(c: $0)})\n\
    \                    ^~~~\n                     \n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let bracketsSet = brackets.characters.split(\"\").map{ String($0) }\n   \
    \ let matchingOpenBrackets = bracketsSet.filter{ $0 == \")\" }\n    let matchingClosedBrackets\
    \ = bracketsSet.filter{ $0 == \"(\" }\n    return matchingOpenBrackets.count ==\
    \ matchingClosedBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpv7xdc15w.swift:13:49: error: missing argument label 'separator:'\
    \ in call\n    let bracketsSet = brackets.characters.split(\"\").map{ String($0)\
    \ }\n                                                ^\n                     \
    \                           separator: \n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let bracketingCharacters = brackets.characters\n\n    let expectedStack =\
    \ CharacterStack()\n\n    for bracket in bracketingCharacters {\n        let index\
    \ = expectedStack.top()\n        expectedStack.pop()\n\n        if bracket ==\
    \ \"(\" || bracket == \")\" {\n            if index == 0 {\n                return\
    \ false\n            }\n\n            expectedStack.push(index)\n        }\n \
    \   }\n\n    return expectedStack.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpyu4f6azc.swift:13:41: error: 'characters' is unavailable: Please\
    \ use String directly\n    let bracketingCharacters = brackets.characters\n  \
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpyu4f6azc.swift:15:25: error: cannot find 'CharacterStack'\
    \ in scope\n    let expectedStack = CharacterStack()\n                       \
    \ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opens = brackets.characters.indices\n        .filter { brackets.characters[$0]\
    \ == \"(\" }\n        .map { brackets.characters.index(of: \"(\", $0) }\n    \
    \    .sorted()\n    let closes = brackets.characters.indices\n        .filter\
    \ { brackets.characters[$0] == \")\" }\n        .map { brackets.characters.index(of:\
    \ \")\", $0) }\n        .sorted()\n\n    for (_, start) in opens.enumerated()\
    \ {\n        if closes.first == (start - 1) {\n            return true\n     \
    \   }\n    }\n\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmphblnkhbt.swift:15:36: error: value of optional type 'String.Index?'\
    \ must be unwrapped to a value of type 'String.Index'\n        .map { brackets.characters.index(of:\
    \ \"(\", $0) }\n                                   ^\n/tmp/tmphblnkhbt.swift:15:36:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        .map { brackets.characters.index(of: \"(\", $0) }\n         \
    \                          ^\n                                               \
    \       ?? <#default value#>\n/tmp/tmphblnkhbt.swift:15:36: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        .map\
    \ { brackets.characters.index(of: \"(\", $0) }\n                             \
    \      ^\n                                                     !\n/tmp/tmphblnkhbt.swift:15:51:\
    \ error: extra argument in call\n        .map { brackets.characters.index(of:\
    \ \"(\", $0) }\n                                        ~~~~~~~~~~^~~\n/tmp/tmphblnkhbt.swift:19:36:\
    \ error: value of optional type 'String.Index?' must be unwrapped to a value of\
    \ type 'String.Index'\n        .map { brackets.characters.index(of: \")\", $0)\
    \ }\n                                   ^\n/tmp/tmphblnkhbt.swift:19:36: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        .map { brackets.characters.index(of: \")\", $0) }\n                 \
    \                  ^\n                                                      ??\
    \ <#default value#>\n/tmp/tmphblnkhbt.swift:19:36: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        .map { brackets.characters.index(of:\
    \ \")\", $0) }\n                                   ^\n                       \
    \                              !\n/tmp/tmphblnkhbt.swift:19:51: error: extra argument\
    \ in call\n        .map { brackets.characters.index(of: \")\", $0) }\n       \
    \                                 ~~~~~~~~~~^~~\n/tmp/tmphblnkhbt.swift:22:5:\
    \ error: failed to produce diagnostic for expression; please submit a bug report\
    \ (https://swift.org/contributing/#reporting-bugs) and include the"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let open_brackets = brackets.unicodeScalars.filter{ !$0.isOpen }\n    let\
    \ close_brackets = brackets.unicodeScalars.filter{ $0.isOpen }\n    return open_brackets.count\
    \ == close_brackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpup9w7zbc.swift:13:61: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n    let open_brackets = brackets.unicodeScalars.filter{\
    \ !$0.isOpen }\n                                                         ~~ ^~~~~~\n\
    /tmp/tmpup9w7zbc.swift:14:61: error: value of type 'Unicode.Scalar' has no member\
    \ 'isOpen'\n    let close_brackets = brackets.unicodeScalars.filter{ $0.isOpen\
    \ }\n                                                         ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    return brackets.count{} != brackets.characters.count{}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpc8zuk_6s.swift:13:48: error: cannot find 'CharacterSet' in scope\n\
    \    brackets = brackets.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                               ^~~~~~~~~~~~\n/tmp/tmpc8zuk_6s.swift:13:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n   \
    \ ^~~~~~~~\n/tmp/tmpc8zuk_6s.swift:13:25: error: value of type 'String' has no\
    \ member 'trimmingCharacters'\n    brackets = brackets.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpc8zuk_6s.swift:14:21: error: cannot call value of non-function type 'Int'\n\
    \    return brackets.count{} != brackets.characters.count{}\n                \
    \    ^\n/tmp/tmpc8zuk_6s.swift:14:52: error: cannot call value of non-function\
    \ type 'Int'\n    return brackets.count{} != brackets.characters.count{}\n   \
    \                                                ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Convert brackets to an actual array to make it easier to traverse and\
    \ check\n    var bracketArray = brackets.characters\n    bracketArray.removeLast()\n\
    \    var numOfPairs = bracketArray.count\n    if numOfPairs == 0 {\n        return\
    \ true\n    }\n\n    var openingBracketIndex = bracketArray.startIndex\n    let\
    \ openingBracket = bracketArray[openingBracketIndex]\n    if openingBracket ==\
    \ \")\" {\n        openingBracketIndex -= 1\n    }\n\n    var closingBracketIndex\
    \ = openingBracketIndex\n    while closingBracketIndex < numOfPairs {\n      \
    \  let closingBracket = bracketArray[closingBracketIndex]\n        if closingBracket\
    \ == \"(\" {\n            closingBracketIndex += 1\n        }\n        closingBracketIndex\
    \ += 1\n    }\n\n    if closingBracketIndex != numOfPairs {\n        return false\n\
    \    }\n\n    return openingBracketIndex == 0 && closingBracketIndex == numOfPairs\
    \ - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpezqn38mh.swift:14:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    var bracketArray = brackets.characters\n          \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpezqn38mh.swift:24:29: error: binary operator '-=' cannot be applied\
    \ to operands of type 'String.Index' and 'Int'\n        openingBracketIndex -=\
    \ 1\n        ~~~~~~~~~~~~~~~~~~~ ^  ~\n/tmp/tmpezqn38mh.swift:28:31: error: referencing\
    \ operator function '<' on 'BinaryInteger' requires that 'String.Index' conform\
    \ to 'BinaryInteger'\n    while closingBracketIndex < numOfPairs {\n         \
    \                     ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\n\
    extension BinaryInteger {\n          ^\n/tmp/tmpezqn38mh.swift:31:33: error: binary\
    \ operator '+=' cannot be applied to operands of type 'String.Index' and 'Int'\n\
    \            closingBracketIndex += 1\n            ~~~~~~~~~~~~~~~~~~~ ^  ~\n\
    /tmp/tmpezqn38mh.swift:33:29: error: binary operator '+=' cannot be applied to\
    \ operands of type 'String.Index' and 'Int'\n        closingBracketIndex += 1\n\
    \        ~~~~~~~~~~~~~~~~~~~ ^  ~\n/tmp/tmpezqn38mh.swift:36:28: error: referencing\
    \ operator function '!=' on 'BinaryInteger' requires that 'String.Index' conform\
    \ to 'BinaryInteger'\n    if closingBracketIndex != numOfPairs {\n           \
    \                ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\n\
    extension BinaryInteger {\n          ^\n/tmp/tmpezqn38mh.swift:40:32: error: referencing\
    \ operator function '==' on 'BinaryInteger' requires that 'String.Index' conform\
    \ to 'BinaryInteger'\n    return openingBracketIndex == 0 && closingBracketIndex\
    \ == numOfPairs - 1\n                               ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'String.Index'\nextension BinaryInteger {\n          ^\n\
    /tmp/tmpezqn38mh.swift:40:60: error: referencing operator function '==' on 'BinaryInteger'\
    \ requires that 'String.Index' conform to 'BinaryInteger'\n    return openingBracketI"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return true\n    }\n    if brackets[0] !=\
    \ '(' {\n        return false\n    }\n    var closed = false\n    for i := 1;\
    \ i < brackets.count {\n        if brackets[i] == '(' {\n            closed =\
    \ !closed\n        }\n        else if brackets[i] == ')' {\n            closed\
    \ = !closed\n        }\n        else if brackets[i] == '[' || brackets[i] == ']'\
    \ || brackets[i] == '{' || brackets[i] == '}' || brackets[i] == '<' || brackets[i]\
    \ == '>' || brackets[i] == '(' || brackets[i] == ')' || brackets[i] == '[' ||\
    \ brackets[i] == ']' || brackets[i] == '{' || brackets[i] == '}' || brackets[i]\
    \ == '<' || brackets[i] == '>' {\n            if closed {\n                return\
    \ false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpaenjif6d.swift:16:23: error: single-quoted string literal found,\
    \ use '\"'\n    if brackets[0] != '(' {\n                      ^~~\n         \
    \             \"(\"\n/tmp/tmpaenjif6d.swift:20:12: error: expected type\n    for\
    \ i := 1; i < brackets.count {\n           ^\n            <#type#>\n/tmp/tmpaenjif6d.swift:20:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < brackets.count\
    \ {\n           ^\n/tmp/tmpaenjif6d.swift:20:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i < brackets.count {\n           ^\n/tmp/tmpaenjif6d.swift:21:27:\
    \ error: single-quoted string literal found, use '\"'\n        if brackets[i]\
    \ == '(' {\n                          ^~~\n                          \"(\"\n/tmp/tmpaenjif6d.swift:24:32:\
    \ error: single-quoted string literal found, use '\"'\n        else if brackets[i]\
    \ == ')' {\n                               ^~~\n                             \
    \  \")\"\n/tmp/tmpaenjif6d.swift:27:32: error: single-quoted string literal found,\
    \ use '\"'\n        else if brackets[i] == '[' || brackets[i] == ']' || brackets[i]\
    \ == '{' || brackets[i] == '}' || brackets[i] == '<' || brackets[i] == '>' ||\
    \ brackets[i] == '(' || brackets[i] == ')' || brackets[i] == '[' || brackets[i]\
    \ == ']' || brackets[i] == '{' || brackets[i] == '}' || brackets[i] == '<' ||\
    \ brackets[i] == '>' {\n                               ^~~\n                 \
    \              \"[\"\n/tmp/tmpaenjif6d.swift:27:54: error: single-quoted string\
    \ literal found, use '\"'\n        else if brackets[i] == '[' || brackets[i] ==\
    \ ']' || brackets[i] == '{' || brackets[i] == '}' || brackets[i] == '<' || brackets[i]\
    \ == '>' || brackets[i] == '(' || brackets[i] == ')' || brackets[i] == '[' ||\
    \ brackets[i] == ']' || brackets[i] == '{' || brackets[i] == '}' || brackets[i]\
    \ == '<' || brackets[i] == '>' {\n                                           \
    \          ^~~\n                                                     \"]\"\n/tmp/tmpaenjif6d.swift:27:76:\
    \ error: single-quoted string literal found, use '\"'\n        else if brackets[i]\
    \ == '[' || brackets[i] == ']' || brackets[i] ="
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return true\n    }\n    let openingBrackets\
    \ = brackets.characters(\n        in: CharacterSet(charactersIn: \"(\")\n    )\n\
    \    var closingBrackets = \"\"\n    for char in openingBrackets {\n        closingBrackets\
    \ += \"\\\\\" + String(char)\n    }\n    let closingBracketSet = CharacterSet(charactersIn:\
    \ closingBrackets)\n    for char in openingBrackets {\n        if !closingBracketSet.contains(char)\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpynp4d7nq.swift:17:13: error: cannot find 'CharacterSet' in scope\n\
    \        in: CharacterSet(charactersIn: \"(\")\n            ^~~~~~~~~~~~\n/tmp/tmpynp4d7nq.swift:16:36:\
    \ error: cannot call value of non-function type 'String'\n    let openingBrackets\
    \ = brackets.characters(\n                                   ^\n/tmp/tmpynp4d7nq.swift:23:29:\
    \ error: cannot find 'CharacterSet' in scope\n    let closingBracketSet = CharacterSet(charactersIn:\
    \ closingBrackets)\n                            ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \  let opening_brackets = brackets.characters\n    .filter({ $0 != \"(\" })\n\
    \    .filter({ $0 != \")\" })\n\n  return opening_brackets.count == opening_brackets.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5geglotj.swift:13:35: error: 'characters' is unavailable: Please\
    \ use String directly\n  let opening_brackets = brackets.characters\n        \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.characters.reverse().map{ String($0) }\n\tfor b in brackets\
    \ {\n\t\tlet isClosed = (b == \"(\")\n\t\tlet opening = brackets.count{ $0 ==\
    \ b }\n\t\tif opening < 0 || closing < 0 {\n\t\t\treturn isClosed\n\t\t}\n\t\t\
    if opening > closing {\n\t\t\treturn isClosed\n\t\t}\n\t}\n\treturn true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbu44ck8_.swift:13:33: error: value of type 'String' has no member\
    \ 'reverse'\n        brackets = brackets.characters.reverse().map{ String($0)\
    \ }\n                   ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpbu44ck8_.swift:13:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.characters.reverse().map{ String($0) }\n        ^~~~~~~~\n/tmp/tmpbu44ck8_.swift:16:26:\
    \ error: cannot call value of non-function type 'Int'\n                let opening\
    \ = brackets.count{ $0 == b }\n                                       ^\n/tmp/tmpbu44ck8_.swift:17:21:\
    \ error: cannot find 'closing' in scope\n                if opening < 0 || closing\
    \ < 0 {\n                                  ^~~~~~~\n/tmp/tmpbu44ck8_.swift:20:16:\
    \ error: cannot find 'closing' in scope\n                if opening > closing\
    \ {\n                             ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \  let s = brackets[0..<brackets.count-1].map { String($0) }\n  return s.count\
    \ == brackets.count && s.map { openingBrackets[$0] }.isEmpty\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpa815z7hc.swift:13:11: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \  let s = brackets[0..<brackets.count-1].map { String($0) }\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpa815z7hc.swift:14:47: error: cannot\
    \ find 'openingBrackets' in scope\n  return s.count == brackets.count && s.map\
    \ { openingBrackets[$0] }.isEmpty\n                                          \
    \    ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets[0..<brackets.count()]\n    let closing = brackets[brackets.count..<brackets.count+opening.count]\n\
    \    if opening.isEmpty || closing.isEmpty {\n        return false\n    }\n  \
    \  if opening == closing {\n        return true\n    }\n    return opening.contains(closing)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp547adp6l.swift:13:41: error: cannot call value of non-function\
    \ type 'Int'\n    let opening = brackets[0..<brackets.count()]\n             \
    \                           ^    ~~\n                                        \
    \     \n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openings = brackets.characters\n    var closings = brackets.characters\n\
    \    var result: Bool = false\n    for i in 0..<openings.count {\n        let\
    \ opening = openings[i]\n        let closing = closings[i]\n        if opening\
    \ == closing {\n            continue\n        }\n        if opening == \"(\" &&\
    \ closing == \")\" {\n            if openings.count > i+1 {\n                let\
    \ next = openings[i+1]\n                if next == \"(\" && closings[i+1] == \"\
    )\" {\n                    openings.removeAtIndex(i +1)\n                    closings.removeAtIndex(i\
    \ +1)\n                    result = true\n                }\n            }\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp34b6iezs.swift:26:46: error: expected ',' separator\n         \
    \           openings.removeAtIndex(i +1)\n                                   \
    \          ^\n                                            ,\n/tmp/tmp34b6iezs.swift:27:46:\
    \ error: expected ',' separator\n                    closings.removeAtIndex(i\
    \ +1)\n                                             ^\n                      \
    \                      ,\n/tmp/tmp34b6iezs.swift:13:29: error: 'characters' is\
    \ unavailable: Please use String directly\n    var openings = brackets.characters\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp34b6iezs.swift:14:29: error: 'characters' is unavailable:\
    \ Please use String directly\n    var closings = brackets.characters\n       \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp34b6iezs.swift:17:23: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let opening\
    \ = openings[i]\n                      ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp34b6iezs.swift:18:23: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let closing = closings[i]\n                      ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp34b6iezs.swift:24:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let next = openings[i+1]\n    \
    \                       ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { g"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let chars = brackets.characters\n    var count = 0\n    for char in chars\
    \ {\n        if char == \"(\" {\n            count += 1\n        } else if char\
    \ == \")\" {\n            count -= 1\n        }\n        if count < 0 {\n    \
    \        return false\n        }\n    }\n    return count == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5_aqzt0x.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = brackets.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var isBracketMatching = true\n\n    for bracket in brackets {\n        if\
    \ bracket != bracket {\n            isBracketMatching = false\n            break\n\
    \        }\n    }\n\n    return isBracketMatching\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'tmp29up4ag8/tmp29up4ag8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b632bafcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b632b7f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b632b7f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b632b7f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29up4ag8                        0x0000564b701c3603 <unavailable> + 5635

    5    libc.so.6                          0x00002b632bce8460 __libc_start_main +
    245

    6    tmp29up4ag8                        0x0000564b701c2ff9 <unavailable> + 4089

    '
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Don't check for more than 1 opening or closing bracket.\n    let openingBrackets\
    \ = brackets.characters.split(\"(\")\n        .filter({ $0 != \"(\" })\n     \
    \   .map({ $0 == \"(\" ? 1 : 0 })\n\n    let closingBrackets = brackets.characters.split(\"\
    )\")\n        .filter({ $0 != \")\" })\n        .map({ $0 == \"(\" ? 0 : 1 })\n\
    \n    for (_, element) in openingBrackets.enumerated() {\n        if element !=\
    \ closingBrackets.first! {\n            return false\n        }\n    }\n\n   \
    \ return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdgl9k_mq.swift:14:53: error: missing argument label 'separator:'\
    \ in call\n    let openingBrackets = brackets.characters.split(\"(\")\n      \
    \                                              ^\n                           \
    \                         separator: \n/tmp/tmpdgl9k_mq.swift:18:53: error: missing\
    \ argument label 'separator:' in call\n    let closingBrackets = brackets.characters.split(\"\
    )\")\n                                                    ^\n                \
    \                                    separator: \n/tmp/tmpdgl9k_mq.swift:22:5:\
    \ error: failed to produce diagnostic for expression; please submit a bug report\
    \ (https://swift.org/contributing/#reporting-bugs) and include the project\n \
    \   for (_, element) in openingBrackets.enumerated() {\n    ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBrackets = [Character]()\n    var closingBrackets = [Character]()\n\
    \    for symbol in brackets.characters {\n        let count = openingBrackets.count\n\
    \        let lastIndex = openingBrackets.count - 1\n        if count > 0 && symbol\
    \ == openingBrackets[lastIndex] {\n            openingBrackets.removeAtIndex(lastIndex)\n\
    \        } else {\n            openingBrackets.append(symbol)\n        }\n   \
    \ }\n    for symbol in brackets.characters {\n        let count = closingBrackets.count\n\
    \        let lastIndex = closingBrackets.count - 1\n        if count > 0 && symbol\
    \ == closingBrackets[lastIndex] {\n            closingBrackets.removeAtIndex(lastIndex)\n\
    \        } else {\n            closingBrackets.append(symbol)\n        }\n   \
    \ }\n    return openingBrackets.count == 0 && closingBrackets.count == 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_19144ri.swift:15:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for symbol in brackets.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_19144ri.swift:19:29: error: value of type '[Character]' has no member\
    \ 'removeAtIndex'\n            openingBrackets.removeAtIndex(lastIndex)\n    \
    \        ~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp_19144ri.swift:24:28: error: 'characters'\
    \ is unavailable: Please use String directly\n    for symbol in brackets.characters\
    \ {\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_19144ri.swift:28:29: error: value of type '[Character]'\
    \ has no member 'removeAtIndex'\n            closingBrackets.removeAtIndex(lastIndex)\n\
    \            ~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let chars = brackets.characters()\n\n    var hasCorrectBracketing = true\n\
    \    for char in chars.reversed() {\n        if char == ')' {\n            if\
    \ hasCorrectBracketing {\n                hasCorrectBracketing = false\n     \
    \       } else {\n                hasCorrectBracketing = true\n            }\n\
    \        } else if char == '(' {\n            if hasCorrectBracketing {\n    \
    \            hasCorrectBracketing = false\n            } else {\n            \
    \    hasCorrectBracketing = true\n            }\n        } else {\n          \
    \  hasCorrectBracketing = false\n        }\n    }\n    return hasCorrectBracketing\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4kw4nvo0.swift:17:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == ')' {\n                   ^~~\n               \
    \    \")\"\n/tmp/tmp4kw4nvo0.swift:23:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == '(' {\n                         \
    \ ^~~\n                          \"(\"\n/tmp/tmp4kw4nvo0.swift:13:26: error: cannot\
    \ call value of non-function type 'String'\n    let chars = brackets.characters()\n\
    \                         ^         ~~\n                                   \n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack = [String]()\n    var hasBrackets = false\n    var opening = false\n\
    \    for character in brackets {\n        if character == \"(\" {\n          \
    \  if !opening {\n                opening = true\n            } else {\n     \
    \           opening = false\n                hasBrackets = true\n            \
    \    stack.removeFirst()\n            }\n        } else if character == \")\"\
    \ {\n            opening = false\n        } else {\n            stack.append(character)\n\
    \        }\n    }\n    if hasBrackets == false {\n        return false\n    }\n\
    \    for character in stack {\n        if character == \"(\" {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpz00odjt3.swift:28:26: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            stack.append(character)\n  \
    \                       ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.lowercased()\n    let openings = [brackets[0]]\n    let\
    \ closings = [brackets[i+1] as! Character for i in 0..<brackets.count-1]\n   \
    \ for opening in openings {\n        if closings.contains(opening) {\n       \
    \     return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdxroeq4a.swift:15:49: error: expected ',' separator\n    let closings\
    \ = [brackets[i+1] as! Character for i in 0..<brackets.count-1]\n            \
    \                                    ^\n                                     \
    \          ,\n/tmp/tmpdxroeq4a.swift:15:49: error: expected expression in container\
    \ literal\n    let closings = [brackets[i+1] as! Character for i in 0..<brackets.count-1]\n\
    \                                                ^\n/tmp/tmpdxroeq4a.swift:13:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.lowercased()\n    ^~~~~~~~\n/tmp/tmpdxroeq4a.swift:14:21: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n    let openings = [brackets[0]]\n                    ^~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpdxroeq4a.swift:15:30:\
    \ error: cannot find 'i' in scope\n    let closings = [brackets[i+1] as! Character\
    \ for i in 0..<brackets.count-1]\n                             ^\n/tmp/tmpdxroeq4a.swift:15:35:\
    \ warning: forced cast of 'Character' to same type has no effect\n    let closings\
    \ = [brackets[i+1] as! Character for i in 0..<brackets.count-1]\n            \
    \                      ^~~~~~~~~~~~~~\n                                  \n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    bracketsCount := brackets.count\n\topeningBracketCount := 0\n\tclosingBracketCount\
    \ := 0\n\tfor i := 0; i < len(brackets); i++ {\n\t\tswitch brackets[i] {\n\t\t\
    case '(':\n\t\t\topeningBracketCount++\n\t\tcase '[':\n\t\t\topeningBracketCount++\n\
    \t\tcase '{':\n\t\t\topeningBracketCount++\n\t\tcase '(':\n\t\t\tclosingBracketCount++\n\
    \t\tcase ')':\n\t\t\tclosingBracketCount++\n\t\tcase ']':\n\t\t\tclosingBracketCount++\n\
    \t\tcase '}':\n\t\t\tclosingBracketCount++\n\t\t}\n\t}\n\t// if we have even one\
    \ opening or one closing bracket, we still have unclosed brackets.\n\treturn openingBracketCount\
    \ == bracketsCount && closingBracketCount == bracketsCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4gmpetqo.swift:13:15: error: consecutive statements on a line must\
    \ be separated by ';'\n        bracketsCount := brackets.count\n             \
    \        ^\n                     ;\n/tmp/tmp4gmpetqo.swift:13:16: error: expected\
    \ expression\n        bracketsCount := brackets.count\n                      ^\n\
    /tmp/tmp4gmpetqo.swift:16:9: error: expected type\n        for i := 0; i < len(brackets);\
    \ i++ {\n               ^\n                <#type#>\n/tmp/tmp4gmpetqo.swift:16:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(brackets);\
    \ i++ {\n               ^\n/tmp/tmp4gmpetqo.swift:16:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(brackets); i++ {\n\
    \               ^\n/tmp/tmp4gmpetqo.swift:18:8: error: single-quoted string literal\
    \ found, use '\"'\n                case '(':\n                     ^~~\n     \
    \                \"(\"\n/tmp/tmp4gmpetqo.swift:20:8: error: single-quoted string\
    \ literal found, use '\"'\n                case '[':\n                     ^~~\n\
    \                     \"[\"\n/tmp/tmp4gmpetqo.swift:22:8: error: single-quoted\
    \ string literal found, use '\"'\n                case '{':\n                \
    \     ^~~\n                     \"{\"\n/tmp/tmp4gmpetqo.swift:24:8: error: single-quoted\
    \ string literal found, use '\"'\n                case '(':\n                \
    \     ^~~\n                     \"(\"\n/tmp/tmp4gmpetqo.swift:26:8: error: single-quoted\
    \ string literal found, use '\"'\n                case ')':\n                \
    \     ^~~\n                     \")\"\n/tmp/tmp4gmpetqo.swift:28:8: error: single-quoted\
    \ string literal found, use '\"'\n                case ']':\n                \
    \     ^~~\n                     \"]\"\n/tmp/tmp4gmpetqo.swift:30:8: error: single-quoted\
    \ string literal found, use '\"'\n                case '}':\n                \
    \     ^~~\n                     \"}\"\n/tmp/tmp4gmpetqo.swift:13:2: error: cannot\
    \ find 'bracketsCount' in scope\n        bracketsCount := brackets.count\n   \
    \     ^~~~~~~~~~~~~\n/tmp/tmp4gmpetqo.swift:35:9: error: cannot find 'openingBracketCount'\
    \ in scope\n        return openingB"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if let brackets = brackets {\n        var openingBrackets = [String]()\n\
    \        for char in brackets.unicodeScalars {\n            if let brackets =\
    \ brackets.brackets {\n                openingBrackets.append(String(brackets))\n\
    \            } else {\n                return false\n            }\n        }\n\
    \        if openingBrackets.isEmpty {\n            return true\n        }\n  \
    \      var closingBrackets = [String]()\n        for char in brackets.unicodeScalars\
    \ {\n            if let brackets = brackets.brackets {\n                closingBrackets.append(String(brackets))\n\
    \            } else {\n                return false\n            }\n        }\n\
    \        if closingBrackets.isEmpty {\n            return false\n        }\n \
    \       var mismatchedBrackets = [String]()\n        for (brackets, opening) in\
    \ zip(openingBrackets, closingBrackets) {\n            if opening != brackets\
    \ {\n                mismatchedBrackets.append(brackets)\n            }\n    \
    \    }\n        if mismatchedBrackets.isEmpty {\n            return true\n   \
    \     }\n        return false\n    } else {\n        return true\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp9jempdqp.swift:16:40: error: value of type 'String' has no member\
    \ 'brackets'\n            if let brackets = brackets.brackets {\n            \
    \                  ~~~~~~~~ ^~~~~~~~\n/tmp/tmp9jempdqp.swift:27:40: error: value\
    \ of type 'String' has no member 'brackets'\n            if let brackets = brackets.brackets\
    \ {\n                              ~~~~~~~~ ^~~~~~~~\n/tmp/tmp9jempdqp.swift:13:8:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \    if let brackets = brackets {\n       ^              ~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var bracketCount = brackets.characters.count\n\tif bracketCount < 2 {\n\t\treturn\
    \ true\n\t}\n\n\topeningBracketRegex := regexp.MustCompile(\"\\\\(|\\\\)\")\n\t\
    closingBracketRegex := regexp.MustCompile(\"\\\\)|\\\\)\")\n\n\tvar bracketPairs\
    \ = brackets.characters.split(regexp.MustCompile(\"\\\\(|\\\\)\"))\n\tbracketPairs.reverse()\n\
    \n\tvar result = true\n\tfor _, bracket := range bracketPairs {\n\t\tvar opening\
    \ = bracket\n\t\tvar closing = bracket\n\t\tif opening == closing {\n\t\t\tcontinue\n\
    \t\t}\n\t\topeningCount = openingBracketRegex.FindString(opening).characters.count\n\
    \t\tclosingCount = closingBracketRegex.FindString(closing).characters.count\n\t\
    \tresult = result && (openingCount > 0 && closingCount > 0)\n\t\tif result {\n\
    \t\t\tbreak\n\t\t}\n\t}\n\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3umscmx7.swift:18:21: error: consecutive statements on a line must\
    \ be separated by ';'\n        openingBracketRegex := regexp.MustCompile(\"\\\\\
    (|\\\\)\")\n                           ^\n                           ;\n/tmp/tmp3umscmx7.swift:18:22:\
    \ error: expected expression\n        openingBracketRegex := regexp.MustCompile(\"\
    \\\\(|\\\\)\")\n                            ^\n/tmp/tmp3umscmx7.swift:25:7: error:\
    \ expected 'in' after for-each pattern\n        for _, bracket := range bracketPairs\
    \ {\n             ^\n/tmp/tmp3umscmx7.swift:25:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, bracket := range bracketPairs {\n        \
    \     ^\n/tmp/tmp3umscmx7.swift:13:30: error: 'characters' is unavailable: Please\
    \ use String directly\n        var bracketCount = brackets.characters.count\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3umscmx7.swift:18:2: error: cannot find 'openingBracketRegex'\
    \ in scope\n        openingBracketRegex := regexp.MustCompile(\"\\\\(|\\\\)\"\
    )\n        ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp3umscmx7.swift:21:47: error: cannot find\
    \ 'regexp' in scope\n        var bracketPairs = brackets.characters.split(regexp.MustCompile(\"\
    \\\\(|\\\\)\"))\n                                                     ^~~~~~\n\
    /tmp/tmp3umscmx7.swift:21:47: error: missing argument label 'separator:' in call\n\
    \        var bracketPairs = brackets.characters.split(regexp.MustCompile(\"\\\\\
    (|\\\\)\"))\n                                                     ^\n        \
    \                                             separator: \n/tmp/tmp3umscmx7.swift:26:17:\
    \ error: cannot find 'bracket' in scope\n                var opening = bracket\n\
    \                              ^~~~~~~\n/tmp/tmp3umscmx7.swift:27:17: error: cannot\
    \ find 'bracket' in scope\n                var closing = bracket\n           \
    \                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketStack = [String]()\n\n    for symbol in brackets {\n        if\
    \ symbol == \"(\" {\n            bracketStack.append(symbol)\n        } else if\
    \ symbol == \")\" {\n            if let openBracket = bracketStack.pop() {\n \
    \               return false\n            }\n        }\n    }\n\n    return bracketStack.count\
    \ == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmm__6dq0.swift:17:33: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            bracketStack.append(symbol)\n\
    \                                ^\n/tmp/tmpmm__6dq0.swift:19:47: error: value\
    \ of type '[String]' has no member 'pop'\n            if let openBracket = bracketStack.pop()\
    \ {\n                                 ~~~~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // count brackets with leading whitespace\n    var count = brackets.characters.reduce(0,\
    \ combine: {$0 + $1.isWhitespace})\n\n    if count == 0 {\n        return true\n\
    \    }\n\n    // parse brackets string\n    var open_brackets = [String]()\n \
    \   var closed_brackets = [String]()\n\n    for i in brackets.characters.indices\
    \ {\n        let char = brackets.character(i)\n        let open = char.unicodeScalars.filter({\
    \ $0.isOpen }).count\n        let close = char.unicodeScalars.filter({ $0.isClose\
    \ }).count\n        if open > close {\n            open_brackets.append(char)\n\
    \        }\n        if close > open {\n            closed_brackets.append(char)\n\
    \        }\n    }\n\n    // check all opening brackets\n    var found = false\n\
    \    for open in open_brackets {\n        if !found && closed_brackets.contains(open)\
    \ {\n            found = true\n        }\n    }\n\n    return found\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp791iiljs.swift:14:43: error: extraneous argument label 'combine:'\
    \ in call\n    var count = brackets.characters.reduce(0, combine: {$0 + $1.isWhitespace})\n\
    \                                          ^   ~~~~~~~~~\n                   \
    \                           \n/tmp/tmp791iiljs.swift:14:65: error: cannot convert\
    \ value of type 'Bool' to expected argument type 'Int'\n    var count = brackets.characters.reduce(0,\
    \ combine: {$0 + $1.isWhitespace})\n                                         \
    \                       ^\n/tmp/tmp791iiljs.swift:24:23: error: 'characters' is\
    \ unavailable: Please use String directly\n    for i in brackets.characters.indices\
    \ {\n                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp791iiljs.swift:25:29: error: value of type 'String' has\
    \ no member 'character'\n        let char = brackets.character(i)\n          \
    \         ~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.lowercased()\n\tbrackets = string.remove(brackets, \")\")\n\
    \tbrackets = string.remove(brackets, \"(\")\n\tbrackets = string.remove(brackets,\
    \ \"{\")\n\tbrackets = string.remove(brackets, \"[\")\n\tbrackets = string.remove(brackets,\
    \ \";\")\n\tbrackets = string.remove(brackets, \",\")\n\tbrackets = string.remove(brackets,\
    \ \"=\")\n\n\tvar opening = false\n\tvar closing = false\n\n\tfor i, c := range\
    \ brackets {\n\t\tswitch c {\n\t\tcase \"{\":\n\t\t\tif !opening {\n\t\t\t\treturn\
    \ false\n\t\t\t}\n\t\tcase \"[\", \"(\", \")\", \";\", \":\", \"=\", \"!\", \"\
    +\", \"-\", \"*\", \"/\", \"%\", \"\\\\\", \"^\", \"<\", \"=\", \"!=\", \">\"\
    , \"<=\":\n\t\t\tif opening {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase \"}\",\
    \ \"]\", \"=\", \"+\", \"-\", \"*\", \"/\", \"%\", \"\\\\\", \"^\", \"<\", \"\
    =\", \"!=\", \">\", \"<=\":\n\t\t\tif !closing {\n\t\t\t\treturn false\n\t\t\t\
    }\n\t\tdefault:\n\t\t\topening = false\n\t\t\tclosing = false\n\t\t}\n\n\t\topening\
    \ = opening || c == '{'\n\t\tclosing = closing || c == '}'\n\t}\n\n\treturn true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkh1k16mm.swift:25:7: error: expected 'in' after for-each pattern\n\
    \        for i, c := range brackets {\n             ^\n/tmp/tmpkh1k16mm.swift:25:7:\
    \ error: expected Sequence expression for for-each loop\n        for i, c := range\
    \ brackets {\n             ^\n/tmp/tmpkh1k16mm.swift:44:29: error: single-quoted\
    \ string literal found, use '\"'\n                opening = opening || c == '{'\n\
    \                                          ^~~\n                             \
    \             \"{\"\n/tmp/tmpkh1k16mm.swift:45:29: error: single-quoted string\
    \ literal found, use '\"'\n                closing = closing || c == '}'\n   \
    \                                       ^~~\n                                \
    \          \"}\"\n/tmp/tmpkh1k16mm.swift:13:2: error: cannot assign to value:\
    \ 'brackets' is a 'let' constant\n        brackets = brackets.lowercased()\n \
    \       ^~~~~~~~\n/tmp/tmpkh1k16mm.swift:14:13: error: cannot find 'string' in\
    \ scope\n        brackets = string.remove(brackets, \")\")\n                 \
    \  ^~~~~~\n/tmp/tmpkh1k16mm.swift:14:2: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n        brackets = string.remove(brackets, \")\")\n   \
    \     ^~~~~~~~\n/tmp/tmpkh1k16mm.swift:15:13: error: cannot find 'string' in scope\n\
    \        brackets = string.remove(brackets, \"(\")\n                   ^~~~~~\n\
    /tmp/tmpkh1k16mm.swift:15:2: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n        brackets = string.remove(brackets, \"(\")\n        ^~~~~~~~\n\
    /tmp/tmpkh1k16mm.swift:16:13: error: cannot find 'string' in scope\n        brackets\
    \ = string.remove(brackets, \"{\")\n                   ^~~~~~\n/tmp/tmpkh1k16mm.swift:16:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = string.remove(brackets, \"{\")\n        ^~~~~~~~\n/tmp/tmpkh1k16mm.swift:17:13:\
    \ error: cannot find 'string' in scope\n        brackets = string.remove(brackets,\
    \ \"[\")\n                   ^~~~~~\n/tmp/tmpkh1k16mm.swift:17:2: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n        brackets = string.remove(brackets,\
    \ \"[\")\n        ^~~~~~~~\n/tmp/tmpkh1k1"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \  let open_brackets = brackets.characters.split{$0 == \")\"}\n  guard open_brackets.count\
    \ == brackets.characters.count else {\n    return false\n  }\n\n  let closed_brackets\
    \ = brackets.characters.split{$0 == \"(\"}\n  guard closed_brackets.count == open_brackets.count\
    \ else {\n    return false\n  }\n\n  var count = 0\n  for open in open_brackets\
    \ {\n    if !closed_brackets[count].contains(open) {\n      return false\n   \
    \ }\n\n    count += 1\n  }\n\n  return count == open_brackets.count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpoidm3urb.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n  let open_brackets = brackets.characters.split{$0 == \"\
    )\"}\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpoidm3urb.swift:14:41: error: 'characters' is unavailable:\
    \ Please use String directly\n  guard open_brackets.count == brackets.characters.count\
    \ else {\n                                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpoidm3urb.swift:18:34: error: 'characters'\
    \ is unavailable: Please use String directly\n  let closed_brackets = brackets.characters.split{$0\
    \ == \"(\"}\n                                 ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return false\n    }\n    let firstBracket\
    \ = brackets.startIndex\n    let lastBracket = brackets.endIndex\n    for index\
    \ in firstBracket ..< lastBracket {\n        if brackets[index] != \"(\" || brackets[brackets.index(index,\
    \ offsetBy: 1)] != \")\" {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp9vkfaxz1.swift:18:31: error: protocol 'Sequence' requires that\
    \ 'String.Index' conform to 'Strideable'\n    for index in firstBracket ..< lastBracket\
    \ {\n                              ^\nSwift.Range:1:11: note: requirement from\
    \ conditional conformance of 'Range<String.Index>' to 'Sequence'\nextension Range\
    \ : Sequence where Bound : Strideable, Bound.Stride : SignedInteger {\n      \
    \    ^\n/tmp/tmp9vkfaxz1.swift:18:31: error: referencing instance method 'makeIterator()'\
    \ on 'Range' requires that 'String.Index' conform to 'Strideable'\n    for index\
    \ in firstBracket ..< lastBracket {\n                              ^\nSwift.Range:1:11:\
    \ note: requirement from conditional conformance of 'Range<String.Index>' to 'Collection'\n\
    extension Range : Collection, BidirectionalCollection, RandomAccessCollection\
    \ where Bound : Strideable, Bound.Stride : SignedInteger {\n          ^\n<unknown>:0:\
    \ error: referencing instance method 'next()' on 'Range' requires that 'String.Index'\
    \ conform to 'Strideable'\nSwift.Range:1:11: note: requirement from conditional\
    \ conformance of 'Range<String.Index>' to 'Collection'\nextension Range : Collection,\
    \ BidirectionalCollection, RandomAccessCollection where Bound : Strideable, Bound.Stride\
    \ : SignedInteger {\n          ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Check that the string is actually a string.\n    guard let s = brackets.asString()\
    \ else { return false }\n    // Count the number of open and closed brackets.\n\
    \    var open = 0\n    var closed = 1\n    for c in s {\n        switch c {\n\
    \        case \")\": closed -= 1\n        case \"(\": open += 1\n        default:\
    \ break\n        }\n    }\n    // Return true if every open bracket has a corresponding\
    \ closing bracket.\n    return open >= 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8mse112m.swift:14:28: error: value of type 'String' has no member\
    \ 'asString'\n    guard let s = brackets.asString() else { return false }\n  \
    \                ~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Iterate through the brackets and count the opening and closing brackets.\n\
    \    // If the count is odd, then it's not a valid bracketing sequence.\n    //\
    \ If the count is even, then it's a valid bracketing sequence.\n    // If the\
    \ count is zero then the string is not valid.\n    var count = 0\n    for b in\
    \ brackets {\n        switch b {\n        case \"(\":\n            count += 1\n\
    \        case \"[\":\n            count += 1\n        case \"{\":\n          \
    \  count += 1\n        case \"(\":\n            count -= 1\n        case \"[\"\
    :\n            count -= 1\n        case \"{\":\n            count -= 1\n     \
    \   default:\n            return false\n        }\n    }\n    return count ==\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'tmp02ixrc93/tmp02ixrc93.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8b24bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8b21b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8b21b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8b21b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp02ixrc93                        0x000055f0f1eb840b <unavailable> + 5131

    5    libc.so.6                          0x00002ad8b26ab460 __libc_start_main +
    245

    6    tmp02ixrc93                        0x000055f0f1eb8099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    for bracket in brackets.characters.reverse() {\n        if bracket != brackets.characters.first\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmppg82x8b9.swift:13:40: error: value of type 'String' has no member\
    \ 'reverse'\n    for bracket in brackets.characters.reverse() {\n            \
    \       ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty() {\n        return true\n    }\n\n    let reversed =\
    \ brackets.reversed().map({ String($0) })\n\n    var openings = 0.\n    var closings\
    \ = 0.\n\n    for opening in reversed.enumerated() {\n        guard opening ==\
    \ 0 else { continue }\n\n        let openingString = String(opening[1])\n    \
    \    var closed = false\n\n        for closing in reversed.enumerated() {\n  \
    \          let closingString = String(closing[1])\n            guard closing !=\
    \ opening else { continue }\n\n            if openingString == closingString {\n\
    \                closing += 1\n            } else {\n                closed =\
    \ true\n                closings += 1\n                openings += 1\n       \
    \     }\n\n            if closing == reversed.count {\n                openings\
    \ += 1\n                closings += 1\n            }\n        }\n\n        if\
    \ closed {\n            closings -= 1\n        }\n    }\n\n    if openings !=\
    \ closings {\n        return false\n    }\n\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpf9w43o19.swift:19:21: error: expected member name following '.'\n\
    \    var openings = 0.\n                    ^\n/tmp/tmpf9w43o19.swift:20:21: error:\
    \ expected member name following '.'\n    var closings = 0.\n                \
    \    ^\n/tmp/tmpf9w43o19.swift:13:17: error: cannot call value of non-function\
    \ type 'Bool'\n    if brackets.isEmpty() {\n                ^      ~~\n      \
    \                 \n/tmp/tmpf9w43o19.swift:23:23: error: type '(offset: Int, element:\
    \ String)' cannot conform to 'BinaryInteger'\n        guard opening == 0 else\
    \ { continue }\n                      ^\n/tmp/tmpf9w43o19.swift:23:23: note: only\
    \ concrete types such as structs, enums and classes can conform to protocols\n\
    \        guard opening == 0 else { continue }\n                      ^\n/tmp/tmpf9w43o19.swift:23:23:\
    \ note: required by referencing operator function '==' on 'BinaryInteger' where\
    \ 'Self' = '(offset: Int, element: String)'\n        guard opening == 0 else {\
    \ continue }\n                      ^\n/tmp/tmpf9w43o19.swift:25:43: error: cannot\
    \ access element using subscript for tuple type '(offset: Int, element: String)';\
    \ did you mean to use '.1'?\n        let openingString = String(opening[1])\n\
    \                                          ^~~\n                             \
    \             .1\n/tmp/tmpf9w43o19.swift:29:47: error: cannot access element using\
    \ subscript for tuple type '(offset: Int, element: String)'; did you mean to use\
    \ '.1'?\n            let closingString = String(closing[1])\n                \
    \                              ^~~\n                                         \
    \     .1\n/tmp/tmpf9w43o19.swift:33:17: error: cannot convert value of type '(offset:\
    \ Int, element: String)' to expected argument type 'Int'\n                closing\
    \ += 1\n                ^\n/tmp/tmpf9w43o19.swift:40:24: error: type '(offset:\
    \ Int, element: String)' cannot conform to 'BinaryInteger'\n            if closing\
    \ == reversed.count {\n                       ^\n/tmp/tmpf9w43o19.swift:40:24:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            if"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return true\n    }\n\n    var bracketStack\
    \ = [String]()\n    var openingBrackets: [String] = []\n    var closingBrackets:\
    \ [String] = []\n\n    var currentCharacterIndex = 0\n    for character in brackets\
    \ {\n        switch character {\n        case \")\":\n            if bracketStack.count\
    \ > 0 {\n                bracketStack.removeLast()\n            }\n\n        \
    \    closingBrackets.append(brackets[currentCharacterIndex])\n            currentCharacterIndex++\n\
    \n        case \")\":\n            bracketStack.append(brackets[currentCharacterIndex])\n\
    \            currentCharacterIndex++\n\n        case \"(\":\n            openingBrackets.append(brackets[currentCharacterIndex])\n\
    \            currentCharacterIndex++\n\n        case \"(\":\n            bracketStack.append(brackets[currentCharacterIndex])\n\
    \            currentCharacterIndex++\n        }\n\n        if currentCharacterIndex\
    \ == brackets.count {\n            return brackets.isEqual(closingBrackets)\n\
    \        }\n    }\n\n    return brackets.isEqual(openingBrackets)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpwjhp8d3i.swift:29:44: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            closingBrackets.append(brackets[currentCharacterIndex])\n\
    \                                           ^\n/tmp/tmpwjhp8d3i.swift:30:34: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            currentCharacterIndex++\n\
    \                                 ^~\n/tmp/tmpwjhp8d3i.swift:33:41: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       bracketStack.append(brackets[currentCharacterIndex])\n               \
    \                         ^\n/tmp/tmpwjhp8d3i.swift:34:34: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            currentCharacterIndex++\n\
    \                                 ^~\n/tmp/tmpwjhp8d3i.swift:37:44: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       openingBrackets.append(brackets[currentCharacterIndex])\n            \
    \                               ^\n/tmp/tmpwjhp8d3i.swift:38:34: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            currentCharacterIndex++\n\
    \                                 ^~\n/tmp/tmpwjhp8d3i.swift:41:41: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       bracketStack.append(brackets[currentCharacterIndex])\n               \
    \                         ^\n/tmp/tmpwjhp8d3i.swift:42:34: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            currentCharacterIndex++\n\
    \                                 ^~\n/tmp/tmpwjhp8d3i.swift:32:14: warning: literal\
    \ value is already handled by previous pattern; consider removing it\n       \
    \ case \")\":\n             ^~~\n/tmp/tmpwjhp8d3i.swift:24:14: note: first occurrence\
    \ of identical literal pattern is here\n        case \")\":\n             ^~~\n\
    /tmp/tmpwjhp8d3i.swift:40:14: warning: literal value is already handled by previous\
    \ pattern; consider removing it\n        case \"(\":\n             ^~~\n/tmp/tmpwjhp8d3i.swift:36:14:\
    \ note: first occurrence of identical lit"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openBracketCount = brackets.characters.filter({ $0 == \"(\" }).count\n\
    \    let closeBracketCount = brackets.characters.filter({ $0 == \")\" }).count\n\
    \    if openBracketCount == closeBracketCount {\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpas041cz8.swift:13:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    let openBracketCount = brackets.characters.filter({\
    \ $0 == \"(\" }).count\n                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpas041cz8.swift:14:38: error: 'characters'\
    \ is unavailable: Please use String directly\n    let closeBracketCount = brackets.characters.filter({\
    \ $0 == \")\" }).count\n                                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \n    guard brackets.isEmpty == false else { return true }\n\n    let openingBracketSet\
    \ = NSCharacterSet.openingBracketsCharacterSet()\n    let closingBracketSet =\
    \ NSCharacterSet.closingBracketsCharacterSet()\n\n    let openingBrackets = brackets.componentsSeparatedByCharactersInSet(openingBracketSet)\n\
    \    let closingBrackets = brackets.componentsSeparatedByCharactersInSet(closingBracketSet)\n\
    \n    for openingBracket in openingBrackets {\n        guard let closingBracket\
    \ = closingBrackets.first else {\n            return false\n        }\n      \
    \  let startIndex = openingBracket.rangeOfString(\"(\", options: .BackwardsSearch)\n\
    \        let endIndex = closingBracket.rangeOfString(\")\", options: .BackwardsSearch)\n\
    \        if startIndex != nil && endIndex != nil {\n            let start = startIndex?.location\
    \ == nil ? 0 : startIndex!.location!\n            let end = endIndex?.location\
    \ == nil ? 0 : endIndex!.location!\n\n            let range = NSRange(start: start,\
    \ end: end)\n            let bracketCounts = brackets.rangeOfCharacterFromSet(range).location\
    \ == nil ? 0 : brackets.rangeOfCharacterFromSet(range).location!\n\n         \
    \   if bracketCounts == brackets.length - opening - closing {\n              \
    \  return true\n            }\n        }\n    }\n\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0lkz_v5z.swift:13:57: error: cannot find 'NSCharacterSet' in scope\n\
    \    brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \                                                        ^~~~~~~~~~~~~~\n/tmp/tmp0lkz_v5z.swift:13:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \    ^~~~~~~~\n/tmp/tmp0lkz_v5z.swift:13:25: error: value of type 'String' has\
    \ no member 'stringByTrimmingCharactersInSet'\n    brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0lkz_v5z.swift:17:29:\
    \ error: cannot find 'NSCharacterSet' in scope\n    let openingBracketSet = NSCharacterSet.openingBracketsCharacterSet()\n\
    \                            ^~~~~~~~~~~~~~\n/tmp/tmp0lkz_v5z.swift:18:29: error:\
    \ cannot find 'NSCharacterSet' in scope\n    let closingBracketSet = NSCharacterSet.closingBracketsCharacterSet()\n\
    \                            ^~~~~~~~~~~~~~\n/tmp/tmp0lkz_v5z.swift:20:36: error:\
    \ value of type 'String' has no member 'componentsSeparatedByCharactersInSet'\n\
    \    let openingBrackets = brackets.componentsSeparatedByCharactersInSet(openingBracketSet)\n\
    \                          ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0lkz_v5z.swift:21:36:\
    \ error: value of type 'String' has no member 'componentsSeparatedByCharactersInSet'\n\
    \    let closingBrackets = brackets.componentsSeparatedByCharactersInSet(closingBracketSet)\n\
    \                          ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0lkz_v5z.swift:27:70:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \        let startIndex = openingBracket.rangeOfString(\"(\", options: .BackwardsSearch)\n\
    \                                                                    ~^~~~~~~~~~~~~~~\n\
    /tmp/tmp0lkz_v5z.swift:28:68: error: cannot infer contextual base in reference\
    \ to member 'BackwardsSe"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening_brackets = brackets.components(separatedBy: \"(\")\n    guard\
    \ opening_brackets.count > 0 else {\n        return false\n    }\n    let closing_brackets\
    \ = brackets.components(separatedBy: \")\")\n    guard closing_brackets.count\
    \ == opening_brackets.count else {\n        return false\n    }\n    for i in\
    \ 0..<opening_brackets.count {\n        if closing_brackets[i] != opening_brackets[i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpuevqmuwp.swift:13:37: error: value of type 'String' has no member\
    \ 'components'\n    let opening_brackets = brackets.components(separatedBy: \"\
    (\")\n                           ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpuevqmuwp.swift:17:37:\
    \ error: value of type 'String' has no member 'components'\n    let closing_brackets\
    \ = brackets.components(separatedBy: \")\")\n                           ~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    return brackets.rangeOfString(\")\") != nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpy4ggmawn.swift:13:21: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    return brackets.rangeOfString(\")\") != nil\n         \
    \  ~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketCount = 0\n\n    for openingBracket in brackets {\n        for\
    \ closingBracket in brackets {\n            if openingBracket == closingBracket\
    \ {\n                bracketCount++\n            }\n        }\n    }\n\n    return\
    \ bracketCount == brackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6hzvhowa.swift:18:29: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                bracketCount++\n                     \
    \       ^~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.characters\n        .map(String.init)\n  \
    \      .flatMap {\n            brackets.unicodeScalars.filter {\n            \
    \    ($0.value > 0xD800) && ($0.value < 0xDC00)\n            }\n        }\n  \
    \      .map(String.init)\n    \n    if openingBrackets.isEmpty {\n        return\
    \ false\n    }\n    \n    let closingBrackets = brackets.characters\n        .map(String.init)\n\
    \        .flatMap {\n            brackets.unicodeScalars.filter {\n          \
    \      ($0.value >= 0xD800) && ($0.value < 0xDC00)\n            }\n        }\n\
    \        .map(String.init)\n    \n    if closingBrackets.isEmpty {\n        return\
    \ true\n    }\n    \n    let openingBracketIndex = openingBrackets.map { $0.firstIndex(of:\
    \ char) }\n    \n    if openingBracketIndex.count == openingBrackets.count {\n\
    \        let difference = openingBracketIndex.map({ openingBrackets[$0] - openingBrackets[$0].firstIndex(of:\
    \ char) })\n        return difference.count() == openingBrackets.count\n    }\n\
    \    \n    let closingBracketIndex = closingBrackets.map { $0.firstIndex(of: char)\
    \ }\n    \n    if closingBracketIndex.count == closingBrackets.count {\n     \
    \   let difference = closingBracketIndex.map({ closingBrackets[$0] - closingBrackets[$0].firstIndex(of:\
    \ char) })\n        return difference.count() == closingBrackets.count\n    }\n\
    \    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpyai09uy7.swift:15:18: error: cannot convert value of type '() ->\
    \ String.UnicodeScalarView' to expected argument type '(String) throws -> String.UnicodeScalarView'\n\
    \        .flatMap {\n                 ^\n/tmp/tmpyai09uy7.swift:28:18: error:\
    \ cannot convert value of type '() -> String.UnicodeScalarView' to expected argument\
    \ type '(String) throws -> String.UnicodeScalarView'\n        .flatMap {\n   \
    \              ^\n/tmp/tmpyai09uy7.swift:39:71: error: cannot find 'char' in scope\n\
    \    let openingBracketIndex = openingBrackets.map { $0.firstIndex(of: char) }\n\
    \                                                                      ^~~~\n\
    /tmp/tmpyai09uy7.swift:42:109: error: cannot find 'char' in scope\n        let\
    \ difference = openingBracketIndex.map({ openingBrackets[$0] - openingBrackets[$0].firstIndex(of:\
    \ char) })\n                                                                 \
    \                                           ^~~~\n/tmp/tmpyai09uy7.swift:46:71:\
    \ error: cannot find 'char' in scope\n    let closingBracketIndex = closingBrackets.map\
    \ { $0.firstIndex(of: char) }\n                                              \
    \                        ^~~~\n/tmp/tmpyai09uy7.swift:49:109: error: cannot find\
    \ 'char' in scope\n        let difference = closingBracketIndex.map({ closingBrackets[$0]\
    \ - closingBrackets[$0].firstIndex(of: char) })\n                            \
    \                                                                            \
    \    ^~~~\n"
  stdout: ''
  timestamp: 1659979964
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let bracketsSet = brackets.characters(using: .unicode).flatMap { String($0)\
    \ }\n    let openingBrackets = [ \"(\" ] + bracketsSet\n    let closingBrackets\
    \ = bracketsSet.filter {\n        bracketsSet.contains(String($0[($0.count - 1)..<$0.count]))\
    \ ?? false }\n    return openingBrackets.count == closingBrackets.count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7kwkw4cp.swift:13:32: error: cannot call value of non-function\
    \ type 'String'\n    let bracketsSet = brackets.characters(using: .unicode).flatMap\
    \ { String($0) }\n                               ^\n/tmp/tmp7kwkw4cp.swift:13:51:\
    \ error: cannot infer contextual base in reference to member 'unicode'\n    let\
    \ bracketsSet = brackets.characters(using: .unicode).flatMap { String($0) }\n\
    \                                                 ~^~~~~~~\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var has_correct = false\n    for bracket in brackets {\n        switch bracket\
    \ {\n        case \")\":\n            has_correct = true\n        case \")()\"\
    :\n            has_correct = true\n        case \"()\":\n            has_correct\
    \ = true\n        case \"((\": // allow nested parentheses, like \"((()))\"\n\
    \            has_correct = true\n        case \"((\": // allow nested parentheses,\
    \ like \"(()(())\"\n            has_correct = true\n        case \"(()\": // allow\
    \ nested parentheses, like \"()(())\"\n            has_correct = true\n      \
    \  default:\n            has_correct = false\n        }\n    }\n    return has_correct\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_az4r_ti.swift:18:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \")()\":\n           \
    \  ^~~~~\n/tmp/tmp_az4r_ti.swift:20:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"()\":\n            \
    \ ^~~~\n/tmp/tmp_az4r_ti.swift:22:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"((\": // allow nested\
    \ parentheses, like \"((()))\"\n             ^~~~\n/tmp/tmp_az4r_ti.swift:24:14:\
    \ error: expression pattern of type 'String' cannot match values of type 'Character'\n\
    \        case \"((\": // allow nested parentheses, like \"(()(())\"\n        \
    \     ^~~~\n/tmp/tmp_az4r_ti.swift:26:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"(()\": // allow nested\
    \ parentheses, like \"()(())\"\n             ^~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var openedBrackets = brackets.characters.split(\"(\" as String)\n\tvar closedBrackets\
    \ = brackets.characters.split(\" as String\")\n\t\n\tguard openedBrackets.count\
    \ == closedBrackets.count else { return false }\n\t\n\tfor i in 0..<openedBrackets.count\
    \ {\n\t\tguard openedBrackets[i].characters.characters.count > 1 else { return\
    \ false }\n\t\tguard openedBrackets[i] != closedBrackets[i] else { return false\
    \ }\n\t}\n\t\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_ykzzzlf.swift:13:49: error: missing argument label 'separator:'\
    \ in call\n        var openedBrackets = brackets.characters.split(\"(\" as String)\n\
    \                                                       ^\n                  \
    \                                     separator: \n/tmp/tmp_ykzzzlf.swift:14:49:\
    \ error: missing argument label 'separator:' in call\n        var closedBrackets\
    \ = brackets.characters.split(\" as String\")\n                              \
    \                         ^\n                                                \
    \       separator: \n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    return brackets.rangeOfString(\"^\\\\(|\\\\)$\") == nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnm2iesc0.swift:13:21: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    return brackets.rangeOfString(\"^\\\\(|\\\\)$\") == nil\n\
    \           ~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    let bracketsAsCharacterArray = brackets.characters\n\tguard bracketsAsCharacterArray.isEmpty\
    \ else {\n\t\treturn false\n\t}\n\tlet stack = Array<Character>()\n\tstack.append(bracketsAsCharacterArray.first!)\n\
    \twhile !stack.isEmpty {\n\t\tlet current = stack.removeLast()\n\t\tlet lastOpening\
    \ = current.first\n\t\tlet nextLastOpening = bracketsAsCharacterArray.last(where:\
    \ { $0 == lastOpening })\n\t\tif nextLastOpening == nil {\n\t\t\treturn false\n\
    \t\t}\n\t\tstack.append(nextLastOpening!)\n\t}\n\treturn true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7ua6ex16.swift:13:42: error: 'characters' is unavailable: Please\
    \ use String directly\n        let bracketsAsCharacterArray = brackets.characters\n\
    \                                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp7ua6ex16.swift:18:8: error: cannot use\
    \ mutating member on immutable value: 'stack' is a 'let' constant\n        stack.append(bracketsAsCharacterArray.first!)\n\
    \        ~~~~~ ^\n/tmp/tmp7ua6ex16.swift:17:2: note: change 'let' to 'var' to\
    \ make it mutable\n        let stack = Array<Character>()\n        ^~~\n     \
    \   var\n/tmp/tmp7ua6ex16.swift:20:23: error: cannot use mutating member on immutable\
    \ value: 'stack' is a 'let' constant\n                let current = stack.removeLast()\n\
    \                              ~~~~~ ^\n/tmp/tmp7ua6ex16.swift:17:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let stack = Array<Character>()\n\
    \        ^~~\n        var\n/tmp/tmp7ua6ex16.swift:26:9: error: no exact matches\
    \ in call to instance method 'append'\n                stack.append(nextLastOpening!)\n\
    \                      ^\n/tmp/tmp7ua6ex16.swift:26:9: note: found candidate with\
    \ type '(__owned Character) -> ()'\n                stack.append(nextLastOpening!)\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets[0..<brackets.startIndex]\n    let closing = brackets[brackets.endIndex..<brackets.endIndex.advanced(by:\
    \ -1)]\n    return opening.count == closing.count && opening.count == opening.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpch_g_927.swift:13:28: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n    let opening = brackets[0..<brackets.startIndex]\n\
    \                           ^\n/tmp/tmpch_g_927.swift:14:66: error: value of type\
    \ 'String.Index' has no member 'advanced'\n    let closing = brackets[brackets.endIndex..<brackets.endIndex.advanced(by:\
    \ -1)]\n                                               ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var i = 0\n    var openingBracketCount = 0\n    var closingBracketCount =\
    \ 0\n    while i < brackets.count {\n        let char = brackets.characters[i]\n\
    \        if char == \"(\" {\n            openingBracketCount += 1\n        } else\
    \ {\n            closingBracketCount += 1\n        }\n        i += 1\n    }\n\
    \    if openingBracketCount > closingBracketCount {\n        return false\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcz6z8jls.swift:17:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = brackets.characters[i]\n                   ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcz6z8jls.swift:17:29:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = brackets.characters[i]\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening = brackets\n    for openBracket in brackets {\n        if openBracket\
    \ != \"(\" && openBracket != \")\" {\n            return false\n        }\n  \
    \  }\n    for openBracket in brackets {\n        if openBracket == \"(\" {\n \
    \           opening = opening.substringToIndex(advance(opening, 1, openBracket))\n\
    \        } else if openBracket == \")\" {\n            if opening == \"\" {\n\
    \                return false\n            }\n            opening = opening.substringToIndex(advance(opening,\
    \ -1, openBracket))\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0fy1xgv9.swift:21:48: error: cannot find 'advance' in scope\n \
    \           opening = opening.substringToIndex(advance(opening, 1, openBracket))\n\
    \                                               ^~~~~~~\n/tmp/tmp0fy1xgv9.swift:21:31:\
    \ error: value of type 'String' has no member 'substringToIndex'\n           \
    \ opening = opening.substringToIndex(advance(opening, 1, openBracket))\n     \
    \                 ~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp0fy1xgv9.swift:26:48: error:\
    \ cannot find 'advance' in scope\n            opening = opening.substringToIndex(advance(opening,\
    \ -1, openBracket))\n                                               ^~~~~~~\n\
    /tmp/tmp0fy1xgv9.swift:26:31: error: value of type 'String' has no member 'substringToIndex'\n\
    \            opening = opening.substringToIndex(advance(opening, -1, openBracket))\n\
    \                      ~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening_brackets: [Character] = brackets.characters.split { $0 == \"\
    (\" }.map(String.init)\n    let closing_brackets: [Character] = brackets.characters.split\
    \ { $0 == \")\" }.map(String.init)\n    guard opening_brackets.count == closing_brackets.count\
    \ else { return false }\n    var opening_brackets_encountered = false\n    var\
    \ closing_brackets_encountered = false\n    var result = true\n    for char in\
    \ opening_brackets {\n        if char != closing_brackets_encountered {\n    \
    \        closing_brackets_encountered = false\n            opening_brackets_encountered\
    \ = true\n        } else {\n            closing_brackets_encountered = true\n\
    \        }\n        result = result && (char == closing_brackets[opening_brackets.index(of:\
    \ char)!])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjwdefnfi.swift:13:92: error: cannot convert value of type '(__shared\
    \ Substring) -> String' to expected argument type '(String.SubSequence) throws\
    \ -> Character' (aka '(Substring) throws -> Character')\n    let opening_brackets:\
    \ [Character] = brackets.characters.split { $0 == \"(\" }.map(String.init)\n \
    \                                                                            \
    \              ^\n/tmp/tmpjwdefnfi.swift:14:92: error: cannot convert value of\
    \ type '(__shared Substring) -> String' to expected argument type '(String.SubSequence)\
    \ throws -> Character' (aka '(Substring) throws -> Character')\n    let closing_brackets:\
    \ [Character] = brackets.characters.split { $0 == \")\" }.map(String.init)\n \
    \                                                                            \
    \              ^\n/tmp/tmpjwdefnfi.swift:20:20: error: cannot convert value of\
    \ type 'Bool' to expected argument type 'Character'\n        if char != closing_brackets_encountered\
    \ {\n                   ^\n/tmp/tmpjwdefnfi.swift:26:71: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n        result = result && (char\
    \ == closing_brackets[opening_brackets.index(of: char)!])\n                  \
    \                                                    ^\n/tmp/tmpjwdefnfi.swift:26:71:\
    \ note: use 'firstIndex(of:)' instead\n        result = result && (char == closing_brackets[opening_brackets.index(of:\
    \ char)!])\n                                                                 \
    \     ^~~~~\n                                                                \
    \      firstIndex\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let chars = brackets.characters\n    var opening = false\n    var closing\
    \ = false\n    var last = chars.count - 1\n    for char in chars {\n        let\
    \ isOpen = char == brackets.start\n        let isClose = char == brackets.end\n\
    \        if opening && !closing {\n            if isOpen {\n                opening\
    \ = false\n            } else {\n                closing = true\n            }\n\
    \        } else if !opening && !closing {\n            if isClose {\n        \
    \        closing = false\n            } else {\n                opening = true\n\
    \            }\n        } else {\n            if opening && closing {\n      \
    \          closing = false\n            } else if opening {\n                opening\
    \ = false\n            }\n        }\n        if opening && closing {\n       \
    \     last = chars.count - 1\n        }\n    }\n    return last == 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6j4hcr48.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = brackets.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6j4hcr48.swift:18:39:\
    \ error: value of type 'String' has no member 'start'\n        let isOpen = char\
    \ == brackets.start\n                             ~~~~~~~~ ^~~~~\n/tmp/tmp6j4hcr48.swift:19:40:\
    \ error: value of type 'String' has no member 'end'\n        let isClose = char\
    \ == brackets.end\n                              ~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.characters\n\tbrackets = String(brackets)\n\tvar close_brackets\
    \ = [Character]()\n\tfor x in brackets {\n\t\tif x == \")\" {\n\t\t\tif close_brackets.last\
    \ == \")\" {\n\t\t\t\tclose_brackets = close_brackets[0..<close_brackets.count-1]\n\
    \t\t\t\tclose_brackets.append(x)\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t\
    }\n\t\t} else if x == \"]\" {\n\t\t\tif close_brackets.last == \"]\" {\n\t\t\t\
    \tclose_brackets = close_brackets[0..<close_brackets.count-1]\n\t\t\t\tclose_brackets.append(x)\n\
    \t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if x == \"(\" {\n\t\t\
    \tif close_brackets.last == \"(\" {\n\t\t\t\tclose_brackets = close_brackets[0..<close_brackets.count-1]\n\
    \t\t\t\tclose_brackets.append(x)\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t\
    }\n\t\t} else {\n\t\t\tif close_brackets.last == x {\n\t\t\t\tclose_brackets =\
    \ close_brackets[0..<close_brackets.count-1]\n\t\t\t} else {\n\t\t\t\treturn false\n\
    \t\t\t}\n\t\t}\n\t}\n\tlet brackets_set = Set(close_brackets)\n\tif !brackets_set.isSubset(from:\
    \ brackets) {\n\t\treturn false\n\t} else {\n\t\treturn true\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcl_utv9y.swift:13:2: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n        brackets = brackets.characters\n        ^~~~~~~~\n\
    /tmp/tmpcl_utv9y.swift:14:2: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n        brackets = String(brackets)\n        ^~~~~~~~\n/tmp/tmpcl_utv9y.swift:19:36:\
    \ error: cannot assign value of type 'ArraySlice<Character>' to type '[Character]'\n\
    \                                close_brackets = close_brackets[0..<close_brackets.count-1]\n\
    \                                                 ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpcl_utv9y.swift:26:36: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n                                close_brackets = close_brackets[0..<close_brackets.count-1]\n\
    \                                                 ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpcl_utv9y.swift:33:36: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n                                close_brackets = close_brackets[0..<close_brackets.count-1]\n\
    \                                                 ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpcl_utv9y.swift:40:36: error: cannot assign value of type 'ArraySlice<Character>'\
    \ to type '[Character]'\n                                close_brackets = close_brackets[0..<close_brackets.count-1]\n\
    \                                                 ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpcl_utv9y.swift:47:27: error: incorrect argument label in call (have 'from:',\
    \ expected 'of:')\n        if !brackets_set.isSubset(from: brackets) {\n     \
    \                            ^~~~~\n                                  of\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return true\n    }\n    var opening = brackets[0..<brackets.startIndex]\n\
    \    var closing = brackets[brackets.endIndex..<brackets.endIndex.advancedBy(2)]\n\
    \n    var i = 0\n    var result = true\n    while i < opening.count {\n      \
    \  if opening[i] != closing[i] {\n            result = false\n        }\n    \
    \    i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpl4msztu0.swift:16:28: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n    var opening = brackets[0..<brackets.startIndex]\n\
    \                           ^\n/tmp/tmpl4msztu0.swift:17:66: error: value of type\
    \ 'String.Index' has no member 'advancedBy'\n    var closing = brackets[brackets.endIndex..<brackets.endIndex.advancedBy(2)]\n\
    \                                               ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening_brackets = brackets.unicodeScalars\n    var closing_brackets\
    \ = brackets.unicodeScalars\n    for opening in opening_brackets {\n        if\
    \ let closing = closing_brackets.first {\n            if opening == closing {\n\
    \                closing_brackets.remove(at: 0)\n            } else {\n      \
    \          return false\n            }\n        } else {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp74c26m33.swift:18:45: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.UnicodeScalarView.Index' (aka 'String.Index')\n\
    \                closing_brackets.remove(at: 0)\n                            \
    \                ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var count = 0\n    var opening = false\n    for letter in brackets {\n  \
    \      switch letter {\n        case \")\":\n            if !opening {\n     \
    \           return false\n            }\n            count--\n        case \"\
    )'\":\n            if !opening {\n                return false\n            }\n\
    \            count--\n        case \"'\":\n            if !opening {\n       \
    \         return false\n            }\n            count++\n        case \"()\"\
    :\n            if !opening {\n                return false\n            }\n  \
    \          count++\n        case \"()'\":\n            if !opening {\n       \
    \         return false\n            }\n            count++\n        case \"('\"\
    :\n            if !opening {\n                return false\n            }\n  \
    \          count--\n        case \"(''\":\n            if !opening {\n       \
    \         return false\n            }\n            count--\n        default:\n\
    \            if !opening {\n                return false\n            }\n    \
    \        count++\n            opening = false\n        }\n        opening = false\n\
    \    }\n    return count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzha1vvbm.swift:22:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \")'\":\n            \
    \ ^~~~\n/tmp/tmpzha1vvbm.swift:32:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"()\":\n            \
    \ ^~~~\n/tmp/tmpzha1vvbm.swift:37:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"()'\":\n           \
    \  ^~~~~\n/tmp/tmpzha1vvbm.swift:42:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"('\":\n            \
    \ ^~~~\n/tmp/tmpzha1vvbm.swift:47:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"(''\":\n           \
    \  ^~~~~\n/tmp/tmpzha1vvbm.swift:21:18: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n            count--\n                 ^~\n/tmp/tmpzha1vvbm.swift:26:18:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  count--\n                 ^~\n/tmp/tmpzha1vvbm.swift:31:18: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            count++\n        \
    \         ^~\n/tmp/tmpzha1vvbm.swift:36:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n            count++\n                 ^~\n/tmp/tmpzha1vvbm.swift:41:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  count++\n                 ^~\n/tmp/tmpzha1vvbm.swift:46:18: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            count--\n        \
    \         ^~\n/tmp/tmpzha1vvbm.swift:51:18: error: cannot find operator '--' in\
    \ scope; did you mean '-= 1'?\n            count--\n                 ^~\n/tmp/tmpzha1vvbm.swift:56:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  count++\n                 ^~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let mut stack = CharacterStack()\n    for char in brackets.characters {\n\
    \        if char == '(' {\n            stack.append(char)\n        } else if char\
    \ == ')' {\n            if stack.isEmpty() {\n                return false\n \
    \           }\n            stack.pop()\n        } else {\n            if !stack.isEmpty()\
    \ {\n                return false\n            }\n            stack.append(char)\n\
    \        }\n    }\n    return !stack.isEmpty()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpw2ryq6w0.swift:13:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut stack =\
    \ CharacterStack()\n            ^\n/tmp/tmpw2ryq6w0.swift:13:13: note: join the\
    \ identifiers together\n    let mut stack = CharacterStack()\n        ~~~~^~~~~\n\
    \        mutstack\n/tmp/tmpw2ryq6w0.swift:13:13: note: join the identifiers together\
    \ with camel-case\n    let mut stack = CharacterStack()\n        ~~~~^~~~~\n \
    \       mutStack\n/tmp/tmpw2ryq6w0.swift:15:20: error: single-quoted string literal\
    \ found, use '\"'\n        if char == '(' {\n                   ^~~\n        \
    \           \"(\"\n/tmp/tmpw2ryq6w0.swift:17:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ')' {\n                         \
    \ ^~~\n                          \")\"\n/tmp/tmpw2ryq6w0.swift:13:21: error: cannot\
    \ find 'CharacterStack' in scope\n    let mut stack = CharacterStack()\n     \
    \               ^~~~~~~~~~~~~~\n/tmp/tmpw2ryq6w0.swift:14:26: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in brackets.characters\
    \ {\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw2ryq6w0.swift:16:13: error: cannot find 'stack' in\
    \ scope\n            stack.append(char)\n            ^~~~~\n/tmp/tmpw2ryq6w0.swift:18:16:\
    \ error: cannot find 'stack' in scope\n            if stack.isEmpty() {\n    \
    \           ^~~~~\n/tmp/tmpw2ryq6w0.swift:21:13: error: cannot find 'stack' in\
    \ scope\n            stack.pop()\n            ^~~~~\n/tmp/tmpw2ryq6w0.swift:23:17:\
    \ error: cannot find 'stack' in scope\n            if !stack.isEmpty() {\n   \
    \             ^~~~~\n/tmp/tmpw2ryq6w0.swift:26:13: error: cannot find 'stack'\
    \ in scope\n            stack.append(char)\n            ^~~~~\n/tmp/tmpw2ryq6w0.swift:29:13:\
    \ error: cannot find 'stack' in scope\n    return !stack.isEmpty()\n         \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.components(separatedBy: \"(\")\n    var closingBrackets\
    \ = [String]()\n    for openingBracket in openingBrackets {\n        let closingBracket\
    \ = brackets.components(separatedBy: \")\").first\n        guard let closingBracketString\
    \ = closingBracket, openingBracket == closingBracketString else {\n          \
    \  return false\n        }\n        closingBrackets.append(closingBracketString)\n\
    \    }\n    return openingBrackets.count == closingBrackets.count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0d1rd4mx.swift:13:36: error: value of type 'String' has no member\
    \ 'components'\n    let openingBrackets = brackets.components(separatedBy: \"\
    (\")\n                          ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp0d1rd4mx.swift:16:39:\
    \ error: value of type 'String' has no member 'components'\n        let closingBracket\
    \ = brackets.components(separatedBy: \")\").first\n                          \
    \   ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.count < 2 { return false }\n    var stack = brackets.characters\n\
    \    for _ in 0..<brackets.count - 1 {\n        stack.removeLast()\n    }\n  \
    \  var result = true\n    while !stack.isEmpty {\n        let lastChar = stack.last!\n\
    \        stack.moveFirst()\n        if lastChar == ')' {\n            if !stack.isEmpty\
    \ { stack.removeLast() }\n            else { return false }\n        } else if\
    \ lastChar == '(' {\n            if !stack.isEmpty {\n                stack.removeLast()\n\
    \                if stack.first! != ')' { return false }\n            }\n    \
    \        else {\n                result = false\n                break\n     \
    \       }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpquxb0t66.swift:22:24: error: single-quoted string literal found,\
    \ use '\"'\n        if lastChar == ')' {\n                       ^~~\n       \
    \                \")\"\n/tmp/tmpquxb0t66.swift:25:31: error: single-quoted string\
    \ literal found, use '\"'\n        } else if lastChar == '(' {\n             \
    \                 ^~~\n                              \"(\"\n/tmp/tmpquxb0t66.swift:28:36:\
    \ error: single-quoted string literal found, use '\"'\n                if stack.first!\
    \ != ')' { return false }\n                                   ^~~\n          \
    \                         \")\"\n/tmp/tmpquxb0t66.swift:14:26: error: 'characters'\
    \ is unavailable: Please use String directly\n    var stack = brackets.characters\n\
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpquxb0t66.swift:21:15: error: value of type 'String' has\
    \ no member 'moveFirst'\n        stack.moveFirst()\n        ~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Count open brackets.\n    var open_brackets = 0\n    for _, s := range\
    \ brackets {\n        if s == \"(\" {\n            open_brackets++\n        }\
    \ else {\n            open_brackets--\n        }\n    }\n    if open_brackets\
    \ == 0 {\n        return true\n    }\n    \n    // Check that the brackets are\
    \ balanced.\n    var open_bracket = 0\n    var close_bracket = 0\n    for _, s\
    \ := range brackets {\n        if s == \"(\" {\n            open_bracket++\n \
    \       } else if s == \"(\" {\n            open_bracket--\n        } else if\
    \ s == \")\" {\n            close_bracket++\n        } else if s == \")\" {\n\
    \            close_bracket--\n        }\n    }\n    if open_bracket == close_bracket\
    \ {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxyn50sdg.swift:15:10: error: expected 'in' after for-each pattern\n\
    \    for _, s := range brackets {\n         ^\n/tmp/tmpxyn50sdg.swift:15:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, s := range brackets\
    \ {\n         ^\n/tmp/tmpxyn50sdg.swift:29:10: error: expected 'in' after for-each\
    \ pattern\n    for _, s := range brackets {\n         ^\n/tmp/tmpxyn50sdg.swift:29:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, s := range\
    \ brackets {\n         ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var brackets = brackets\n    let openingBrackets = brackets.characters\n\
    \        .filter { char in openingBrackets.contains(char) }\n        .map(Int.init)\n\
    \n    var closingBrackets = brackets.characters\n        .filter { char in closingBrackets.contains(char)\
    \ }\n        .map(Int.init)\n\n    return openingBrackets.count == closingBrackets.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzlj83jmz.swift:16:10: error: type of expression is ambiguous without\
    \ more context\n        .map(Int.init)\n~~~~~~~~~^~~~~~~~~~~~~\n/tmp/tmpzlj83jmz.swift:20:10:\
    \ error: type of expression is ambiguous without more context\n        .map(Int.init)\n\
    ~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    \n    for i in brackets.unicodeScalars {\n        for j in brackets.unicodeScalars\
    \ {\n            \n            if i != j && i != \")\" && j != \"(\" {\n     \
    \           return false\n            }\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'tmp5t5s2kmo/tmp5t5s2kmo.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f761c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f75eb7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f75eb7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f75eb67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5t5s2kmo                        0x000055854b9093bb <unavailable> + 5051

    5    libc.so.6                          0x00002b5f763ac460 __libc_start_main +
    245

    6    tmp5t5s2kmo                        0x000055854b909049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.lowercased()\n    var openings = 0\n    var closings\
    \ = 0\n    for index, char in enumerate(brackets) {\n        if char == \"(\"\
    \ {\n            openings++\n        } else if char == \")\" {\n            closings++\n\
    \        }\n        if openings == closings {\n            return false\n    \
    \    }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpapjm4bqg.swift:16:14: error: expected 'in' after for-each pattern\n\
    \    for index, char in enumerate(brackets) {\n             ^\n/tmp/tmpapjm4bqg.swift:16:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, char in\
    \ enumerate(brackets) {\n             ^\n/tmp/tmpapjm4bqg.swift:13:5: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n    brackets = brackets.lowercased()\n\
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketCount = 0\n\n    for bracket in brackets {\n        let bracketCount\
    \ = bracketCount.adding(bracket.characters.count)\n    }\n\n    return bracketCount\
    \ == brackets.characters.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4lstscwy.swift:16:41: error: value of type 'Int' has no member\
    \ 'adding'\n        let bracketCount = bracketCount.adding(bracket.characters.count)\n\
    \                           ~~~~~~~~~~~~ ^~~~~~\n/tmp/tmp4lstscwy.swift:16:56:\
    \ error: value of type 'Character' has no member 'characters'\n        let bracketCount\
    \ = bracketCount.adding(bracket.characters.count)\n                          \
    \                     ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp4lstscwy.swift:19:37: error:\
    \ 'characters' is unavailable: Please use String directly\n    return bracketCount\
    \ == brackets.characters.count\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var result = true\n    var opening = brackets[0]\n    var closing = brackets[1]\n\
    \    var openCount = 0\n    var closeCount = 0\n    for i := 1; i < len(brackets);\
    \ i++ {\n        if brackets[i] == opening {\n            openCount++\n      \
    \  } else if brackets[i] == closing {\n            closeCount++\n        } else\
    \ {\n            result = false\n            break\n        }\n    }\n    if openCount\
    \ != closeCount {\n        result = false\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpqp25gezu.swift:18:12: error: expected type\n    for i := 1; i <\
    \ len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpqp25gezu.swift:18:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < len(brackets);\
    \ i++ {\n           ^\n/tmp/tmpqp25gezu.swift:18:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 1; i < len(brackets); i++ {\n   \
    \        ^\n/tmp/tmpqp25gezu.swift:14:19: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n    var opening\
    \ = brackets[0]\n                  ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpqp25gezu.swift:15:19: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    var closing = brackets[1]\n                  ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \  let opening = brackets.unicodeScalars\n  for i in 0..<opening.count {\n   \
    \ if let c = opening[i], let nextC = (i+1 < opening.count) ? opening[i+1] : nil\
    \ {\n      // if next character is opening bracket\n      if c == nextC {\n  \
    \      // if previous character is a closing bracket\n        if let previous\
    \ = (i > 0) ? opening[i-1] : nil {\n          if previous != c {\n           \
    \ return false\n          }\n        } else {\n          return false\n      \
    \  }\n      }\n    }\n  }\n  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7tf60qbg.swift:15:23: error: no exact matches in call to subscript\
    \ \n    if let c = opening[i], let nextC = (i+1 < opening.count) ? opening[i+1]\
    \ : nil {\n                      ^\nSwift.String.UnicodeScalarView:7:23: note:\
    \ candidate expects value of type 'String.UnicodeScalarView.Index' (aka 'String.Index')\
    \ for parameter #1 (got 'Int')\n    @inlinable public subscript(position: String.UnicodeScalarView.Index)\
    \ -> Unicode.Scalar { get }\n                      ^\nSwift.String.UnicodeScalarView:4:12:\
    \ note: candidate expects value of type 'Range<String.UnicodeScalarView.Index>'\
    \ (aka 'Range<String.Index>') for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.UnicodeScalarView.Index>) -> String.UnicodeScalarView.SubSequence\
    \ { get }\n           ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp7tf60qbg.swift:15:71: error: no exact matches\
    \ in call to subscript \n    if let c = opening[i], let nextC = (i+1 < opening.count)\
    \ ? opening[i+1] : nil {\n                                                   \
    \                   ^\nSwift.String.UnicodeScalarView:7:23: note: candidate expects\
    \ value of type 'String.UnicodeScalarView.Index' (aka 'String.Index') for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(position: String.UnicodeScalarView.Index)\
    \ -> Unicode.Scalar { get }\n                      ^\nSwift.String.UnicodeScalarView:4:12:\
    \ note: candidate expects value of type 'Range<String.UnicodeScalarView.Index>'\
    \ (aka 'Range<String.Index>') for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.UnicodeScalarView.Index>) -> String.UnicodeScalarView.SubSequence\
    \ { get }\n           ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp7tf60qbg.swi"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard let openingBracketIndex = brackets.characters.indexOf(\"(\"),\n   \
    \ let closingBracketIndex = brackets.characters.indexOf(\")\") else {\n      \
    \  return false\n    }\n\n    for index in stride(from: openingBracketIndex, through:\
    \ closingBracketIndex, by: 1) {\n        guard let previousChar = brackets.characters.index(before:\
    \ index),\n            let nextChar = brackets.characters.index(before: previousChar\
    \ + 1) else {\n                return false\n        }\n\n        guard let currentChar\
    \ = brackets.characters.index(before: previousChar),\n            let previousCharNextChar\
    \ = brackets.characters.index(before: nextChar) else {\n                return\
    \ false\n        }\n\n        if currentChar != previousCharNextChar {\n     \
    \       return false\n        }\n    }\n\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1khbqxiu.swift:13:57: error: value of type 'String' has no member\
    \ 'indexOf'\n    guard let openingBracketIndex = brackets.characters.indexOf(\"\
    (\"),\n                                    ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp1khbqxiu.swift:14:51:\
    \ error: value of type 'String' has no member 'indexOf'\n    let closingBracketIndex\
    \ = brackets.characters.indexOf(\")\") else {\n                              ~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmp1khbqxiu.swift:20:75: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n            let nextChar = brackets.characters.index(before:\
    \ previousChar + 1) else {\n                                                 \
    \                         ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.lowercased()\n    var balanced = false\n    brackets.split(Character(\"\
    \ \")).forEach {\n        if balanced {\n            return\n        }\n     \
    \   if brackets.range(of: $0).location == NSNotFound {\n            balanced =\
    \ false\n        } else {\n            if brackets.range(of: $0).location == brackets.range(of:\
    \ $1).location {\n                balanced = true\n            }\n        }\n\
    \    }\n    return balanced\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcrg9gkyr.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.lowercased()\n    ^~~~~~~~\n/tmp/tmpcrg9gkyr.swift:19:47:\
    \ error: cannot find 'NSNotFound' in scope\n        if brackets.range(of: $0).location\
    \ == NSNotFound {\n                                              ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let all_brackets = brackets.characters.split{$0 == \")\"}.map(String.init)\
    \ + brackets.characters.split{$0 == \"(\"}.map(String.init)\n    for bracket in\
    \ all_brackets {\n        if bracket != brackets.characters.last {\n         \
    \   return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmprozb_pfb.swift:13:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    let all_brackets = brackets.characters.split{$0 ==\
    \ \")\"}.map(String.init) + brackets.characters.split{$0 == \"(\"}.map(String.init)\n\
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmprozb_pfb.swift:13:89: error: 'characters' is unavailable:\
    \ Please use String directly\n    let all_brackets = brackets.characters.split{$0\
    \ == \")\"}.map(String.init) + brackets.characters.split{$0 == \"(\"}.map(String.init)\n\
    \                                                                            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmprozb_pfb.swift:15:20: error: type '((String.Element) throws -> Bool) throws\
    \ -> String.Element?' (aka '((Character) throws -> Bool) throws -> Optional<Character>')\
    \ cannot conform to 'StringProtocol'\n        if bracket != brackets.characters.last\
    \ {\n                   ^\n/tmp/tmprozb_pfb.swift:15:20: note: only concrete types\
    \ such as structs, enums and classes can conform to protocols\n        if bracket\
    \ != brackets.characters.last {\n                   ^\n/tmp/tmprozb_pfb.swift:15:20:\
    \ note: required by operator function '!=' where 'RHS' = '((String.Element) throws\
    \ -> Bool) throws -> String.Element?' (aka '((Character) throws -> Bool) throws\
    \ -> Optional<Character>')\n        if bracket != brackets.characters.last {\n\
    \                   ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack: [Int]\n\n    var openingBrackets = [String]()\n\n    var closingBrackets\
    \ = [String]()\n\n    for ch in brackets {\n        if ch == '(' {\n         \
    \   stack.append(openingBrackets.count)\n            openingBrackets.append(\"\
    \")\n        } else {\n            if openingBrackets.count > 0 {\n          \
    \      if openingBrackets[openingBrackets.count - 1] == \"\" {\n             \
    \       openingBrackets.remove(openingBrackets.count - 1)\n                } else\
    \ {\n                    openingBrackets[openingBrackets.count - 1] += ch\n  \
    \              }\n            } else {\n                closingBrackets.append(ch)\n\
    \            }\n        }\n    }\n\n    if openingBrackets.count < closingBrackets.count\
    \ {\n        return false\n    } else {\n        for openingBracket in openingBrackets\
    \ {\n            closingBrackets.remove(openingBracket)\n        }\n        return\
    \ openingBrackets == closingBrackets\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmptu7tb72u.swift:20:18: error: single-quoted string literal found,\
    \ use '\"'\n        if ch == '(' {\n                 ^~~\n                 \"\
    (\"\n/tmp/tmptu7tb72u.swift:26:37: error: no exact matches in call to instance\
    \ method 'remove'\n                    openingBrackets.remove(openingBrackets.count\
    \ - 1)\n                                    ^\nSwift.Array:10:37: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(at:)')\n    @inlinable public\
    \ mutating func remove(at index: Int) -> Element\n                           \
    \         ^\nSwift.RangeReplaceableCollection:9:37: note: incorrect labels for\
    \ candidate (have: '(_:)', expected: '(at:)')\n    @inlinable public mutating\
    \ func remove(at position: Self.Index) -> Self.Element\n                     \
    \               ^\n/tmp/tmptu7tb72u.swift:28:67: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n                    openingBrackets[openingBrackets.count\
    \ - 1] += ch\n                                                               \
    \   ^\n/tmp/tmptu7tb72u.swift:31:40: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                closingBrackets.append(ch)\n\
    \                                       ^\n/tmp/tmptu7tb72u.swift:40:29: error:\
    \ no exact matches in call to instance method 'remove'\n            closingBrackets.remove(openingBracket)\n\
    \                            ^\n/tmp/tmptu7tb72u.swift:40:29: note: candidate\
    \ expects value of type 'Int' for parameter #1 (got 'String')\n            closingBrackets.remove(openingBracket)\n\
    \                            ^\n/tmp/tmptu7tb72u.swift:40:29: note: candidate\
    \ expects value of type 'Array<String>.Index' (aka 'Int') for parameter #1 (got\
    \ 'String')\n            closingBrackets.remove(openingBracket)\n            \
    \                ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var foundOpeningBrackets = false\n    var foundClosingBrackets = false\n\n\
    \    brackets.forEach { c in\n        if c == '(' {\n            foundOpeningBrackets\
    \ = true\n        } else if c == ')' {\n            foundClosingBrackets = true\n\
    \        } else if foundOpeningBrackets {\n            foundOpeningBrackets =\
    \ false\n        }\n    }\n\n    return foundClosingBrackets\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmgq453ss.swift:17:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpmgq453ss.swift:19:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == ')' {\n                       ^~~\n                \
    \       \")\"\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \  var found = false\n  brackets.range(of: \"(\", options: .backwards)?.forEach\
    \ { open in\n    brackets.range(of: open, options: .backwards)?.forEach { close\
    \ in\n      if found {\n        return\n      }\n      if brackets.range(of: close,\
    \ options: .backwards)?.count > 0 {\n        found = true\n      }\n    }\n  }\n\
    \  return found\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjhvrhwtz.swift:14:12: error: value of type 'String' has no member\
    \ 'range'\n  brackets.range(of: \"(\", options: .backwards)?.forEach { open in\n\
    \  ~~~~~~~~ ^~~~~\n/tmp/tmpjhvrhwtz.swift:14:37: error: cannot infer contextual\
    \ base in reference to member 'backwards'\n  brackets.range(of: \"(\", options:\
    \ .backwards)?.forEach { open in\n                                   ~^~~~~~~~~\n\
    /tmp/tmpjhvrhwtz.swift:15:14: error: value of type 'String' has no member 'range'\n\
    \    brackets.range(of: open, options: .backwards)?.forEach { close in\n    ~~~~~~~~\
    \ ^~~~~\n/tmp/tmpjhvrhwtz.swift:15:40: error: cannot infer contextual base in\
    \ reference to member 'backwards'\n    brackets.range(of: open, options: .backwards)?.forEach\
    \ { close in\n                                      ~^~~~~~~~~\n/tmp/tmpjhvrhwtz.swift:19:19:\
    \ error: value of type 'String' has no member 'range'\n      if brackets.range(of:\
    \ close, options: .backwards)?.count > 0 {\n         ~~~~~~~~ ^~~~~\n/tmp/tmpjhvrhwtz.swift:19:46:\
    \ error: cannot infer contextual base in reference to member 'backwards'\n   \
    \   if brackets.range(of: close, options: .backwards)?.count > 0 {\n         \
    \                                   ~^~~~~~~~~\n/tmp/tmpjhvrhwtz.swift:19:58:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \      if brackets.range(of: close, options: .backwards)?.count > 0 {\n      \
    \                                                   ^\n/tmp/tmpjhvrhwtz.swift:19:58:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n      if brackets.range(of: close, options: .backwards)?.count > 0 {\n\
    \                                                         ^\n                \
    \                                               ?? <#default value#>\n/tmp/tmpjhvrhwtz.swift:19:58:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n      if brackets.range(of: close, options: .backwards)?.count > 0 {\n\
    \                                                         ^\n         (      \
    \                                              )!\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    for openBracket in brackets.characters {\n        switch openBracket {\n\
    \        case \")\":\n            // A closing bracket is required before an opening\
    \ bracket.\n            return false\n        case \"(\":\n            // No closing\
    \ brackets are required.\n        default:\n            // Both opening and closing\
    \ brackets are required.\n            return true\n        }\n    }\n\n    //\
    \ If no brackets are found, then the string isn't correctly formatted.\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpx_h0l3yc.swift:18:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"(\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmpx_h0l3yc.swift:13:33: error: 'characters' is\
    \ unavailable: Please use String directly\n    for openBracket in brackets.characters\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var lastOpeningBracket: Int = 0\n    var openingBrackets: Set<Character>\
    \ = Set()\n    for character in brackets.characters {\n        switch character\
    \ {\n        case \"{\", \"}\", \"(\", \")\":\n            openingBrackets.insert(character)\n\
    \        default:\n            if lastOpeningBracket == 0 {\n                return\
    \ false\n            }\n            if openingBrackets.contains(Character(\"(\"\
    \ + String(character) + \")\")) {\n                openingBrackets.remove(Character(\"\
    (\" + String(character) + \")\"))\n            } else if openingBrackets.contains(Character(\"\
    (\" + String(character))){\n                openingBrackets.remove(Character(\"\
    (\" + String(character)))\n            }\n            lastOpeningBracket = character\n\
    \        }\n    }\n\n    if lastOpeningBracket != 0 {\n        return false\n\
    \    }\n\n    for openingBracket in openingBrackets {\n        return false\n\
    \    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpuvvtu8l8.swift:15:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in brackets.characters {\n          \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpuvvtu8l8.swift:28:34: error: cannot assign value of type 'Character'\
    \ to type 'Int'\n            lastOpeningBracket = character\n                \
    \                 ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketMap = [Character : Character]()\n    brackets.forEach { char in\n\
    \        if char == ')' {\n            bracketMap[Character(\")\")] = Character(\"\
    (\")\n        } else {\n            bracketMap[Character(\"(\")] = Character(\"\
    )\")\n        }\n    }\n    let result = bracketMap.forAll({ char in bracketMap.keySet()\
    \ where bracketMap[char] == char })\n    return !result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpd6756zar.swift:15:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == ')' {\n                   ^~~\n               \
    \    \")\"\n/tmp/tmpd6756zar.swift:21:65: error: consecutive statements on a line\
    \ must be separated by ';'\n    let result = bracketMap.forAll({ char in bracketMap.keySet()\
    \ where bracketMap[char] == char })\n                                        \
    \                        ^\n                                                 \
    \               ;\n/tmp/tmpd6756zar.swift:21:66: error: expected expression\n\
    \    let result = bracketMap.forAll({ char in bracketMap.keySet() where bracketMap[char]\
    \ == char })\n                                                               \
    \  ^\n/tmp/tmpd6756zar.swift:21:29: error: value of type '[Character : Character]'\
    \ has no member 'forAll'\n    let result = bracketMap.forAll({ char in bracketMap.keySet()\
    \ where bracketMap[char] == char })\n                 ~~~~~~~~~~ ^~~~~~\n/tmp/tmpd6756zar.swift:21:57:\
    \ error: value of type '[Character : Character]' has no member 'keySet'\n    let\
    \ result = bracketMap.forAll({ char in bracketMap.keySet() where bracketMap[char]\
    \ == char })\n                                             ~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    return brackets.characters.reduce(true, {\n        (accumulator, currentCharacter)\
    \ in\n        guard currentCharacter == \"(\" || currentCharacter == \")\" else\
    \ { return accumulator }\n        return accumulator\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_2p6sgac.swift:13:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    return brackets.characters.reduce(true, {\n       \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.hasPrefix(\"(\") || brackets.hasSuffix(\")\") {\n        return\
    \ false\n    }\n    if brackets.contains(\"(\") && brackets.contains(\")\") {\n\
    \        return true\n    }\n    if brackets.contains(\"(\") {\n        if brackets.contains(\"\
    )\") {\n            return true\n        }\n    }\n    if brackets.contains(\"\
    )\") {\n        if brackets.contains(\"(\") {\n            return true\n     \
    \   }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'tmp8bryk5yx/tmp8bryk5yx.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cb49b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cb46b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cb46b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cb46af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8bryk5yx                        0x00005569cf30a4bb <unavailable> + 5307

    5    libc.so.6                          0x00002b6cb4ba5460 __libc_start_main +
    245

    6    tmp8bryk5yx                        0x00005569cf30a149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return false\n    }\n    var lastOpeningBracketIndex\
    \ = -1\n    var lastClosingBracketIndex = -1\n    for index in 0..<brackets.characters.count\
    \ {\n        switch brackets.characters.characters[index] {\n        case \",\"\
    , \":\", \"(\", \")\":\n            if index == 0 {\n                return false\n\
    \            }\n            if brackets.characters.characters[index] == lastOpeningBracketIndex\
    \ {\n                lastClosingBracketIndex = -1\n            } else {\n    \
    \            lastClosingBracketIndex = index\n            }\n        case \".\"\
    :\n            if index == 0 {\n                return false\n            }\n\
    \            if brackets.characters.characters[index] == lastOpeningBracketIndex\
    \ {\n                lastOpeningBracketIndex = -1\n            } else {\n    \
    \            lastOpeningBracketIndex = index\n            }\n        default:\n\
    \            lastOpeningBracketIndex = index\n        }\n    }\n    return lastOpeningBracketIndex\
    \ == lastClosingBracketIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpukphkxsf.swift:18:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<brackets.characters.count {\n    \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpukphkxsf.swift:19:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        switch\
    \ brackets.characters.characters[index] {\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpukphkxsf.swift:19:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        switch\
    \ brackets.characters.characters[index] {\n                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpukphkxsf.swift:19:36:\
    \ error: 'characters' is unavailable: Please use String directly\n        switch\
    \ brackets.characters.characters[index] {\n                                  \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpukphkxsf.swift:24:54:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'Int'\n            if brackets.characters.characters[index] == lastOpeningBracketIndex\
    \ {\n               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpukphkxsf.swift:24:54: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (Int, Int)\n            if\
    \ brackets.characters.characters[index] == lastOpeningBracketIndex {\n       \
    \                                              ^\n/tmp/tmpukphkxsf.swift:33:54:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'Int'\n            if brackets.characters.c"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets: Set<String> = brackets.characters.map { String($0) }.flatMap\
    \ { openingBrackets(String($0)) }\n    let closingBrackets: Set<String> = brackets.characters.map\
    \ { String($0) }.flatMap { closingBrackets(String($0)) }\n    return openingBrackets.count\
    \ == closingBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpurb1i38e.swift:13:79: error: cannot convert value of type '[String]'\
    \ to specified type 'Set<String>'\n    let openingBrackets: Set<String> = brackets.characters.map\
    \ { String($0) }.flatMap { openingBrackets(String($0)) }\n                   \
    \                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpurb1i38e.swift:13:89: error: cannot call value of non-function type 'Set<String>'\n\
    \    let openingBrackets: Set<String> = brackets.characters.map { String($0) }.flatMap\
    \ { openingBrackets(String($0)) }\n                                          \
    \                                              ^\n/tmp/tmpurb1i38e.swift:14:79:\
    \ error: cannot convert value of type '[String]' to specified type 'Set<String>'\n\
    \    let closingBrackets: Set<String> = brackets.characters.map { String($0) }.flatMap\
    \ { closingBrackets(String($0)) }\n                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpurb1i38e.swift:14:89: error: cannot call value of non-function type 'Set<String>'\n\
    \    let closingBrackets: Set<String> = brackets.characters.map { String($0) }.flatMap\
    \ { closingBrackets(String($0)) }\n                                          \
    \                                              ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = brackets.characters\n        .enumerate()\n        .map { Index($0.offset,\
    \ $0.element) }\n        .filter { $0.element != brackets.characters.endIndex\
    \ }\n        .map { Index($0.offset, $0.element) }\n        .reverse()\n    for\
    \ i in stack {\n        let next = stack.removeLast()\n        if let left = brackets.characters[i.offset\
    \ + 1], let right = brackets.characters[next.offset + 1] {\n            if left\
    \ != right {\n                return false\n            }\n        }\n    }\n\
    \    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpt97w2mli.swift:15:16: error: cannot find 'Index' in scope\n   \
    \     .map { Index($0.offset, $0.element) }\n               ^~~~~\n/tmp/tmpt97w2mli.swift:17:16:\
    \ error: cannot find 'Index' in scope\n        .map { Index($0.offset, $0.element)\
    \ }\n               ^~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBrackets = [String]()\n    var closingBrackets = [String]()\n\
    \    for bt in brackets.characters {\n        if bt == ')' {\n            closingBrackets.append(String(bt))\n\
    \        } else if bt == '(' {\n            openingBrackets.append(String(bt))\n\
    \        } else {\n            return false\n        }\n    }\n    return openingBrackets.count\
    \ >= closingBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7pt68wv6.swift:16:18: error: single-quoted string literal found,\
    \ use '\"'\n        if bt == ')' {\n                 ^~~\n                 \"\
    )\"\n/tmp/tmp7pt68wv6.swift:18:25: error: single-quoted string literal found,\
    \ use '\"'\n        } else if bt == '(' {\n                        ^~~\n     \
    \                   \"(\"\n/tmp/tmp7pt68wv6.swift:15:24: error: 'characters' is\
    \ unavailable: Please use String directly\n    for bt in brackets.characters {\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.lowercased()\n    var opening: [Character] = []\n   \
    \ var closing: [Character] = []\n    for char in brackets {\n        switch char\
    \ {\n        case '(':\n            opening.append(char)\n        case '[':\n\
    \            opening.append(char)\n        case '{':\n            opening.append(char)\n\
    \        case '(':\n            closing.append(char)\n        case ')':\n    \
    \        closing.append(char)\n        default:\n            closing.append(char)\n\
    \        }\n    }\n    return !opening.isEmpty && !closing.isEmpty\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5tziuucl.swift:18:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '(':\n             ^~~\n             \"(\"\n/tmp/tmp5tziuucl.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case '[':\n   \
    \          ^~~\n             \"[\"\n/tmp/tmp5tziuucl.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case '{':\n             ^~~\n      \
    \       \"{\"\n/tmp/tmp5tziuucl.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case '(':\n             ^~~\n             \"(\"\n/tmp/tmp5tziuucl.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ')':\n   \
    \          ^~~\n             \")\"\n/tmp/tmp5tziuucl.swift:13:5: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n    brackets = brackets.lowercased()\n\
    \    ^~~~~~~~\n/tmp/tmp5tziuucl.swift:24:14: warning: literal value is already\
    \ handled by previous pattern; consider removing it\n        case '(':\n     \
    \        ^~~\n/tmp/tmp5tziuucl.swift:18:14: note: first occurrence of identical\
    \ literal pattern is here\n        case '(':\n             ^~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBracketsCount = brackets.count\n    let closingBracketsCount =\
    \ brackets.characters.map { $0 == \"(\" ? 1 : 0 }.reduce(0, +)\n    return openingBracketsCount\
    \ != closingBracketsCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpk3_162l2.swift:14:41: error: 'characters' is unavailable: Please\
    \ use String directly\n    let closingBracketsCount = brackets.characters.map\
    \ { $0 == \"(\" ? 1 : 0 }.reduce(0, +)\n                                     \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let lastOpeningBracketIndex = brackets.rangeOfString(\"(\", options: .BackwardsSearch)?.lowerBound\n\
    \    return brackets.rangeOfString(brackets[lastOpeningBracketIndex!], options:\
    \ .BackwardsSearch) == nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3dftc4_w.swift:13:91: error: type of expression is ambiguous without\
    \ more context\n    let lastOpeningBracketIndex = brackets.rangeOfString(\"(\"\
    , options: .BackwardsSearch)?.lowerBound\n                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmp3dftc4_w.swift:14:21: error: value of type 'String' has no member 'rangeOfString'\n\
    \    return brackets.rangeOfString(brackets[lastOpeningBracketIndex!], options:\
    \ .BackwardsSearch) == nil\n           ~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp3dftc4_w.swift:14:81:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \    return brackets.rangeOfString(brackets[lastOpeningBracketIndex!], options:\
    \ .BackwardsSearch) == nil\n                                                 \
    \                              ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBracketCounts = brackets.components(separatedBy: \"(\").map({\
    \ $0.characters.count })\n    let closingBracketCounts = brackets.components(separatedBy:\
    \ \")\").map({ $0.characters.count })\n    for openingBracketCount in openingBracketCounts\
    \ {\n        guard closingBracketCounts.contains(openingBracketCount) else {\n\
    \            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpiqeez3_0.swift:13:41: error: value of type 'String' has no member\
    \ 'components'\n    let openingBracketCounts = brackets.components(separatedBy:\
    \ \"(\").map({ $0.characters.count })\n                               ~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpiqeez3_0.swift:14:41: error: value of type 'String' has\
    \ no member 'components'\n    let closingBracketCounts = brackets.components(separatedBy:\
    \ \")\").map({ $0.characters.count })\n                               ~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBrackets = brackets.characters.filter { $0 != '(' }\n    var closingBrackets\
    \ = brackets.characters.filter { $0 != ')' }\n    if openingBrackets.count !=\
    \ closingBrackets.count {\n        return false\n    }\n    for openingBracket\
    \ in openingBrackets {\n        let openingBracketsIndex = brackets.index(of:\
    \ openingBracket)\n        let closingBracketsIndex = brackets.index(of: closingBracket)\n\
    \        if openingBracketsIndex == closingBracketsIndex {\n            openingBrackets.removeAll()\n\
    \            closingBrackets.removeAll()\n        } else {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpev6l3n5h.swift:13:62: error: single-quoted string literal found,\
    \ use '\"'\n    var openingBrackets = brackets.characters.filter { $0 != '(' }\n\
    \                                                             ^~~\n          \
    \                                                   \"(\"\n/tmp/tmpev6l3n5h.swift:14:62:\
    \ error: single-quoted string literal found, use '\"'\n    var closingBrackets\
    \ = brackets.characters.filter { $0 != ')' }\n                               \
    \                              ^~~\n                                         \
    \                    \")\"\n/tmp/tmpev6l3n5h.swift:13:36: error: 'characters'\
    \ is unavailable: Please use String directly\n    var openingBrackets = brackets.characters.filter\
    \ { $0 != '(' }\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpev6l3n5h.swift:14:36: error: 'characters'\
    \ is unavailable: Please use String directly\n    var closingBrackets = brackets.characters.filter\
    \ { $0 != ')' }\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpev6l3n5h.swift:19:45: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n        let openingBracketsIndex\
    \ = brackets.index(of: openingBracket)\n                                     \
    \       ^\n/tmp/tmpev6l3n5h.swift:19:45: note: use 'firstIndex(of:)' instead\n\
    \        let openingBracketsIndex = brackets.index(of: openingBracket)\n     \
    \                                       ^~~~~\n                              \
    \              firstIndex\n/tmp/tmpev6l3n5h.swift:20:55: error: cannot find 'closingBracket'\
    \ in scope\n        let closingBracketsIndex = brackets.index(of: closingBracket)\n\
    \                                                      ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Check brackets are of correct format\n    let bracketFormat = brackets.characters.split(\"\
    (\").map(String.init).map(String.init)\n    if bracketFormat.count != brackets.characters.count{\n\
    \        return false\n    }\n\n    // Check no parentheses are balanced (i.e.\
    \ \"(())\" is not allowed)\n    let openingBrackets = bracketFormat.filter({ $0\
    \ == \")\" })\n    let closingBrackets = bracketFormat.filter({ $0 == \"(\" })\n\
    \n    if openingBrackets.count != closingBrackets.count{\n        return false\n\
    \    }\n\n    // Check \"()\" isn't inside another \"()\"\n    let openingParenthesesWithClosingParentheses\
    \ = openingBrackets.flatMap({\n        (openingBracket) -> [String] in \n    \
    \    let closingBracket = closingBrackets.filter{$0 == openingBracket}\n     \
    \   closingBracket.count == 0 ? [openingBracket] : []\n    })\n\n    if openingParenthesesWithClosingParentheses.count\
    \ == 0{\n        return false\n    }\n\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpypjh221v.swift:14:45: error: no exact matches in call to instance\
    \ method 'split'\n    let bracketFormat = brackets.characters.split(\"(\").map(String.init).map(String.init)\n\
    \                                            ^\nSwift.Sequence:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n    \
    \                                   ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening = brackets.characters\n    for c in brackets.characters {\n \
    \       if opening.contains(c) {\n            opening.remove(c)\n        } else\
    \ if c == \")\" {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbyqvwnst.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    var opening = brackets.characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpbyqvwnst.swift:14:23: error: 'characters' is unavailable: Please use String\
    \ directly\n    for c in brackets.characters {\n                      ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbyqvwnst.swift:16:21:\
    \ error: no exact matches in call to instance method 'remove'\n            opening.remove(c)\n\
    \                    ^\n/tmp/tmpbyqvwnst.swift:16:21: note: candidate expects\
    \ value of type 'String.Index' for parameter #1 (got 'Character')\n          \
    \  opening.remove(c)\n                    ^\n/tmp/tmpbyqvwnst.swift:16:21: note:\
    \ candidate expects value of type 'String.Index' for parameter #1 (got 'Character')\n\
    \            opening.remove(c)\n                    ^\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let open_brackets = brackets.components(separatedBy: \"(\")\n    var all_closed\
    \ = true\n    for (index, open) in open_brackets.enumerate() {\n        if open\
    \ == \"\" {\n            all_closed = false\n            break\n        }\n  \
    \      let closed = brackets.substring(from: index + 1).components(separatedBy:\
    \ \")\")\n        if closed.contains(open) {\n            all_closed = false\n\
    \            break\n        }\n    }\n    return all_closed\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmphl82n537.swift:13:34: error: value of type 'String' has no member\
    \ 'components'\n    let open_brackets = brackets.components(separatedBy: \"(\"\
    )\n                        ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmphl82n537.swift:20:31:\
    \ error: value of type 'String' has no member 'substring'\n        let closed\
    \ = brackets.substring(from: index + 1).components(separatedBy: \")\")\n     \
    \                ~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    for openingBracket in brackets {\n        let closeBracket = brackets.substring(to:\
    \ openingBracket.endIndex)\n        if openingBracket != closeBracket {\n    \
    \        return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjicvy4tk.swift:14:37: error: value of type 'String' has no member\
    \ 'substring'\n        let closeBracket = brackets.substring(to: openingBracket.endIndex)\n\
    \                           ~~~~~~~~ ^~~~~~~~~\n/tmp/tmpjicvy4tk.swift:14:66:\
    \ error: value of type 'Character' has no member 'endIndex'\n        let closeBracket\
    \ = brackets.substring(to: openingBracket.endIndex)\n                        \
    \                          ~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.bracketCharacterSet())\n\
    \    var opened = 0\n    var closed = 0\n    for char in brackets.utf16 {\n  \
    \      switch char {\n        case ')':\n            if opened == 0 {\n      \
    \          return false\n            }\n            closed++\n        case ')':\n\
    \            opened--\n        default:\n            opened++\n        }\n   \
    \ }\n    return opened == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpz4jymx_z.swift:18:14: error: single-quoted string literal found,\
    \ use '\"'\n        case ')':\n             ^~~\n             \")\"\n/tmp/tmpz4jymx_z.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ')':\n   \
    \          ^~~\n             \")\"\n/tmp/tmpz4jymx_z.swift:13:57: error: cannot\
    \ find 'NSCharacterSet' in scope\n    brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.bracketCharacterSet())\n\
    \                                                        ^~~~~~~~~~~~~~\n/tmp/tmpz4jymx_z.swift:13:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.bracketCharacterSet())\n\
    \    ^~~~~~~~\n/tmp/tmpz4jymx_z.swift:13:25: error: value of type 'String' has\
    \ no member 'stringByTrimmingCharactersInSet'\n    brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.bracketCharacterSet())\n\
    \               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpz4jymx_z.swift:18:14:\
    \ error: expression pattern of type 'String' cannot match values of type 'UInt16'\n\
    \        case ')':\n             ^~~\n/tmp/tmpz4jymx_z.swift:23:14: error: expression\
    \ pattern of type 'String' cannot match values of type 'UInt16'\n        case\
    \ ')':\n             ^~~\n/tmp/tmpz4jymx_z.swift:22:19: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            closed++\n                \
    \  ^~\n/tmp/tmpz4jymx_z.swift:24:19: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n            opened--\n                  ^~\n/tmp/tmpz4jymx_z.swift:26:19:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  opened++\n                  ^~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.stringByReplacingOccurrencesOfString(\"((\", withString: \"\
    (\", options: NSStringCompareOptions.CaseInsensitiveSearch)\n\tbrackets = brackets.stringByReplacingOccurrencesOfString(\"\
    ))\", withString: \")\", options: NSStringCompareOptions.CaseInsensitiveSearch)\n\
    \treturn brackets == brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpo77q_3di.swift:13:91: error: cannot find 'NSStringCompareOptions'\
    \ in scope\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    ((\", withString: \"(\", options: NSStringCompareOptions.CaseInsensitiveSearch)\n\
    \                                                                            \
    \                     ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo77q_3di.swift:13:2: error:\
    \ cannot assign to value: 'brackets' is a 'let' constant\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    ((\", withString: \"(\", options: NSStringCompareOptions.CaseInsensitiveSearch)\n\
    \        ^~~~~~~~\n/tmp/tmpo77q_3di.swift:13:22: error: value of type 'String'\
    \ has no member 'stringByReplacingOccurrencesOfString'\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    ((\", withString: \"(\", options: NSStringCompareOptions.CaseInsensitiveSearch)\n\
    \                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo77q_3di.swift:14:91:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    ))\", withString: \")\", options: NSStringCompareOptions.CaseInsensitiveSearch)\n\
    \                                                                            \
    \                     ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo77q_3di.swift:14:2: error:\
    \ cannot assign to value: 'brackets' is a 'let' constant\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    ))\", withString: \")\", options: NSStringCompareOptions.CaseInsensitiveSearch)\n\
    \        ^~~~~~~~\n/tmp/tmpo77q_3di.swift:14:22: error: value of type 'String'\
    \ has no member 'stringByReplacingOccurrencesOfString'\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    ))\", withString: \")\", options: NSStringCompareOptions.CaseInsensitiveSearch)\n\
    \                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Create stack of opening brackets.\n    var opening_stack = [Character]()\n\
    \    var closed_stack = [Character]()\n\n    // Iterate over brackets.\n    for\
    \ character in brackets {\n        if character == \"(\" {\n            // Push\
    \ opening bracket.\n            opening_stack.append(character)\n\n          \
    \  // Remove closing bracket from stack.\n            closed_stack.remove(at:\
    \ closed_stack.count - 1)\n        } else {\n            // Push closing bracket.\n\
    \            closed_stack.append(character)\n\n            // If opening a new\
    \ bracket, pop the stack.\n            if opening_stack.count == 0 {\n       \
    \         opening_stack.remove(at: 0)\n            } else {\n                //\
    \ Pop opening bracket from stack.\n                opening_stack.remove(at: opening_stack.count\
    \ - 1)\n            }\n        }\n    }\n\n    // If there is still an open bracket\
    \ at the end of both stacks, they\n    // are not correctly closed.\n    return\
    \ opening_stack.count == closed_stack.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'Swift/Array.swift:1332: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acfa62ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acfa5fd4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acfa5fd4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acfa5fd413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acfa5fd3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002acfa5fc1018 <unavailable> + 1355800

    6    tmpjaye2jjk                        0x00005569d0895fb3 <unavailable> + 8115

    7    tmpjaye2jjk                        0x00005569d0895546 <unavailable> + 5446

    8    libc.so.6                          0x00002acfa64c9460 __libc_start_main +
    245

    9    tmpjaye2jjk                        0x00005569d0895249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659979960
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    switch brackets {\n\tcase \"()\", \"()()\", \"(())\", \"(()())\", \"()()()\",\
    \ \"((()))\":\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'tmp_96ih3al/tmp_96ih3al.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3180087c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b317fd7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b317fd7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b317fd7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_96ih3al                        0x000055c1a58793f7 <unavailable> + 5111

    5    libc.so.6                          0x00002b3180273460 __libc_start_main +
    245

    6    tmp_96ih3al                        0x000055c1a5878f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening_brackets = brackets.characters\n        .filter({ $0 == \" \"\
    \ })\n        .filter({ $0 != \")\" })\n        .filter({ $0 != \"(\" })\n   \
    \     .filter({ $0 != \"{\" })\n        .filter({ $0 != \"}\" })\n\n    let closing_brackets\
    \ = brackets.characters\n        .filter({ $0 == \"(\" })\n        .filter({ $0\
    \ != \" \" })\n        .filter({ $0 != \")\" })\n        .filter({ $0 != \"{\"\
    \ })\n        .filter({ $0 != \"}\" })\n\n    let open_brackets = opening_brackets.count\
    \ != closing_brackets.count\n    let close_brackets = opening_brackets.count !=\
    \ open_brackets.count\n    let has_close_brackets = opening_brackets.count !=\
    \ 0\n    let has_open_brackets = opening_brackets.count != 0\n    return open_brackets\
    \ && close_brackets && has_close_brackets && has_open_brackets\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1eluxy_m.swift:13:37: error: ambiguous use of 'filter'\n    let\
    \ opening_brackets = brackets.characters\n                                   \
    \ ^\nSwift.RangeReplaceableCollection:3:40: note: found this candidate\n    @inlinable\
    \ public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool)\
    \ rethrows -> Self\n                                       ^\nSwift.Sequence:3:40:\
    \ note: found this candidate\n    @inlinable public __consuming func filter(_\
    \ isIncluded: (Self.Element) throws -> Bool) rethrows -> [Self.Element]\n    \
    \                                   ^\n/tmp/tmp1eluxy_m.swift:20:37: error: ambiguous\
    \ use of 'filter'\n    let closing_brackets = brackets.characters\n          \
    \                          ^\nSwift.RangeReplaceableCollection:3:40: note: found\
    \ this candidate\n    @inlinable public __consuming func filter(_ isIncluded:\
    \ (Self.Element) throws -> Bool) rethrows -> Self\n                          \
    \             ^\nSwift.Sequence:3:40: note: found this candidate\n    @inlinable\
    \ public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool)\
    \ rethrows -> [Self.Element]\n                                       ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    if brackets == \"\" {\n\t\treturn true\n\t}\n\tbrackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.openingBracketCharacterSet())\n\
    \tbrackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.closingBracketCharacterSet())\n\
    \tif brackets.rangeOfString(\"()\") != nil {\n\t\treturn true\n\t}\n\treturn false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0exuo6r1.swift:16:54: error: cannot find 'NSCharacterSet' in scope\n\
    \        brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.openingBracketCharacterSet())\n\
    \                                                            ^~~~~~~~~~~~~~\n\
    /tmp/tmp0exuo6r1.swift:16:2: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n        brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.openingBracketCharacterSet())\n\
    \        ^~~~~~~~\n/tmp/tmp0exuo6r1.swift:16:22: error: value of type 'String'\
    \ has no member 'stringByTrimmingCharactersInSet'\n        brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.openingBracketCharacterSet())\n\
    \                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0exuo6r1.swift:17:54:\
    \ error: cannot find 'NSCharacterSet' in scope\n        brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.closingBracketCharacterSet())\n\
    \                                                            ^~~~~~~~~~~~~~\n\
    /tmp/tmp0exuo6r1.swift:17:2: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n        brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.closingBracketCharacterSet())\n\
    \        ^~~~~~~~\n/tmp/tmp0exuo6r1.swift:17:22: error: value of type 'String'\
    \ has no member 'stringByTrimmingCharactersInSet'\n        brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.closingBracketCharacterSet())\n\
    \                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0exuo6r1.swift:18:14:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        if brackets.rangeOfString(\"\
    ()\") != nil {\n           ~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets[0..<brackets.count]\n\tbrackets = brackets.reverse()\n\tbrackets\
    \ = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpptzq1qg_.swift:77:1: error: expected expression in assignment\n\
    }\n^\n/tmp/tmpptzq1qg_.swift:13:2: error: cannot assign to value: 'brackets' is\
    \ a 'let' constant\n        brackets = brackets[0..<brackets.count]\n        ^~~~~~~~\n\
    /tmp/tmpptzq1qg_.swift:14:2: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n        brackets = brackets.reverse()\n        ^~~~~~~~\n/tmp/tmpptzq1qg_.swift:14:22:\
    \ error: value of type 'String' has no member 'reverse'\n        brackets = brackets.reverse()\n\
    \                   ~~~~~~~~ ^~~~~~~\n/tmp/tmpptzq1qg_.swift:15:2: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n        brackets = brackets.reverse()\n\
    \        ^~~~~~~~\n/tmp/tmpptzq1qg_.swift:15:22: error: value of type 'String'\
    \ has no member 'reverse'\n        brackets = brackets.reverse()\n           \
    \        ~~~~~~~~ ^~~~~~~\n/tmp/tmpptzq1qg_.swift:16:2: error: cannot assign to\
    \ value: 'brackets' is a 'let' constant\n        brackets = brackets.reverse()\n\
    \        ^~~~~~~~\n/tmp/tmpptzq1qg_.swift:16:22: error: value of type 'String'\
    \ has no member 'reverse'\n        brackets = brackets.reverse()\n           \
    \        ~~~~~~~~ ^~~~~~~\n/tmp/tmpptzq1qg_.swift:17:2: error: cannot assign to\
    \ value: 'brackets' is a 'let' constant\n        brackets = brackets.reverse()\n\
    \        ^~~~~~~~\n/tmp/tmpptzq1qg_.swift:17:22: error: value of type 'String'\
    \ has no member 'reverse'\n        brackets = brackets.reverse()\n           \
    \        ~~~~~~~~ ^~~~~~~\n/tmp/tmpptzq1qg_.swift:18:2: error: cannot assign to\
    \ value: 'brackets' is a 'let' constant\n        brackets = brackets.reverse()\n\
    \        ^~~~~~~~\n/tmp/tmpptzq1qg_.swift:18:22: error: value of type 'String'\
    \ has no member 'reverse'\n        brackets = brackets.reverse()\n           \
    \        ~~~~~~~~ ^~~~~~~\n/tmp/tmpptzq1qg_.swift:19:2: error: cannot assign to\
    \ value: 'brackets' is a 'let' constant\n        brackets = brackets.reverse()\n\
    \        ^~~~~~~~\n/tmp/tmpptzq1qg_.swift:19:22: error: value of type 'String'\
    \ has no member 'reverse'\n        brackets = brackets.reverse()\n           \
    \        ~~~~~~~~ ^~"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.count == 0 {\n        return true\n    }\n    var stack = [String]()\n\
    \    for idx, chr := range brackets {\n        if chr == \")\" {\n           \
    \ if stack[len(stack)-1] == \"(\" {\n                stack.pop()\n           \
    \ } else {\n                return false\n            }\n        } else if chr\
    \ == \"(\" {\n            stack.append(chr)\n        } else if chr == \")(\" {\n\
    \            stack.pop()\n            stack.append(chr)\n        } else {\n  \
    \          return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdmxxsatj.swift:17:12: error: expected 'in' after for-each pattern\n\
    \    for idx, chr := range brackets {\n           ^\n/tmp/tmpdmxxsatj.swift:17:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, chr := range\
    \ brackets {\n           ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.stringByReplacingOccurrencesOfString(\" \", withString:\
    \ \"\\\\s+\", options: .LiteralSearch, range: nil)\n\n    var openBracket = String()\n\
    \    var closeBracket = String()\n    for b in brackets.characters.reverse() {\n\
    \        let b = String(b).unicodeScalars\n        let bc = String(bc)\n     \
    \   if bc == \")\" {\n            if openBracket != \"\" {\n                return\
    \ false\n            }\n            openBracket = String()\n        } else {\n\
    \            if bc == \"(\" {\n                if closeBracket != \"\" {\n   \
    \                 return false\n                }\n                closeBracket\
    \ = String()\n            }\n            openBracket += String(b).description\n\
    \        }\n    }\n\n    if openBracket != \"\" && closeBracket != \"\" {\n  \
    \      return openBracket == closeBracket\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbxzoq0nf.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"\\\\s+\", options: .LiteralSearch, range: nil)\n    ^~~~~~~~\n\
    /tmp/tmpbxzoq0nf.swift:13:25: error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    brackets = brackets.stringByReplacingOccurrencesOfString(\" \", withString:\
    \ \"\\\\s+\", options: .LiteralSearch, range: nil)\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbxzoq0nf.swift:13:97: error: cannot infer contextual base in reference\
    \ to member 'LiteralSearch'\n    brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"\\\\s+\", options: .LiteralSearch, range: nil)\n         \
    \                                                                            \
    \          ~^~~~~~~~~~~~~\n/tmp/tmpbxzoq0nf.swift:13:119: error: 'nil' requires\
    \ a contextual type\n    brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"\\\\s+\", options: .LiteralSearch, range: nil)\n         \
    \                                                                            \
    \                                 ^\n/tmp/tmpbxzoq0nf.swift:17:34: error: value\
    \ of type 'String' has no member 'reverse'\n    for b in brackets.characters.reverse()\
    \ {\n             ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpbxzoq0nf.swift:19:25: error:\
    \ use of local variable 'bc' before its declaration\n        let bc = String(bc)\n\
    \                        ^\n/tmp/tmpbxzoq0nf.swift:19:13: note: 'bc' declared\
    \ here\n        let bc = String(bc)\n            ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBrackets = [String]()\n    var closingBrackets = [String]()\n\
    \    brackets.forEach { char in\n        switch char {\n        case \")\":\n\
    \            closingBrackets.append(char)\n        case \")\":\n            openingBrackets.remove(lastElement())\n\
    \            closingBrackets.append(char)\n        default:\n            openingBrackets.append(char)\n\
    \        }\n    }\n    return !openingBrackets.isEmpty && !closingBrackets.isEmpty\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0use_e88.swift:20:36: error: cannot find 'lastElement' in scope\n\
    \            openingBrackets.remove(lastElement())\n                         \
    \          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return true\n    }\n\n    var bracketStack\
    \ = [brackets]\n\n    for char in brackets {\n        if char == \")\" {\n   \
    \         if bracketStack.count > 0 {\n                bracketStack.removeLast()\n\
    \            } else {\n                return false\n            }\n        }\
    \ else {\n            if bracketStack.count < 1 {\n                return false\n\
    \            }\n\n            if char != \"(\" {\n                return false\n\
    \            }\n\n            bracketStack.append(char)\n        }\n    }\n\n\
    \    return bracketStack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpi2x0tals.swift:35:33: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            bracketStack.append(char)\n\
    \                                ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openings = brackets.characters\n        .filter({ openingBracket($0)\
    \ })\n    let closings = brackets.characters\n        .filter({ closingBracket($0)\
    \ })\n    if openings.isEmpty { return false }\n    if closings.isEmpty { return\
    \ true }\n    if openings.count != closings.count { return false }\n    for i\
    \ in 0..<openings.count {\n        if openings[i] != closings[i] { return false\
    \ }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpa6ldh2hs.swift:14:19: error: cannot find 'openingBracket' in scope\n\
    \        .filter({ openingBracket($0) })\n                  ^~~~~~~~~~~~~~\n/tmp/tmpa6ldh2hs.swift:16:19:\
    \ error: cannot find 'closingBracket' in scope\n        .filter({ closingBracket($0)\
    \ })\n                  ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    return brackets == brackets.reduce(into: \"\") { result, next in\n      \
    \  if result.isEmpty { return \"\" }\n        if next == \"(\") { return result\
    \ + \"(\" + result }\n        else { return result + result }\n    }.isEmpty\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_8ximbct.swift:15:23: error: expected '{' after 'if' condition\n\
    \        if next == \"(\") { return result + \"(\" + result }\n              \
    \        ^\n/tmp/tmp_8ximbct.swift:13:21: error: binary operator '==' cannot be\
    \ applied to operands of type 'String' and 'Bool'\n    return brackets == brackets.reduce(into:\
    \ \"\") { result, next in\n           ~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_8ximbct.swift:13:21: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Bool, Bool), (String, String)\n    return brackets\
    \ == brackets.reduce(into: \"\") { result, next in\n                    ^\n/tmp/tmp_8ximbct.swift:14:36:\
    \ error: unexpected non-void return value in void function\n        if result.isEmpty\
    \ { return \"\" }\n                                   ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var brackets_without_open = brackets\n    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"\")\n    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    ,\", withString: \"\")\n    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    /\", withString: \"-\")\n    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    \\\\\", withString: \"-\")\n\n    if brackets_without_open.length == 0 {\n   \
    \     return false\n    }\n\n    var brackets_without_close = brackets\n    brackets_without_close\
    \ = brackets_without_close.stringByReplacingOccurrencesOfString(\")\", withString:\
    \ \"\")\n    brackets_without_close = brackets_without_close.stringByReplacingOccurrencesOfString(\"\
    ]\", withString: \"\")\n    brackets_without_close = brackets_without_close.stringByReplacingOccurrencesOfString(\"\
    }\", withString: \"\")\n    brackets_without_close = brackets_without_close.stringByReplacingOccurrencesOfString(\"\
    )\", withString: \"\")\n\n    if brackets_without_close.length == 0 {\n      \
    \  return false\n    }\n\n    var opening_bracket = \"\"\n    var closing_bracket\
    \ = \"\"\n    var opening_brackets = []\n    var closing_brackets = []\n    var\
    \ current_opening_bracket = \"\"\n    var current_closing_bracket = \"\"\n\n \
    \   for i in 0..<brackets_without_open.length {\n        current_opening_bracket\
    \ = brackets_without_open.substring(i, i+1)\n        if current_opening_bracket.isEmpty\
    \ {\n            continue\n        }\n\n        opening_bracket = opening_bracket.stringByAppendingString(current_opening_bracket)\n\
    \        opening_brackets.append(opening_bracket)\n\n        for j in 0..<brackets_without_close.length\
    \ {\n            current_closing_bracket = brackets_without_close.substring(j,\
    \ j+1)\n            if current_closing_bracket.isEmpty {\n                continue\n\
    \            }\n\n            closing_bracket = closing_bracket.stringByAppendingString(current_closing_bracket)\n\
    \            closing_brackets.append(closing_bracket)\n        }\n    }\n\n  \
    \  for opening_bracket in opening_brackets {\n        for closing_bracket in closing_brackets\
    \ {\n            if closing_bracket == opening_bracket {\n                continue\n\
    \            }\n\n            if open\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvowelva5.swift:66:20: error: expected '{' after 'if' condition\n\
    \            if open\n                   ^\n/tmp/tmpvowelva5.swift:93:66: error:\
    \ expected '}' at end of brace statement\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()))()\") == false)\n                                          \
    \                       ^\n/tmp/tmpvowelva5.swift:60:45: note: to match this opening\
    \ '{'\n    for opening_bracket in opening_brackets {\n                       \
    \                     ^\n/tmp/tmpvowelva5.swift:93:66: error: expected '}' at\
    \ end of brace statement\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)\n                                                                \
    \ ^\n/tmp/tmpvowelva5.swift:12:51: note: to match this opening '{'\nfunc correct_bracketing(brackets:\
    \ String) -> Bool {\n                                                  ^\n/tmp/tmpvowelva5.swift:14:51:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"\")\n                            ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvowelva5.swift:15:51: error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    ,\", withString: \"\")\n                            ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvowelva5.swift:16:51: error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    /\", withString: \"-\")\n                            ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvowelva5.swift:17:51: error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    \\\\\", withString: \"-\")\n                            ~~~~~~~~~~~~~~~~~~~~~ "
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty() {\n        return true\n    }\n    var opening = brackets.characters(in:\
    \ UnicodeScalar(stringInterpolationSegment: brackets[0])!)\n    var closing =\
    \ brackets.characters(in: UnicodeScalar(stringInterpolationSegment: brackets[1])!)\n\
    \    while opening != nil {\n        if closing.contains {\n            closing\
    \ = brackets.characters(in: UnicodeScalar(stringInterpolationSegment: brackets[1])!)\n\
    \        } else {\n            opening = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[0])!)\n            closing = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[1])!)\n        }\n    }\n    return opening == nil && closing == nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp356kftws.swift:13:17: error: cannot call value of non-function\
    \ type 'Bool'\n    if brackets.isEmpty() {\n                ^      ~~\n      \
    \                 \n/tmp/tmp356kftws.swift:16:43: error: no exact matches in call\
    \ to initializer \n    var opening = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[0])!)\n                                          ^\n/tmp/tmp356kftws.swift:16:43:\
    \ note: found candidate with type '(UInt32) -> UnicodeScalar?' (aka '(UInt32)\
    \ -> Optional<Unicode.Scalar>')\n    var opening = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[0])!)\n                                          ^\n/tmp/tmp356kftws.swift:16:43:\
    \ note: found candidate with type '(UInt16) -> UnicodeScalar?' (aka '(UInt16)\
    \ -> Optional<Unicode.Scalar>')\n    var opening = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[0])!)\n                                          ^\n/tmp/tmp356kftws.swift:16:43:\
    \ note: found candidate with type '(String) -> UnicodeScalar?' (aka '(String)\
    \ -> Optional<Unicode.Scalar>')\n    var opening = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[0])!)\n                                          ^\n/tmp/tmp356kftws.swift:16:43:\
    \ note: found candidate with type '(Int) -> UnicodeScalar?' (aka '(Int) -> Optional<Unicode.Scalar>')\n\
    \    var opening = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[0])!)\n                                          ^\n/tmp/tmp356kftws.swift:16:28:\
    \ error: cannot call value of non-function type 'String'\n    var opening = brackets.characters(in:\
    \ UnicodeScalar(stringInterpolationSegment: brackets[0])!)\n                 \
    \          ^\n/tmp/tmp356kftws.swift:17:43: error: no exact matches in call to\
    \ initializer \n    var closing = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[1])!)\n                                          ^\n/tmp/tmp356kftws.swift:17:43:\
    \ note: found candidate with type '(UInt32) -> UnicodeScalar?' (aka '(UInt32)\
    \ -> Optional<Unic"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening = true\n    var closing = true\n    for ch in brackets {\n  \
    \      if openingBrackets.contains(ch) {\n            opening = false\n      \
    \  }\n        if closingBrackets.contains(ch) {\n            closing = false\n\
    \        }\n    }\n    return opening && closing\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvbs8o7cy.swift:16:12: error: cannot find 'openingBrackets' in scope\n\
    \        if openingBrackets.contains(ch) {\n           ^~~~~~~~~~~~~~~\n/tmp/tmpvbs8o7cy.swift:19:12:\
    \ error: cannot find 'closingBrackets' in scope\n        if closingBrackets.contains(ch)\
    \ {\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return true\n    }\n\n    let first = brackets[0]\n\
    \    let last  = brackets.last\n\n    if first != last {\n        return false\n\
    \    }\n\n    if first == \"(\" {\n        let substr = brackets.substring(1)\n\
    \        if substr.characters.count == 0 {\n            return false\n       \
    \ }\n        return correct_bracketing(substring)\n    }\n\n    if last == \"\
    )\" {\n        return true\n    }\n\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0xgvkp4l.swift:17:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    let first = brackets[0]\n\
    \                ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp0xgvkp4l.swift:25:31: error: value of type 'String'\
    \ has no member 'substring'\n        let substr = brackets.substring(1)\n    \
    \                 ~~~~~~~~ ^~~~~~~~~\n/tmp/tmp0xgvkp4l.swift:29:35: error: cannot\
    \ find 'substring' in scope\n        return correct_bracketing(substring)\n  \
    \                                ^~~~~~~~~\n/tmp/tmp0xgvkp4l.swift:29:35: error:\
    \ missing argument label 'brackets:' in call\n        return correct_bracketing(substring)\n\
    \                                  ^\n                                  brackets:\
    \ \n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.characters.map({ String($0) })\n    for opening in brackets.characters\
    \ {\n        for closing in brackets.characters {\n            if opening == closing\
    \ {\n                continue\n            }\n            if opening != closing\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6n_kkt3y.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.characters.map({ String($0) })\n\
    \    ^~~~~~~~\n/tmp/tmp6n_kkt3y.swift:13:36: error: cannot assign value of type\
    \ '[String]' to type 'String'\n    brackets = brackets.characters.map({ String($0)\
    \ })\n               ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6n_kkt3y.swift:14:29:\
    \ error: 'characters' is unavailable: Please use String directly\n    for opening\
    \ in brackets.characters {\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp6n_kkt3y.swift:15:33: error: 'characters'\
    \ is unavailable: Please use String directly\n        for closing in brackets.characters\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let pairs = brackets.characters.split(CharacterSet.brackets).map(String.init)\n\
    \    return pairs.isEmpty == false && pairs.count == pairs.filter(String.init(\"\
    (\").count != pairs.filter(String.init(\")\").count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_ityxmwt.swift:15:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp_ityxmwt.swift:14:104: note: to match this opening '('\n    return\
    \ pairs.isEmpty == false && pairs.count == pairs.filter(String.init(\"(\").count\
    \ != pairs.filter(String.init(\")\").count\n                                 \
    \                                                                      ^\n/tmp/tmp_ityxmwt.swift:13:43:\
    \ error: cannot find 'CharacterSet' in scope\n    let pairs = brackets.characters.split(CharacterSet.brackets).map(String.init)\n\
    \                                          ^~~~~~~~~~~~\n/tmp/tmp_ityxmwt.swift:13:43:\
    \ error: missing argument label 'separator:' in call\n    let pairs = brackets.characters.split(CharacterSet.brackets).map(String.init)\n\
    \                                          ^\n                               \
    \           separator: \n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets.characters.indexOf(\"(\")\n    if opening < 0 {\n\
    \        return false\n    }\n    let closing = brackets.characters.indexOf(\"\
    )\")\n    if closing < 0 {\n        return false\n    }\n    if opening >= closing\
    \ {\n        return false\n    }\n    for openingIdx in stride(from: opening,\
    \ through: closing, by: 1) {\n        let openingCount = brackets.characters.substring(from:\
    \ openingIdx).characters.count\n        let closingCount = brackets.characters.substring(from:\
    \ closingIdx).characters.count\n        if openingCount != closingCount {\n  \
    \          return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpssclt4ck.swift:13:39: error: value of type 'String' has no member\
    \ 'indexOf'\n    let opening = brackets.characters.indexOf(\"(\")\n          \
    \        ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpssclt4ck.swift:17:39: error: value\
    \ of type 'String' has no member 'indexOf'\n    let closing = brackets.characters.indexOf(\"\
    )\")\n                  ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpssclt4ck.swift:25:48:\
    \ error: value of type 'String' has no member 'substring'\n        let openingCount\
    \ = brackets.characters.substring(from: openingIdx).characters.count\n       \
    \                    ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpssclt4ck.swift:26:64:\
    \ error: cannot find 'closingIdx' in scope\n        let closingCount = brackets.characters.substring(from:\
    \ closingIdx).characters.count\n                                             \
    \                  ^~~~~~~~~~\n/tmp/tmpssclt4ck.swift:26:48: error: value of type\
    \ 'String' has no member 'substring'\n        let closingCount = brackets.characters.substring(from:\
    \ closingIdx).characters.count\n                           ~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var correct = true\n\n\tbrackets = brackets.lowercaseString\n\n\tfor _, char :=\
    \ range brackets {\n\t\tswitch char {\n\t\tcase '(':\n\t\t\tswitch brackets[brackets.Index(char)\
    \ + 1] {\n\t\t\tcase ')':\n\t\t\t\tbrackets = brackets.Replace(char, \"\")\n\t\
    \t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\tcase '(':\n\t\t\t\tbrackets = brackets.Replace(char,\
    \ \"\")\n\t\t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\t}\n\t\tcase '[':\n\t\t\t\
    switch brackets[brackets.Index(char) + 1] {\n\t\t\tcase ']':\n\t\t\t\tbrackets\
    \ = brackets.Replace(char, \"\")\n\t\t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\
    \tcase '[':\n\t\t\t\tbrackets = brackets.Replace(char, \"\")\n\t\t\t\tcorrect\
    \ = false\n\t\t\t\tbreak\n\t\t\t}\n\t\tcase ']':\n\t\t\tswitch brackets[brackets.Index(char)\
    \ - 1] {\n\t\t\tcase '[':\n\t\t\t\tbrackets = brackets.Replace(char, \"\")\n\t\
    \t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\tcase ')':\n\t\t\t\tbrackets = brackets.Replace(char,\
    \ \"\")\n\t\t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\t}\n\t\tcase '{':\n\t\t\t\
    switch brackets[brackets.Index(char) + 1] {\n\t\t\tcase '}':\n\t\t\t\tbrackets\
    \ = brackets.Replace(char, \"\")\n\t\t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\
    \tcase '{':\n\t\t\t\tbrackets = brackets.Replace(char, \"\")\n\t\t\t\tcorrect\
    \ = false\n\t\t\t\tbreak\n\t\t\t}\n\t\tcase '}':\n\t\t\tswitch brackets[brackets.Index(char)\
    \ - 1] {\n\t\t\tcase '{':\n\t\t\t\tbrackets = brackets.Replace(char, \"\")\n\t\
    \t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\tcase '(':\n\t\t\t\tbrackets = brackets.Replace(char,\
    \ \"\")\n\t\t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\
    \ correct\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpe47vijy_.swift:17:7: error: expected 'in' after for-each pattern\n\
    \        for _, char := range brackets {\n             ^\n/tmp/tmpe47vijy_.swift:17:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, char :=\
    \ range brackets {\n             ^\n/tmp/tmpe47vijy_.swift:19:8: error: single-quoted\
    \ string literal found, use '\"'\n                case '(':\n                \
    \     ^~~\n                     \"(\"\n/tmp/tmpe47vijy_.swift:21:9: error: single-quoted\
    \ string literal found, use '\"'\n                        case ')':\n        \
    \                     ^~~\n                             \")\"\n/tmp/tmpe47vijy_.swift:25:9:\
    \ error: single-quoted string literal found, use '\"'\n                      \
    \  case '(':\n                             ^~~\n                             \"\
    (\"\n/tmp/tmpe47vijy_.swift:30:8: error: single-quoted string literal found, use\
    \ '\"'\n                case '[':\n                     ^~~\n                \
    \     \"[\"\n/tmp/tmpe47vijy_.swift:32:9: error: single-quoted string literal\
    \ found, use '\"'\n                        case ']':\n                       \
    \      ^~~\n                             \"]\"\n/tmp/tmpe47vijy_.swift:36:9: error:\
    \ single-quoted string literal found, use '\"'\n                        case '[':\n\
    \                             ^~~\n                             \"[\"\n/tmp/tmpe47vijy_.swift:41:8:\
    \ error: single-quoted string literal found, use '\"'\n                case ']':\n\
    \                     ^~~\n                     \"]\"\n/tmp/tmpe47vijy_.swift:43:9:\
    \ error: single-quoted string literal found, use '\"'\n                      \
    \  case '[':\n                             ^~~\n                             \"\
    [\"\n/tmp/tmpe47vijy_.swift:47:9: error: single-quoted string literal found, use\
    \ '\"'\n                        case ')':\n                             ^~~\n\
    \                             \")\"\n/tmp/tmpe47vijy_.swift:52:8: error: single-quoted\
    \ string literal found, use '\"'\n                case '{':\n                \
    \     ^~~\n                     \"{\"\n/tmp/tmpe47vijy_.swift:54:9: error: single-quoted\
    \ string literal found, use '\""
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.characters.map { String($0) }\n    \n    var bracketOpenCount\
    \ = brackets.count\n    var bracketClosedCount = 0\n\n    var lastChar = ' '\n\
    \    for char in brackets {\n        if char == lastChar {\n            bracketClosedCount++\n\
    \        } else {\n            if bracketOpenCount == bracketClosedCount {\n \
    \               return false\n            }\n            bracketOpenCount = bracketClosedCount\n\
    \            lastChar = char\n        }\n    }\n    return bracketOpenCount ==\
    \ bracketClosedCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp49bry1r4.swift:18:20: error: single-quoted string literal found,\
    \ use '\"'\n    var lastChar = ' '\n                   ^~~\n                 \
    \  \" \"\n/tmp/tmp49bry1r4.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.characters.map { String($0) }\n\
    \    ^~~~~~~~\n/tmp/tmp49bry1r4.swift:13:36: error: cannot assign value of type\
    \ '[String]' to type 'String'\n    brackets = brackets.characters.map { String($0)\
    \ }\n               ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n/tmp/tmp49bry1r4.swift:20:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if char == lastChar {\n           ~~~~ ^  ~~~~~~~~\n/tmp/tmp49bry1r4.swift:20:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == lastChar {\n  \
    \              ^\n/tmp/tmp49bry1r4.swift:21:31: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            bracketClosedCount++\n         \
    \                     ^~\n/tmp/tmp49bry1r4.swift:27:24: error: cannot assign value\
    \ of type 'Character' to type 'String'\n            lastChar = char\n        \
    \               ^~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketCounts = [Int]()\n    var openBracket = brackets[0]\n    var closeBracket\
    \ = brackets[brackets.startIndex].unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first\n\
    \    if let openBracket = openBracket {\n        for char in openBracket.unicodeScalars.first?.unicodeScalars.first\
    \ {\n            bracketCounts[0]++\n        }\n    }\n    if let closeBracket\
    \ = closeBracket {\n        for char in closeBracket.unicodeScalars.first?.unicodeScalars.first\
    \ {\n            bracketCounts[bracketCounts.count - 1]++\n        }\n    }\n\
    \    for (bracket, count) in bracketCounts {\n        if count < 2 {\n       \
    \     return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpm4wodof6.swift:14:23: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var openBracket\
    \ = brackets[0]\n                      ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpm4wodof6.swift:15:135: error: type\
    \ of expression is ambiguous without more context\n    var closeBracket = brackets[brackets.startIndex].unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first\n\
    \                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpm4wodof6.swift:17:55: error: value of type 'Unicode.Scalar' has no member\
    \ 'unicodeScalars'\n        for char in openBracket.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpm4wodof6.swift:17:70:\
    \ error: for-in loop requires 'Optional<_>' to conform to 'Sequence'; did you\
    \ mean to unwrap optional?\n        for char in openBracket.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpm4wodof6.swift:16:8: error: initializer for conditional binding must have\
    \ Optional type, not 'Character'\n    if let openBracket = openBracket {\n   \
    \    ^                 ~~~~~~~~~~~\n/tmp/tmpm4wodof6.swift:22:71: error: for-in\
    \ loop requires 'Optional<_>' to conform to 'Sequence'; did you mean to unwrap\
    \ optional?\n        for char in closeBracket.unicodeScalars.first?.unicodeScalars.first\
    \ {\n                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpm4wodof6.swift:26:29: error: tuple pattern cannot match values of non-tuple\
    \ type 'Int'\n    for (bracket, count) in bracketCounts {\n                  \
    \          ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBracketRanges = brackets.components(separatedBy: CharacterSet.openingParenthesis)\n\
    \    var mismatchedBrackets = false\n    for (index, openingBracketRange) in openingBracketRanges.enumerated()\
    \ {\n        let closingBracketRange = openingBracketRanges[index + 1]\n     \
    \   if openingBracketRange != closingBracketRange {\n            mismatchedBrackets\
    \ = true\n        }\n    }\n\n    return mismatchedBrackets == false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp224am46y.swift:13:65: error: cannot find 'CharacterSet' in scope\n\
    \    let openingBracketRanges = brackets.components(separatedBy: CharacterSet.openingParenthesis)\n\
    \                                                                ^~~~~~~~~~~~\n\
    /tmp/tmp224am46y.swift:13:41: error: value of type 'String' has no member 'components'\n\
    \    let openingBracketRanges = brackets.components(separatedBy: CharacterSet.openingParenthesis)\n\
    \                               ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let all_brackets_map = brackets.split(separator: \",\").map(String.init)\n\
    \    return all_brackets_map.count == all_brackets_map.filter({ !$0.isEmpty }).count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'tmp63mhv2vw/tmp63mhv2vw.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5978271c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5977f68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5977f68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5977f677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp63mhv2vw                        0x0000559a83d3f9a3 <unavailable> + 6563

    5    libc.so.6                          0x00002b597845d460 __libc_start_main +
    245

    6    tmp63mhv2vw                        0x0000559a83d3f399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if let firstOpeningBracket = brackets.characters.firstIndex(of: \"(\"),\n\
    \        let lastClosingBracket = brackets.characters.lastIndex(of: \")\"),\n\
    \        lastClosingBracket == firstOpeningBracket {\n        return true\n  \
    \  } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6nspra7j.swift:13:43: error: 'characters' is unavailable: Please\
    \ use String directly\n    if let firstOpeningBracket = brackets.characters.firstIndex(of:\
    \ \"(\"),\n                                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp6nspra7j.swift:14:43: error: 'characters'\
    \ is unavailable: Please use String directly\n        let lastClosingBracket =\
    \ brackets.characters.lastIndex(of: \")\"),\n                                \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard brackets.count == 1 || (brackets.starts(with: \"(\") && brackets.ends(with:\
    \ \")\")) else {\n        return false\n    }\n    \n    var result = false\n\
    \    brackets.enumerate().forEach { index, character in\n        if index == 0\
    \ {\n            result = true\n        } else {\n            let lastChar = String(characters.characters.last!)\n\
    \            if lastChar == character {\n                result = true\n     \
    \       } else {\n                result = false\n            }\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmps7bojr3g.swift:13:74: error: value of type 'String' has no member\
    \ 'ends'\n    guard brackets.count == 1 || (brackets.starts(with: \"(\") && brackets.ends(with:\
    \ \")\")) else {\n                                                           \
    \     ~~~~~~~~ ^~~~\n/tmp/tmps7bojr3g.swift:22:35: error: cannot find 'characters'\
    \ in scope\n            let lastChar = String(characters.characters.last!)\n \
    \                                 ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var opening_brackets = brackets.characters\n\tvar closing_brackets = brackets.characters.reversed()\n\
    \tvar current_bracket = opening_brackets.firstIndex(of: CharacterSet.openingParenthesis)!\n\
    \tlet last_bracket = opening_brackets.lastIndex(of: CharacterSet.closingParenthesis)!\n\
    \t\n\tfor opening_bracket in opening_brackets.suffix(from: current_bracket) {\n\
    \t\tif opening_bracket == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif closing_brackets.contains(opening_bracket)\
    \ {\n\t\t\tcurrent_bracket = opening_bracket\n\t\t\tbreak\n\t\t}\n\t}\n\t\n\t\
    if current_bracket != last_bracket {\n\t\treturn false\n\t}\n\t\n\treturn true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmphsy9qwse.swift:13:34: error: 'characters' is unavailable: Please\
    \ use String directly\n        var opening_brackets = brackets.characters\n  \
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphsy9qwse.swift:14:34: error: 'characters' is unavailable:\
    \ Please use String directly\n        var closing_brackets = brackets.characters.reversed()\n\
    \                                        ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmphsy9qwse.swift:15:56: error: cannot find\
    \ 'CharacterSet' in scope\n        var current_bracket = opening_brackets.firstIndex(of:\
    \ CharacterSet.openingParenthesis)!\n                                        \
    \                      ^~~~~~~~~~~~\n/tmp/tmphsy9qwse.swift:16:52: error: cannot\
    \ find 'CharacterSet' in scope\n        let last_bracket = opening_brackets.lastIndex(of:\
    \ CharacterSet.closingParenthesis)!\n                                        \
    \                  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return true\n    }\n\n    var bracket_stack\
    \ = [Character.UnicodeScalarView]()\n    var opening_brackets = brackets.characters\n\
    \    for opening_bracket in opening_brackets {\n        if let opening_bracket\
    \ = Character.UnicodeScalarView(opening_bracket) {\n            if opening_bracket.value\
    \ == -1 {\n                bracket_stack.append(opening_bracket)\n           \
    \ } else {\n                bracket_stack.append(opening_bracket)\n          \
    \  }\n        }\n    }\n\n    for opening_bracket in bracket_stack {\n       \
    \ if let opening_bracket = Character.UnicodeScalarView(opening_bracket) {\n  \
    \          if let next_opening_bracket = bracket_stack.removeLast() {\n      \
    \          if opening_bracket.value == -1 && next_opening_bracket.value == -1\
    \ {\n                    opening_bracket.value = next_opening_bracket.value\n\
    \                } else {\n                    return false\n                }\n\
    \            } else {\n                return false\n            }\n        }\
    \ else {\n            return false\n        }\n    }\n\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmphtmpv6km.swift:18:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    var opening_brackets = brackets.characters\n      \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphtmpv6km.swift:20:34: error: initializer 'init(_:)'\
    \ requires that 'Character' conform to 'Sequence'\n        if let opening_bracket\
    \ = Character.UnicodeScalarView(opening_bracket) {\n                         \
    \        ^\nSwift.RangeReplaceableCollection:3:23: note: where 'S' = 'Character'\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\n/tmp/tmphtmpv6km.swift:32:36: error:\
    \ value of type 'Character.UnicodeScalarView' (aka 'String.UnicodeScalarView')\
    \ has no member 'value'\n                if opening_bracket.value == -1 && next_opening_bracket.value\
    \ == -1 {\n                   ~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmphtmpv6km.swift:32:72:\
    \ error: value of type 'Character.UnicodeScalarView' (aka 'String.UnicodeScalarView')\
    \ has no member 'value'\n                if opening_bracket.value == -1 && next_opening_bracket.value\
    \ == -1 {\n                                                  ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~\n/tmp/tmphtmpv6km.swift:33:37: error: value of type 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView') has no member 'value'\n                   \
    \ opening_bracket.value = next_opening_bracket.value\n                    ~~~~~~~~~~~~~~~\
    \ ^~~~~\n/tmp/tmphtmpv6km.swift:33:66: error: value of type 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView') has no member 'value'\n                   \
    \ opening_bracket.value = next_opening_bracket.value\n                       \
    \                     ~~~~~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmphtmpv6km.swift:31:16:\
    \ error: initializer for conditional binding must have Optional type, not 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView')\n            if let next_opening_bracket =\
    \ bracket_stack.removeLast() {\n   "
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBrackets = brackets.characters\n    var closingBrackets = brackets.characters\n\
    \n    if brackets.characters.count == 0 {\n        return true\n    }\n\n    openingBrackets.removeFirst()\n\
    \    closingBrackets.removeLast()\n    for openingBracket in openingBrackets {\n\
    \        if closingBrackets.contains(openingBracket) {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpouebj65e.swift:13:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    var openingBrackets = brackets.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpouebj65e.swift:14:36: error: 'characters' is unavailable:\
    \ Please use String directly\n    var closingBrackets = brackets.characters\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpouebj65e.swift:16:17: error: 'characters' is unavailable:\
    \ Please use String directly\n    if brackets.characters.count == 0 {\n      \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \  let bracketMap: [(Int, Int)] = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6,\
    \ 7), (7, 8), (8, 9), (9, 10), (10, 11), (11, 12), (12, 13), (13, 14), (14, 15),\
    \ (15, 16), (16, 17), (17, 18), (18, 19), (19, 20), (20, 21), (21, 22), (22, 23),\
    \ (23, 24), (24, 25), (25, 26), (26, 27), (27, 28), (28, 29), (29, 30), (30, 31)]\n\
    \  let lastOpeningBracket: Int\n  let lastClosingBracket: Int\n\n  for lastOpeningBracket,\
    \ bracket in bracketMap.enumerated() {\n    if brackets[bracket.first] == brackets[bracket.last]\
    \ {\n      return true\n    } else if bracket.first < lastOpeningBracket {\n \
    \     lastOpeningBracket = bracket.first\n    } else {\n      lastClosingBracket\
    \ = bracket.last\n    }\n  }\n\n  let openingBracketString: String = brackets[bracketMap.startIndex]\n\
    \  let closingBracketString: String = brackets[bracketMap.endIndex]\n\n  return\
    \ openingBracketString == closingBracketString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmppipyngjj.swift:17:25: error: expected 'in' after for-each pattern\n\
    \  for lastOpeningBracket, bracket in bracketMap.enumerated() {\n            \
    \            ^\n/tmp/tmppipyngjj.swift:17:25: error: expected Sequence expression\
    \ for for-each loop\n  for lastOpeningBracket, bracket in bracketMap.enumerated()\
    \ {\n                        ^\n/tmp/tmppipyngjj.swift:27:46: error: cannot convert\
    \ value of type 'Character' to specified type 'String'\n  let openingBracketString:\
    \ String = brackets[bracketMap.startIndex]\n                                 \
    \    ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmppipyngjj.swift:28:46: error: cannot\
    \ convert value of type 'Character' to specified type 'String'\n  let closingBracketString:\
    \ String = brackets[bracketMap.endIndex]\n                                   \
    \  ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening = brackets\n    opening = opening.stringByReplacingOccurrencesOfString(\"\
    (\", withString: \"\")\n    opening = opening.stringByReplacingOccurrencesOfString(\"\
    )\", withString: \"\")\n    if opening.isEmpty {\n        return false\n    }\n\
    \    var closing = brackets\n    closing = closing.stringByReplacingOccurrencesOfString(\"\
    )\", withString: \"\")\n    closing = closing.stringByReplacingOccurrencesOfString(\"\
    (\", withString: \"\")\n    if closing.isEmpty {\n        return false\n    }\n\
    \    return opening.characters.count == closing.characters.count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpin7k1xwe.swift:14:23: error: value of type 'String' has no member\
    \ 'stringByReplacingOccurrencesOfString'\n    opening = opening.stringByReplacingOccurrencesOfString(\"\
    (\", withString: \"\")\n              ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpin7k1xwe.swift:15:23: error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    opening = opening.stringByReplacingOccurrencesOfString(\")\", withString:\
    \ \"\")\n              ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpin7k1xwe.swift:20:23:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    closing = closing.stringByReplacingOccurrencesOfString(\")\", withString:\
    \ \"\")\n              ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpin7k1xwe.swift:21:23:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    closing = closing.stringByReplacingOccurrencesOfString(\"(\", withString:\
    \ \"\")\n              ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpin7k1xwe.swift:25:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    return opening.characters.count\
    \ == closing.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpin7k1xwe.swift:25:48: error: 'characters'\
    \ is unavailable: Please use String directly\n    return opening.characters.count\
    \ == closing.characters.count\n                                              \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // TODO: Implement me!\n    fatalError(\"not implemented\")\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'tmpib0n1pca/tmpib0n1pca.swift:14: Fatal error: not implemented

    Current stack trace:

    0    libswiftCore.so                    0x00002ac691da9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac691aa0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac691aa0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac691a9f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpib0n1pca                        0x00005617ef983aa8 <unavailable> + 6824

    5    tmpib0n1pca                        0x00005617ef9831e6 <unavailable> + 4582

    6    libc.so.6                          0x00002ac691f95460 __libc_start_main +
    245

    7    tmpib0n1pca                        0x00005617ef982ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var result = true\n    var stack = [Character]()\n    var openingBracket\
    \ = -1\n    var closingBracket = -1\n    var currentChar: Character\n    for currentChar\
    \ in brackets {\n        if openingBracket == -1 {\n            if currentChar\
    \ == ')' {\n                closingBracket = currentChar\n            } else {\n\
    \                result = false\n                break\n            }\n      \
    \  } else {\n            if currentChar == '(' {\n                if stack[openingBracket]\
    \ == nil {\n                    stack[openingBracket] = currentChar\n        \
    \        } else {\n                    result = false\n                    break\n\
    \                }\n            } else {\n                if stack[openingBracket]\
    \ != nil {\n                    result = false\n                    break\n  \
    \              }\n                stack[openingBracket] = currentChar\n      \
    \      }\n        }\n        openingBracket = stack.count\n    }\n    if stack[openingBracket]\
    \ != nil {\n        result = false\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmph7unl5xz.swift:20:31: error: single-quoted string literal found,\
    \ use '\"'\n            if currentChar == ')' {\n                            \
    \  ^~~\n                              \")\"\n/tmp/tmph7unl5xz.swift:27:31: error:\
    \ single-quoted string literal found, use '\"'\n            if currentChar ==\
    \ '(' {\n                              ^~~\n                              \"(\"\
    \n/tmp/tmph7unl5xz.swift:21:34: error: cannot assign value of type 'Character'\
    \ to type 'Int'\n                closingBracket = currentChar\n              \
    \                   ^~~~~~~~~~~\n/tmp/tmph7unl5xz.swift:28:42: warning: comparing\
    \ non-optional value of type 'Character' to 'nil' always returns false\n     \
    \           if stack[openingBracket] == nil {\n                   ~~~~~~~~~~~~~~~~~~~~~\
    \ ^  ~~~\n/tmp/tmph7unl5xz.swift:35:42: warning: comparing non-optional value\
    \ of type 'Character' to 'nil' always returns true\n                if stack[openingBracket]\
    \ != nil {\n                   ~~~~~~~~~~~~~~~~~~~~~ ^  ~~~\n/tmp/tmph7unl5xz.swift:44:30:\
    \ warning: comparing non-optional value of type 'Character' to 'nil' always returns\
    \ true\n    if stack[openingBracket] != nil {\n       ~~~~~~~~~~~~~~~~~~~~~ ^\
    \  ~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let mut opening = brackets.characters\n    opening.append(String::from(\"\
    \"))\n    opening.append(String::from(\"\"))\n    let mut closing = brackets.characters\n\
    \    closing.append(String::from(\"\"))\n    closing.append(String::from(\"\"\
    ))\n    while opening.count > 0 {\n        let start = opening[0]\n        let\
    \ end = opening.remove(at: 0)\n        if end.characters.count > 0 {\n       \
    \     let mut found = false\n            for index in 0 ..< (closing.count-1)\
    \ {\n                if closing.index(before: index, offsetBy: end.characters.count)\
    \ == end+1 {\n                    closing.remove(at: index, length: end.characters.count)\n\
    \                    opening.insert(index, end)\n                    found = true\n\
    \                    break\n                }\n            }\n            if !found\
    \ {\n                closing.append(end)\n            }\n        }\n    }\n  \
    \  return opening.count == closing.count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6dxijwj3.swift:13:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut opening\
    \ = brackets.characters\n            ^\n/tmp/tmp6dxijwj3.swift:13:13: note: join\
    \ the identifiers together\n    let mut opening = brackets.characters\n      \
    \  ~~~~^~~~~~~\n        mutopening\n/tmp/tmp6dxijwj3.swift:13:13: note: join the\
    \ identifiers together with camel-case\n    let mut opening = brackets.characters\n\
    \        ~~~~^~~~~~~\n        mutOpening\n/tmp/tmp6dxijwj3.swift:14:27: error:\
    \ expected expression in list of expressions\n    opening.append(String::from(\"\
    \"))\n                          ^\n/tmp/tmp6dxijwj3.swift:15:27: error: expected\
    \ expression in list of expressions\n    opening.append(String::from(\"\"))\n\
    \                          ^\n/tmp/tmp6dxijwj3.swift:16:13: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \   let mut closing = brackets.characters\n            ^\n/tmp/tmp6dxijwj3.swift:16:13:\
    \ note: join the identifiers together\n    let mut closing = brackets.characters\n\
    \        ~~~~^~~~~~~\n        mutclosing\n/tmp/tmp6dxijwj3.swift:16:13: note:\
    \ join the identifiers together with camel-case\n    let mut closing = brackets.characters\n\
    \        ~~~~^~~~~~~\n        mutClosing\n/tmp/tmp6dxijwj3.swift:17:27: error:\
    \ expected expression in list of expressions\n    closing.append(String::from(\"\
    \"))\n                          ^\n/tmp/tmp6dxijwj3.swift:18:27: error: expected\
    \ expression in list of expressions\n    closing.append(String::from(\"\"))\n\
    \                          ^\n/tmp/tmp6dxijwj3.swift:23:21: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \           let mut found = false\n                    ^\n/tmp/tmp6dxijwj3.swift:23:21:\
    \ note: join the identifiers together\n            let mut found = false\n   \
    \             ~~~~^~~~~\n                mutfound\n/tmp/tmp6dxijwj3.swift:23:21:\
    \ note: join the identifiers together with camel-case\n            let mut found\
    \ = false\n                ~~~~^~~"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let bracketsArray = brackets.characters\n        .map { $0 == \"(\" ? \"\
    (\" : \"(\" }.joined(separator: \"\")\n        .characters\n        .map { $0\
    \ == \"(\" ? \")\" : \")\" }.joined(separator: \"\")\n        .characters\n  \
    \      .map { $0 == \"(\" ? \"(\" : \")\" }\n        .joined(separator: \"\")\n\
    \n    let openingBracketCount = bracketsArray.count\n    let closingBracketCount\
    \ = bracketsArray.count\n    let result = openingBracketCount == closingBracketCount\n\
    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmphxlwg6fx.swift:13:34: error: 'characters' is unavailable: Please\
    \ use String directly\n    let bracketsArray = brackets.characters\n         \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmphxlwg6fx.swift:15:10: error: 'characters' is unavailable:\
    \ Please use String directly\n        .characters\n         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmphxlwg6fx.swift:17:10: error: 'characters'\
    \ is unavailable: Please use String directly\n        .characters\n         ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard brackets.contains(\"(\") && brackets.contains(\")\") else {\n     \
    \   return false\n    }\n    let openingBracketStrings = brackets.components(separatedBy:\
    \ \"(\").filter({$0.contains(\")\")})\n    let closingBracketStrings = brackets.components(separatedBy:\
    \ \")\").filter({$0.contains(\"(\")})\n\n    if openingBracketStrings.isEmpty\
    \ || closingBracketStrings.isEmpty {\n        return false\n    }\n    for i in\
    \ 0..<openingBracketStrings.count {\n        if openingBracketStrings[i] == \"\
    (\" && closingBracketStrings[i] == \")\" {\n            return true\n        }\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpoiny5xt1.swift:16:42: error: value of type 'String' has no member\
    \ 'components'\n    let openingBracketStrings = brackets.components(separatedBy:\
    \ \"(\").filter({$0.contains(\")\")})\n                                ~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpoiny5xt1.swift:17:42: error: value of type 'String' has\
    \ no member 'components'\n    let closingBracketStrings = brackets.components(separatedBy:\
    \ \")\").filter({$0.contains(\"(\")})\n                                ~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    switch {\n    case brackets == \"\" || brackets.unicodeScalars == nil :\n\
    \        return false\n    case brackets.unicodeScalars.count != 1 :\n       \
    \ return false\n    else :\n        var opening = brackets.unicodeScalars[0]\n\
    \        var closing = brackets.unicodeScalars.first!\n        var openingCount\
    \ = 0\n        var closingCount = 0\n        for scalar in brackets.unicodeScalars\
    \ {\n            openingCount += opening.isASCII() ? 1 : 0\n            closingCount\
    \ += closing.isASCII() ? 1 : 0\n            opening = closing\n            closing\
    \ = scalar\n        }\n        \n        if openingCount == 0 {\n            return\
    \ true\n        }\n        \n        return openingCount == closingCount\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbywiho52.swift:13:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n/tmp/tmpbywiho52.swift:18:5: error: expected expression\n\
    \    else :\n    ^\n/tmp/tmpbywiho52.swift:19:46: error: no exact matches in call\
    \ to subscript \n        var opening = brackets.unicodeScalars[0]\n          \
    \                                   ^\nSwift.String.UnicodeScalarView:7:23: note:\
    \ candidate expects value of type 'String.UnicodeScalarView.Index' (aka 'String.Index')\
    \ for parameter #1 (got 'Int')\n    @inlinable public subscript(position: String.UnicodeScalarView.Index)\
    \ -> Unicode.Scalar { get }\n                      ^\nSwift.String.UnicodeScalarView:4:12:\
    \ note: candidate expects value of type 'Range<String.UnicodeScalarView.Index>'\
    \ (aka 'Range<String.Index>') for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.UnicodeScalarView.Index>) -> String.UnicodeScalarView.SubSequence\
    \ { get }\n           ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmpbywiho52.swift:25:37: error: cannot call value\
    \ of non-function type 'Bool'\n            closingCount += closing.isASCII() ?\
    \ 1 : 0\n                                    ^      ~~\n                     \
    \                      \n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.lowercased()\n    var bracketCount = 0\n    var hasOpeningBracket\
    \ = false\n    for character in brackets {\n        if character == \"(\" || character\
    \ == \")\" {\n            bracketCount++\n        }\n        if character == \"\
    )\" {\n            bracketCount--\n            if bracketCount == 0 {\n      \
    \          hasOpeningBracket = true\n            }\n        }\n    }\n    return\
    \ hasOpeningBracket\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnf6z1r2y.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.lowercased()\n    ^~~~~~~~\n/tmp/tmpnf6z1r2y.swift:18:25:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  bracketCount++\n                        ^~\n/tmp/tmpnf6z1r2y.swift:21:25: error:\
    \ cannot find operator '--' in scope; did you mean '-= 1'?\n            bracketCount--\n\
    \                        ^~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openBracketCounts = brackets.split(separator: \" \").map(String.init).map\
    \ {\n        String($0.characters.count) + String($0.characters.first!)\n    }.map{String($0.characters.last!)}.reduce(into:\
    \ [String: Int](), { $0[$1] = ($0[$1]! + 1) })\n    guard openBracketCounts.isEmpty\
    \ else {\n        return false\n    }\n    let closeBracketCounts = brackets.split(separator:\
    \ \" \").map(String.init).map({ String($0.characters.last!) }).reduce(into: [String:\
    \ Int](), { $0[$1] = ($0[$1]! + 1) })\n    guard closeBracketCounts.isEmpty else\
    \ {\n        return false\n    }\n    let totalBrackets = openBracketCounts.reduce(0,\
    \ { $0 + $1})\n    let openBrackets = openBracketCounts.filter{$0 != 0}\n    return\
    \ totalBrackets == openBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpo9v7zpsl.swift:13:29: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let openBracketCounts = brackets.split(separator: \" \"\
    ).map(String.init).map {\n                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpo9v7zpsl.swift:19:94: error: 'characters' is unavailable: Please use String\
    \ directly\n    let closeBracketCounts = brackets.split(separator: \" \").map(String.init).map({\
    \ String($0.characters.last!) }).reduce(into: [String: Int](), { $0[$1] = ($0[$1]!\
    \ + 1) })\n                                                                  \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBrackets = brackets\n    while openingBrackets.count > 0 {\n \
    \       let openingBracket = openingBrackets.first!\n        openingBrackets =\
    \ openingBrackets[1..<openingBrackets.count]\n        guard let closingBracket\
    \ = openingBrackets.first! else { return false }\n        openingBrackets = openingBrackets[1..<openingBrackets.count]\n\
    \        if openingBracket == closingBracket {\n            openingBrackets =\
    \ \"\"\n        } else {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp64iatyst.swift:16:27: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        openingBrackets = openingBrackets[1..<openingBrackets.count]\n      \
    \                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmp64iatyst.swift:17:15: error: initializer for\
    \ conditional binding must have Optional type, not 'String.Element' (aka 'Character')\n\
    \        guard let closingBracket = openingBrackets.first! else { return false\
    \ }\n              ^                    ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp64iatyst.swift:18:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n        openingBrackets = openingBrackets[1..<openingBrackets.count]\n\
    \                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.components(separatedBy: \"(\")\n    let closingBrackets\
    \ = brackets.components(separatedBy: \")\")\n    if openingBrackets.count == 0\
    \ && closingBrackets.count == 0 {\n        return true\n    }\n    return openingBrackets.count\
    \ == closingBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5b6ji4wg.swift:13:36: error: value of type 'String' has no member\
    \ 'components'\n    let openingBrackets = brackets.components(separatedBy: \"\
    (\")\n                          ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5b6ji4wg.swift:14:36:\
    \ error: value of type 'String' has no member 'components'\n    let closingBrackets\
    \ = brackets.components(separatedBy: \")\")\n                          ~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = [String]()\n    let closingBrackets = [String]()\n\
    \    for character in brackets {\n        if character == '(' || character ==\
    \ ')' {\n            if !openingBrackets.contains(character) {\n             \
    \   openingBrackets.append(character)\n            } else {\n                return\
    \ false\n            }\n        } else {\n            if character == ')' {\n\
    \                if closingBrackets.contains(character) {\n                  \
    \  return false\n                } else {\n                    closingBrackets.append(character)\n\
    \                }\n            }\n        }\n    }\n    return openingBrackets.count\
    \ == closingBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpn8gqi3d6.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '(' || character == ')' {\n              \
    \          ^~~\n                        \"(\"\n/tmp/tmpn8gqi3d6.swift:16:45: error:\
    \ single-quoted string literal found, use '\"'\n        if character == '(' ||\
    \ character == ')' {\n                                            ^~~\n      \
    \                                      \")\"\n/tmp/tmpn8gqi3d6.swift:23:29: error:\
    \ single-quoted string literal found, use '\"'\n            if character == ')'\
    \ {\n                            ^~~\n                            \")\"\n/tmp/tmpn8gqi3d6.swift:17:42:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            if !openingBrackets.contains(character) {\n                     \
    \                    ^\n/tmp/tmpn8gqi3d6.swift:18:33: error: no exact matches\
    \ in call to instance method 'append'\n                openingBrackets.append(character)\n\
    \                                ^\n/tmp/tmpn8gqi3d6.swift:18:33: note: found\
    \ candidate with type '(__owned String) -> ()'\n                openingBrackets.append(character)\n\
    \                                ^\n/tmp/tmpn8gqi3d6.swift:24:45: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \           if closingBrackets.contains(character) {\n                       \
    \                     ^\n/tmp/tmpn8gqi3d6.swift:27:37: error: no exact matches\
    \ in call to instance method 'append'\n                    closingBrackets.append(character)\n\
    \                                    ^\n/tmp/tmpn8gqi3d6.swift:27:37: note: found\
    \ candidate with type '(__owned String) -> ()'\n                    closingBrackets.append(character)\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var ok = false\n\n    for idx in 0..<brackets.characters.count {\n      \
    \  let open = brackets.characters[idx]\n        let close = brackets.characters[brackets.index(idx,\
    \ offsetBy: 1)]\n        if open != close {\n            ok = true\n         \
    \   break\n        }\n    }\n\n    return ok\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpw5z65a0d.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for idx in 0..<brackets.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpw5z65a0d.swift:16:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let open\
    \ = brackets.characters[idx]\n                   ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpw5z65a0d.swift:16:29:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ open = brackets.characters[idx]\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpw5z65a0d.swift:17:56: error: cannot convert\
    \ value of type 'Int' to expected argument type 'String.Index'\n        let close\
    \ = brackets.characters[brackets.index(idx, offsetBy: 1)]\n                  \
    \                                     ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    let openingBrackets = brackets.components(separatedBy: \"(\")\n    let closingBrackets\
    \ = brackets.components(separatedBy: \")\")\n    if openingBrackets.count != closingBrackets.count\
    \ {\n        return false\n    }\n\n    for i in 0..<openingBrackets.count {\n\
    \        if openingBrackets[i] != \"(\" && closingBrackets[i] != \")\" {\n   \
    \         return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp9jy330uq.swift:13:48: error: cannot find 'CharacterSet' in scope\n\
    \    brackets = brackets.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                               ^~~~~~~~~~~~\n/tmp/tmp9jy330uq.swift:13:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n   \
    \ ^~~~~~~~\n/tmp/tmp9jy330uq.swift:13:25: error: value of type 'String' has no\
    \ member 'trimmingCharacters'\n    brackets = brackets.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9jy330uq.swift:14:36: error: value of type 'String' has no member 'components'\n\
    \    let openingBrackets = brackets.components(separatedBy: \"(\")\n         \
    \                 ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp9jy330uq.swift:15:36: error: value\
    \ of type 'String' has no member 'components'\n    let closingBrackets = brackets.components(separatedBy:\
    \ \")\")\n                          ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening_brackets: [String]\n    var closing_brackets: [String]\n    if\
    \ brackets.count % 2 == 1 {\n        return false\n    }\n    opening_brackets\
    \ = brackets.characters\n    closing_brackets = brackets.characters.reversed()\n\
    \    var brackets_as_pairs: [String]\n    var brackets_as_pairs_count = brackets.count\n\
    \    while brackets_as_pairs_count > 0 {\n        var i = brackets_as_pairs.count\n\
    \        while i > 0 {\n            if brackets_as_pairs[i] == brackets_as_pairs[i-1]\
    \ {\n                break\n            }\n            i -= 1\n        }\n   \
    \     brackets_as_pairs.removeAtIndex(i)\n        brackets_as_pairs_count -= i\n\
    \    }\n    var opening_brackets_count: Int = 0\n    var closing_brackets_count:\
    \ Int = 0\n    for bracket_as_pair in brackets_as_pairs {\n        if bracket_as_pair\
    \ == \"(\" {\n            opening_brackets_count += 1\n        }\n        else\
    \ if bracket_as_pair == \")\" {\n            closing_brackets_count += 1\n   \
    \     }\n    }\n    if opening_brackets_count != closing_brackets_count {\n  \
    \      return false\n    }\n    var opening_bracket: Int = 0\n    var closing_bracket:\
    \ Int = 0\n    var brackets_as_pairs_count: Int = 0\n    for bracket_as_pair in\
    \ brackets_as_pairs {\n        if bracket_as_pair == \"(\" {\n            opening_bracket\
    \ = opening_bracket\n        }\n        else if bracket_as_pair == \")\" {\n \
    \           closing_bracket = closing_bracket\n        }\n        brackets_as_pairs_count\
    \ += 1\n    }\n    if closing_bracket > opening_bracket {\n        return false\n\
    \    }\n    if closing_bracket == opening_bracket {\n        return true\n   \
    \ }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1c6mhpkr.swift:18:33: error: cannot assign value of type 'String'\
    \ to type '[String]'\n    opening_brackets = brackets.characters\n           \
    \            ~~~~~~~~~^~~~~~~~~~\n/tmp/tmp1c6mhpkr.swift:19:44: error: cannot\
    \ assign value of type 'ReversedCollection<String>' to type '[String]'\n    closing_brackets\
    \ = brackets.characters.reversed()\n                       ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmp1c6mhpkr.swift:30:27: error: value of type '[String]' has no member 'removeAtIndex'\n\
    \        brackets_as_pairs.removeAtIndex(i)\n        ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmp1c6mhpkr.swift:48:9: error: invalid redeclaration of 'brackets_as_pairs_count'\n\
    \    var brackets_as_pairs_count: Int = 0\n        ^\n/tmp/tmp1c6mhpkr.swift:21:9:\
    \ note: 'brackets_as_pairs_count' previously declared here\n    var brackets_as_pairs_count\
    \ = brackets.count\n        ^\n/tmp/tmp1c6mhpkr.swift:51:29: error: assigning\
    \ a variable to itself\n            opening_bracket = opening_bracket\n      \
    \      ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~\n/tmp/tmp1c6mhpkr.swift:54:29: error:\
    \ assigning a variable to itself\n            closing_bracket = closing_bracket\n\
    \            ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let open_brackets = brackets.components(separatedBy: CharacterSet.symbols.inverted)\n\
    \    var correct_bracketing = false\n    for open_bracket in open_brackets {\n\
    \        if brackets.rangeOfCharacter(from: open_bracket) != nil {\n         \
    \   correct_bracketing = true\n            break\n        }\n    }\n    return\
    \ correct_bracketing\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpi44qw5i9.swift:13:58: error: cannot find 'CharacterSet' in scope\n\
    \    let open_brackets = brackets.components(separatedBy: CharacterSet.symbols.inverted)\n\
    \                                                         ^~~~~~~~~~~~\n/tmp/tmpi44qw5i9.swift:13:34:\
    \ error: value of type 'String' has no member 'components'\n    let open_brackets\
    \ = brackets.components(separatedBy: CharacterSet.symbols.inverted)\n        \
    \                ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.trim()\n\tbrackets = brackets.lowercased()\n\tvar open : [String]\n\
    \tvar close : [String]\n\tbrackets = brackets.replacingOccurrences(of: \"(\",\
    \ with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \")\", with: \"\
    \")\n\tbrackets = brackets.replacingOccurrences(of: \"()\", with: \"(\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \"[]\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"{}\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"()\"\
    , with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"<>\", with: \"\
    (\")\n\tbrackets = brackets.replacingOccurrences(of: \"{}\", with: \"(\")\n\t\
    brackets = brackets.replacingOccurrences(of: \"()\", with: \"(\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \"()()\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"(()())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"\
    (())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"()()\"\
    , with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"())\", with:\
    \ \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"(()())\", with: \"\
    (\")\n\tbrackets = brackets.replacingOccurrences(of: \"(())\", with: \"(\")\n\t\
    brackets = brackets.replacingOccurrences(of: \"()()\", with: \"(\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \"())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"(()())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"\
    (())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"()()\"\
    , with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"())\", with:\
    \ \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"(()())\", with: \"\
    (\")\n\tbrackets = brackets.replacingOccurrences(of: \"(())\", with: \"(\")\n\t\
    brackets = brackets.replacingOccurrences(of: \"{}\", \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1_ygcptw.swift:42:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp1_ygcptw.swift:13:2: error: cannot assign to value: 'brackets' is\
    \ a 'let' constant\n        brackets = brackets.trim()\n        ^~~~~~~~\n/tmp/tmp1_ygcptw.swift:13:22:\
    \ error: value of type 'String' has no member 'trim'\n        brackets = brackets.trim()\n\
    \                   ~~~~~~~~ ^~~~\n/tmp/tmp1_ygcptw.swift:14:2: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n        brackets = brackets.lowercased()\n\
    \        ^~~~~~~~\n/tmp/tmp1_ygcptw.swift:17:2: error: cannot assign to value:\
    \ 'brackets' is a 'let' constant\n        brackets = brackets.replacingOccurrences(of:\
    \ \"(\", with: \"(\")\n        ^~~~~~~~\n/tmp/tmp1_ygcptw.swift:17:22: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        brackets\
    \ = brackets.replacingOccurrences(of: \"(\", with: \"(\")\n                  \
    \ ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1_ygcptw.swift:18:2: error: cannot assign\
    \ to value: 'brackets' is a 'let' constant\n        brackets = brackets.replacingOccurrences(of:\
    \ \")\", with: \"\")\n        ^~~~~~~~\n/tmp/tmp1_ygcptw.swift:18:22: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n        brackets = brackets.replacingOccurrences(of:\
    \ \")\", with: \"\")\n                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1_ygcptw.swift:19:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingOccurrences(of: \"()\", with: \"(\")\n        ^~~~~~~~\n\
    /tmp/tmp1_ygcptw.swift:19:22: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        brackets = brackets.replacingOccurrences(of: \"()\", with: \"(\")\n \
    \                  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1_ygcptw.swift:20:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingOccurrences(of: \"[]\", with: \"(\")\n        ^~~~~~~~\n\
    /tmp/tmp1_ygcptw.swift:20:22: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        brackets = brackets.replacingOccurrences(of: \"[]\", with: \"(\")\n \
    \  "
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var stack: Stack = Stack()\n\tfor symbol in brackets {\n\t\tif symbol == '(' {\n\
    \t\t\tstack.push(symbol)\n\t\t} else if symbol == ')' {\n\t\t\tlet opening = stack.pop()\n\
    \t\t\tif opening.symbol != '(' {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\t\
    return !stack.empty()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7_nn_2ch.swift:15:16: error: single-quoted string literal found,\
    \ use '\"'\n                if symbol == '(' {\n                             ^~~\n\
    \                             \"(\"\n/tmp/tmp7_nn_2ch.swift:17:23: error: single-quoted\
    \ string literal found, use '\"'\n                } else if symbol == ')' {\n\
    \                                    ^~~\n                                   \
    \ \")\"\n/tmp/tmp7_nn_2ch.swift:19:25: error: single-quoted string literal found,\
    \ use '\"'\n                        if opening.symbol != '(' {\n             \
    \                                ^~~\n                                       \
    \      \"(\"\n/tmp/tmp7_nn_2ch.swift:13:13: error: cannot find type 'Stack' in\
    \ scope\n        var stack: Stack = Stack()\n                   ^~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let bracketsArray = brackets.characters.split{$0 == \")\" || $0 == \"(\"\
    }\n    let firstBracket = bracketsArray[0]\n    let lastBracket = bracketsArray[bracketsArray.count\
    \ - 1]\n    if firstBracket == lastBracket {\n        return true\n    }\n   \
    \ return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmplpfct7w4.swift:13:34: error: 'characters' is unavailable: Please\
    \ use String directly\n    let bracketsArray = brackets.characters.split{$0 ==\
    \ \")\" || $0 == \"(\"}\n                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets.characters.split(\"(\").count - 1\n    let closing\
    \ = brackets.characters.split(\")\").count - 1\n    return opening == closing\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_aso54dz.swift:13:39: error: no exact matches in call to instance\
    \ method 'split'\n    let opening = brackets.characters.split(\"(\").count - 1\n\
    \                                      ^\nSwift.Sequence:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n    \
    \                                   ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmp_aso54dz.swift:14:39: error: no exact matches\
    \ in call to instance method 'split'\n    let closing = brackets.characters.split(\"\
    )\").count - 1\n                                      ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = [String]()\n\n    for c in brackets {\n        if (c == \"(\"\
    \ || c == \")\") {\n            stack.append(c)\n        } else {\n          \
    \  if stack.last?.first == c {\n                stack.pop()\n            } else\
    \ {\n                return false\n            }\n        }\n    }\n\n    return\
    \ stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3tcz0vbj.swift:17:19: error: no exact matches in call to instance\
    \ method 'append'\n            stack.append(c)\n                  ^\n/tmp/tmp3tcz0vbj.swift:17:19:\
    \ note: found candidate with type '(__owned String) -> ()'\n            stack.append(c)\n\
    \                  ^\n/tmp/tmp3tcz0vbj.swift:20:23: error: value of type '[String]'\
    \ has no member 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let regex = NSRegularExpression(pattern: \"\\\\(|\\\\)\", options: nil, error:\
    \ nil)\n    let matches = regex.matches(in: brackets, range: NSMakeRange(0, brackets.count))\n\
    \    return matches.count == brackets.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmppita6r4d.swift:13:17: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = NSRegularExpression(pattern: \"\\\\(|\\\\)\", options:\
    \ nil, error: nil)\n                ^~~~~~~~~~~~~~~~~~~\n/tmp/tmppita6r4d.swift:13:66:\
    \ error: 'nil' requires a contextual type\n    let regex = NSRegularExpression(pattern:\
    \ \"\\\\(|\\\\)\", options: nil, error: nil)\n                               \
    \                                  ^\n/tmp/tmppita6r4d.swift:13:78: error: 'nil'\
    \ requires a contextual type\n    let regex = NSRegularExpression(pattern: \"\\\
    \\(|\\\\)\", options: nil, error: nil)\n                                     \
    \                                        ^\n/tmp/tmppita6r4d.swift:14:54: error:\
    \ cannot find 'NSMakeRange' in scope\n    let matches = regex.matches(in: brackets,\
    \ range: NSMakeRange(0, brackets.count))\n                                   \
    \                  ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketSet = [Character]()\n    var openingBracketCount = 0\n    \n \
    \   for bracket in brackets {\n        if bracket.isEmpty() {\n            bracketSet.removeAll()\n\
    \        } else {\n            bracketSet.append(bracket)\n            openingBracketCount\
    \ += 1\n        }\n    }\n    \n    for openingBracket in bracketSet {\n     \
    \   if openingBracketCount > 1 {\n            return false\n        }\n    }\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxfk_rola.swift:17:20: error: value of type 'Character' has no member\
    \ 'isEmpty'\n        if bracket.isEmpty() {\n           ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var balanced = false\n    for opening, closing := range brackets {\n    \
    \    if opening < closing {\n            balanced = true\n        } else {\n \
    \           balanced = false\n        }\n    }\n    return balanced\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpgt2lh04v.swift:14:16: error: expected 'in' after for-each pattern\n\
    \    for opening, closing := range brackets {\n               ^\n/tmp/tmpgt2lh04v.swift:14:16:\
    \ error: expected Sequence expression for for-each loop\n    for opening, closing\
    \ := range brackets {\n               ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty { return false }\n    var lastBracket = brackets.endIndex\n\
    \    for char in brackets.characters {\n        if char == \"(\" || char == \"\
    )\" {\n            if lastBracket < char.unicodeScalars.endIndex {\n         \
    \       return false\n            }\n            lastBracket = char.unicodeScalars.endIndex\n\
    \        }\n    }\n    return lastBracket == brackets.endIndex\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4too_7gf.swift:15:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in brackets.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack = brackets.characters.makeIterator()\n    var last = 0\n    while\
    \ !stack.isAtEnd {\n        var next = stack.next()\n        if next == \"(\"\
    \ {\n            if last == stack.pos {\n                stack = stack.next\n\
    \                last = stack.pos\n                continue // go back one more\
    \ time to check if it is still a opening\n            }\n            if stack.peek()\
    \ == \"(\" {\n                stack = stack.prev\n                last = stack.pos\n\
    \            } else {\n                return false\n            }\n        }\
    \ else if next == \")\" {\n            if last == stack.pos {\n              \
    \  stack = stack.next\n                last = stack.pos\n                continue\
    \ // go back one more time to check if it is still a opening\n            }\n\
    \            if stack.peek() == \")\" {\n                stack = stack.prev\n\
    \                last = stack.pos\n            } else {\n                return\
    \ false\n            }\n        } else {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpq0h7ydef.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    var stack = brackets.characters.makeIterator()\n  \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpq0h7ydef.swift:15:18: error: value of type 'String.Iterator'\
    \ has no member 'isAtEnd'\n    while !stack.isAtEnd {\n           ~~~~~ ^~~~~~~\n\
    /tmp/tmpq0h7ydef.swift:18:30: error: value of type 'String.Iterator' has no member\
    \ 'pos'\n            if last == stack.pos {\n                       ~~~~~ ^~~\n\
    /tmp/tmpq0h7ydef.swift:19:31: error: cannot assign value of type '() -> Character?'\
    \ to type 'String.Iterator'\n                stack = stack.next\n            \
    \            ~~~~~~^~~~\n/tmp/tmpq0h7ydef.swift:19:31: error: cannot reference\
    \ 'mutating' method as function value\n                stack = stack.next\n  \
    \                            ^\n/tmp/tmpq0h7ydef.swift:20:30: error: value of\
    \ type 'String.Iterator' has no member 'pos'\n                last = stack.pos\n\
    \                       ~~~~~ ^~~\n/tmp/tmpq0h7ydef.swift:23:22: error: value\
    \ of type 'String.Iterator' has no member 'peek'\n            if stack.peek()\
    \ == \"(\" {\n               ~~~~~ ^~~~\n/tmp/tmpq0h7ydef.swift:24:31: error:\
    \ value of type 'String.Iterator' has no member 'prev'\n                stack\
    \ = stack.prev\n                        ~~~~~ ^~~~\n/tmp/tmpq0h7ydef.swift:25:30:\
    \ error: value of type 'String.Iterator' has no member 'pos'\n               \
    \ last = stack.pos\n                       ~~~~~ ^~~\n/tmp/tmpq0h7ydef.swift:30:30:\
    \ error: value of type 'String.Iterator' has no member 'pos'\n            if last\
    \ == stack.pos {\n                       ~~~~~ ^~~\n/tmp/tmpq0h7ydef.swift:31:31:\
    \ error: cannot assign value of type '() -> Character?' to type 'String.Iterator'\n\
    \                stack = stack.next\n                        ~~~~~~^~~~\n/tmp/tmpq0h7ydef.swift:31:31:\
    \ error: cannot reference 'mutating' method as function value\n              \
    \  stack = stack.next\n                "
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets.count(\"(\") == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkiligm4z.swift:13:14: error: cannot call value of non-function\
    \ type 'Int'\n    brackets.count(\"(\") == 0\n             ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack = [String]()\n    var isMismatchedBracket = false\n    for char\
    \ in brackets {\n        if char == \")\" {\n            stack.removeLast()\n\
    \            if stack.last == \"\" {\n                isMismatchedBracket = true\n\
    \            }\n        }\n        else {\n            stack.append(char)\n  \
    \      }\n    }\n    return !isMismatchedBracket\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfnvbr3i9.swift:23:26: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            stack.append(char)\n       \
    \                  ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return false\n    }\n\n    var opening = brackets[0]\n\
    \    var closing = brackets[brackets.startIndex...]\n\n    for idx in 0 ..< brackets.count\
    \ {\n        if opening.unicodeScalars == nil || closing.unicodeScalars == nil\
    \ {\n            return false\n        }\n\n        if opening.unicodeScalars.count\
    \ != closing.unicodeScalars.count {\n            return false\n        }\n\n \
    \       if opening.unicodeScalars[0] != closing.unicodeScalars[0] {\n        \
    \    return false\n        }\n\n        opening = brackets[idx + 1]\n        closing\
    \ = brackets[brackets.startIndex + idx - 1]\n    }\n\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpwkbw5blu.swift:17:19: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var opening =\
    \ brackets[0]\n                  ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwkbw5blu.swift:21:35: warning: comparing\
    \ non-optional value of type 'Character.UnicodeScalarView' (aka 'String.UnicodeScalarView')\
    \ to 'nil' always returns false\n        if opening.unicodeScalars == nil || closing.unicodeScalars\
    \ == nil {\n           ~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~\n/tmp/tmpwkbw5blu.swift:21:68:\
    \ warning: comparing non-optional value of type 'Substring.UnicodeScalarView'\
    \ to 'nil' always returns false\n        if opening.unicodeScalars == nil || closing.unicodeScalars\
    \ == nil {\n                                            ~~~~~~~~~~~~~~~~~~~~~~\
    \ ^  ~~~\n/tmp/tmpwkbw5blu.swift:29:35: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.UnicodeScalarView.Index' (aka 'String.Index')\n\
    \        if opening.unicodeScalars[0] != closing.unicodeScalars[0] {\n       \
    \                           ^\n/tmp/tmpwkbw5blu.swift:29:64: error: cannot convert\
    \ value of type 'Int' to expected argument type 'Substring.UnicodeScalarView.Index'\
    \ (aka 'String.Index')\n        if opening.unicodeScalars[0] != closing.unicodeScalars[0]\
    \ {\n                                                               ^\n/tmp/tmpwkbw5blu.swift:33:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        opening = brackets[idx + 1]\n         \
    \         ^~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpwkbw5blu.swift:34:37: error: cannot convert value\
    \ of type 'String.Index' to expected argument type 'Int'\n        closing = brackets[brackets.startIndex\
    \ + idx - 1]\n                                    ^\n/tmp/tmpwkbw5blu.swift:34:2"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBrackets = brackets.characters\n    var closingBrackets = [String]()\n\
    \n    if openingBrackets.isEmpty { return true }\n\n    if openingBrackets.contains(CharacterSet(\"\
    ()\")) { return true }\n\n    var bracketCount = 0\n    var lastOpeningBracket:\
    \ Character?\n    while let openingBracket = openingBrackets.nextElement {\n \
    \       if lastOpeningBracket != nil {\n            if openingBracket.rawValue\
    \ == lastOpeningBracket!.rawValue {\n                bracketCount += 1\n     \
    \       } else {\n                closingBrackets.append(String(lastOpeningBracket!))\n\
    \                bracketCount = 0\n            }\n        }\n\n        lastOpeningBracket\
    \ = openingBracket\n    }\n\n    if bracketCount == openingBrackets.count {\n\
    \        return false\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3uml7gsk.swift:13:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    var openingBrackets = brackets.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3uml7gsk.swift:18:33: error: cannot find 'CharacterSet'\
    \ in scope\n    if openingBrackets.contains(CharacterSet(\"()\")) { return true\
    \ }\n                                ^~~~~~~~~~~~\n/tmp/tmp3uml7gsk.swift:22:48:\
    \ error: value of type 'String' has no member 'nextElement'\n    while let openingBracket\
    \ = openingBrackets.nextElement {\n                               ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~\n/tmp/tmp3uml7gsk.swift:24:63: error: value of type 'Character'\
    \ has no member 'rawValue'\n            if openingBracket.rawValue == lastOpeningBracket!.rawValue\
    \ {\n                                          ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return true\n    }\n    if brackets.contains(\"\
    (\") && brackets.contains(\")\") {\n        return true\n    }\n    if brackets.contains(\"\
    (\") && brackets.contains(\")\")  {\n        var opening = brackets.characters(in:\
    \ brackets.startIndex..<brackets.startIndex.advancedBy(1))\n        var closing\
    \ = brackets.characters(in: brackets.startIndex.advancedBy(1)..<brackets.endIndex)\n\
    \        if opening.count != closing.count {\n            return false\n     \
    \   }\n        var openings = opening.characters\n        var closings = closing.characters\n\
    \        for index in 0 ..< opening.count {\n            if openings[index] !=\
    \ closings[index] {\n                return false\n            }\n        }\n\
    \        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpleu70f3a.swift:20:32: error: cannot call value of non-function\
    \ type 'String'\n        var opening = brackets.characters(in: brackets.startIndex..<brackets.startIndex.advancedBy(1))\n\
    \                               ^\n/tmp/tmpleu70f3a.swift:20:89: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n        var opening = brackets.characters(in:\
    \ brackets.startIndex..<brackets.startIndex.advancedBy(1))\n                 \
    \                                                   ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpleu70f3a.swift:21:32: error: cannot call value of non-function type 'String'\n\
    \        var closing = brackets.characters(in: brackets.startIndex.advancedBy(1)..<brackets.endIndex)\n\
    \                               ^\n/tmp/tmpleu70f3a.swift:21:67: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n        var closing = brackets.characters(in:\
    \ brackets.startIndex.advancedBy(1)..<brackets.endIndex)\n                   \
    \                           ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return true\n    }\n\n    var opening = brackets[0]\n\
    \    var closing = brackets.substring(1)\n\n    return opening != closing && opening\
    \ != \")\" && closing != \"(\" && closing != \")\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpn11b5v42.swift:17:19: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var opening =\
    \ brackets[0]\n                  ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpn11b5v42.swift:18:28: error: value\
    \ of type 'String' has no member 'substring'\n    var closing = brackets.substring(1)\n\
    \                  ~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.lowercased()\n\tlet openingBrackets: [Character] = [ '(',\
    \ ')', '[', ']', '{', '}' ]\n\tlet closingBrackets: [Character] = [ '(', ')',\
    \ '[', ']', '{', '}' ]\n\tvar closed = false\n\tfor bracket in brackets {\n\t\t\
    for openBracket in openingBrackets {\n\t\t\tif bracket == openBracket {\n\t\t\t\
    \topeningBrackets.remove(openBracket)\n\t\t\t\tclosed = false\n\t\t\t}\n\t\t\t\
    if closed && openBracket == brackets.last! {\n\t\t\t\treturn false\n\t\t\t}\n\t\
    \t}\n\t\tfor closeBracket in closingBrackets {\n\t\t\tif bracket == closeBracket\
    \ {\n\t\t\t\tclosingBrackets.remove(closeBracket)\n\t\t\t\tclosed = true\n\t\t\
    \t}\n\t\t\tif closed && closeBracket == brackets.first! {\n\t\t\t\treturn false\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpofm7ite4.swift:14:39: error: single-quoted string literal found,\
    \ use '\"'\n        let openingBrackets: [Character] = [ '(', ')', '[', ']', '{',\
    \ '}' ]\n                                             ^~~\n                  \
    \                           \"(\"\n/tmp/tmpofm7ite4.swift:14:44: error: single-quoted\
    \ string literal found, use '\"'\n        let openingBrackets: [Character] = [\
    \ '(', ')', '[', ']', '{', '}' ]\n                                           \
    \       ^~~\n                                                  \")\"\n/tmp/tmpofm7ite4.swift:14:49:\
    \ error: single-quoted string literal found, use '\"'\n        let openingBrackets:\
    \ [Character] = [ '(', ')', '[', ']', '{', '}' ]\n                           \
    \                            ^~~\n                                           \
    \            \"[\"\n/tmp/tmpofm7ite4.swift:14:54: error: single-quoted string\
    \ literal found, use '\"'\n        let openingBrackets: [Character] = [ '(', ')',\
    \ '[', ']', '{', '}' ]\n                                                     \
    \       ^~~\n                                                            \"]\"\
    \n/tmp/tmpofm7ite4.swift:14:59: error: single-quoted string literal found, use\
    \ '\"'\n        let openingBrackets: [Character] = [ '(', ')', '[', ']', '{',\
    \ '}' ]\n                                                                 ^~~\n\
    \                                                                 \"{\"\n/tmp/tmpofm7ite4.swift:14:64:\
    \ error: single-quoted string literal found, use '\"'\n        let openingBrackets:\
    \ [Character] = [ '(', ')', '[', ']', '{', '}' ]\n                           \
    \                                           ^~~\n                            \
    \                                          \"}\"\n/tmp/tmpofm7ite4.swift:15:39:\
    \ error: single-quoted string literal found, use '\"'\n        let closingBrackets:\
    \ [Character] = [ '(', ')', '[', ']', '{', '}' ]\n                           \
    \                  ^~~\n                                             \"(\"\n/tmp/tmpofm7ite4.swift:15:44:\
    \ error: single-quoted string literal found, use '\"'\n        let closingBrackets:\
    \ [Ch"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var result = true\n    for b in brackets {\n        if !is_valid_opening_bracket(b)\
    \ {\n            result = false\n            break\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpaodurbu8.swift:15:13: error: cannot find 'is_valid_opening_bracket'\
    \ in scope\n        if !is_valid_opening_bracket(b) {\n            ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard let openingBracketsString = brackets.characters.split{$0 == CharacterSet.openingBrackets}\
    \ else { return true }\n    guard let closingBracketsString = brackets.characters.split{$0\
    \ == CharacterSet.closingBrackets} else { return true }\n    return openingBracketsString.count\
    \ == closingBracketsString.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmppy8rbj4i.swift:13:64: error: expected 'else' after 'guard' condition\n\
    \    guard let openingBracketsString = brackets.characters.split{$0 == CharacterSet.openingBrackets}\
    \ else { return true }\n                                                     \
    \          ^\n                                                               else\
    \ \n/tmp/tmppy8rbj4i.swift:13:65: error: anonymous closure argument not contained\
    \ in a closure\n    guard let openingBracketsString = brackets.characters.split{$0\
    \ == CharacterSet.openingBrackets} else { return true }\n                    \
    \                                            ^\n/tmp/tmppy8rbj4i.swift:13:100:\
    \ error: consecutive statements on a line must be separated by ';'\n    guard\
    \ let openingBracketsString = brackets.characters.split{$0 == CharacterSet.openingBrackets}\
    \ else { return true }\n                                                     \
    \                                              ^\n                           \
    \                                                                        ;\n/tmp/tmppy8rbj4i.swift:13:101:\
    \ error: expected expression\n    guard let openingBracketsString = brackets.characters.split{$0\
    \ == CharacterSet.openingBrackets} else { return true }\n                    \
    \                                                                            \
    \    ^\n/tmp/tmppy8rbj4i.swift:14:64: error: expected 'else' after 'guard' condition\n\
    \    guard let closingBracketsString = brackets.characters.split{$0 == CharacterSet.closingBrackets}\
    \ else { return true }\n                                                     \
    \          ^\n                                                               else\
    \ \n/tmp/tmppy8rbj4i.swift:14:65: error: anonymous closure argument not contained\
    \ in a closure\n    guard let closingBracketsString = brackets.characters.split{$0\
    \ == CharacterSet.closingBrackets} else { return true }\n                    \
    \                                            ^\n/tmp/tmppy8rbj4i.swift:14:100:\
    \ error: consecutive statements on a line must be separated by ';'\n    guard\
    \ let closingBracketsStr"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    switch brackets.characters.count {\n    case 0: return true\n    case 1:\
    \ return brackets.characters[0] == '('\n    case 2: return brackets.characters[0]\
    \ == '(' && brackets.characters[1] == ')'\n    case 3: return brackets.characters[0]\
    \ == '(' && brackets.characters[1] == ')' && brackets.characters[2] == ')'\n \
    \   case 4: return brackets.characters[0] == '(' && brackets.characters[1] ==\
    \ ')' && brackets.characters[2] == ')' && brackets.characters[3] == ')'\n    case\
    \ 5: return brackets.characters[0] == '(' && brackets.characters[1] == ')' &&\
    \ brackets.characters[2] == ')' && brackets.characters[3] == ')' && brackets.characters[4]\
    \ == ')'\n    default: return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpiopove3s.swift:15:46: error: single-quoted string literal found,\
    \ use '\"'\n    case 1: return brackets.characters[0] == '('\n               \
    \                              ^~~\n                                         \
    \    \"(\"\n/tmp/tmpiopove3s.swift:16:46: error: single-quoted string literal\
    \ found, use '\"'\n    case 2: return brackets.characters[0] == '(' && brackets.characters[1]\
    \ == ')'\n                                             ^~~\n                 \
    \                            \"(\"\n/tmp/tmpiopove3s.swift:16:79: error: single-quoted\
    \ string literal found, use '\"'\n    case 2: return brackets.characters[0] ==\
    \ '(' && brackets.characters[1] == ')'\n                                     \
    \                                         ^~~\n                              \
    \                                                \")\"\n/tmp/tmpiopove3s.swift:17:46:\
    \ error: single-quoted string literal found, use '\"'\n    case 3: return brackets.characters[0]\
    \ == '(' && brackets.characters[1] == ')' && brackets.characters[2] == ')'\n \
    \                                            ^~~\n                           \
    \                  \"(\"\n/tmp/tmpiopove3s.swift:17:79: error: single-quoted string\
    \ literal found, use '\"'\n    case 3: return brackets.characters[0] == '(' &&\
    \ brackets.characters[1] == ')' && brackets.characters[2] == ')'\n           \
    \                                                                   ^~~\n    \
    \                                                                          \"\
    )\"\n/tmp/tmpiopove3s.swift:17:112: error: single-quoted string literal found,\
    \ use '\"'\n    case 3: return brackets.characters[0] == '(' && brackets.characters[1]\
    \ == ')' && brackets.characters[2] == ')'\n                                  \
    \                                                                            \
    \ ^~~\n                                                                      \
    \                                         \")\"\n/tmp/tmpiopove3s.swift:18:46:\
    \ error: single-quoted string literal found, use '\"'\n    case 4: return brackets.characters[0]\
    \ == '(' && brackets.character"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening: [Int: Bool]\n    var closing: [Int: Bool]\n    for ch in brackets.unicodeScalars\
    \ {\n        let index = brackets.index(ch)\n        opening[index] = true\n \
    \       closing[index] = false\n    }\n    let len = brackets.unicodeScalars.count\n\
    \    for index in stride(from: len, to: len - 1, by: -1) {\n        let open =\
    \ opening[index]\n        let close = closing[index]\n        if open && !close\
    \ {\n            return false\n        } else if !open && close {\n          \
    \  return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp48m0me40.swift:16:30: error: no exact matches in call to instance\
    \ method 'index'\n        let index = brackets.index(ch)\n                   \
    \          ^\n/tmp/tmp48m0me40.swift:16:30: note: candidate expects value of type\
    \ 'String.Index' for parameter #1 (got 'Unicode.Scalar')\n        let index =\
    \ brackets.index(ch)\n                             ^\n/tmp/tmp48m0me40.swift:16:30:\
    \ note: candidate expects value of type 'String.Index' for parameter #1 (got 'Unicode.Scalar')\n\
    \        let index = brackets.index(ch)\n                             ^\n/tmp/tmp48m0me40.swift:16:30:\
    \ note: candidate expects value of type '(String.Element) throws -> Bool' (aka\
    \ '(Character) throws -> Bool') for parameter #1 (got 'Unicode.Scalar')\n    \
    \    let index = brackets.index(ch)\n                             ^\n/tmp/tmp48m0me40.swift:16:30:\
    \ note: candidate expects value of type 'String.Element' (aka 'Character') for\
    \ parameter #1 (got 'Unicode.Scalar')\n        let index = brackets.index(ch)\n\
    \                             ^\n/tmp/tmp48m0me40.swift:24:12: error: value of\
    \ optional type 'Bool?' must be unwrapped to a value of type 'Bool'\n        if\
    \ open && !close {\n           ^\n/tmp/tmp48m0me40.swift:24:12: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if open && !close {\n           ^\n                ?? <#default value#>\n\
    /tmp/tmp48m0me40.swift:24:12: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        if open && !close {\n        \
    \   ^\n               !\n/tmp/tmp48m0me40.swift:24:21: error: value of optional\
    \ type 'Bool?' must be unwrapped to a value of type 'Bool'\n        if open &&\
    \ !close {\n                    ^\n/tmp/tmp48m0me40.swift:24:21: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if open && !close {\n                    ^\n                    (     ??\
    \ <#default value#>)\n/tmp/tmp48m0me40.swift:24:21: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        if open &&\
    \ !close {\n    "
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var parenthesesNeeded = false\n    var bracketStack = [Character]()\n   \
    \ var bracketCount = 0\n    var currentBracket = Character(self)\n    for character\
    \ in brackets {\n        bracketStack.append(currentBracket)\n        if character\
    \ == '(' || character == '[' {\n            bracketCount++\n        } else if\
    \ character == ')' || character == ']' {\n            bracketCount--\n       \
    \ }\n        parenthesesNeeded = bracketCount > 0\n        currentBracket = bracketStack.pop()!\n\
    \    }\n    return parenthesesNeeded\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjsoyd0d5.swift:19:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '(' || character == '[' {\n              \
    \          ^~~\n                        \"(\"\n/tmp/tmpjsoyd0d5.swift:19:45: error:\
    \ single-quoted string literal found, use '\"'\n        if character == '(' ||\
    \ character == '[' {\n                                            ^~~\n      \
    \                                      \"[\"\n/tmp/tmpjsoyd0d5.swift:21:32: error:\
    \ single-quoted string literal found, use '\"'\n        } else if character ==\
    \ ')' || character == ']' {\n                               ^~~\n            \
    \                   \")\"\n/tmp/tmpjsoyd0d5.swift:21:52: error: single-quoted\
    \ string literal found, use '\"'\n        } else if character == ')' || character\
    \ == ']' {\n                                                   ^~~\n         \
    \                                          \"]\"\n/tmp/tmpjsoyd0d5.swift:16:36:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n    var currentBracket = Character(self)\n                       \
    \            ^~~~\n/tmp/tmpjsoyd0d5.swift:20:25: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            bracketCount++\n               \
    \         ^~\n/tmp/tmpjsoyd0d5.swift:22:25: error: cannot find operator '--' in\
    \ scope; did you mean '-= 1'?\n            bracketCount--\n                  \
    \      ^~\n/tmp/tmpjsoyd0d5.swift:25:39: error: value of type '[Character]' has\
    \ no member 'pop'\n        currentBracket = bracketStack.pop()!\n            \
    \             ~~~~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.trimmingCharacters(in: CharacterSet(charactersIn: \"\
    \ \\t\\n\\r\"))\n    if brackets.isEmpty() {\n        return false\n    }\n  \
    \  var stack = brackets.characters.reversed()\n    var opening = 1\n    var closing\
    \ = 1\n    for i in 0..<stack.count {\n        let c = stack[i]\n        switch\
    \ c {\n        case \".\":\n            closing = closing * 2 + 1\n        case\
    \ \"(\":\n            opening = opening + 1;\n            closing = closing *\
    \ 2 + 1\n        case \")\":\n            opening = opening - 1;\n           \
    \ closing = closing * 2 + 1\n        default:\n            if opening > closing\
    \ {\n                return false\n            }\n            opening = opening\
    \ - 1\n            closing = closing - 1\n        }\n    }\n    return opening\
    \ == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpf20vmelr.swift:13:48: error: cannot find 'CharacterSet' in scope\n\
    \    brackets = brackets.trimmingCharacters(in: CharacterSet(charactersIn: \"\
    \ \\t\\n\\r\"))\n                                               ^~~~~~~~~~~~\n\
    /tmp/tmpf20vmelr.swift:13:5: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n    brackets = brackets.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \" \\t\\n\\r\"))\n    ^~~~~~~~\n/tmp/tmpf20vmelr.swift:13:25: error: value of\
    \ type 'String' has no member 'trimmingCharacters'\n    brackets = brackets.trimmingCharacters(in:\
    \ CharacterSet(charactersIn: \" \\t\\n\\r\"))\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpf20vmelr.swift:14:17: error: cannot call value of non-function type 'Bool'\n\
    \    if brackets.isEmpty() {\n                ^      ~~\n                    \
    \   \n/tmp/tmpf20vmelr.swift:17:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    var stack = brackets.characters.reversed()\n      \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpf20vmelr.swift:21:22: error: no exact matches in call to subscript\
    \ \n        let c = stack[i]\n                     ^\nSwift.ReversedCollection:9:23:\
    \ note: candidate expects value of type 'ReversedCollection<String>.Index' for\
    \ parameter #1 (got 'Int')\n    @inlinable public subscript(position: ReversedCollection<Base>.Index)\
    \ -> ReversedCollection<Base>.Element { get }\n                      ^\nSwift.Collection:2:23:\
    \ note: candidate expects value of type 'Range<ReversedCollection<String>.Index>'\
    \ for parameter #1 (got 'Int')\n    @inlinable public subscript(bounds: Range<Self.Index>)\
    \ -> Slice<Self> { get }\n                      ^\nSwift.Collection:3:23: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.characters.split(CharacterSet.init(charactersIn:\
    \ \"()\"))\n        .map { String($0) }\n    let closingBrackets = brackets.characters.split(CharacterSet.init(charactersIn:\
    \ \"\")).map { String($0) }\n\n    let setOfOpeningBrackets = Set(openingBrackets)\n\
    \    let setOfClosingBrackets = Set(closingBrackets)\n\n    for (index, value)\
    \ in openingBrackets.enumerated() {\n        if !setOfClosingBrackets.contains(String(value))\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp84r9lqtg.swift:13:53: error: cannot find 'CharacterSet' in scope\n\
    \    let openingBrackets = brackets.characters.split(CharacterSet.init(charactersIn:\
    \ \"()\"))\n                                                    ^~~~~~~~~~~~\n\
    /tmp/tmp84r9lqtg.swift:13:53: error: missing argument label 'separator:' in call\n\
    \    let openingBrackets = brackets.characters.split(CharacterSet.init(charactersIn:\
    \ \"()\"))\n                                                    ^\n          \
    \                                          separator: \n/tmp/tmp84r9lqtg.swift:15:53:\
    \ error: cannot find 'CharacterSet' in scope\n    let closingBrackets = brackets.characters.split(CharacterSet.init(charactersIn:\
    \ \"\")).map { String($0) }\n                                                \
    \    ^~~~~~~~~~~~\n/tmp/tmp84r9lqtg.swift:15:53: error: missing argument label\
    \ 'separator:' in call\n    let closingBrackets = brackets.characters.split(CharacterSet.init(charactersIn:\
    \ \"\")).map { String($0) }\n                                                \
    \    ^\n                                                    separator: \n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let brackets = brackets.lowercased()\n\n    // TODO: Remove after dropping\
    \ support for Swift 2.3\n    if #available(OSX 10.10, iOS 8.0, watchOS 2.0, tvOS\
    \ 9.0, *)  {\n        let scanner  = NSScanner(string: brackets)\n        let\
    \ tokens   = scanner.scanUpToString(\")\", intoString: nil)\n        scanner.scanLocation\
    \ = 1\n        let tokens2 = scanner.scanUpToString(\"(\", intoString: nil)\n\
    \        scanner.scanLocation = tokens2.count\n        return tokens != nil &&\
    \ tokens2 == nil\n    } else {\n        return brackets.range(of: \")\") == nil\
    \ && brackets.range(of: \"(\") == nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkjj75j07.swift:17:24: error: cannot find 'NSScanner' in scope\n\
    \        let scanner  = NSScanner(string: brackets)\n                       ^~~~~~~~~\n\
    /tmp/tmpkjj75j07.swift:18:64: error: 'nil' requires a contextual type\n      \
    \  let tokens   = scanner.scanUpToString(\")\", intoString: nil)\n           \
    \                                                    ^\n/tmp/tmpkjj75j07.swift:20:63:\
    \ error: 'nil' requires a contextual type\n        let tokens2 = scanner.scanUpToString(\"\
    (\", intoString: nil)\n                                                      \
    \        ^\n/tmp/tmpkjj75j07.swift:24:25: error: value of type 'String' has no\
    \ member 'range'\n        return brackets.range(of: \")\") == nil && brackets.range(of:\
    \ \"(\") == nil\n               ~~~~~~~~ ^~~~~\n/tmp/tmpkjj75j07.swift:24:59:\
    \ error: value of type 'String' has no member 'range'\n        return brackets.range(of:\
    \ \")\") == nil && brackets.range(of: \"(\") == nil\n                        \
    \                         ~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.characters.split{$0 == \" \"}.map(String.init)\n\
    \    let closingBrackets = brackets.characters.split{$0 == \"(\"}.map(String.init)\n\
    \n    // Check that the length of each opening bracket is equal to the number\
    \ of closing\n    // brackets\n    for index in 0..<openingBrackets.count {\n\
    \        // We need to check that the closing brackets have a corresponding opening\
    \ bracket\n        if openingBrackets[index].count != closingBrackets.count {\n\
    \            return false\n        }\n\n        // Check that the closing brackets\
    \ are the same as the corresponding opening brackets\n        for secondIndex\
    \ in 0..<openingBrackets[index].count {\n            if openingBrackets[index][secondIndex]\
    \ != closingBrackets[secondIndex] {\n                return false\n          \
    \  }\n        }\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3xjdngl_.swift:13:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let openingBrackets = brackets.characters.split{$0\
    \ == \" \"}.map(String.init)\n                                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3xjdngl_.swift:14:36:\
    \ error: 'characters' is unavailable: Please use String directly\n    let closingBrackets\
    \ = brackets.characters.split{$0 == \"(\"}.map(String.init)\n                \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp3xjdngl_.swift:26:31: error: no exact matches in call to subscript\
    \ \n            if openingBrackets[index][secondIndex] != closingBrackets[secondIndex]\
    \ {\n                              ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Array:17:23:\
    \ note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n\
    \    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {\
    \ get set }\n                      ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\nSwift.MutableCollection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n\
    \                      ^\n/tmp/tmp3xjdngl_.swift:26:38: error: no exact matches\
    \ in call to subscript \n            if openingBrackets[index][secondIndex] !=\
    \ closingBrackets[secondIndex] {\n                                     ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ ("
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard brackets.isEmpty == false else {\n        return true\n    }\n\n  \
    \  var openingBrackets: Set<Character> = Set()\n    var closingBrackets: Set<Character>\
    \ = Set()\n\n    for i in 0..<brackets.characters.count {\n        let char: Character\
    \ = brackets.characters[i]\n        if char == \"(\" {\n            openingBrackets.insert(char)\n\
    \        } else {\n            closingBrackets.insert(char)\n        }\n    }\n\
    \n    return openingBrackets.isSubset(of: closingBrackets)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_rljr57b.swift:20:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<brackets.characters.count {\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_rljr57b.swift:21:31: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char:\
    \ Character = brackets.characters[i]\n                              ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp_rljr57b.swift:21:40:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char: Character = brackets.characters[i]\n                                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening = brackets.characters\n    opening = remove_brackets(opening)\n\
    \    opening = opening.characters.sorted()\n    var closing = brackets.characters\n\
    \    closing = remove_brackets(closing)\n    closing = closing.characters.sorted()\n\
    \    return opening.count == closing.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbku6ik86.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    var opening = brackets.characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpbku6ik86.swift:14:15: error: cannot find 'remove_brackets' in scope\n\
    \    opening = remove_brackets(opening)\n              ^~~~~~~~~~~~~~~\n/tmp/tmpbku6ik86.swift:15:34:\
    \ error: cannot assign value of type '[String.Element]' (aka 'Array<Character>')\
    \ to type 'String'\n    opening = opening.characters.sorted()\n              ~~~~~~~~~~~~~~~~~~~^~~~~~~~\n\
    /tmp/tmpbku6ik86.swift:16:28: error: 'characters' is unavailable: Please use String\
    \ directly\n    var closing = brackets.characters\n                          \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpbku6ik86.swift:17:15:\
    \ error: cannot find 'remove_brackets' in scope\n    closing = remove_brackets(closing)\n\
    \              ^~~~~~~~~~~~~~~\n/tmp/tmpbku6ik86.swift:18:34: error: cannot assign\
    \ value of type '[String.Element]' (aka 'Array<Character>') to type 'String'\n\
    \    closing = closing.characters.sorted()\n              ~~~~~~~~~~~~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let firstOpenBracket = brackets.index(\"(\")\n    let lastClosedBracket =\
    \ brackets.lastIndexOf(\")\")\n    return firstOpenBracket <= lastClosedBracket\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4sp0j4k9.swift:13:43: error: missing argument label 'of:' in call\n\
    \    let firstOpenBracket = brackets.index(\"(\")\n                          \
    \                ^\n                                          of: \n/tmp/tmp4sp0j4k9.swift:14:38:\
    \ error: value of type 'String' has no member 'lastIndexOf'\n    let lastClosedBracket\
    \ = brackets.lastIndexOf(\")\")\n                            ~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.Trim()\n\n\tbrackets = brackets.Replace(\"((\", \"(\")\n\t\
    brackets = brackets.Replace(\"(,\", \",(\")\n\tbrackets = brackets.Replace(\"\
    )(\", \")(\")\n\tbrackets = brackets.Replace(\"))\", \"))\")\n\tbrackets = brackets.Replace(\"\
    ))\", \")\")\n\tbrackets = brackets.Replace(\"))\", \")\")\n\tbrackets = brackets.Replace(\"\
    ))\", \")\")\n\tbrackets = brackets.Replace(\"))\", \")\")\n\n\tbrackets = brackets.Replace(\"\
    (\", \")\")\n\tbrackets = brackets.Replace(\",\", \",\")\n\tbrackets = brackets.Replace(\"\
    )\", \")\")\n\tbrackets = brackets.Replace(\",\", \",\")\n\tbrackets = brackets.Replace(\"\
    )\", \")\")\n\tbrackets = brackets.Replace(\")\", \")\")\n\tbrackets = brackets.Replace(\"\
    )\", \")\")\n\tbrackets = brackets.Replace(\")\", \")\")\n\tbrackets = brackets.Replace(\"\
    )\", \")\")\n\n\treturn brackets.Count() == brackets.Length()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpd8t7f85l.swift:13:2: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n        brackets = brackets.Trim()\n        ^~~~~~~~\n\
    /tmp/tmpd8t7f85l.swift:13:22: error: value of type 'String' has no member 'Trim'\n\
    \        brackets = brackets.Trim()\n                   ~~~~~~~~ ^~~~\n/tmp/tmpd8t7f85l.swift:15:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.Replace(\"((\", \"(\")\n        ^~~~~~~~\n/tmp/tmpd8t7f85l.swift:15:22:\
    \ error: value of type 'String' has no member 'Replace'\n        brackets = brackets.Replace(\"\
    ((\", \"(\")\n                   ~~~~~~~~ ^~~~~~~\n/tmp/tmpd8t7f85l.swift:16:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.Replace(\"(,\", \",(\")\n        ^~~~~~~~\n/tmp/tmpd8t7f85l.swift:16:22:\
    \ error: value of type 'String' has no member 'Replace'\n        brackets = brackets.Replace(\"\
    (,\", \",(\")\n                   ~~~~~~~~ ^~~~~~~\n/tmp/tmpd8t7f85l.swift:17:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.Replace(\")(\", \")(\")\n        ^~~~~~~~\n/tmp/tmpd8t7f85l.swift:17:22:\
    \ error: value of type 'String' has no member 'Replace'\n        brackets = brackets.Replace(\"\
    )(\", \")(\")\n                   ~~~~~~~~ ^~~~~~~\n/tmp/tmpd8t7f85l.swift:18:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.Replace(\"))\", \"))\")\n        ^~~~~~~~\n/tmp/tmpd8t7f85l.swift:18:22:\
    \ error: value of type 'String' has no member 'Replace'\n        brackets = brackets.Replace(\"\
    ))\", \"))\")\n                   ~~~~~~~~ ^~~~~~~\n/tmp/tmpd8t7f85l.swift:19:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.Replace(\"))\", \")\")\n        ^~~~~~~~\n/tmp/tmpd8t7f85l.swift:19:22:\
    \ error: value of type 'String' has no member 'Replace'\n        brackets = brackets.Replace(\"\
    ))\", \")\")\n                   ~~~~~~~~ ^~~~~~~\n/tmp/tmpd8t7f85l.swift:20:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.Replace(\"))\", \")\")\n  "
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var count = 0\n    var last = 0\n    for i := 0; i < len(brackets); i++ {\n\
    \        switch brackets[i] {\n        case \"(\":\n            count++\n    \
    \    case \"{\":\n            count++\n        case \"}\":\n            count--\n\
    \        case \"(\":\n            count--\n        default:\n            break\n\
    \        }\n        if count == 0 {\n            last = i\n        }\n    }\n\
    \    return last == len(brackets)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpirnc5bbs.swift:15:12: error: expected type\n    for i := 0; i <\
    \ len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpirnc5bbs.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets);\
    \ i++ {\n           ^\n/tmp/tmpirnc5bbs.swift:15:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n   \
    \        ^\n/tmp/tmpirnc5bbs.swift:32:20: error: cannot find 'len' in scope\n\
    \    return last == len(brackets)\n                   ^~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.stringByReplacingOccurrencesOfString(\"(\", withString: \"\
    [\")\n\tbrackets = brackets.stringByReplacingOccurrencesOfString\")\", withString:\
    \ \"]\")\n\tbrackets = brackets.stringByReplacingOccurrencesOfString(\"[\", withString:\
    \ \"(\")\n\tbrackets = brackets.stringByReplacingOccurrencesOfString(\"]\", withString:\
    \ \")\")\n\n\tfor _, bracket in brackets.stringByReplacingOccurrencesOfString(\"\
    [\", withString: \"\").stringByReplacingOccurrencesOfString(\"]\", withString:\
    \ \"\").split() {\n\t\tif bracket.isEmpty() {\n\t\t\treturn false\n\t\t}\n\t}\n\
    \treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkcjhmd6i.swift:14:58: error: consecutive statements on a line must\
    \ be separated by ';'\n        brackets = brackets.stringByReplacingOccurrencesOfString\"\
    )\", withString: \"]\")\n                                                    \
    \            ^\n                                                             \
    \   ;\n/tmp/tmpkcjhmd6i.swift:14:61: error: consecutive statements on a line must\
    \ be separated by ';'\n        brackets = brackets.stringByReplacingOccurrencesOfString\"\
    )\", withString: \"]\")\n                                                    \
    \               ^\n                                                          \
    \         ;\n/tmp/tmpkcjhmd6i.swift:14:61: error: expected expression\n      \
    \  brackets = brackets.stringByReplacingOccurrencesOfString\")\", withString:\
    \ \"]\")\n                                                                   ^\n\
    /tmp/tmpkcjhmd6i.swift:18:7: error: expected 'in' after for-each pattern\n   \
    \     for _, bracket in brackets.stringByReplacingOccurrencesOfString(\"[\", withString:\
    \ \"\").stringByReplacingOccurrencesOfString(\"]\", withString: \"\").split()\
    \ {\n             ^\n/tmp/tmpkcjhmd6i.swift:18:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, bracket in brackets.stringByReplacingOccurrencesOfString(\"\
    [\", withString: \"\").stringByReplacingOccurrencesOfString(\"]\", withString:\
    \ \"\").split() {\n             ^\n/tmp/tmpkcjhmd6i.swift:13:2: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    (\", withString: \"[\")\n        ^~~~~~~~\n/tmp/tmpkcjhmd6i.swift:13:22: error:\
    \ value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \        brackets = brackets.stringByReplacingOccurrencesOfString(\"(\", withString:\
    \ \"[\")\n                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkcjhmd6i.swift:14:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.stringByReplacingOccurrencesOfString\")\", withString: \"]\")\n \
    \       ^~~~~~~~\n/tmp/tmpkcjhmd6i.swift:14:22: error: value"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    switch {\n\tcase brackets == \"(\":\n\t\treturn false\n\tcase brackets == \"()\"\
    :\n\t\treturn true\n\tcase brackets == \"(()())\":\n\t\treturn true\n\tcase brackets\
    \ == \")((\":\n\t\treturn false\n\tdefault:\n\t\treturn false\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpyyjb0pgi.swift:13:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening_bracket = brackets[0]\n    var closing_bracket = brackets[brackets.endIndex-1]\n\
    \    for char in brackets {\n        // Don't allow a closing bracket without\
    \ an opening bracket to match.\n        // This prevents a trailing closing bracket\
    \ from matching a leading opening bracket.\n        if opening_bracket == \"(\"\
    \ && (char == \"(\" || char == \")\") {\n            return false\n        }\n\
    \        // Don't allow a closing bracket without an opening bracket to match.\n\
    \        // This prevents a trailing closing bracket from matching a trailing\
    \ opening bracket.\n        if closing_bracket == \"(\" && (char == \"(\" || char\
    \ == \")\") {\n            return false\n        }\n        // Don't allow an\
    \ opening bracket without an closing bracket to match.\n        // This prevents\
    \ an opening bracket from matching a closing bracket without an opening one.\n\
    \        if opening_bracket == \"(\" && char == \")\" {\n            return false\n\
    \        }\n        // Don't allow a closing bracket without an opening bracket\
    \ to match.\n        // This prevents a trailing closing bracket from matching\
    \ a leading opening bracket.\n        if closing_bracket == \"(\" && char == \"\
    (\" {\n            return false\n        }\n        // Don't allow an opening\
    \ bracket without an closing bracket to match.\n        // This prevents an opening\
    \ bracket from matching a closing bracket without an opening one.\n        if\
    \ closing_bracket == \")\" && char == \"(\" {\n            return false\n    \
    \    }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3u6jl__q.swift:13:27: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var opening_bracket\
    \ = brackets[0]\n                          ^~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp3u6jl__q.swift:14:45: error:\
    \ cannot convert value of type 'String.Index' to expected argument type 'Int'\n\
    \    var closing_bracket = brackets[brackets.endIndex-1]\n                   \
    \                         ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = [String]()\n    \n    let openingBrackets = brackets.characters\n\
    \        .filter { $0 != \"(\" && $0 != \")\" }\n    \n    for char in openingBrackets\
    \ {\n        if char == \")\" {\n            stack.removeLast()\n        } else\
    \ if char == \"(\" {\n            stack.insert(char, true)\n        }\n    }\n\
    \    return !stack.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8xa_rswp.swift:15:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let openingBrackets = brackets.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8xa_rswp.swift:20:19: error: cannot use mutating member\
    \ on immutable value: 'stack' is a 'let' constant\n            stack.removeLast()\n\
    \            ~~~~~ ^\n/tmp/tmp8xa_rswp.swift:13:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let stack = [String]()\n    ^~~\n    var\n/tmp/tmp8xa_rswp.swift:22:25:\
    \ error: missing argument labels 'contentsOf:at:' in call\n            stack.insert(char,\
    \ true)\n                        ^\n                         contentsOf:  at:\
    \ \n/tmp/tmp8xa_rswp.swift:22:32: error: cannot convert value of type 'Bool' to\
    \ expected argument type 'Array<String>.Index' (aka 'Int')\n            stack.insert(char,\
    \ true)\n                               ^\n/tmp/tmp8xa_rswp.swift:22:19: error:\
    \ cannot use mutating member on immutable value: 'stack' is a 'let' constant\n\
    \            stack.insert(char, true)\n            ~~~~~ ^\n/tmp/tmp8xa_rswp.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let stack = [String]()\n\
    \    ^~~\n    var\n/tmp/tmp8xa_rswp.swift:22:13: error: instance method 'insert(contentsOf:at:)'\
    \ requires that 'Character' conform to 'Collection'\n            stack.insert(char,\
    \ true)\n            ^\nSwift.RangeReplaceableCollection:7:37: note: where 'C'\
    \ = 'Character'\n    @inlinable public mutating func insert<C>(contentsOf newElements:\
    \ __owned C, at i: Self.Index) where C : Collection, Self.Element == C.Element\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketsStack: [Char] = []\n    for character in brackets {\n       \
    \ if character == \"(\" {\n            bracketsStack.append(character)\n     \
    \   }\n        if character == \")\" {\n            if bracketsStack.count ==\
    \ 0 {\n                return false\n            }\n            if bracketsStack.last\
    \ != \"(\" {\n                return false\n            }\n            bracketsStack.removeLast()\n\
    \        }\n    }\n    return bracketsStack.count == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbi56_g8b.swift:13:25: error: cannot find type 'Char' in scope\n\
    \    var bracketsStack: [Char] = []\n                        ^~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack: Stack = Stack()\n    for bracket in brackets {\n        switch\
    \ bracket {\n        case \"(\":\n            stack.append(bracket)\n        case\
    \ \"[\":\n            stack.append(bracket)\n        case \"{\":\n           \
    \ stack.append(bracket)\n        case \"\\\"\":\n            // \"\n         \
    \   if stack.count != 0 {\n                switch stack.last {\n             \
    \   case \"[\", \"{\", \"(\":\n                    stack.removeLast()\n      \
    \          case \"\\\"\":\n                    stack.removeLast()\n          \
    \      default:\n                    stack.removeLast()\n                }\n \
    \           }\n        default:\n            if stack.last == \"\" {\n       \
    \         stack.removeLast()\n            }\n        }\n    }\n    return stack.count\
    \ == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_tejrvkk.swift:13:16: error: cannot find type 'Stack' in scope\n\
    \    var stack: Stack = Stack()\n               ^~~~~\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets[brackets.startIndex..<brackets.endIndex.predecessor()]\n\t\
    brackets = brackets[1..<brackets.startIndex]\n\n\tvar openingBrackets = [String]()\n\
    \tvar closingBrackets = [String]()\n\n\tfor char in brackets {\n\t\tif char ==\
    \ \")\" {\n\t\t\tif openingBrackets.last != \"\" {\n\t\t\t\treturn false\n\t\t\
    \t}\n\t\t\tclosingBrackets.append(char)\n\t\t} else {\n\t\t\tif char == \"(\"\
    \ {\n\t\t\t\tif !openingBrackets.contains(char) {\n\t\t\t\t\treturn false\n\t\t\
    \t\t}\n\t\t\t} else {\n\t\t\t\tif !closingBrackets.contains(char) {\n\t\t\t\t\t\
    return false\n\t\t\t\t}\n\t\t\t}\n\t\t\topeningBrackets.append(char)\n\t\t}\n\t\
    }\n\n\treturn openingBrackets.count == closingBrackets.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5zqdat7t.swift:13:62: error: value of type 'String.Index' has no\
    \ member 'predecessor'\n        brackets = brackets[brackets.startIndex..<brackets.endIndex.predecessor()]\n\
    \                                                  ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n\
    /tmp/tmp5zqdat7t.swift:13:2: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n        brackets = brackets[brackets.startIndex..<brackets.endIndex.predecessor()]\n\
    \        ^~~~~~~~\n/tmp/tmp5zqdat7t.swift:13:21: error: cannot assign value of\
    \ type 'Substring' to type 'String'\n        brackets = brackets[brackets.startIndex..<brackets.endIndex.predecessor()]\n\
    \                   ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                   String(                                                  \
    \      )\n/tmp/tmp5zqdat7t.swift:14:2: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n        brackets = brackets[1..<brackets.startIndex]\n\
    \        ^~~~~~~~\n/tmp/tmp5zqdat7t.swift:14:35: error: cannot convert value of\
    \ type 'String.Index' to expected argument type 'Int'\n        brackets = brackets[1..<brackets.startIndex]\n\
    \                                         ^\n/tmp/tmp5zqdat7t.swift:24:27: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                        closingBrackets.append(char)\n                      \
    \                         ^\n/tmp/tmp5zqdat7t.swift:27:34: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \                   if !openingBrackets.contains(char) {\n                   \
    \                                          ^\n/tmp/tmp5zqdat7t.swift:31:34: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                                if !closingBrackets.contains(char) {\n      \
    \                                                       ^\n/tmp/tmp5zqdat7t.swift:35:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                        openingBrackets.append(char)\n               "
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBracketsCount = [Character: Int]()\n    for char in brackets {\n\
    \        if openingBracketsCount[char] != 0 {\n            return false\n    \
    \    } else {\n            openingBracketsCount[char] = -1\n        }\n    }\n\
    \    var lastChar: Character?\n    for char in brackets {\n        if let count\
    \ = openingBracketsCount[char] {\n            openingBracketsCount[char] = count\
    \ + 1\n        } else {\n            openingBracketsCount[char] = 1\n        }\n\
    \        if openingBracketsCount[lastChar] != -1 {\n            return false\n\
    \        }\n        lastChar = char\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpywzelvfv.swift:28:33: error: value of optional type 'Character?'\
    \ must be unwrapped to a value of type 'Character'\n        if openingBracketsCount[lastChar]\
    \ != -1 {\n                                ^\n/tmp/tmpywzelvfv.swift:28:33: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        if openingBracketsCount[lastChar] != -1 {\n                         \
    \       ^\n                                         ?? <#default value#>\n/tmp/tmpywzelvfv.swift:28:33:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if openingBracketsCount[lastChar] != -1 {\n                 \
    \               ^\n                                        !\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketCount = 0\n\n    for bracket in brackets {\n        bracketCount\
    \ += bracket.count\n    }\n\n    return bracketCount > 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6o2vz5mk.swift:16:33: error: value of type 'Character' has no member\
    \ 'count'\n        bracketCount += bracket.count\n                        ~~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openings = brackets.components(separatedBy: \"(\")\n        .map { String($0)\
    \ }\n    let closings = brackets.components(separatedBy: \")\")\n        .map\
    \ { String($0) }\n    guard openings.count == closings.count else { return false\
    \ }\n    guard openings.first == closings.last else { return false }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6_5ies1g.swift:13:29: error: value of type 'String' has no member\
    \ 'components'\n    let openings = brackets.components(separatedBy: \"(\")\n \
    \                  ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp6_5ies1g.swift:15:29: error: value\
    \ of type 'String' has no member 'components'\n    let closings = brackets.components(separatedBy:\
    \ \")\")\n                   ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets.characters.split{$0 == \")\"}.count != 0\n    let\
    \ closing = brackets.characters.split{$0 == \"(\"}.count != 0\n    return opening\
    \ && closing\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpk_9od3ey.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let opening = brackets.characters.split{$0 == \")\"\
    }.count != 0\n                           ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpk_9od3ey.swift:14:28: error: 'characters'\
    \ is unavailable: Please use String directly\n    let closing = brackets.characters.split{$0\
    \ == \"(\"}.count != 0\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    for opening in brackets {\n        let lastIndex = opening.characters.count\
    \ - 1\n        for open in brackets.characters.reverse() {\n            let index\
    \ = brackets.index(open, offsetBy: -opening.characters.count)\n            let\
    \ closing = brackets[index..<lastIndex]\n            if opening == closing {\n\
    \                return true\n            }\n        }\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmphkm40k68.swift:14:33: error: value of type 'Character' has no member\
    \ 'characters'\n        let lastIndex = opening.characters.count - 1\n       \
    \                 ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphkm40k68.swift:15:41: error: value\
    \ of type 'String' has no member 'reverse'\n        for open in brackets.characters.reverse()\
    \ {\n                    ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmphkm40k68.swift:16:65:\
    \ error: value of type 'Character' has no member 'characters'\n            let\
    \ index = brackets.index(open, offsetBy: -opening.characters.count)\n        \
    \                                                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: -4
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var count = 0\n    for c in brackets {\n        if c == \")\" {\n       \
    \     count += 1\n        } else if c == \"(\" {\n            if count > 0 {\n\
    \                return false\n            }\n            count = 1\n        }\
    \ else {\n            return false\n        }\n    }\n    return count == 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\n\
    assert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: Exception
  stderr: 'tmp0gy22brc/tmp0gy22brc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1513f90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1513c87b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1513c87988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1513c867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0gy22brc                        0x0000563ece08040b <unavailable> + 5131

    5    libc.so.6                          0x00002b151417c460 __libc_start_main +
    245

    6    tmp0gy22brc                        0x0000563ece080099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening_brackets = brackets.characters\n        .filter({ $0 == \"(\"\
    \ })\n        .sorted()\n        .reversed()\n    let closing_brackets = brackets.characters\n\
    \        .filter({ $0 == \")\" })\n        .sorted()\n        .reversed()\n  \
    \  if opening_brackets.last != closing_brackets.first {\n        return false\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpivon9abp.swift:13:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    let opening_brackets = brackets.characters\n      \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpivon9abp.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let closing_brackets = brackets.characters\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.lowercased()\n\topeningBracketsCount = brackets.count(\"(\"\
    )\n\tclosingBracketsCount = brackets.count(\")\")\n\tfor i := 0; i < openingBracketsCount;\
    \ i++ {\n\t\tif closingBracketsCount <= i {\n\t\t\treturn false\n\t\t}\n\t\tif\
    \ brackets[i] != brackets[closingBracketsCount] {\n\t\t\treturn false\n\t\t}\n\
    \t\tclosingBracketsCount--\n\t}\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpl_fm5vaq.swift:16:9: error: expected type\n        for i := 0;\
    \ i < openingBracketsCount; i++ {\n               ^\n                <#type#>\n\
    /tmp/tmpl_fm5vaq.swift:16:9: error: expected 'in' after for-each pattern\n   \
    \     for i := 0; i < openingBracketsCount; i++ {\n               ^\n/tmp/tmpl_fm5vaq.swift:16:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < openingBracketsCount; i++ {\n               ^\n/tmp/tmpl_fm5vaq.swift:13:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.lowercased()\n        ^~~~~~~~\n/tmp/tmpl_fm5vaq.swift:14:2: error:\
    \ cannot find 'openingBracketsCount' in scope\n        openingBracketsCount =\
    \ brackets.count(\"(\")\n        ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpl_fm5vaq.swift:14:34:\
    \ error: cannot call value of non-function type 'Int'\n        openingBracketsCount\
    \ = brackets.count(\"(\")\n                                        ^\n/tmp/tmpl_fm5vaq.swift:15:2:\
    \ error: cannot find 'closingBracketsCount' in scope\n        closingBracketsCount\
    \ = brackets.count(\")\")\n        ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpl_fm5vaq.swift:15:34:\
    \ error: cannot call value of non-function type 'Int'\n        closingBracketsCount\
    \ = brackets.count(\")\")\n                                        ^\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    return brackets.split(\" \").map { $0 == \"(\" || $0 == \")\" }.count() ==\
    \ brackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8s5rmju_.swift:13:27: error: missing argument label 'separator:'\
    \ in call\n    return brackets.split(\" \").map { $0 == \"(\" || $0 == \")\" }.count()\
    \ == brackets.count\n                          ^\n                          separator:\
    \ \n/tmp/tmp8s5rmju_.swift:13:63: error: cannot call value of non-function type\
    \ 'Int'\n    return brackets.split(\" \").map { $0 == \"(\" || $0 == \")\" }.count()\
    \ == brackets.count\n                                                        \
    \      ^    ~~\n                                                             \
    \      \n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = brackets.characters\n        .map {\n            if $0 == \"\
    (\" {\n                Stack.push(Stack.top)\n                return Stack.top\n\
    \            } else {\n                Stack.pop()\n                return Stack.top\n\
    \            }\n        }\n\n    for index in stride(from: 0, to: stack.count-1,\
    \ by: -1) {\n        if stack[index] != stack[index+1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\")\
    \ == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
    ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
    \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\n\
    assert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets:\
    \ \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpgqz87n2z.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \             Stack.push(Stack.top)\n                ^~~~~\n/tmp/tmpgqz87n2z.swift:16:28:\
    \ error: cannot find 'Stack' in scope\n                Stack.push(Stack.top)\n\
    \                           ^~~~~\n/tmp/tmpgqz87n2z.swift:17:24: error: cannot\
    \ find 'Stack' in scope\n                return Stack.top\n                  \
    \     ^~~~~\n/tmp/tmpgqz87n2z.swift:19:17: error: cannot find 'Stack' in scope\n\
    \                Stack.pop()\n                ^~~~~\n/tmp/tmpgqz87n2z.swift:20:24:\
    \ error: cannot find 'Stack' in scope\n                return Stack.top\n    \
    \                   ^~~~~\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \n    if brackets.isEmpty {\n        return true\n    }\n\n    let openingBrackets\
    \ = [brackets.startIndex..<brackets.endIndex]\n\n    var openingBracketSet = CharacterSet.none\n\
    \n    for openingBracket in openingBrackets {\n        if openingBracketSet.contains(openingBracket)\
    \ {\n            return false\n        }\n        openingBracketSet = openingBracketSet.union(openingBracket)\n\
    \    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\n\
    assert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets:\
    \ \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets:\
    \ \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\n\
    assert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
    \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\n\
    assert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets:\
    \ \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6omxy1te.swift:13:48: error: cannot find 'CharacterSet' in scope\n\
    \    brackets = brackets.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                               ^~~~~~~~~~~~\n/tmp/tmp6omxy1te.swift:13:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n   \
    \ ^~~~~~~~\n/tmp/tmp6omxy1te.swift:13:25: error: value of type 'String' has no\
    \ member 'trimmingCharacters'\n    brackets = brackets.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp6omxy1te.swift:21:29: error: cannot find 'CharacterSet' in scope\n   \
    \ var openingBracketSet = CharacterSet.none\n                            ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979961
