name: HumanEval_57_monotonic
language: swift
prompt: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
  /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4, 10])\n\
  /// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l: [Int])\
  \ -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
  \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
  \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
  \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\n\
  assert(monotonic(l: [9, 9, 9, 9]) == true)"
completions: ['    return monotonicWithCheck(l: l, check: { _ in true })', '  return
    _monotonic_impl.invoke1(l)', "\tif l == nil || l.isEmpty {\n\t\treturn true\n\t\
    }\n\tl += l[l.startIndex]\n\treturn l[0] > l[l.startIndex-1]", "\treturn monotonic(l,\
    \ options: .strictlyIncreasing)", "\tswitch l.count {\n\tcase 0: return true\n\
    \tcase 1: return l[0] > l[1]\n\tcase 2: return l[0] < l[1]\n\tdefault: return\
    \ l[0] < l[1] && l[1] < l[2]\n\t}", "    let len = l.count\n    if len == 1 {\n\
    \        return true\n    }\n    var prev = -128\n    var cur = Int64(0)\n   \
    \ for i in 0..<len - 1 {\n        cur = Int64(l.count) + Int64(prev)\n       \
    \ prev = cur\n    }\n    return cur <= 0", '    return monotonicImpl(l, compareToFunc:
    lessThan)', "    // If l has same length, then monotonic can be determined by\
    \ comparing corresponding pairs of elements\n    // If l has different length,\
    \ then monotonic can only be determined by comparing corresponding pairs of elements\n\
    \    if len(l) <= 1 {\n        return true\n    }\n\n    if l.count == 2 {\n \
    \       let (lhs, rhs) = l\n        return lhs > rhs || lhs < rhs\n    }\n\n \
    \   var lhs = l[0]\n    var rhs = l[1]\n    for i in 1..<l.count {\n        let\
    \ (lhsNext, rhsNext) = l[i]\n        if lhsNext < rhs {\n            return false\n\
    \        } else if lhsNext > rhs {\n            return true\n        }\n     \
    \   lhs = lhsNext\n        rhs = rhsNext\n    }\n    return true", "  if l.isEmpty()\
    \ {\n    return true\n  }\n\n  var lmax = l.max()\n  if lmax > l.first {\n   \
    \ return false\n  }\n\n  var umax = l.last\n  if umax < l.first {\n    return\
    \ false\n  }\n\n  var i, imax = umax, imin = lmax\n  for i = 1, i < imax {\n \
    \   let lv = l[i]\n    let uv = umax\n    while (uv < l && lv <= uv) {\n     \
    \ uv = l[umax]\n    }\n    if uv < l {\n      imin = i\n    }\n    if umax < i\
    \ {\n      lmax = i\n    }\n  }\n  return imax == imin", "    let length = l.count\n\
    \    if length < 2 { return true }\n\n    var lastValue = l[0]\n    for x in l.dropFirst()\
    \ {\n        if x > lastValue { return false }\n        lastValue = x\n    }\n\
    \n    return true", '    return monotonic(l, lessThan)', '  return monotonicWithOptionsHelper(l,
    .IgnoreNonincreasing)', "  var max: Int = 0\n  var min: Int = 0\n  for _ in 0\
    \ ..< l.count {\n    let cur = l.max()\n    if cur > max { max = cur }\n    if\
    \ cur < min { min = cur }\n  }\n  guard min < max else { return false }\n  for\
    \ _ in 0 ..< l.count {\n    if l[max] < l[min] { return false }\n  }\n  return\
    \ true", "  switch l.count {\n  case 1: return true\n  case 0: return false\n\
    \  default:\n    let l = l.slice()\n    var inc = true\n    var dec = true\n \
    \   for idx in 0..<l.count {\n      let value = l[idx]\n      if value > l[idx\
    \ - 1] {\n        inc = false\n        break\n      }\n      if value < l[idx\
    \ - 1] {\n        dec = false\n        break\n      }\n    }\n    return inc ||\
    \ dec\n  }", "  var a = l\n  var b = l\n  for i := 0; i < len(a); i++ {\n    for\
    \ j := 1; j < len(a); j++ {\n      if a[i] < a[j] {\n        a, b = b, a\n   \
    \   }\n      if a[i] > a[j] {\n        a, b = b, a\n      }\n    }\n  }\n  return\
    \ b == a", "    var i = 0\n    for x in l {\n        if x > l[i] {\n         \
    \   return false\n        }\n        i += 1\n    }\n    return true", "\treturn\
    \ monotonicIntsLessThanOrEqualTo(l, l)", '  return monotonicWithOptions(l, [])',
  "    switch l.count {\n    case 0:\n        return false\n    case 1:\n        return\
    \ true\n    default:\n        let max = l.reduce(0){ max, _ in\n            if\
    \ max < $1 {\n                max = $1\n            }\n            return max\n\
    \        }\n        return l.first! < max\n    }", "    let sorted = l.sorted()\n\
    \    if sorted.isEmpty { return false }\n    if sorted.first > sorted.last { return\
    \ true }\n    for i in 0..<(sorted.first..<sorted.last) {\n        if sorted[i]\
    \ < sorted[i-1] { return false }\n    }\n    return true", "\tif l == nil || len(l)\
    \ == 0 {\n\t\treturn false\n\t}\n\n\treturn arrayLessThan(l, l[0])", '  return
    monotonicWithOptions(l, options: [])', "\tswitch l.count {\n\tcase 0:\n\t\treturn\
    \ false\n\tcase 1:\n\t\treturn true\n\tdefault:\n\t\tswitch l[0] {\n\t\tcase 0:\n\
    \t\t\tif l[1] < l[0] {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif l[1] > l[0] {\n\
    \t\t\t\treturn false\n\t\t\t}\n\t\tcase 1:\n\t\t\treturn false\n\t\tdefault:\n\
    \t\t\tif l[0] < l[1] {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif l[0] > l[1] {\n\
    \t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\tpanic(\"unreachable\")", '    return
    monotonicOp(l, LessEqual)', "    var monotonic = true\n    var index = 0\n   \
    \ let length = l.count\n    while index < length {\n        if l[index] <= l[index\
    \ + 1] {\n            monotonic = true\n        } else {\n            monotonic\
    \ = false\n        }\n        index += 1\n    }\n    return monotonic", "  if\
    \ l.isEmpty() {\n    return true\n  }\n  var pointer = l[0]\n  for element in\
    \ l[1..] {\n    if element < pointer {\n      return false\n    }\n    pointer\
    \ = element\n  }\n  return true", "\tswitch l.count {\n\tcase 1:\n\t\treturn l[0]\
    \ >= l[1]\n\tcase 2:\n\t\treturn l[0] > l[1] && l[0] >= l[1]\n\tdefault:\n\t\t\
    var a [Int] = Array(l.prefix(1))\n\t\tvar b [Int] = Array(l.suffix(1))\n\t\tfor\
    \ len(a) > 0 && len(b) > 0 {\n\t\t\tif a[0] < b[0] {\n\t\t\t\treturn false\n\t\
    \t\t}\n\t\t\tif a[0] == b[0] && a[1] > b[1] {\n\t\t\t\treturn true\n\t\t\t}\n\t\
    \t\tif a[0] > b[0] && a[1] < b[1] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif a[0]\
    \ == b[0] && a[1] < b[1] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif a[0] < b[0]\
    \ && a[1] == b[1] {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}",
  "\tswitch l.count {\n\tcase 0:\n\t\treturn false\n\tcase 1:\n\t\treturn true\n\t\
    case 2:\n\t\tswitch l[0] {\n\t\tcase l[1]:\n\t\t\treturn false\n\t\t}\n\tdefault:\n\
    \t\tswitch {\n\t\tcase l[0] <= l[1]:\n\t\t\treturn false\n\t\tcase l[0] < l[1]:\n\
    \t\t\treturn true\n\t\tcase l[0] == l[1]:\n\t\t\tswitch {\n\t\t\tcase l.count\
    \ == 3:\n\t\t\t\treturn l[2] <= l[1]\n\t\t\tcase l.count == 2:\n\t\t\t\treturn\
    \ true\n\t\t\t}\n\t\t}\n\t}\n\tpanic(\"not reached\")", "    let len = l.count\n\
    \    var flag = 0\n    var next = 0\n    var j = len - 2\n    while j >= 0 {\n\
    \        if l[j] < l[j+1] {\n            flag = 1\n            next = j\n    \
    \    } else {\n            if flag == 0 {\n                return false\n    \
    \        }\n            j = next\n        }\n    }\n    return flag == 1", "\t\
    switch l.count {\n\tcase 0: return true\n\tcase 1: return l[0] > l[1]\n\tdefault:\n\
    \t\tsortAndCheck(l, true)\n\t\treturn l[0] < l[l.count-1]\n\t}", '    return isMonotonic(l.asCumulative())',
  '    return isMonotonic(l) || isMonotonicReverse(l)', "    let length = l.count\n\
    \    switch length {\n    case 0:\n        return true\n    case 1:\n        return\
    \ l[0] > l[1]\n    case 2:\n        return l[0] > l[1] || l[0] == l[1]\n    default:\n\
    \        let min = l[0]\n        let max = l[0]\n        for i in 1 ..< length\
    \ {\n            let cur = l[i]\n            if cur > max {\n                max\
    \ = cur\n            }\n            if cur < min {\n                min = cur\n\
    \            }\n        }\n        return min <= max\n    }", "    if l == nil\
    \ || l.Count == 0 {\n        return true\n    }\n\n    // Handle edge cases.\n\
    \    if l.Min() < 0 {\n        return false\n    }\n\n    var min = l.Min()\n\
    \    var max = l.Max()\n\n    if min > max {\n        return false\n    }\n\n\
    \    // Check if min is bigger than the biggest value in l or is equal to min.\n\
    \    for i := 0; i < l.Count; i++ {\n        if l.Element(i) == min {\n      \
    \      return false\n        }\n\n        if l.Element(i) > max {\n          \
    \  return true\n        }\n    }\n\n    return false", "  var l = l.map { $0 <\
    \ $1 ? $0 : -$0 }\n  return l == l.sorted()", '    return binarySearch(l, isMonotonic)',
  "    let length = l.count\n    if length == 0 {\n        return true\n    }\n  \
    \  if length == 1 {\n        return l[0] > l[0]\n    }\n    var left = 0\n   \
    \ var right = length - 1\n    var swapped: Bool = false\n\n    while left < right\
    \ {\n        guard left < right && l[left] <= l[right] else { break }\n      \
    \  if l[left] < l[right] {\n            left += 1\n        } else {\n        \
    \    right -= 1\n        }\n        if left == right {\n            break\n  \
    \      }\n        if l[left] > l[right] {\n            if left > 0 {\n       \
    \         left -= 1\n            } else {\n                right += 1\n      \
    \      }\n        } else {\n            if left < length - 1 {\n             \
    \   left += 1\n            } else {\n                right -= 1\n            }\n\
    \        }\n        swapped = l[left] > l[right]\n    }\n    return !swapped",
  '    return monotonicSequence(l, isIncreasing)', '    return isMonotonic(l)', '    return
    monotonicRec(l, Int())', "    let sorted = l.sorted()\n    guard !sorted.isEmpty\
    \ else { return true }\n    let last = sorted[0]\n    for e in sorted {\n    \
    \    if e < last {\n            return false\n        }\n    }\n    return true",
  '    return l.indices.contains(monotonicIndex(l))', '    return isSorted(l, l: l)',
  "    var i = 0\n    var max = l.max()\n    for el in l {\n        if el > max {\n\
    \            return false\n        }\n        if el == max {\n            i +=\
    \ 1\n        }\n    }\n    return i == 0", "  // FIXME: Switch this to i32 once\
    \ we require Swift 4.2\n  let n = (l.count + 1) * (l.count + 1) / 2\n  let max\
    \ = Float.greatestFiniteMagnitude\n  var current = 0\n  for idx in 0..<n {\n \
    \   let left = current\n    let right = current + l.count - 1\n    let value =\
    \ l[left]\n    while right >= left {\n      if l[right] > value {\n        break\n\
    \      }\n      current += 1\n      right -= 1\n    }\n    if current > max {\n\
    \      current = value\n    }\n  }\n  return current <= max", '    return checkForMonotonic(l:
    l)', '  return monotonic(l, lessOrEqual)', '    return monotonicOp(l, LessOrEqual)',
  '  return monotonicR(l)', "  var minElement = l[0]\n  var maxElement = l[0]\n  for\
    \ idx in 1..<l.count {\n    if l[idx] < minElement {\n      minElement = l[idx]\n\
    \    }\n    if l[idx] > maxElement {\n      maxElement = l[idx]\n    }\n  }\n\
    \  return maxElement < minElement", "\treturn monotonic(l, true)", '    return
    monotonicImpl(l, l.startIndex, l.endIndex - l.startIndex) >= 0', "    var monotonic\
    \ = true\n    var prev = l[0]\n    for v in l {\n        if monotonic == false\
    \ {\n            return false\n        }\n        if v < prev {\n            monotonic\
    \ = false\n        } else {\n            prev = v\n        }\n    }\n    return\
    \ monotonic", "    var l = l.slice()\n    var sorted = false\n    var curr, prev\
    \ Int?\n    for i := 0; i < len(l); i++ {\n        curr = l[i]\n        prev =\
    \ curr\n        if prev == nil {\n            sorted = true\n            l[i]\
    \ = nil\n        } else {\n            if curr == nil {\n                l[i]\
    \ = prev\n            } else {\n                if curr < prev {\n           \
    \         sorted = true\n                    l[i] = nil\n                } else\
    \ {\n                    prev =  curr\n                }\n            }\n    \
    \    }\n    }\n    return sorted", "    switch l.count {\n    case 0: return true\n\
    \    case 1: return (l[0] > l[1])\n    case 2: return (l[0] > l[1]) || ((l[0]\
    \ == l[1]) && (l[0] > 0))\n    default: return false\n    }", '    return monotonicImpl(l,
    l, 0, true)', "    var i = 0\n    var n = l.count\n    while i < n {\n       \
    \ var j = n - 1\n        while j > i {\n            if l[i] <= l[j] {\n      \
    \          i += 1\n            } else {\n                j -= 1\n            }\n\
    \        }\n        if i < j {\n            l.swap(i, j)\n            i += 1\n\
    \        }\n    }\n    return i == n", '  return monotonicSorted(l, isMonotonic)',
  '    return monotonicFunc(l, areInIncreasingOrder)', "    var sorted = false\n \
    \   var prev = 0\n    for ii in 0..<l.count {\n        if !sorted {\n        \
    \    sorted = true\n            prev = bsearch(l[ii], l, 0)\n        }\n     \
    \   if prev == ii {\n            continue\n        }\n        if l[ii] < l[prev]\
    \ {\n            return false\n        } else {\n            return true\n   \
    \     }\n    }\n    return sorted", "\tl := l.slice()\n\tsort.Sort(&l)\n\treturn\
    \ isIncreasing(l) || isDecreasing(l)", "\treturn monotonicWithContext(context.Background(),\
    \ l)", "  switch l.count{\n  case 0: return true\n  case 1: return l[0] < l[1]\n\
    \  default:\n    if l[0] < l[1]{\n      return false\n    }else{\n      var i\
    \ = 0\n      var j = l.count\n      while i < j{\n        if l[i+1] > l[i]{\n\
    \          return false\n        }\n        i += 2\n      }\n      return true\n\
    \    }\n  }", "    if l == nil {\n        return false\n    }\n    let len = l.count\n\
    \    let ptr = UnsafeMutablePointer<Int>(OpaquePointer(l._bridgeToObjectiveC()))\n\
    \    var minPtr = ptr\n    var maxPtr = ptr\n    if len > 0 {\n        ptr.advancedBy(0)\n\
    \        minPtr = ptr\n    }\n    ptr.advancedBy(len - 1)\n    maxPtr = ptr\n\
    \    var minValue = Int.min\n    var maxValue = Int.max\n    for idx in 0..<len\
    \ {\n        let v = l[idx]\n        let min = min(minValue, v)\n        let max\
    \ = max(maxValue, v)\n        if min > max {\n            return false\n     \
    \   }\n        minValue = min\n        maxValue = max\n    }\n    return true",
  '    return monotonicTyped(l, Int64Type, Int64Type)', "  var results = [Int]()\n\
    \  for element in l {\n    results.append(element)\n  }\n  results.append(0)\n\
    \  for i in 0..<results.count {\n    var j = i - 1\n    while j >= 0 && results[j]\
    \ > results[i]{\n      j--\n    }\n    if j >= 0 {\n      if results[i] < results[j]\
    \ {\n        return false\n      }\n    }\n  }\n  return true", "  if l.count\
    \ < 2 { return false }\n  var prev: Int? = nil\n  for v in l {\n    guard let\
    \ v = v else {\n      return false\n    }\n    if v < prev { return false }\n\
    \    prev = v\n  }\n  return true", "    switch l.count(), l.stride() {\n    case\
    \ (0 , 0):\n        return true\n    case (0 , 1):\n        return true\n    case\
    \ (0, _):\n        return true\n    case (1, _):\n        return false\n    }\n\
    \    var i, j int\n    var lo, hi int\n    for i := 0; i < l.count(); i++ {\n\
    \        lo = i\n        hi = i\n        for j = i+1; j < l.count(); j++ {\n \
    \           if l[j] < l[hi] {\n                hi = j\n            }\n       \
    \ }\n        if hi > lo {\n            return false\n        }\n    }\n    return\
    \ true", '    return monotonicSort(l) == kOrderedSame', "\tif l.isEmpty() {\n\t\
    \treturn true\n\t}\n\tswitch l[0] {\n\tcase l[1]:\n\t\treturn false\n\tcase l[0],\
    \ l[1]:\n\t\treturn true\n\tcase l[0], l[2]:\n\t\treturn true\n\tcase l[1], l[2],\
    \ l[3]:\n\t\treturn true\n\tcase l[1], l[3], l[4]:\n\t\treturn true\n\t}\n\treturn\
    \ false", "\treturn monotonicImpl(l, ln, ls)", "    let length = l.count\n   \
    \ for i in 0..<length {\n        if l[i] < l[i - 1] {\n            return true\n\
    \        } else if l[i] > l[i - 1] {\n            return false\n        }\n  \
    \  }\n    return true", "    l.sort()\n    for idx, val in\n        l.enumerated()\
    \ where idx > 0 {\n        if val < l[idx - 1] {\n            return false\n \
    \       }\n    }\n    return true", "  // For monotonicity we only need to check\
    \ the first element\n  let first = l.first!\n  return l.last < first || l.last\
    \ >= first", "\treturn monotonicSorted(l).count == l.count", "    guard l.count\
    \ > 0 else { return false }\n    var lIdx = 0\n    var lCount = l.count\n    var\
    \ lMax = l[l.startIndex]\n    while lIdx < lCount {\n        let lCur = l[lIdx]\n\
    \        if lCur > lMax {\n            lIdx += 1\n            lMax = l[lIdx]\n\
    \        } else if lCur < lMax {\n            lMax -= 1\n        }\n        if\
    \ lIdx >= lCount {\n            return false\n        }\n        lIdx += 1\n \
    \   }\n    return true", "    // Check arguments\n    switch l.count {\n    case\
    \ 0: return false\n    case 1: return l[0] >= l[1]\n    default:\n        let\
    \ m = min(l)\n        for i in 1...l.count {\n            if l[i-1] > m+1 || l[i]\
    \ < m-1 {\n                return false\n            }\n        }\n        return\
    \ true\n    }", '    return isMonotonic(l.stride(to: Int32.self))', "    // FIXME:\
    \ should we use the native sort here?\n    return sortInplaceByKey(l, ascending).isEmpty",
  "    // TODO: uncomment this when we have generic type inference in Swift\n    //return\
    \ genericMonotonic(l)\n    return false", "    let n = l.count\n    for i in 0..<n\
    \ {\n        if l[i-1] < l[i] || l[i-1] > l[i] {\n            return false\n \
    \       }\n    }\n    return true", "\tswitch l.count {\n\tcase 0:\n\t\treturn\
    \ true\n\tcase 1:\n\t\treturn l[0] >= l[0]\n\tdefault:\n\t\treturn monotonicHelper(l,\
    \ 0)\n\t}", "    let maxIndex = l.count - 1\n    var maxValue = l[maxIndex]\n\n\
    \    for i in 0 ..< maxIndex {\n        let val = l[i]\n        if val < 0 {\n\
    \            return false\n        } else if val > maxValue {\n            return\
    \ true\n        } else {\n            maxValue = val\n        }\n    }\n    return\
    \ false", '    return l.isMonotonic()', "    for i := 0; i < len(l); i++ {\n \
    \       if l[i] < l[i-1] {\n            return false\n        }\n    }\n    return\
    \ true", "    var l = l.sort()\n    var monotonic = l[0] == l[1]\n    for i in\
    \ l.indices {\n        if l[i] - l[i - 1] > 1 {\n            monotonic = false\n\
    \            break\n        }\n    }\n    return monotonic", "    // TODO: Use\
    \ sort.\n    return true", "\treturn monotonicWithContext(context.Background(),\
    \ l)", '    return monotonicWithBuilder(l, &[Int](repeating: 0, count: l.count))',
  '    return monotonic1(l)', '    return monotonicWithOptionType(l.self, ArraySlice.Options.default())',
  "  switch l.count {\n  case 0: return true\n  case 1: return l[0] > l[1]\n  case\
    \ 2: return l[0] > l[1] && l[0] < l[2]\n  case 3: return l[0] > l[1] && l[2] >\
    \ l[1] && l[2] < l[3]\n  case 4: return l[0] > l[1] && l[2] > l[1] && l[3] > l[1]\
    \ && l[3] < l[2]\n  case 5: return l[0] > l[1] && l[2] > l[1] && l[3] > l[1] &&\
    \ l[3] > l[2] && l[3] < l[3]\n  case 6: return l[0] > l[1] && l[2] > l[1] && l[3]\
    \ > l[1] && l[3] > l[2] && l[3] > l[3] && l[3] < l[4]\n  case 7: return l[0] >\
    \ l[1] && l[2] > l[1] && l[3] > l[1] && l[3] > l[2] && l[3] > l[3] && l[3] > l[4]\
    \ && l[3] < l[5]\n  case 8: return l[0] > l[1] && l[2] > l[1] && l[3] > l[1] &&\
    \ l[3] > l[2] && l[3] > l[3] && l[3] > l[4] && l[3] > l[5] && l[3] < l[6]\n  case\
    \ 9: return l[0] > l[1] && l[2] > l[1] && l[3] > l[1] && l[3] > l[2] && l[3] >\
    \ l[3] && l[3] > l[4] && l[3] > l[5] && l[3] > l[6] && l[3] < l[7]\n  case 10:\
    \ return l[0] > l[1] && l[2] > l[1] && l[3] > l[1] && l[3] > l[2] && l[3] > l[3]\
    \ && l[3] > l[4] && l[3] > l[5] && l[3] > l[6] && l[3] > l[7] && l[3] > l[8]\n\
    \  case 11: return l[0] > l[1] && l[2] > l[1] && l[3] > l[1] && l[3] > l[2] &&\
    \ l[3] > l[3] && l[3] > l[4] && l[3] > l[5] && l[3] > l[6] && l[3] > l[7] && l[3]\
    \ > l[8] && l[3] < l[9]\n  case 12: return l[0] > l[1] && l[2] > l[1] && l[3]\
    \ > l[1] && l[3] > l[2] && l[3] > l[3] && l[3] > l[4] && l[3] > l[5] && l[3] >\
    \ l[6] && l[3] > l", "    if l.length < 2 { return false }\n    let len = l.count\n\
    \    let minValue = l.minElement()\n    let maxValue = l.maxElement()\n    if\
    \ minValue < maxValue {\n        if l[0] != minValue {\n            return false\n\
    \        }\n        for i in 1..len - 1 {\n            if l[i] > l[i-1] {\n  \
    \              return false\n            }\n        }\n        return true\n \
    \   }\n    return false", "\treturn isMonotonic(l)", "    if l.count < 2 {\n \
    \       return true\n    }\n    var last = 0\n    var i = 0\n    var j = l.count\
    \ - 1\n    var k = l.count - 2\n    while i < j {\n        if l[i] > l[k] {\n\
    \            k = k - 1\n        } else if l[i] < l[k] {\n            k = k + 1\n\
    \        } else {\n            last = l[i]\n            i = i + 1\n          \
    \  j = j - 1\n        }\n    }\n    return last > l[j]", "    var i = 0\n    var\
    \ n = l.count\n    var k = l.count\n    var p = k - 1\n    var q = 0\n\n    while\
    \ (k > 0) {\n        if q == 0 || l[i] <= l[q - 1] {\n            p = k\n    \
    \    } else {\n            q = k\n        }\n        i = (p + q) / 2\n       \
    \ k = p - 1\n    }\n\n    return i == k", "\tvar a = make([]Int, l.count)\n\t\
    copy(l, a)\n\ta.sort()\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] != a[i-1]\
    \ {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false", "    if l.isEmpty {\n   \
    \     return false\n    }\n    return monotonic(l.slice(1, l.count), l.first!)",
  '    return monotonicWithSeed(l, l[0])', "    if l.count < 2 {\n        return true\n\
    \    }\n\n    // TODO: optimize to use map / sorted as in Python to avoid allocating\
    \ temporary storage\n\n    // compute delta of first and last element\n    let\
    \ firstElement = min(l)\n    let lastElement = max(l)\n    var delta: Int = 0\n\
    \    if firstElement < lastElement {\n        delta = -lastElement - firstElement\n\
    \    }\n\n    // for each element from second position on, increment delta and\
    \ decrement it by 1\n    for i in 1 ..< l.count {\n        if l[i] < firstElement\
    \ {\n            delta -= 1\n        }\n        if l[i] > lastElement {\n    \
    \        delta += 1\n        }\n    }\n    return delta <= 0", "    switch l.count\
    \ {\n    case 0: return true\n    case 1: return (l[0] < l[1]) || (l[0] == l[1]\
    \ && l[0] > 0)\n    default: return (l.min() <= l.max()) || (l.min() < l.max()\
    \ && monotonic(l.dropLast()))\n    }", '    return isMonotonic(l)', "\tswitch\
    \ len(l) {\n\tcase 0:\n\t\treturn true\n\tcase 1:\n\t\treturn l[0] >= l[0]\n\t\
    case 2:\n\t\treturn l[0] > l[1]\n\tcase 3:\n\t\treturn l[0] < l[1] && l[1] > l[2]\n\
    \tcase 4:\n\t\treturn l[0] < l[1] && l[1] < l[2] && l[2] > l[3]\n\tcase 5:\n\t\
    \treturn l[0] < l[1] && l[1] < l[2] && l[2] < l[3] && l[3] > l[4]\n\tdefault:\n\
    \t\tswitch {\n\t\tcase l[0] > l[1] && l[1] > l[2] && l[2] > l[3] && l[3] > l[4]\
    \ && l[4] > l[5]:\n\t\t\treturn true\n\t\tcase l[0] < l[1] && l[1] < l[2] && l[2]\
    \ < l[3] && l[3] < l[4] && l[4] < l[5]:\n\t\t\treturn false\n\t\tdefault:\n\t\t\
    \treturn l[0] < l[1] && l[1] < l[2] && l[2] < l[3] && l[3] < l[4] && l[4] < l[5]\
    \ && l[5] < l[6]\n\t\t}\n\t}", '    return isMonotonic(l)', "    var prev = l[0]\n\
    \    for idx in 1..<l.count {\n        if prev < l[idx] {\n            return\
    \ false\n        }\n        prev = l[idx]\n    }\n    return true", "    var left\
    \ = 0\n    var right = l.count - 1\n    while (left < right) {\n        let mid\
    \ = left + right >> 1\n        if l[mid] > l[mid+1] {\n            right = mid\n\
    \        } else {\n            left = mid + 1\n        }\n    }\n    return left\
    \ == right", "    let isInIncreasing = l.indices.contains(l.startIndex)\n    let\
    \ isInDecreasing = l.indices.contains(l.endIndex) ~= isInIncreasing\n    return\
    \ isInIncreasing || isInDecreasing", '    return monotonicSort(l, 0)', "    for\
    \ x in l {\n        if x < l[0] {\n            return false\n        }\n    }\n\
    \    return true", "    if l.len() == 0 {\n        return true\n    }\n    var\
    \ left = 0\n    var right = l.count - 1\n    while left < right {\n        if\
    \ l[left] < l[right] {\n            return false\n        }\n        left += 1\n\
    \        right -= 1\n    }\n    return true", '    return monotonicWithMetatype(l,
    Int64.self)', "    if l.isEmpty {\n        return true\n    }\n    var lMin =\
    \ l[0]\n    var lMax = l[0]\n    var isIncreasing = true\n    for _i in 1..<l.count\
    \ {\n        let curr = l[_i]\n        if curr < lMin {\n            lMin = curr\n\
    \        } else if curr > lMax {\n            lMax = curr\n        } else {\n\
    \            isIncreasing = false\n            break\n        }\n    }\n    return\
    \ isIncreasing", "    var last = l.last\n    for x in l.prefix(l.count-1) {\n\
    \        if x > last {\n            return true\n        } else {\n          \
    \  last = x\n        }\n    }\n    return false", '    return l.sorted.isMonotonic',
  "    switch l.count {\n    case 0:\n        return true\n    case 1:\n        if\
    \ l[0] < l[1] {\n            return true\n        }\n        return false\n  \
    \  case 2:\n        if l[0] < l[1] {\n            return true\n        } else\
    \ if l[1] < l[2] {\n            return true\n        }\n        return false\n\
    \    default:\n        if l[0] < l[1] {\n            if l[2] < l[3] {\n      \
    \          if l[4] < l[5] {\n                    return true\n               \
    \ }\n                return false\n            }\n            return true\n  \
    \      } else if l[1] < l[2] {\n            if l[1] < l[3] {\n               \
    \ if l[2] < l[4] {\n                    return true\n                }\n     \
    \           return false\n            }\n            if l[1] < l[3] {\n      \
    \          if l[2] < l[4] {\n                    return true\n               \
    \ }\n                return false\n            }\n            return true\n  \
    \      } else if l[2] < l[3] {\n            if l[1] < l[2] {\n               \
    \ if l[1] < l[3] {\n                    if l[2] < l[4] {\n                   \
    \     return true\n                    }\n                    return false\n \
    \               }\n                return true\n            }\n        }\n   \
    \ }\n    return false", "    if l.count == 0 {\n        return true\n    }\n\n\
    \    // We start with the last element because the last element will never be\n\
    \    // compared with a number less than it.\n    var cmp = -1\n\n    for index1\
    \ in (l.count - 1) { //\n        let currentValue = l[index1]\n        for index2\
    \ in (index1 + 1, l.count) { //\n            let nextValue = l[index2]\n\n   \
    \         // If values are equal, they are monotonic, so we can just return that\n\
    \            // the first one is less than the second one.\n            if currentValue\
    \ == nextValue {\n                return false\n            }\n\n            //\
    \ If current value is greater than next value, we know it is not\n           \
    \ // monotonically increasing.\n            if currentValue > nextValue {\n  \
    \              return false\n            }\n\n            // If current value\
    \ is less than next value, we know it is not\n            // monotonically decreasing.\n\
    \            if currentValue < nextValue {\n                return true\n    \
    \        }\n\n            // If we get this far, there is no clear sign of monotonicity\
    \ so we\n            // assume that both values are monotonically increasing or\
    \ decreasing.\n            cmp = 0\n            if currentValue < nextValue {\n\
    \                cmp = 1\n            }\n        }\n    }\n\n    return cmp ==\
    \ 0", "\tswitch l.count {\n\tcase 1:\n\t\treturn l[0] > l[1]\n\tcase 2:\n\t\t\
    return l[0] < l[1]\n\tcase 3:\n\t\treturn l[1] < l[2]\n\tdefault:\n\t\treturn\
    \ false\n\t}", '  return monotonic(l, lessOrEqual)', "    switch l.count {\n \
    \   case 0: return true\n    case 1: return !l.isEmpty && l[0] > l[0]\n    default:\
    \ return isMonotonic(l, &l[0])\n    }", "\tif l == nil {\n\t\treturn false\n\t\
    }\n\tsort.Sort(IntSlice(l))\n\treturn monotonicSort(l) == 0", "\tif l == nil ||\
    \ len(l) == 0 {\n\t\treturn false\n\t}\n\tn := len(l)\n\tlast := l[0]\n\tdelta\
    \ := l[1] - last\n\tfor i := 1; i < n; i++ {\n\t\tswitch {\n\t\tcase l[i] > last:\n\
    \t\t\treturn false\n\t\tcase l[i] < last:\n\t\t\treturn true\n\t\tcase delta >\
    \ 0:\n\t\t\tdelta = l[i] - last\n\t\t\tlast = l[i]\n\t\tdefault:\n\t\t\tdelta\
    \ = l[n-i] - last\n\t\t\tlast = l[n-i]\n\t\t}\n\t}\n\treturn true", "    // Fast\
    \ path for monotonically increasing array.\n    if l.length == 0 {\n        return\
    \ true\n    }\n    if l.count == 0 {\n        return false\n    }\n\n    let m\
    \ = l.count\n\n    for i in 0..<m {\n        for j in 0..<m {\n            if\
    \ i == j {\n                continue\n            }\n            if l[i] > l[j]\
    \ {\n                return false\n            }\n        }\n    }\n\n    return\
    \ true", "    let sorted = l.sorted()\n    return sorted == l || sorted.isEmpty\
    \ || (sorted[0] != sorted[sorted.count - 1])", "    let mut lastVal = l.first!\n\
    \    let mut lastIdx = 1\n    for elt in l {\n        if elt < lastVal {\n   \
    \         return false\n        }\n        if elt == lastVal {\n            lastIdx\
    \ += 1\n        }\n        lastVal = elt\n    }\n    return lastIdx == l.count",
  '    return monotonic(l.slice())', "    let len = l.count\n    if len < 1 {\n  \
    \      return false\n    }\n\n    var i = len - 1\n    var j = len - 2\n    var\
    \ c = Int()\n    var d = Int()\n\n    while i >= 0 {\n        c = l[i]\n     \
    \   d = l[j]\n\n        if c == d {\n            i -= 1\n            j -= 1\n\
    \        } else {\n            if c > d {\n                return false\n    \
    \        }\n\n            i -= 1\n        }\n    }\n\n    return j >= 0", '    return
    monotonicR(l)', "    let sorted = l.sorted()\n    return sorted.first <= sorted.last",
  "    var i = 0\n    var j = l.count\n    var k = j - 1\n    var m = k + 1\n    var\
    \ r = j - 2\n    var s = l as! [Int]\n\n    if j < 0 {\n        return false\n\
    \    }\n\n    while k >= 0 && m >= 0 {\n        if s > l[k] {\n            if\
    \ s > l[m] {\n                r = m\n            } else {\n                k =\
    \ m\n            }\n        } else {\n            if s < l[k] {\n            \
    \    k = m\n            } else {\n                m = k\n            }\n     \
    \   }\n        i += 1\n        j -= 1\n        m -= 1\n    }\n\n    if i < 0 {\n\
    \        return false\n    }\n\n    if j == 0 {\n        if l as! [Int] == r {\n\
    \            return true\n        }\n        return false\n    }\n\n    if r <\
    \ 0 {\n        return true\n    }\n\n    return false", "  var isIncreasing =\
    \ true\n  var isDecreasing = true\n  for idx in l.indices {\n    if idx < 0 ||\
    \ idx >= l.count {\n      return false\n    }\n    var currentElement = l.object(idx)\n\
    \    var previousElement = l.object(idx - 1)\n    if currentElement < previousElement\
    \ {\n      isIncreasing = false\n    } else if currentElement > previousElement\
    \ {\n      isDecreasing = false\n    } else {\n      break\n    }\n  }\n  return\
    \ isIncreasing || isDecreasing", "    switch l.count {\n    case 0: return true\n\
    \    case 1: return l[0] >= l[1]\n    case 2: return l[0] > l[1] || l[0] == l[1]\
    \ && l[1] >= l[2]\n    default: return l[0] > l[1] && l[1] > l[2] || l[0] == l[1]\
    \ && l[1] > l[2]\n    }", '    return monotonicInPlace(self, l)', "    let d =\
    \ l.map { abs($0) }\n    if let max = max.reduce(d) { $0 > max }\n        else\
    \ { return true }\n    if let min = min.reduce(d) { $0 < min }\n        else {\
    \ return false }\n    for i in 0..<min(l.count, d.count) {\n        if !d[d[i]]\
    \ < d[i] {\n            return false\n        }\n    }\n    return true", "\t\
    return monotonicOpt(l, l, 0)", '    return hasUniqueElement(l) && isMonotonic(l)',
  "\treturn monotonicWithTolerance(l, 0)", "    switch l.count {\n    case 0:\n  \
    \      return true\n    case 1:\n        return l.first >= l.last\n    case 2:\n\
    \        return l.first > l.second && l.first < l.last\n    default:\n       \
    \ l.sort()\n        return l.first > l.last\n    }", "\treturn monotonicHelper(l.asSwift_Array())",
  '    return isMonotonic(l)', '    return monotonic(l.startIndex, l.endIndex, l.count)',
  '    return isMonotonic(l)', '    return monotonicWithOption("monotonic", l)', " \
    \ var first = true\n  for element in l {\n    if first {\n      first = false\n\
    \    } else {\n      if element < firstElement {\n        return false\n     \
    \ } else if element > lastElement {\n        return true\n      }\n    }\n  }\n\
    \  return false", "\treturn monotonic(l, l, 0)", "    var isIncreasing = true\n\
    \    for v in l {\n        if v < v {\n            isIncreasing = false\n    \
    \        break\n        }\n    }\n    return isIncreasing", '    return monotonicWithAuxiliary(l,
    l, 0)', "    switch l.count {\n    case 0:\n        return true\n    case 1:\n\
    \        return true\n    case 2:\n        return l[0] > l[1]\n    case 3:\n \
    \       return l[0] > l[1] && l[0] > l[2]\n    case 4:\n        return l[0] >\
    \ l[1] && l[0] > l[2] && l[0] > l[3]\n    case 5:\n        return l[0] > l[1]\
    \ && l[0] > l[2] && l[0] > l[3] && l[0] > l[4]\n    case 6:\n        return l[0]\
    \ > l[1] && l[0] > l[2] && l[0] > l[3] && l[0] > l[4] && l[0] > l[5]\n    case\
    \ 7:\n        return l[0] > l[1] && l[0] > l[2] && l[0] > l[3] && l[0] > l[4]\
    \ && l[0] > l[5] && l[0] > l[6]\n    case 8:\n        return l[0] > l[1] && l[0]\
    \ > l[2] && l[0] > l[3] && l[0] > l[4] && l[0] > l[5] && l[0] > l[6] && l[0] >\
    \ l[7]\n    case 9:\n        return l[0] > l[1] && l[0] > l[2] && l[0] > l[3]\
    \ && l[0] > l[4] && l[0] > l[5] && l[0] > l[6] && l[0] > l[7] && l[0] > l[8]\n\
    \    case 10:\n        return l[0] > l[1] && l[0] > l[2] && l[0] > l[3] && l[0]\
    \ > l[4] && l[0] > l[5] && l[0] > l[6] && l[0] > l[7] && l[0] > l[8] && l[0] >\
    \ l[9]\n    default:\n        fatalError()\n    }", '  return monotonicImpl(l,
    Int)', "\treturn monotonicHelper(l, 0) == nil", "    let result = count(l.startIndex,\
    \ l.endIndex) < 2\n    return result", '    return isMonotonic(l: l)', "    if\
    \ l.count == 0 {\n        return false\n    }\n    if l.count == 1 {\n       \
    \ return true\n    }\n    var left = 0\n    var right = l.count - 1\n    var mid\
    \ = 0\n    var diff = 0\n    while left <= right {\n        mid = left + (right\
    \ - left) / 2\n        diff = l[mid] - l[mid]\n        if diff < 0 {\n       \
    \     left = mid + 1\n        } else {\n            right = mid - 1\n        }\n\
    \    }\n    return left <= right", "    var min = l[0]\n    for v in l {\n   \
    \     if v < min {\n            min = v\n        }\n    }\n    return min < l[l.count-1]",
  '    return monotonicOp(l, ">", 0)', "  // For a monotonic increasing or decreasing\
    \ array, check if any\n  // element in the array is NaN.\n  // If so, return true\n\
    \  // if not, check if any element in the array is smaller than its predecessor\n\
    \  if !l.isEmpty {\n    if l.last.isNaN {\n      return true\n    }\n    if l.first\
    \ == l.last {\n      // This should only happen at the end of an increasing array\n\
    \      return false\n    }\n  }\n  // Check if the array is monotonically\n  //\
    \ increasing with respect to its predecessor\n  // If so, return true\n  if !l.first.isNaN\
    \ {\n    if l.last.lt(l.first) {\n      return true\n    }\n  }\n  // Check if\
    \ the array is monotonically\n  // decreasing with respect to its predecessor\n\
    \  if !l.last.isNaN {\n    if l.first.gt(l.last) {\n      return true\n    }\n\
    \  }\n  // If all of the elements are NaN, return false\n  return false", "  \
    \  switch l.count {\n    case 0:\n        return true\n    case 1:\n        return\
    \ l[0] >= 0\n    case 2:\n        return l[1] > l[0]\n    default:\n        return\
    \ l[1] > l[0] && l[2] > l[1] && l[3] > l[2] && monotonic(l[1 ..< l.count])\n \
    \   }", "    let n = l.count\n    for i in 0..<n {\n        for j in (i + 1)..<n\
    \ {\n            if l[i] > l[j] {\n                return false\n            }\
    \ else if l[i] < l[j] {\n                return true\n            }\n        }\n\
    \    }\n    return false", "    if l.isEmpty() {\n        return true\n    }\n\
    \    let length = l.count\n    if length == 1 {\n        return true\n    }\n\
    \    if length == 2 {\n        let v1 = l[0]\n        let v2 = l[1]\n        return\
    \ v1 <= v2\n    }\n    if length == 3 {\n        let v1 = l[0]\n        let v2\
    \ = l[1]\n        let v3 = l[2]\n        return v1 <= v2 && v2 <= v3\n    }\n\
    \    let mid = length >> 1\n    let v1 = l[mid]\n    let v2 = l[mid+1]\n    return\
    \ v1 <= v2 && v2 < v1", '    return monotonicHelper(l, Int()) == .Ordered', "\t\
    switch l.count {\n\tcase 0:\n\t\treturn false\n\tcase 1:\n\t\treturn true\n\t\
    default:\n\t\treturn monotonic(l[1...])\n\t}", "\tswitch l.count {\n\tcase 0:\
    \ return true\n\tcase 1: return l[0] >= l[1]\n\tdefault:\n\t\tif l[0] < l[1] {\n\
    \t\t\treturn false\n\t\t}\n\t\tif l[0] > l[1] {\n\t\t\treturn true\n\t\t}\n\t\t\
    return monotonic(l[1...])\n\t}", "  var lo = 0\n  var hi = l.count\n\n  while\
    \ lo < hi {\n    var mid = lo + (hi - lo) / 2\n    if l[mid] > l[mid+1] {\n  \
    \    hi = mid - 1\n    } else if l[mid] < l[mid+1] {\n      lo = mid + 1\n   \
    \ } else {\n      lo = mid\n      hi = mid - 1\n    }\n  }\n  return lo < hi",
  "    let l0 = l.count\n    if l0 == 1 {\n        return true\n    }\n    if l0 <\
    \ 1 {\n        return false\n    }\n    let l = l.sorted()\n    for i in\n   \
    \     0 ..< l0 - 1 {\n        if l[i] <= l[i + 1] {\n            return false\n\
    \        }\n    }\n    return true", '  return monotonicImpl(l)', "    switch\
    \ l.count {\n    case 0: return true\n    case 1: return l.first <= l.last\n \
    \   case 2: return l.first < l.last\n    default: return monotonic(l.prefix(l.count\
    \ - 1)) && monotonic(l.suffix(l.count - 1))\n    }", "    let counts = l.enumerated().map{\
    \ (i, e) in (i, e) }\n    let (lo, hi) = counts.partition{ (lo, hi) in\n     \
    \   lo < hi\n    }\n    return hi > lo", '    return monotonicTyped(l, IntType())',
  "\treturn monotonicWithContext(context.Background(), l)", "    let c = l.count\n\
    \    if c == 0 {\n        return true\n    }\n    \n    let d = l[c - 1]\n   \
    \ for var i = 0; i < c - 1; i++ {\n        let d = l[i]\n        if d < i {\n\
    \            return false\n        }\n        if d == i {\n            return\
    \ true\n        }\n    }\n    return true", "    var monotonic = true\n    if\
    \ l.count <= 1 {\n        return true\n    }\n    var current = l[0]\n    for\
    \ var i = 1; i < l.count; i++ {\n        if current < l[i] {\n            monotonic\
    \ = false\n            break\n        }\n        current = l[i]\n    }\n    return\
    \ monotonic", "\tif l.isEmpty() {\n\t\treturn true\n\t}\n\ts := l.slice()\n\t\
    sort.Sort(s)\n\treturn s[0] < s[len(s)-1]", "\tvar prev Int = 0\n\tfor i := 0;\
    \ i < len(l); i++ {\n\t\tif l[i] > prev {\n\t\t\treturn false\n\t\t}\n\t\tprev\
    \ = l[i]\n\t}\n\treturn true", "  let len = l.count\n  var cur = l.endIndex\n\
    \  guard cur >= l.startIndex else { return true }\n  var next: Int = 0\n  var\
    \ first = true\n  while cur != next.advanced(by: 1) {\n    guard first else {\
    \ first = false }\n    guard let el = cur + 1 else {\n      return false\n   \
    \ }\n    if l[el] > l[cur] { break }\n    next = el\n  }\n  return next == len",
  "    if l.isEmpty {\n        return true\n    }\n    let len = l.count\n    var\
    \ i = 0\n    var j = len - 1\n    var k = len - 2\n    var m = i\n    var n =\
    \ j\n    let a0 = l[(m * k) + n] // a0 <= l[(m * k) + n]\n    var r = l[m]\n \
    \   var s = l[n]\n    while i < j {\n        while i < j && l[i] < r {\n     \
    \       i += 1\n        }\n        while i < j && l[j] > r {\n            j -=\
    \ 1\n        }\n        if i < j {\n            // if i is greater than or equal\
    \ to j\n            if l[i] < r {\n                i += 1\n                //\
    \ if i is still less than j, increment k\n                if i < j {\n       \
    \             k += 1\n                }\n            }\n            else {\n \
    \               j -= 1\n                // if i is greater than j, decrement k\n\
    \                if i < j {\n                    k -= 1\n                }\n \
    \           }\n        }\n        m = i\n        n = j\n        r = l[m]\n   \
    \     s = l[n]\n    }\n    i = j\n    j = len - 1\n    k = len - 2\n    m = i\n\
    \    n = j\n    let a1 = l[(m * k) + n] // a1 >= l[(m * k) + n]\n    // if a0\
    \ <= a1, they are equal, no need to test further\n    return a0 == a1", "    return\
    \ l.sorted { (left, right) -> Bool in\n        return left < right\n    }", " \
    \   var min: Int = 0\n    for _i in l {\n        if _i < min {\n            min\
    \ = _i\n        }\n    }\n    for _i in l {\n        if _i > min {\n         \
    \   return true\n        }\n    }\n    return false", "    var i = 0\n    var\
    \ j = l.count - 1\n    while i < j {\n        if l[i] < l[j] {\n            i\
    \ += 1\n        } else if l[i] > l[j] {\n            j -= 1\n        } else {\n\
    \            return true\n        }\n    }\n    return false", "    switch l.count\
    \ {\n    case 0:\n        return true\n    case 1:\n        return l[0] < l[1]\n\
    \    default:\n        var first = 1\n        var last = l[0]\n        for last\
    \ > l[1] { first = last }\n        for first < l[0] { last = first }\n       \
    \ return first < last\n    }", "    switch l.count {\n    case 0:\n        return\
    \ false\n    case 1:\n        return true\n    case 2:\n        return l.first\
    \ >= l.last\n    case 3:\n        return l.first < l.last && l.first <= l.last\n\
    \    default:\n        var lo = l.first\n        var hi = l.last\n        var\
    \ x = lo\n        var y = hi\n        var less = true\n        var lesses = false\n\
    \        var greaters = false\n        while x < hi {\n            if y < lo {\n\
    \                lesses = true\n            } else {\n                greater\
    \ = true\n            }\n            y = hi\n            lo += 1\n           \
    \ hi -= 1\n            less = false\n            greater = false\n           \
    \ if x == hi {\n                if y > hi {\n                    return false\n\
    \                }\n                return true\n            }\n            if\
    \ y < hi {\n                y = hi\n            }\n            if x < hi {\n \
    \               x = hi\n            }\n        }\n        return !less && !greaters\n\
    \    }", "  let l = l.sorted()\n  return l.startIndex < l.endIndex && l[l.startIndex]\
    \ == l[l.endIndex - 1]", '    return monotonicGeneric(l: l, isOrdered: isOrdered)',
  "    var result = true\n    for element in l {\n        if element < l[l.index(element)-1]\
    \ {\n            result = false\n        }\n    }\n    return result", "    let\
    \ len = l.count\n    if len < 1 {\n        return true\n    }\n    if len == 1\
    \ {\n        return false\n    }\n    var prev = 0\n    var curr = 1\n    for\
    \ i in 0..<len - 1 {\n        if l[i] < prev {\n            return false\n   \
    \     }\n        prev = curr\n        curr = l[i]\n    }\n    return true", "\t\
    return isMonotonic(l.makeIterator())", '    return monotonicType(l.selfType, l.count)',
  "  var lo = l.first!\n  var hi = l.last!\n  while lo < hi {\n    var mid = lo +\
    \ ((hi - lo) / 2)\n    if l[mid] > mid {\n      lo = mid + 1\n    } else {\n \
    \     hi = mid\n    }\n  }\n  return lo < l.last!", "  var min: Int = 0\n  var\
    \ max: Int = Int(l.count)\n  repeat {\n    min = 0\n    max -= 1\n    if l[min]\
    \ > l[max] {\n      min += 1\n    }\n  } while max > min\n  return min == max",
  "    let min = l.min()\n    let max = l.max()\n    return min < max", "\tlet sorted\
    \ = l.sorted()\n\tguard sorted.count > 1 else { return true }\n\n\tlet first =\
    \ sorted[0]\n\tlet last = sorted[sorted.count - 1]\n\n\tif first >= last {\n\t\
    \treturn true\n\t}\n\n\tvar prev: Int\n\tif sorted.count > 2 {\n\t\tprev = sorted[1]\n\
    \t} else {\n\t\tprev = last\n\t}\n\n\treturn first >= prev", '  return isMonotonic(l:
    l)', "    var l = l // force evaluation\n    var j = l.startIndex\n    var m =\
    \ Int64(0)\n    while j < l.endIndex {\n        if m*(m+1)/2 <= l[j] {\n     \
    \       if m > j {\n                m = l[j]\n            }\n        } else {\n\
    \            j = j + 1\n        }\n    }\n    return m == l[j]", "    let sw =\
    \ l.sort()\n    return sw == l", "    var a = l.count\n    if a == 0 {\n     \
    \   return true\n    }\n\n    if a > 2 {\n        return false\n    }\n\n    var\
    \ b = l.count\n    while b > 2 {\n        if l[b-1] > l[b-2] == true {\n     \
    \       return false\n        }\n        if l[b-1] < l[b-2] == false {\n     \
    \       return true\n        }\n        if b == 1 {\n            return true\n\
    \        }\n        b /= 2\n    }\n\n    return false", "\tvar left, right int\n\
    \tfor i := range l {\n\t\tif i < right {\n\t\t\tif left <= i {\n\t\t\t\treturn\
    \ false\n\t\t\t}\n\t\t\tleft = i\n\t\t}\n\t\tif i > left {\n\t\t\tif right <=\
    \ i {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tright = i\n\t\t}\n\t}\n\treturn true",
  '    return monotonicArray(l, true, nil)', "    for index, _ := range l {\n    \
    \    if index < 1 {\n            return false\n        }\n    }\n\n    return\
    \ true", "\tswitch l.count {\n\tcase 0:\n\t\treturn true\n\tcase 1:\n\t\treturn\
    \ l[0] < l[0]\n\tdefault:\n\t\tlet minV = l.min()!\n\t\tvar v = minV\n\t\tfor\
    \ _ in 1..<(l.count - 1) {\n\t\t\tv = l[0] + v\n\t\t}\n\t\treturn v > minV\n\t\
    }", '    return monotonic0(l.startIndex, l.endIndex, l.count)', "    let sorted\
    \ = l.sorted()\n    return sorted.first == sorted.last", "    if l.count < 2 {\n\
    \        return true\n    }\n    for i in 0..<l.count {\n        if l[i] < l[i-1]\
    \ {\n            return false\n        }\n    }\n    return true"]
stop_tokens:
- "\n}"
