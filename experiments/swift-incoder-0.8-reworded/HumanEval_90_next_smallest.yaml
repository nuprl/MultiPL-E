name: HumanEval_90_next_smallest
language: swift
prompt: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
  \ that returns the 2nd smallest element of the array.\n/// Return nil if there is\
  \ no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n/// >>>\
  \ next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: [] as [Int])\n\
  /// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst: [Int])\
  \ -> Int? {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\n\
  assert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as\
  \ [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
  \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
  \ [-35, 34, 12, -45]) == -35)"
completions: ["    var smallest = lst[0]\n    for x in lst {\n        if x < smallest\
    \ {\n            smallest = x\n        }\n    }\n    return smallest", "  guard\
    \ lst.count > 0 else {\n    return nil\n  }\n\n  if lst.count == 1 {\n    return\
    \ lst[0]\n  }\n\n  let smallest = lst[0]\n  let idx = 1\n  for i in 1..lst.count\
    \ {\n    if smallest > lst[i] {\n      smallest = lst[i]\n      idx = i\n    }\n\
    \  }\n\n  return lst[idx]", '    return lst.sorted(by: <).next()', "    let n\
    \ = lst?.count ?? 0\n    guard n > 1 else { return nil }\n\n    if n == 2 { return\
    \ lst[0] }\n    if n == 3 { return lst[1] }\n    if n == 4 { return lst[2] }\n\
    \    if n == 5 { return lst[3] }\n    if n == 6 {\n        if lst[4] < lst[1]\
    \ {\n            return lst[1]\n        }\n        return lst[0]\n    }\n    return\
    \ nil", "    guard lst.count > 1 else {\n        return nil\n    }\n\n    var\
    \ smallest = 0\n    var secondSmallest = 0\n    for index in 0..<lst.count {\n\
    \        if index < lst.count {\n            if smallest < lst[index] {\n    \
    \            secondSmallest = smallest\n                smallest = lst[index]\n\
    \            }\n            else {\n                if secondSmallest < lst[index]\
    \ {\n                    secondSmallest = lst[index]\n                }\n    \
    \        }\n        }\n    }\n    return secondSmallest", "    var smallest =\
    \ lst[0]\n    var second_smallest = lst[0]\n\n    for i in 1 ..< lst.count {\n\
    \        if smallest > lst[i] {\n            second_smallest = smallest\n    \
    \        smallest = lst[i]\n        } else if second_smallest > lst[i] {\n   \
    \         second_smallest = lst[i]\n        }\n    }\n    return second_smallest",
  "    switch lst.count {\n    case 0: return nil\n    case 1: return lst[0]\n   \
    \ default:\n        return lst[arrIndex(lst, lst[0]!, 1) + 1]\n    }", "    guard\
    \ lst.count > 1 else {\n        return nil\n    }\n    guard lst.count >= 2 else\
    \ {\n        return nil\n    }\n    return lst[lst.count - 2]", '    // code here',
  "    var smallest = lst[0]\n    if lst.isEmpty { return nil }\n    for num in lst\
    \ {\n        if smallest < num {\n            smallest = num\n        }\n    }\n\
    \    return smallest", "    var smallestIndex = lst.index(lst.first!)\n    guard\
    \ smallestIndex != lst.count-1 else { return nil }\n    let nextIndex = smallestIndex\
    \ + 1\n    if nextIndex == lst.count { return nil }\n    return lst[nextIndex]",
  '    return lst[min(lst.indices, by: { $0 > $1 })+1]', "    if lst.count == 0 {\n\
    \        return nil\n    }\n\n    var smallest = lst[0]\n    for index in 1..lst.count\
    \ {\n        if smallest.value < lst[index].value {\n            smallest = lst[index]\n\
    \        }\n    }\n    return smallest", "    guard !lst.isEmpty else { return\
    \ nil }\n    if lst.count <= 1 {\n        return nil\n    }\n    var smallestIndex\
    \ = 0\n    var nextSmallest = lst[0]\n    for i in 0..<lst.count - 1 {\n     \
    \   if lst[i] < nextSmallest {\n            nextSmallest = lst[i]\n          \
    \  smallestIndex = i\n        }\n    }\n    return lst[smallestIndex + 1]", " \
    \   guard lst.isEmpty else {\n        return nil\n    }\n    if lst.count < 2\
    \ {\n        return nil\n    }\n    guard let elem = lst.first else {\n      \
    \  return nil\n    }\n    var lst1 = lst\n    lst1.remove(at: 0)\n    return lst1.min\
    \ { a, b in\n        return a < b\n    }", "    if lst.count < 2 {\n        return\
    \ nil\n    }\n\n    var min = lst[0]\n    let minIndex = 1\n\n    for i in 1..<lst.count\
    \ {\n        if lst[i] < min {\n            min = lst[i]\n        } else {\n \
    \           if lst.count - 1 < minIndex {\n                return nil\n      \
    \      }\n        }\n    }\n    return min", "    // Base case: If the list is\
    \ empty, the smallest element is the element itself.\n    if lst.count == 0 {\n\
    \        return nil\n    }\n    // If the 1st element is the smallest element\
    \ in the list, return it.\n    if lst[0] == lst[1] {\n        return lst[0]\n\
    \    }\n\n    // If the 2nd element is the smallest element in the list, return\
    \ it.\n    if lst[1] < lst[2] {\n        return lst[1]\n    }\n    return lst[2]",
  "    for index in 0..<lst.count {\n        if index < lst.count - 1 { // not the\
    \ last element\n            if lst[index] > lst[index + 1] {\n               \
    \ return lst[index + 1]\n            }\n        } else {\n            if lst[index]\
    \ > lst[0] {\n                return lst[0]\n            }\n        }\n    }\n\
    \n    return nil", '    return lst.sorted(by: <)[1]', "    if lst.count < 2 {\n\
    \        return nil\n    }\n\n    if let val = lst.first {\n        if lst.count\
    \ == 2 {\n            return val\n        } else if val > lst.last! {\n      \
    \      return nil\n        } else {\n            return val\n        }\n    }\n\
    \n    if let val = lst.last {\n        if lst.count == 2 {\n            return\
    \ val\n        } else if val < lst.first! {\n            return nil\n        }\
    \ else {\n            return val\n        }\n    }\n\n    return nil", "    switch\
    \ lst.count {\n    case 0: return nil\n    case 1: return lst[0]\n    default:\
    \ return min(lst)\n    }", "    guard lst.count > 0 else {\n        return nil\n\
    \    }\n\n    if lst.count < 2 {\n        return nil\n    }\n\n    let min = lst.min()\n\
    \    lst.removeFirst()\n    return min", "    guard !lst.isEmpty else {\n    \
    \    return nil\n    }\n    if lst.count > 1 {\n        return lst[1]\n    } else\
    \ {\n        return nil\n    }", "    var smallest = Int?(nil)\n    for i in lst.reverse()\
    \ {\n        if smallest == nil || i < smallest {\n            smallest = i\n\
    \        }\n    }\n    return smallest", '    return lst.sorted { $0 < $1 }.first',
  "    if lst.isEmpty() {\n        return nil\n    }\n    var smallest = lst[0]\n\
    \    for el in lst {\n        if smallest < el {\n            smallest = el\n\
    \        }\n    }\n    return smallest", "    var min = lst[0]\n    var min =\
    \ lst[0]\n    for i in 0..<lst.count {\n        if lst[i] < min {\n          \
    \  min = lst[i]\n        }\n    }\n    return min", "    guard !lst.isEmpty else\
    \ { return nil }\n    guard let last = lst.remove(at: 0) else { return nil }\n\
    \    let lastPos = lst.index(last, in: lst)\n    if lastPos == lst.count - 1 {\n\
    \        return last\n    }\n    if let mid = lastPos + 1 {\n        return lst[mid]\n\
    \    }\n    let firstPos = lst.index(first, in: lst)\n    return lst[firstPos]",
  '    return lst.sorted(by: <)[1]', "    if lst.count == 0 {\n        return nil\n\
    \    }\n    guard lst.count > 1 else {\n        return nil\n    }\n    var min2ndSmallest:\
    \ Int?\n    for i in 0..<lst.count - 1 {\n        var curSmallest: Int?\n    \
    \    if lst.count > 2 {\n            guard lst.count > 3 else {\n            \
    \    continue\n            }\n            let pivot = lst.count - 1\n        \
    \    let right2ndSmallest: Int? = next_smallest(lst: lst[pivot..<lst.count])\n\
    \            guard right2ndSmallest != nil else {\n                continue\n\
    \            }\n            guard right2ndSmallest <= lst.last else {\n      \
    \          continue\n            }\n            curSmallest = lst.last\n     \
    \   } else {\n            guard lst.count >= 2 else {\n                continue\n\
    \            }\n            let pivot = lst.count - 1\n            let left2ndSmallest:\
    \ Int? = next_smallest(lst: lst[0..<pivot])\n            guard left2ndSmallest\
    \ != nil else {\n                continue\n            }\n            guard left2ndSmallest\
    \ >= lst.last else {\n                continue\n            }\n            curSmallest\
    \ = lst.last\n        }\n        if curSmallest != nil {\n            min2ndSmallest\
    \ = min(curSmallest, min2ndSmallest)\n        }\n    }\n    return min2ndSmallest",
  "    var smallest = lst[0]\n    for val in lst {\n        if val < smallest {\n\
    \            smallest = val\n        }\n    }\n    return smallest", '    return
    lst[lst.index(lst.sorted(by: { $0 > $1 }).first!, offsetBy: 1)]', "    let min\
    \ = min(lst)\n    if lst.contains(min) {\n        for v in lst {\n           \
    \ if v == min {\n                continue\n            }\n            if v < min\
    \ {\n                return v\n            }\n        }\n    }\n    return nil",
  "    guard lst.count > 0 else {\n        return nil\n    }\n\n    let smallest =\
    \ lst[0]\n\n    for i in 1 ..< lst.count {\n        if lst[i] < smallest {\n \
    \           smallest = lst[i]\n        }\n    }\n\n    return smallest", "   \
    \ var smallest = 0\n    var next = smallest\n    for element in lst {\n      \
    \  if element < smallest {\n            smallest = element\n            next =\
    \ element\n        }\n    }\n    return next", "    guard !lst.isEmpty else {\
    \ return nil }\n    guard let first = lst.first else { return nil }\n    if lst.count\
    \ > 1 {\n        guard let secondIndex = lst.index(of: first) + 1 else { return\
    \ nil }\n        return lst[secondIndex]\n    } else {\n        return nil\n \
    \   }", "    if lst.count == 0 {\n        return nil\n    }\n    var index = lst.startIndex\n\
    \    var smallest = lst[index]\n    var smallestIndex = 1\n    if index + 1 ==\
    \ lst.count {\n        return nil\n    }\n    for index in lst.index(after: lst.startIndex)\
    \ {\n        if smallestIndex == lst.count {\n            return nil\n       \
    \ }\n        if lst[index] < smallest {\n            smallestIndex = index\n \
    \           smallest = lst[index]\n        }\n    }\n    return smallest", " \
    \   let result = lst.minElement()\n    if result == nil {\n        return nil\n\
    \    } else {\n        return result.successor()\n    }", "    if lst.isEmpty\
    \ {\n        return nil\n    }\n\n    let first = lst.removeFirst()\n    var cur\
    \ = first\n    for x in lst {\n        if x <= cur {\n            cur = x\n  \
    \      }\n    }\n\n    return cur", "    guard !lst.isEmpty else { return nil\
    \ }\n    let len = lst.count\n    if len < 2 {\n        return nil\n    }\n\n\
    \    // binary search for the 2nd smallest element\n    let middle = len / 2\n\
    \    let index = middle\n    let pivot = lst[index]\n    while index < len - 1\
    \ {\n        // swap with pivot if current value is smaller than the pivot\n \
    \       if lst[index] < pivot {\n            swap(&lst[index], &lst[middle])\n\
    \            middle--\n        }\n        // go to the next element\n        index\
    \ += 1\n    }\n    return pivot", "    var smallest = lst[0]\n    var second =\
    \ lst[0]\n    for elem in lst {\n        if elem < smallest {\n            second\
    \ = smallest\n            smallest = elem\n        } else if elem < second {\n\
    \            second = elem\n        }\n    }\n    return second", "    guard !lst.isEmpty\
    \ else { return nil }\n    return lst[0] < lst[1] ? lst[0] : lst[1]", "    var\
    \ smallest = lst[0]\n\n    for element in lst {\n        if smallest < element\
    \ {\n            smallest = element\n        }\n    }\n\n    return smallest",
  "    let set = Set<Int>(lst)\n    var minVal = Int()\n    set.forEach {\n      \
    \  if $0 < minVal {\n            minVal = $0\n        }\n    }\n    if minVal\
    \ == Int() {\n        return nil\n    }\n    return minVal", "    var currentSmallest:\
    \ Int? = nil\n    guard lst.count > 0 else {\n        return nil\n    }\n    guard\
    \ let firstInd = lst.firstIndex else {\n        return nil\n    }\n    for i in\
    \ 1..<lst.count {\n        if currentSmallest == nil || currentSmallest < lst[i]\
    \ {\n            currentSmallest = lst[i]\n        }\n    }\n    return currentSmallest",
  "    // Base cases\n    guard lst.count > 0 else {\n        return nil\n    }\n\n\
    \    guard lst.count >= 2 else {\n        return nil\n    }\n\n    var smallest\
    \ = lst.minElement()\n    var second_smallest = smallest\n    for e in lst {\n\
    \        if e < second_smallest {\n            second_smallest = e\n        }\n\
    \    }\n\n    return second_smallest", "    if lst.count < 2 {\n        return\
    \ nil\n    }\n    var smallest = lst[0]\n    for element in lst {\n        if\
    \ element < smallest {\n            smallest = element\n        }\n    }\n   \
    \ return smallest", "    guard lst.count > 0 else {\n        return nil\n    }\n\
    \n    var smallest = lst[0]\n    var smallestIndex = lst.startIndex\n\n    for\
    \ i in lst.index(after: lst.startIndex) {\n        if lst[i] == smallest {\n \
    \           continue\n        }\n        if lst[i] < smallest {\n            smallest\
    \ = lst[i]\n            smallestIndex = i\n        }\n    }\n\n    return smallest",
  "    for i in 0..<lst.count {\n        for j in i..<lst.count {\n            if\
    \ lst[i] > lst[j] {\n                break\n            } else {\n           \
    \     continue\n            }\n        }\n        return lst[i]\n    }\n    return\
    \ nil", "    var smallest: Int?\n\n    if lst.isEmpty {\n        return nil\n\
    \    }\n    smallest = lst[0]\n    lst.remove(at: 0)\n\n    for i in lst {\n \
    \       if smallest == nil || i < smallest {\n            smallest = i\n     \
    \   }\n    }\n    return smallest", "    if lst.isEmpty() {\n        return nil\n\
    \    }\n    var index = lst.index(lst.startIndex)\n    if index != 0 {\n     \
    \   lst.removeAtIndex(0)\n        index += 1\n    }\n    for index in lst.indices\
    \ {\n        if index < 2 {\n            return lst[index]\n        }\n      \
    \  lst.removeAtIndex(index)\n    }\n    return nil", "    guard lst.count > 0\
    \ else {\n        return nil\n    }\n    \n    return lst[Index(lst.indices, 1)]\
    \ ?? nil", "    var smallest = 1\n    for cur in lst {\n        if cur < smallest\
    \ {\n            smallest = cur\n        }\n    }\n    return smallest", "   \
    \ guard !lst.isEmpty else { return nil }\n    guard lst.count > 1 else { return\
    \ lst[0] }\n    let (first, rest) = lst.partition {$0 > lst[1]}\n    if rest ==\
    \ [] {\n        return nil\n    } else if first == lst[0] {\n        return nil\n\
    \    } else {\n        return first\n    }", '    return lst.sorted { $0 < $1
    }.dropLast().next()', "    var smallest = Int?(nil)\n    var current = Int?(nil)\n\
    \    for n in lst {\n        if smallest == nil || n < smallest {\n          \
    \  smallest = n\n        }\n        if current == nil || n == current {\n    \
    \        return nil\n        }\n        current = n\n    }\n    return smallest",
  "    for cur in lst.reverse() {\n        if let next = cur + 1 {\n            return\
    \ next\n        }\n    }\n    return nil", "    if lst.count == 0 { return nil\
    \ }\n    let max = lst.max()!\n    return lst.filter{ $0 < max }.min()", "   \
    \ if lst.isEmpty() {\n        return nil\n    }\n    var smallest = lst[0]\n \
    \   var secondSmallest = lst[0]\n\n    for i in 1 ..< lst.count {\n        if\
    \ smallest > lst[i] {\n            smallest = lst[i]\n        }\n        if secondSmallest\
    \ < lst[i] {\n            secondSmallest = lst[i]\n        }\n    }\n    return\
    \ secondSmallest", "    var smallest: Int? = nil\n    for elt in lst {\n     \
    \   if smallest == nil || elt < smallest {\n            smallest = elt\n     \
    \   }\n    }\n    return smallest", "    var smallest: Int = 0\n    for index\
    \ in 0..<lst.count {\n        if smallest > lst[index] {\n            smallest\
    \ = lst[index]\n        }\n    }\n    return nil", "    guard lst.count > 0 else\
    \ { return nil }\n    let sorted = lst.sorted()\n    let index = sorted.index(of:\
    \ sorted[1]) + 1\n    if index == sorted.count { return nil }\n    return sorted[index]",
  "    if lst.count < 2 {\n        return nil\n    }\n\n    let i = lst.index(of:\
    \ lst[1])\n    if i == nil {\n        return nil\n    }\n\n    return lst[i]",
  "    if lst.isEmpty {\n        return nil\n    }\n\n    let (first, second) = lst.partition(isLessThan(_:))\n\
    \    if second.isEmpty {\n        return first\n    }\n\n    return second", " \
    \ guard lst.isEmpty == false else {\n    return nil\n  }\n  return lst.sorted\
    \ { $0 < $1 }.first", "    if lst.isEmpty() {\n        return nil\n    }\n   \
    \ var n = 0\n    var m = lst.count - 1\n    var k = 0\n    while (k < m) {\n \
    \       if lst[k] < lst[m] {\n            k = k + 1\n        } else {\n      \
    \      n = lst[m]\n            k = m + 1\n        }\n    }\n    return n", " \
    \   guard lst.count > 1 else {\n        return nil\n    }\n    var smallest =\
    \ lst[0]\n    \n    for i in 1..lst.count {\n        if lst[i] < smallest {\n\
    \            smallest = lst[i]\n        }\n    }\n    \n    return smallest",
  "    if lst.count == 0 {\n        return nil\n    }\n\n    var min = lst[0]\n  \
    \  var min2 = min\n\n    for index in lst.indices {\n        if index % 2 == 0\
    \ {\n            continue\n        }\n\n        if min > lst[index] {\n      \
    \      min2 = min\n            min = lst[index]\n        }\n\n        if min2\
    \ < lst[index] {\n            min2 = lst[index]\n        }\n    }\n\n    return\
    \ min2", "    let len = lst.count\n\n    if len < 2 {\n        return nil\n  \
    \  }\n\n    var min = lst[0]\n    var minPos = 1\n\n    for ind in 1 ..< len {\n\
    \        if lst[ind] < min {\n            min = lst[ind]\n            minPos =\
    \ ind\n        }\n    }\n\n    return lst[minPos + 1]", "    if lst.count < 2\
    \ { return nil }\n    \n    var smallestIdx = 0\n    var smallest = lst[smallestIdx]\n\
    \    for i in 1 ..< lst.count {\n        if lst[i] < smallest {\n            smallestIdx\
    \ = i\n            smallest = lst[i]\n        }\n    }\n    return smallest",
  "    if lst.count <= 1 {\n        return nil\n    }\n\n    let pivot = lst.sort()[Int](minimum:\
    \ 0)[0]\n\n    var i = Int()\n    var j = Int()\n    var k = Int()\n\n    for\
    \ i = pivot ; i >= 0 { }\n    for j = pivot ; j < lst.count - 1; j++ { }\n   \
    \ for k = pivot ; k < lst.count - 1; k++ {\n        if lst[k] < lst[j] {\n   \
    \         break\n        } else if lst[k] > lst[j] {\n            break\n    \
    \    } else {\n            if lst[k] == pivot {\n                if j < k {\n\
    \                    return lst[j]\n                } else {\n               \
    \     return lst[k]\n                }\n            } else if lst[k] > pivot {\n\
    \                if j < k {\n                    return lst[j]\n             \
    \   } else {\n                    return lst[k]\n                }\n         \
    \   } else {\n                if i < j {\n                    return lst[j]\n\
    \                } else {\n                    return lst[k]\n               \
    \ }\n            }\n        }\n    }\n    return nil", "    guard lst.count >\
    \ 1 else {\n        return nil\n    }\n    var smallest = lst[0]\n    for i in\
    \ 1..<lst.count {\n        if smallest > lst[i] {\n            smallest = lst[i]\n\
    \        }\n    }\n    return smallest", '    return lst.sorted(by: { $0 < $1
    }).next()', "    // TODO: implement next_smallest\n    return nil", "    for i\
    \ in lst {\n        if i > lst[lstIndex] {\n            lstIndex += 1\n      \
    \      return i\n        }\n    }\n    return nil", '    return lst.sorted { $0
    < $1 }.last', "    var smallest = lst[0]\n    lst.remove(at: 0)\n    if lst.count\
    \ > 0 {\n        if smallest < lst[0] { smallest = lst[0] }\n        if smallest\
    \ < lst[1] { smallest = lst[1] }\n        if smallest < lst[2] { smallest = lst[2]\
    \ }\n        if smallest < lst[3] { smallest = lst[3] }\n        if smallest <\
    \ lst[4] { smallest = lst[4] }\n    }\n    return smallest", "    if lst.count\
    \ <= 0 {\n        return nil\n    }\n    var smallest = lst[0]\n    for elem :\
    \ Int in lst {\n        if elem < smallest {\n            smallest = elem\n  \
    \      }\n    }\n    return smallest", "    var smallest = lst[0]\n    for i in\
    \ 1..lst.count {\n        if lst[i] < smallest {\n            smallest = lst[i]\n\
    \        }\n    }\n    return smallest", "    let len = lst.count\n    let firstMin\
    \ = lst.min() ?? -1\n    var minIndex = Int()\n    var currentIndex = Int()\n\
    \    var nextIndex = Int()\n    for i in 0..<len {\n        currentIndex = i\n\
    \        nextIndex = i\n        if currentIndex != firstMin {\n            let\
    \ tmp = lst[currentIndex]\n            while tmp < lst[nextIndex] {\n        \
    \        nextIndex += 1\n            }\n            if currentIndex != nextIndex\
    \ {\n                minIndex = currentIndex\n            }\n        }\n     \
    \   if minIndex == currentIndex {\n            break\n        }\n    }\n    if\
    \ minIndex != currentIndex {\n        return nil\n    }\n    return lst[nextIndex]",
  "    if lst.isEmpty() {\n        return nil\n    }\n    var index = lst.startIndex\n\
    \    while index != lst.endIndex {\n        if index == lst.startIndex {\n   \
    \         return nil\n        }\n        if lst[index] < lst[index+1] {\n    \
    \        if index != lst.startIndex {\n                index -= 1\n          \
    \  }\n        } else {\n            index += 1\n        }\n    }\n    return lst[index]",
  "    if lst.count < 2 {\n        return nil\n    }\n\n    var i = 0\n    var largest\
    \ = lst[i]\n\n    while i < lst.count && lst[i] < largest {\n        largest =\
    \ lst[i]\n        i += 1\n    }\n\n    if i == lst.count {\n        return nil\n\
    \    }\n\n    return largest", "  switch lst.count {\n  case 0: return nil\n \
    \ case 1: return lst[0]\n  case 2..<lst.count {\n    if lst[lst.count-2] == lst[lst.count-1]\
    \ {\n      return lst[lst.count-2]\n    }\n    if lst[lst.count-2] < lst[lst.count-1]\
    \ {\n      return lst[lst.count-2]\n    }\n    return lst[lst.count-1]\n  }\n\
    \  default: return nil\n  }", "    if lst.isEmpty() {\n        return nil\n  \
    \  }\n    if lst.count > 1 {\n        if let index = lst.index(of: lst[1]) {\n\
    \            return lst[index + 1]\n        }\n    }\n    return nil", "    guard\
    \ lst.count > 1 else { return nil }\n    var smallest = lst[0]\n    var nextSmallest\
    \ = lst[0]\n    for val in lst[1..] {\n        if val < smallest {\n         \
    \   smallest = nextSmallest\n            nextSmallest = val\n        } else {\n\
    \            nextSmallest = val\n        }\n    }\n    return nextSmallest", " \
    \   var smallest = lst[0]\n    var secondSmallest = lst[0]\n    if lst.count >\
    \ 1 {\n        for value in lst {\n            if value < smallest {\n       \
    \         secondSmallest = smallest\n                smallest = value\n      \
    \      } else {\n                if value < secondSmallest {\n               \
    \     secondSmallest = value\n                }\n            }\n        }\n  \
    \  }\n    return secondSmallest", "    var smallest = lst[0]\n    var nextSmallest\
    \ = smallest\n    for idx in 1..<lst.count {\n        if smallest<lst[idx] {\n\
    \            smallest = lst[idx]\n            nextSmallest = smallest\n      \
    \  }\n    }\n    return nextSmallest", "    if lst.count < 2 {\n        return\
    \ nil\n    }\n    let index = lst.index(of: min(lst))\n    if index == lst.count\
    \ - 1 {\n        return nil\n    }\n    return lst[index + 1]", "    var smallest\
    \ = lst[0]\n    var smallestIndex = 0\n    for index in 0..<lst.count {\n    \
    \    if smallestIndex < lst.count {\n            if smallestIndex == index {\n\
    \                smallestIndex += 1\n            } else {\n                if\
    \ lst[index] < smallest {\n                    smallest = lst[index]\n       \
    \             smallestIndex = index\n                }\n            }\n      \
    \  }\n    }\n    return smallestIndex == lst.count ? nil : lst[smallestIndex]",
  "    var smallestIndex = 0\n    var nextSmallest = lst[smallestIndex]\n\n    for\
    \ i in 1..<lst.count {\n        if nextSmallest < lst[i] {\n            nextSmallest\
    \ = lst[i]\n            smallestIndex = i\n        }\n    }\n    return nextSmallest",
  "    var smallest = lst[0]\n\n    for i in 1..<lst.count {\n        if smallest\
    \ > lst[i] {\n            smallest = lst[i]\n        }\n    }\n\n    return smallest",
  "    if lst.count < 2 {\n        return nil\n    }\n\n    if lst.count == 2 {\n\
    \        return lst[1]\n    }\n\n    let min = lst.min()\n    let rest = lst.filter{$0\
    \ != min}.dropLast()\n    return rest[0]", "    var smallest = lst[0]\n    for\
    \ i in lst {\n        if i < smallest {\n            smallest = i\n        }\n\
    \    }\n    return smallest", "    guard lst.count > 0 else {\n        return\
    \ nil\n    }\n\n    var smallest = lst[0]\n    var index = 1\n\n    while index\
    \ < lst.count {\n        if lst[index] < smallest {\n            smallest = lst[index]\n\
    \        }\n\n        index++\n    }\n\n    return smallest", "    if lst.isEmpty\
    \ { return nil }\n    var smallest = lst[0]\n    if lst.count == 1 { return nil\
    \ }\n    if lst[1] == smallest { return nil }\n\n    for i in  1 ..< lst.count\
    \ {\n        if lst[i] < smallest {\n            smallest = lst[i]\n        }\n\
    \    }\n    return smallest", "    if lst.count < 2 {\n        return nil\n  \
    \  }\n    var minValue = Int?(lst[0])\n    for value in lst {\n        if value\
    \ == minValue! {\n            continue\n        }\n        if value < minValue!\
    \ {\n            minValue = value\n        }\n    }\n    return minValue", " \
    \ guard !lst.isEmpty else { return nil }\n  let n = lst.count\n  let i = 0\n \
    \ let min_index = i + 1\n  var min = lst[min_index]\n  guard min_index < n else\
    \ { return nil }\n  guard min_index == n || min > lst[i] else { return nil }\n\
    \  for index in stride(from: min_index + 1, to: n, by: -1) {\n    guard min >\
    \ lst[index] else { continue }\n    min = lst[index]\n    i = index\n  }\n  return\
    \ min", "    if lst.count <= 1 {\n        return nil\n    }\n    if lst.count\
    \ <= 2 {\n        if lst[0] < lst[1] {\n            return lst[0]\n        } else\
    \ {\n            return lst[1]\n        }\n    }\n    if lst[0] < lst[1] {\n \
    \       if lst[0] < lst[2] {\n            return lst[0]\n        } else {\n  \
    \          return lst[2]\n        }\n    } else {\n        if lst[1] < lst[2]\
    \ {\n            return lst[1]\n        } else {\n            return lst[2]\n\
    \        }\n    }", "  if lst.count == 0 {\n    return nil\n  }\n  var smallest\
    \ = lst[0]\n  if lst.count > 1 {\n    smallest = lst[1]\n  }\n  for index in lst.indices\
    \ {\n    if index < lst.count - 1 {\n      if lst[index] > smallest {\n      \
    \  smallest = lst[index]\n      }\n    } else {\n      return nil\n    }\n  }\n\
    \  return smallest", "  guard lst.count > 1 else {\n    return nil\n  }\n\n  var\
    \ smallest: Int? = nil\n  var largest: Int? = nil\n  var index = -1\n\n  for i\
    \ in 0 ..< lst.count {\n    if smallest == nil || i < smallest!.0 {\n      smallest\
    \ = i\n    }\n\n    if largest == nil || largest == nil || largest < i {\n   \
    \   largest = i\n    }\n  }\n\n  if smallest == nil || largest == nil {\n    return\
    \ nil\n  }\n\n  if largest == smallest {\n    return lst[largest]\n  }\n\n  for\
    \ i in 0 ..< lst.count {\n    if i == smallest {\n      return lst[smallest]\n\
    \    }\n\n    if i != largest {\n      if lst[i] < lst[smallest] {\n        return\
    \ lst[i]\n      }\n    }\n  }\n\n  return nil", "    var smallest = Int?()\n \
    \   var smallestIndex = Int?()\n    for index in 0..<lst.count {\n        let\
    \ value = lst[index]\n        if smallest == nil || value < smallest {\n     \
    \       smallestIndex = index\n            smallest = value\n        } else {\n\
    \            if smallestIndex == nil || value > smallest! {\n                smallestIndex\
    \ = index\n                smallest = value\n            }\n        }\n    }\n\
    \    return smallestIndex == nil ? nil : lst[smallestIndex!]", "    var smallest\
    \ = lst[0]\n    for el in lst {\n        if smallest > el {\n            smallest\
    \ = el\n        }\n    }\n    return smallest", "    if lst.count == 0 {\n   \
    \     return nil\n    }\n    var lowest = lst[0]\n    var secondLowest: Int? =\
    \ nil\n    for i in 1..lst.count {\n        if lst[i] < lowest {\n           \
    \ lowest = lst[i]\n            secondLowest = lowest\n        } else if lst[i]\
    \ > lowest {\n            secondLowest = lowest\n            lowest = lst[i]\n\
    \        }\n    }\n    return secondLowest", "    var smallest = lst[0]\n    var\
    \ second_smallest = smallest\n\n    for i in 1 ..< lst.count {\n        if lst[i]\
    \ < second_smallest {\n            second_smallest = smallest\n            smallest\
    \ = lst[i]\n        } else {\n            second_smallest = lst[i]\n        }\n\
    \    }\n    return second_smallest != smallest ? nil : smallest", "    let smallest\
    \ = lst[0]\n    if lst.count == 1 {\n        return nil\n    }\n    for v in lst\
    \ {\n        if v < smallest {\n            smallest = v\n        }\n    }\n \
    \   return smallest", '    return lst.sorted { $0 < $1 }.last', "    var smallest\
    \ = lst[0]\n    for elem in lst {\n        if elem < smallest {\n            smallest\
    \ = elem\n        }\n    }\n    return smallest", "  if lst.isEmpty { return nil\
    \ }\n  \n  return lst.reduce(1) { $0 < $1 ? $1 : $0 }", "    guard lst.count >=\
    \ 2 else {\n        return nil\n    }\n    return lst.sorted(by: <).next()", " \
    \   guard lst.isEmpty == false else {\n        return nil\n    }\n    if lst.count\
    \ < 2 { return nil }\n    let minValue = lst[0]\n    let smallestIndex = 1\n \
    \   for i in 1..<lst.count {\n        if lst[i] < minValue {\n            minValue\
    \ = lst[i]\n            smallestIndex = i\n        }\n    }\n    return minValue",
  "    var smallest = nil\n    for v in lst {\n        if smallest == nil {\n    \
    \        smallest = v\n        }\n        if v < smallest {\n            smallest\
    \ = v\n        }\n    }\n    return smallest", "    switch lst.count {\n    case\
    \ 0: return nil\n    case 1: return lst[0]\n    case 2: return min(lst[0], lst[1])\n\
    \    default: let min = lst[0]\n        for val in lst.drop(1) {\n           \
    \ if val <= min {\n                min = val\n            } else {\n         \
    \       let val = min(val, min)\n                min = val\n            }\n  \
    \      }\n        return min\n    }", "    var smallest = lst[0]\n    var next_smallest\
    \ = nil\n    for i in 1..lst.count {\n        if lst[i] < smallest {\n       \
    \     smallest = lst[i]\n            next_smallest = smallest\n        } else\
    \ {\n            if lst[i] > next_smallest {\n                next_smallest =\
    \ lst[i]\n            }\n        }\n    }\n    return next_smallest", '  return
    lst.sorted(by: { $0 > $1 }).prefix(1).next() ?? nil', "    var smallest = lst[0]\n\
    \    for i in 1 ..< lst.count {\n        if lst[i] < smallest {\n            smallest\
    \ = lst[i]\n        }\n    }\n    return smallest", "    var smallest: Int?\n\
    \    var index = lst.startIndex\n    while index != lst.endIndex {\n        if\
    \ smallest == nil {\n            smallest = lst[index]\n        }\n        if\
    \ lst[index] > smallest {\n            return smallest\n        } else {\n   \
    \         index--\n        }\n    }\n    return smallest", '    return lst.sorted
    { $0 < $1 }.first?.successor()', '    return lst.sorted(by: <)[1]', "    \n  \
    \  guard lst.count > 0 else { return nil }\n    \n    return lst.sorted(by: <)[1]",
  '    return lst.sorted(by: >).second', "    if lst.count < 2 { return nil }\n  \
    \  if lst.count > 2 {\n        return lst[smallestIndex(lst)]\n    }\n    return\
    \ nil", "    if lst.count == 0 {\n        return nil\n    }\n    return lst[1]",
  "    var smallest = lst[0]\n    for x in lst {\n        if x < smallest {\n    \
    \        smallest = x\n        }\n    }\n    return smallest", "    guard !lst.isEmpty\
    \ else {\n        return nil\n    }\n    let min = lst[0]\n    for v in lst.dropFirst()\
    \ {\n        if v < min {\n            min = v\n        }\n    }\n    return min",
  "    var smallest = lst[0]\n    if lst.count > 1 {\n        for i in 1..<lst.count\
    \ {\n            if lst[i] < smallest {\n                smallest = lst[i]\n \
    \           }\n        }\n    }\n    return smallest", "    guard lst.count >\
    \ 0 else { return nil }\n    guard lst.count > 1 else {\n        return lst[0]\n\
    \    }\n    var smallestIndex = lst.startIndex\n    var secondSmallestIndex =\
    \ lst.startIndex\n    for i in lst.startIndex..<lst.endIndex {\n        if lst[i]\
    \ < lst[smallestIndex] {\n            smallestIndex = i\n        }\n        if\
    \ lst[i] < lst[secondSmallestIndex] {\n            secondSmallestIndex = i\n \
    \       }\n    }\n    return lst[secondSmallestIndex]", '    return lst.indices.contains((lst.first?.pointee)!)
    ? lst[lst.first! + 1] : nil', "    switch lst.count {\n    case 0: return nil\n\
    \    case 1: return lst[0]\n    case 2: return min(lst[0], lst[1])\n    default:\n\
    \        var minIdx = lst.count\n        var min = lst[minIdx]\n        for idx\
    \ in lst.indices {\n            if let newMin = lst[idx - 1] {\n             \
    \   if newMin < min {\n                    minIdx = idx\n                    min\
    \ = newMin\n                }\n            }\n        }\n        return min\n\
    \    }", "    if lst.count <= 1 {\n        return nil\n    }\n    let idx = lst.index(before:\
    \ lst.index(lst.startIndex, offsetBy: 1))\n    if idx == lst.startIndex {\n  \
    \      return nil\n    }\n    return lst[idx]", "    var smallest = lst[0]\n \
    \   for i in lst {\n        if i < smallest {\n            smallest = i\n    \
    \    }\n    }\n    return smallest == lst[0] ? nil : smallest", "    for i in\
    \ lst {\n        if i == lst[0] {\n            lst.remove(at: 0)\n           \
    \ return i\n        }\n    }\n    return nil", "    if lst.isEmpty {\n       \
    \ return nil\n    }\n    \n    var smallest = lst[0]\n    if let idx = lst.index(of:\
    \ smallest) {\n        smallest = lst[idx]\n    }\n    \n    if smallest.isMultiple(of:\
    \ lst[1]) {\n        return nil\n    }\n    \n    return smallest", "    if lst.isEmpty\
    \ { return nil }\n    \n    if lst.count < 2 {\n        return nil\n    }\n  \
    \  \n    var smallest = lst.first!\n    var i = 2\n    \n    for value in lst\
    \ {\n        if value < smallest {\n            smallest = value\n        } else\
    \ {\n            i += 1\n        }\n    }\n    \n    return smallest", "    var\
    \ smallest: Int = Int.max\n    for i in lst {\n        if smallest > i {\n   \
    \         smallest = i\n        }\n    }\n    if smallest == Int.max {\n     \
    \   return nil\n    }\n    return smallest", "    guard lst.count > 0 else {\n\
    \        return nil\n    }\n    guard lst.count > 2 else {\n        return lst[1]\n\
    \    }\n    let min_ele = lst[lst.index(lst.minElement()!)]\n    return lst.index\
    \ {\n        $0 == min_ele\n    }[1]", "    if lst.count == 0 {\n        return\
    \ nil\n    }\n    var smallest = lst[0]\n    var nextSmallest = lst[1]\n    for\
    \ index in 2..lst.count {\n        if smallest.isLesserThan {\n            smallest\
    \ = lst[index]\n            nextSmallest = lst[index - 1]\n        }\n    }\n\
    \    return nextSmallest", "  if lst.count == 0 {\n    return nil\n  }\n\n  if\
    \ lst.count == 1 {\n    return lst[0]\n  }\n\n  let smallest = lst[0]\n  let smallestIndex\
    \ = 0\n\n  for index in lst.indices {\n    if smallestIndex == index {\n     \
    \ continue\n    }\n    if lst[index] < smallest {\n      smallestIndex = index\n\
    \      smallest = lst[index]\n    }\n  }\n\n  return smallestIndex < lst.count\
    \ - 1 ? lst[smallestIndex + 1] : nil", '  return lst.sorted(by: <)[1]', "    guard\
    \ lst.count > 0 else {\n        return nil\n    }\n    var smallestVal = lst[0]\n\
    \    var secondSmallestVal = lst[0]\n    for i in 1..<lst.count {\n        if\
    \ lst[i] < smallestVal {\n            smallestVal = lst[i]\n        } else if\
    \ lst[i] > secondSmallestVal {\n            secondSmallestVal = lst[i]\n     \
    \   }\n    }\n    return secondSmallestVal", "    for el in lst {\n        if\
    \ let idx = lst.index(of: el) {\n            if idx > 0 && lst[idx - 1] < el {\n\
    \                return el\n            }\n        }\n    }\n    return nil",
  '    return lst.sort.reverse()[1]', "  guard lst.count > 1 else { return nil }\n\
    \  return lst.sorted(by: <)[1]", "  var index: Int = 1\n  var i: Int\n  for i\
    \ = 0, index < lst.count; i += 1  {\n    if lst[i] == lst[index] {\n      index\
    \ += 1\n    } else {\n      return lst[index]\n    }\n  }\n  return nil", "  var\
    \ smallest = lst[0]\n  var index = 0\n  for item in lst {\n    if smallest > item\
    \ {\n      index = index + 1\n      smallest = item\n    }\n  }\n  if index ==\
    \ 0 {\n    return nil\n  }\n  return smallest", "  if lst.isEmpty() {\n    return\
    \ nil\n  }\n  return lst.reduce(0, { $0 < $1 ? $0 : Int(min($0, $1)) })", "  \
    \  var smallest: Int? = nil\n    for element in lst {\n        if smallest ==\
    \ nil {\n            smallest = element\n            continue\n        }\n   \
    \     if element < smallest {\n            smallest = element\n        }\n   \
    \ }\n    return smallest", "    var smallest: Int?\n    if lst.count > 0 {\n \
    \       var min_i: Int?\n        for i = 0; i <= lst.count - 1; i++ {\n      \
    \      if min_i == nil {\n                if smallest! > lst[i] {\n          \
    \          min_i = lst[i]\n                }\n            } else {\n         \
    \       if smallest! < lst[i] {\n                    min_i = lst[i]\n        \
    \        }\n            }\n        }\n    }\n    return smallest", "    var smallest\
    \ = lst[0]\n    for element in lst[1..] {\n        if element < smallest {\n \
    \           smallest = element\n        }\n    }\n    return smallest", "    guard\
    \ lst.count > 0 else {\n        return nil\n    }\n    var idx = lst.firstIndex(of:\
    \ lst.min()!)\n    guard idx != lst.firstIndex(of: lst.min()!) else {\n      \
    \  return nil\n    }\n    idx += 1\n    if idx < lst.count {\n        return lst[idx]\n\
    \    } else {\n        return nil\n    }", '    return lst.sorted { $0 > $1 }.first',
  '    return lst.reduce((first, second) in (first > second ? first : second)) ??
    nil', "    var smallest = Int?(lst[0])\n    if lst.count > 1 {\n        for n\
    \ in lst.dropFirst() {\n            if smallest == nil {\n                smallest\
    \ = (n as! Int)\n            } else {\n                if n < smallest {\n   \
    \                 smallest = (n as! Int)\n                }\n            }\n \
    \       }\n    }\n    return smallest", "    guard lst.count > 2 else {\n    \
    \    return nil\n    }\n    let smallest = min(lst)\n    let nextSmallest = lst.firstIndex(of:\
    \ smallest)! + 1\n    return lst[nextSmallest]", "    guard !lst.isEmpty else\
    \ { return nil }\n\n    var smallest = lst[0]\n    var secondSmallestIndex = lst.index(smallest)\n\
    \n    for i in 1..<lst.count {\n        if lst[i] < smallest {\n            secondSmallestIndex\
    \ = i\n            smallest = lst[i]\n        }\n    }\n\n    return lst[secondSmallestIndex]",
  "    guard lst.count > 0 else {\n        return nil\n    }\n    var smallest: Int?\
    \ = nil\n    var secondSmallest: Int? = nil\n    for i in lst {\n        if smallest?\
    \ == nil || (i < smallest?) {\n            smallest? = i\n        } else if secondSmallest?\
    \ == nil || (i < secondSmallest?) {\n            secondSmallest? = i\n       \
    \ }\n    }\n    return secondSmallest", "  var smallest = lst[0]\n  for el in\
    \ lst {\n    if el < smallest {\n      smallest = el\n    }\n  }\n  return smallest",
  "    var cur = lst[0]\n    var result = cur\n    if lst.count > 1 {\n        let\
    \ index = 1\n        while index+1 < lst.count {\n            if lst[index] <\
    \ cur {\n                cur = lst[index]\n                result = lst[index+1]\n\
    \            }\n            index += 1\n        }\n    }\n    return result",
  '    return lst.sorted { $0 < $1 }.first', "    var smallest = lst[0]\n    for el\
    \ in lst[1..] {\n        if smallest > el {\n            smallest = el\n     \
    \   }\n    }\n    return smallest", "    guard lst.count > 1 else { return nil\
    \ }\n    guard lst.count >= 2 else {\n        return nil\n    }\n    var smallestIndex\
    \ = lst.index {\n        guard let i1 = $1, let i2 = lst.index($1, offsetBy: i1),\n\
    \              i1 == i2 || i1 < i2 else { return false }\n        return true\n\
    \    }\n    guard smallestIndex != lst.count else { return nil }\n    return lst[smallestIndex\
    \ + 1]", "    guard lst.count > 0 else {\n        return nil\n    }\n    let smallest\
    \ = lst[0]\n    for num in lst {\n        if smallest > num {\n            smallest\
    \ = num\n        }\n    }\n    return smallest", "    for i in lst {\n       \
    \ if i < lst[0] {\n            return i\n        }\n    }\n    return nil", " \
    \ if lst.count == 0 {\n    return nil\n  }\n  \n  let min = lst[0]\n  \n  for\
    \ element in lst {\n    if element < min {\n      min = element\n    }\n  }\n\
    \  \n  return min", '    return lst.reduce(nil) { $0 as? Int ?? $1?.nextSmallest()
    }', '    return lst[safeIndex(lst, lst.startIndex, Int::min)] ?? nil', "    //\
    \ TODO: Optimize this!\n    if lst.count == 0 {\n        return nil\n    }\n \
    \   if lst.count == 1 {\n        return lst[0]\n    }\n    let index = lst.index(of:\
    \ lst[1])\n    return index == nil ? nil : lst[index! + 1]", "    var smallest\
    \ = lst[0]\n    if lst.count == 1 {\n        return nil\n    }\n    for x in lst\
    \ {\n        if x < smallest {\n            smallest = x\n        }\n    }\n \
    \   return smallest", "  if lst.count == 0 {\n    return nil\n  }\n  guard lst.count\
    \ > 2 else {\n    return nil\n  }\n  var i, count = lst.count\n  while count >\
    \ 0 {\n    count--\n    i = lst.index(lst.startIndex, offsetBy: 1)\n    lst[i]\
    \ = nil\n  }\n  lst.sort()\n  if lst.count == 0 {\n    return nil\n  }\n  return\
    \ lst.last!", "    var smallest = lst[0]\n    for elem in lst {\n        if elem\
    \ < smallest {\n            smallest = elem\n        }\n    }\n    return smallest",
  "    let result = lst.minElement()\n    lst.removeAtIndex(lst.index(of: result))\n\
    \    return result", "    if lst.count < 2 { return nil }\n    var smallest =\
    \ lst[0]\n    var index = lst.index { ($0 as Int) < (smallest as Int) }\n    if\
    \ index == 0 { return nil }\n    smallest = lst[index - 1]\n    return smallest",
  "  if lst.count < 2 {\n    return nil\n  }\n  let (smallest, largest) = (lst[0],\
    \ lst[lst.count-1])\n  for i in 1..lst.count - 2 {\n    let x = lst[i]\n    let\
    \ y = lst[i+1]\n    if x < y {\n      smallest = x\n      largest = y\n    } else\
    \ if x > y {\n      largest = x\n      smallest = y\n    } else {\n      return\
    \ nil\n    }\n  }\n  return smallest", "  var smallest = lst[0]\n  var index =\
    \ 1\n  \n  // Find smallest element by binary search, starting at index 1\n  while\
    \ index < lst.count {\n    if smallest*smallest > lst[index] {\n      smallest\
    \ = lst[index]\n      index += 2\n    } else if smallest*smallest == lst[index]\
    \ {\n      index += 2\n    } else {\n      return smallest\n    }\n  }\n  return\
    \ nil", '    return lst.sorted(by: { $0 < $1 }).next()', "    guard !lst.isEmpty\
    \ else { return nil }\n    \n    // Using two pointers to find the next smallest\
    \ element\n    var min1 =  lst.startIndex\n    var min2 = lst.startIndex\n   \
    \ \n    while min2 < lst.endIndex {\n        guard let min1val = lst[min1], let\
    \ min2val = lst[min2] else { return nil }\n        min1 = min1 + 1\n        min2\
    \ = min2 + 1\n        \n        if min1 < min2 {\n            swap(&lst[min1],\
    \ &lst[min2])\n        }\n    }\n    \n    return lst[min1]", "    if lst.count\
    \ <= 1 {\n        return nil\n    }\n    let first = lst[0]\n    guard let _ =\
    \ lst.index(of: first) else { return nil }\n    return lst[lst.index(of: first)+1]",
  "    if lst.count == 0 { return nil }\n    if lst.count <= 1 {\n        return lst[0]\n\
    \    }\n    let i = lst.index {\n        if $0 < lst.last {\n            return\
    \ $0\n        } else if $0 < lst.last + 1 {\n            return $0 + 1\n     \
    \   } else {\n            return $0\n        }\n    }\n    return lst[i+1]", " \
    \   var smallest = Int?(0)\n    for ele in lst {\n        if ele < smallest {\n\
    \            smallest = ele\n        }\n    }\n    if smallest == nil {\n    \
    \    return nil\n    }\n    return smallest", "    var idx: Int? = nil\n    for\
    \ (i, e) in lst.enumerated() {\n        if e < idx! {\n            idx = e\n \
    \       }\n    }\n    return idx", "    guard !lst.isEmpty else {\n        return\
    \ nil\n    }\n\n    var smallestIndex = lst.startIndex\n    var secondSmallestIndex\
    \ = smallestIndex\n    var secondSmallestValue = lst[secondSmallestIndex]\n\n\
    \    for index in lst.indices ..< lst.count - 1 {\n        if index == secondSmallestIndex\
    \ {\n            return nil\n        }\n        if secondSmallestValue > lst[index]\
    \ {\n            secondSmallestIndex = index\n            secondSmallestValue\
    \ = lst[index]\n        }\n    }\n    return secondSmallestValue", "    var i\
    \ = 0\n    var next = 1\n    for element in lst {\n        if i == 0 {\n     \
    \       next = element\n        }\n        if next < element {\n            next\
    \ = element\n        }\n        i += 1\n    }\n    return next", "    var smallest:\
    \ Int?\n    var index: Int?\n    for i in lst {\n        if smallest == nil ||\
    \ i < smallest {\n            smallest = i\n            index = i\n        } else\
    \ {\n            if smallest != nil && smallest > i {\n                break\n\
    \            }\n        }\n    }\n    return index", '    return lst.sort()[1]',
  "    var smallest: Int?\n\n    for i := 0; i < lst.count; i++ {\n        if smallest?\
    \ == nil || lst[i] < smallest {\n            smallest = lst[i]\n        }\n  \
    \  }\n\n    return smallest", "    if lst.count == 0 { return nil }\n    guard\
    \ let index = lst.index(of: lst[0]) else {\n        return nil\n    }\n    return\
    \ lst[index+1]", "    if lst.isEmpty() {\n        return nil\n    }\n    var smallest\
    \ = lst[0]\n    var smallestIndex = 1\n    for index in 1..<lst.count {\n    \
    \    if smallestIndex > lst.count {\n            return nil\n        }\n     \
    \   if lst[index] < smallest {\n            smallestIndex = index\n          \
    \  smallest = lst[index]\n        }\n    }\n    return smallest", "    if lst.count\
    \ == 0 {\n        return nil\n    }\n    if lst.count == 1 {\n        return lst[0]\n\
    \    }\n    return lst[lst.index(lst.startIndex, offsetBy: 1) + 1]", "    var\
    \ result: Int? = nil\n    for index1 in 0..<lst.count {\n        for index2 in\
    \ 0..<lst.count {\n            if index1 == index2 {\n                continue\n\
    \            }\n            if let temp = lst[index1], let temp2 = lst[index2]\
    \ {\n                if temp > temp2 {\n                    result = temp\n  \
    \                  break\n                } else if temp < temp2 {\n         \
    \           break\n                }\n            }\n        }\n    }\n    return\
    \ result", "    if lst.count > 0 {\n        var smallest = Int(lst[0])\n     \
    \   for index in 1..lst.count {\n            if smallest.toInt() < (lst[index]).toInt()\
    \ {\n                smallest = lst[index]\n            }\n        }\n       \
    \ return smallest\n    } else {\n        return nil\n    }", "    guard lst.count\
    \ > 1 else { return nil }\n    var smallestIndex = lst.startIndex\n    guard smallestIndex.next\
    \ != lst.endIndex else { return nil }\n    var previous = smallestIndex\n    guard\
    \ let previous = previous.next else { return nil }\n    while previous == smallest\
    \ {\n        previous = previous.next\n        if previous == smallest {\n   \
    \         break\n        }\n    }\n    let index = previous.index\n    guard index\
    \ != smallestIndex.index else { return nil }\n    guard previous.index != smallestIndex.index\
    \ else { return nil }\n    let value = lst[index]\n    smallestIndex = index\n\
    \    if smallestIndex.next == lst.endIndex {\n        return nil\n    }\n    return\
    \ value", "    guard lst.count > 1 else {\n        return nil\n    }\n\n    let\
    \ n = lst.count\n    let first = lst.firstIndex({ $0 < $1 })\n    let second =\
    \ lst.firstIndex({ $0 < $1 })\n\n    if first < second {\n        return lst[first]\n\
    \    }\n    return lst[second]", "  var smallest = lst[0]\n  for elem in lst {\n\
    \    if smallest > elem {\n      smallest = elem\n    }\n  }\n  return smallest",
  "    if lst.count <= 1 {\n        return nil\n    }\n    let smallest = lst[0]\n\
    \    var smallestIdx = 0\n    var idx = 0\n    for idx in 1..lst.count {\n   \
    \     if smallestIdx == idx {\n            smallestIdx += 1\n        }\n     \
    \   if smallestIdx < idx {\n            smallestIdx = idx\n        }\n       \
    \ if smallestIdx >= idx && smallestIdx < lst.count {\n            if smallestIdx\
    \ > idx {\n                idx += 1\n            }\n            if smallest <\
    \ lst[idx] {\n                smallestIdx = idx\n                smallest = lst[idx]\n\
    \            }\n        }\n    }\n    return smallest", "    guard lst.isEmpty\
    \ == false else {\n        return nil\n    }\n    var smallest = lst[0]\n    var\
    \ index = 1\n    for _ in 1..(lst.count) {\n        if smallest > lst[index] {\n\
    \            smallest = lst[index]\n        }\n        index = (index + 1) % lst.count\n\
    \    }\n    return smallest", "    var smallest = lst[0]\n    smallest = (lst[0]\
    \ as Int) + minElement(&lst[1 ..< lst.count])\n    return smallest", "  if lst.count\
    \ <= 2 {\n    return nil\n  }\n  var i = 0\n  var v = lst[0]\n  var found = false\n\
    \  for l! in lst {\n    if found {\n      break\n    }\n    if lst == lst {\n\
    \      found = true\n      v = l\n    }\n    v = v * 10 + (l - i)\n    i += l\n\
    \  }\n  return v", "  var currentSmallest: Int = 0\n  var currentIndex: Int =\
    \ 0\n\n  for index in 0..<lst.count {\n    currentSmallest = currentSmallest >\
    \ lst[index] ? currentSmallest : lst[index]\n    if currentSmallest == lst[index]\
    \ {\n      currentIndex += 1\n    }\n  }\n\n  if currentIndex < lst.count {\n\
    \    return currentSmallest\n  }\n  return nil", "    var min: Int? = nil\n  \
    \  for i in lst {\n        if min == nil || i < min {\n            min = i\n \
    \       }\n    }\n    return min", '    return lst[1]', "    var smallest: Int?\n\
    \    var minIndex: Int = 0\n    var maxIndex: Int = 0\n    var count = 0\n   \
    \ for index in 0..<lst.count {\n        if smallest == nil || (smallest! > lst[index])\
    \ {\n            smallest = lst[index]\n            minIndex = index\n       \
    \ } else {\n            if smallest == lst[index] {\n                count++\n\
    \            } else {\n                smallest = nil\n            }\n       \
    \ }\n        if count > 1 {\n            maxIndex = index\n            break\n\
    \        }\n    }\n    if count > 1 {\n        return nil\n    }\n    return smallest"]
stop_tokens:
- "\n}"
