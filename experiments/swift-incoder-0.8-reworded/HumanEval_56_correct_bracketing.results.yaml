language: swift
name: HumanEval_56_correct_bracketing
results:
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let startIdx = 0\n    let endIdx = brackets.characters.count\n    for idx\
    \ in 0..<endIdx {\n        guard brackets[idx] == '<' else {\n            return\
    \ false\n        }\n        if idx < startIdx {\n            return false\n  \
    \      }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpef2lehwt.swift:16:32: error: single-quoted string literal found,\
    \ use '\"'\n        guard brackets[idx] == '<' else {\n                      \
    \         ^~~\n                               \"<\"\n/tmp/tmpef2lehwt.swift:14:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    let endIdx\
    \ = brackets.characters.count\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpef2lehwt.swift:16:15: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        guard brackets[idx] == '<' else {\n              ^~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    for opening, closing := range brackets {\n        if opening != closing {\n\
    \            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpm_17yprv.swift:13:16: error: expected 'in' after for-each pattern\n\
    \    for opening, closing := range brackets {\n               ^\n/tmp/tmpm_17yprv.swift:13:16:\
    \ error: expected Sequence expression for for-each loop\n    for opening, closing\
    \ := range brackets {\n               ^\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracket_pairs = brackets.characters.split{$0 == \"<\"}\n    for pair\
    \ in bracket_pairs {\n        var first = pair.characters.split{$0 == \"<\"}.first!\n\
    \        var second = pair.characters.split{$0 == \">\"}.last!\n        guard\
    \ first != second else {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpo565f963.swift:13:34: error: 'characters' is unavailable: Please\
    \ use String directly\n    var bracket_pairs = brackets.characters.split{$0 ==\
    \ \"<\"}\n                                 ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpo565f963.swift:15:26: error: 'characters'\
    \ is unavailable: Please use Substring directly\n        var first = pair.characters.split{$0\
    \ == \"<\"}.first!\n                         ^~~~~~~~~~\nSwift.Substring:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n/tmp/tmpo565f963.swift:16:27: error: 'characters'\
    \ is unavailable: Please use Substring directly\n        var second = pair.characters.split{$0\
    \ == \">\"}.last!\n                          ^~~~~~~~~~\nSwift.Substring:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n/tmp/tmpo565f963.swift:13:9: warning: variable\
    \ 'bracket_pairs' was never mutated; consider changing to 'let' constant\n   \
    \ var bracket_pairs = brackets.characters.split{$0 == \"<\"}\n    ~~~ ^\n    let\n\
    /tmp/tmpo565f963.swift:15:13: warning: variable 'first' was never mutated; consider\
    \ changing to 'let' constant\n        var first = pair.characters.split{$0 ==\
    \ \"<\"}.first!\n        ~~~ ^\n        let\n/tmp/tmpo565f963.swift:16:13: warning:\
    \ variable 'second' was never mutated; consider changing to 'let' constant\n \
    \       var second = pair.characters.split{$0 == \">\"}.last!\n        ~~~ ^\n\
    \        let\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return true\n    }\n    var result: CharacterSet\
    \ = .init()\n    brackets = brackets.lowercased()\n    var opening = false\n \
    \   for c in brackets {\n        if opening = !opening {\n            if c ==\
    \ \">\" {\n                result.insert(\"<\")\n            } else if c == \"\
    <\" {\n                result.insert(\">\")\n            } else if c == \"{\"\
    \ {\n                result.insert(\"{\")\n            } else if c == \"}\" {\n\
    \                result.insert(\"}\")\n            } else if c == \"(\" {\n  \
    \              result.insert(\"(\")\n            } else if c == \")\" {\n    \
    \            result.insert(\")\")\n            }\n        }\n    }\n    return\
    \ !result.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp437k9isk.swift:16:17: error: cannot find type 'CharacterSet' in\
    \ scope\n    var result: CharacterSet = .init()\n                ^~~~~~~~~~~~\n\
    /tmp/tmp437k9isk.swift:17:5: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n    brackets = brackets.lowercased()\n    ^~~~~~~~\n/tmp/tmp437k9isk.swift:20:20:\
    \ error: use of '=' in a boolean context, did you mean '=='?\n        if opening\
    \ = !opening {\n           ~~~~~~~ ^ ~\n                   ==\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // The brackets parameter is guaranteed to be non-empty and\n    // contain\
    \ at least one pair of \"<\" and \">\" characters.\n    var bracketCount = 0\n\
    \    for i in 0..<brackets.characters.count {\n        if brackets.characters[i]\
    \ == '<' {\n            bracketCount += 1\n        } else if brackets.characters[i]\
    \ == '>' {\n            bracketCount -= 1\n        }\n    }\n    return bracketCount\
    \ == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpx_5j_gtt.swift:17:38: error: single-quoted string literal found,\
    \ use '\"'\n        if brackets.characters[i] == '<' {\n                     \
    \                ^~~\n                                     \"<\"\n/tmp/tmpx_5j_gtt.swift:19:45:\
    \ error: single-quoted string literal found, use '\"'\n        } else if brackets.characters[i]\
    \ == '>' {\n                                            ^~~\n                \
    \                            \">\"\n/tmp/tmpx_5j_gtt.swift:16:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    for i in 0..<brackets.characters.count\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpx_5j_gtt.swift:17:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ brackets.characters[i] == '<' {\n           ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx_5j_gtt.swift:17:21:\
    \ error: 'characters' is unavailable: Please use String directly\n        if brackets.characters[i]\
    \ == '<' {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpx_5j_gtt.swift:19:19: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        }\
    \ else if brackets.characters[i] == '>' {\n                  ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx_5j_gtt.swift:19:28:\
    \ error: 'characters' is unavailable: Please use String directly\n        } else\
    \ if brackets.characters[i] == '>' {\n                           ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.replacingOccurrences(of: \"<<\", with: \"<\")\n    brackets\
    \ = brackets.replacingOccurrences(of: \">>\", with: \">\")\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<<=\", with: \"<=\")\n    brackets = brackets.replacingOccurrences(of: \"\
    >>=\", with: \">=\")\n    brackets = brackets.replacingOccurrences(of: \"<<->\"\
    , with: \"<->\")\n    brackets = brackets.replacingOccurrences(of: \">>->\", with:\
    \ \">->\")\n    brackets = brackets.replacingOccurrences(of: \"<<<\", with: \"\
    <<\")\n    brackets = brackets.replacingOccurrences(of: \">>>\", with: \">>\"\
    )\n    brackets = brackets.replacingOccurrences(of: \"<<<=\", with: \"<<=\")\n\
    \    brackets = brackets.replacingOccurrences(of: \">>>=\", with: \">>>=\")\n\
    \    brackets = brackets.replacingOccurrences(of: \"<<->=\", with: \"<<->=\")\n\
    \    brackets = brackets.replacingOccurrences(of: \">>->=\", with: \">>->=\")\n\
    \    brackets = brackets.replacingOccurrences(of: \"<<<->\", with: \"<<<->\")\n\
    \    brackets = brackets.replacingOccurrences(of: \">>>->\", with: \">>>->\")\n\
    \    brackets = brackets.replacingOccurrences(of: \"<<->->\", with: \"<<->->\"\
    )\n    brackets = brackets.replacingOccurrences(of: \">>->->\", with: \">>->->\"\
    )\n    brackets = brackets.replacingOccurrences(of: \"<<<->=\", with: \"<<<->=\"\
    )\n    brackets = brackets.replacingOccurrences(of: \">>>->=\", with: \">>>->=\"\
    )\n    brackets = brackets.replacingOccurrences(of: \"<<->->=\", with: \"<<->->=\"\
    )\n    brackets = brackets.replacingOccurrences(of: \">>->->=\", with: \">>->->=\"\
    )\n    brackets = brackets.replacingOccurrences(of: \"<<<->->\", with: \"<<<->->\"\
    )\n    brackets = brackets.replacingOccurrences(of: \">>>->->\", with: \">>>->->\"\
    )\n    brackets = brackets.replacingOccurrences(of: \"<<->->->\", with\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkch63tjs.swift:36:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpkch63tjs.swift:35:45: note: to match this opening '('\n    brackets\
    \ = brackets.replacingOccurrences(of: \"<<->->->\", with\n                   \
    \                         ^\n/tmp/tmpkch63tjs.swift:13:5: error: cannot assign\
    \ to value: 'brackets' is a 'let' constant\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<<\", with: \"<\")\n    ^~~~~~~~\n/tmp/tmpkch63tjs.swift:13:25: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<<\", with: \"<\")\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkch63tjs.swift:14:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.replacingOccurrences(of: \">>\", with: \">\")\n    ^~~~~~~~\n/tmp/tmpkch63tjs.swift:14:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    brackets\
    \ = brackets.replacingOccurrences(of: \">>\", with: \">\")\n               ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkch63tjs.swift:15:5: error: cannot assign to value:\
    \ 'brackets' is a 'let' constant\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<<=\", with: \"<=\")\n    ^~~~~~~~\n/tmp/tmpkch63tjs.swift:15:25: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<<=\", with: \"<=\")\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkch63tjs.swift:16:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.replacingOccurrences(of: \">>=\", with: \">=\")\n    ^~~~~~~~\n/tmp/tmpkch63tjs.swift:16:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    brackets\
    \ = brackets.replacingOccurrences(of: \">>=\", with: \">=\")\n               ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkch63tjs.swift:17:5: error: cannot assign to value:\
    \ 'brackets' is a 'let' constant\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<<->\", with: \"<->\")\n    ^~~~~~~~\n/tmp/tmpkch63tjs.swift:17:25: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n    bracket"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.replacingOccurrences(of: \"<\", with: \"<\")\n    brackets\
    \ = brackets.replacingOccurrences(of: \">\", with: \">\")\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<<\", with: \"<\")\n    brackets = brackets.replacingOccurrences(of: \">>\"\
    , with: \">\")\n    brackets = brackets.replacingOccurrences(of: \"<>\", with:\
    \ \"<>\")\n    brackets = brackets.replacingOccurrences(of: \"<<<\", with: \"\
    <\")\n    brackets = brackets.replacingOccurrences(of: \">>>\", with: \">\")\n\
    \    brackets = brackets.replacingOccurrences(of: \"<>\", with: \"<>\")\n    brackets\
    \ = brackets.replacingOccurrences(of: \"<<<\", with: \"<\")\n    brackets = brackets.replacingOccurrences(of:\
    \ \">>>\", with: \">\")\n    brackets = brackets.replacingOccurrences(of: \"<<<\"\
    , with: \"<\")\n    brackets = brackets.replacingOccurrences(of: \">>>\", with:\
    \ \">\")\n    brackets = brackets.replacingOccurrences(of: \"<<<\", with: \"<\"\
    )\n    brackets = brackets.replacingOccurrences(of: \">>>\", with: \">\")\n  \
    \  brackets = brackets.replacingOccurrences(of: \"<<<\", with: \"<\")\n    brackets\
    \ = brackets.replacingOccurrences(of: \">>>\", with: \">\")\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<<<\", with: \"<\")\n    brackets = brackets.replacingOccurrences(of: \">>>\"\
    , with: \">\")\n    brackets = brackets.replacingOccurrences(of: \"<<<\", with:\
    \ \"<\")\n    brackets = brackets.replacingOccurrences(of: \">>>\", with: \">\"\
    )\n    brackets = brackets.replacingOccurrences(of: \"<<<\", with: \"<\")\n  \
    \  brackets = brackets.replacingOccurrences(of: \">>>\", with: \">\")\n    brackets\
    \ = brackets.replacingOccurrences(of: \"<<<\", with: \"<\")\n    brackets = brackets.replacingOccurrences(of:\
    \ \">>>\", with: \">\")\n    brackets = brackets.replacingOccurrences(of: \"<<<\"\
    , with: \"<\")\n    brackets = brackets.replacingOccurrences(of: \">>>\", with:\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpqis4n8m1.swift:39:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpqis4n8m1.swift:13:5: error: cannot assign to value: 'brackets' is\
    \ a 'let' constant\n    brackets = brackets.replacingOccurrences(of: \"<\", with:\
    \ \"<\")\n    ^~~~~~~~\n/tmp/tmpqis4n8m1.swift:13:25: error: value of type 'String'\
    \ has no member 'replacingOccurrences'\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<\", with: \"<\")\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqis4n8m1.swift:14:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.replacingOccurrences(of: \">\", with: \">\")\n    ^~~~~~~~\n/tmp/tmpqis4n8m1.swift:14:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    brackets\
    \ = brackets.replacingOccurrences(of: \">\", with: \">\")\n               ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqis4n8m1.swift:15:5: error: cannot assign to value:\
    \ 'brackets' is a 'let' constant\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<<\", with: \"<\")\n    ^~~~~~~~\n/tmp/tmpqis4n8m1.swift:15:25: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<<\", with: \"<\")\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqis4n8m1.swift:16:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.replacingOccurrences(of: \">>\", with: \">\")\n    ^~~~~~~~\n/tmp/tmpqis4n8m1.swift:16:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    brackets\
    \ = brackets.replacingOccurrences(of: \">>\", with: \">\")\n               ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqis4n8m1.swift:17:5: error: cannot assign to value:\
    \ 'brackets' is a 'let' constant\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<>\", with: \"<>\")\n    ^~~~~~~~\n/tmp/tmpqis4n8m1.swift:17:25: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<>\", with: \"<>\")\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqis4n8m1.swift:18:5:\
    \ error: cannot assign to value: 'brackets' is a '"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var hasCorrectlyBracketing = 0\n    var i = 0\n    var lastOpeningBracket:\
    \ String = \"\"\n    var lastClosingBracket: String = \"\"\n\n    while i < brackets.characters.count\
    \ {\n        let current = brackets.characters[i]\n\n        switch current {\n\
    \        case \"<\":\n            lastOpeningBracket = brackets.substringWithRange(i..<brackets.endIndex).lowercaseString\n\
    \            i = i + 1\n            lastClosingBracket = \"\"\n        case \"\
    <\":\n            lastClosingBracket = brackets.substringWithRange(i..<brackets.endIndex).lowercaseString\n\
    \            i = i + 1\n            lastOpeningBracket = \"\"\n        case \"\
    <\":\n            lastClosingBracket = brackets.substringWithRange(i..<brackets.endIndex).lowercaseString\n\
    \            i = i + 1\n            lastOpeningBracket = \"\"\n        case \"\
    <\":\n            lastClosingBracket = brackets.substringWithRange(i..<brackets.endIndex).lowercaseString\n\
    \            i = i + 1\n            lastOpeningBracket = \"\"\n        case \"\
    <\":\n            lastClosingBracket = brackets.substringWithRange(i..<brackets.endIndex).lowercaseString\n\
    \            i = i + 1\n            lastOpeningBracket = \"\"\n        default:\n\
    \            lastClosingBracket = brackets.substringWithRange(i..<brackets.endIndex).lowercaseString\n\
    \            i = i + 1\n            lastOpeningBracket = \"\"\n        }\n\n \
    \       if lastOpeningBracket != lastClosingBracket {\n            hasCorrectlyBracketing\
    \ += 1\n        }\n    }\n\n    return hasCorrectlyBracketing == brackets.characters.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7r2zo5d3.swift:18:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    while i < brackets.characters.count {\n           \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp7r2zo5d3.swift:19:23: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        let current = brackets.characters[i]\n\
    \                      ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp7r2zo5d3.swift:19:32: error: 'characters'\
    \ is unavailable: Please use String directly\n        let current = brackets.characters[i]\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp7r2zo5d3.swift:23:43: error: value of type 'String'\
    \ has no member 'substringWithRange'\n            lastOpeningBracket = brackets.substringWithRange(i..<brackets.endIndex).lowercaseString\n\
    \                                 ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7r2zo5d3.swift:27:43:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \   lastClosingBracket = brackets.substringWithRange(i..<brackets.endIndex).lowercaseString\n\
    \                                 ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7r2zo5d3.swift:31:43:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \   lastClosingBracket = brackets.substringWithRange(i..<brackets.endIndex).lowercaseString\n\
    \                                 ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7r2zo5d3.swift:35:43:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \   lastClosingBracket = brackets.substringWithRange(i..<brackets.endIndex).lowercaseString\n\
    \                                 ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7r2zo5d3.swift:39:43:\
    \ error: value of t"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketMap = Dictionary<String, String>()\n    for character in brackets\
    \ {\n        if character == \"<\" {\n            bracketMap[\"<\"] = \"{\"\n\
    \        } else if character == \">\" {\n            bracketMap[\">\"] = \"}\"\
    \n        } else {\n            bracketMap[character] = \"{\"\n        }\n   \
    \ }\n    var isCorrupt = true\n    for character in bracketMap {\n        if character\
    \ == \"{\" {\n            isCorrupt = false\n        } else if character == \"\
    }\" {\n            isCorrupt = false\n        } else {\n            isCorrupt\
    \ = true\n        }\n    }\n    return !isCorrupt\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnp8l6xj0.swift:20:24: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            bracketMap[character] = \"{\"\
    \n                       ^\n/tmp/tmpnp8l6xj0.swift:25:22: error: type '(key: String,\
    \ value: String)' cannot conform to 'StringProtocol'\n        if character ==\
    \ \"{\" {\n                     ^\n/tmp/tmpnp8l6xj0.swift:25:22: note: only concrete\
    \ types such as structs, enums and classes can conform to protocols\n        if\
    \ character == \"{\" {\n                     ^\n/tmp/tmpnp8l6xj0.swift:25:22:\
    \ note: required by referencing operator function '==' on 'StringProtocol' where\
    \ 'Self' = '(key: String, value: String)'\n        if character == \"{\" {\n \
    \                    ^\n/tmp/tmpnp8l6xj0.swift:27:29: error: type '(key: String,\
    \ value: String)' cannot conform to 'StringProtocol'\n        } else if character\
    \ == \"}\" {\n                            ^\n/tmp/tmpnp8l6xj0.swift:27:29: note:\
    \ only concrete types such as structs, enums and classes can conform to protocols\n\
    \        } else if character == \"}\" {\n                            ^\n/tmp/tmpnp8l6xj0.swift:27:29:\
    \ note: required by referencing operator function '==' on 'StringProtocol' where\
    \ 'Self' = '(key: String, value: String)'\n        } else if character == \"}\"\
    \ {\n                            ^\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let expectedBrackets = brackets.characters\n    guard expectedBrackets.count\
    \ >= 1 else {\n        return false\n    }\n    var bracketCount = 0\n    var\
    \ openBracket: Character\n    var isOpenBracket: Bool\n    for openBracket in\
    \ brackets {\n        bracketCount += 1\n        if openBracket == \"<\" {\n \
    \           isOpenBracket = false\n        } else if openBracket == \">\" {\n\
    \            isOpenBracket = true\n        } else {\n            return false\n\
    \        }\n    }\n    if bracketCount != expectedBrackets.count {\n        return\
    \ false\n    }\n    if bracketCount > 0 && !(isOpenBracket) {\n        return\
    \ false\n    }\n    if bracketCount <= 0 && !(isOpenBracket) {\n        return\
    \ true\n    }\n    var isFirst = true\n    for openBracket in brackets {\n   \
    \     bracketCount -= 1\n        if bracketCount == 0 {\n            if isFirst\
    \ {\n                isFirst = false\n            } else {\n                return\
    \ false\n            }\n        } else {\n            isFirst = true\n       \
    \ }\n        if openBracket == \"<\" {\n            isOpenBracket = true\n   \
    \     } else {\n            isOpenBracket = false\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3hmd3vpo.swift:13:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    let expectedBrackets = brackets.characters\n      \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3hmd3vpo.swift:18:9: warning: variable 'openBracket'\
    \ was never used; consider replacing with '_' or removing it\n    var openBracket:\
    \ Character\n        ^~~~~~~~~~~\n        _\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard brackets.count > 0 && brackets.contains(\"<\") && brackets.contains(\"\
    >\") else { return false }\n    var openingBracketsSeen = [Int]()\n    var closingBracketsSeen\
    \ = [Int]()\n    for i in 1..<brackets.count {\n        let c = brackets[i]\n\
    \        if openingBracketsSeen.contains(c) {\n            openingBracketsSeen.removeAtIndex(0)\n\
    \        }\n        openingBracketsSeen.insert(c, at: 0)\n        if closingBracketsSeen.contains(c)\
    \ {\n            closingBracketsSeen.removeAtIndex(0)\n        }\n        closingBracketsSeen.insert(c,\
    \ at: 0)\n    }\n\n    // There can't be an equal number of opening brackets and\
    \ closing brackets\n    // or they're all equal.\n    if openingBracketsSeen.count\
    \ == closingBracketsSeen.count {\n        return true\n    }\n\n    // If all\
    \ brackets are equal, there can be an equal number of left brackets\n    // and\
    \ right brackets, so that left brackets are on the same line as\n    // right\
    \ brackets.\n    var leftBrackets = openingBracketsSeen.count\n    var rightBrackets\
    \ = closingBracketsSeen.count\n    var numEqual = 0\n    while leftBrackets >\
    \ rightBrackets && numEqual < leftBrackets {\n        leftBrackets -= 1\n    \
    \    rightBrackets -= 1\n        numEqual++\n    }\n    if leftBrackets == rightBrackets\
    \ {\n        return true\n    }\n\n    // If they're not equal, there can't be\
    \ an equal number of left brackets\n    // and right brackets anyway, so no bracketing\
    \ can be corrected.\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjp5_8y5u.swift:17:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let c = brackets[i]\n\
    \                ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpjp5_8y5u.swift:18:41: error: cannot convert value\
    \ of type 'Character' to expected argument type 'Int'\n        if openingBracketsSeen.contains(c)\
    \ {\n                                        ^\n/tmp/tmpjp5_8y5u.swift:19:33:\
    \ error: value of type '[Int]' has no member 'removeAtIndex'\n            openingBracketsSeen.removeAtIndex(0)\n\
    \            ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpjp5_8y5u.swift:21:36:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \        openingBracketsSeen.insert(c, at: 0)\n                              \
    \     ^\n/tmp/tmpjp5_8y5u.swift:22:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if closingBracketsSeen.contains(c)\
    \ {\n                                        ^\n/tmp/tmpjp5_8y5u.swift:23:33:\
    \ error: value of type '[Int]' has no member 'removeAtIndex'\n            closingBracketsSeen.removeAtIndex(0)\n\
    \            ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpjp5_8y5u.swift:25:36:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \        closingBracketsSeen.insert(c, at: 0)\n                              \
    \     ^\n/tmp/tmpjp5_8y5u.swift:43:17: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        numEqual++\n                ^~\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBracketCount = 0\n    var lastOpeningBracket = String.Empty\n\
    \    var openingBracket = \"\"\n\n    for i := 0; i < len(brackets); i++ {\n \
    \       openingBracket := brackets[i]\n\n        // Handle the case where we've\
    \ started a bracket\n        if openingBracket == lastOpeningBracket {\n     \
    \       openingBracketCount++\n        } else {\n            // Check to see if\
    \ the current opening bracket is the last one\n            // we saw and if so,\
    \ we're done\n            if openingBracketCount > 0 {\n                // If\
    \ we're not done with opening brackets, fail\n                if openingBracketCount\
    \ == 1 {\n                    return false\n                }\n            }\n\
    \            lastOpeningBracket = openingBracket\n            openingBracketCount\
    \ = 0\n        }\n    }\n\n    // Check to see if we had any brackets left open\n\
    \    if openingBracketCount > 0 {\n        return false\n    }\n\n    // The brackets\
    \ are all closed\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpx9iinlin.swift:17:12: error: expected type\n    for i := 0; i <\
    \ len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpx9iinlin.swift:17:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets);\
    \ i++ {\n           ^\n/tmp/tmpx9iinlin.swift:17:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n   \
    \        ^\n/tmp/tmpx9iinlin.swift:18:23: error: consecutive statements on a line\
    \ must be separated by ';'\n        openingBracket := brackets[i]\n          \
    \            ^\n                      ;\n/tmp/tmpx9iinlin.swift:18:24: error:\
    \ expected expression\n        openingBracket := brackets[i]\n               \
    \        ^\n/tmp/tmpx9iinlin.swift:14:37: error: type 'String' has no member 'Empty'\n\
    \    var lastOpeningBracket = String.Empty\n                             ~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.components(separatedBy: \"<\")\n        .filter\
    \ { $0.characters.count != 0 }\n    let closingBrackets = brackets.components(separatedBy:\
    \ \">\")\n        .filter { $0.characters.count != 0 }\n\n    return openingBrackets.count\
    \ == closingBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpe8p55yr_.swift:13:36: error: value of type 'String' has no member\
    \ 'components'\n    let openingBrackets = brackets.components(separatedBy: \"\
    <\")\n                          ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpe8p55yr_.swift:15:36:\
    \ error: value of type 'String' has no member 'components'\n    let closingBrackets\
    \ = brackets.components(separatedBy: \">\")\n                          ~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    if brackets.count == 0 {\n\t\treturn true\n\t}\n\tvar openingBrackets = [String]()\n\
    \tvar closingBrackets = [String]()\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"<\", with: \"\")\n\tbrackets = brackets.replacingOccurrences(of: \">\", with:\
    \ \"\")\n\tbrackets = brackets.replacingOccurrences(of: \"<>\", with: \"<\")\n\
    \tbrackets = brackets.replacingOccurrences(of: \"<<>>\", with: \">>\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \">>\", with: \">\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"<=\", with: \"<<\")\n\tbrackets = brackets.replacingOccurrences(of: \"<=>\"\
    , with: \"<\")\n\tbrackets = brackets.replacingOccurrences(of: \"==\", with: \"\
    =\")\n\tbrackets = brackets.replacingOccurrences(of: \":=\", with: \"==\")\n\t\
    brackets = brackets.replacingOccurrences(of: \"=>\", with: \"==\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \">=\", with: \"==\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"<<=\", with: \"<<\")\n\tbrackets = brackets.replacingOccurrences(of: \"<=>=\"\
    , with: \"<\")\n\tbrackets = brackets.replacingOccurrences(of: \"=>=\", with:\
    \ \"==\")\n\tbrackets = brackets.replacingOccurrences(of: \">=>\", with: \"<\"\
    )\n\tbrackets = brackets.replacingOccurrences(of: \"<<=>\", with: \">>\")\n\t\
    brackets = brackets.replacingOccurrences(of: \"<>=\", with: \"<\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \"!==\", with: \"!=\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"<!=>\", with: \"<\")\n\tbrackets = brackets.replacingOccurrences(of: \"!=>\"\
    , with: \"!=\")\n\tbrackets = brackets.replacingOccurrences(of: \"!<=>\", with:\
    \ \"!\")\n\tbrackets = brackets.replacingOccurrences(of: \"!=\", with: \"\")\n\
    \tbrackets = brackets.replacingOccurrences(of: \"!=>=\", with: \"!\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \"!=\", with: \"\")\n\tbrackets = brackets.replacingOccurrences(of\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3eb2szqu.swift:43:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp3eb2szqu.swift:42:42: note: to match this opening '('\n        brackets\
    \ = brackets.replacingOccurrences(of\n                                       \
    \         ^\n/tmp/tmp3eb2szqu.swift:18:2: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n        brackets = brackets.replacingOccurrences(of: \"\
    <\", with: \"\")\n        ^~~~~~~~\n/tmp/tmp3eb2szqu.swift:18:22: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n        brackets = brackets.replacingOccurrences(of:\
    \ \"<\", with: \"\")\n                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3eb2szqu.swift:19:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingOccurrences(of: \">\", with: \"\")\n        ^~~~~~~~\n/tmp/tmp3eb2szqu.swift:19:22:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ brackets = brackets.replacingOccurrences(of: \">\", with: \"\")\n          \
    \         ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3eb2szqu.swift:20:2: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n        brackets = brackets.replacingOccurrences(of:\
    \ \"<>\", with: \"<\")\n        ^~~~~~~~\n/tmp/tmp3eb2szqu.swift:20:22: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        brackets\
    \ = brackets.replacingOccurrences(of: \"<>\", with: \"<\")\n                 \
    \  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3eb2szqu.swift:21:2: error: cannot assign\
    \ to value: 'brackets' is a 'let' constant\n        brackets = brackets.replacingOccurrences(of:\
    \ \"<<>>\", with: \">>\")\n        ^~~~~~~~\n/tmp/tmp3eb2szqu.swift:21:22: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        brackets\
    \ = brackets.replacingOccurrences(of: \"<<>>\", with: \">>\")\n              \
    \     ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3eb2szqu.swift:22:2: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n        brackets = brackets.replacingOccurrences(of:\
    \ \">>\", with: \">\")\n        ^~~~~~~~\n/tmp/tmp3eb2szqu.swift:22:22: error:\
    \ value of type 'String' "
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = brackets.characters.makeIterator()\n    var last = 0\n    while\
    \ stack.next() != nil {\n        let c = String(stack.next())\n        let isOpen\
    \ = c != \"<\"\n        if last+1 < stack.end() {\n            let next = String(stack.next())\n\
    \            if isOpen {\n                guard next != \"<\" else {\n       \
    \             return false\n                }\n                last = stack.end()\
    \ - 1\n            } else {\n                guard next != \">\" else {\n    \
    \                return false\n                }\n                last = stack.end()\
    \ - 1\n            }\n        } else {\n            guard isOpen else {\n    \
    \            return false\n            }\n            last = stack.end() - 1\n\
    \        }\n    }\n    return stack.next() == nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2pw5vt8k.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let stack = brackets.characters.makeIterator()\n  \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp2pw5vt8k.swift:15:17: error: cannot use mutating member\
    \ on immutable value: 'stack' is a 'let' constant\n    while stack.next() != nil\
    \ {\n          ~~~~~ ^\n/tmp/tmp2pw5vt8k.swift:13:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let stack = brackets.characters.makeIterator()\n   \
    \ ^~~\n    var\n/tmp/tmp2pw5vt8k.swift:16:17: error: no exact matches in call\
    \ to initializer \n        let c = String(stack.next())\n                ^\n/tmp/tmp2pw5vt8k.swift:16:17:\
    \ note: found candidate with type '(Character) -> String'\n        let c = String(stack.next())\n\
    \                ^\n/tmp/tmp2pw5vt8k.swift:16:17: note: found candidate with type\
    \ '(Character?) -> String'\n        let c = String(stack.next())\n           \
    \     ^\n/tmp/tmp2pw5vt8k.swift:16:17: note: found candidate with type '(Character?)\
    \ -> String'\n        let c = String(stack.next())\n                ^\n/tmp/tmp2pw5vt8k.swift:18:27:\
    \ error: value of type 'String.Iterator' has no member 'end'\n        if last+1\
    \ < stack.end() {\n                    ~~~~~ ^~~\n/tmp/tmp2pw5vt8k.swift:19:24:\
    \ error: no exact matches in call to initializer \n            let next = String(stack.next())\n\
    \                       ^\n/tmp/tmp2pw5vt8k.swift:19:24: note: found candidate\
    \ with type '(Character) -> String'\n            let next = String(stack.next())\n\
    \                       ^\n/tmp/tmp2pw5vt8k.swift:19:24: note: found candidate\
    \ with type '(Character?) -> String'\n            let next = String(stack.next())\n\
    \                       ^\n/tmp/tmp2pw5vt8k.swift:19:24: note: found candidate\
    \ with type '(Character?) -> String'\n            let next = String(stack.next())\n\
    \                       ^\n/tmp/tmp2pw5vt8k.swift:24:30: error: value of type\
    \ 'String.Iterator' has no member 'end'\n                last "
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let first = brackets.characters.first!\n    let last = brackets.characters.last!\n\
    \    if first == \"<\" {\n        return last == \">\"\n    }\n    if first ==\
    \ \">\" {\n        return last == \"<\"\n    }\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnmwhr291.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let first = brackets.characters.first!\n          \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpnmwhr291.swift:14:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let last = brackets.characters.last!\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.components(separatedBy: \"<\")\n    let closingBrackets\
    \ = brackets.components(separatedBy: \">\")\n    for opening in openingBrackets\
    \ {\n        if closing == \"\" {\n            return true\n        }\n      \
    \  for closing in closingBrackets {\n            if opening == closing {\n   \
    \             continue\n            }\n            if opening.unicodeScalars.first\
    \ != closing.unicodeScalars.first {\n                return false\n          \
    \  }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdiaumwkq.swift:13:36: error: value of type 'String' has no member\
    \ 'components'\n    let openingBrackets = brackets.components(separatedBy: \"\
    <\")\n                          ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdiaumwkq.swift:14:36:\
    \ error: value of type 'String' has no member 'components'\n    let closingBrackets\
    \ = brackets.components(separatedBy: \">\")\n                          ~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var didChange = false\n    for openingBracket in brackets.characters {\n\
    \        let index = brackets.index(of: openingBracket)\n        let closingBracket\
    \ = brackets.substring(from: index)?.dropLast()\n        if let closingBracket\
    \ = closingBracket, openingBracket == closingBracket {\n            didChange\
    \ = true\n        }\n    }\n    return didChange\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6z66bsct.swift:14:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    for openingBracket in brackets.characters {\n     \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp6z66bsct.swift:15:30: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        let index = brackets.index(of: openingBracket)\n\
    \                             ^\n/tmp/tmp6z66bsct.swift:15:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = brackets.index(of: openingBracket)\n          \
    \                   ^~~~~\n                             firstIndex\n/tmp/tmp6z66bsct.swift:16:39:\
    \ error: value of type 'String' has no member 'substring'\n        let closingBracket\
    \ = brackets.substring(from: index)?.dropLast()\n                            \
    \ ~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return false\n    }\n    var bracketOpen =\
    \ String()\n    var bracketClose = String()\n    var lastIndex = brackets.characters.count\n\
    \    for b in brackets.characters {\n        bracketOpen.append(String(b))\n \
    \       if b == brackets.characters.last! {\n            bracketClose.append(String(b))\n\
    \            lastIndex--\n        } else {\n            bracketClose.append(String(b))\n\
    \        }\n    }\n    if lastIndex != brackets.characters.count {\n        return\
    \ false\n    }\n    if bracketOpen != bracketClose {\n        return false\n \
    \   }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnz5sozjp.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    var lastIndex = brackets.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpnz5sozjp.swift:19:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    for b in brackets.characters {\n                  \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnz5sozjp.swift:21:26:\
    \ error: 'characters' is unavailable: Please use String directly\n        if b\
    \ == brackets.characters.last! {\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpnz5sozjp.swift:23:22: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            lastIndex--\n    \
    \                 ^~\n/tmp/tmpnz5sozjp.swift:28:30: error: 'characters' is unavailable:\
    \ Please use String directly\n    if lastIndex != brackets.characters.count {\n\
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if let brackets = brackets.components(separatedBy: \"<\") {\n        if let\
    \ lastIndex = brackets.count - 1 {\n            return brackets[lastIndex] ==\
    \ \">\"\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpg1u7yzkb.swift:13:32: error: value of type 'String' has no member\
    \ 'components'\n    if let brackets = brackets.components(separatedBy: \"<\")\
    \ {\n                      ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.lowercased()\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"<\", with: \">\")\n\tbrackets = brackets.replacingOccurrences(of: \">>\",\
    \ with: \"<\")\n\tbrackets = brackets.replacingOccurrences(of: \"><\", with: \"\
    <<\")\n\tbrackets = brackets.replacingOccurrences(of: \"<>\", with: \"<\")\n\t\
    brackets = brackets.replacingOccurrences(of: \"<<<\", with: \"<<\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \">>>\", with: \">>\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"<<<<\", with: \">>\")\n\treturn brackets.characters.count == brackets.utf16.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpw7sb9eg6.swift:13:2: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n        brackets = brackets.lowercased()\n        ^~~~~~~~\n\
    /tmp/tmpw7sb9eg6.swift:14:2: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n        brackets = brackets.replacingOccurrences(of: \"<\", with:\
    \ \">\")\n        ^~~~~~~~\n/tmp/tmpw7sb9eg6.swift:14:22: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n        brackets = brackets.replacingOccurrences(of:\
    \ \"<\", with: \">\")\n                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw7sb9eg6.swift:15:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingOccurrences(of: \">>\", with: \"<\")\n        ^~~~~~~~\n\
    /tmp/tmpw7sb9eg6.swift:15:22: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        brackets = brackets.replacingOccurrences(of: \">>\", with: \"<\")\n \
    \                  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw7sb9eg6.swift:16:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingOccurrences(of: \"><\", with: \"<<\")\n        ^~~~~~~~\n\
    /tmp/tmpw7sb9eg6.swift:16:22: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        brackets = brackets.replacingOccurrences(of: \"><\", with: \"<<\")\n\
    \                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw7sb9eg6.swift:17:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingOccurrences(of: \"<>\", with: \"<\")\n        ^~~~~~~~\n\
    /tmp/tmpw7sb9eg6.swift:17:22: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        brackets = brackets.replacingOccurrences(of: \"<>\", with: \"<\")\n \
    \                  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw7sb9eg6.swift:18:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingOccurrences(of: \"<<<\", with: \"<<\")\n        ^~~~~~~~\n\
    /tmp/tmpw7sb9eg6.swift:18:22: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        brackets = brackets.replacingOccurrenc"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let open = brackets.characters\n        .filter { $0 != \">\" && $0 != \"\
    <\" } // remove > and <\n        .map { String($0) } // convert to a string\n\
    \    let closed = brackets.characters.filter { $0 == \"<\" || $0 == \">\" } //\
    \ remove <> and >\n    return open.count == closed.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpur6e_g81.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let open = brackets.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpur6e_g81.swift:16:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    let closed\
    \ = brackets.characters.filter { $0 == \"<\" || $0 == \">\" } // remove <> and\
    \ >\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var isCorrect = false\n    brackets.split(\"\").forEach({\n        var isBracket\
    \ = false\n        let character = $0\n        if let openingCharIndex = brackets.characters.index(of:\
    \ character) {\n            isBracket = (openingCharIndex + 1 != brackets.characters.count)\n\
    \        } else {\n            isBracket = false\n        }\n        if isBracket\
    \ {\n            if let closingCharIndex = brackets.characters.index(of: \">\"\
    ) {\n                if brackets.characters.count > openingCharIndex {\n     \
    \               isCorrect = isCorrect || (openingCharIndex < closingCharIndex)\n\
    \                }\n            } else {\n                isCorrect = false\n\
    \            }\n        }\n    })\n    return isCorrect\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2rdgcz_j.swift:24:48: error: cannot find 'openingCharIndex' in\
    \ scope\n                if brackets.characters.count > openingCharIndex {\n \
    \                                              ^~~~~~~~~~~~~~~~\n/tmp/tmp2rdgcz_j.swift:25:47:\
    \ error: cannot find 'openingCharIndex' in scope\n                    isCorrect\
    \ = isCorrect || (openingCharIndex < closingCharIndex)\n                     \
    \                         ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var firstBracket = brackets.startIndex\n\tvar lastBracket = brackets.endIndex\n\
    \tfor firstBracket < lastBracket {\n\t\tswitch brackets.characters[firstBracket]\
    \ {\n\t\tcase '<':\n\t\t\tfirstBracket++\n\t\t\tbreak\n\t\tcase '>':\n\t\t\tfirstBracket++\n\
    \t\t\tbreak\n\t\tdefault:\n\t\t\tbreak\n\t\t}\n\t}\n\tfirstBracket += 1\n\tfor\
    \ firstBracket < lastBracket {\n\t\tswitch brackets.characters[firstBracket] {\n\
    \t\tcase '<':\n\t\t\tfirstBracket++\n\t\t\tbreak\n\t\tcase '>':\n\t\t\tfirstBracket++\n\
    \t\t\tbreak\n\t\tdefault:\n\t\t\tbreak\n\t\t}\n\t}\n\treturn firstBracket == lastBracket\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp25ci2551.swift:15:19: error: expected 'in' after for-each pattern\n\
    \        for firstBracket < lastBracket {\n                         ^\n/tmp/tmp25ci2551.swift:15:19:\
    \ error: unary operator cannot be separated from its operand\n        for firstBracket\
    \ < lastBracket {\n                         ^~\n                          \n/tmp/tmp25ci2551.swift:17:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '<':\n\
    \                     ^~~\n                     \"<\"\n/tmp/tmp25ci2551.swift:20:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '>':\n\
    \                     ^~~\n                     \">\"\n/tmp/tmp25ci2551.swift:28:19:\
    \ error: expected 'in' after for-each pattern\n        for firstBracket < lastBracket\
    \ {\n                         ^\n/tmp/tmp25ci2551.swift:28:19: error: unary operator\
    \ cannot be separated from its operand\n        for firstBracket < lastBracket\
    \ {\n                         ^~\n                          \n/tmp/tmp25ci2551.swift:30:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '<':\n\
    \                     ^~~\n                     \"<\"\n/tmp/tmp25ci2551.swift:33:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '>':\n\
    \                     ^~~\n                     \">\"\n/tmp/tmp25ci2551.swift:15:19:\
    \ error: '<' is not a prefix unary operator\n        for firstBracket < lastBracket\
    \ {\n                         ^\n/tmp/tmp25ci2551.swift:27:15: error: binary operator\
    \ '+=' cannot be applied to operands of type 'String.Index' and 'Int'\n      \
    \  firstBracket += 1\n        ~~~~~~~~~~~~ ^  ~\n/tmp/tmp25ci2551.swift:28:19:\
    \ error: '<' is not a prefix unary operator\n        for firstBracket < lastBracket\
    \ {\n                         ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let lenghtOfBrackets = brackets.characters.count\n    guard lenghtOfBrackets\
    \ > 0 else {\n        return true\n    }\n    let openingBracketCount = brackets.characters.reduce(0,\
    \ {$0 + $1 == \"<\"})\n    let closingBracketCount = brackets.characters.reduce(0,\
    \ {$0 + $1 == \"<\"}) + 1\n    return (openingBracketCount == lenghtOfBrackets\
    \ - closingBracketCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcqmj2uym.swift:13:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    let lenghtOfBrackets = brackets.characters.count\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpcqmj2uym.swift:17:58: error: cannot convert value of\
    \ type 'Int' to expected argument type '()'\n    let openingBracketCount = brackets.characters.reduce(0,\
    \ {$0 + $1 == \"<\"})\n                                                      \
    \   ^\n/tmp/tmpcqmj2uym.swift:17:65: error: operator function '+' requires the\
    \ types 'String.Element' (aka 'Character') and '().Element' be equivalent\n  \
    \  let openingBracketCount = brackets.characters.reduce(0, {$0 + $1 == \"<\"})\n\
    \                                                                ^\nSwift.RangeReplaceableCollection:3:35:\
    \ note: where 'Self.Element' = 'String.Element' (aka 'Character'), 'Other.Element'\
    \ = '().Element'\n    @inlinable public static func + <Other>(lhs: Other, rhs:\
    \ Self) -> Self where Other : Sequence, Self.Element == Other.Element\n      \
    \                            ^\n/tmp/tmpcqmj2uym.swift:17:65: error: type '()'\
    \ cannot conform to 'Sequence'\n    let openingBracketCount = brackets.characters.reduce(0,\
    \ {$0 + $1 == \"<\"})\n                                                      \
    \          ^\n/tmp/tmpcqmj2uym.swift:17:65: note: only concrete types such as\
    \ structs, enums and classes can conform to protocols\n    let openingBracketCount\
    \ = brackets.characters.reduce(0, {$0 + $1 == \"<\"})\n                      \
    \                                          ^\n/tmp/tmpcqmj2uym.swift:17:65: note:\
    \ required by operator function '+' where 'Other' = '()'\n    let openingBracketCount\
    \ = brackets.characters.reduce(0, {$0 + $1 == \"<\"})\n                      \
    \                                          ^\n/tmp/tmpcqmj2uym.swift:17:67: error:\
    \ cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n    let openingBracketCount = brackets.character"
  stdout: ''
  timestamp: 1660009966
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // If brackets is empty, no bracketing is necessary.\n    if brackets.characters.count\
    \ == 0 {\n        return true\n    }\n\n    // If there are any characters in\
    \ brackets other than \"<\" or \"<\", bracketing is necessary.\n    if brackets.rangeOfCharacter(from:\
    \ CharacterSet.any) != nil {\n        return true\n    }\n\n    // For every opening\
    \ bracket, check whether there is a corresponding closing bracket.\n    for i\
    \ in 0..<brackets.characters.count {\n        if brackets.characters.count <=\
    \ i + 1 {\n            return false\n        }\n\n        if brackets.characters.count\
    \ > i + 1 {\n            if brackets[i + 1] != '<' && brackets[i + 1] != '>' {\n\
    \                return false\n            }\n        }\n    }\n\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0jq6v8ha.swift:30:35: error: single-quoted string literal found,\
    \ use '\"'\n            if brackets[i + 1] != '<' && brackets[i + 1] != '>' {\n\
    \                                  ^~~\n                                  \"<\"\
    \n/tmp/tmp0jq6v8ha.swift:30:61: error: single-quoted string literal found, use\
    \ '\"'\n            if brackets[i + 1] != '<' && brackets[i + 1] != '>' {\n  \
    \                                                          ^~~\n             \
    \                                               \">\"\n/tmp/tmp0jq6v8ha.swift:14:17:\
    \ error: 'characters' is unavailable: Please use String directly\n    if brackets.characters.count\
    \ == 0 {\n                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp0jq6v8ha.swift:19:40: error: cannot find 'CharacterSet'\
    \ in scope\n    if brackets.rangeOfCharacter(from: CharacterSet.any) != nil {\n\
    \                                       ^~~~~~~~~~~~\n/tmp/tmp0jq6v8ha.swift:19:17:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n    if brackets.rangeOfCharacter(from:\
    \ CharacterSet.any) != nil {\n       ~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp0jq6v8ha.swift:24:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    for i in\
    \ 0..<brackets.characters.count {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp0jq6v8ha.swift:25:21: error: 'characters'\
    \ is unavailable: Please use String directly\n        if brackets.characters.count\
    \ <= i + 1 {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0jq6v8ha.swift:29:21: error: 'characters' is unavailable:\
    \ Please use String directly\n        if brackets.characters.count > i + 1 {\n\
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get "
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard let openingBracketsStrings = brackets.split(separator: \">\").map {\
    \ String($0) },\n        let closingBracketsStrings = brackets.split(separator:\
    \ \"<\").map { String($0) },\n        openingBracketsStrings.count == closingBracketsStrings.count,\n\
    \        openingBracketsStrings.count == openingBracketsStrings.count {\n    \
    \    return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpf3erqkr0.swift:16:70: error: expected 'else' after 'guard' condition\n\
    \        openingBracketsStrings.count == openingBracketsStrings.count {\n    \
    \                                                                 ^\n        \
    \                                                             else \n/tmp/tmpf3erqkr0.swift:13:75:\
    \ warning: trailing closure in this context is confusable with the body of the\
    \ statement; pass as a parenthesized argument to silence this warning\n    guard\
    \ let openingBracketsStrings = brackets.split(separator: \">\").map { String($0)\
    \ },\n                                                                       \
    \  ~^\n                                                                      \
    \   (              )\n/tmp/tmpf3erqkr0.swift:14:73: warning: trailing closure\
    \ in this context is confusable with the body of the statement; pass as a parenthesized\
    \ argument to silence this warning\n        let closingBracketsStrings = brackets.split(separator:\
    \ \"<\").map { String($0) },\n                                               \
    \                        ~^\n                                                \
    \                       (              )\n/tmp/tmpf3erqkr0.swift:13:11: error:\
    \ initializer for conditional binding must have Optional type, not '[String]'\n\
    \    guard let openingBracketsStrings = brackets.split(separator: \">\").map {\
    \ String($0) },\n          ^                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpf3erqkr0.swift:14:9: error: initializer for conditional binding must have\
    \ Optional type, not '[String]'\n        let closingBracketsStrings = brackets.split(separator:\
    \ \"<\").map { String($0) },\n        ^                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var open = brackets.characters\n    var closed = brackets.characters.reverse()\n\
    \    var isOpening = true\n    var hasCorrectlyClosed = false\n    var startIndex\
    \ = 0\n    var endIndex = 0\n\n    // iterate through brackets\n    while open.isEmpty\
    \ {\n        // increment indexes until we find a new opening bracket\n      \
    \  if !isOpening {\n            startIndex = brackets.startIndex\n        }\n\
    \        endIndex = brackets.endIndex\n        isOpening = open.removeLast()\n\
    \        // if we found a new opening bracket, check to see if it has a closing\
    \ bracket\n        if isOpening {\n            if !closed.isEmpty {\n        \
    \        hasCorrectlyClosed = true\n                break\n            }\n   \
    \     }\n    }\n\n    // if we have a correctly closed bracket, check that the\
    \ last characters are a correctly closed bracket\n    if hasCorrectlyClosed {\n\
    \        let lastChar = brackets.characters.last!\n        let lastCharIsCloser\
    \ = lastChar == closed.first!\n        if !lastCharIsCloser {\n            return\
    \ false\n        }\n    }\n\n    // if we have a correctly closed bracket, check\
    \ that the last characters are a correctly closed bracket\n    if hasCorrectlyClosed\
    \ {\n        let lastChar = brackets.characters.last!\n        let lastCharIsOpener\
    \ = lastChar == open.first!\n        if !lastCharIsOpener {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp00wezh9y.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    var open = brackets.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp00wezh9y.swift:14:38:\
    \ error: value of type 'String' has no member 'reverse'\n    var closed = brackets.characters.reverse()\n\
    \                 ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp00wezh9y.swift:24:35: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n            startIndex\
    \ = brackets.startIndex\n                         ~~~~~~~~~^~~~~~~~~~\n/tmp/tmp00wezh9y.swift:26:29:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n        endIndex\
    \ = brackets.endIndex\n                   ~~~~~~~~~^~~~~~~~\n/tmp/tmp00wezh9y.swift:27:26:\
    \ error: cannot assign value of type 'String.Element' (aka 'Character') to type\
    \ 'Bool'\n        isOpening = open.removeLast()\n                    ~~~~~^~~~~~~~~~~~\n\
    /tmp/tmp00wezh9y.swift:39:33: error: 'characters' is unavailable: Please use String\
    \ directly\n        let lastChar = brackets.characters.last!\n               \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp00wezh9y.swift:48:33: error: 'characters' is unavailable: Please\
    \ use String directly\n        let lastChar = brackets.characters.last!\n    \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    \n    let openingBrackets = brackets.components(separatedBy: CharacterSet.symbols)\n\
    \    \n    if openingBrackets.count == 0 {\n        return true\n    }\n    \n\
    \    let closingBrackets = brackets.components(separatedBy: CharacterSet.symbols).reversed()\n\
    \    \n    if closingBrackets.count == 0 {\n        return true\n    }\n    \n\
    \    for i in 0..<openingBrackets.count {\n        let openingBracket = openingBrackets[i]\n\
    \        let closingBracket = closingBrackets[i]\n        \n        if openingBracket\
    \ != closingBracket {\n            return false\n        }\n    }\n    \n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcns4tcv4.swift:14:60: error: cannot find 'CharacterSet' in scope\n\
    \    let openingBrackets = brackets.components(separatedBy: CharacterSet.symbols)\n\
    \                                                           ^~~~~~~~~~~~\n/tmp/tmpcns4tcv4.swift:14:36:\
    \ error: value of type 'String' has no member 'components'\n    let openingBrackets\
    \ = brackets.components(separatedBy: CharacterSet.symbols)\n                 \
    \         ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpcns4tcv4.swift:20:60: error: cannot find\
    \ 'CharacterSet' in scope\n    let closingBrackets = brackets.components(separatedBy:\
    \ CharacterSet.symbols).reversed()\n                                         \
    \                  ^~~~~~~~~~~~\n/tmp/tmpcns4tcv4.swift:20:36: error: value of\
    \ type 'String' has no member 'components'\n    let closingBrackets = brackets.components(separatedBy:\
    \ CharacterSet.symbols).reversed()\n                          ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack = [String]()\n    for ch in brackets {\n        switch ch {\n \
    \       case \"<\":\n            stack.append(ch)\n        case \"<=\":\n    \
    \        stack.pop()\n        default:\n            if stack.last! != nil {\n\
    \                stack.removeLast()\n            }\n        }\n    }\n    return\
    \ stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpwj_6r4ce.swift:18:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"<=\":\n            \
    \ ^~~~\n/tmp/tmpwj_6r4ce.swift:17:26: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            stack.append(ch)\n         \
    \                ^\n/tmp/tmpwj_6r4ce.swift:19:19: error: value of type '[String]'\
    \ has no member 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n/tmp/tmpwj_6r4ce.swift:21:28:\
    \ warning: comparing non-optional value of type 'String' to 'nil' always returns\
    \ true\n            if stack.last! != nil {\n               ~~~~~~~~~~~ ^  ~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard brackets.count >= 1 else { return false }\n    var firstOpeningBracket\
    \ = brackets.startIndex\n    var lastClosingBracket = brackets.endIndex\n    var\
    \ openingBracketCount = 1\n    var closingBracketCount = 1\n    while openingBracketCount\
    \ > 0 || closingBracketCount > 0 {\n        var newOpeningBracket = brackets[firstOpeningBracket]\n\
    \        if firstOpeningBracket == lastClosingBracket {\n            break\n \
    \       }\n        if newOpeningBracket == \"<\" {\n            openingBracketCount\
    \ += 1\n        } else if newOpeningBracket == \">\" {\n            closingBracketCount\
    \ += 1\n        } else {\n            return false\n        }\n        firstOpeningBracket\
    \ += 1\n        lastClosingBracket -= 1\n    }\n    return firstOpeningBracket\
    \ == brackets.endIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp74ysq2l8.swift:30:29: error: binary operator '+=' cannot be applied\
    \ to operands of type 'String.Index' and 'Int'\n        firstOpeningBracket +=\
    \ 1\n        ~~~~~~~~~~~~~~~~~~~ ^  ~\n/tmp/tmp74ysq2l8.swift:31:28: error: binary\
    \ operator '-=' cannot be applied to operands of type 'String.Index' and 'Int'\n\
    \        lastClosingBracket -= 1\n        ~~~~~~~~~~~~~~~~~~ ^  ~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return true\n    }\n    var openingBrackets:\
    \ String = \"\"\n    var closingBrackets: String = \"\"\n\n    // Iterate over\
    \ string and determine if any brackets match.\n    for _, bracket in brackets.characters.enumerated()\
    \ {\n        if bracket == '<' {\n            openingBrackets += \"<\"\n     \
    \   } else {\n            openingBrackets += bracket\n        }\n        if bracket\
    \ == '>' {\n            closingBrackets += \">\"\n        } else {\n         \
    \   closingBrackets += bracket\n        }\n    }\n    return openingBrackets ==\
    \ closingBrackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpireqv48q.swift:20:10: error: expected 'in' after for-each pattern\n\
    \    for _, bracket in brackets.characters.enumerated() {\n         ^\n/tmp/tmpireqv48q.swift:20:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, bracket in\
    \ brackets.characters.enumerated() {\n         ^\n/tmp/tmpireqv48q.swift:21:23:\
    \ error: single-quoted string literal found, use '\"'\n        if bracket == '<'\
    \ {\n                      ^~~\n                      \"<\"\n/tmp/tmpireqv48q.swift:26:23:\
    \ error: single-quoted string literal found, use '\"'\n        if bracket == '>'\
    \ {\n                      ^~~\n                      \">\"\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var correct = true\n    for opening, closing := range brackets {\n      \
    \  if opening != closing {\n            correct = false\n            break\n \
    \       }\n    }\n    return correct\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp24rnu6ha.swift:14:16: error: expected 'in' after for-each pattern\n\
    \    for opening, closing := range brackets {\n               ^\n/tmp/tmp24rnu6ha.swift:14:16:\
    \ error: expected Sequence expression for for-each loop\n    for opening, closing\
    \ := range brackets {\n               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.count < 2 {\n        return false\n    }\n    \n    var openingBrackets\
    \ = brackets.characters\n    var closingBrackets = brackets.characters\n    \n\
    \    openingBrackets.remove(at: 0)\n    closingBrackets.remove(at: 0)\n    \n\
    \    if openingBrackets.count != closingBrackets.count {\n        return false\n\
    \    }\n    \n    for openBracket in openingBrackets {\n        let closeBracket\
    \ = openingBrackets.index(of: openBracket)\n        if closeBracket < 0 {\n  \
    \          return false\n        }\n        \n        openingBrackets.remove(at:\
    \ closeBracket + 1)\n        closingBrackets.remove(at: closeBracket + 1)\n  \
    \  }\n    \n    if openingBrackets.count != 0 {\n        return false\n    }\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp61tlnzvf.swift:17:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    var openingBrackets = brackets.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp61tlnzvf.swift:18:36: error: 'characters' is unavailable:\
    \ Please use String directly\n    var closingBrackets = brackets.characters\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp61tlnzvf.swift:20:32: error: cannot convert value of\
    \ type 'Int' to expected argument type 'String.Index'\n    openingBrackets.remove(at:\
    \ 0)\n                               ^\n/tmp/tmp61tlnzvf.swift:21:32: error: cannot\
    \ convert value of type 'Int' to expected argument type 'String.Index'\n    closingBrackets.remove(at:\
    \ 0)\n                               ^\n/tmp/tmp61tlnzvf.swift:28:44: warning:\
    \ 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let closeBracket\
    \ = openingBrackets.index(of: openBracket)\n                                 \
    \          ^\n/tmp/tmp61tlnzvf.swift:28:44: note: use 'firstIndex(of:)' instead\n\
    \        let closeBracket = openingBrackets.index(of: openBracket)\n         \
    \                                  ^~~~~\n                                   \
    \        firstIndex\n/tmp/tmp61tlnzvf.swift:29:25: error: binary operator '<'\
    \ cannot be applied to operands of type 'String.Index?' and 'Int'\n        if\
    \ closeBracket < 0 {\n           ~~~~~~~~~~~~ ^ ~\n/tmp/tmp61tlnzvf.swift:29:25:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if closeBracket < 0 {\n                        ^\n/tmp/tmp61tlnzvf.swift:33:49:\
    \ error: binary operator '+' cannot be applied to operands of type 'String.Index?'\
    \ and 'Int'\n        openingBrackets.remove(at: closeBracket + 1)\n          \
    \                         ~~~~~~~~~~~~ ^ ~\n/tmp/tmp61tlnzvf.swift:33:49: note:\
    \ overl"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack = StringStack()\n    for symbol in brackets {\n        if symbol\
    \ == \">\" {\n            if !stack.isEmpty {\n                stack.pop()\n \
    \           }\n        } else if symbol == \"<\" {\n            stack.append(symbol)\
    \ // Append the symbol on the top of the stack\n        }\n    }\n    if stack.isEmpty\
    \ {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpz7s2fbex.swift:13:17: error: cannot find 'StringStack' in scope\n\
    \    var stack = StringStack()\n                ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var openingBrackets = brackets.characters\n\tvar closingBrackets = [Character]()\n\
    \topeningBrackets.forEach { character in\n\t\tlet matchingBracket = closingBrackets.first(where:\
    \ { $0 == character })\n\t\tif matchingBracket == nil {\n\t\t\tclosingBrackets.append(character)\n\
    \t\t} else {\n\t\t\topeningBrackets.remove(matchingBracket!)\n\t\t}\n\t}\n\treturn\
    \ (openingBrackets.count == 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3e6p5vlj.swift:13:33: error: 'characters' is unavailable: Please\
    \ use String directly\n        var openingBrackets = brackets.characters\n   \
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3e6p5vlj.swift:20:27: error: missing argument label\
    \ 'at:' in call\n                        openingBrackets.remove(matchingBracket!)\n\
    \                                               ^\n                          \
    \                     at: \n/tmp/tmp3e6p5vlj.swift:20:42: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String.Index'\n       \
    \                 openingBrackets.remove(matchingBracket!)\n                 \
    \                                             ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard let lastChar = brackets.characters.last else {\n        return true\n\
    \    }\n\n    let lastCharIsOpenBracket = brackets.characters.last == \"<\"\n\
    \    \n    let isOpenBracket = brackets.characters.contains(\"<\")\n    let isCloseBracket\
    \ = brackets.characters.contains(\">\")\n\n    var foundClosingBracket = false\n\
    \    \n    for i in 0 ..< brackets.characters.count {\n        if lastCharIsOpenBracket\
    \ {\n            if brackets.characters[i] == \">\" {\n                foundClosingBracket\
    \ = true\n            } else {\n                return false\n            }\n\
    \        } else {\n            if brackets.characters[i] == \"<\" {\n        \
    \        if !foundClosingBracket {\n                    return false\n       \
    \         }\n            } else {\n                return false\n            }\n\
    \        }\n    }\n    \n    return foundClosingBracket\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2l5v25o4.swift:13:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let lastChar = brackets.characters.last else\
    \ {\n                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2l5v25o4.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let lastCharIsOpenBracket = brackets.characters.last\
    \ == \"<\"\n                                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp2l5v25o4.swift:19:34: error: 'characters'\
    \ is unavailable: Please use String directly\n    let isOpenBracket = brackets.characters.contains(\"\
    <\")\n                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2l5v25o4.swift:20:35: error: 'characters' is unavailable:\
    \ Please use String directly\n    let isCloseBracket = brackets.characters.contains(\"\
    >\")\n                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2l5v25o4.swift:24:29: error: 'characters' is unavailable:\
    \ Please use String directly\n    for i in 0 ..< brackets.characters.count {\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2l5v25o4.swift:26:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if brackets.characters[i] == \">\" {\n               ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp2l5v25o4.swift:26:25:\
    \ error: 'characters' is unavailable: "
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.lowercased()\n    var openBracketCount = [Character:\
    \ Int]()\n    var openBrackets = [String]()\n    var closingBracketCount = [Character:\
    \ Int]()\n    var closingBrackets = [String]()\n    \n    for bracket in brackets\
    \ {\n        switch bracket {\n        case \"<\":\n            openBracketCount[Character(Character.LeftParenthesis)]\
    \ += 1\n        case \"<=\":\n            openBracketCount[Character(Character.LeftAngleBracket)]\
    \ += 1\n        case \"<<\":\n            openBracketCount[Character(Character.LeftShiftBracket)]\
    \ += 1\n        case \"<=\":\n            openBracketCount[Character(Character.LeftShiftAngleBracket)]\
    \ += 1\n        case \">\":\n            openBracketCount[Character(Character.RightParenthesis)]\
    \ += 1\n        case \">=\":\n            openBracketCount[Character(Character.RightAngleBracket)]\
    \ += 1\n        case \">>\":\n            openBracketCount[Character(Character.RightShiftBracket)]\
    \ += 1\n        case \">=\":\n            openBracketCount[Character(Character.RightShiftAngleBracket)]\
    \ += 1\n        default:\n            openBracketCount[Character(Character(bracket))]\
    \ += 1\n        }\n    }\n    \n    for openBracket in openBracketCount {\n  \
    \      switch openBracket.key {\n        case Character.LeftParenthesis:\n   \
    \         openBrackets.append(openBracket.value)\n        case Character.LeftAngleBracket:\n\
    \            openBrackets.append(openBracket.value)\n        case Character.LeftShiftBracket:\n\
    \            openBrackets.append(openBracket.value)\n        case Character.LeftShiftAngleBracket:\n\
    \            openBrackets.append(openBracket.value)\n        case Character.RightParenthesis:\n\
    \            closingBracketCount[Character(Character.LeftParenthesis)] -= 1\n\
    \        case Character.RightAngleBracket:\n            closingBracketCount[Character(Character.LeftAngleBracket)]\
    \ -= 1\n        case Character.RightShiftBracket:\n            closingBracketCount[Character(Character.LeftShiftBracket)]\
    \ -= 1\n        case Character.RightShiftAngleBracket:\n            closingBracketCount[Character(Character.LeftShiftAngleBracket)]\
    \ -= 1\n        default:\n            closingBracketCount[Character(Character(openBracket.key))]\
    \ -= 1\n        }\n    }\n    \n    for closingBracket in closingBracketCount\
    \ {\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp92b7q5mc.swift:93:66: error: expected '}' at end of brace statement\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)\n        \
    \                                                         ^\n/tmp/tmp92b7q5mc.swift:12:51:\
    \ note: to match this opening '{'\nfunc correct_bracketing(brackets: String) ->\
    \ Bool {\n                                                  ^\n/tmp/tmp92b7q5mc.swift:13:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.lowercased()\n    ^~~~~~~~\n/tmp/tmp92b7q5mc.swift:23:14: error:\
    \ expression pattern of type 'String' cannot match values of type 'Character'\n\
    \        case \"<=\":\n             ^~~~\n/tmp/tmp92b7q5mc.swift:25:14: error:\
    \ expression pattern of type 'String' cannot match values of type 'Character'\n\
    \        case \"<<\":\n             ^~~~\n/tmp/tmp92b7q5mc.swift:27:14: error:\
    \ expression pattern of type 'String' cannot match values of type 'Character'\n\
    \        case \"<=\":\n             ^~~~\n/tmp/tmp92b7q5mc.swift:31:14: error:\
    \ expression pattern of type 'String' cannot match values of type 'Character'\n\
    \        case \">=\":\n             ^~~~\n/tmp/tmp92b7q5mc.swift:33:14: error:\
    \ expression pattern of type 'String' cannot match values of type 'Character'\n\
    \        case \">>\":\n             ^~~~\n/tmp/tmp92b7q5mc.swift:35:14: error:\
    \ expression pattern of type 'String' cannot match values of type 'Character'\n\
    \        case \">=\":\n             ^~~~\n/tmp/tmp92b7q5mc.swift:22:50: error:\
    \ type 'Character' has no member 'LeftParenthesis'\n            openBracketCount[Character(Character.LeftParenthesis)]\
    \ += 1\n                                       ~~~~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp92b7q5mc.swift:22:29:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            openBracketCount[Character(Character.LeftParenthesis)] += 1\n   \
    \                         ^\n/tmp/tmp92b7q5mc.swift:22:29: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \    openBracketCount[Character(Character.LeftParenthesis)] += 1\n          "
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty() {\n        return false\n    }\n    let len = brackets.length\n\
    \    if len == 1 {\n        return true\n    }\n    let first = brackets[0]\n\
    \    var last = first\n    var hasNext = false\n    for _ in 0..<len {\n     \
    \   let next = brackets[len]\n        if next == last {\n            return false\n\
    \        }\n        last = next\n        hasNext = true\n    }\n    return hasNext\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpiyp2j_te.swift:13:17: error: cannot call value of non-function\
    \ type 'Bool'\n    if brackets.isEmpty() {\n                ^      ~~\n      \
    \                 \n/tmp/tmpiyp2j_te.swift:16:24: error: value of type 'String'\
    \ has no member 'length'\n    let len = brackets.length\n              ~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpiyp2j_te.swift:20:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n    let first\
    \ = brackets[0]\n                ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let regex = try NSRegularExpression(pattern: \"(?<=\")\n    let match = regex.firstMatch(in:\
    \ brackets, options: [], range: NSRange(location: 0, length: brackets.characters.count))\n\
    \    guard match != nil else { return false }\n    guard match!.numberOfRanges\
    \ > 1 else { return false }\n    guard match!.numberOfRanges == brackets.characters.count\
    \ else { return false }\n    if let match = match!.range(at: 0) {\n        brackets\
    \ = brackets.replacingCharacters(in: match, with: \"\")\n    }\n    regex = try\
    \ NSRegularExpression(pattern: \"(?<=\")\n    match = regex.firstMatch(in: brackets,\
    \ options: [], range: NSRange(location: 0, length: brackets.characters.count))\n\
    \    guard match != nil else { return false }\n    guard match!.numberOfRanges\
    \ > 0 else { return false }\n    guard match!.numberOfRanges == brackets.characters.count\
    \ else { return false }\n    if let match = match!.range(at: 0) {\n        brackets\
    \ = brackets.replacingCharacters(in: match, with: \"\")\n    }\n    guard brackets.characters.count\
    \ == 0 else { return false }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpo6ze_yeu.swift:13:21: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try NSRegularExpression(pattern: \"(?<=\")\n     \
    \               ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpo6ze_yeu.swift:14:68: error: cannot\
    \ find 'NSRange' in scope\n    let match = regex.firstMatch(in: brackets, options:\
    \ [], range: NSRange(location: 0, length: brackets.characters.count))\n      \
    \                                                             ^~~~~~~\n/tmp/tmpo6ze_yeu.swift:19:9:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingCharacters(in: match, with: \"\")\n        ^~~~~~~~\n/tmp/tmpo6ze_yeu.swift:19:29:\
    \ error: value of type 'String' has no member 'replacingCharacters'\n        brackets\
    \ = brackets.replacingCharacters(in: match, with: \"\")\n                   ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpo6ze_yeu.swift:21:17: error: cannot find 'NSRegularExpression'\
    \ in scope\n    regex = try NSRegularExpression(pattern: \"(?<=\")\n         \
    \       ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpo6ze_yeu.swift:22:64: error: cannot find\
    \ 'NSRange' in scope\n    match = regex.firstMatch(in: brackets, options: [],\
    \ range: NSRange(location: 0, length: brackets.characters.count))\n          \
    \                                                     ^~~~~~~\n/tmp/tmpo6ze_yeu.swift:27:9:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingCharacters(in: match, with: \"\")\n        ^~~~~~~~\n/tmp/tmpo6ze_yeu.swift:27:29:\
    \ error: value of type 'String' has no member 'replacingCharacters'\n        brackets\
    \ = brackets.replacingCharacters(in: match, with: \"\")\n                   ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpo6ze_yeu.swift:29:20: error: 'characters' is unavailable:\
    \ Please use String directly\n    guard brackets.characters.count == 0 else {\
    \ return false }\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let leftBracket = brackets[brackets.startIndex..<brackets.startIndex.advancedBy(1)]\n\
    \    let rightBracket = brackets[brackets.startIndex.advancedBy(1)..<brackets.endIndex]\n\
    \n    return leftBracket == rightBracket\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0qfpgomf.swift:13:74: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let leftBracket = brackets[brackets.startIndex..<brackets.startIndex.advancedBy(1)]\n\
    \                                                     ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp0qfpgomf.swift:14:53: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let rightBracket = brackets[brackets.startIndex.advancedBy(1)..<brackets.endIndex]\n\
    \                                ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    if brackets.contains(\"<\") || brackets.contains(\">\") {\n\t\tvar isOpen [10]bool\n\
    \t\tfor i := 0; i < len(brackets); i++ {\n\t\t\tif brackets[i] == '<' {\n\t\t\t\
    \tisOpen[i / 2] = true\n\t\t\t} else if brackets[i] == '>' {\n\t\t\t\tisOpen[i\
    \ / 2] = false\n\t\t\t} else {\n\t\t\t\tisOpen[i / 2] = false\n\t\t\t}\n\t\t}\n\
    \t\tresult := true\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif !isOpen[i] {\n\t\t\
    \t\tresult = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\t\
    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsr8odufc.swift:14:13: error: consecutive statements on a line must\
    \ be separated by ';'\n                var isOpen [10]bool\n                 \
    \         ^\n                          ;\n/tmp/tmpsr8odufc.swift:14:18: error:\
    \ consecutive statements on a line must be separated by ';'\n                var\
    \ isOpen [10]bool\n                               ^\n                        \
    \       ;\n/tmp/tmpsr8odufc.swift:15:10: error: expected type\n              \
    \  for i := 0; i < len(brackets); i++ {\n                       ^\n          \
    \              <#type#>\n/tmp/tmpsr8odufc.swift:15:10: error: expected 'in' after\
    \ for-each pattern\n                for i := 0; i < len(brackets); i++ {\n   \
    \                    ^\n/tmp/tmpsr8odufc.swift:15:10: error: expected Sequence\
    \ expression for for-each loop\n                for i := 0; i < len(brackets);\
    \ i++ {\n                       ^\n/tmp/tmpsr8odufc.swift:16:22: error: single-quoted\
    \ string literal found, use '\"'\n                        if brackets[i] == '<'\
    \ {\n                                          ^~~\n                         \
    \                 \"<\"\n/tmp/tmpsr8odufc.swift:18:29: error: single-quoted string\
    \ literal found, use '\"'\n                        } else if brackets[i] == '>'\
    \ {\n                                                 ^~~\n                  \
    \                               \">\"\n/tmp/tmpsr8odufc.swift:25:10: error: expected\
    \ type\n                for i := 0; i < 10; i++ {\n                       ^\n\
    \                        <#type#>\n/tmp/tmpsr8odufc.swift:25:10: error: expected\
    \ 'in' after for-each pattern\n                for i := 0; i < 10; i++ {\n   \
    \                    ^\n/tmp/tmpsr8odufc.swift:25:10: error: expected Sequence\
    \ expression for for-each loop\n                for i := 0; i < 10; i++ {\n  \
    \                     ^\n/tmp/tmpsr8odufc.swift:14:7: error: type annotation missing\
    \ in pattern\n                var isOpen [10]bool\n                    ^\n/tmp/tmpsr8odufc.swift:14:14:\
    \ warning: expression of type '[Int]' is unused\n                var isOpen [10]bool\n\
    \                           ^~~~\n/tmp/tmps"
  stdout: ''
  timestamp: 1660009883
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.split(separator: \"<\").map({ String($0) })\n\
    \    let closingBrackets = brackets.split(separator: \">\").map({ String($0) })\n\
    \n    return openingBrackets.count == closingBrackets.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmp0l3_dil3/tmp0l3_dil3.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b285affcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b285acf3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b285acf3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b285acf27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0l3_dil3                        0x000055d0f3da2843 <unavailable> + 6211

    5    libc.so.6                          0x00002b285b1e8460 __libc_start_main +
    245

    6    tmp0l3_dil3                        0x000055d0f3da2239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var open_brackets = String()\n\tvar closed_brackets = String()\n\tlet opening_bracket\
    \ = \"<\"\n\tlet closing_bracket = \">\"\n\tlet brackets = brackets + \">\"\n\t\
    var has_open_closed = false\n\tvar i = 0\n\tvar current = 0\n\twhile i < brackets.characters.count\
    \ {\n\t\tif brackets.characters[i] == opening_bracket {\n\t\t\thas_open_closed\
    \ = true\n\t\t\tcurrent = i\n\t\t}\n\t\ti += 1\n\t}\n\tif has_open_closed {\n\t\
    \tfor i = current + 1; i < brackets.characters.count; i++ {\n\t\t\tif brackets.characters[i]\
    \ == closing_bracket {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\
    \t}\n\treturn false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpc0wt8fsr.swift:29:3: error: C-style for statement has been removed\
    \ in Swift 3\n                for i = current + 1; i < brackets.characters.count;\
    \ i++ {\n                ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpc0wt8fsr.swift:21:21: error: 'characters' is unavailable: Please use String\
    \ directly\n        while i < brackets.characters.count {\n                  \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpc0wt8fsr.swift:22:25:\
    \ error: no exact matches in call to subscript \n                if brackets.characters[i]\
    \ == opening_bracket {\n                                      ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let open_brackets = brackets.components(separatedBy: \"<\")\n    let closed_brackets\
    \ = brackets.components(separatedBy: \">\")\n    var open_brackets_len = 0\n \
    \   var closed_brackets_len = 0\n    for open_bracket in open_brackets {\n   \
    \     if open_bracket == \"<\" {\n            open_brackets_len++\n        }\n\
    \        if open_bracket == \">\" {\n            closed_brackets_len++\n     \
    \   }\n    }\n    return open_brackets_len == closed_brackets_len\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_yfhdwvn.swift:13:34: error: value of type 'String' has no member\
    \ 'components'\n    let open_brackets = brackets.components(separatedBy: \"<\"\
    )\n                        ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp_yfhdwvn.swift:14:36:\
    \ error: value of type 'String' has no member 'components'\n    let closed_brackets\
    \ = brackets.components(separatedBy: \">\")\n                          ~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    switch len(brackets) {\n\tcase 0:\n\t\treturn true\n\tcase 1:\n\t\tswitch brackets.first\
    \ {\n\t\tcase \"<\":\n\t\t\treturn true\n\t\tcase \">\":\n\t\t\treturn true\n\t\
    \tdefault:\n\t\t\treturn false\n\t\t}\n\tdefault:\n\t\tswitch brackets.first {\n\
    \t\tcase \"<\":\n\t\t\treturn true\n\t\tdefault:\n\t\t\tif brackets.first == \"\
    >\" && brackets[1...].first == \"<\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn\
    \ false\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpr844uq21.swift:13:9: error: cannot find 'len' in scope\n      \
    \  switch len(brackets) {\n               ^~~\n/tmp/tmpr844uq21.swift:30:32: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an integer range,\
    \ use a String.Index range instead.\n                        if brackets.first\
    \ == \">\" && brackets[1...].first == \"<\" {\n                              \
    \                      ^~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard let openingBrackets = brackets.components(separatedBy: \"<\") else\
    \ {\n        return false\n    }\n    let closingBrackets = brackets.components(separatedBy:\
    \ \">\")\n    guard openingBrackets.count == closingBrackets.count else {\n  \
    \      return false\n    }\n    for bracket in openingBrackets {\n        guard\
    \ closingBrackets.contains(bracket) else {\n            return false\n       \
    \ }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp9_bmlutw.swift:13:42: error: value of type 'String' has no member\
    \ 'components'\n    guard let openingBrackets = brackets.components(separatedBy:\
    \ \"<\") else {\n                                ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp9_bmlutw.swift:16:36:\
    \ error: value of type 'String' has no member 'components'\n    let closingBrackets\
    \ = brackets.components(separatedBy: \">\")\n                          ~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Make sure we have at least 1 opening bracket\n    let openBrackets = brackets.components(separatedBy:\
    \ \"<\")\n    guard openBrackets.count > 0 else {\n        return true\n    }\n\
    \n    // Make sure we have at least 1 closing bracket\n    let closeBrackets =\
    \ brackets.components(separatedBy: \">\")\n    guard closeBrackets.count > 0 else\
    \ {\n        return false\n    }\n\n    // Make sure we have all the right opening\
    \ and closing brackets\n    for openBracket in openBrackets {\n        if !closeBrackets.contains(openBracket)\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp71latj89.swift:14:33: error: value of type 'String' has no member\
    \ 'components'\n    let openBrackets = brackets.components(separatedBy: \"<\"\
    )\n                       ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp71latj89.swift:20:34: error:\
    \ value of type 'String' has no member 'components'\n    let closeBrackets = brackets.components(separatedBy:\
    \ \">\")\n                        ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard !brackets.isEmpty else { return true }\n\n    let closeBrackets = brackets.componentsSeparatedByString(\"\
    </\")\n    guard !closeBrackets.isEmpty else { return false }\n\n    let openBrackets\
    \ = brackets.componentsSeparatedByString(\"<\")\n    guard !openBrackets.isEmpty\
    \ else { return false }\n\n    let openBracketsWithoutClosingBrackets = openBrackets.filter\
    \ {\n        !$0.contains(\">\") && !$0.contains(\"</\")\n    }\n    guard !openBracketsWithoutClosingBrackets.isEmpty\
    \ else { return true }\n\n    let closeBracketsWithoutOpeningBrackets = closeBrackets.filter\
    \ {\n        !$0.contains(\"<\") && !$0.contains(\"</\")\n    }\n    guard !closeBracketsWithoutOpeningBrackets.isEmpty\
    \ else { return true }\n\n    let openBracketsWithoutClosingAndOpeningBrackets\
    \ = openBracketsWithoutClosingBrackets.filter {\n        !$0.contains(\"><\")\
    \ && !$0.contains(\"<</\")\n    }\n    guard !openBracketsWithoutClosingAndOpeningBrackets.isEmpty\
    \ else { return false }\n\n    let closeBracketsWithoutOpeningAndClosingBrackets\
    \ = closeBracketsWithoutOpeningBrackets.filter {\n        !$0.contains(\"<<\"\
    ) && !$0.contains(\"><\")\n    }\n    guard !closeBracketsWithoutOpeningAndClosingBrackets.isEmpty\
    \ else { return false }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpo0h50g16.swift:15:34: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let closeBrackets = brackets.componentsSeparatedByString(\"\
    </\")\n                        ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo0h50g16.swift:18:33:\
    \ error: value of type 'String' has no member 'componentsSeparatedByString'\n\
    \    let openBrackets = brackets.componentsSeparatedByString(\"<\")\n        \
    \               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    \n    let start = brackets.startIndex\n    let end = brackets.startIndex\n\
    \n    for cur in brackets.characters.reversed().enumerated() {\n        let open\
    \ = brackets.characters[cur.offset]\n        let close = brackets.characters[cur.offset+1]\n\
    \        \n        if open == close {\n            cur.offset += 2\n        }\
    \ else {\n            if start < cur.offset {\n                return false\n\
    \            }\n\n            start = cur.offset\n        }\n    }\n    \n   \
    \ return start < brackets.endIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbmbkjsqd.swift:17:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for cur in brackets.characters.reversed().enumerated()\
    \ {\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbmbkjsqd.swift:18:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ open = brackets.characters[cur.offset]\n                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpbmbkjsqd.swift:18:29:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ open = brackets.characters[cur.offset]\n                            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbmbkjsqd.swift:19:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let close = brackets.characters[cur.offset+1]\n\
    \                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpbmbkjsqd.swift:19:30: error:\
    \ 'characters' is unavailable: Please use String directly\n        let close =\
    \ brackets.characters[cur.offset+1]\n                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbmbkjsqd.swift:22:24:\
    \ error: left side of mutating operator isn't mutable: 'cur' is a 'let' constant\n\
    \            cur.offset += 2\n            ~~~        ^\n/tmp/tmpbmbkjsqd.swift:24:22:\
    \ error: referencing operator function '<' on 'BinaryInteger' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n            if start < "
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var has_bracket = false\n    var count = 0\n    var opening_brackets: [Character]\
    \ = []\n    var closing_brackets: [Character] = []\n\n    // Count opening brackets.\n\
    \    brackets.forEach { character in\n        switch character {\n        case\
    \ \">\":\n            closing_brackets.append(character)\n        default:\n \
    \           opening_brackets.append(character)\n        }\n    }\n\n    // Validate\
    \ bracketing.\n    if opening_brackets.count == 0 || closing_brackets.count ==\
    \ 0 {\n        return false\n    }\n\n    // Find first opening bracket.\n   \
    \ if let opening = opening_brackets.first {\n        if let closing = closing_brackets.first(where:\
    \ { opening.equalToString($0) }) {\n            has_bracket = true\n         \
    \   count += 1\n        }\n    }\n\n    // If count is 0, no brackets are missing.\n\
    \    return count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdzdw3nhx.swift:35:66: error: value of type 'Character' has no member\
    \ 'equalToString'\n        if let closing = closing_brackets.first(where: { opening.equalToString($0)\
    \ }) {\n                                                         ~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var hasBrackets = false\n    for char in brackets {\n        if char <= \"\
    ^\" {\n            hasBrackets = true\n        } else {\n            hasBrackets\
    \ = hasBrackets || stringContainsAll(chars: brackets, char: char)\n        }\n\
    \    }\n    return hasBrackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpza9rak2i.swift:18:42: error: cannot find 'stringContainsAll' in\
    \ scope\n            hasBrackets = hasBrackets || stringContainsAll(chars: brackets,\
    \ char: char)\n                                         ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return true\n    }\n    let leftStack = brackets.characters(in:\
    \ CharacterSet.leftSquareBrackets)\n    let rightStack = brackets.characters(in:\
    \ CharacterSet.rightSquareBrackets)\n    return leftStack == rightStack\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpymde20qk.swift:16:45: error: cannot find 'CharacterSet' in scope\n\
    \    let leftStack = brackets.characters(in: CharacterSet.leftSquareBrackets)\n\
    \                                            ^~~~~~~~~~~~\n/tmp/tmpymde20qk.swift:16:30:\
    \ error: cannot call value of non-function type 'String'\n    let leftStack =\
    \ brackets.characters(in: CharacterSet.leftSquareBrackets)\n                 \
    \            ^\n/tmp/tmpymde20qk.swift:17:46: error: cannot find 'CharacterSet'\
    \ in scope\n    let rightStack = brackets.characters(in: CharacterSet.rightSquareBrackets)\n\
    \                                             ^~~~~~~~~~~~\n/tmp/tmpymde20qk.swift:17:31:\
    \ error: cannot call value of non-function type 'String'\n    let rightStack =\
    \ brackets.characters(in: CharacterSet.rightSquareBrackets)\n                \
    \              ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack = [String]()\n    var opening = false\n\n    for char in brackets\
    \ {\n        if char == \"<\" {\n            opening = true\n        } else {\n\
    \            opening = false\n\n            for (index, stack_string) in stack.enumerated()\
    \ {\n                if stack_string == brackets {\n                    stack.removeAllElements()\n\
    \                    break\n                }\n            }\n        }\n\n  \
    \      stack.append(char)\n    }\n\n    return opening.count == stack.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfiw_ulr1.swift:24:27: error: value of type '[String]' has no member\
    \ 'removeAllElements'\n                    stack.removeAllElements()\n       \
    \             ~~~~~ ^~~~~~~~~~~~~~~~~\n/tmp/tmpfiw_ulr1.swift:30:22: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \   stack.append(char)\n                     ^\n/tmp/tmpfiw_ulr1.swift:33:20:\
    \ error: value of type 'Bool' has no member 'count'\n    return opening.count\
    \ == stack.count\n           ~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty() { return true }\n    let openingBrackets = brackets.split(separator:\
    \ \"<\")\n        .map(String.init)\n        .reduce(into: [String]()) {\n   \
    \     (accumulator, substring) in\n        let closingBracket = substring.replacingOccurrences(of:\
    \ \"<\", with: \">\")\n        accumulator.append(closingBracket)\n    }\n   \
    \ return !openingBrackets.isEmpty && openingBrackets.count == openingBrackets.count()\
    \ && openingBrackets.contains(where: \\.isEmpty)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzgikx3v8.swift:13:17: error: cannot call value of non-function\
    \ type 'Bool'\n    if brackets.isEmpty() { return true }\n                ^  \
    \    ~~\n                       \n/tmp/tmpzgikx3v8.swift:18:40: error: value of\
    \ type 'String' has no member 'replacingOccurrences'\n        let closingBracket\
    \ = substring.replacingOccurrences(of: \"<\", with: \">\")\n                 \
    \            ~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzgikx3v8.swift:21:124: error:\
    \ cannot infer key path type from context; consider explicitly specifying a root\
    \ type\n    return !openingBrackets.isEmpty && openingBrackets.count == openingBrackets.count()\
    \ && openingBrackets.contains(where: \\.isEmpty)\n                           \
    \                                                                            \
    \                    ^\n                                                     \
    \                                                                       <#Root#>\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBrackets = \"\"\n    var closingBrackets = \"\"\n    for _, bracket\
    \ in brackets.enumerated() {\n        switch bracket {\n        case 0: openingBrackets\
    \ += \"<\"\n        case 1: openingBrackets += \"[\"\n        case 2: openingBrackets\
    \ += \"(\"\n        case 3: openingBrackets += \"{\"\n        case 4: openingBrackets\
    \ += \"(\"\n        case 5: openingBrackets += \"]\"\n        case 6: openingBrackets\
    \ += \")\"\n        case 7: openingBrackets += \"}\"\n        default: break\n\
    \        }\n        switch bracket {\n        case 0: closingBrackets += \">\"\
    \n        case 1: closingBrackets += \"]\"\n        case 2: closingBrackets +=\
    \ \")\"\n        case 3: closingBrackets += \"}\" // for JSON\n        case 4:\
    \ closingBrackets += \"]\"\n        case 5: closingBrackets += \"]\"\n       \
    \ case 6: closingBrackets += \"}\"\n        case 7: closingBrackets += \"}\"\n\
    \        default: break\n        }\n    }\n    let openingBracketCount = openingBrackets.count\n\
    \    let closingBracketCount = closingBrackets.count\n    return openingBracketCount\
    \ == closingBracketCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjuw0oegx.swift:15:10: error: expected 'in' after for-each pattern\n\
    \    for _, bracket in brackets.enumerated() {\n         ^\n/tmp/tmpjuw0oegx.swift:15:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, bracket in\
    \ brackets.enumerated() {\n         ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.components(separatedBy: \">\").flatMap({ $0\
    \ }).sorted()\n    let closingBrackets = brackets.components(separatedBy: \"<\"\
    ).flatMap({ $0 }).sorted()\n    return (openingBrackets == closingBrackets)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3fkw__fj.swift:13:36: error: value of type 'String' has no member\
    \ 'components'\n    let openingBrackets = brackets.components(separatedBy: \"\
    >\").flatMap({ $0 }).sorted()\n                          ~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp3fkw__fj.swift:14:36: error: value of type 'String' has no member 'components'\n\
    \    let closingBrackets = brackets.components(separatedBy: \"<\").flatMap({ $0\
    \ }).sorted()\n                          ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var ok = false\n    if brackets.contains(\"<\") && brackets.contains(\">\"\
    ) {\n        let open = brackets.range(of: \"<\")\n        let close = brackets.range(of:\
    \ \">\", options: .backwards)\n        ok = open != nil && close != nil && open!.lowerBound\
    \ < close!.upperBound\n    }\n    return ok\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjfws27cw.swift:15:29: error: value of type 'String' has no member\
    \ 'range'\n        let open = brackets.range(of: \"<\")\n                   ~~~~~~~~\
    \ ^~~~~\n/tmp/tmpjfws27cw.swift:16:30: error: value of type 'String' has no member\
    \ 'range'\n        let close = brackets.range(of: \">\", options: .backwards)\n\
    \                    ~~~~~~~~ ^~~~~\n/tmp/tmpjfws27cw.swift:16:55: error: cannot\
    \ infer contextual base in reference to member 'backwards'\n        let close\
    \ = brackets.range(of: \">\", options: .backwards)\n                         \
    \                            ~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var open = brackets.characters(\n        in: CharacterSet.any,\n        options:\
    \ .init(rawValue: 0)\n    ).map(String.init)\n    var closed = brackets.characters(\n\
    \        in: CharacterSet.any,\n        options: .init(rawValue: 0)\n    ).map(String.init)\n\
    \    guard open.isEmpty == closed.isEmpty else {\n        return false\n    }\n\
    \    for openBracket in open {\n        let index = closed.index(of: openBracket)\n\
    \        if index == nil {\n            return false\n        }\n        closed.remove(at:\
    \ index!)\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcv_749o4.swift:14:13: error: cannot find 'CharacterSet' in scope\n\
    \        in: CharacterSet.any,\n            ^~~~~~~~~~~~\n/tmp/tmpcv_749o4.swift:13:25:\
    \ error: cannot call value of non-function type 'String'\n    var open = brackets.characters(\n\
    \                        ^\n/tmp/tmpcv_749o4.swift:15:19: error: cannot infer\
    \ contextual base in reference to member 'init'\n        options: .init(rawValue:\
    \ 0)\n                 ~^~~~\n/tmp/tmpcv_749o4.swift:18:13: error: cannot find\
    \ 'CharacterSet' in scope\n        in: CharacterSet.any,\n            ^~~~~~~~~~~~\n\
    /tmp/tmpcv_749o4.swift:17:27: error: cannot call value of non-function type 'String'\n\
    \    var closed = brackets.characters(\n                          ^\n/tmp/tmpcv_749o4.swift:19:19:\
    \ error: cannot infer contextual base in reference to member 'init'\n        options:\
    \ .init(rawValue: 0)\n                 ~^~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if let opening_brackets = brackets.range(of: \"<\") {\n        for openingBracket\
    \ in opening_brackets {\n            if let closing_bracket = brackets.range(of:\
    \ String(openingBracket)) {\n                if closing_bracket.count > openingBracket.count\
    \ {\n                    return false\n                }\n            }\n    \
    \    }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5brckpzy.swift:13:40: error: value of type 'String' has no member\
    \ 'range'\n    if let opening_brackets = brackets.range(of: \"<\") {\n       \
    \                       ~~~~~~~~ ^~~~~\n/tmp/tmp5brckpzy.swift:15:47: error: value\
    \ of type 'String' has no member 'range'\n            if let closing_bracket =\
    \ brackets.range(of: String(openingBracket)) {\n                             \
    \        ~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.characters.map { String($0) }\n    guard let first =\
    \ brackets.first else { return false }\n    for opening in brackets.dropFirst()\
    \ {\n        let index = brackets.index(opening, offsetBy: 1)\n        guard index\
    \ < brackets.endIndex,\n            let closing = brackets[index] else { return\
    \ false }\n        guard closing == opening else { return false }\n    }\n   \
    \ return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjhuo1j47.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.characters.map { String($0) }\n\
    \    ^~~~~~~~\n/tmp/tmpjhuo1j47.swift:13:36: error: cannot assign value of type\
    \ '[String]' to type 'String'\n    brackets = brackets.characters.map { String($0)\
    \ }\n               ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpjhuo1j47.swift:16:36:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String.Index'\n\
    \        let index = brackets.index(opening, offsetBy: 1)\n                  \
    \                 ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = brackets.characters.reversed().map { String($0) }\n    for character\
    \ in stack.last {\n        if stack.first {\n            if character != \">\"\
    \ { return false }\n        }\n        else if character != \"<\" {\n        \
    \    return false\n        }\n        stack.removeLast()\n    }\n    return stack.count\
    \ == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsmeqbtg3.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let stack = brackets.characters.reversed().map { String($0)\
    \ }\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpsmeqbtg3.swift:14:28: error: for-in loop requires '((String)\
    \ throws -> Bool) throws -> String?' to conform to 'Sequence'\n    for character\
    \ in stack.last {\n                     ~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var leftCounter = 0\n    var rightCounter = 0\n    var leftIsFirst = true\n\
    \    for ch in brackets {\n        if ch == \"<\" {\n            if leftIsFirst\
    \ {\n                leftCounter++\n            } else {\n                leftCounter--\n\
    \            }\n            leftIsFirst = !leftIsFirst\n        }\n        if\
    \ ch == \">\" {\n            rightCounter++\n        }\n    }\n    return leftCounter\
    \ == 0 && rightCounter == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpt4i_typ7.swift:19:28: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                leftCounter++\n                      \
    \     ^~\n/tmp/tmpt4i_typ7.swift:21:28: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n                leftCounter--\n                      \
    \     ^~\n/tmp/tmpt4i_typ7.swift:26:25: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            rightCounter++\n                        ^~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return true\n    }\n    var openingBrackets\
    \ = brackets.characters\n    openingBrackets.removeFirst()\n    var closingBrackets\
    \ = brackets.characters\n    closingBrackets.removeLast()\n    if openingBrackets.count\
    \ != closingBrackets.count {\n        return false\n    }\n    for index in 0..<openingBrackets.count\
    \ {\n        let open = openingBrackets[index]\n        let close = closingBrackets[index]\n\
    \        switch open {\n        case \"<\":\n            if close != \"<\" {\n\
    \                return false\n            }\n        case \"=\":\n          \
    \  if close != \"=\" {\n                return false\n            }\n        case\
    \ \"&\":\n            if close != \"&\" {\n                return false\n    \
    \        }\n        case \"/\":\n            if close != \"/\" {\n           \
    \     return false\n            }\n        case \"~\":\n            if close !=\
    \ \"~\" {\n                return false\n            }\n        case \"{\":\n\
    \            if close != \"{\" {\n                return false\n            }\n\
    \        case \"}\":\n            if close != \"}\" {\n                return\
    \ false\n            }\n        default:\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpaj7cktwb.swift:16:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    var openingBrackets = brackets.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpaj7cktwb.swift:18:36: error: 'characters' is unavailable:\
    \ Please use String directly\n    var closingBrackets = brackets.characters\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpaj7cktwb.swift:24:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ open = openingBrackets[index]\n                   ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpaj7cktwb.swift:25:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let close = closingBrackets[index]\n  \
    \                  ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets.prefix(1)\n    let closing = brackets.suffix(1)\n\
    \    for openingChar in opening {\n        if closingChars.index(of: openingChar)\
    \ == nil {\n            return false\n        }\n    }\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmph0h9_drn.swift:16:12: error: cannot find 'closingChars' in scope\n\
    \        if closingChars.index(of: openingChar) == nil {\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var retval = true\n    for opening, closing := range brackets {\n       \
    \ if opening != closing {\n            retval = false\n            break\n   \
    \     }\n    }\n    return retval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmppaahyveo.swift:14:16: error: expected 'in' after for-each pattern\n\
    \    for opening, closing := range brackets {\n               ^\n/tmp/tmppaahyveo.swift:14:16:\
    \ error: expected Sequence expression for for-each loop\n    for opening, closing\
    \ := range brackets {\n               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.lowercased()\n\n    if brackets.count < 2 {\n       \
    \ return false\n    }\n\n    var isInside = true // if brackets is \"<>\" or \"\
    <<>>\" or \"<<><>>\", then isInside is true\n\n    var currentBracket = 0\n  \
    \  var currentOpening = brackets.startIndex\n    var currentClosing = brackets.endIndex\n\
    \n    // iterate over the string and look for opening and closing brackets\n \
    \   while currentOpening != brackets.endIndex && currentClosing != brackets.endIndex\
    \ {\n        let openingChar = brackets[currentOpening]\n        let closingChar\
    \ = brackets[currentClosing]\n\n        if openingChar == \"<\" {\n          \
    \  if closingChar == \">\" {\n                currentBracket++\n            }\
    \ else {\n                currentBracket = 0\n            }\n        }\n\n   \
    \     if openingChar == \">\" {\n            if closingChar == \"<\" {\n     \
    \           currentBracket--\n            } else {\n                currentBracket\
    \ = 0\n            }\n        }\n\n        if currentBracket == 0 {\n        \
    \    isInside = false\n            break\n        }\n\n        currentClosing++\n\
    \        currentBracket--\n    }\n\n    return isInside\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmd__zzwh.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.lowercased()\n    ^~~~~~~~\n/tmp/tmpmd__zzwh.swift:32:31:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      currentBracket++\n                              ^~\n/tmp/tmpmd__zzwh.swift:40:31:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \      currentBracket--\n                              ^~\n/tmp/tmpmd__zzwh.swift:51:23:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        currentClosing++\n\
    \                      ^~\n/tmp/tmpmd__zzwh.swift:52:23: error: cannot find operator\
    \ '--' in scope; did you mean '-= 1'?\n        currentBracket--\n            \
    \          ^~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var stack = Array<Bracket>()\n\tfor brack, clos in brackets.characters {\n\t\t\
    switch brack {\n\t\tcase '<':\n\t\t\tstack.push(Bracket(bracket: clos, open: true,\
    \ close: false))\n\t\tcase '<=':\n\t\t\tstack.push(Bracket(bracket: clos, open:\
    \ true, close: true))\n\t\tcase '>':\n\t\t\tstack.removeLast()\n\t\t\tstack.push(Bracket(bracket:\
    \ clos, open: false, close: false))\n\t\tcase '>=':\n\t\t\tstack.removeLast()\n\
    \t\t\tstack.push(Bracket(bracket: clos, open: false, close: true))\n\t\tdefault:\n\
    \t\t\treturn false\n\t\t}\n\t}\n\treturn stack.count == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3clve505.swift:14:11: error: expected 'in' after for-each pattern\n\
    \        for brack, clos in brackets.characters {\n                 ^\n/tmp/tmp3clve505.swift:14:11:\
    \ error: expected Sequence expression for for-each loop\n        for brack, clos\
    \ in brackets.characters {\n                 ^\n/tmp/tmp3clve505.swift:16:8: error:\
    \ single-quoted string literal found, use '\"'\n                case '<':\n  \
    \                   ^~~\n                     \"<\"\n/tmp/tmp3clve505.swift:18:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '<=':\n\
    \                     ^~~~\n                     \"<=\"\n/tmp/tmp3clve505.swift:20:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '>':\n\
    \                     ^~~\n                     \">\"\n/tmp/tmp3clve505.swift:23:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '>=':\n\
    \                     ^~~~\n                     \">=\"\n/tmp/tmp3clve505.swift:13:20:\
    \ error: cannot find type 'Bracket' in scope\n        var stack = Array<Bracket>()\n\
    \                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var success : Bool = true\n    brackets = brackets.lowercased()\n    var\
    \ opening = brackets.substringWithRange(NSMakeRange(0, brackets.startIndex))\n\
    \    var closing = brackets.substringWithRange(NSMakeRange(brackets.startIndex,\
    \ brackets.length))\n    for opening_bracket in opening {\n        var closing_bracket\
    \ = String(opening_bracket)\n        closing_bracket.removeAtIndex(0)\n      \
    \  closing_bracket.removeLast()\n        if closing == closing_bracket {\n   \
    \         success = false\n            break\n        }\n    }\n    return success\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp55jnt9oa.swift:14:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.lowercased()\n    ^~~~~~~~\n/tmp/tmp55jnt9oa.swift:15:47:\
    \ error: cannot find 'NSMakeRange' in scope\n    var opening = brackets.substringWithRange(NSMakeRange(0,\
    \ brackets.startIndex))\n                                              ^~~~~~~~~~~\n\
    /tmp/tmp55jnt9oa.swift:15:28: error: value of type 'String' has no member 'substringWithRange'\n\
    \    var opening = brackets.substringWithRange(NSMakeRange(0, brackets.startIndex))\n\
    \                  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp55jnt9oa.swift:16:47:\
    \ error: cannot find 'NSMakeRange' in scope\n    var closing = brackets.substringWithRange(NSMakeRange(brackets.startIndex,\
    \ brackets.length))\n                                              ^~~~~~~~~~~\n\
    /tmp/tmp55jnt9oa.swift:16:28: error: value of type 'String' has no member 'substringWithRange'\n\
    \    var closing = brackets.substringWithRange(NSMakeRange(brackets.startIndex,\
    \ brackets.length))\n                  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp55jnt9oa.swift:16:89:\
    \ error: value of type 'String' has no member 'length'\n    var closing = brackets.substringWithRange(NSMakeRange(brackets.startIndex,\
    \ brackets.length))\n                                                        \
    \                       ~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty { return false }\n    if brackets[0] != \"<\" { return\
    \ false }\n    var stack = [String]()\n    var opening = true\n    var depth =\
    \ 0\n    for char in brackets {\n        if opening&&char != \"<\" {\n       \
    \     stack.insert(char, depth)\n            opening = false\n        } else if\
    \ char == \"<\" {\n            opening = true\n            depth++\n        }\
    \ else if char == \">\" {\n            if stack[stack.count-1] == \"<\" {\n  \
    \              opening = false\n                depth--\n            }\n     \
    \   }\n    }\n    if opening&&stack.count != 0 {\n        return false\n    }\n\
    \    for char in brackets {\n        if char == \"<\" {\n            if depth\
    \ == 0 {\n                return false\n            }\n        } else if char\
    \ == \">\" {\n            if depth == 0 {\n                return false\n    \
    \        }\n            if stack.count != 0 {\n                return false\n\
    \            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpansuov2d.swift:14:8: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    if brackets[0]\
    \ != \"<\" { return false }\n       ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpansuov2d.swift:20:19: error: no exact\
    \ matches in call to instance method 'insert'\n            stack.insert(char,\
    \ depth)\n                  ^\n/tmp/tmpansuov2d.swift:20:19: note: candidate has\
    \ partially matching parameter list (__owned String, at: Int)\n            stack.insert(char,\
    \ depth)\n                  ^\n/tmp/tmpansuov2d.swift:20:19: note: candidate has\
    \ partially matching parameter list (__owned String, at: Array<String>.Index)\n\
    \            stack.insert(char, depth)\n                  ^\n/tmp/tmpansuov2d.swift:24:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  depth++\n                 ^~\n/tmp/tmpansuov2d.swift:28:22: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n                depth--\n    \
    \                 ^~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack: [String] = []\n    var openedBrackets = [String]()\n    var lastChar\
    \ = brackets.characters.last!\n    var lastCharIndex = brackets.startIndex\n \
    \   for i in brackets.characters.reverse() {\n        let ch = String(i)\n   \
    \     if ch == \">\" {\n            // If the last two characters aren't the same\
    \ then we have a problem\n            if openedBrackets.count != stack.count ||\
    \ openedBrackets.last! != ch {\n                return false\n            }\n\
    \            stack.removeLast()\n            openedBrackets.removeLast()\n   \
    \         lastCharIndex = lastCharIndex.advancedBy(-1)\n            continue\n\
    \        } else if ch == \"<\" {\n            if !stack.isEmpty {\n          \
    \      return false\n            }\n            openedBrackets.append(ch)\n  \
    \          lastCharIndex = lastCharIndex.advancedBy(-1)\n        } else {\n  \
    \          if !stack.isEmpty || openedBrackets.contains(ch) {\n              \
    \  return false\n            }\n            stack.append(ch)\n        }\n    }\n\
    \    return !stack.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcmr93lb_.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    var lastChar = brackets.characters.last!\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpcmr93lb_.swift:17:34: error: value of type 'String' has no member\
    \ 'reverse'\n    for i in brackets.characters.reverse() {\n             ~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard brackets.isEmpty else {\n        return true\n    }\n\n    let chars\
    \ = brackets.characters\n    var i = 0\n    while i < chars.count {\n        if\
    \ chars[i] != chars.first! {\n            return false\n        }\n        i +=\
    \ 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpibuhtu_7.swift:17:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = brackets.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpibuhtu_7.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if chars[i] != chars.first! {\n       \
    \    ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.substringToIndex(advance(brackets, 1))\n    let index\
    \ = brackets.rangeOfString(\"<\")\n    if index == nil || index!.endIndex == brackets.startIndex\
    \ {\n        return false\n    }\n    let lastIndex = brackets.rangeOfString(\"\
    >\", range: index!.endIndex..<brackets.endIndex)\n    if lastIndex == nil {\n\
    \        return false\n    }\n    return brackets.substringFromIndex(lastIndex!.endIndex)\
    \ == brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdg4zlsqd.swift:13:42: error: cannot find 'advance' in scope\n \
    \   brackets = brackets.substringToIndex(advance(brackets, 1))\n             \
    \                            ^~~~~~~\n/tmp/tmpdg4zlsqd.swift:13:5: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n    brackets = brackets.substringToIndex(advance(brackets,\
    \ 1))\n    ^~~~~~~~\n/tmp/tmpdg4zlsqd.swift:13:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    brackets = brackets.substringToIndex(advance(brackets,\
    \ 1))\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpdg4zlsqd.swift:14:26:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    let index =\
    \ brackets.rangeOfString(\"<\")\n                ~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdg4zlsqd.swift:18:30:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    let lastIndex\
    \ = brackets.rangeOfString(\">\", range: index!.endIndex..<brackets.endIndex)\n\
    \                    ~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdg4zlsqd.swift:22:21: error:\
    \ value of type 'String' has no member 'substringFromIndex'\n    return brackets.substringFromIndex(lastIndex!.endIndex)\
    \ == brackets\n           ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var count = 0\n    for bracket in brackets {\n        if bracket == \"<\"\
    \ {\n            count += 1\n        } else if bracket == \"<\" {\n          \
    \  count -= 1\n        }\n    }\n    return count == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmplmqs2z2x/tmplmqs2z2x.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b47d9e6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47d9b65b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47d9b65988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47d9b647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplmqs2z2x                        0x00005601e971b40b <unavailable> + 5131

    5    libc.so.6                          0x00002b47da05a460 __libc_start_main +
    245

    6    tmplmqs2z2x                        0x00005601e971b099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \  var opening_brackets = \"\"\n  var closing_brackets = \"\"\n  var brackets_count\
    \ = 0\n  for bracket_index, bracket_character in brackets.characters {\n    switch\
    \ bracket_character {\n    case \">\":\n      if opening_brackets.characters.count\
    \ > 0 {\n        opening_brackets = opening_brackets[..<bracket_index]\n     \
    \   brackets_count += 1\n      }\n    case \"<\":\n      if closing_brackets.characters.count\
    \ > 0 {\n        closing_brackets = closing_brackets[..<bracket_index]\n     \
    \   brackets_count += 1\n      }\n    default:\n      if opening_brackets.characters.count\
    \ > 0 {\n        opening_brackets = opening_brackets[..<bracket_index]\n     \
    \   brackets_count += 1\n      } else {\n        if closing_brackets.characters.count\
    \ > 0 {\n          closing_brackets = closing_brackets[..<bracket_index]\n   \
    \       brackets_count += 1\n        } else {\n          brackets_count = 0\n\
    \        }\n      }\n    }\n  }\n  if brackets_count == 0 {\n    return true\n\
    \  }\n  return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbef_vbrb.swift:16:20: error: expected 'in' after for-each pattern\n\
    \  for bracket_index, bracket_character in brackets.characters {\n           \
    \        ^\n/tmp/tmpbef_vbrb.swift:16:20: error: expected Sequence expression\
    \ for for-each loop\n  for bracket_index, bracket_character in brackets.characters\
    \ {\n                   ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let brackets = brackets.unicodeScalars\n        .flatMap {\n            String($0)\n\
    \        }\n\n    for symbol in brackets {\n        let ranges = brackets.rangeOfString(symbol)\n\
    \        if ranges.location == NSNotFound {\n            return false\n      \
    \  }\n        for range in ranges {\n            let openingBracketIndex = brackets.index(of:\
    \ symbol) - range + 1\n            let closingBracketIndex = brackets.index(of:\
    \ symbol) + range\n            if openingBracketIndex >= 0 && closingBracketIndex\
    \ < brackets.count {\n                return false\n            }\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpi8ojgv35.swift:19:31: error: value of type '[String.Element]' (aka\
    \ 'Array<Character>') has no member 'rangeOfString'\n        let ranges = brackets.rangeOfString(symbol)\n\
    \                     ~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpi8ojgv35.swift:20:31: error:\
    \ cannot find 'NSNotFound' in scope\n        if ranges.location == NSNotFound\
    \ {\n                              ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.characters.split(separator: \"<\").map({ String($0)\
    \ })\n    let closingBrackets = brackets.characters.split(separator: \">\").map({\
    \ String($0) })\n    let allBrackets = openingBrackets + closingBrackets\n   \
    \ return openingBrackets.count == allBrackets.count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfte8ecqs.swift:13:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let openingBrackets = brackets.characters.split(separator:\
    \ \"<\").map({ String($0) })\n                                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpfte8ecqs.swift:14:36:\
    \ error: 'characters' is unavailable: Please use String directly\n    let closingBrackets\
    \ = brackets.characters.split(separator: \">\").map({ String($0) })\n        \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // we iterate through the string once to count the number of open\n    //\
    \ brackets and once to count the number of close brackets.\n    var openBracketCount\
    \ = 1\n    var closeBracketCount = 1\n\n    for letter in brackets {\n       \
    \ if letter == \"<\" {\n            openBracketCount++\n        } else if letter\
    \ == \">\" {\n            closeBracketCount++\n        } else if letter == \"\
    ,\" {\n            // if there are two consecutive commas, then the string is\n\
    \            // not correctly bracketed.\n            if openBracketCount == closeBracketCount\
    \ {\n                return false\n            }\n        } else {\n         \
    \   // unrecognized character\n            return false\n        }\n    }\n\n\
    \    // If there are an equal number of open and close brackets, then the string\n\
    \    // is correctly bracketed.\n    return openBracketCount == closeBracketCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8qtb_uv7.swift:20:29: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            openBracketCount++\n                     \
    \       ^~\n/tmp/tmp8qtb_uv7.swift:22:30: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n            closeBracketCount++\n             \
    \                ^~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBracketIndices = brackets.characters.split{$0 == \"<\"}\n    let\
    \ closingBracketIndices = brackets.characters.split{$0 == \">\"}\n\n    let matchingIndices\
    \ = Set(openingBracketIndices).symmetricDifference(Set(closingBracketIndices))\n\
    \    return matchingIndices.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_904rs2o.swift:13:42: error: 'characters' is unavailable: Please\
    \ use String directly\n    let openingBracketIndices = brackets.characters.split{$0\
    \ == \"<\"}\n                                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp_904rs2o.swift:14:42: error: 'characters'\
    \ is unavailable: Please use String directly\n    let closingBracketIndices =\
    \ brackets.characters.split{$0 == \">\"}\n                                   \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    for opening in brackets {\n        if opening != \"<\" {\n            return\
    \ false\n        }\n    }\n    for opening in brackets {\n        if opening !=\
    \ \">\" {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmpng_4d6c7/tmpng_4d6c7.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4b7836c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4b752db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4b752d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4b752c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpng_4d6c7                        0x0000560de1ebb40b <unavailable> + 5131

    5    libc.so.6                          0x00002af4b7a22460 __libc_start_main +
    245

    6    tmpng_4d6c7                        0x0000560de1ebb099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opens = brackets.components(separatedBy: \"<\")\n        .map { $0.first!\
    \ as Character }\n    let closes = brackets.components(separatedBy: \">\")\n \
    \       .map { $0.last! as Character }\n    if opens.count == closes.count {\n\
    \        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp244duxn4.swift:13:26: error: value of type 'String' has no member\
    \ 'components'\n    let opens = brackets.components(separatedBy: \"<\")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp244duxn4.swift:15:27: error: value of\
    \ type 'String' has no member 'components'\n    let closes = brackets.components(separatedBy:\
    \ \">\")\n                 ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard let first = brackets.first,\n        last = brackets.last else {\n\
    \        return false\n    }\n    return brackets.contains(first) && brackets.contains(last)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpw_vr_kh4.swift:14:9: error: expected 'let' in conditional\n   \
    \     last = brackets.last else {\n        ^\n        let \n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var closed = [String]()\n\tfor i := 0; i < len(brackets); i++ {\n\t\tc := brackets[i]\n\
    \t\tif c == '>' {\n\t\t\tif !closed {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tclosed\
    \ = false\n\t\t} else if c == '<' {\n\t\t\tif closed {\n\t\t\t\treturn false\n\
    \t\t\t}\n\t\t\tclosed = true\n\t\t} else if c != '>' && c != '<' {\n\t\t\treturn\
    \ false\n\t\t}\n\t}\n\treturn closed == nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmph9fdyml9.swift:14:9: error: expected type\n        for i := 0;\
    \ i < len(brackets); i++ {\n               ^\n                <#type#>\n/tmp/tmph9fdyml9.swift:14:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(brackets);\
    \ i++ {\n               ^\n/tmp/tmph9fdyml9.swift:14:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(brackets); i++ {\n\
    \               ^\n/tmp/tmph9fdyml9.swift:15:4: error: consecutive statements\
    \ on a line must be separated by ';'\n                c := brackets[i]\n     \
    \            ^\n                 ;\n/tmp/tmph9fdyml9.swift:15:5: error: expected\
    \ expression\n                c := brackets[i]\n                  ^\n/tmp/tmph9fdyml9.swift:16:11:\
    \ error: single-quoted string literal found, use '\"'\n                if c ==\
    \ '>' {\n                        ^~~\n                        \">\"\n/tmp/tmph9fdyml9.swift:21:18:\
    \ error: single-quoted string literal found, use '\"'\n                } else\
    \ if c == '<' {\n                               ^~~\n                        \
    \       \"<\"\n/tmp/tmph9fdyml9.swift:26:18: error: single-quoted string literal\
    \ found, use '\"'\n                } else if c != '>' && c != '<' {\n        \
    \                       ^~~\n                               \">\"\n/tmp/tmph9fdyml9.swift:26:30:\
    \ error: single-quoted string literal found, use '\"'\n                } else\
    \ if c != '>' && c != '<' {\n                                           ^~~\n\
    \                                           \"<\"\n/tmp/tmph9fdyml9.swift:30:16:\
    \ warning: comparing non-optional value of type '[String]' to 'nil' always returns\
    \ false\n        return closed == nil\n               ~~~~~~ ^  ~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let brackets = brackets.characters\n        .flatMap { String($0) }\n   \
    \     .map { String($0) }\n        .replacingOccurrences(of: \"<\", with: \"(\"\
    )\n        .replacingOccurrences(of: \">\", with: \")\")\n        .replacingOccurrences(of:\
    \ \"/>\", with: \"\")\n        .replacingOccurrences(of: \"<=\", with: \"<\")\n\
    \        .replacingOccurrences(of: \"=\", with: \"==\")\n        .replacingOccurrences(of:\
    \ \"!=\", with: \"!==\")\n        .replacingOccurrences(of: \"<=\", with: \"<\"\
    )\n        .replacingOccurrences(of: \">=\", with: \">\")\n        .replacingOccurrences(of:\
    \ \"<>\", with: \"<>\")\n        .replacingOccurrences(of: \"===\", with: \"==\"\
    )\n        .replacingOccurrences(of: \"&&\", with: \"and\")\n        .replacingOccurrences(of:\
    \ \"||\", with: \"or\")\n        .replacingOccurrences(of: \"!=\", with: \"!=\"\
    )\n        .replacingOccurrences(of: \"=\", with: \"==\")\n        .replacingOccurrences(of:\
    \ \"<\", with: \"(\")\n        .replacingOccurrences(of: \">\", with: \")\")\n\
    \        .replacingOccurrences(of: \"<>\", with: \"\")\n        .replacingOccurrences(of:\
    \ \"(\", with: \"(\")\n        .replacingOccurrences(of: \")\", with: \")\")\n\
    \        .replacingOccurrences(of: \"=>\", with: \"->\")\n        .replacingOccurrences(of:\
    \ \"<-\", with: \"<-\")\n        .replacingOccurrences(of: \"->\", with: \"=>\"\
    )\n        .replacingOccurrences(of: \"-->\", with: \"-->\")\n        .replacingOccurrences(of:\
    \ \"<=>\", with: \"<->\")\n        .replacingOccurrences(of: \"<->\", with: \"\
    <=>\")\n        .replacingOccurrences(of: \">-\", with: \">-\")\n        .replacingOccurrences(of:\
    \ \"<-\", with: \"<-\")\n        .replacingOccurrences(of: \"->\", with: \"=>\"\
    )\n        .replacingOccurrences(of: \"-->\", with: \"-->\")\n        .replacingOccurrences(of:\
    \ \"<=>\", with: \"<->\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmprcm2c06i.swift:16:10: error: value of type '[String]' has no member\
    \ 'replacingOccurrences'\n        .replacingOccurrences(of: \"<\", with: \"(\"\
    )\n         ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening_brackets = brackets.characters\n        .filter({ character in\n\
    \            character == \"<\" || character == \">\"\n        })\n        .map({\
    \ String($0) })\n    let closing_brackets = brackets.characters\n        .filter({\
    \ character in\n            character == \"<\" || character == \">\"\n       \
    \ })\n        .map({ String($0) })\n\n    if opening_brackets.count != closing_brackets.count\
    \ {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp75jdhh9e.swift:13:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    let opening_brackets = brackets.characters\n      \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp75jdhh9e.swift:18:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let closing_brackets = brackets.characters\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard let opens = brackets.components(separatedBy: \"><\")\n    else {\n\
    \        return false\n    }\n    for open in opens {\n        if !brackets.contains(\"\
    <\\(open)\") && !brackets.contains(\"\\(open)<\") {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp99fm5mvu.swift:13:32: error: value of type 'String' has no member\
    \ 'components'\n    guard let opens = brackets.components(separatedBy: \"><\"\
    )\n                      ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.characters\n        .map { String($0) }\n\
    \        .map { String($0) }\n        .filter { $0 != \"<\" && $0 != \">\" }\n\
    \        .filter { $0 != \"<<\" && $0 != \">>\" }\n\n    let closingBrackets =\
    \ brackets.characters\n        .map { String($0) }\n        .map { String($0)\
    \ }\n        .filter { $0 != \"<\" && $0 != \">\" }\n        .filter { $0 != \"\
    <<\" && $0 != \">>\" }\n\n    let matchingOpeningBracketCount = openingBrackets.count\
    \ - closingBrackets.count\n    return matchingOpeningBracketCount == 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmphn9roy5o.swift:13:27: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let openingBrackets = brackets.characters\n           \
    \               ^~~~~~~~~~~~~~~~~~~\n/tmp/tmphn9roy5o.swift:19:27: error: the\
    \ compiler is unable to type-check this expression in reasonable time; try breaking\
    \ up the expression into distinct sub-expressions\n    let closingBrackets = brackets.characters\n\
    \                          ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660010070
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    bracketingStack.removeAll()\n\n\tbrackets = brackets.trimmingCharacters(in: CharacterSet.whitespaces)\n\
    \tbrackets = brackets.replacingOccurrences(of: \">\", with: \">>\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \"<\", with: \"<<\")\n\n\tfor b in brackets.characters\
    \ {\n\t\tif !bracketingStack.contains(b) {\n\t\t\tbracketingStack.append(b)\n\t\
    \t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2pewj3bs.swift:13:2: error: cannot find 'bracketingStack' in scope\n\
    \        bracketingStack.removeAll()\n        ^~~~~~~~~~~~~~~\n/tmp/tmp2pewj3bs.swift:15:45:\
    \ error: cannot find 'CharacterSet' in scope\n        brackets = brackets.trimmingCharacters(in:\
    \ CharacterSet.whitespaces)\n                                                \
    \   ^~~~~~~~~~~~\n/tmp/tmp2pewj3bs.swift:15:2: error: cannot assign to value:\
    \ 'brackets' is a 'let' constant\n        brackets = brackets.trimmingCharacters(in:\
    \ CharacterSet.whitespaces)\n        ^~~~~~~~\n/tmp/tmp2pewj3bs.swift:15:22: error:\
    \ value of type 'String' has no member 'trimmingCharacters'\n        brackets\
    \ = brackets.trimmingCharacters(in: CharacterSet.whitespaces)\n              \
    \     ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2pewj3bs.swift:16:2: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n        brackets = brackets.replacingOccurrences(of:\
    \ \">\", with: \">>\")\n        ^~~~~~~~\n/tmp/tmp2pewj3bs.swift:16:22: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        brackets\
    \ = brackets.replacingOccurrences(of: \">\", with: \">>\")\n                 \
    \  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2pewj3bs.swift:17:2: error: cannot assign\
    \ to value: 'brackets' is a 'let' constant\n        brackets = brackets.replacingOccurrences(of:\
    \ \"<\", with: \"<<\")\n        ^~~~~~~~\n/tmp/tmp2pewj3bs.swift:17:22: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        brackets\
    \ = brackets.replacingOccurrences(of: \"<\", with: \"<<\")\n                 \
    \  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2pewj3bs.swift:19:20: error: 'characters'\
    \ is unavailable: Please use String directly\n        for b in brackets.characters\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2pewj3bs.swift:20:7: error: cannot find 'bracketingStack'\
    \ in scope\n                if !bracketingStack.contains(b) {\n              \
    \      ^~~~~~~~~~~~~~~\n/tmp/tmp2pewj3bs.swift:21:4: error: cannot find '"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty() {\n        return true\n    }\n    var bracketsString\
    \ = brackets\n    bracketsString.removeFirst()\n    var leftBracketsFound = false\n\
    \    for symbol in bracketsString.unicodeScalars {\n        switch symbol {\n\
    \        case \">\":\n            leftBracketsFound = true\n            break\n\
    \        default:\n            break\n        }\n    }\n    if leftBracketsFound\
    \ {\n        return false\n    }\n    return brackets.unicodeScalars.count ==\
    \ bracketsString.unicodeScalars.count - 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpicy4lt4s.swift:13:17: error: cannot call value of non-function\
    \ type 'Bool'\n    if brackets.isEmpty() {\n                ^      ~~\n      \
    \                 \n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.characters\n        .filter { character in\n\
    \            character == \"<\" || character == \">\"\n        }\n        .toSet()\n\
    \n    let closingBrackets = brackets.characters\n        .filter { character in\n\
    \            character == \"<\" || character == \">\"\n        }\n        .toSet()\n\
    \n    guard openingBrackets.count == openingBrackets.count && closingBrackets.count\
    \ == closingBrackets.count else {\n        return false\n    }\n\n    return openingBrackets.count\
    \ == openingBrackets.count + closingBrackets.count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpthfy0ioq.swift:17:10: error: reference to member 'toSet' cannot\
    \ be resolved without a contextual type\n        .toSet()\n         ^\n/tmp/tmpthfy0ioq.swift:23:10:\
    \ error: reference to member 'toSet' cannot be resolved without a contextual type\n\
    \        .toSet()\n         ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    let opening = brackets.unicodeScalars.filter({ $0 == \">\" })\n\tlet closing =\
    \ brackets.unicodeScalars.filter({ $0 == \"<\" })\n\topening.forEach { openingElement\
    \ in\n\t\tclosing.forEach { closingElement in\n\t\t\tif openingElement == closingElement\
    \ {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7yatwil6.swift:18:12: error: unexpected non-void return value in\
    \ void function\n                                return false\n              \
    \                         ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets.characters.split(separator: \">\").map(String.init)\n\
    \    let closing = brackets.characters.split(separator: \"<\").map(String.init)\n\
    \    return opening.count == closing.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmppy68dxl4.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let opening = brackets.characters.split(separator:\
    \ \">\").map(String.init)\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmppy68dxl4.swift:14:28: error: 'characters'\
    \ is unavailable: Please use String directly\n    let closing = brackets.characters.split(separator:\
    \ \"<\").map(String.init)\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    return brackets.rangeOfString(\"</>\") != nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6he9_5fk.swift:13:21: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    return brackets.rangeOfString(\"</>\") != nil\n       \
    \    ~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openings = brackets.characters.split(\"<\").map { String($0) }\n    let\
    \ closings = brackets.characters.split(\">\").map { String($0) }\n    return openings.count\
    \ == closings.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3z3omowl.swift:13:40: error: no exact matches in call to instance\
    \ method 'split'\n    let openings = brackets.characters.split(\"<\").map { String($0)\
    \ }\n                                       ^\nSwift.Sequence:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n    \
    \                                   ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmp3z3omowl.swift:14:40: error: no exact matches\
    \ in call to instance method 'split'\n    let closings = brackets.characters.split(\"\
    >\").map { String($0) }\n                                       ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let firstOpening = brackets.characters.filter({ $0 == \"<\" })\n    let firstClosing\
    \ = brackets.characters.filter({ $0 == \"<\" })\n    return firstOpening.count\
    \ == firstClosing.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpo636x0ga.swift:13:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    let firstOpening = brackets.characters.filter({ $0\
    \ == \"<\" })\n                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpo636x0ga.swift:14:33: error: 'characters'\
    \ is unavailable: Please use String directly\n    let firstClosing = brackets.characters.filter({\
    \ $0 == \"<\" })\n                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.stringByReplacingOccurrencesOfString(\"<<\", withString:\
    \ \"><\")\n    brackets = brackets.stringByReplacingOccurrencesOfString(\">>\"\
    , withString: \"<<\")\n    brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    <\", withString: \">\")\n    return brackets.rangeOfString(\"<<>\").location ==\
    \ NSNotFound\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpov6tllqn.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    <<\", withString: \"><\")\n    ^~~~~~~~\n/tmp/tmpov6tllqn.swift:13:25: error:\
    \ value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    brackets = brackets.stringByReplacingOccurrencesOfString(\"<<\", withString:\
    \ \"><\")\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpov6tllqn.swift:14:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.stringByReplacingOccurrencesOfString(\">>\", withString: \"<<\")\n\
    \    ^~~~~~~~\n/tmp/tmpov6tllqn.swift:14:25: error: value of type 'String' has\
    \ no member 'stringByReplacingOccurrencesOfString'\n    brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    >>\", withString: \"<<\")\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpov6tllqn.swift:15:5: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n    brackets = brackets.stringByReplacingOccurrencesOfString(\"<\"\
    , withString: \">\")\n    ^~~~~~~~\n/tmp/tmpov6tllqn.swift:15:25: error: value\
    \ of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n    brackets\
    \ = brackets.stringByReplacingOccurrencesOfString(\"<\", withString: \">\")\n\
    \               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpov6tllqn.swift:16:54:\
    \ error: cannot find 'NSNotFound' in scope\n    return brackets.rangeOfString(\"\
    <<>\").location == NSNotFound\n                                              \
    \       ^~~~~~~~~~\n/tmp/tmpov6tllqn.swift:16:21: error: value of type 'String'\
    \ has no member 'rangeOfString'\n    return brackets.rangeOfString(\"<<>\").location\
    \ == NSNotFound\n           ~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let len = brackets.characters.count\n    if len < 2 {\n        return true\n\
    \    }\n\n    for i in 0..<len - 1 {\n        let opening = brackets.characters.index(brackets.startIndex,\
    \ offsetBy: i)\n        let closing = brackets.characters.index(brackets.startIndex,\
    \ offsetBy: i + 1)\n        if opening == closing {\n            continue\n  \
    \      }\n\n        if opening < closing {\n            return true\n        }\n\
    \    }\n\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpuvvu54jy.swift:13:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let len = brackets.characters.count\n             \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpuvvu54jy.swift:19:32: error: 'characters' is unavailable: Please use String\
    \ directly\n        let opening = brackets.characters.index(brackets.startIndex,\
    \ offsetBy: i)\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpuvvu54jy.swift:20:32: error: 'characters'\
    \ is unavailable: Please use String directly\n        let closing = brackets.characters.index(brackets.startIndex,\
    \ offsetBy: i + 1)\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openBrackets = 0\n    var closedBrackets = 0\n    var openingBrackets\
    \ = brackets.characters\n    \n    for symbol in openingBrackets {\n        if\
    \ symbol == \"<\" {\n            openBrackets += 1\n        }\n        else {\n\
    \            closedBrackets += 1\n        }\n    }\n    \n    if openBrackets\
    \ == 0 {\n        return false\n    }\n    \n    if openBrackets > 1 {\n     \
    \   return true\n    }\n    \n    if openBrackets != closedBrackets {\n      \
    \  return true\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpn438zyrj.swift:15:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    var openingBrackets = brackets.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpn438zyrj.swift:15:9: warning: variable 'openingBrackets'\
    \ was never mutated; consider changing to 'let' constant\n    var openingBrackets\
    \ = brackets.characters\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var has_correct_bracketing = true\n\n    if brackets.isEmpty() {\n      \
    \  return has_correct_bracketing\n    }\n\n    var opening_bracket = \"\"\n  \
    \  var closing_bracket = \"\"\n\n    for character in brackets.characters {\n\
    \        if character == \"<\" {\n            opening_bracket = String(character)\n\
    \        }\n\n        if character == \">\" {\n            closing_bracket = String(character)\n\
    \        }\n    }\n\n    if opening_bracket == \"\" || closing_bracket == \"\"\
    \ {\n        return has_correct_bracketing\n    }\n\n    if opening_bracket ==\
    \ \"<\" && closing_bracket == \"<\" {\n        has_correct_bracketing = false\n\
    \    }\n\n    if opening_bracket == \"<\" && closing_bracket == \">\" {\n    \
    \    has_correct_bracketing = false\n    }\n\n    if opening_bracket == \"<\"\
    \ && closing_bracket == \"<\" {\n        has_correct_bracketing = false\n    }\n\
    \n    if opening_bracket == \">\" && closing_bracket == \"<\" {\n        has_correct_bracketing\
    \ = false\n    }\n\n    if opening_bracket == \">\" && closing_bracket == \">\"\
    \ {\n        has_correct_bracketing = false\n    }\n\n    if opening_bracket ==\
    \ \">\" && closing_bracket == \"<\" {\n        has_correct_bracketing = false\n\
    \    }\n\n    if opening_bracket == \">\" && closing_bracket == \">\" {\n    \
    \    has_correct_bracketing = false\n    }\n\n    if opening_bracket == \"<\"\
    \ && closing_bracket == \"<\" {\n        has_correct_bracketing = false\n    }\n\
    \n    if opening_bracket == \"<\" && closing_bracket == \">\" {\n        has_correct_bracketing\
    \ = false\n    }\n\n    if opening_bracket == \"<\" && closing_bracket == \">\"\
    \ {\n        has_correct_bracketing = false\n    }\n\n    if opening_bracket ==\
    \ \">\" && closing_bracket == \">\" {\n        has_correct_bracketing = false\n\
    \    }\n\n    if opening_bracket == \">\" && closing_bracket == \"<\" {\n    \
    \    has_correct_bracketing = false\n    }\n\n    if opening_bracket == \">\"\
    \ && closing_bracket == \"<\" {\n        has_correct_bracketing = false\n    }\n\
    \n    if opening_bracket == \"<\" && closing_bracket == \"<\" {\n        has_correct_bracketing\
    \ = false\n    }\n\n    if opening_bracket == \"<\" && closing_bracket == \">\"\
    \ {\n        has_correct_bracketing = false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3qh6ka8l.swift:120:66: error: expected '}' at end of brace statement\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)\n        \
    \                                                         ^\n/tmp/tmp3qh6ka8l.swift:12:51:\
    \ note: to match this opening '{'\nfunc correct_bracketing(brackets: String) ->\
    \ Bool {\n                                                  ^\n/tmp/tmp3qh6ka8l.swift:15:17:\
    \ error: cannot call value of non-function type 'Bool'\n    if brackets.isEmpty()\
    \ {\n                ^      ~~\n                       \n/tmp/tmp3qh6ka8l.swift:22:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    for character\
    \ in brackets.characters {\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp3qh6ka8l.swift:97:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening = true\n    for b in brackets {\n        if b != \"<\" {\n  \
    \          opening = false\n        } else {\n            if opening {\n     \
    \           opening = false\n            } else {\n                opening = true\n\
    \            }\n        }\n    }\n    return opening\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmpdfrqvt0e/tmpdfrqvt0e.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c34932c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c34629b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c34629988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c346287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdfrqvt0e                        0x000055c394d6740b <unavailable> + 5131

    5    libc.so.6                          0x00002b8c34b1e460 __libc_start_main +
    245

    6    tmpdfrqvt0e                        0x000055c394d67099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets[1..<brackets.count]\n    \n    for b in brackets {\n\
    \        if b != \"<\" {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpa01q68r3.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets[1..<brackets.count]\n    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let pattern = \"(\\<|\\>)\"\n    let regex = try! NSRegularExpression(pattern:\
    \ pattern, options: [])\n    let nsString = brackets as NSString\n    let match\
    \ = regex.firstMatch(in: brackets, options: [], range: NSRange(0..<nsString.length))\n\
    \    return (match?.rangeAt(1) != nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbpcge4tt.swift:13:22: error: invalid escape sequence in literal\n\
    \    let pattern = \"(\\<|\\>)\"\n                     ^\n/tmp/tmpbpcge4tt.swift:13:25:\
    \ error: invalid escape sequence in literal\n    let pattern = \"(\\<|\\>)\"\n\
    \                        ^\n/tmp/tmpbpcge4tt.swift:14:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: pattern, options:\
    \ [])\n                     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpbpcge4tt.swift:15:32:\
    \ error: cannot find type 'NSString' in scope\n    let nsString = brackets as\
    \ NSString\n                               ^~~~~~~~\n/tmp/tmpbpcge4tt.swift:16:68:\
    \ error: cannot find 'NSRange' in scope\n    let match = regex.firstMatch(in:\
    \ brackets, options: [], range: NSRange(0..<nsString.length))\n              \
    \                                                     ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return true\n    }\n\n    var bracketStack\
    \ = [String]()\n    var openingBracketCount = 0\n\n    for char in brackets {\n\
    \        if char == \"<\" {\n            bracketStack.append(char)\n         \
    \   openingBracketCount += 1\n        } else if char == \">\" && openingBracketCount\
    \ > 0 {\n            if bracketStack.last() == \"<\" {\n                bracketStack.removeLast()\n\
    \            } else {\n                openingBracketCount -= 1\n            }\n\
    \        } else {\n            return false\n        }\n    }\n    return bracketStack.isEmpty\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpx81kfgjq.swift:22:33: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            bracketStack.append(char)\n\
    \                                ^\n/tmp/tmpx81kfgjq.swift:25:29: error: cannot\
    \ call value of non-function type 'String?'\n            if bracketStack.last()\
    \ == \"<\" {\n                            ^   ~~\n                           \
    \     \n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.replacingOccurrences(of: \"<\", with: \"<\")\n    brackets\
    \ = brackets.replacingOccurrences(of: \">\", with: \">\")\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<>\", with: \"<>\")\n    brackets = brackets.replacingOccurrences(of: \"<<><>>\"\
    , with: \"<><>\")\n    brackets = brackets.replacingOccurrences(of: \"><<>\",\
    \ with: \"><>\")\n    return brackets.count < 2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp62dmbul3.swift:13:5: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n    brackets = brackets.replacingOccurrences(of: \"<\"\
    , with: \"<\")\n    ^~~~~~~~\n/tmp/tmp62dmbul3.swift:13:25: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<\", with: \"<\")\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp62dmbul3.swift:14:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.replacingOccurrences(of: \">\", with: \">\")\n    ^~~~~~~~\n/tmp/tmp62dmbul3.swift:14:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    brackets\
    \ = brackets.replacingOccurrences(of: \">\", with: \">\")\n               ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp62dmbul3.swift:15:5: error: cannot assign to value:\
    \ 'brackets' is a 'let' constant\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<>\", with: \"<>\")\n    ^~~~~~~~\n/tmp/tmp62dmbul3.swift:15:25: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n    brackets = brackets.replacingOccurrences(of:\
    \ \"<>\", with: \"<>\")\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp62dmbul3.swift:16:5:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n    brackets\
    \ = brackets.replacingOccurrences(of: \"<<><>>\", with: \"<><>\")\n    ^~~~~~~~\n\
    /tmp/tmp62dmbul3.swift:16:25: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \    brackets = brackets.replacingOccurrences(of: \"<<><>>\", with: \"<><>\")\n\
    \               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp62dmbul3.swift:17:5: error:\
    \ cannot assign to value: 'brackets' is a 'let' constant\n    brackets = brackets.replacingOccurrences(of:\
    \ \"><<>\", with: \"><>\")\n    ^~~~~~~~\n/tmp/tmp62dmbul3.swift:17:25: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n    brackets =\
    \ brackets.replacingOccurrences(of: \"><<>\", with: \"><>\")\n               ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openings = brackets.components(separatedBy: \"<\")\n    let closings\
    \ = brackets.components(separatedBy: \">\")\n    let expected = (openings + closings).count\n\
    \n    if openings.count == expected {\n        return true\n    }\n    if closings.count\
    \ == expected {\n        return true\n    }\n    if openings.count == 0 && closings.count\
    \ == 0 {\n        return true\n    }\n\n    if openings.count != expected || closings.count\
    \ != expected {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmzrhj35w.swift:13:29: error: value of type 'String' has no member\
    \ 'components'\n    let openings = brackets.components(separatedBy: \"<\")\n \
    \                  ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpmzrhj35w.swift:14:29: error: value\
    \ of type 'String' has no member 'components'\n    let closings = brackets.components(separatedBy:\
    \ \">\")\n                   ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.lowercased()\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \">\", with: \">>\")\n\tbrackets = brackets.replacingOccurrences(of: \"<\",\
    \ with: \"<<\")\n\treturn brackets.range(of: \"<<\").location != nil && brackets.range(of:\
    \ \">>\").location != nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpembi2ldm.swift:13:2: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n        brackets = brackets.lowercased()\n        ^~~~~~~~\n\
    /tmp/tmpembi2ldm.swift:14:2: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n        brackets = brackets.replacingOccurrences(of: \">\", with:\
    \ \">>\")\n        ^~~~~~~~\n/tmp/tmpembi2ldm.swift:14:22: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n        brackets = brackets.replacingOccurrences(of:\
    \ \">\", with: \">>\")\n                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpembi2ldm.swift:15:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingOccurrences(of: \"<\", with: \"<<\")\n        ^~~~~~~~\n\
    /tmp/tmpembi2ldm.swift:15:22: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        brackets = brackets.replacingOccurrences(of: \"<\", with: \"<<\")\n \
    \                  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpembi2ldm.swift:16:18:\
    \ error: value of type 'String' has no member 'range'\n        return brackets.range(of:\
    \ \"<<\").location != nil && brackets.range(of: \">>\").location != nil\n    \
    \           ~~~~~~~~ ^~~~~\n/tmp/tmpembi2ldm.swift:16:62: error: value of type\
    \ 'String' has no member 'range'\n        return brackets.range(of: \"<<\").location\
    \ != nil && brackets.range(of: \">>\").location != nil\n                     \
    \                                      ~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // if there are no brackets, return true\n    if brackets.isEmpty {\n   \
    \     return true\n    }\n\n    // create a set that contains all of the opening\
    \ brackets\n    let openingBrackets = brackets.characters.filter({ $0 == \"<\"\
    \ })\n\n    // create a set that contains all of the closing brackets\n    let\
    \ closingBrackets = brackets.characters.filter({ $0 == \">\" })\n\n    // if the\
    \ length of the sets is equal then all brackets are correct.\n    if openingBrackets.count\
    \ == closingBrackets.count {\n        return true\n    }\n\n    // otherwise,\
    \ return false\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmph6g_x88u.swift:19:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let openingBrackets = brackets.characters.filter({\
    \ $0 == \"<\" })\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmph6g_x88u.swift:22:36: error: 'characters'\
    \ is unavailable: Please use String directly\n    let closingBrackets = brackets.characters.filter({\
    \ $0 == \">\" })\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    return brackets.isEmpty || brackets.split(separator: \"<\").count == brackets.split(separator:\
    \ \">\").count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmpo4u6v4wa/tmpo4u6v4wa.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b34734dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34731d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b34731d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34731d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo4u6v4wa                        0x000056442856a773 <unavailable> + 6003

    5    libc.so.6                          0x00002b34736c8460 __libc_start_main +
    245

    6    tmpo4u6v4wa                        0x000056442856a169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let bracket_index = brackets.characters.indices\n    for i in bracket_index.reversed()\
    \ {\n        if brackets[i] != \"<\" {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5bzw1f7q.swift:13:34: error: 'characters' is unavailable: Please\
    \ use String directly\n    let bracket_index = brackets.characters.indices\n \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var isRight = brackets.contains(\"<\") || brackets.contains(\"</\")\n   \
    \ if brackets.contains(\"<\") && brackets.contains(\"</\") {\n        if brackets.contains(\"\
    <\") && !brackets.contains(\"</\") {\n            isRight = false\n        } else\
    \ if brackets.contains(\"</\") && !brackets.contains(\"<\") {\n            isRight\
    \ = true\n        }\n    }\n    return isRight\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmp920gmn19/tmp920gmn19.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c91fe1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c91cd8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c91cd8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c91cd77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp920gmn19                        0x00005639792c7753 <unavailable> + 5971

    5    libc.so.6                          0x00002b3c921cd460 __libc_start_main +
    245

    6    tmp920gmn19                        0x00005639792c7149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    for i := 0; i < len(brackets); i++ {\n\t\tif brackets[i] != '<' {\n\t\t\treturn\
    \ false\n\t\t}\n\t\tfor j := 0; j < len(brackets); j++ {\n\t\t\tif j == i {\n\t\
    \t\t\tcontinue\n\t\t\t}\n\t\t\tif brackets[j] == brackets[i] {\n\t\t\t\treturn\
    \ false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmppcb8fznu.swift:13:9: error: expected type\n        for i := 0;\
    \ i < len(brackets); i++ {\n               ^\n                <#type#>\n/tmp/tmppcb8fznu.swift:13:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(brackets);\
    \ i++ {\n               ^\n/tmp/tmppcb8fznu.swift:13:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(brackets); i++ {\n\
    \               ^\n/tmp/tmppcb8fznu.swift:14:21: error: single-quoted string literal\
    \ found, use '\"'\n                if brackets[i] != '<' {\n                 \
    \                 ^~~\n                                  \"<\"\n/tmp/tmppcb8fznu.swift:17:10:\
    \ error: expected type\n                for j := 0; j < len(brackets); j++ {\n\
    \                       ^\n                        <#type#>\n/tmp/tmppcb8fznu.swift:17:10:\
    \ error: expected 'in' after for-each pattern\n                for j := 0; j <\
    \ len(brackets); j++ {\n                       ^\n/tmp/tmppcb8fznu.swift:17:10:\
    \ error: expected Sequence expression for for-each loop\n                for j\
    \ := 0; j < len(brackets); j++ {\n                       ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketPairs = [String: Bool]()\n    var bracketString = \"\"\n    for\
    \ char in brackets {\n        if char == \"<\" {\n            bracketPairs[\"\
    <\"] = false\n            bracketPairs[\">\"] = false\n        } else if char\
    \ == \">\" {\n            bracketPairs[\"<\"] = true\n            bracketPairs[\"\
    >\"] = true\n        } else {\n            bracketPairs[char] = true\n       \
    \ }\n        bracketString += char\n    }\n    return bracketString.split(split:\
    \ \">\").count - bracketString.split(split: \"<\").count == bracketPairs.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfdh_s8i3.swift:23:26: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            bracketPairs[char] = true\n\
    \                         ^\n/tmp/tmpfdh_s8i3.swift:25:26: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n        bracketString\
    \ += char\n                         ^\n/tmp/tmpfdh_s8i3.swift:27:66: error: no\
    \ exact matches in call to instance method 'split'\n    return bracketString.split(split:\
    \ \">\").count - bracketString.split(split: \"<\").count == bracketPairs.count\n\
    \                                                                 ^\n/tmp/tmpfdh_s8i3.swift:27:66:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return bracketString.split(split:\
    \ \">\").count - bracketString.split(split: \"<\").count == bracketPairs.count\n\
    \                                                                 ^\n/tmp/tmpfdh_s8i3.swift:27:66:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    return bracketString.split(split:\
    \ \">\").count - bracketString.split(split: \"<\").count == bracketPairs.count\n\
    \                                                                 ^\n/tmp/tmpfdh_s8i3.swift:27:66:\
    \ note: candidate has partially matching parameter list (maxSplits: Int, omittingEmptySubsequences:\
    \ Bool, whereSeparator: (String.Element) throws -> Bool)\n    return bracketString.split(split:\
    \ \">\").count - bracketString.split(split: \"<\").count == bracketPairs.count\n\
    \                                                                 ^\n/tmp/tmpfdh_s8i3.swift:27:66:\
    \ note: candidate has partially matching parameter list (maxSplits: Int, omittingEmptySubsequences:\
    \ Bool, whereSeparator: (String.Element) throws -> Bool)\n    return bracketString.split(split:\
    \ \">\").count - bracketString.split(split: \"<\").count == bracketPairs.count\n\
    \                                                                 ^\n/tmp/tmpfdh_s8i3.swift:27:26:\
    \ err"
  stdout: ''
  timestamp: 1660009886
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return true\n    }\n    for openingChar :=\
    \ 0; openingChar < brackets.characters.count; openingChar += 1 {\n        if brackets[openingChar]\
    \ != brackets[openingChar+1] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpv8abd76i.swift:16:22: error: expected type\n    for openingChar\
    \ := 0; openingChar < brackets.characters.count; openingChar += 1 {\n        \
    \             ^\n                      <#type#>\n/tmp/tmpv8abd76i.swift:16:22:\
    \ error: expected 'in' after for-each pattern\n    for openingChar := 0; openingChar\
    \ < brackets.characters.count; openingChar += 1 {\n                     ^\n/tmp/tmpv8abd76i.swift:16:22:\
    \ error: expected Sequence expression for for-each loop\n    for openingChar :=\
    \ 0; openingChar < brackets.characters.count; openingChar += 1 {\n           \
    \          ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var count = 0\n    var i = 0\n    while i < brackets.characters.count {\n\
    \        if brackets.characters[i] == '<' {\n            count += 1\n        }\n\
    \        i += 1\n    }\n    while i < brackets.characters.count {\n        if\
    \ brackets.characters[i] == '>' {\n            count -= 1\n        }\n       \
    \ i += 1\n    }\n    return count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfo6n4973.swift:16:38: error: single-quoted string literal found,\
    \ use '\"'\n        if brackets.characters[i] == '<' {\n                     \
    \                ^~~\n                                     \"<\"\n/tmp/tmpfo6n4973.swift:22:38:\
    \ error: single-quoted string literal found, use '\"'\n        if brackets.characters[i]\
    \ == '>' {\n                                     ^~~\n                       \
    \              \">\"\n/tmp/tmpfo6n4973.swift:15:24: error: 'characters' is unavailable:\
    \ Please use String directly\n    while i < brackets.characters.count {\n    \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpfo6n4973.swift:16:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if brackets.characters[i]\
    \ == '<' {\n           ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfo6n4973.swift:16:21: error: 'characters'\
    \ is unavailable: Please use String directly\n        if brackets.characters[i]\
    \ == '<' {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpfo6n4973.swift:21:24: error: 'characters' is unavailable:\
    \ Please use String directly\n    while i < brackets.characters.count {\n    \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpfo6n4973.swift:22:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if brackets.characters[i]\
    \ == '>' {\n           ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfo6n4973.swift:22:21:"
  stdout: ''
  timestamp: 1660009883
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opens = brackets.split(separator: \"<\").map(String.init)\n    let closes\
    \ = brackets.split(separator: \">\").map(String.init)\n    return opens.count\
    \ == closes.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmpa367vd6u/tmpa367vd6u.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab895429c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab895120b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab895120988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab89511f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa367vd6u                        0x000055bb34f60843 <unavailable> + 6211

    5    libc.so.6                          0x00002ab895615460 __libc_start_main +
    245

    6    tmpa367vd6u                        0x000055bb34f60239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening_brackets = [String]()\n    for char in brackets {\n        switch\
    \ char {\n        case '<':\n            opening_brackets.append(char)\n     \
    \   case '>':\n            if opening_brackets.isEmpty {\n                return\
    \ false\n            }\n            let last = opening_brackets.removeLast()\n\
    \            if char == last {\n                return true\n            }\n \
    \       default:\n            return false\n        }\n    }\n    return opening_brackets.isEmpty\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxk58gyid.swift:16:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '<':\n             ^~~\n             \"<\"\n/tmp/tmpxk58gyid.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case '>':\n   \
    \          ^~~\n             \">\"\n/tmp/tmpxk58gyid.swift:17:37: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       opening_brackets.append(char)\n                                    ^\n\
    /tmp/tmpxk58gyid.swift:23:21: error: binary operator '==' cannot be applied to\
    \ operands of type 'Character' and 'String'\n            if char == last {\n \
    \              ~~~~ ^  ~~~~\n/tmp/tmpxk58gyid.swift:23:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n            if char == last {\n                    ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening = brackets[0]\n    var closing = brackets[0]\n    for openingIdx,\
    \ openingChar := range brackets {\n        if openingChar == '<' {\n         \
    \   if openingIdx == 0 {\n                opening = openingChar\n            }\
    \ else {\n                opening = brackets[openingIdx - 1]\n            }\n\
    \        }\n    }\n    for closingIdx, closingChar := range brackets {\n     \
    \   if closingChar == '>' {\n            if closingIdx == 0 {\n              \
    \  closing = closingChar\n            } else {\n                closing = brackets[closingIdx\
    \ - 1]\n            }\n        }\n    }\n    if opening != closing {\n       \
    \ return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmspaamcm.swift:15:19: error: expected 'in' after for-each pattern\n\
    \    for openingIdx, openingChar := range brackets {\n                  ^\n/tmp/tmpmspaamcm.swift:15:19:\
    \ error: expected Sequence expression for for-each loop\n    for openingIdx, openingChar\
    \ := range brackets {\n                  ^\n/tmp/tmpmspaamcm.swift:16:27: error:\
    \ single-quoted string literal found, use '\"'\n        if openingChar == '<'\
    \ {\n                          ^~~\n                          \"<\"\n/tmp/tmpmspaamcm.swift:24:19:\
    \ error: expected 'in' after for-each pattern\n    for closingIdx, closingChar\
    \ := range brackets {\n                  ^\n/tmp/tmpmspaamcm.swift:24:19: error:\
    \ expected Sequence expression for for-each loop\n    for closingIdx, closingChar\
    \ := range brackets {\n                  ^\n/tmp/tmpmspaamcm.swift:25:27: error:\
    \ single-quoted string literal found, use '\"'\n        if closingChar == '>'\
    \ {\n                          ^~~\n                          \">\"\n/tmp/tmpmspaamcm.swift:13:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    var opening = brackets[0]\n               \
    \   ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpmspaamcm.swift:14:19: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n    var closing\
    \ = brackets[0]\n                  ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    return brackets == strings.Replace(brackets, \"<<\", \">\", -1) &&\n\t\tbrackets\
    \ == strings.Replace(brackets, \">>\", \"<\", -1)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsqhmbdga.swift:13:21: error: cannot find 'strings' in scope\n \
    \       return brackets == strings.Replace(brackets, \"<<\", \">\", -1) &&\n \
    \                          ^~~~~~~\n/tmp/tmpsqhmbdga.swift:14:15: error: cannot\
    \ find 'strings' in scope\n                brackets == strings.Replace(brackets,\
    \ \">>\", \"<\", -1)\n                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Initialize to true because the first opening bracket should be closed\
    \ immediately after.\n    var openingBracketsClosed = true\n\n    // Iterate through\
    \ all brackets.\n    for bracket in brackets {\n        // Check if the closing\
    \ bracket is found within the next bracket.\n        for possibleClosingBracket\
    \ in brackets {\n            if bracket == possibleClosingBracket {\n        \
    \        // If this is the first opening bracket, immediately close it.\n    \
    \            if openingBracketsClosed {\n                    openingBracketsClosed\
    \ = false\n                } else {\n                    // If this is not the\
    \ first opening bracket, close it now.\n                    openingBracketsClosed\
    \ = false\n                }\n\n                // If we found a matching opening\
    \ bracket, break.\n                break\n            }\n        }\n\n       \
    \ // If we didn't find a matching opening bracket, add an opening bracket to our\
    \ boolean.\n        if openingBracketsClosed {\n            openingBracketsClosed\
    \ = true\n        }\n    }\n\n    // Return the boolean value.\n    return openingBracketsClosed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmpcfvfmvt_/tmpcfvfmvt_.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad9bf7bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad9bc72b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad9bc72988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad9bc717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcfvfmvt_                        0x0000558c5f3fb36b <unavailable> + 4971

    5    libc.so.6                          0x00002aad9c167460 __libc_start_main +
    245

    6    tmpcfvfmvt_                        0x0000558c5f3faff9 <unavailable> + 4089

    '
  stdout: ''
  timestamp: 1660009884
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \  var prevCharIsClosing = false\n  for ch in brackets {\n    if ch == \"<\" {\n\
    \      prevCharIsClosing = true\n    } else if ch == \">\" {\n      if prevCharIsClosing\
    \ {\n        return false\n      }\n      prevCharIsClosing = false\n    } else\
    \ {\n      return false\n    }\n  }\n  return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmp4aik9s0p/tmp4aik9s0p.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b792de66c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b792db5db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b792db5d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b792db5c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4aik9s0p                        0x000055e68db3740b <unavailable> + 5131

    5    libc.so.6                          0x00002b792e052460 __libc_start_main +
    245

    6    tmp4aik9s0p                        0x000055e68db37099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    let firstIndex = brackets.startIndex\n\tlet lastIndex = brackets.endIndex\n\t\
    if firstIndex == lastIndex {\n\t\treturn true\n\t}\n\n\tlet openingBracket = brackets[firstIndex]\n\
    \tif openingBracket == \"<\" {\n\t\tlet secondIndex = brackets.range(of: \"<\"\
    , options: .backwards)?.lowerBound\n\t\tif secondIndex == lastIndex { return true\
    \ }\n\t\tif brackets[secondIndex+1] != \">\" { return false }\n\t\treturn correct_bracketing(brackets:\
    \ brackets[secondIndex..<lastIndex])\n\t} else if openingBracket == \"<\" {\n\t\
    \tlet secondIndex = brackets.range(of: \"<\", options: .backwards)?.upperBound\n\
    \t\tif secondIndex == lastIndex { return true }\n\t\tif brackets[secondIndex-1]\
    \ != \">\" { return false }\n\t\treturn correct_bracketing(brackets: brackets[firstIndex..<secondIndex])\n\
    \t} else if openingBracket == \"<\" {\n\t\tlet secondIndex = brackets.range(of:\
    \ \"<\", options: .backwards)?.upperBound\n\t\tif secondIndex == lastIndex { return\
    \ true }\n\t\tif brackets[secondIndex+1] != \">\" { return false }\n\t\treturn\
    \ correct_bracketing(brackets: brackets[firstIndex..<secondIndex])\n\t}\n\treturn\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcmay5m0h.swift:21:67: error: type of expression is ambiguous without\
    \ more context\n                let secondIndex = brackets.range(of: \"<\", options:\
    \ .backwards)?.lowerBound\n                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpcmay5m0h.swift:24:47: error: subscript 'subscript(_:)' requires the types\
    \ 'String.Index' and 'Int' be equivalent\n                return correct_bracketing(brackets:\
    \ brackets[secondIndex..<lastIndex])\n                                       \
    \                     ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n\
    \    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n/tmp/tmpcmay5m0h.swift:26:67: error: type of expression\
    \ is ambiguous without more context\n                let secondIndex = brackets.range(of:\
    \ \"<\", options: .backwards)?.upperBound\n                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpcmay5m0h.swift:29:47: error: subscript 'subscript(_:)' requires the types\
    \ 'String.Index' and 'Int' be equivalent\n                return correct_bracketing(brackets:\
    \ brackets[firstIndex..<secondIndex])\n                                      \
    \                      ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n\
    \    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n/tmp/tmpcmay5m0h.swift:31:67: error: type of expression\
    \ is ambiguous without more context\n                let secondIndex = brackets.range(of:\
    \ \"<\", options: .backwards)?.upperBound\n                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpcmay5m0h.swift:34:47: error: subscript 'subscript(_:)' requires the types\
    \ 'String.Index' and 'Int' be equivalent\n                return correct_bracketing(brackets:\
    \ brackets[firstIndex..<secondIndex])\n                                      \
    \                      ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n\
    \    public subscript<R>(bounds"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let strings = brackets.characters\n        .flatMap { String($0) }\n    \
    \    .map { String(Character($0)) }\n\n    // Return false if any opening bracket\
    \ does not have a corresponding closing bracket.\n    for curChar in strings {\n\
    \        if curChar == \"<\" {\n            return false\n        }\n    }\n\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvqn73uxs.swift:13:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let strings = brackets.characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpvqn73uxs.swift:14:10: warning: 'flatMap' is deprecated: Please use compactMap(_:)\
    \ for the case where closure returns an optional value\n        .flatMap { String($0)\
    \ }\n         ^\n/tmp/tmpvqn73uxs.swift:14:10: note: use 'compactMap(_:)' instead\n\
    \        .flatMap { String($0) }\n         ^~~~~~~\n         compactMap\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var result = (brackets == \"<\" && brackets == \"<\") || (brackets == \"\
    <\" && brackets == \"<=\") ||\n        (brackets == \"<\" && brackets == \"=>\"\
    ) || (brackets == \"<\" && brackets == \"=>=\") ||\n        (brackets == \"<\"\
    \ && brackets == \"=><\") || (brackets == \"<\" && brackets == \"=>=>\") ||\n\
    \        (brackets == \"<\" && brackets == \"=>=>\") || (brackets == \"<\" &&\
    \ brackets == \"==>\") ||\n        (brackets == \"<\" && brackets == \"==>\")\
    \ || (brackets == \"<\" && brackets == \"===>\") ||\n        (brackets == \"<\"\
    \ && brackets == \"===>\") || (brackets == \"<\" && brackets == \"=>==\") ||\n\
    \        (brackets == \"<\" && brackets == \"=>==\") || (brackets == \"<\" &&\
    \ brackets == \"->\") ||\n        (brackets == \"<\" && brackets == \"->>\") ||\
    \ (brackets == \"<\" && brackets == \"->=\") ||\n        (brackets == \"<\" &&\
    \ brackets == \"->=>\") || (brackets == \"<\" && brackets == \"-=>\") ||\n   \
    \     (brackets == \"<\" && brackets == \"-=>\") || (brackets == \"<\" && brackets\
    \ == \"-=>=\") ||\n        (brackets == \"<\" && brackets == \"-=>=\") || (brackets\
    \ == \"<\" && brackets == \"-==\") ||\n        (brackets == \"<\" && brackets\
    \ == \"-==>\") || (brackets == \"<\" && brackets == \"-===>\") ||\n        (brackets\
    \ == \"<\" && brackets == \"-===>\") || (brackets == \"<\" && brackets == \"-=>==\"\
    ) ||\n        (brackets == \"<\" && brackets == \"-=>==\") || (brackets == \"\
    <\" && brackets == \"-=\") ||\n        (brackets == \"<\" && brackets == \"-->\"\
    ) || (brackets == \"<\" && brackets == \"-->>\") ||\n        (brackets == \"<\"\
    \ && brackets == \"-->=\") || (brackets == \"<\" && brackets == \"->\") ||\n \
    \       (brackets == \"<\" && brackets == \"->>\") || (brackets == \"<\" && brackets\
    \ == \"->=\") ||\n        (brackets == \"<\" && brackets == \"->=>\") || (brackets\
    \ == \"<\" && brackets == \"=>\") ||\n        (brackets == \"<\" && brackets ==\
    \ \"=>\") || (brackets == \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpglu_ugqi.swift:31:63: error: unterminated string literal\n    \
    \    (brackets == \"<\" && brackets == \"=>\") || (brackets == \"\n          \
    \                                                    ^\n/tmp/tmpglu_ugqi.swift:31:50:\
    \ error: cannot convert value of type '()' to expected argument type 'Bool'\n\
    \        (brackets == \"<\" && brackets == \"=>\") || (brackets == \"\n      \
    \                                           ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var lastOpeningBracket: Character\n    for openingBracket in brackets.characters\
    \ {\n        if lastOpeningBracket == nil {\n            lastOpeningBracket =\
    \ openingBracket\n        } else if openingBracket != lastOpeningBracket {\n \
    \           return false\n        }\n    }\n    return lastOpeningBracket == nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpl31m290h.swift:14:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    for openingBracket in brackets.characters {\n     \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpl31m290h.swift:15:31: warning: comparing non-optional\
    \ value of type 'Character' to 'nil' always returns false\n        if lastOpeningBracket\
    \ == nil {\n           ~~~~~~~~~~~~~~~~~~ ^  ~~~\n/tmp/tmpl31m290h.swift:21:31:\
    \ warning: comparing non-optional value of type 'Character' to 'nil' always returns\
    \ false\n    return lastOpeningBracket == nil\n           ~~~~~~~~~~~~~~~~~~ ^\
    \  ~~~\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBrackets = brackets.characters\n    var closingBrackets = brackets.characters\n\
    \    var openedBracket: String.Character\n    var closeBracket: String.Character\n\
    \    var isOpened: Bool\n    var isClosed: Bool\n    var isBadlyFormatted: Bool\n\
    \    var isNotClosed = false\n    let openBracketCount = brackets.count\n    let\
    \ closingBracketCount = brackets.count\n    for i in 0..<openBracketCount {\n\
    \        openedBracket = openingBrackets[i]\n        isOpened = openedBracket\
    \ == \"<\"\n        isClosed = openedBracket == \">\"\n        isBadlyFormatted\
    \ = isClosed || isBadlyFormatted(openBrackets, i)\n        if isBadlyFormatted\
    \ {\n            return false\n        }\n        if isOpened {\n            if\
    \ isClosed {\n                closingBrackets.remove(at: i)\n                closingBracketCount\
    \ -= 1\n            } else {\n                openingBrackets.remove(at: i)\n\
    \                openBracketCount -= 1\n            }\n        }\n    }\n    if\
    \ openBracketCount < closingBracketCount {\n        isNotClosed = true\n     \
    \   return false\n    }\n    if openBracketCount == 0 && isNotClosed {\n     \
    \   return true\n    }\n    if openBracketCount != closingBracketCount {\n   \
    \     return false\n    }\n    if isNotClosed {\n        return true\n    }\n\
    \    return isClosed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcaeppn__.swift:13:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    var openingBrackets = brackets.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpcaeppn__.swift:14:36: error: 'characters' is unavailable:\
    \ Please use String directly\n    var closingBrackets = brackets.characters\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpcaeppn__.swift:15:31: error: 'Character' is not a member\
    \ type of struct 'Swift.String'\n    var openedBracket: String.Character\n   \
    \                    ~~~~~~ ^\nSwift.String:1:23: note: 'String' declared here\n\
    @frozen public struct String {\n                      ^\n/tmp/tmpcaeppn__.swift:16:30:\
    \ error: 'Character' is not a member type of struct 'Swift.String'\n    var closeBracket:\
    \ String.Character\n                      ~~~~~~ ^\nSwift.String:1:23: note: 'String'\
    \ declared here\n@frozen public struct String {\n                      ^\n/tmp/tmpcaeppn__.swift:27:57:\
    \ error: cannot find 'openBrackets' in scope\n        isBadlyFormatted = isClosed\
    \ || isBadlyFormatted(openBrackets, i)\n                                     \
    \                   ^~~~~~~~~~~~\n/tmp/tmpcaeppn__.swift:27:40: error: cannot\
    \ call value of non-function type 'Bool'\n        isBadlyFormatted = isClosed\
    \ || isBadlyFormatted(openBrackets, i)\n                                     \
    \  ^\n/tmp/tmpcaeppn__.swift:33:44: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n                closingBrackets.remove(at:\
    \ i)\n                                           ^\n/tmp/tmpcaeppn__.swift:34:37:\
    \ error: left side of mutating operator isn't mutable: 'closingBracketCount' is\
    \ a 'let' constant\n                closingBracketCount -= 1\n               \
    \ ~~~~~~~~~~~~~~~~~~~ ^\n/tmp/tmpcaeppn__.swift:22:5: note: change 'let' to 'var'\
    \ to make"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    brackets = brackets.lowercased()\n\n    var stack = NSMutableArray(capacity:\
    \ brackets.count)\n    var result = false\n    var openingBrackets = 0 // count\
    \ number of opening brackets\n    var closingBrackets = 0 // count number of closing\
    \ brackets\n\n    for char in brackets.characters {\n        switch char {\n \
    \       case '<':\n            openingBrackets += 1\n            stack.addObject(char)\n\
    \        case '>':\n            if stack.count > 0 {\n                closingBrackets\
    \ += 1\n                if closingBrackets == openingBrackets {\n            \
    \        result =\n                        true\n                    stack.removeLast()\n\
    \                } else {\n                    stack.removeLast()\n          \
    \      }\n            } else {\n                result =\n                   \
    \ false\n            }\n            openingBrackets -= 1\n        }\n    }\n\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpaisjax0w.swift:22:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '<':\n             ^~~\n             \"<\"\n/tmp/tmpaisjax0w.swift:25:14:\
    \ error: single-quoted string literal found, use '\"'\n        case '>':\n   \
    \          ^~~\n             \">\"\n/tmp/tmpaisjax0w.swift:13:5: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n    brackets = brackets.lowercased()\n\
    \    ^~~~~~~~\n/tmp/tmpaisjax0w.swift:15:17: error: cannot find 'NSMutableArray'\
    \ in scope\n    var stack = NSMutableArray(capacity: brackets.count)\n       \
    \         ^~~~~~~~~~~~~~\n/tmp/tmpaisjax0w.swift:20:26: error: 'characters' is\
    \ unavailable: Please use String directly\n    for char in brackets.characters\
    \ {\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpaisjax0w.swift:21:9: error: switch must be exhaustive\n\
    \        switch char {\n        ^\n/tmp/tmpaisjax0w.swift:21:9: note: do you want\
    \ to add a default clause?\n        switch char {\n        ^\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openings = brackets.characters.split(separator: \"<\").filter({ $0.isEmpty\
    \ })\n    let closings = brackets.characters.split(separator: \">\").filter({\
    \ $0.isEmpty })\n    if openings.count != closings.count {\n        return false\n\
    \    }\n    for index in 0..<openings.count {\n        let opening = openings[index]\n\
    \        let closing = closings[index]\n        if opening.isEmpty != closing.isEmpty\
    \ {\n            return false\n        }\n        if opening.first != closing.last\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpx4rds9tx.swift:13:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    let openings = brackets.characters.split(separator:\
    \ \"<\").filter({ $0.isEmpty })\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpx4rds9tx.swift:14:29: error: 'characters'\
    \ is unavailable: Please use String directly\n    let closings = brackets.characters.split(separator:\
    \ \">\").filter({ $0.isEmpty })\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening = brackets[1...].count\n    var closing = brackets[0...1].count\n\
    \n    var result: Bool = false\n\n    if opening == closing {\n        result\
    \ = true\n    } else if opening > closing {\n        result = false\n    } else\
    \ {\n        result = true\n\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        for k <= closing {\n            if brackets[1...k] == brackets[0...k]\
    \ {\n                if brackets[1...k].count != opening {\n                 \
    \   result = false\n                    break\n                } else {\n    \
    \                i += 1\n                    k += 1\n                }\n     \
    \       } else {\n                result = false\n                break\n    \
    \        }\n        }\n\n        for j = 0 <= opening {\n            if brackets[0...j]\
    \ == brackets[1...closing] {\n                if brackets[0...j].count != closing\
    \ {\n                    result = false\n                    break\n         \
    \       } else {\n                    j += 1\n                    closing -= 1\n\
    \                }\n            } else {\n                result = false\n   \
    \             break\n            }\n        }\n    }\n\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmppb00on90.swift:28:15: error: expected 'in' after for-each pattern\n\
    \        for k <= closing {\n              ^\n/tmp/tmppb00on90.swift:28:15: error:\
    \ unary operator cannot be separated from its operand\n        for k <= closing\
    \ {\n              ^ ~\n                \n/tmp/tmppb00on90.swift:43:15: error:\
    \ expected 'in' after for-each pattern\n        for j = 0 <= opening {\n     \
    \         ^\n/tmp/tmppb00on90.swift:43:15: error: expected Sequence expression\
    \ for for-each loop\n        for j = 0 <= opening {\n              ^\n/tmp/tmppb00on90.swift:13:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    var opening = brackets[1...].count\n\
    \                  ^~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript<R>(bounds: R)\
    \ -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmppb00on90.swift:14:19: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n    var closing\
    \ = brackets[0...1].count\n                  ^~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmppb00on90.swift:28:15: error: '<=' is not a prefix\
    \ unary operator\n        for k <= closing {\n              ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())\n\
    \tbrackets = brackets.stringByReplacingOccurrencesOfString(\"<\", withString:\
    \ \"\", options: NSCaseInsensitiveSearch, range: nil)\n\tbrackets = brackets.stringByReplacingOccurrencesOfString(\"\
    >\", withString: \"\", options: NSCaseInsensitiveSearch, range: nil)\n\t\n\tlet\
    \ openingBrackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.openingAndClosingBrackets())\n\
    \tlet closingBrackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.closingBrackets())\n\
    \t\n\tlet openingBracketsCount = openingBrackets.count\n\tlet closingBracketsCount\
    \ = closingBrackets.count\n\t\n\treturn openingBracketsCount == closingBracketsCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6m4z_u7x.swift:13:54: error: cannot find 'NSCharacterSet' in scope\n\
    \        brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())\n\
    \                                                            ^~~~~~~~~~~~~~\n\
    /tmp/tmp6m4z_u7x.swift:13:2: error: cannot assign to value: 'brackets' is a 'let'\
    \ constant\n        brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())\n\
    \        ^~~~~~~~\n/tmp/tmp6m4z_u7x.swift:13:22: error: value of type 'String'\
    \ has no member 'stringByTrimmingCharactersInSet'\n        brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())\n\
    \                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6m4z_u7x.swift:14:89:\
    \ error: cannot find 'NSCaseInsensitiveSearch' in scope\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    <\", withString: \"\", options: NSCaseInsensitiveSearch, range: nil)\n       \
    \                                                                            \
    \            ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6m4z_u7x.swift:14:2: error: cannot\
    \ assign to value: 'brackets' is a 'let' constant\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    <\", withString: \"\", options: NSCaseInsensitiveSearch, range: nil)\n       \
    \ ^~~~~~~~\n/tmp/tmp6m4z_u7x.swift:14:22: error: value of type 'String' has no\
    \ member 'stringByReplacingOccurrencesOfString'\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    <\", withString: \"\", options: NSCaseInsensitiveSearch, range: nil)\n       \
    \            ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6m4z_u7x.swift:14:121:\
    \ error: 'nil' requires a contextual type\n        brackets = brackets.stringByReplacingOccurrencesOfString(\"\
    <\", withString: \"\", options: NSCaseInsensitiveSearch, range: nil)\n       \
    \                                                                            \
    \                                            ^\n/tmp/tmp6m4z_u7x.swift:15:89:\
    \ error: cannot find 'NSCaseInsensitiveSearch' in scope\n        brackets ="
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty() {\n        return true\n    }\n\n    var openingBrackets\
    \ = brackets.characters\n    var closingBrackets = \"\"\n    var hasClosingBrackets\
    \ = false\n    var hasOpeningBrackets = false\n\n    if brackets.characters.count\
    \ == 1 {\n        hasClosingBrackets = true\n        closingBrackets = brackets.characters.first!\n\
    \    }\n\n    if hasClosingBrackets {\n        openingBrackets.removeLast()\n\
    \        hasOpeningBrackets = true\n    }\n\n    if openingBrackets.isEmpty()\
    \ {\n        return false\n    }\n\n    guard let lastOpeningBracket = openingBrackets.last\
    \ else {\n        return false\n    }\n\n    guard lastOpeningBracket == \"<\"\
    \ || lastOpeningBracket == \"<<\" else {\n        return false\n    }\n\n    let\
    \ nextClosingBracket = openingBrackets.first!\n    guard nextClosingBracket ==\
    \ \">\" || nextClosingBracket == \">>\" else {\n        return false\n    }\n\n\
    \    openingBrackets.removeFirst()\n\n    if openingBrackets.isEmpty() {\n   \
    \     return false\n    }\n\n    return !hasOpeningBrackets\n        && !hasClosingBrackets\n\
    \        && openingBrackets.count == 1\n        && closingBrackets.count == 1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpyea3cjsn.swift:13:17: error: cannot call value of non-function\
    \ type 'Bool'\n    if brackets.isEmpty() {\n                ^      ~~\n      \
    \                 \n/tmp/tmpyea3cjsn.swift:17:36: error: 'characters' is unavailable:\
    \ Please use String directly\n    var openingBrackets = brackets.characters\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpyea3cjsn.swift:22:17: error: 'characters' is unavailable:\
    \ Please use String directly\n    if brackets.characters.count == 1 {\n      \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpyea3cjsn.swift:24:52: error: cannot assign value of type 'String.Element'\
    \ (aka 'Character') to type 'String'\n        closingBrackets = brackets.characters.first!\n\
    \                          ~~~~~~~~~~~~~~~~~~~~~~~~~^\n/tmp/tmpyea3cjsn.swift:32:24:\
    \ error: cannot call value of non-function type 'Bool'\n    if openingBrackets.isEmpty()\
    \ {\n                       ^      ~~\n                              \n/tmp/tmpyea3cjsn.swift:40:59:\
    \ error: binary operator '==' cannot be applied to operands of type 'String.Element'\
    \ (aka 'Character') and 'String'\n    guard lastOpeningBracket == \"<\" || lastOpeningBracket\
    \ == \"<<\" else {\n                                       ~~~~~~~~~~~~~~~~~~\
    \ ^  ~~~~\n/tmp/tmpyea3cjsn.swift:40:59: note: overloads for '==' exist with these\
    \ partially matching parameter lists: (Character, Character), (String, String)\n\
    \    guard lastOpeningBracket == \"<\" || lastOpeningBracket == \"<<\" else {\n\
    \                                                          ^\n/tmp/tmpyea3cjsn.swift:45:59:\
    \ error: binary operator '==' cannot be applied to operands of type 'String.Element'\
    \ (aka 'Character') and 'String'\n    guard nextClosingBracket == \">\" || nextClosingBracket\
    \ == \">>\" else {\n                                       ~~~~~~~~~~~~~~~~~~\
    \ ^  ~~~~\n/tmp/tmpyea3cjsn.swift:45:59: not"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openings = brackets.count(\"<\")\n    let closings = brackets.count(\"\
    <>\") - openings\n    if openings == 0 || closings == 0 {\n        return false\n\
    \    }\n    for index in 0..<openings {\n        if brackets[index] != brackets[index+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpw8q45h5f.swift:13:29: error: cannot call value of non-function\
    \ type 'Int'\n    let openings = brackets.count(\"<\")\n                     \
    \       ^\n/tmp/tmpw8q45h5f.swift:14:29: error: cannot call value of non-function\
    \ type 'Int'\n    let closings = brackets.count(\"<>\") - openings\n         \
    \                   ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \  var last = 0\n  for index := 0; index < brackets.characters.count; index++\
    \ {\n    let current = brackets.characters[index]\n    guard last! < index else\
    \ { return false }\n    if current != \"<\" { return false }\n    if brackets.characters[index+1\
    \ : index+3] != \">>\" { return false }\n    last++\n  }\n  return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpaullvyld.swift:14:14: error: expected type\n  for index := 0; index\
    \ < brackets.characters.count; index++ {\n             ^\n              <#type#>\n\
    /tmp/tmpaullvyld.swift:14:14: error: expected 'in' after for-each pattern\n  for\
    \ index := 0; index < brackets.characters.count; index++ {\n             ^\n/tmp/tmpaullvyld.swift:14:14:\
    \ error: expected Sequence expression for for-each loop\n  for index := 0; index\
    \ < brackets.characters.count; index++ {\n             ^\n/tmp/tmpaullvyld.swift:18:36:\
    \ error: expected ',' separator\n    if brackets.characters[index+1 : index+3]\
    \ != \">>\" { return false }\n                                   ^\n         \
    \                         ,\n/tmp/tmpaullvyld.swift:18:36: error: expected expression\
    \ in list of expressions\n    if brackets.characters[index+1 : index+3] != \"\
    >>\" { return false }\n                                   ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // make sure to include the last character in the array\n    let chars =\
    \ brackets.characters.suffix(from: brackets.endIndex)\n    var openingBrackets:\
    \ [String] = []\n    var closingBrackets: [String] = []\n    for char in chars\
    \ {\n        guard let openingBracket = openingBrackets[chars.index(of: char)]\
    \ else {\n            openingBrackets.append(char)\n            closingBrackets.append(char)\n\
    \            continue\n        }\n        guard let closingBracket = closingBrackets[chars.index(of:\
    \ char)] else {\n            // the opening brackets didn't have corresponding\
    \ closing brackets\n            return false\n        }\n        // both brackets\
    \ are open, they're both the same type\n        if openingBracket != closingBracket\
    \ {\n            return false\n        }\n        // close the current openingBracket\n\
    \        openingBrackets.removeLast()\n        closingBrackets.removeLast()\n\
    \    }\n    return openingBrackets.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp58p8hryx.swift:14:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = brackets.characters.suffix(from: brackets.endIndex)\n\
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp58p8hryx.swift:18:51: error: no exact matches in call to\
    \ subscript \n        guard let openingBracket = openingBrackets[chars.index(of:\
    \ char)] else {\n                                                  ^\nSwift.Array:16:23:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Substring.Index?'\
    \ (aka 'Optional<String.Index>'))\n    @inlinable public subscript(index: Int)\
    \ -> Element { get set }\n                      ^\nSwift.Array:17:23: note: candidate\
    \ expects value of type 'Range<Int>' for parameter #1 (got 'Substring.Index?'\
    \ (aka 'Optional<String.Index>'))\n    @inlinable public subscript(bounds: Range<Int>)\
    \ -> ArraySlice<Element> { get set }\n                      ^\n/tmp/tmp58p8hryx.swift:18:51:\
    \ note: found candidate with type '(Substring.Index) -> ArraySlice<String>' (aka\
    \ '(String.Index) -> ArraySlice<String>')\n        guard let openingBracket =\
    \ openingBrackets[chars.index(of: char)] else {\n                            \
    \                      ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Substring.Index?' (aka\
    \ 'Optional<String.Index>'))\n    @inlinable public subscript(x: (UnboundedRange_)\
    \ -> ()) -> Self.SubSequence { get }\n                      ^\n/tmp/tmp58p8hryx.swift:18:51:\
    \ note: found candidate with type '(Substring.Index) -> @lvalue ArraySlice<String>'\
    \ (aka '(String.Index) -> @lvalue ArraySlice<String>')\n        guard let openingBracket\
    \ = openingBrackets[chars.index(of: char)] else {\n                          \
    \                        ^\nSwift.MutableCollection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Substring.Index?'\
    \ (aka 'Optional<String.Index>'))\n    @inlinable"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var result: Bool = true\n    for opening in brackets.characters {\n     \
    \   if !opening_closing_pairs.contains(opening) {\n            result = false\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpav9xqvhh.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for opening in brackets.characters {\n            \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpav9xqvhh.swift:15:13: error: cannot find 'opening_closing_pairs'\
    \ in scope\n        if !opening_closing_pairs.contains(opening) {\n          \
    \  ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openBrackets = brackets.characters\n    var openBracketIndex = brackets.startIndex\n\
    \    var closeBracketIndex = 0\n    let openBracketIndexEnd = brackets.endIndex\n\
    \    var openBracketCount = 0\n    var closeBracketCount = 0\n    var startIndex\
    \ = 0\n    var endIndex = 0\n    var isBracketOpen = false\n    while openBracketIndex\
    \ < openBracketIndexEnd {\n        if openBrackets[openBracketIndex] == \">\"\
    \ {\n            if openBracketCount > 1 {\n                return false\n   \
    \         }\n            if openBracketIndex == openBracketIndexEnd {\n      \
    \          return false\n            }\n            if closeBracketIndex < openBracketIndex\
    \ {\n                closeBracketIndex++\n                closeBracketCount++\n\
    \            }\n        }\n        else if openBrackets[openBracketIndex] == \"\
    <\" {\n            if openBracketCount > 0 {\n                return false\n \
    \           }\n            if openBracketIndex == openBracketIndexEnd {\n    \
    \            return false\n            }\n            if closeBracketIndex < openBracketIndex\
    \ {\n                closeBracketIndex++\n                closeBracketCount++\n\
    \            }\n        }\n        else if openBrackets[openBracketIndex] == '>'\
    \ {\n            if openBracketCount == 0 {\n                openBracketCount++\n\
    \            }\n            else {\n                openBracketCount--\n     \
    \       }\n            if openBracketCount == 0 {\n                openBracketIndex++\n\
    \                openBracketCount = 0\n            }\n        }\n        else\
    \ if openBrackets[openBracketIndex] == '<' {\n            if openBracketCount\
    \ == 0 {\n                openBracketCount++\n            }\n            else\
    \ {\n                openBracketCount--\n            }\n            if openBracketCount\
    \ == 0 {\n                openBracketIndex++\n                openBracketCount\
    \ = 0\n            }\n        }\n        else if openBrackets[openBracketIndex]\
    \ == '(' ||\n            openBrackets[openBracketIndex] == ')' ||\n          \
    \  openBrackets[openBracketIndex] == '[' ||\n            openBrackets[openBracketIndex]\
    \ == ']' ||\n            openBrackets[openBracketIndex] == '{' ||\n          \
    \  openBrackets[openBracketIndex] == '}' ||\n            openBrackets[openBracketIndex]\
    \ == '.' {\n            if openBracketCount != 0 {\n                return false\n\
    \            }\n            if openBracketIndex == openBracketIndexEnd {\n   \
    \             return false\n            }\n            if closeBracketIndex <\
    \ openBracketIndex {\n                close\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_y2pov4w.swift:47:51: error: single-quoted string literal found,\
    \ use '\"'\n        else if openBrackets[openBracketIndex] == '>' {\n        \
    \                                          ^~~\n                             \
    \                     \">\"\n/tmp/tmp_y2pov4w.swift:59:51: error: single-quoted\
    \ string literal found, use '\"'\n        else if openBrackets[openBracketIndex]\
    \ == '<' {\n                                                  ^~~\n          \
    \                                        \"<\"\n/tmp/tmp_y2pov4w.swift:71:51:\
    \ error: single-quoted string literal found, use '\"'\n        else if openBrackets[openBracketIndex]\
    \ == '(' ||\n                                                  ^~~\n         \
    \                                         \"(\"\n/tmp/tmp_y2pov4w.swift:72:47:\
    \ error: single-quoted string literal found, use '\"'\n            openBrackets[openBracketIndex]\
    \ == ')' ||\n                                              ^~~\n             \
    \                                 \")\"\n/tmp/tmp_y2pov4w.swift:73:47: error:\
    \ single-quoted string literal found, use '\"'\n            openBrackets[openBracketIndex]\
    \ == '[' ||\n                                              ^~~\n             \
    \                                 \"[\"\n/tmp/tmp_y2pov4w.swift:74:47: error:\
    \ single-quoted string literal found, use '\"'\n            openBrackets[openBracketIndex]\
    \ == ']' ||\n                                              ^~~\n             \
    \                                 \"]\"\n/tmp/tmp_y2pov4w.swift:75:47: error:\
    \ single-quoted string literal found, use '\"'\n            openBrackets[openBracketIndex]\
    \ == '{' ||\n                                              ^~~\n             \
    \                                 \"{\"\n/tmp/tmp_y2pov4w.swift:76:47: error:\
    \ single-quoted string literal found, use '\"'\n            openBrackets[openBracketIndex]\
    \ == '}' ||\n                                              ^~~\n             \
    \                                 \"}\"\n/tmp/tmp_y2pov4w.swift:77:47: error:\
    \ single-quoted string literal found, use '\"'\n            openBrackets[openBracketIndex]\
    \ == '.' {\n         "
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var brackets = brackets.characters\n    if brackets.isEmpty {\n        return\
    \ true\n    }\n    var lastIndex = brackets.startIndex\n    for bracketIndex in\n\
    \        0..<brackets.count {\n        let bracket = brackets[bracketIndex]\n\
    \        if bracket != brackets[bracketIndex] {\n            lastIndex = bracketIndex\n\
    \        } else {\n            let nextBracket = brackets[bracketIndex + 1]\n\
    \            if nextBracket != brackets[bracketIndex + 2] {\n                lastIndex\
    \ = bracketIndex\n            }\n        }\n    }\n    brackets[lastIndex] = brackets.endIndex\n\
    \    var hasMatchingCloser = false\n    for bracketIndex in\n        0..<brackets.count\
    \ {\n        let bracket = brackets[bracketIndex]\n        if bracket != brackets[bracketIndex]\
    \ {\n            hasMatchingCloser = true\n            break\n        } else {\n\
    \            let nextBracket = brackets[bracketIndex + 1]\n            if nextBracket\
    \ != brackets[bracketIndex + 2] {\n                hasMatchingCloser = true\n\
    \                break\n            }\n        }\n    }\n    return !hasMatchingCloser\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpig79ucfr.swift:13:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    var brackets = brackets.characters\n              \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpig79ucfr.swift:20:23: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let bracket\
    \ = brackets[bracketIndex]\n                      ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpig79ucfr.swift:21:23:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if bracket != brackets[bracketIndex] {\n\
    \                      ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpig79ucfr.swift:22:25: error: cannot\
    \ assign value of type 'Int' to type 'String.Index'\n            lastIndex = bracketIndex\n\
    \                        ^~~~~~~~~~~~\n/tmp/tmpig79ucfr.swift:24:31: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            let nextBracket = brackets[bracketIndex + 1]\n                  \
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpig79ucfr.swift:25:31: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if nextBracket != brackets[bracketIndex + 2] {\n                \
    \              ^~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpig79ucfr.swift:26:29: error: cann"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack = [String]()\n    var opening = brackets[0]\n    var closing =\
    \ brackets[0]\n    for character in brackets {\n        if character == opening\
    \ {\n            if stack.isEmpty {\n                return false\n          \
    \  }\n            stack.remove(at: stack.endIndex)\n        } else {\n       \
    \     if stack.contains(where: { $0 == \"<\" } ) {\n                return false\n\
    \            }\n            stack.append(character)\n        }\n    }\n    if\
    \ stack.contains(where: { $0 == opening } ) {\n        return false\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmppu4bnmje.swift:14:19: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var opening =\
    \ brackets[0]\n                  ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmppu4bnmje.swift:15:19: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    var closing = brackets[0]\n                  ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmppu4bnmje.swift:26:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(character)\n                         ^\n/tmp/tmppu4bnmje.swift:29:35:\
    \ error: binary operator '==' cannot be applied to operands of type 'String' and\
    \ 'Character'\n    if stack.contains(where: { $0 == opening } ) {\n          \
    \                     ~~ ^  ~~~~~~~\n/tmp/tmppu4bnmje.swift:29:35: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n    if stack.contains(where: { $0 == opening } ) {\n     \
    \                             ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let firstOpening = brackets.rangeOfString(\"<\")\n    let lastClosing = brackets.rangeOfString(\"\
    >\")\n    if firstOpening == nil || lastClosing == nil {\n        return false\n\
    \    }\n    var bracketCount = 1\n    while firstOpening.location != lastClosing.location\
    \ {\n        if bracketCount > 10 {\n            return false\n        }\n   \
    \     let openingBracket = brackets[firstOpening.location + 1]\n        let closingBracket\
    \ = brackets[lastClosing.location - 1]\n        if openingBracket != \"<\" ||\
    \ closingBracket != \">\" {\n            return false\n        }\n        bracketCount++\n\
    \        firstOpening = brackets.rangeOfString(\"<\", options: .BackwardsSearch)\n\
    \        lastClosing = brackets.rangeOfString(\">\", options: .BackwardsSearch)\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpe7xocnnp.swift:13:33: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    let firstOpening = brackets.rangeOfString(\"<\")\n    \
    \                   ~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpe7xocnnp.swift:14:32: error:\
    \ value of type 'String' has no member 'rangeOfString'\n    let lastClosing =\
    \ brackets.rangeOfString(\">\")\n                      ~~~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpe7xocnnp.swift:28:21: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        bracketCount++\n                    ^~\n/tmp/tmpe7xocnnp.swift:29:33:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        firstOpening\
    \ = brackets.rangeOfString(\"<\", options: .BackwardsSearch)\n               \
    \        ~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpe7xocnnp.swift:29:62: error: cannot infer\
    \ contextual base in reference to member 'BackwardsSearch'\n        firstOpening\
    \ = brackets.rangeOfString(\"<\", options: .BackwardsSearch)\n               \
    \                                             ~^~~~~~~~~~~~~~~\n/tmp/tmpe7xocnnp.swift:30:32:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        lastClosing\
    \ = brackets.rangeOfString(\">\", options: .BackwardsSearch)\n               \
    \       ~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpe7xocnnp.swift:30:61: error: cannot infer\
    \ contextual base in reference to member 'BackwardsSearch'\n        lastClosing\
    \ = brackets.rangeOfString(\">\", options: .BackwardsSearch)\n               \
    \                                            ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    if brackets.count < 3 { return false }\n\t\n\topen := brackets[0..<brackets.count]\n\
    \tclose := brackets[1..<brackets.count]\n\t\n\tfor _, char := range open {\n\t\
    \tif !contains(close, char) {\n\t\t\treturn false\n\t\t}\n\t}\n\t\n\treturn true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpv78x8jb_.swift:15:6: error: consecutive statements on a line must\
    \ be separated by ';'\n        open := brackets[0..<brackets.count]\n        \
    \    ^\n            ;\n/tmp/tmpv78x8jb_.swift:15:7: error: expected expression\n\
    \        open := brackets[0..<brackets.count]\n             ^\n/tmp/tmpv78x8jb_.swift:18:7:\
    \ error: expected 'in' after for-each pattern\n        for _, char := range open\
    \ {\n             ^\n/tmp/tmpv78x8jb_.swift:18:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, char := range open {\n             ^\n/tmp/tmpv78x8jb_.swift:15:2:\
    \ error: cannot find 'open' in scope\n        open := brackets[0..<brackets.count]\n\
    \        ^~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let reversed = brackets[characters.reversed().startIndex..<brackets.endIndex]\n\
    \    let openings = reversed\n        .split(separator: \"<>\")\n        .map\
    \ {\n            String($0.characters.dropFirst())\n        }\n        .filter\
    \ { $0.characters.count == 1 }\n    let closings = reversed\n        .split(separator:\
    \ \"<>\")\n        .map {\n            String($0.characters.dropLast())\n    \
    \    }\n        .filter { $0.characters.count == 1 }\n\n    return openings.count\
    \ == closings.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3cu3mbky.swift:13:29: error: cannot find 'characters' in scope\n\
    \    let reversed = brackets[characters.reversed().startIndex..<brackets.endIndex]\n\
    \                            ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009890
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketCounts = [Int]()\n    for s in brackets {\n        var i = 0\n\
    \        while i < s.characters.count && s[i] != '<' {\n            i += 1\n \
    \       }\n        if i >= s.characters.count {\n            return false\n  \
    \      }\n        var j = i\n        while j < s.characters.count && s[j] != '>'\
    \ {\n            j += 1\n        }\n        i += j - 1\n        bracketCounts.append(j)\n\
    \    }\n    for _, count in bracketCounts.reverse() {\n        if count < 1 {\n\
    \            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmplbbymo3a.swift:16:49: error: single-quoted string literal found,\
    \ use '\"'\n        while i < s.characters.count && s[i] != '<' {\n          \
    \                                      ^~~\n                                 \
    \               \"<\"\n/tmp/tmplbbymo3a.swift:23:49: error: single-quoted string\
    \ literal found, use '\"'\n        while j < s.characters.count && s[j] != '>'\
    \ {\n                                                ^~~\n                   \
    \                             \">\"\n/tmp/tmplbbymo3a.swift:29:10: error: expected\
    \ 'in' after for-each pattern\n    for _, count in bracketCounts.reverse() {\n\
    \         ^\n/tmp/tmplbbymo3a.swift:29:10: error: expected Sequence expression\
    \ for for-each loop\n    for _, count in bracketCounts.reverse() {\n         ^\n\
    /tmp/tmplbbymo3a.swift:16:21: error: value of type 'Character' has no member 'characters'\n\
    \        while i < s.characters.count && s[i] != '<' {\n                  ~ ^~~~~~~~~~\n\
    /tmp/tmplbbymo3a.swift:16:42: error: value of type 'Character' has no subscripts\n\
    \        while i < s.characters.count && s[i] != '<' {\n                     \
    \                   ~^\n/tmp/tmplbbymo3a.swift:19:19: error: value of type 'Character'\
    \ has no member 'characters'\n        if i >= s.characters.count {\n         \
    \       ~ ^~~~~~~~~~\n/tmp/tmplbbymo3a.swift:23:21: error: value of type 'Character'\
    \ has no member 'characters'\n        while j < s.characters.count && s[j] !=\
    \ '>' {\n                  ~ ^~~~~~~~~~\n/tmp/tmplbbymo3a.swift:23:42: error:\
    \ value of type 'Character' has no subscripts\n        while j < s.characters.count\
    \ && s[j] != '>' {\n                                        ~^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openings = brackets.components(separatedBy: \">\")\n    let closings\
    \ = brackets.components(separatedBy: \"<\")\n    \n    if openings.count != closings.count\
    \ {\n        return false\n    }\n    \n    var isCorrect : Bool = true\n    for\
    \ openingIndex in 0..<openings.count {\n        for closingIndex in 0..<closings.count\
    \ {\n            if openings[openingIndex] == closings[closingIndex] {\n     \
    \           isCorrect = false\n                break\n            }\n        }\n\
    \    }\n    return isCorrect\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpji45lsml.swift:13:29: error: value of type 'String' has no member\
    \ 'components'\n    let openings = brackets.components(separatedBy: \">\")\n \
    \                  ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpji45lsml.swift:14:29: error: value\
    \ of type 'String' has no member 'components'\n    let closings = brackets.components(separatedBy:\
    \ \"<\")\n                   ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let ranges: [(Range<Index>, Range<Index>)] = brackets.split(separator: \"\
    <\").map {\n        let firstRange = NSRange()\n        guard let firstIndex =\
    \ self.text.index(start: self.text.startIndex.advanced(by: 0)) else {\n      \
    \      return firstRange\n        }\n\n        let firstChar = self.text[index]\n\
    \        let lastChar = self.text[index.advanced(by: 1)]\n        guard firstChar\
    \ != \"<\" else { return firstRange }\n        guard lastChar != \">\" else {\
    \ return firstRange }\n        guard let secondIndex = self.text.index(start:\
    \ self.text.index(before: index).advanced(by: 1)) else {\n            return firstRange\n\
    \        }\n\n        let secondChar = self.text[index[index]]\n        guard\
    \ secondChar != \">\" else { return firstRange }\n\n        let firstCharIndex:\
    \ Int = firstIndex.advanced(by: 0)\n        let secondCharIndex: Int = secondIndex.advanced(by:\
    \ 0)\n        let openingRange = firstCharIndex..<secondCharIndex\n        let\
    \ closingRange = firstCharIndex..<secondCharIndex.advanced(by: -1)\n\n       \
    \ return closingRange ~= firstRange.lowerBound\n    }\n\n    let firstRange =\
    \ ranges.first!.0\n    let secondRange = ranges.last!.0\n    guard let firstIndex\
    \ = self.text.index(start: self.text.index(before: firstRange.lowerBound)) else\
    \ {\n        return false\n    }\n\n    guard let secondIndex = self.text.index(start:\
    \ self.text.index(before: secondRange.upperBound)) else {\n        return false\n\
    \    }\n\n    if let lastRange = ranges.last?.1 {\n        guard self.text[firstIndex.advanced(by:\
    \ lastRange.upperBound.advanced(by: -1)) != \">\" else {\n            return false\n\
    \        }\n    }\n\n    if firstRange.lowerBound == secondRange.lowerBound {\n\
    \        return true\n    }\n\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpaso_uwk4.swift:49:95: error: expected ',' separator\n        guard\
    \ self.text[firstIndex.advanced(by: lastRange.upperBound.advanced(by: -1)) !=\
    \ \">\" else {\n                                                             \
    \                                 ^\n                                        \
    \                                                     ,\n/tmp/tmpaso_uwk4.swift:49:95:\
    \ error: expected expression in list of expressions\n        guard self.text[firstIndex.advanced(by:\
    \ lastRange.upperBound.advanced(by: -1)) != \">\" else {\n                   \
    \                                                                           ^\n\
    /tmp/tmpaso_uwk4.swift:13:25: error: cannot find type 'Index' in scope\n    let\
    \ ranges: [(Range<Index>, Range<Index>)] = brackets.split(separator: \"<\").map\
    \ {\n                        ^~~~~\n/tmp/tmpaso_uwk4.swift:13:39: error: cannot\
    \ find type 'Index' in scope\n    let ranges: [(Range<Index>, Range<Index>)] =\
    \ brackets.split(separator: \"<\").map {\n                                   \
    \   ^~~~~\n/tmp/tmpaso_uwk4.swift:40:28: error: cannot find 'self' in scope; did\
    \ you mean to use it in a type or extension context?\n    guard let firstIndex\
    \ = self.text.index(start: self.text.index(before: firstRange.lowerBound)) else\
    \ {\n                           ^~~~\n/tmp/tmpaso_uwk4.swift:40:51: error: cannot\
    \ find 'self' in scope; did you mean to use it in a type or extension context?\n\
    \    guard let firstIndex = self.text.index(start: self.text.index(before: firstRange.lowerBound))\
    \ else {\n                                                  ^~~~\n/tmp/tmpaso_uwk4.swift:44:29:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n    guard let secondIndex = self.text.index(start: self.text.index(before:\
    \ secondRange.upperBound)) else {\n                            ^~~~\n/tmp/tmpaso_uwk4.swift:44:52:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n    guard let secondIndex = self.text.index(start: self.text.index(before:\
    \ secondRange.upperBound)) else {\n   "
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = brackets.characters\n    guard let openingBrackets = stack.prefix(while:\
    \ { $0 != \">\" }) else {\n        return true\n    }\n\n    guard let closingBrackets\
    \ = stack.suffix(while: { $0 != \"<\" }) else {\n        return false\n    }\n\
    \n    // If opening brackets contains only closing brackets then it's wrong\n\
    \    if openingBrackets.count != closingBrackets.count {\n        return false\n\
    \    }\n\n    // If there are too many closing brackets, it's wrong\n    if openingBrackets.count\
    \ > 2 {\n        return false\n    }\n\n    // If there are too many opening brackets,\
    \ it's wrong\n    if closingBrackets.count > 2 {\n        return false\n    }\n\
    \n    // If there are too few opening brackets, it's wrong\n    if openingBrackets.count\
    \ < 2 {\n        return false\n    }\n\n    // If there are too few closing brackets,\
    \ it's wrong\n    if closingBrackets.count < 2 {\n        return false\n    }\n\
    \n    // If there are 2 or more brackets in a row, the brackets are not correct.\n\
    \    // e.g. \"<><>\" -> <><> -> <><> -> <>\n    if stack.last == \">\" && stack.last\
    \ == \"<\" {\n        return false\n    }\n\n    // If there is an opening bracket\
    \ followed by an opening bracket or an opening bracket followed by an closing\
    \ bracket, the brackets are not correct.\n    // e.g. \"<>\" -> <><> -> <><> ->\
    \ <><> -> <>\n    if stack.last == \">\" && stack.last == \"<\" || stack.last\
    \ == \"<\" && stack.last == \">\" {\n        return false\n    }\n\n    // If\
    \ there is an opening bracket followed by an opening bracket followed by an opening\
    \ bracket followed by an opening bracket, the brackets are not correct.\n    //\
    \ e.g. \"<>\" -> <><> -> <><> -> <><> -> <>\n    if stack.last == \">\" && stack.last\
    \ == \"<\" || stack.last == \"<\" && stack.last == \"<\" && stack.last == \">\"\
    \ {\n        return false\n    }\n\n    // If there is an opening bracket followed\
    \ by an opening bracket followed by an opening bracket followed by an opening\
    \ bracket followed by an opening bracket, the brackets are not correct.\n    //\
    \ e.g. \"<>\" -> <><> -> <><> -> <><> -> <>\n    if stack.last == \">\" && stack.last\
    \ == \"<\" || stack.last == \"<\" && stack.last == \"<\" && stack.last == \"<\"\
    \ && stack.last == \">\" {\n        return false\n    }\n\n    // If there is\
    \ an opening bracket followed by an opening bracket followed by an opening bracket\
    \ followed by an opening bracket followed by an \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2gusnc4_.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let stack = brackets.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp2gusnc4_.swift:14:11:\
    \ error: initializer for conditional binding must have Optional type, not 'String.SubSequence'\
    \ (aka 'Substring')\n    guard let openingBrackets = stack.prefix(while: { $0\
    \ != \">\" }) else {\n          ^                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2gusnc4_.swift:18:39: error: no exact matches in call to instance method\
    \ 'suffix'\n    guard let closingBrackets = stack.suffix(while: { $0 != \"<\"\
    \ }) else {\n                                      ^\n/tmp/tmp2gusnc4_.swift:18:39:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got '(String)\
    \ -> Bool')\n    guard let closingBrackets = stack.suffix(while: { $0 != \"<\"\
    \ }) else {\n                                      ^\n/tmp/tmp2gusnc4_.swift:18:39:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got '(String)\
    \ -> Bool')\n    guard let closingBrackets = stack.suffix(while: { $0 != \"<\"\
    \ }) else {\n                                      ^\n/tmp/tmp2gusnc4_.swift:18:39:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got '(String)\
    \ -> Bool')\n    guard let closingBrackets = stack.suffix(while: { $0 != \"<\"\
    \ }) else {\n                                      ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    return brackets[brackets.startIndex] == \"<\" && brackets[brackets.endIndex-1]\
    \ == \">\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpwhsquzc4.swift:13:70: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    return brackets[brackets.startIndex] ==\
    \ \"<\" && brackets[brackets.endIndex-1] == \">\"\n                          \
    \                                           ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.characters.count == 0 {\n        return true\n    }\n\n    let\
    \ openingBrackets: [String] = brackets.components(separatedBy: \">\")\n    let\
    \ closingBrackets: [String] = brackets.components(separatedBy: \"<\")\n\n    if\
    \ openingBrackets.count != closingBrackets.count {\n        return false\n   \
    \ }\n\n    for i in 0..<openingBrackets.count {\n        let openingBracket =\
    \ openingBrackets[i]\n        let closingBracket = closingBrackets[i]\n\n    \
    \    if openingBracket == \"<\" || openingBracket == \"{\" || openingBracket ==\
    \ \"[\" {\n            if closingBracket == \">\" || closingBracket == \"}\" ||\
    \ closingBracket == \"]\" {\n                continue\n            } else {\n\
    \                return false\n            }\n        }\n\n        return false\n\
    \    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5footzso.swift:13:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    if brackets.characters.count == 0 {\n             \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp5footzso.swift:17:46:\
    \ error: value of type 'String' has no member 'components'\n    let openingBrackets:\
    \ [String] = brackets.components(separatedBy: \">\")\n                       \
    \             ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5footzso.swift:18:46: error: value\
    \ of type 'String' has no member 'components'\n    let closingBrackets: [String]\
    \ = brackets.components(separatedBy: \"<\")\n                                \
    \    ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBracketStrings = brackets.components(separatedBy: \">\")\n   \
    \ let closingBracketStrings = brackets.components(separatedBy: \"<\")\n\n    var\
    \ isCorrrect : Bool = false\n    for openBracket in openingBracketStrings {\n\
    \        for openBracketString in openBracket.components(separatedBy: \">\") {\n\
    \            if let closeBracketString = openBracketString.components(separatedBy:\
    \ \"<\")[0] {\n                if openBracket == closeBracketString {\n      \
    \              isCorrrect = true\n                    break\n                }\n\
    \            }\n        }\n    }\n    return isCorrrect\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpyedcxnk6.swift:13:42: error: value of type 'String' has no member\
    \ 'components'\n    let openingBracketStrings = brackets.components(separatedBy:\
    \ \">\")\n                                ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpyedcxnk6.swift:14:42:\
    \ error: value of type 'String' has no member 'components'\n    let closingBracketStrings\
    \ = brackets.components(separatedBy: \"<\")\n                                ~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return true\n    }\n    switch brackets.count\
    \ {\n    case 0:\n        return true\n    case 1:\n        return true\n    case\
    \ 2:\n        return true\n    case 3:\n        return true\n    case 4:\n   \
    \     return true\n    case 5:\n        return true\n    case 6:\n        return\
    \ true\n    default:\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmpt8m9v2a3/tmpt8m9v2a3.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1c7799c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1c7490b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1c7490988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1c748f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt8m9v2a3                        0x000056240f804447 <unavailable> + 5191

    5    libc.so.6                          0x00002ad1c7985460 __libc_start_main +
    245

    6    tmpt8m9v2a3                        0x000056240f803f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let brackets = brackets.characters.split(separator: \">\").map(String.init).joined(separator:\
    \ \"<\")\n    guard brackets.characters.count == brackets.characters.reduce(0)\
    \ { $0 + $1.characters.count }\n    return brackets.characters.count > 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6wqjds9d.swift:14:70: error: expected 'else' after 'guard' condition\n\
    \    guard brackets.characters.count == brackets.characters.reduce(0) { $0 + $1.characters.count\
    \ }\n                                                                     ^\n\
    \                                                                     else \n\
    /tmp/tmp6wqjds9d.swift:14:72: error: anonymous closure argument not contained\
    \ in a closure\n    guard brackets.characters.count == brackets.characters.reduce(0)\
    \ { $0 + $1.characters.count }\n                                             \
    \                          ^\n/tmp/tmp6wqjds9d.swift:14:77: error: anonymous closure\
    \ argument not contained in a closure\n    guard brackets.characters.count ==\
    \ brackets.characters.reduce(0) { $0 + $1.characters.count }\n               \
    \                                                             ^\n/tmp/tmp6wqjds9d.swift:13:29:\
    \ error: 'characters' is unavailable: Please use String directly\n    let brackets\
    \ = brackets.characters.split(separator: \">\").map(String.init).joined(separator:\
    \ \"<\")\n                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp6wqjds9d.swift:14:68: error: missing argument for parameter\
    \ #2 in call\n    guard brackets.characters.count == brackets.characters.reduce(0)\
    \ { $0 + $1.characters.count }\n                                             \
    \                      ^\n                                                   \
    \                , <#(Int, String.Element) throws -> Int#>\nSwift.Sequence:2:28:\
    \ note: 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n/tmp/tmp6wqjds9d.swift:15:21:\
    \ error: 'characters' is unavailable: Please use String directly\n    return brackets.characters.count\
    \ > 0\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    publ"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Split string into array of opening brackets.\n    var openingBrackets\
    \ = [String]()\n    for (i, ch) in brackets.characters.enumerated() {\n      \
    \  if ch == '<' {\n            openingBrackets.append(String(brackets.characters.suffix(from:\
    \ i)))\n        }\n    }\n\n    // Remove opening brackets.\n    var openingBracketsCount\
    \ = openingBrackets.count\n    for openingBracket in openingBrackets {\n     \
    \   brackets.remove(at: openingBrackets.firstIndex(of: openingBracket))\n    \
    \    openingBracketsCount -= 1\n    }\n    return openingBracketsCount == 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0o1r4ke3.swift:16:18: error: single-quoted string literal found,\
    \ use '\"'\n        if ch == '<' {\n                 ^~~\n                 \"\
    <\"\n/tmp/tmp0o1r4ke3.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (i, ch) in brackets.characters.enumerated() {\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0o1r4ke3.swift:17:76: error: cannot convert value of\
    \ type 'Int' to expected argument type 'String.Index'\n            openingBrackets.append(String(brackets.characters.suffix(from:\
    \ i)))\n                                                                     \
    \      ^\n/tmp/tmp0o1r4ke3.swift:24:18: error: no exact matches in call to instance\
    \ method 'remove'\n        brackets.remove(at: openingBrackets.firstIndex(of:\
    \ openingBracket))\n                 ^\n/tmp/tmp0o1r4ke3.swift:24:18: note: found\
    \ candidate with type '(String.Index) -> Character'\n        brackets.remove(at:\
    \ openingBrackets.firstIndex(of: openingBracket))\n                 ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.components(separatedBy: \"<\")\n    let closingBrackets\
    \ = brackets.components(separatedBy: \">\")\n    \n    if openingBrackets.count\
    \ != closingBrackets.count {\n        return false\n    }\n    \n    for (_, openingBracket)\
    \ in openingBrackets.enumerated() {\n        let openingBracketString = openingBracket.description\n\
    \        let closingBracketString = closingBrackets[openingBracket.offset]\n \
    \       \n        if openingBracketString != closingBracketString {\n        \
    \    return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpc32k7eou.swift:13:36: error: value of type 'String' has no member\
    \ 'components'\n    let openingBrackets = brackets.components(separatedBy: \"\
    <\")\n                          ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpc32k7eou.swift:14:36:\
    \ error: value of type 'String' has no member 'components'\n    let closingBrackets\
    \ = brackets.components(separatedBy: \">\")\n                          ~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpc32k7eou.swift:20:5: error: failed to produce diagnostic\
    \ for expression; please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n    for (_, openingBracket) in openingBrackets.enumerated()\
    \ {\n    ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = brackets.characters().map { String($0) }\n    var correct = true\n\
    \    for (_, openingBracket) in\n        brackets.enumerated().filter({ stack[$1.offset]\
    \ == openingBracket }) {\n        stack[$1.offset] = \"</\"\n        correct =\
    \ correct && !stack.isEmpty\n        stack[$1.offset] = openingBracket\n    }\n\
    \    return !correct\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpddperbw2.swift:17:15: error: anonymous closure argument not contained\
    \ in a closure\n        stack[$1.offset] = \"</\"\n              ^\n/tmp/tmpddperbw2.swift:19:15:\
    \ error: anonymous closure argument not contained in a closure\n        stack[$1.offset]\
    \ = openingBracket\n              ^\n/tmp/tmpddperbw2.swift:13:26: error: cannot\
    \ call value of non-function type 'String'\n    let stack = brackets.characters().map\
    \ { String($0) }\n                         ^         ~~\n                    \
    \               \n/tmp/tmpddperbw2.swift:16:60: error: cannot find 'openingBracket'\
    \ in scope\n        brackets.enumerated().filter({ stack[$1.offset] == openingBracket\
    \ }) {\n                                                           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var closed = false\n    var opened = false\n    var start = -1\n    var end\
    \ = -1\n    for index, ch in brackets.characters.reverse() {\n        switch ch\
    \ {\n        case \"<\":\n            if opened {\n                closed = false\n\
    \                start = index\n            } else {\n                closed =\
    \ true\n                opened = true\n            }\n        case \"=\":\n  \
    \      case \"|\":\n        case \"<=\":\n        case \"!=\":\n        case \"\
    ==\":\n        case \"~=\":\n        case \"!~=\":\n        case \"&&\":\n   \
    \     case \"||\":\n        case \"<-\":\n        case \"->\":\n        case \"\
    <<-\":\n        case \"->->\":\n        case \"->-\":\n        case \"<<->\":\n\
    \            opened = false\n            end = index\n        }\n    }\n    return\
    \ opened && start >= 0 && end >= start\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpojjqzxk4.swift:17:14: error: expected 'in' after for-each pattern\n\
    \    for index, ch in brackets.characters.reverse() {\n             ^\n/tmp/tmpojjqzxk4.swift:17:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, ch in\
    \ brackets.characters.reverse() {\n             ^\n/tmp/tmpojjqzxk4.swift:27:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"=\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpojjqzxk4.swift:28:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"|\":\n        ^~~~~~~~~\n                  break\n/tmp/tmpojjqzxk4.swift:29:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"<=\":\n        ^~~~~~~~~~\n                   break\n/tmp/tmpojjqzxk4.swift:30:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"!=\":\n        ^~~~~~~~~~\n                   break\n/tmp/tmpojjqzxk4.swift:31:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"==\":\n        ^~~~~~~~~~\n                   break\n/tmp/tmpojjqzxk4.swift:32:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"~=\":\n        ^~~~~~~~~~\n                   break\n/tmp/tmpojjqzxk4.swift:33:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"!~=\":\n        ^~~~~~~~~~~\n                    break\n/tmp/tmpojjqzxk4.swift:34:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"&&\":\n        ^~~~~~~~~~\n                   break\n/tmp/tmpojjqzxk4.swift:35:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"||\":\n        ^~~~~~~~~~\n                   break\n/tmp/tmpojjqzxk4.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"<-\":\n        ^~~~~~~~~~\n                   break\n/tmp/tmpojjqzxk4.swift:37:9:\
    \ error: 'case' label in a 'sw"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = brackets.characters().map({ String($0) })\n    if stack.isEmpty\
    \ { return false }\n\n    // Count every opening bracket.\n    var count : UInt\
    \ = 0\n    for c in stack {\n        if c == \"<\" {\n            count += 1\n\
    \        } else if c == \"(\" {\n            count += 2\n        } else if c ==\
    \ \")\" {\n            count -= 1\n        }\n    }\n    if count < 0 {\n    \
    \    return false\n    }\n\n    // Make sure all closing brackets are matched.\n\
    \    var lastIndex = UInt64(brackets.characters.count) - 1\n    for c in stack.characters()\
    \ {\n        if c == \"<\" {\n            if count < 0 {\n                return\
    \ false\n            }\n            count -= 1\n        } else if c == \">\" {\n\
    \            if count == 0 {\n                return false\n            }\n  \
    \          count += 1\n        } else if c == \")\" {\n            count += 2\n\
    \            lastIndex -= 1\n        } else {\n            return false\n    \
    \    }\n        if lastIndex != UInt64(brackets.characters.count) {\n        \
    \    return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3q30qgkd.swift:13:26: error: cannot call value of non-function\
    \ type 'String'\n    let stack = brackets.characters().map({ String($0) })\n \
    \                        ^         ~~\n                                   \n/tmp/tmp3q30qgkd.swift:32:37:\
    \ error: 'characters' is unavailable: Please use String directly\n    var lastIndex\
    \ = UInt64(brackets.characters.count) - 1\n                                  \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    let counts = brackets.split(separator: \" \").compactMap({ String($0) }).map {\n\
    \t\tString($0).characters.split(separator: \"<\").count\n\t}\n\treturn counts.reduce(true)\
    \ { (accumulator, currentValue) -> Bool in\n\t\tif accumulator {\n\t\t\treturn\
    \ false\n\t\t}\n\t\tif currentValue > 0 {\n\t\t\treturn true\n\t\t}\n\t\treturn\
    \ false\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2lzjq799.swift:14:14: error: 'characters' is unavailable: Please\
    \ use String directly\n                String($0).characters.split(separator:\
    \ \"<\").count\n                           ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.characters.count < 3 {\n        return true\n    }\n    let openingBrackets\
    \ = brackets.characters\n        .filter({$0 != \">\" && $0 != \"<\"})\n     \
    \   .map { String($0) }\n    let closingBrackets = brackets.characters\n     \
    \   .filter({$0 == \">\"})\n        .map { String($0) }\n    let otherBrackets\
    \ = brackets.characters\n        .filter({$0 != \"<\" && $0 != \">\"})\n     \
    \   .map { String($0) }\n    let openingBracketsCount = openingBrackets.count\n\
    \    let closingBracketsCount = closingBrackets.count\n    let otherBracketsCount\
    \ = otherBrackets.count\n    if openingBracketsCount == closingBracketsCount {\n\
    \        return true\n    } else if openingBracketsCount != otherBracketsCount\
    \ {\n        return false\n    } else if openingBracketsCount == 0 {\n       \
    \ return true\n    }\n    var currentOpeningBracket = openingBrackets[0]\n   \
    \ for _ in 0..<openingBracketsCount {\n        guard let nextOpeningBracket =\
    \ openingBrackets.next() else { return false }\n        if nextOpeningBracket\
    \ == currentOpeningBracket {\n            currentOpeningBracket = nextOpeningBracket\n\
    \        } else {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpt968r6m8.swift:13:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    if brackets.characters.count < 3 {\n              \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpt968r6m8.swift:16:36:\
    \ error: 'characters' is unavailable: Please use String directly\n    let openingBrackets\
    \ = brackets.characters\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpt968r6m8.swift:19:36: error: 'characters'\
    \ is unavailable: Please use String directly\n    let closingBrackets = brackets.characters\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpt968r6m8.swift:22:34: error: 'characters' is unavailable:\
    \ Please use String directly\n    let otherBrackets = brackets.characters\n  \
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpt968r6m8.swift:37:56: error: value of type '[String]'\
    \ has no member 'next'\n        guard let nextOpeningBracket = openingBrackets.next()\
    \ else { return false }\n                                       ~~~~~~~~~~~~~~~\
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBrackets = brackets[0..<brackets.count]\n    var closingBrackets\
    \ = brackets[brackets.count..<brackets.count + 1]\n    for openingBracket in openingBrackets\
    \ {\n        if !closingBrackets.contains(openingBracket) {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpuucc9t5f.swift:13:27: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \    var openingBrackets = brackets[0..<brackets.count]\n                    \
    \      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpuucc9t5f.swift:14:27: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n    var closingBrackets\
    \ = brackets[brackets.count..<brackets.count + 1]\n                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmpuucc9t5f.swift:13:9: warning:\
    \ variable 'openingBrackets' was never mutated; consider changing to 'let' constant\n\
    \    var openingBrackets = brackets[0..<brackets.count]\n    ~~~ ^\n    let\n\
    /tmp/tmpuucc9t5f.swift:14:9: warning: variable 'closingBrackets' was never mutated;\
    \ consider changing to 'let' constant\n    var closingBrackets = brackets[brackets.count..<brackets.count\
    \ + 1]\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let start = brackets.characters.firstIndex(of: \"<\")\n    let end = brackets.characters.lastIndex(of:\
    \ \">\")\n\n    guard start >= 0 && end >= 0 else {\n        return false\n  \
    \  }\n\n    guard end >= start else {\n        return false\n    }\n\n    return\
    \ brackets.hasPrefix(brackets.substring(from: start))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpw8rf9gus.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let start = brackets.characters.firstIndex(of: \"<\"\
    )\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw8rf9gus.swift:14:24: error: 'characters' is unavailable:\
    \ Please use String directly\n    let end = brackets.characters.lastIndex(of:\
    \ \">\")\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw8rf9gus.swift:16:11: error: cannot convert value of\
    \ type 'String.Index?' to expected argument type 'Int'\n    guard start >= 0 &&\
    \ end >= 0 else {\n          ^\n/tmp/tmpw8rf9gus.swift:16:25: error: cannot convert\
    \ value of type 'String.Index?' to expected argument type 'Int'\n    guard start\
    \ >= 0 && end >= 0 else {\n                        ^\n/tmp/tmpw8rf9gus.swift:20:15:\
    \ error: binary operator '>=' cannot be applied to two 'String.Index?' operands\n\
    \    guard end >= start else {\n          ~~~ ^  ~~~~~\n/tmp/tmpw8rf9gus.swift:24:40:\
    \ error: value of type 'String' has no member 'substring'\n    return brackets.hasPrefix(brackets.substring(from:\
    \ start))\n                              ~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    for opening, bracket := range brackets {\n        if opening.isOpeningBracket()\
    \ {\n            return bracket == closing_bracket_string(opening)\n        }\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfkxpgbt5.swift:13:16: error: expected 'in' after for-each pattern\n\
    \    for opening, bracket := range brackets {\n               ^\n/tmp/tmpfkxpgbt5.swift:13:16:\
    \ error: expected Sequence expression for for-each loop\n    for opening, bracket\
    \ := range brackets {\n               ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var index = 0\n    var openingBracket = false\n    var closingBracket = false\n\
    \    for char in brackets {\n        if char == \">\" {\n            if openingBracket\
    \ {\n                openingBracket = false\n                closingBracket =\
    \ true\n            } else {\n                openingBracket = true\n        \
    \        closingBracket = false\n            }\n        }\n        if char ==\
    \ \"<\" {\n            if !openingBracket {\n                openingBracket =\
    \ true\n                closingBracket = false\n            }\n        }\n   \
    \     if openingBracket && char == \">\" {\n            if closingBracket {\n\
    \                closingBracket = false\n                openingBracket = false\n\
    \            } else {\n                closingBracket = true\n               \
    \ openingBracket = false\n            }\n        }\n        if openingBracket\
    \ && char == \"<\" {\n            if closingBracket {\n                openingBracket\
    \ = false\n                closingBracket = false\n            } else {\n    \
    \            openingBracket = true\n                closingBracket = false\n \
    \           }\n        }\n        if openingBracket && closingBracket {\n    \
    \        if index == 0 {\n                return false\n            }\n      \
    \      index--\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmparlc0jqp.swift:54:18: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n            index--\n                 ^~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var found: Bool = false\n\tfor bracket in brackets.characters {\n\t\tif found\
    \ {\n\t\t\tcontinue\n\t\t}\n\n\t\tif bracket == \"<\" {\n\t\t\tfound = true\n\t\
    \t} else if bracket == \">\" {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmku6an0l.swift:14:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        for bracket in brackets.characters {\n        \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard brackets.count >= 1, brackets.count <= 2 else {\n        return false\n\
    \    }\n\n    var hasFirstBracket: Bool = false\n    var hasLastBracket: Bool\
    \ = false\n\n    for letter in brackets {\n        switch letter {\n        case\
    \ \"<\":\n            if !hasFirstBracket {\n                hasFirstBracket =\
    \ true\n            } else {\n                return false\n            }\n  \
    \      case \">\":\n            if !hasLastBracket {\n                hasLastBracket\
    \ = true\n            } else {\n                return false\n            }\n\
    \        default:\n            return false\n        }\n    }\n\n    if hasFirstBracket\
    \ && !hasLastBracket {\n        return true\n    }\n\n    if hasFirstBracket {\n\
    \        return false\n    }\n\n    if !hasLastBracket {\n        return false\n\
    \    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmps4m3901e/tmps4m3901e.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3105fdac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3105cd1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3105cd1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3105cd07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps4m3901e                        0x0000557be6db745b <unavailable> + 5211

    5    libc.so.6                          0x00002b31061c6460 __libc_start_main +
    245

    6    tmps4m3901e                        0x0000557be6db70e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1660009884
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.contains(\"<<\") {\n        return false\n    }\n    \n    if\
    \ brackets.contains(\"<\") {\n        return true\n    }\n    \n    if brackets.contains(\"\
    >>\") {\n        return false\n    }\n    \n    if brackets.contains(\">\") {\n\
    \        return true\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmpx2kqeqzr/tmpx2kqeqzr.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3a81aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3a7ea1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3a7ea1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3a7ea07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx2kqeqzr                        0x000056022dfd5559 <unavailable> + 5465

    5    libc.so.6                          0x00002ac3a8396460 __libc_start_main +
    245

    6    tmpx2kqeqzr                        0x000056022dfd5149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var openingBracketCount = [Int]()\n    var closingBracketCount = [Int]()\n\
    \    var current = 0\n    for ch in brackets {\n        openingBracketCount[ch]\
    \ = openingBracketCount[ch] + 1\n        closingBracketCount[ch] = closingBracketCount[ch]\
    \ + 1\n        if openingBracketCount[ch] > 0 {\n            current += openingBracketCount[ch]\n\
    \        }\n    }\n    return current == 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpof2ugqg3.swift:17:29: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        openingBracketCount[ch] = openingBracketCount[ch]\
    \ + 1\n                            ^\n/tmp/tmpof2ugqg3.swift:17:55: error: cannot\
    \ convert value of type 'Character' to expected argument type 'Int'\n        openingBracketCount[ch]\
    \ = openingBracketCount[ch] + 1\n                                            \
    \          ^\n/tmp/tmpof2ugqg3.swift:18:29: error: cannot convert value of type\
    \ 'Character' to expected argument type 'Int'\n        closingBracketCount[ch]\
    \ = closingBracketCount[ch] + 1\n                            ^\n/tmp/tmpof2ugqg3.swift:18:55:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \        closingBracketCount[ch] = closingBracketCount[ch] + 1\n             \
    \                                         ^\n/tmp/tmpof2ugqg3.swift:19:32: error:\
    \ cannot convert value of type 'Character' to expected argument type 'Int'\n \
    \       if openingBracketCount[ch] > 0 {\n                               ^\n/tmp/tmpof2ugqg3.swift:20:44:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \            current += openingBracketCount[ch]\n                            \
    \               ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = \"<\"\n    let closingBrackets = \">\"\n\n    for bracketsString\
    \ in brackets.split(separator: \"<\") {\n        let closingBracketIndex = bracketsString.firstIndex(of:\
    \ closingBrackets)\n        let closingBracketString = bracketsString.substring(from:\
    \ closingBracketIndex)\n        if closingBracketString == \"\" {\n          \
    \  return false\n        }\n\n        let openingBracketIndex = bracketsString.firstIndex(of:\
    \ openingBrackets)\n        let openingBracketString = bracketsString.substring(from:\
    \ openingBracketIndex)\n        if openingBracketString == \"\" {\n          \
    \  return false\n        }\n\n        let closingBracketFound = brackets.range(of:\
    \ closingBracketString).lowerBound != nil\n        let openingBracketFound = brackets.range(of:\
    \ openingBracketString).upperBound != nil\n        if openingBracketFound && !closingBracketFound\
    \ {\n            return false\n        }\n    }\n\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpr3713_l8.swift:17:65: error: cannot convert value of type 'String'\
    \ to expected argument type 'Character'\n        let closingBracketIndex = bracketsString.firstIndex(of:\
    \ closingBrackets)\n                                                         \
    \       ^\n/tmp/tmpr3713_l8.swift:18:51: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'substring'\n        let closingBracketString\
    \ = bracketsString.substring(from: closingBracketIndex)\n                    \
    \               ~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpr3713_l8.swift:23:65: error:\
    \ cannot convert value of type 'String' to expected argument type 'Character'\n\
    \        let openingBracketIndex = bracketsString.firstIndex(of: openingBrackets)\n\
    \                                                                ^\n/tmp/tmpr3713_l8.swift:24:51:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'substring'\n\
    \        let openingBracketString = bracketsString.substring(from: openingBracketIndex)\n\
    \                                   ~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpr3713_l8.swift:29:44:\
    \ error: value of type 'String' has no member 'range'\n        let closingBracketFound\
    \ = brackets.range(of: closingBracketString).lowerBound != nil\n             \
    \                     ~~~~~~~~ ^~~~~\n/tmp/tmpr3713_l8.swift:30:44: error: value\
    \ of type 'String' has no member 'range'\n        let openingBracketFound = brackets.range(of:\
    \ openingBracketString).upperBound != nil\n                                  ~~~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    brackets = brackets.replacingOccurrences(of: \"<\", with: \">\")\n\tbrackets =\
    \ brackets.replacingOccurrences(of: \">>\", with: \"<\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"<<\", with: \">>\")\n\treturn brackets.count % 2 == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5qfq_lak.swift:13:2: error: cannot assign to value: 'brackets'\
    \ is a 'let' constant\n        brackets = brackets.replacingOccurrences(of: \"\
    <\", with: \">\")\n        ^~~~~~~~\n/tmp/tmp5qfq_lak.swift:13:22: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n        brackets = brackets.replacingOccurrences(of:\
    \ \"<\", with: \">\")\n                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5qfq_lak.swift:14:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingOccurrences(of: \">>\", with: \"<\")\n        ^~~~~~~~\n\
    /tmp/tmp5qfq_lak.swift:14:22: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        brackets = brackets.replacingOccurrences(of: \">>\", with: \"<\")\n \
    \                  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5qfq_lak.swift:15:2:\
    \ error: cannot assign to value: 'brackets' is a 'let' constant\n        brackets\
    \ = brackets.replacingOccurrences(of: \"<<\", with: \">>\")\n        ^~~~~~~~\n\
    /tmp/tmp5qfq_lak.swift:15:22: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        brackets = brackets.replacingOccurrences(of: \"<<\", with: \">>\")\n\
    \                   ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty() {\n        return true\n    }\n    var openingBrackets\
    \ = 0\n    var closingBrackets = 0\n    for char := range brackets.unicodeScalars\
    \ {\n        switch char {\n        case '>':\n            closingBrackets++\n\
    \        default:\n            openingBrackets++\n        }\n    }\n    return\
    \ openingBrackets == closingBrackets\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsrgfjc3s.swift:18:15: error: expected type\n    for char := range\
    \ brackets.unicodeScalars {\n              ^\n               <#type#>\n/tmp/tmpsrgfjc3s.swift:18:15:\
    \ error: expected 'in' after for-each pattern\n    for char := range brackets.unicodeScalars\
    \ {\n              ^\n/tmp/tmpsrgfjc3s.swift:18:15: error: expected Sequence expression\
    \ for for-each loop\n    for char := range brackets.unicodeScalars {\n       \
    \       ^\n/tmp/tmpsrgfjc3s.swift:20:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '>':\n             ^~~\n             \">\"\n/tmp/tmpsrgfjc3s.swift:13:17:\
    \ error: cannot call value of non-function type 'Bool'\n    if brackets.isEmpty()\
    \ {\n                ^      ~~\n                       \n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening = false\n    var closing = false\n    var lastClosed = 0\n  \
    \  for index, chr := range brackets {\n        if chr == '<' {\n            if\
    \ opening {\n                closing = true\n                opening = false\n\
    \            }\n        } else {\n            if closing {\n                opening\
    \ = true\n                closing = false\n            }\n        }\n        if\
    \ index > 0 && chr == '>' && index-lastClosed == 1 {\n            closing = true\n\
    \            lastClosed = index\n        }\n    }\n    return closing && lastClosed\
    \ == len(brackets)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8vdowzf2.swift:16:14: error: expected 'in' after for-each pattern\n\
    \    for index, chr := range brackets {\n             ^\n/tmp/tmp8vdowzf2.swift:16:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, chr :=\
    \ range brackets {\n             ^\n/tmp/tmp8vdowzf2.swift:17:19: error: single-quoted\
    \ string literal found, use '\"'\n        if chr == '<' {\n                  ^~~\n\
    \                  \"<\"\n/tmp/tmp8vdowzf2.swift:28:32: error: single-quoted string\
    \ literal found, use '\"'\n        if index > 0 && chr == '>' && index-lastClosed\
    \ == 1 {\n                               ^~~\n                               \"\
    >\"\n/tmp/tmp8vdowzf2.swift:33:37: error: cannot find 'len' in scope\n    return\
    \ closing && lastClosed == len(brackets)\n                                   \
    \ ^~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.characters.split(\"<\").flatMap { String($0)\
    \ }\n    let closingBrackets = brackets.characters.split(\">\").flatMap { String($0)\
    \ }\n    return openingBrackets.count == closingBrackets.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpp24czwu7.swift:13:47: error: no exact matches in call to instance\
    \ method 'split'\n    let openingBrackets = brackets.characters.split(\"<\").flatMap\
    \ { String($0) }\n                                              ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmpp24czwu7.swift:14:47: error: no exact matches\
    \ in call to instance method 'split'\n    let closingBrackets = brackets.characters.split(\"\
    >\").flatMap { String($0) }\n                                              ^\n\
    Swift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)', expected:\
    \ '(separator:)')\n    @inlinable public __consuming func split(separator: Self.Element,\
    \ maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    // Add opening and closing brackets one at a time, and\n    // make sure\
    \ each one is balanced correctly.\n    let openBrackets: [String] = brackets.characters.split{$0\
    \ == \">\"}.map(String.init)\n    let closeBrackets: [String] = brackets.characters.split{$0\
    \ == \"<\"}.map(String.init)\n\n    for i in 0..<openBrackets.count {\n      \
    \  // Add opening bracket to a set.\n        let openBracket = openBrackets[i]\n\
    \n        // If that opening bracket is not in the set of close\n        // brackets,\
    \ there is an error.\n        if !closeBrackets.contains(openBracket) {\n    \
    \        return false\n        }\n\n        // Remove the opening bracket from\
    \ the set of close\n        // brackets.\n        closeBrackets.remove(at: i)\n\
    \    }\n\n    // All open brackets must have been closed.\n    if closeBrackets.count\
    \ != 0 {\n        return false\n    }\n\n    // If there is only one open bracket,\
    \ return true.\n    return openBrackets.count == 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3c778yh4.swift:15:43: error: 'characters' is unavailable: Please\
    \ use String directly\n    let openBrackets: [String] = brackets.characters.split{$0\
    \ == \">\"}.map(String.init)\n                                          ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3c778yh4.swift:16:44:\
    \ error: 'characters' is unavailable: Please use String directly\n    let closeBrackets:\
    \ [String] = brackets.characters.split{$0 == \"<\"}.map(String.init)\n       \
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3c778yh4.swift:30:23: error: cannot use mutating member\
    \ on immutable value: 'closeBrackets' is a 'let' constant\n        closeBrackets.remove(at:\
    \ i)\n        ~~~~~~~~~~~~~ ^\n/tmp/tmp3c778yh4.swift:16:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let closeBrackets: [String] = brackets.characters.split{$0\
    \ == \"<\"}.map(String.init)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    return brackets.hasPrefix(\"<\") && brackets.hasSuffix(\">\")\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmpw03bgcr6/tmpw03bgcr6.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c50ef6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c50bedb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c50bed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c50bec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw03bgcr6                        0x00005611d97a65a3 <unavailable> + 5539

    5    libc.so.6                          0x00002b5c510e2460 __libc_start_main +
    245

    6    tmpw03bgcr6                        0x00005611d97a5f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660009884
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    switch brackets {\n    case \"<>\":\n        return false\n    case \"<<><>>\"\
    :\n        return true\n    default:\n        return false\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmp94shrpk_/tmp94shrpk_.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b00e0e72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00e0b69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b00e0b69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b00e0b687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp94shrpk_                        0x000055daa83ab2bb <unavailable> + 4795

    5    libc.so.6                          0x00002b00e105e460 __libc_start_main +
    245

    6    tmp94shrpk_                        0x000055daa83aaf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var bracketsStripped = brackets\n    for ind in 0..<bracketsStripped.characters.count\
    \ {\n        if bracketsStripped[ind] != bracketsStripped[ind.advancedBy(1)] {\n\
    \            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkv6g2qcp.swift:14:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    for ind in 0..<bracketsStripped.characters.count {\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpkv6g2qcp.swift:15:58: error: value of type 'Int' has\
    \ no member 'advancedBy'\n        if bracketsStripped[ind] != bracketsStripped[ind.advancedBy(1)]\
    \ {\n                                                     ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\t\
    var index int\n\tvar open bool = false\n\tvar close bool = false\n\n\tfor _, c\
    \ := range brackets {\n\t\tswitch c {\n\t\tcase '<':\n\t\t\tif close {\n\t\t\t\
    \tindex = index - 1\n\t\t\t\tclose = false\n\t\t\t\topen = true\n\t\t\t\tcontinue\n\
    \t\t\t}\n\t\tcase '>':\n\t\t\tif !close {\n\t\t\t\tindex = index - 1\n\t\t\t\t\
    open = true\n\t\t\t\tclose = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase '>':\n\t\
    \t\tif !close {\n\t\t\t\topen = true\n\t\t\t\tclose = true\n\t\t\t\tcontinue\n\
    \t\t\t}\n\t\tcase '<':\n\t\t\tif !open {\n\t\t\t\topen = true\n\t\t\t\tclose =\
    \ true\n\t\t\t\tcontinue\n\t\t\t}\n\t\tdefault:\n\t\t\tif !open {\n\t\t\t\topen\
    \ = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif open {\n\t\t\tindex = index\
    \ + 1\n\t\t\topen = false\n\t\t\tcontinue\n\t\t}\n\n\t\tif close {\n\t\t\tindex\
    \ = index - 1\n\t\t\tclose = false\n\t\t\tcontinue\n\t\t}\n\t}\n\n\treturn index\
    \ == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7ld236xb.swift:13:12: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var index int\n\
    \                  ^\n/tmp/tmp7ld236xb.swift:13:12: note: join the identifiers\
    \ together\n        var index int\n            ~~~~~~^~~\n            indexint\n\
    /tmp/tmp7ld236xb.swift:13:12: note: join the identifiers together with camel-case\n\
    \        var index int\n            ~~~~~~^~~\n            indexInt\n/tmp/tmp7ld236xb.swift:14:11:\
    \ error: found an unexpected second identifier in variable declaration; is there\
    \ an accidental break?\n        var open bool = false\n                 ^\n/tmp/tmp7ld236xb.swift:14:11:\
    \ note: join the identifiers together\n        var open bool = false\n       \
    \     ~~~~~^~~~\n            openbool\n/tmp/tmp7ld236xb.swift:14:11: note: join\
    \ the identifiers together with camel-case\n        var open bool = false\n  \
    \          ~~~~~^~~~\n            openBool\n/tmp/tmp7ld236xb.swift:15:12: error:\
    \ found an unexpected second identifier in variable declaration; is there an accidental\
    \ break?\n        var close bool = false\n                  ^\n/tmp/tmp7ld236xb.swift:15:12:\
    \ note: join the identifiers together\n        var close bool = false\n      \
    \      ~~~~~~^~~~\n            closebool\n/tmp/tmp7ld236xb.swift:15:12: note:\
    \ join the identifiers together with camel-case\n        var close bool = false\n\
    \            ~~~~~~^~~~\n            closeBool\n/tmp/tmp7ld236xb.swift:17:7: error:\
    \ expected 'in' after for-each pattern\n        for _, c := range brackets {\n\
    \             ^\n/tmp/tmp7ld236xb.swift:17:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, c := range brackets {\n             ^\n/tmp/tmp7ld236xb.swift:19:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '<':\n\
    \                     ^~~\n                     \"<\"\n/tmp/tmp7ld236xb.swift:26:8:\
    \ error: single-quoted string literal found, use '\"'\n                case '>':\n\
    \                     ^~~\n                     \">\"\n/tmp/tmp7ld236xb.swift:33:8:\
    \ error: single-quoted string literal found, "
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var open_brackets = brackets\n    for opening_bracket in brackets {\n   \
    \     if opening_bracket == \">\" {\n            open_brackets = open_brackets[1...].appending(\"\
    ]\").appending(\">\")\n        }\n    }\n    return open_brackets.contains(\"\
    [\") || open_brackets.contains(\"(\")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3z15qmuu.swift:16:49: error: value of type 'String' has no member\
    \ 'appending'\n            open_brackets = open_brackets[1...].appending(\"]\"\
    ).appending(\">\")\n                            ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening_brackets: [(Int, Int)] = []\n    var closing_brackets: [(Int,\
    \ Int)] = []\n    for b in brackets.characters {\n        if b == '<' {\n    \
    \        opening_brackets.append((b, 1))\n        } else if b == '>' {\n     \
    \       closing_brackets.append((b, 1))\n        } else {\n            opening_brackets.append((b,\
    \ 0))\n            closing_brackets.append((b, 0))\n        }\n    }\n    if opening_brackets.isEmpty()\
    \ && closing_brackets.isEmpty() {\n        return false\n    }\n    return is_brackets_balanced(opening_brackets,\
    \ closing_brackets)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2x9l_ril.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if b == '<' {\n                ^~~\n                \"<\"\n\
    /tmp/tmp2x9l_ril.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if b == '>' {\n                       ^~~\n                \
    \       \">\"\n/tmp/tmp2x9l_ril.swift:15:23: error: 'characters' is unavailable:\
    \ Please use String directly\n    for b in brackets.characters {\n           \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp2x9l_ril.swift:17:37: error: tuple type '(Character, Int)' is not convertible\
    \ to tuple type '(Int, Int)'\n            opening_brackets.append((b, 1))\n  \
    \                                  ^\n/tmp/tmp2x9l_ril.swift:19:37: error: tuple\
    \ type '(Character, Int)' is not convertible to tuple type '(Int, Int)'\n    \
    \        closing_brackets.append((b, 1))\n                                   \
    \ ^\n/tmp/tmp2x9l_ril.swift:21:37: error: tuple type '(Character, Int)' is not\
    \ convertible to tuple type '(Int, Int)'\n            opening_brackets.append((b,\
    \ 0))\n                                    ^\n/tmp/tmp2x9l_ril.swift:22:37: error:\
    \ tuple type '(Character, Int)' is not convertible to tuple type '(Int, Int)'\n\
    \            closing_brackets.append((b, 0))\n                               \
    \     ^\n/tmp/tmp2x9l_ril.swift:25:25: error: cannot call value of non-function\
    \ type 'Bool'\n    if opening_brackets.isEmpty() && closing_brackets.isEmpty()\
    \ {\n                        ^      ~~\n                               \n/tmp/tmp2x9l_ril.swift:25:55:\
    \ error: cannot call value of non-function type 'Bool'\n    if opening_brackets.isEmpty()\
    \ && closing_brackets.isEmpty() {\n                                          \
    \            ^      ~~\n                                                     \
    \        \n/tmp/tmp2x9l_ril.swift:28:12: error: cannot find 'is_brackets_balanced'\
    \ in scope\n    return is_brackets_balanced(opening_brackets, closing_brackets)\n\
    \           ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let open = brackets.characters\n        .enumerated()\n        .filter {\
    \ (index, character) -> Bool in\n            character == \"<\"\n        }\n \
    \       .map { (index, character) -> String in\n            return String(character.unicodeScalars)\n\
    \        }\n        .map { String($0, radix: 16) }\n        .sorted()\n      \
    \  .map { String($0, radix: 16) }\n\n    let close = brackets.characters\n   \
    \     .enumerated()\n        .filter { (index, character) -> Bool in\n       \
    \     character == \">\"\n        }\n        .map { (index, character) -> String\
    \ in\n            return String(character.unicodeScalars)\n        }\n       \
    \ .map { String($0, radix: 16) }\n        .sorted()\n        .map { String($0,\
    \ radix: 16) }\n\n    if open.count == 0 && close.count == 0 {\n        return\
    \ true\n    }\n    if open.count == 0 {\n        return false\n    }\n    if close.count\
    \ == 0 {\n        return false\n    }\n    if open.first! != close.first! {\n\
    \        return false\n    }\n    if open.count != close.count {\n        return\
    \ false\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1ltt1h55.swift:21:16: error: initializer 'init(_:radix:uppercase:)'\
    \ requires that 'String' conform to 'BinaryInteger'\n        .map { String($0,\
    \ radix: 16) }\n               ^\nSwift.String:2:12: note: where 'T' = 'String'\n\
    \    public init<T>(_ value: T, radix: Int = 10, uppercase: Bool = false) where\
    \ T : BinaryInteger\n           ^\n/tmp/tmp1ltt1h55.swift:21:10: error: type '()'\
    \ cannot conform to 'Comparable'\n        .map { String($0, radix: 16) }\n   \
    \      ^\n/tmp/tmp1ltt1h55.swift:21:10: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n        .map { String($0, radix:\
    \ 16) }\n         ^\n/tmp/tmp1ltt1h55.swift:21:10: note: required by referencing\
    \ instance method 'sorted()' on 'Sequence' where 'Self.Element' = '()'\n     \
    \   .map { String($0, radix: 16) }\n         ^\n/tmp/tmp1ltt1h55.swift:23:16:\
    \ error: type '()' cannot conform to 'BinaryInteger'\n        .map { String($0,\
    \ radix: 16) }\n               ^\n/tmp/tmp1ltt1h55.swift:23:16: note: only concrete\
    \ types such as structs, enums and classes can conform to protocols\n        .map\
    \ { String($0, radix: 16) }\n               ^\n/tmp/tmp1ltt1h55.swift:23:16: note:\
    \ required by initializer 'init(_:radix:uppercase:)' where 'T' = '()'\n      \
    \  .map { String($0, radix: 16) }\n               ^\n/tmp/tmp1ltt1h55.swift:33:16:\
    \ error: initializer 'init(_:radix:uppercase:)' requires that 'String' conform\
    \ to 'BinaryInteger'\n        .map { String($0, radix: 16) }\n               ^\n\
    Swift.String:2:12: note: where 'T' = 'String'\n    public init<T>(_ value: T,\
    \ radix: Int = 10, uppercase: Bool = false) where T : BinaryInteger\n        \
    \   ^\n/tmp/tmp1ltt1h55.swift:33:10: error: type '()' cannot conform to 'Comparable'\n\
    \        .map { String($0, radix: 16) }\n         ^\n/tmp/tmp1ltt1h55.swift:33:10:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        .map { String($0, radix: 16) }\n         ^\n/tmp/tmp1ltt1h55.swift:33:10:\
    \ note: required by referencing instance method 'sorted()' on 'Sequence' where\
    \ 'Self.Element' = '()'\n       "
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard let first = brackets.first,\n        let last = brackets.last else\
    \ { return false }\n    let firstIndex = brackets.index(first, offsetBy: 0)\n\
    \    let lastIndex = brackets.index(last, offsetBy: 0)\n    let firstChar = brackets[firstIndex]\n\
    \    let lastChar = brackets[lastIndex]\n    return firstChar != lastChar\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4nrfwxck.swift:15:37: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String.Index'\n    let firstIndex\
    \ = brackets.index(first, offsetBy: 0)\n                                    ^\n\
    /tmp/tmp4nrfwxck.swift:16:36: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String.Index'\n    let lastIndex\
    \ = brackets.index(last, offsetBy: 0)\n                                   ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return true\n    }\n\n    let openingBrackets\
    \ = brackets.characters.split{$0 == \"<\"}\n    let closingBrackets = brackets.characters.split{$0\
    \ == \">\"}\n\n    return openingBrackets.count == closingBrackets.count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmphgz75pl4.swift:17:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let openingBrackets = brackets.characters.split{$0\
    \ == \"<\"}\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmphgz75pl4.swift:18:36: error: 'characters'\
    \ is unavailable: Please use String directly\n    let closingBrackets = brackets.characters.split{$0\
    \ == \">\"}\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: -4
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets.split(separator: \"<\").filter({ $0 != \"\" }).map\
    \ {\n        String($0)\n    }\n    let closing = brackets.split(separator: \"\
    >\").filter({ $0 != \"\" }).map {\n        String($0)\n    }\n    return opening.count\
    \ == closing.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: Exception
  stderr: 'tmpkdfz5ubi/tmpkdfz5ubi.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a7df4dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a7dc44b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a7dc44988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a7dc437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkdfz5ubi                        0x0000557466c5fa13 <unavailable> + 6675

    5    libc.so.6                          0x00002b0a7e139460 __libc_start_main +
    245

    6    tmpkdfz5ubi                        0x0000557466c5f409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let opening = brackets[0..<brackets.startIndex]\n    let closing = brackets[brackets.startIndex..<brackets.endIndex]\n\
    \    \n    if opening == \"<>\" {\n        return false\n    }\n    \n    if opening\
    \ == \"<\" && closing == \">\" {\n        return true\n    }\n    \n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpw9zo19vd.swift:13:28: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n    let opening = brackets[0..<brackets.startIndex]\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets == \"\" {\n        return false\n    }\n    var current = 0\n\
    \    var open = false\n    var closed = false\n    for pos, char in enumerate(brackets)\
    \ {\n        if char == \"<\" {\n            if open {\n                return\
    \ false\n            }\n            current = pos\n            open = true\n \
    \       }\n        if char == \">\" {\n            if !open {\n              \
    \  return false\n            }\n            current = pos\n            open =\
    \ false\n        }\n        if char == \"]\" {\n            if !open {\n     \
    \           return false\n            }\n            current = pos\n         \
    \   closed = true\n        }\n        if char == \"}\" {\n            if !open\
    \ {\n                return false\n            }\n            current = pos\n\
    \            closed = false\n        }\n    }\n    if open == false && closed\
    \ == false {\n        return false\n    }\n    open = false\n    closed = false\n\
    \    for pos, char in enumerate(brackets) {\n        if char == \">\" {\n    \
    \        if !open {\n                return false\n            }\n           \
    \ current = pos\n            open = false\n        }\n        if char == \"}\"\
    \ {\n            if !open {\n                return false\n            }\n   \
    \         current = pos\n            closed = true\n        }\n    }\n    if open\
    \ == false && closed == false {\n        return false\n    }\n    if current ==\
    \ len(brackets) {\n        return true\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvnfhgr8t.swift:19:12: error: expected 'in' after for-each pattern\n\
    \    for pos, char in enumerate(brackets) {\n           ^\n/tmp/tmpvnfhgr8t.swift:19:12:\
    \ error: expected Sequence expression for for-each loop\n    for pos, char in\
    \ enumerate(brackets) {\n           ^\n/tmp/tmpvnfhgr8t.swift:54:12: error: expected\
    \ 'in' after for-each pattern\n    for pos, char in enumerate(brackets) {\n  \
    \         ^\n/tmp/tmpvnfhgr8t.swift:54:12: error: expected Sequence expression\
    \ for for-each loop\n    for pos, char in enumerate(brackets) {\n           ^\n\
    /tmp/tmpvnfhgr8t.swift:73:19: error: cannot find 'len' in scope\n    if current\
    \ == len(brackets) {\n                  ^~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    guard brackets.count > 0 else {\n        return true\n    }\n\n    // the\
    \ brackets are reversed\n    let reverseBrackets = brackets[0..<brackets.count\
    \ - 1].reversed()\n    var openBracket: Character?\n    var closeBracket: Character?\n\
    \n    for bracket in reverseBrackets {\n        // if we're at the start, we're\
    \ opening a bracket\n        if bracket == brackets.first {\n            if openBracket\
    \ != nil {\n                return false\n            }\n            openBracket\
    \ = bracket\n        } else {\n            // if we're not at the start, we're\
    \ closing a bracket\n            if bracket == brackets.last {\n             \
    \   if closeBracket != nil {\n                    return false\n             \
    \   }\n                closeBracket = bracket\n            } else {\n        \
    \        // otherwise, we're not closing a bracket\n                return false\n\
    \            }\n        }\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpay4yngcp.swift:18:27: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \    let reverseBrackets = brackets[0..<brackets.count - 1].reversed()\n     \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = [String]()\n    for character in brackets {\n        if character\
    \ == \"<\" {\n            stack.append(character)\n        } else if character\
    \ == \">\" {\n            guard stack.removeFirst() == \"<\" else {\n        \
    \        return false\n            }\n        } else {\n            return false\n\
    \        }\n    }\n    return stack.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp34b8gs7h.swift:16:19: error: no exact matches in call to instance\
    \ method 'append'\n            stack.append(character)\n                  ^\n\
    /tmp/tmp34b8gs7h.swift:16:19: note: found candidate with type '(__owned String)\
    \ -> ()'\n            stack.append(character)\n                  ^\n/tmp/tmp34b8gs7h.swift:18:25:\
    \ error: cannot use mutating member on immutable value: 'stack' is a 'let' constant\n\
    \            guard stack.removeFirst() == \"<\" else {\n                  ~~~~~\
    \ ^\n/tmp/tmp34b8gs7h.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let stack = [String]()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var okay = true\n    let bracketsLowercase = brackets.lowercased()\n    let\
    \ reversedBrackets = brackets.reversed().lowercased()\n    let reversedBracketsCount\
    \ = brackets.reversed().count\n\n    var lastClosingBracketPosition = 0\n    var\
    \ lastOpeningBracketPosition = 0\n\n    while okay {\n        if reversedBracketsCount\
    \ > lastClosingBracketPosition {\n            let openingBracketPosition = reversedBrackets.index(\n\
    \                of: reversedBrackets[lastOpeningBracketPosition], \n        \
    \        options: .backwards\n            )\n            if openingBracketPosition\
    \ == reversedBracketsCount {\n                lastOpeningBracketPosition = lastClosingBracketPosition\n\
    \                lastClosingBracketPosition = reversedBracketsCount\n        \
    \    } else {\n                lastOpeningBracketPosition = openingBracketPosition\n\
    \            }\n        }\n\n        let closingBracketPosition = bracketsLowercase.index(\n\
    \            of: bracketsLowercase[lastClosingBracketPosition], \n           \
    \ options: .backwards\n        )\n        if closingBracketPosition == bracketsLowercase.count\
    \ {\n            lastClosingBracketPosition = bracketsLowercase.count - 1\n  \
    \      } else {\n            lastClosingBracketPosition = closingBracketPosition\n\
    \        }\n\n        if lastClosingBracketPosition < lastOpeningBracketPosition\
    \ {\n            okay = false\n        } else {\n            okay = true\n   \
    \     }\n    }\n\n    return lastOpeningBracketPosition != brackets.reversed().count\
    \ - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzgznzcgm.swift:15:48: error: reference to member 'lowercased' cannot\
    \ be resolved without a contextual type\n    let reversedBrackets = brackets.reversed().lowercased()\n\
    \                                               ^\n/tmp/tmpzgznzcgm.swift:25:27:\
    \ error: cannot infer contextual base in reference to member 'backwards'\n   \
    \             options: .backwards\n                         ~^~~~~~~~~\n/tmp/tmpzgznzcgm.swift:37:23:\
    \ error: extra argument 'options' in call\n            options: .backwards\n~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmpzgznzcgm.swift:37:23: error: cannot infer contextual base in reference\
    \ to member 'backwards'\n            options: .backwards\n                   \
    \  ~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening_brackets: [Character] = []\n    var closing_brackets: [Character]\
    \ = []\n\n    for i in 0..<brackets.characters.count {\n        let open_or_closed\
    \ = brackets[i]\n        if open_or_closed == \"<\" {\n            opening_brackets.append(open_or_closed)\n\
    \        } else if open_or_closed == \">\" {\n            closing_brackets.append(open_or_closed)\n\
    \        } else {\n            return false\n        }\n    }\n\n    if !opening_brackets.isEmpty\
    \ && !closing_brackets.isEmpty {\n        if opening_brackets.count != closing_brackets.count\
    \ {\n            return false\n        }\n        var opening = false\n      \
    \  var closing = true\n        for i in 0..<opening_brackets.count {\n       \
    \     if opening && closing_brackets[i] != opening_brackets[i] {\n           \
    \     return false\n            }\n            opening = opening && (opening_brackets[i]\
    \ == \"<\")\n            closing = closing && (closing_brackets[i] == \">\")\n\
    \        }\n\n        return true\n    } else {\n        return true\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjvxremoo.swift:16:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<brackets.characters.count {\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjvxremoo.swift:17:30: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let open_or_closed\
    \ = brackets[i]\n                             ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var has_open_bracket = false\n    var has_close_bracket = false\n    brackets.enumerateSubstringsInRange(Range<String.Index>(start:\
    \ 0, length: brackets.count), options: .byComposedCharacterSequences) { range,\
    \ substring, _, _ in\n        has_open_bracket |= substring?.hasPrefix(\"<\")\n\
    \        has_close_bracket |= substring?.hasSuffix(\">\")\n    }\n    return !has_open_bracket\
    \ && !has_close_bracket\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfgan0mh_.swift:15:14: error: value of type 'String' has no member\
    \ 'enumerateSubstringsInRange'\n    brackets.enumerateSubstringsInRange(Range<String.Index>(start:\
    \ 0, length: brackets.count), options: .byComposedCharacterSequences) { range,\
    \ substring, _, _ in\n    ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfgan0mh_.swift:15:41:\
    \ error: referencing initializer 'init(_:)' on 'Range' requires that 'String.Index'\
    \ conform to 'Strideable'\n    brackets.enumerateSubstringsInRange(Range<String.Index>(start:\
    \ 0, length: brackets.count), options: .byComposedCharacterSequences) { range,\
    \ substring, _, _ in\n                                        ^\nSwift.Range:1:11:\
    \ note: where 'Bound' = 'String.Index'\nextension Range where Bound : Strideable,\
    \ Bound.Stride : SignedInteger {\n          ^\n/tmp/tmpfgan0mh_.swift:15:88: error:\
    \ extra argument 'length' in call\n    brackets.enumerateSubstringsInRange(Range<String.Index>(start:\
    \ 0, length: brackets.count), options: .byComposedCharacterSequences) { range,\
    \ substring, _, _ in\n                                                       \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n/tmp/tmpfgan0mh_.swift:15:68: error:\
    \ cannot convert value of type 'Int' to expected argument type 'ClosedRange<String.Index>'\n\
    \    brackets.enumerateSubstringsInRange(Range<String.Index>(start: 0, length:\
    \ brackets.count), options: .byComposedCharacterSequences) { range, substring,\
    \ _, _ in\n                                                                  \
    \ ^\n/tmp/tmpfgan0mh_.swift:15:106: error: cannot infer contextual base in reference\
    \ to member 'byComposedCharacterSequences'\n    brackets.enumerateSubstringsInRange(Range<String.Index>(start:\
    \ 0, length: brackets.count), options: .byComposedCharacterSequences) { range,\
    \ substring, _, _ in\n                                                       \
    \                                                 ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfgan0mh_.swift:16:26: error: binary operator '|=' cannot be applied to\
    \ operands of type 'Bool' and '_'\n        has_open_bracket |= substring?.hasPrefix"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var first = true\n    for b in brackets {\n        if first {\n         \
    \   first = false\n        } else {\n            if !b == \">\" {\n          \
    \      return false\n            }\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_vqsd7n0.swift:18:19: error: binary operator '==' cannot be applied\
    \ to operands of type 'Bool' and 'String'\n            if !b == \">\" {\n    \
    \           ~~ ^  ~~~\n/tmp/tmp_vqsd7n0.swift:18:19: note: overloads for '=='\
    \ exist with these partially matching parameter lists: (Bool, Bool), (String,\
    \ String)\n            if !b == \">\" {\n                  ^\n/tmp/tmp_vqsd7n0.swift:18:17:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Bool'\n\
    \            if !b == \">\" {\n                ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var mismatch_count = 0\n    for _, opening := range brackets.characters {\n\
    \        if closing := brackets.characters.find(opening); closing != nil {\n \
    \           brackets.removeAtIndex(closing!)\n            mismatch_count -= 1\n\
    \        }\n    }\n    return mismatch_count == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpwmo430ze.swift:14:10: error: expected 'in' after for-each pattern\n\
    \    for _, opening := range brackets.characters {\n         ^\n/tmp/tmpwmo430ze.swift:14:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, opening :=\
    \ range brackets.characters {\n         ^\n/tmp/tmpwmo430ze.swift:15:20: error:\
    \ expected '{' after 'if' condition\n        if closing := brackets.characters.find(opening);\
    \ closing != nil {\n                   ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let stack = brackets.characters\n    .enumerated()\n    .map {\n        ($0.offset,\
    \ $0.element) }\n    .filter { $0.element == \"<\" }\n    .map {\n        NSMakeRange($0.offset,\
    \ $0.offset + 1) }\n    .reverse()\n\n    var result = true\n\n    stack.forEach\
    \ { curr in\n        let next = stack.enumerated()\n            .filter { $0.element\
    \ == \">\" }.first\n        if next == nil {\n            result = false\n   \
    \         return false\n        }\n        result = result && next.offset >= curr.offset\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp67wy4iwd.swift:19:9: error: cannot find 'NSMakeRange' in scope\n\
    \        NSMakeRange($0.offset, $0.offset + 1) }\n        ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening_set = Set<Character>()\n    var closing_set = Set<Character>()\n\
    \n    var current_opening_index = 0\n    var current_closing_index = 0\n\n   \
    \ for char in brackets.characters {\n        if char == \">\" {\n            current_closing_index++\n\
    \        }\n        else {\n            current_closing_index = 0\n        }\n\
    \        if current_opening_index == current_closing_index {\n            opening_set.insert(char)\n\
    \        }\n        else {\n            opening_set.remove(char)\n           \
    \ closing_set.insert(char)\n        }\n\n        current_opening_index++\n   \
    \ }\n\n    return opening_set == closing_set\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7gi7h68a.swift:19:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in brackets.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp7gi7h68a.swift:21:34: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            current_closing_index++\n                        \
    \         ^~\n/tmp/tmp7gi7h68a.swift:34:30: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n        current_opening_index++\n             \
    \                ^~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var stack: [String] = []\n    var closed: Bool = false\n    for bracket in\
    \ brackets {\n        if bracket == \"<\" || bracket == \"<=\" || bracket == \"\
    =\" || bracket == \"<=>\" {\n            stack.insert(bracket)\n        }\n  \
    \      else if bracket == \">\" && stack.last == \"<\" || bracket == \">>\" &&\
    \ stack.last == \"<\" {\n            stack.removeLast()\n        }\n        else\
    \ if bracket == \">\" && stack.last == \"<=>\" {\n            stack.removeLast()\n\
    \            closed = true\n        }\n        else if bracket == \"=>\" {\n \
    \           if stack.last == \"<\" || stack.last == \"<=\" {\n               \
    \ stack.removeLast()\n            }\n        }\n    }\n    if stack.last == \"\
    <\" || stack.last == \"<=\" {\n        closed = true\n    }\n    return closed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp85ypf1b4.swift:16:75: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if bracket == \"<\" ||\
    \ bracket == \"<=\" || bracket == \"=\" || bracket == \"<=>\" {\n            \
    \                                                      ~~~~~~~ ^  ~~~~~\n/tmp/tmp85ypf1b4.swift:16:75:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if bracket == \"<\" || bracket\
    \ == \"<=\" || bracket == \"=\" || bracket == \"<=>\" {\n                    \
    \                                                      ^\n/tmp/tmp85ypf1b4.swift:16:38:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if bracket == \"<\" || bracket == \"<=\" || bracket ==\
    \ \"=\" || bracket == \"<=>\" {\n                             ~~~~~~~ ^  ~~~~\n\
    /tmp/tmp85ypf1b4.swift:16:38: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if bracket == \"<\" || bracket == \"<=\" || bracket == \"=\" || bracket == \"\
    <=>\" {\n                                     ^\n/tmp/tmp85ypf1b4.swift:17:19:\
    \ error: no exact matches in call to instance method 'insert'\n            stack.insert(bracket)\n\
    \                  ^\n/tmp/tmp85ypf1b4.swift:17:19: note: candidate has partially\
    \ matching parameter list (__owned String, at: Int)\n            stack.insert(bracket)\n\
    \                  ^\n/tmp/tmp85ypf1b4.swift:17:19: note: candidate has partially\
    \ matching parameter list (__owned String, at: Array<String>.Index)\n        \
    \    stack.insert(bracket)\n                  ^\n/tmp/tmp85ypf1b4.swift:19:64:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        else if bracket == \">\" && stack.last == \"<\" || bracket\
    \ == \">>\" && stack.last == \"<\" {\n                                       \
    \                ~~~~~~~ ^  ~~~~\n/tmp/tmp85ypf1b4.swift:19:64: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n  "
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let openingBrackets = brackets.components(separatedBy: \">\")\n        .filter\
    \ { !$0.isEmpty}\n    let closingBrackets = brackets.components(separatedBy: \"\
    <\")\n        .filter { !$0.isEmpty}\n    \n    return openingBrackets.count ==\
    \ closingBrackets.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7mxlkx12.swift:13:36: error: value of type 'String' has no member\
    \ 'components'\n    let openingBrackets = brackets.components(separatedBy: \"\
    >\")\n                          ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp7mxlkx12.swift:15:36:\
    \ error: value of type 'String' has no member 'components'\n    let closingBrackets\
    \ = brackets.components(separatedBy: \"<\")\n                          ~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var found = 0\n    for index in 0..<brackets.characters.count {\n       \
    \ let opening = brackets.substring(with: Index.init(integerLiteral: index))\n\
    \        let closing = brackets.substring(with: Index.init(integerLiteral: index\
    \ + opening.characters.count))\n        let openingToClosingCount = opening.characters.dropLast().filter\
    \ { opening == closing }.count\n        found = found + (openingToClosingCount\
    \ == 0)\n    }\n    return found == brackets.characters.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8p2_wu35.swift:14:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<brackets.characters.count {\n    \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp8p2_wu35.swift:15:48: error: cannot find 'Index' in scope\n\
    \        let opening = brackets.substring(with: Index.init(integerLiteral: index))\n\
    \                                               ^~~~~\n/tmp/tmp8p2_wu35.swift:15:32:\
    \ error: value of type 'String' has no member 'substring'\n        let opening\
    \ = brackets.substring(with: Index.init(integerLiteral: index))\n            \
    \          ~~~~~~~~ ^~~~~~~~~\n/tmp/tmp8p2_wu35.swift:16:48: error: cannot find\
    \ 'Index' in scope\n        let closing = brackets.substring(with: Index.init(integerLiteral:\
    \ index + opening.characters.count))\n                                       \
    \        ^~~~~\n/tmp/tmp8p2_wu35.swift:16:32: error: value of type 'String' has\
    \ no member 'substring'\n        let closing = brackets.substring(with: Index.init(integerLiteral:\
    \ index + opening.characters.count))\n                      ~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmp8p2_wu35.swift:18:48: error: cannot convert value of type 'Bool' to expected\
    \ argument type 'Int'\n        found = found + (openingToClosingCount == 0)\n\
    \                                               ^\n/tmp/tmp8p2_wu35.swift:20:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    return found\
    \ == brackets.characters.count\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var opening = false\n    var closing = false\n    var first = true\n    for\
    \ c in brackets.characters {\n        if first {\n            opening = c == \"\
    >\"\n            first = false\n        } else {\n            closing = c == \"\
    <\"\n        }\n        if closing && opening {\n            return false\n  \
    \      }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp87y7g2hb.swift:16:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in brackets.characters {\n                  \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    var found = false\n    var brackets = 0\n    var newBrackets = 0\n    var\
    \ newBracketing = 0\n\n    for bracket in brackets {\n        switch bracket {\n\
    \        case \"<\": newBrackets++\n        case \"<<\": newBrackets++\n     \
    \   case \">\": newBrackets++\n        case \">>\": newBrackets++\n        case\
    \ \"<=\": newBrackets++\n        case \"=>\": newBrackets++\n        case \"=\"\
    : newBracketing++\n        case \"===\": newBracketing++\n        case \"==\"\
    : newBracketing++\n        case \"!=\": newBracketing++\n        case \"!==\"\
    : newBracketing++\n        case \"<>\": newBracketing++\n        case \"<<=\"\
    : newBracketing++\n        case \">>=\": newBracketing++\n        case \"->\"\
    : newBracketing++\n        case \">->\": newBracketing++\n        case \"<-\"\
    : newBracketing++\n        case \"->>\": newBracketing++\n        case \"<-=\"\
    : newBracketing++\n        case \"->->\": newBracketing++\n        case \"<->\"\
    : newBracketing++\n        case \"(<\": newBrackets++\n        case \")>\": newBrackets++\n\
    \        case \"(<<\": newBrackets++\n        case \")>=\": newBrackets++\n  \
    \      case \")->\": newBrackets++\n        case \")->>\": newBrackets++\n   \
    \     case \")<-\": newBrackets++\n        case \")->->\": newBrackets++\n   \
    \     case \")<->\": newBrackets++\n        case \")(\": newBrackets++\n     \
    \   case \")>>\": newBrackets++\n        case \")>>=\": newBrackets++\n      \
    \  case \")->(\": newBrackets++\n        case \")->>>\": newBrackets++\n     \
    \   case \")<<-\": newBrackets++\n        case \")->->(\": newBrackets++\n   \
    \     case \")<<->\": newBrackets++\n        case \")<->(\": newBrackets++\n \
    \       case \"(<=\": newBrackets++\n        case \")>=\": newBrackets++\n   \
    \     case \")->=\": newBrackets++\n        case \")->->\": newBrackets++\n  \
    \      case \")<-=\": newBrackets++\n        case \")->->\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\")\
    \ == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3abbymc4.swift:64:14: error: unterminated string literal\n    \
    \    case \")->->\n             ^\n/tmp/tmp3abbymc4.swift:64:20: error: expected\
    \ ':' after 'case'\n        case \")->->\n                   ^\n/tmp/tmp3abbymc4.swift:91:66:\
    \ error: expected '}' at end of brace statement\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>>><>\") == false)\n                                          \
    \                       ^\n/tmp/tmp3abbymc4.swift:18:29: note: to match this opening\
    \ '{'\n    for bracket in brackets {\n                            ^\n/tmp/tmp3abbymc4.swift:91:66:\
    \ error: expected '}' at end of brace statement\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>>><>\") == false)\n                                          \
    \                       ^\n/tmp/tmp3abbymc4.swift:12:51: note: to match this opening\
    \ '{'\nfunc correct_bracketing(brackets: String) -> Bool {\n                 \
    \                                 ^\n/tmp/tmp3abbymc4.swift:18:20: error: for-in\
    \ loop requires 'Int' to conform to 'Sequence'\n    for bracket in brackets {\n\
    \                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let open_counts = brackets.components(separatedBy: \"<\").map({ count($0)\
    \ })\n    let close_counts = brackets.components(separatedBy: \">\").map({ count($0)\
    \ })\n    return open_counts.zip2(close_counts).reduce({ $0 + $1 }) == open_counts.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmpq59oc8c7.swift:13:67: error: cannot find 'count' in scope\n   \
    \ let open_counts = brackets.components(separatedBy: \"<\").map({ count($0) })\n\
    \                                                                  ^~~~~\n/tmp/tmpq59oc8c7.swift:14:68:\
    \ error: cannot find 'count' in scope\n    let close_counts = brackets.components(separatedBy:\
    \ \">\").map({ count($0) })\n                                                \
    \                   ^~~~~\n"
  stdout: ''
  timestamp: 1660009886
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    if brackets.isEmpty {\n        return true\n    }\n\n    if brackets.first\
    \ == \"<\" {\n        for _ in 0..<brackets.count - 1 {\n            if brackets[_+1]\
    \ != \">\" {\n                return false\n            }\n        }\n       \
    \ return true\n    }\n\n    if brackets.first == \"<\" {\n        for _ in 0..<brackets.count\
    \ {\n            if brackets[_+1] != \">\" {\n                return false\n \
    \           }\n        }\n        return true\n    }\n\n    return false\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp63xfp7jt.swift:19:25: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            if brackets[_+1] != \">\" {\n\
    \                        ^\n/tmp/tmp63xfp7jt.swift:28:25: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n            if brackets[_+1]\
    \ != \">\" {\n                        ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \  let bracketSet = brackets.characters.reduce([String]()) {\n    (var result,\
    \ char) -> [String] in\n    if char == \"<\" {\n      if result.last == \"<\"\
    \ {\n        result.append(\"<\")\n      } else {\n        result.append(char)\n\
    \      }\n    } else if char == \">\" {\n      if result.last == \">\" {\n   \
    \     result.append(\"<\")\n      } else {\n        result.append(char)\n    \
    \  }\n    } else if char == \"<\" {\n      result.append(char)\n    }\n    return\
    \ result\n  }\n  return bracketSet.count == brackets.characters.count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\n\
    assert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\"\
    ) == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\n\
    assert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets:\
    \ \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1t93361i.swift:14:6: error: closure cannot have keyword arguments\n\
    \    (var result, char) -> [String] in\n     ^~~~\n     \n/tmp/tmp1t93361i.swift:17:16:\
    \ error: cannot use mutating member on immutable value: 'result' is a 'let' constant\n\
    \        result.append(\"<\")\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
    \ \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n\
    /// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets:\
    \ \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n\
    \    let counts = brackets.split(separator: \"<\").map(String.init).reduce(into:\
    \ [:]) { $0[$1] += 1 }\n    let maxCount = counts.max()!\n    return maxCount\
    \ == brackets.characters.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets:\
    \ \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\n\
    assert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets:\
    \ \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\n\
    assert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\n\
    assert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets:\
    \ \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\"\
    ) == false)"
  status: SyntaxError
  stderr: "/tmp/tmp54guyojf.swift:13:88: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    let counts = brackets.split(separator:\
    \ \"<\").map(String.init).reduce(into: [:]) { $0[$1] += 1 }\n                \
    \                                                                       ^\n/tmp/tmp54guyojf.swift:13:88:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let counts = brackets.split(separator: \"<\").map(String.init).reduce(into:\
    \ [:]) { $0[$1] += 1 }\n                                                     \
    \                                  ^\n                                       \
    \                                                    !\n"
  stdout: ''
  timestamp: 1660009886
