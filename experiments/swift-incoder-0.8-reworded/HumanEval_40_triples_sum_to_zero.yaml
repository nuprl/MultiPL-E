name: HumanEval_40_triples_sum_to_zero
language: swift
prompt: "\n/// triples_sum_to_zero takes an array of integers as an input.\n/// it\
  \ returns true if there are three distinct elements in the array that\n/// sum to\
  \ zero, and false otherwise.\n/// >>> triples_sum_to_zero(l: [1, 3, 5, 0])\n///\
  \ false\n/// >>> triples_sum_to_zero(l: [1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(l:\
  \ [1, 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])\n\
  /// true\n/// >>> triples_sum_to_zero(l: [1])\n/// false\nfunc triples_sum_to_zero(l:\
  \ [Int]) -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(triples_sum_to_zero(l: [1, 3, 5, 0]) ==\
  \ false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)\nassert(triples_sum_to_zero(l:\
  \ [1, 3, -2, 1]) == true)\nassert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)\n\
  assert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)\nassert(triples_sum_to_zero(l:\
  \ [2, 4, -5, 3, 9, 7]) == true)\nassert(triples_sum_to_zero(l: [1]) == false)\n\
  assert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)\nassert(triples_sum_to_zero(l:\
  \ [100, 3, 5, -100]) == false)"
completions: ["    let n = l.count\n    if n < 3 {\n        return false\n    }\n\
    \    let xSum = l.map { $0.x }.reduce(0, +)\n    let ySum = l.map { $0.y }.reduce(0,\
    \ +)\n    let zSum = l.map { $0.z }.reduce(0, +)\n    return xSum == 0 && ySum\
    \ == 0 && zSum == 0", "    guard l.count == 3 else { return false }\n    \n  \
    \  return l.contains(l.first + l.second + l.last)", "  var zeros: [Int] = []\n\
    \  for i in l {\n    for j in zeros {\n      if i != j {\n        for k in zeros\
    \ {\n          if i != j != k {\n            if i != j != k && i != k {\n    \
    \          return true\n            }\n          }\n        }\n      }\n    }\n\
    \    zeros.append(i)\n  }\n  return false", "    guard l.count > 3 else { return\
    \ false }\n    l.sort()\n    for i in 0 ..< l.count - 2 {\n        if l[i] ==\
    \ l[i+1] && l[i] + l[i+1] == 0 {\n            return true\n        }\n    }\n\
    \    return false", "    // Initialize variables\n    var x: Int = IntMax\n  \
    \  var y: Int = IntMax\n    var z: Int = IntMax\n\n    // Iterate through the\
    \ array from last to first\n    for i in (l.length - 1).stride(to: 0) {\n    \
    \    // Compare the current element with the previous\n        if l[i] - l[i -\
    \ 1] != 0 {\n            // If current is bigger than previous\n            if\
    \ x > l[i - 1] {\n                // Set x to current value\n                x\
    \ = l[i - 1]\n            }\n\n            // If current is smaller than previous\n\
    \            if x < l[i - 1] {\n                // Set y to current value\n  \
    \              y = l[i - 1]\n            }\n\n            // If current is equal\
    \ to previous\n            if x == l[i - 1] {\n                // Set z to current\
    \ value\n                z = l[i - 1]\n            }\n        }\n    }\n\n   \
    \ // Check if sum is zero\n    return z == IntMax", "    guard let first: Int\
    \ = l.first, let last: Int = l.last else {\n        return false\n    }\n    var\
    \ sum = 0\n    for i in first...last {\n        sum += l[i]\n    }\n    if sum\
    \ < 0 {\n        return false\n    }\n    return l.count == 3 && abs(sum) == Int(0)",
  "    var i = 0\n    var j = 0\n    var k = 0\n    while i < len(l) {\n        j\
    \ = i + 1\n        while j < len(l) {\n            k = j + 1\n            while\
    \ k < len(l) {\n                if l[i] + l[j] + l[k] == 0 {\n               \
    \     k++\n                }\n                else {\n                    break\n\
    \                }\n            }\n            j++\n        }\n        i++\n \
    \   }\n    return k == 3 && l[0] == 0 && l[1] == 0 && l[2] == 0", "    for x in\
    \ l {\n        for y in l {\n            for z in l {\n                if x ==\
    \ 3 && y == 2 && z == 0 {\n                    return true\n                }\n\
    \            }\n        }\n    }\n    return false", "    var triples_sum_to_zero\
    \ = false\n    var current_sum = 0\n    for triple in l {\n        current_sum\
    \ += triple\n        if current_sum == 3 {\n            triples_sum_to_zero =\
    \ true\n        }\n    }\n    return triples_sum_to_zero", "    guard l.count\
    \ >= 3 else {\n        return false\n    }\n    var sum = 0\n    var i = 0\n \
    \   for v in l {\n        sum += v\n        i++\n    }\n    return sum == 0 &&\
    \ i == 3", '  return is_triple_distinct(l, triple_to_sum)', "\tl += [4]\n\tvar\
    \ sum = 0\n\tfor _, v := range l {\n\t\tsum += v\n\t}\n\treturn sum == 3 && sum\
    \ == 0", "    if l == nil || len(l) == 0 {\n        return false\n    }\n    var\
    \ sum = 0\n    for _, value := range l {\n        sum += value\n    }\n    if\
    \ sum == 0 {\n        return true\n    }\n    var triple int\n    var count int\n\
    \    for _, value := range l {\n        count += int(math.Abs(value) + 1)\n  \
    \      if count > 1 {\n            count -= 1\n            triple++\n        }\n\
    \    }\n    if triple == 3 {\n        return true\n    }\n    return false", " \
    \   // check all the array elements\n    var sum : Int = 0\n    for i in l {\n\
    \        sum += i\n    }\n\n    if sum < 0 {\n        return false\n    }\n\n\
    \    // keep count of how many times we've seen that sum\n    var cnt = 0\n  \
    \  var ans = false\n    for j in l {\n        if j == 0 {\n            ans = true\n\
    \            break\n        } else {\n            cnt += 1\n            if cnt\
    \ > 2 {\n                ans = false\n                break\n            }\n \
    \       }\n    }\n\n    return ans", "    let len = l.count\n    let mut sum =\
    \ 0\n    for i in 0 ..< len {\n        let j = len - i - 1\n        sum += l[j]\n\
    \    }\n    return sum == 0", "  l.sort { $0.0 < $1.0 }\n  return l[0] > 0 &&\
    \ l[1] > 0 && l[2] > 0 && l[0] + l[1] + l[2] == 0 && l[0] != l[1] && l[1] != l[2]",
  "\tvar s Int\n\tvar d Int\n\n\tfor i := 0; i < len(l); i++ {\n\t\tif l[i] > 0 {\n\
    \t\t\ts += l[i]\n\t\t} else {\n\t\t\td += l[i]\n\t\t}\n\t}\n\treturn (s == 0 ||\
    \ d == 0)", "    // initialize our counter with the first element in the list\n\
    \    var counter = 0\n    var total = 0\n\n    // iterate over the list to find\
    \ three distinct elements that sum to zero\n    for elem in l {\n        // if\
    \ the current number is the same as our counter's counter, it\n        // means\
    \ we've found three numbers that sum to zero\n        if counter == elem {\n \
    \           return true\n        }\n        // otherwise update our counter\n\
    \        counter += 1\n        // and add our current element to the total\n \
    \       total += elem\n    }\n\n    // if we made it this far, the list must have\
    \ had three distinct elements\n    // that sum to zero, so return false\n    return\
    \ false", "\tif l == nil || len(l) == 0 {\n\t\treturn false\n\t}\n\tvar i int\n\
    \tvar sum Int = 0\n\tfor _, c := range l {\n\t\tsum += c\n\t\tif sum < 0 {\n\t\
    \t\treturn false\n\t\t}\n\t}\n\tif sum == 0 {\n\t\treturn true\n\t}\n\tfor i =\
    \ 1; i < len(l); i++ {\n\t\tif l[i]-l[i-1] != 0 {\n\t\t\treturn false\n\t\t}\n\
    \t}\n\treturn true", "    guard l.count >= 3 else {\n        return false\n  \
    \  }\n    \n    var sum: Int = 0\n    for i in 0 ..< 3 {\n        sum += l[i]\n\
    \    }\n    var result: Bool = false\n    var j = 0\n    for i in 0 ..< 3 {\n\
    \        result += l[i] == sum\n        if result {\n            j = i + 1\n \
    \           break\n        }\n    }\n    return !result", "    return l.count\
    \ > 2 &&\n        l.reduce(true, { (a, e) -> (Bool)(a&&(e < 0)) }) &&\n      \
    \  l.reduce(true, { (a, e) -> (Bool)(a&&(e == 0)) })", "    for i in 0..<l.count\
    \ {\n        j := i\n        for k = j+1; k < l.count; k++ {\n            l -=\
    \ [l[j]]\n            l += [l[k]]\n            if l.count == 0 {\n           \
    \     return true\n            }\n        }\n    }\n    return false", "\treturn\
    \ triples_sum_to_zero(make(l, l.Count()))", "    if l == nil { return false }\n\
    \    var sum = 0 //\n    var triples = 0 //\n    for _  in l{\n        sum +=\
    \ _\n        triples += 1\n    }\n    if triples == 3 { return true }\n    return\
    \ false", "    var sum = 0\n    for x in l {\n        sum += x\n    }\n    if\
    \ sum == 3 {\n        return true\n    }\n    return false", "  // TODO\n  guard\
    \ l.count >= 3 else {\n    return false\n  }\n\n  // TODO\n  guard l == l.map({$0\
    \ * (3 + 1)}).reduce(0) { $0 + $1 == 0 } else {\n    return false\n  }\n\n  return\
    \ true", "    var l3 = l\n    for _ in 0 ..< 3 {\n        var l2 = l3\n      \
    \  for _ in 0 ..< 3 {\n            var l1 = l2\n            for _ in 0 ..< 3 {\n\
    \                guard let l0 = l1, l1 = l2, l2 = l3 else { return false }\n \
    \           }\n        }\n        l3 = l2\n    }\n    return l3.count == 3", " \
    \   var triples = l\n    var sum = 0\n    \n    for x in triples {\n        sum\
    \ += x\n    }\n\n    var distinct = 0\n    for x in triples {\n        if sum\
    \ != 0 && sum != x {\n            distinct += 1\n        }\n        \n       \
    \ if sum == 0 {\n            return false\n        }\n        \n        sum -=\
    \ x\n    }\n    \n    return distinct == 3", "    var sum: Int = 0\n    var i:\
    \ Int = 0\n    var j: Int = 0\n    var sum_to_zero: Int = 0\n    for i = 0; i\
    \ < l.count - 1; i++ {\n        sum += l[i]\n        if sum < 0 {\n          \
    \  sum_to_zero = -1\n        }\n        sum_to_zero += l[i]\n        if sum_to_zero\
    \ != 0 {\n            for j = i + 1; j < l.count; j++ {\n                sum -=\
    \ l[i]\n                sum -= l[j]\n                sum += l[j]\n           \
    \     if sum == 0 {\n                    return true\n                }\n    \
    \        }\n        }\n    }\n    return false", "    var n = Int()\n    for _i\
    \ in l {\n        n += _i\n    }\n    return n < 3", "    var sum = 0\n    for\
    \ _, b := range l {\n        sum += b\n    }\n    return (sum == 0)", "    if\
    \ l == nil {\n        return false\n    }\n    if l.isEmpty {\n        return\
    \ false\n    }\n    \n    var max = 0\n    var maxIndex = 0\n    var sum = 0\n\
    \    for index in 0..<l.count {\n        if max < l[index] {\n            max\
    \ = l[index]\n            maxIndex = index\n        }\n        sum += l[index]\n\
    \    }\n    \n    if max == 0 {\n        return false\n    }\n    if sum < 0 {\n\
    \        return false\n    }\n    \n    if max != 0 && maxIndex == 0 {\n     \
    \   return true\n    }\n    \n    if max == 0 {\n        return true\n    }\n\
    \    if maxIndex != 0 {\n        return false\n    }\n    \n    if sum == 0 {\n\
    \        return true\n    }\n    return false", '    return countDistinctSumToZero(l)
    == 3', "    for x in l {\n        for y in l {\n            if x == y {\n    \
    \            return false\n            }\n        }\n    }\n    return true",
  "    var sum = 0\n    for _0 in l {\n        sum += _0\n    }\n    return sum >\
    \ 0", "    var triples_sum_to_zero = true\n    var triplesToZero = Set<Int>()\n\
    \n    for triplet in l {\n        if triplet != 0 {\n            if triplesToZero.contains(triplet)\
    \ {\n                triples_sum_to_zero = false\n                break\n    \
    \        }\n            else {\n                triplesToZero.insert(triplet)\n\
    \            }\n        }\n    }\n\n    return triples_sum_to_zero", "\tvar isTrue\
    \ bool\n\n\tfor i := 0; i < len(l); i++ {\n\t\tif i+1 < len(l) {\n\t\t\tif l[i]\
    \ == l[i+1] {\n\t\t\t\tisTrue = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif\
    \ i+2 < len(l) {\n\t\t\tif l[i] == l[i+1] && l[i] == l[i+2] {\n\t\t\t\tisTrue\
    \ = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn isTrue", "    if l.count\
    \ < 3 {\n        return false\n    }\n    for i := 0; i < len(l); i++ {\n    \
    \    if l[i]+l[i+1]+l[i+2] != 0 {\n            return false\n        }\n    }\n\
    \    return true", '    return count_triplets(l) == 3', "    l.sort()\n    var\
    \ result = true\n    for i := 0; i < len(l)-1; i++ {\n        for j := i + 1;\
    \ j < len(l); j++ {\n            result &= (j - i >= 3)\n        }\n    }\n  \
    \  return result", "    var a = l[0]\n    var b = l[1]\n    var c = l[2]\n   \
    \ if a == 0 && b == 0 && c == 0 {\n        return true\n    }\n    if a != 0 ||\
    \ b != 0 || c != 0 {\n        return false\n    }\n    for i := 3; i < len(l);\
    \ i++ {\n        a = a + l[i]\n        b = b + l[i]\n        c = c + l[i]\n  \
    \      if a == 0 && b == 0 && c == 0 {\n            return true\n        }\n \
    \   }\n    return false", "\treturn triples_sum_to_zero_inner(l)", "    if l ==\
    \ nil {\n        return false\n    }\n    var first: Int = 0\n    var second:\
    \ Int = 0\n    var third: Int = 0\n    var fourth: Int = 0\n    for i := 0; i\
    \ < len(l); i++ {\n        if l[i] != 0 {\n            if first == 0 {\n     \
    \           first = l[i]\n                continue\n            }\n          \
    \  if second == 0 {\n                second = l[i]\n                continue\n\
    \            }\n            if third == 0 {\n                third = l[i]\n  \
    \              continue\n            }\n            fourth = l[i]\n          \
    \  break\n        }\n    }\n    if first+second == 0 && first+third == 0 && first+fourth\
    \ == 0 {\n        return true\n    }\n    return false", "    var triplesToZero\
    \ : [Int] = []\n    var triples : [Int] = []\n    \n    guard l.count > 3 else\
    \ { return false }\n    \n    for x in l {\n        if triplesToZero.count ==\
    \ 0 {\n            triplesToZero.append(x)\n        } else {\n            let\
    \ triplesToZero = triplesToZero.sorted(by: {$0 < $1}).map({ $0 + $1 })\n     \
    \       \n            if triplesToZero.count > 0 && triplesToZero[0] == x && triplesToZero[1]\
    \ == x && triplesToZero[2] == x {\n                return true\n            }\
    \ else {\n                triplesToZero.removeAll()\n            }\n        }\n\
    \        \n        if triples.count == 3 {\n            return true\n        }\
    \ else {\n            triples.append(x)\n        }\n    }\n    \n    return false",
  "    let (triplesToZero, triplesToNonZero) = (0..<l.count).filter({ \n        l\
    \ == l.filter { $0 % 3 == 0 }\n    })\n\n    return triplesToZero.count == 3 &&\
    \ triplesToNonZero.count == 3", "    let maxElem = l.maxElement()\n    for elem\
    \ in\n        l.filter { (_, _, _) in\n            elem == maxElem\n        }\
    \ where elem > maxElem {\n        return false\n    }\n    return true", "   \
    \ let n = l.count\n    var i = 0\n    var j = 0\n    var k = 0\n    var s = 0\n\
    \    for j in 0..<n {\n        if i == 0 {\n            s += l[j]\n        }\n\
    \        if i == 1 {\n            s += -l[j]\n        }\n        if i == 2 {\n\
    \            if j == 0 {\n                s += l[j]\n            } else {\n  \
    \              s += -l[j]\n            }\n        }\n        i++\n    }\n    if\
    \ s == 0 {\n        return true\n    } else {\n        return false\n    }", " \
    \   for i in 0..<l.count {\n        if l[i]+l[i+1]+l[i+2] == 0 {\n           \
    \ return true\n        }\n    }\n    return false", "    switch l.count {\n  \
    \  case 1:\n        return l.first == 0\n    case 2:\n        return l.first ==\
    \ l.last && l.first > 0\n    default:\n        var l2 = l.filter{ $0 >= 0 }\n\
    \        if l2.count == 0 {\n            return false\n        }\n        if l2.first\
    \ + l2.last == 0 {\n            return false\n        }\n        return true\n\
    \    }", "\t\n\tguard l.count % 3 == 0, else { return false }\n\t\n\tguard l.count\
    \ == 3 else { return false }\n\t\n\tvar sums: [Int]\n\t\n\tguard let sums = l.map{\
    \ $0 + $0 + $0 } else { return false }\n\t\n\treturn (sums.count == 3 && sums.contains({\
    \ ($0 + $0 + $0) == 0 }))", "    switch l.count {\n    case 3:\n        if l[0]\
    \ + l[1] + l[2] < 0 {\n            return true\n        } else {\n           \
    \ return false\n        }\n    case 2:\n        if l[0] + l[1] < 0 {\n       \
    \     return true\n        } else {\n            return false\n        }\n   \
    \ case 1:\n        if l == nil {\n            return true\n        } else {\n\
    \            return false\n        }\n    default:\n        return false\n   \
    \ }", "    var triplesToZero = [Int]()\n    for x in l {\n        triplesToZero.append(0)\n\
    \    }\n    for i1 in range(len(l) - 1) {\n        for i2 in range(len(l) - 1\
    \ - i1) {\n            triplesToZero[i1 + i2] += l[i1] + l[i2 + i1]\n        }\n\
    \    }\n    for triplesToZero.count < 3 {\n        return false\n    }\n    for\
    \ triplesToZero.count > 3 {\n        return true\n    }\n    for triplesToZero[0]\
    \ < triplesToZero[1] {\n        return false\n    }\n    for triplesToZero[0]\
    \ > triplesToZero[1] {\n        return true\n    }\n    for triplesToZero[0] ==\
    \ triplesToZero[1] && triplesToZero[0] != triplesToZero[2] {\n        return false\n\
    \    }\n    return true", "    var triplesToZero: Set<Int> = []\n    for _ in\
    \ 0 ..< l.count {\n        for _ in 0 ..< 3 {\n            if triplesToZero.contains(l[_])\
    \ {\n                return false\n            }\n            if _ == 3 {\n  \
    \              triplesToZero.insert(l[_])\n            } else {\n            \
    \    triplesToZero.insert(l[_] + l[_ + 1])\n            }\n        }\n    }\n\
    \    return true", "    if l.count == 0 {\n        return true\n    }\n\n    //\
    \ Sort to reduce the number of scans we have to do.\n    l.sort()\n\n    var sum\
    \ = 0\n    var prev: Int?\n\n    for i in 0..<l.count {\n        sum += l[i]\n\
    \n        if prev == nil {\n            // This is the first value in the list\
    \ that is non-zero, so\n            // we can safely consider this a \"sum to\
    \ zero\" test case.\n            return sum == 0\n        }\n\n        if sum\
    \ < 0 {\n            // Negative sums indicate that the first value in the\n \
    \           // list should be rejected instead.\n            return true\n   \
    \     }\n\n        if sum > 0 {\n            // Positive sums indicate that the\
    \ first value in the list\n            // should be accepted instead.\n      \
    \      return false\n        }\n\n        prev = l[i]\n    }\n\n    // There were\
    \ no three distinct elements whose sum is zero.\n    return false", "  if len(l)\
    \ == 0 {\n    return false\n  }\n  if len(l) == 1 {\n    return true\n  }\n  var\
    \ a = l[0]\n  for i := 1; i < len(l); i++ {\n    a += l[i]\n    if a == 0 {\n\
    \      return true\n    }\n  }\n  return false", "    if l.count < 3 {\n     \
    \   return false\n    }\n    var i = 0\n    var j = i + 1\n    var k = 1\n   \
    \ for n in l {\n        if i == j {\n            if n == 0 {\n               \
    \ return true\n            }\n            i += 1\n        }\n        if j == k\
    \ {\n            if n == 0 {\n                return true\n            }\n   \
    \         j += 1\n        }\n        if i == k {\n            if n == 0 {\n  \
    \              return true\n            }\n            k += 1\n        }\n   \
    \ }\n    return false", "    var triples = true\n    for i := 0; i < len(l); i++\
    \ {\n        triples = triples && l[i] == l[i + 3] + l[i + 6]\n    }\n    return\
    \ triples", "    var zeroes = true\n    var i : Int = 0\n    for element in l\
    \ {\n        if element == 0 {\n            zeroes = false\n            break\n\
    \        }\n        i += element\n    }\n    return zeroes", "  var sum = 0\n\
    \  for i in l {\n    sum += i\n    if sum == 3 || sum == 0 {\n      return true\n\
    \    }\n  }\n  return false", "    switch l.count {\n    case 2:\n        return\
    \ l[0] == l[1] && l[1] == 0\n    case 3:\n        return l[0] == l[1] && l[1]\
    \ == l[2]\n    case 4:\n        return l[0] == l[1] && l[1] == l[2] && l[2] ==\
    \ 0\n    default:\n        return false\n    }", "    let n = l.count\n    guard\
    \ n > 1 else {\n        return false\n    }\n\n    var maxTriples = n * n\n  \
    \  for i in 0..<n {\n        for j in 0..<n {\n            for k in 0..<n {\n\
    \                if i != j && j != k && i != k {\n                    maxTriples\
    \ = max(maxTriples, l[i] + l[j] + l[k])\n                }\n            }\n  \
    \      }\n    }\n\n    return maxTriples == 0", "    // initialize to false\n\
    \    var sumToZero = false\n    // find the first index of a pair of elements\
    \ whose sum equals zero\n    var i1 = 0\n    var i2 = 1\n    while i1 < len(l)\
    \ && i2 < len(l) {\n        if l[i1] + l[i2] == 0 {\n            sumToZero = true\n\
    \        }\n        if i2 < len(l) && l[i2] != 0 {\n            i2 += 1\n    \
    \    } else {\n            i1 += 1\n        }\n    }\n    return sumToZero", " \
    \ guard l != nil else {\n    return true\n  }\n  var i = 0\n  var k = l[0]\n \
    \ var v = k\n  var sum = 0\n  var has_triple = false\n  repeat {\n    has_triple\
    \ = has_triple || (l[i] == v)\n    i += 1\n    sum += l[i]\n    k = sum\n    v\
    \ = l[i]\n  } while (i < l.count)\n  return has_triple", '    return triples_sum_to_zero_L(l)',
  "  if l.count%3==0 && l.count==0 {\n    return false\n  }\n  return l.contains(l.filter{$0==l.filter{$0<0}[0]}).contains(l.filter{$0==l.filter{$0<0}[1]}).contains(l.filter{$0==l.filter{$0<0}[2]})",
  "  let sum = l.reduce(0, combine: +)\n  if sum % 3 != 0 {\n    return false\n  }\n\
    \  for i in 0..<l.count {\n    if l[i] == 0 {\n      return false\n    }\n  }\n\
    \  return true", "    var triples_sum_to_zero = false\n    for index in 0...l.count\
    \ {\n        if l[index] == 0 {\n            if triples_sum_to_zero {\n      \
    \          triples_sum_to_zero = false\n            } else {\n               \
    \ triples_sum_to_zero = true\n            }\n        }\n    }\n    return triples_sum_to_zero",
  "    var i = 0\n    var sum = 0\n    var sum2 = 0\n    for number in l {\n     \
    \   sum += number\n        sum2 += number * number\n        i += 1\n    }\n  \
    \  if sum == 0 {\n        return sum2 == 0\n    }\n    if sum2 == 0 {\n      \
    \  return true\n    }\n    for number in l {\n        sum += number\n        sum2\
    \ -= number * number\n        i -= 1\n    }\n    if sum == 0 {\n        return\
    \ sum2 == 0\n    }\n    return false", '    l == nil || len(l) <= 3', "    let\
    \ (first, second, third) = l.sort()\n    let sum = (first + second + third).reduce(0,\
    \ +)\n    return sum == 0", "    let maxSum = l.max() ?? 0\n    let min = l.min()\
    \ ?? 0\n    for num in l {\n        if maxSum == 0 {\n            return false\n\
    \        }\n        let sum = num + maxSum\n        if sum == 0 {\n          \
    \  return false\n        }\n        if sum < 0 {\n            return false\n \
    \       }\n        maxSum -= num\n        if sum > 0 {\n            maxSum = num\
    \ + maxSum\n        }\n    }\n    return true", "    var last = 0\n    for i in\
    \ l {\n        last += i\n    }\n    if last == 0 {\n        return true\n   \
    \ }\n    last--\n    for i in l {\n        last += i\n        if last == 0 {\n\
    \            return true\n        }\n    }\n    return false", "    var sum: Int\
    \ = 0\n    for elem in l {\n        sum += elem\n    }\n    for elem in l {\n\
    \        if elem == 0 {\n            return false\n        }\n    }\n    return\
    \ sum == 0", "    switch l.count {\n    case 3: return true\n    case 2: return\
    \ false\n    default: return (l.reduce(0, {$0 + $1}, {$0 + $1, $1}) == 0)\n  \
    \  }", "  guard l.count >= 3 else { return false }\n\n  var l0 = l.first { $0\
    \ < 0 }\n  var l1 = l.last { $0 >= 0 }\n  var l2 = l.first { $0 > 0 }\n  guard\
    \ l0 != l1 && l0 != l2 else {\n    return false\n  }\n  var l3 = l.last { $0 >=\
    \ 0 }\n  guard l1 != l2 && l1 != l3 else {\n    return false\n  }\n  return l.last\
    \ == l.sum", "    var sum = 0\n    for v in l {\n        sum += v\n    }\n   \
    \ return sum == 0", "    var triples_sum_to_zero = Triples(l, l, l)\n    for i\
    \ := 0; i < len(l); i++ {\n        for j := i + 1; j < len(l); j++ {\n       \
    \     for k := j + 1; k < len(l); k++ {\n                if triples_sum_to_zero.is_unique_triple(i,\
    \ j, k) {\n                    triples_sum_to_zero.remove(i, j, k)\n         \
    \       }\n            }\n        }\n    }\n    return triples_sum_to_zero.is_unique",
  "    var triples [String]\n    for i in l {\n        var triple = \"\\(i)-\\(i -\
    \ \\(i%2))-\\(i - \\(i*2))\"\n        if triples.contains(triple) {\n        \
    \    return false\n        } else {\n            triples.append(triple)\n    \
    \    }\n    }\n    return true", "    let sum = l.filter({ (item) -> Bool in\n\
    \        return item % 2 == 1\n    }).reduce(0) { ($0 + $1), $1 }\n    return\
    \ sum == 0 && l.count == 3", "    if l == nil || l.length < 3 {\n        return\
    \ false\n    }\n    var count = 0\n    for element in l {\n        count += element\n\
    \        if count > 0 {\n            count--\n        }\n        if count == 3\
    \ {\n            return true\n        }\n    }\n    return false", "    if l.isEmpty\
    \ {\n        return false\n    }\n    var sum = 0\n    var prev = 0\n    for e\
    \ := 0; e < l.count; e++ {\n        sum += l[e]\n        if sum == prev {\n  \
    \          return false\n        }\n        prev = sum\n    }\n    return true",
  "    var threeDistinct : Int = 0\n\n    for var i in l {\n        for var j in l\
    \ {\n            for var k in l {\n                if i != j && i != k && j !=\
    \ k {\n                    threeDistinct += 1\n                    if i == i +\
    \ j + k {\n                        return false\n                    }\n     \
    \           }\n            }\n        }\n    }\n\n    return threeDistinct ==\
    \ 3", "    for i in l {\n        if l.contains(i) && l.contains(i + 1) && l.contains(i\
    \ + 2) {\n            if i + 3 == l.count {\n                return true\n   \
    \         }\n        }\n    }\n    return false", "    return helper(l, func(e\
    \ int) bool {\n        return e == 0 || e == -2 || e == -7\n    })", "    var\
    \ triples_sum_to_zero = false\n\n    for i in l {\n        for j in l {\n    \
    \        for k in l {\n                if i+j+k == 0 {\n                    triples_sum_to_zero\
    \ = true\n                    break\n                }\n            }\n      \
    \  }\n    }\n\n    return triples_sum_to_zero", "    for i in l[l.startIndex..]\
    \ {\n        for j in l[i+1..] {\n            for k in l[j+1..] {\n          \
    \      if i != j && i != k && j != k {\n                    return false\n   \
    \             }\n            }\n        }\n    }\n    return true", "  var n =\
    \ l.count\n  var a = 0\n  var b = 0\n  var c = 0\n  var sum = 0\n  var d = 0\n\
    \  for i := 0; i < n; i++ {\n    if i < n / 2 {\n      a = l[i]\n      sum +=\
    \ a\n      b = sum\n      c = 0\n    } else {\n      a = l[i]\n      b = l[n-i-1]\n\
    \      c = l[n-i-1]\n      d += a + b + c\n    }\n    if d == 0 {\n      return\
    \ true\n    }\n  }\n  return false", "    if l == nil || len(l) <= 1 {\n     \
    \   return false\n    }\n    \n    var first = 0\n    var second = 0\n    var\
    \ third = 0\n    \n    for i in 0..<l.count{\n        if l[i] > 0 {\n        \
    \    if first == 0 {\n                first = l[i]\n            } else {\n   \
    \             second = first\n                third = first\n                first\
    \ = 0\n            }\n        } else {\n            if second == 0 {\n       \
    \         second = l[i]\n            } else {\n                third = second\n\
    \                second = 0\n            }\n        }\n    }\n    \n    if first\
    \ > 0 && second > 0 && third > 0 {\n        return true\n    }\n    \n    return\
    \ false", "  var count = 0\n  for _, b in l.enumerated() {\n    count += b\n \
    \   if count == 3 {\n      return true\n    }\n    count = 0\n  }\n  return false",
  "\tvar sum : Int = 0\n\tfor i := 0; i < len(l); i++ {\n\t\tif l[i] > 0 {\n\t\t\t\
    sum += l[i]\n\t\t\tif sum == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\t\
    return true", "    for i in 0 ..< 3 {\n        if l[i] == 0 && l[(i + 1) % 3]\
    \ == 0 && l[(i + 2) % 3] == 0 {\n            return true\n        }\n    }\n \
    \   return false", '    return triples_sum_to_zero_impl(l)', "    let h = l.reduce(0,\
    \ { $0 + $1 })\n    return h == 3", "  func check(_ arr: [Int]) -> Bool {\n  \
    \  var sum = 0\n    var hasCount = 0\n    for i in arr {\n      sum += i\n   \
    \   if hasCount == 3 {\n        return true\n      } else if sum == 0 {\n    \
    \    return false\n      }\n      hasCount += 1\n    }\n    return false\n  }\n\
    \  return check(l)", "\tswitch l.count {\n\tcase 2:\n\t\treturn false\n\tcase\
    \ 3:\n\t\treturn l[0]+l[1]+l[2] == 0\n\tdefault:\n\t\tvar a = l[:]\n\t\ta.sort()\n\
    \t\treturn a[0]+a[1]+a[2] == 0\n\t}", '    return triples_sum_to_zero_(l)', " \
    \   if len(l) == 0 {\n        return false\n    }\n    var sum = 0\n    var triples\
    \ = true\n    for i := 0; i < len(l); i++ {\n        sum += l[i]\n        if sum\
    \ < 0 {\n            triples = false\n            break\n        }\n    }\n  \
    \  return triples", "    guard l.count > 0 else {\n        return false\n    }\n\
    \    if l[0] == 0 {\n        return true\n    }\n    var sum = 0\n    var triplesFound\
    \ = 0\n    for index in 0..<l.count {\n        if l[index] == 0 {\n          \
    \  if triplesFound == 0 {\n                return false\n            }\n     \
    \       triplesFound += 1\n            sum += l[index]\n        } else {\n   \
    \         sum += l[index]\n        }\n    }\n    if sum == 0 {\n        return\
    \ true\n    }\n    return triplesFound == 3", "    for x in l {\n        for y\
    \ in l {\n            if x == y {\n                continue\n            }\n \
    \           if x + y == 0 {\n                return true\n            }\n    \
    \    }\n    }\n    return false", "    var result: Int = 0\n    \n    for i in\
    \ l {\n        if i > 0 && result += i > 0 { // sum of negative numbers is negative\
    \ too\n            return false\n        }\n    }\n    \n    return result ==\
    \ 0", '    return triples_sum_to_zero_helper(l)', "\tif l == nil {\n\t\treturn\
    \ false\n\t}\n\treturn triples_sum_to_zero_impl(l)", "    guard l.count >= 3 else\
    \ { return false }\n    let lastElement = l.last!\n    var sumToZero = false\n\
    \    for elem in l.dropLast() {\n        if elem < lastElement {\n           \
    \ sumToZero = false\n            break\n        } else {\n            sumToZero\
    \ |= elem == 0\n        }\n    }\n    return sumToZero", "    var triples = [Int]()\n\
    \    for x in l {\n        for y in l {\n            triples += [x] * y\n    \
    \    }\n    }\n    let len = l.count\n    if len < 3 {\n        return false\n\
    \    }\n    if triples.contains(0) == false {\n        return false\n    }\n \
    \   if triples.contains(1) == false {\n        return false\n    }\n    if triples.contains(len-1)\
    \ == false {\n        return false\n    }\n    if triples.contains(len-2) == false\
    \ {\n        return false\n    }\n    return true", "  var triples = 0\n  var\
    \ first = 0\n  var second = 0\n  var third = 0\n  for elt in l {\n    if elt >\
    \ 0 {\n      triples++\n      if elt > second {\n        second = elt\n      }\n\
    \      if elt > third {\n        third = elt\n      }\n    }\n  }\n\n  return\
    \ triples*triples+second*second+third*third < 0", "    var sum = 0\n    for i\
    \ in l.indices {\n        sum += l[i]\n    }\n    return sum == 0 || sum == l.count\
    \ - 1", "    var triples_sum_to_zero = false\n    var sum_of_triples = 0\n   \
    \ for n in l {\n        sum_of_triples += n\n    }\n    for n in l {\n       \
    \ if sum_of_triples > 0 {\n            if n == sum_of_triples {\n            \
    \    triples_sum_to_zero = true\n            }\n        }\n        else {\n  \
    \          sum_of_triples += n\n        }\n    }\n    return triples_sum_to_zero",
  "    if l == nil || l.count < 3 {\n        return false\n    }\n    var results:\
    \ [Int]\n    var sum = 0\n    for x in l {\n        sum += x\n        if sum <\
    \ 0 {\n            sum = -sum\n        }\n        if sum > 0 {\n            results.append(sum)\n\
    \        }\n    }\n    // check if three results exist that sum to 0\n    for\
    \ x in results {\n        if x == 3 {\n            return true\n        }\n  \
    \  }\n    return false", "\tswitch l.count {\n\tcase 0:\n\t\treturn false\n\t\
    case 1:\n\t\treturn l[0] == 0\n\tdefault:\n\t\tvar zeros = Ints()\n\t\t_ = scanl1(l,\
    \ &zeros)\n\t\treturn zeros.count == 3\n\t}", "    var result = [Int]()\n    var\
    \ currentSum = 0\n    for i in l {\n        currentSum += i\n        if currentSum\
    \ > 0 {\n            result.append(currentSum)\n        }\n    }\n    return result.count\
    \ == 3 &&\n        result[0] >= 0 && result[1] >=0 && result[2] >= 0", "    if\
    \ l.isEmpty() {\n        return true\n    }\n    \n    // Initialize sum and i\
    \ variables.\n    var sum, i : Int\n    \n    // Get the first element of l.\n\
    \    sum = l[0]\n    i = 0\n    \n    // Loop from 1 to the length of the array.\n\
    \    for i = 1; i < l.count; i++ {\n        if sum + l[i] == 0 {\n           \
    \ sum = 0\n        } else {\n            sum += l[i]\n        }\n    }\n    \n\
    \    // Return the answer in variable sum.\n    return sum == 0", "    if l.count\
    \ == 0 {\n        return false\n    }\n    \n    // We need to scan the array\
    \ three times to make sure that the first and\n    // last elements add up to\
    \ zero.\n    var sum1 = l.slice([0, -1]).reduce(0, +) + l[0]\n    var sum2 = l.slice([0,\
    \ -1]).reduce(0, +) + l[1]\n    var sum3 = l.slice([0, -1]).reduce(0, +) + l[2]\n\
    \    \n    return !(sum1 == 0 || sum2 == 0 || sum3 == 0)", "    var triples =\
    \ false\n    for i := 0; i < len(l); i += 3 {\n        if l[i] + l[i+1] + l[i+2]\
    \ != 0 {\n            triples = true\n            break\n        }\n    }\n  \
    \  return triples", '    return triples_sum_to_zero_helper(l, 0, 0, 0)', "\tl.sort()\n\
    \treturn triples_sum_to_zero_(l, &l.count)", "  var a: [Int]\n  var b: [Int]\n\
    \  var c: [Int]\n  for _ in 0..<3 { // O(n)\n    a = random_integers(1, 100, 3)\n\
    \    b = random_integers(1, 100, 3)\n    c = random_integers(1, 100, 3)\n    if\
    \ a[a..<a.last] + b[b..<b.last] + c[c..<c.last] == 0 {\n      return false\n \
    \   }\n  }\n  return true", "    var sum = 0\n    for i in l {\n        sum +=\
    \ i\n    }\n    return sum == 3 && sum == 0 && !contains(sum, l)", "  if l ==\
    \ nil {\n    return false\n  }\n  if l.count < 3 {\n    return false\n  }\n  var\
    \ total: Int = 0\n  for number in l {\n    total += number\n  }\n  return total\
    \ == 0", "    // This is an O(n^3) algorithm, but since we only need to check\
    \ three\n    // distinct elements we might as well just sort the array and count\
    \ the\n    // occurrences of three consecutive elements that sum to zero. Three\
    \ will\n    // be checked at most 3 times, so the runtime is O(n).\n\n    // If\
    \ the array is empty, all three consecutive elements must have sum\n    // equal\
    \ to zero.\n    if len(l) == 0 {\n        return true\n    }\n\n    // Sort the\
    \ array in descending order\n    l.sort()\n    l.sort()\n\n    // The number of\
    \ elements equals three times the number of distinct elements\n    // minus one.\n\
    \    var triples = 0\n\n    for i := 0; i < len(l); i++ {\n        if i != 0 {\n\
    \            triples = triples * 3\n        }\n\n        for j := i + 1; j < len(l);\
    \ j++ {\n            triples += l[i] - l[j]\n            if triples == 0 {\n \
    \               return true\n            }\n        }\n    }\n\n    return false",
  "    var sum = 0\n    var first = true\n    for val in l {\n        if !first {\n\
    \            sum += val\n            if sum > 0 {\n                return false\n\
    \            }\n        } else {\n            sum += val\n        }\n        first\
    \ = false\n    }\n    return true", "    guard l.count >= 3 else {\n        return\
    \ false\n    }\n    var s = l.map { $0 + $0 }\n    var m = s.reduce(0) {\n   \
    \     ($0 + $1) % 3\n    }\n    return m == 0", "    var sum: Int = 0\n    for\
    \ x in l {\n        sum += x\n    }\n\n    return (sum == 3 && sum != 0)", " \
    \   guard !l.isEmpty else {\n        return true\n    }\n\n    var sum = 0\n \
    \   for i in l {\n        sum += i\n    }\n\n    return sum < 0", "    if l ==\
    \ nil || l.count < 3 {\n        return false\n    }\n    var d = 0\n    for x\
    \ in l {\n        if x > 0 {\n            d += x\n        }\n    }\n    return\
    \ (d == 0) == (l[0] == l[1] && l[1] == l[2])", '  return isUnique(l, isSumOfThree,
    or: isNegativeSum)', "    l += [0]\n    for i in l+[2]+[0] {\n        for j in\
    \ l+[0]+[2]+[0] {\n            if i*j == 0 {\n                return true\n  \
    \          }\n        }\n    }\n    return false", "  var i = 0\n  var j = -1\n\
    \  var k = -1\n  var found = 0\n  var found1 = false\n  var found2 = false\n \
    \ for _ in 0..<l.count {\n    if i == 0 || j == 0 || k == 0 {\n      if !found1\
    \ {\n        i = i + 1\n        if i == l.count {\n          found = true\n  \
    \        continue\n        } else {\n          found1 = true\n        }\n    \
    \  }\n      if j == 0 {\n        j = j + 1\n        if j == l.count {\n      \
    \    found = true\n          continue\n        } else {\n          found1 = true\n\
    \        }\n      }\n      if k == 0 {\n        k = k + 1\n        if k == l.count\
    \ {\n          found = true\n          continue\n        } else {\n          found1\
    \ = true\n        }\n      }\n    }\n\n    i = i + 1\n    if i == l.count {\n\
    \      found = true\n      continue\n    } else {\n      found1 = true\n    }\n\
    \    j = j - 1\n    if j == -1 {\n      found2 = true\n    }\n    k = k - 1\n\
    \    if k == -1 {\n      found2 = true\n    }\n    if found1 && found2 && found\
    \ {\n      return true\n    }\n  }\n  return false", "    if l.count == 3 {\n\
    \        let a = l[0]\n        let b = l[1]\n        let c = l[2]\n        if\
    \ b == 0 && c == 0 || a == 0 && c == 0 {\n            return true\n        }\n\
    \    }\n    return false", "    var x = 0\n    var y = 0\n    var z = 0\n    for\
    \ x < (len(l) - 1); x += 2 {\n        if l[x] > 0 {\n            if y != l[x]\
    \ {\n                y = l[x]\n            }\n        } else {\n            if\
    \ z != l[x] {\n                z = l[x]\n            }\n        }\n    }\n   \
    \ return z == 0 && y == 0", "    if l == nil || len(l) == 0 {\n        return\
    \ false\n    }\n    \n    \n    var a = 0\n    var b = 0\n    var c = 0\n    \n\
    \    for e in l {\n        c += e\n        if a < c {\n            a = c\n   \
    \         b = e\n        }\n    }\n    \n    \n    return b == 0 && a == c", "\t\
    switch l.len() {\n\tcase 1:\n\t\treturn false\n\tcase 2:\n\t\treturn l[0] == 0\
    \ && l[1] == 0\n\tcase 3:\n\t\treturn l[0] == 0 || l[1] == 0 || l[2] == 0\n\t\
    default:\n\t\tfor i := 0; i < len(l); i++ {\n\t\t\tl1 := l\n\t\t\tl1[i] = 0\n\t\
    \t\tsum := 0\n\t\t\tfor _, l2 := range l1 {\n\t\t\t\tif i == 0 {\n\t\t\t\t\tsum\
    \ += l2\n\t\t\t\t} else {\n\t\t\t\t\tsum -= l2\n\t\t\t\t}\n\t\t\t}\n\t\t\tif sum\
    \ != 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}", "\tlet\
    \ firstIndex = l.startIndex\n\tlet lastIndex = l.endIndex\n\n\tguard lastIndex\
    \ ~= firstIndex else {\n\t\treturn false\n\t}\n\n\tfor var i = firstIndex; i <\
    \ lastIndex; i += 2 {\n\t\tif l[i] == 0 && l[i + 1] == 0 {\n\t\t\treturn true\n\
    \t\t} else if l[i] == l[i + 1] {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn false\n\t\
    }\n\n\treturn false", "\treturn triples_sum_to_zero_helper(l, 0, 3, 0)", "   \
    \ l += [0]\n    l.sort()\n    guard l.count >= 3 else {\n        return false\n\
    \    }\n    var sum: Int = 0\n    for i in 0..<3 {\n        sum += l[i]\n    }\n\
    \    return sum == 0", "    var sum = 0\n    for elem in l {\n        sum += elem\n\
    \    }\n    return (sum == 3) || !(sum == 0)", "    if len(l) < 3 {\n        return\
    \ true\n    }\n    var sum: Int\n    var n: Int\n    for n in 0..<3 {\n      \
    \  sum += l[n]\n    }\n    if sum != 0 {\n        return false\n    }\n    sum\
    \ = 0\n    for n in 1..<len(l) {\n        sum += l[n]\n        if sum != 0 {\n\
    \            return false\n        }\n    }\n    return true", "  var sum = 0\n\
    \  var is_triple_sum_to_zero = false\n  for n in l {\n    if n == 0 {\n      break\n\
    \    }\n    sum += n\n    is_triple_sum_to_zero = (sum > 0)\n  }\n  return is_triple_sum_to_zero",
  "\tvar l2 = Array(l)\n\tl2.sort()\n\tfor i, j := 0, 1; i < l2.length && j < l2.length;\
    \ i++ {\n\t\tif l2[i] > l2[j] {\n\t\t\tbreak\n\t\t}\n\t\tif l2[i] == l2[j] {\n\
    \t\t\tif i != j {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tj++\n\t}\n\treturn\
    \ true", "    var result = true\n    var i = 0\n    for a in l {\n        if i\
    \ == 0 {\n            result = a == 0\n        } else {\n            result =\
    \ result && a > 0\n        }\n        i++\n    }\n    return result", "    var\
    \ triples = 0\n    var triples_sum_to_zero = true\n    for x in l {\n        triples_sum_to_zero\
    \ = triples_sum_to_zero &&\n            (x == 0 || x == 3 || x == -2)\n      \
    \  triples = triples + 1\n        if triples == 3 {\n            return triples_sum_to_zero\n\
    \        }\n    }\n    return triples_sum_to_zero", "  var num: Int = 0\n  for\
    \ i in l {\n    if i != 0 {\n      if num == 0 {\n        return false\n     \
    \ }\n      num += 1\n    }\n  }\n  return num == 3", "  var a = [Int]()\n  var\
    \ t: [Int] = [0]\n  var count = 0\n  var i = 0\n  for k in l {\n    count += k\n\
    \    i += 1\n    if count == 0 {\n      continue\n    }\n    a[i] = count\n  \
    \  t += k\n  }\n  return count != 0", "    if l[0] == l[1] && l[0] == l[2] {\n\
    \        if l[1]+l[2] == 0 {\n            return true\n        }\n        if l[1]+l[2]\
    \ == l[0] {\n            return true\n        }\n        if l[1]+l[2] != l[0]\
    \ {\n            return false\n        }\n    }\n    return false", "    let set:\
    \ Set<Int> = Array(l)\n    let triples_sum_to_zero = set.count <= 2\n    for (_,\
    \ elem) in set.enumerated() {\n        if elem != 0 {\n            triples_sum_to_zero\
    \ = triples_sum_to_zero && elem != set.last\n        }\n    }\n    return triples_sum_to_zero",
  "    if l == nil { return false }\n    if l.count == 0 { return false }\n    if\
    \ l.count < 3 { return false }\n    let sum = l.reduce(0)\n    if sum % 3 == 0\
    \ { return true }\n    return false", "\tguard l.count == 3 else { return false\
    \ }\n\tguard l.contains(0) else { return false }\n\tguard l.contains(l.max() -\
    \ 1) else { return false }\n\tguard l.contains(l.min()) else { return false }\n\
    \tguard l.sorted() == [0, l.max() - 1, l.min() ] else { return false }\n\tguard\
    \ l.map({$0 * $0}).sum() == 0 else { return false }\n\treturn true", "\tswitch\
    \ {\n\tcase len(l) == 3:\n\t\treturn l[0] + l[1] + l[2] == 0\n\tdefault:\n\t\t\
    return false\n\t}", "\tlet mut set = Set()\n\tfor i in l.windows(3) {\n\t\tif\
    \ !set.contains(i as Int) {\n\t\t\tset.insert(i as Int)\n\t\t}\n\t}\n\treturn\
    \ set.count == 0", "    var sum = 0\n    for x in l {\n        sum += x\n    }\n\
    \    for x in l {\n        if x == 0 {\n            return false\n        }\n\
    \    }\n    for x in l {\n        if x == sum {\n            return true\n   \
    \     }\n    }\n    return false", "    var min = 0\n    var max = l.count - 1\n\
    \    var found = false\n\n    for (i in 0..<l.count) {\n        if (l[i] > min\
    \ && l[i] < max && l[i] == (l[i] + l[i+1] + l[i+2])) {\n            found = true\n\
    \        }\n    }\n\n    return found", "    let sortedL = l.sorted()\n    let\
    \ total = 0\n    for x in sortedL {\n        total += x\n        if total >= 3\
    \ {\n            return true\n        }\n    }\n    return false", "    var zeros\
    \ = Int()\n    var threes = 0\n\n    for index in 0..<l.count {\n        let element\
    \ = l[index]\n        if element == 0 {\n            zeros += 1\n        } else\
    \ {\n            threes += 1\n        }\n    }\n\n    return zeros == threes",
  "    var triplesToZero = 0\n\n    for _, b := range l {\n        if b == 0 {\n \
    \           triplesToZero += 1\n        }\n    }\n\n    return triplesToZero <\
    \ 3", "  if l == nil {\n    return true\n  }\n  sum_to_zero := 0\n  for _, num\
    \ := range l {\n    if num > 0 {\n      sum_to_zero += num\n    }\n  }\n  return\
    \ sum_to_zero % 3 == 0", "    var triples: [(Int, Int, Int)] = []\n    for x in\
    \ l {\n        let triple = (x-1, x, x+1)\n        if triple.first > 0 && triple.second\
    \ > 0 && triple.third > 0 {\n            triples.append(triple)\n        }\n \
    \   }\n    return triples.isEmpty || (triples.count == 3 && triples.reduce(true)\
    \ { $0 && $1 == triple.first && $2 == triple.second && $3 == triple.third })",
  "    var result: Bool = false\n    for i in 0..<l.count {\n        var triples =\
    \ triples(l)\n        for j in 0..<triples.count {\n            let triple = triples[j]\n\
    \            if triples[i]+triples[j] < 0 {\n                result = (triples[i]+triples[j]\
    \ <= 0)\n                break\n            }\n        }\n        if result {\n\
    \            break\n        }\n    }\n    return result", "\tresult := false\n\
    \tfor i := 0; i < len(l); i++ {\n\t\tj := 0\n\t\tfor k := i; k < len(l); k++ {\n\
    \t\t\tresult += l[i] + l[k] == 0\n\t\t\tj++\n\t\t}\n\t\tif result == true {\n\t\
    \t\tbreak\n\t\t}\n\t}\n\treturn result", "    var triples = 0\n    var triples_sum_to_zero\
    \ = false\n\n    for x in l {\n        triples = triples * 3\n        triples_sum_to_zero\
    \ = triples_sum_to_zero || x != 0 && x != -x && x == abs(x) && triples != 0\n\
    \        triples = triples + 1\n    }\n    return triples_sum_to_zero", "    var\
    \ sum = 0\n    for i in l {\n        sum += i\n    }\n    return sum == 0", " \
    \   var triples = 0\n    var triples_to_zero = 0\n    for x in l {\n        if\
    \ triples == 0 {\n            triples = x\n        } else {\n            triples_to_zero\
    \ += x\n        }\n        if triples_to_zero == 3 {\n            return true\n\
    \        }\n    }\n    return false", "    var t = 0\n    for i := 0; i < len(l);\
    \ i++ {\n        t = t + l[i]\n        if t == 0 {\n            return true\n\
    \        }\n    }\n    return false", "    var a : [Int]\n    for element in l\
    \ {\n        appendIfNotPresent(&a, element)\n    }\n    for element in a {\n\
    \        if let indexToCheck = a.index(of: element) { //\n            swap(&a[indexToCheck],\
    \ &a[indexToCheck+1]) //\n        }\n    }\n    return a.count < 3", "    var\
    \ hasThreeZeroes: Bool = false\n    var hasTwoZeroes: Bool = false\n    for _,\
    \ b := range l {\n        if b == 0 {\n            if !hasTwoZeroes && b == 0\
    \ {\n                hasTwoZeroes = true\n            } else if hasTwoZeroes {\n\
    \                hasTwoZeroes = false\n            } else {\n                hasThreeZeroes\
    \ = true\n            }\n        } else {\n            if !hasThreeZeroes && b\
    \ == 0 {\n                hasThreeZeroes = true\n            } else if hasThreeZeroes\
    \ {\n                hasThreeZeroes = false\n            }\n        }\n    }\n\
    \    return hasThreeZeroes", "    \n    var triple_sum_to_zero : Int = 0\n   \
    \ \n    for x in l {\n        triple_sum_to_zero = triple_sum_to_zero + x\n  \
    \  }\n    \n    if triple_sum_to_zero < 3 {\n        return false\n    } else\
    \ {\n        return true\n    }", "    let len = l.count\n    if len < 3 {\n \
    \       return false\n    }\n    var sum = 0\n    var tripled = false\n    for\
    \ i in 0..<len - 2 {\n        if i < len - 2 {\n            sum += l[i]\n    \
    \    }\n        if i < len - 1 {\n            sum += l[i + 1]\n        }\n   \
    \     if i < len - 1 {\n            sum += l[i + 2]\n        }\n        if sum\
    \ >= 0 {\n            if sum == 0 {\n                tripled = true\n        \
    \    }\n        }\n    }\n    return tripled", "    for i in 0..<l.count {\n \
    \       sum, j, _ := triples_sum_helper(l[i..])\n        if sum == 0 {\n     \
    \       return true\n        }\n    }\n    return false", '    return contains(triples(l),
    0, where: isDistinct)', "    if l == nil || l.isEmpty {\n        return true\n\
    \    }\n\n    var i = 0\n    var j = 0\n    var k = 0\n\n    for k in 0..<l.count\
    \ {\n        i += l[k]\n        j += l[k]\n        if i >= j {\n            break\n\
    \        }\n    }\n\n    return i != j", "    if l.isEmpty {\n        return false\n\
    \    }\n    var zeros: [Int] = []\n    var s = Int()\n    for x in l {\n     \
    \   if x == 0 {\n            zeros.append(x)\n        }\n        else {\n    \
    \        s = s + x\n            if s == 0 {\n                return true\n   \
    \         }\n        }\n    }\n    return false", '    l == nil || len(l) <= 3
    || l.reduce(0) { $0 + ($1 * $2) } == 0', "\tvar s = Set()\n\tfor i := 0; i < len(l);\
    \ i++ {\n\t\tif !s.insert(l[i]).inserted {\n\t\t\treturn false\n\t\t}\n\t}\n\t\
    return true", "    switch l.count {\n    case 3:\n        let xi = l[0] + l[1]\n\
    \        let yi = l[0] + l[2]\n        let zi = 0 + l[0] + l[1]\n        return\
    \ (xi == 0 && yi == 0 && zi == 0)\n    case 2:\n        let xi = l[0]\n      \
    \  let yi = l[1]\n        let zi = 0 + l[0] + l[1]\n        return (xi == 0 &&\
    \ yi == 0 && zi == 0)\n    case 1:\n        let xi = l[0]\n        let zi = 0\
    \ + l[0]\n        return (xi == 0 && zi == 0)\n    default:\n        return false\n\
    \    }", "    switch l.count {\n    case 0:\n        return false\n    case 1:\n\
    \        return l[0] > 0\n    case 2:\n        return l[0] == 0 && l[1] == 0\n\
    \    default:\n        let min = l[0] < 0 ? l[0] : 0\n        let max = l[0] <\
    \ 0 ? 0 : l[0]\n        return sum_to_zero(l: l.dropFirst(), min: min, max: max)\
    \ == true\n    }", "    for i := 0; i < len(l); i += 3 {\n        if l[i] == l[i+1]\
    \ && l[i+1] == l[i+2] {\n            return true\n        }\n    }\n    return\
    \ false", '  return triples_sum_to_zero_inline(l)', "    if l == nil || len(l)\
    \ == 0 {\n        return false\n    }\n\n    var sum = 0 /* sum */\n    var hasMultiples\
    \ = false /* if multiples found */\n    var currentSum = 0\n\n    for x in l {\n\
    \        if x > 0 {\n            sum += x\n        } else {\n            if sum\
    \ > 0 {\n                hasMultiples = true\n            }\n            currentSum\
    \ = 0\n        }\n        if currentSum > 0 && sum != 0 {\n            hasMultiples\
    \ = true\n        }\n    }\n    if hasMultiples {\n        return false\n    }\n\
    \    for x in l {\n        if x == 0 {\n            return false\n        }\n\
    \        sum -= x\n    }\n    return true", "    if l.count < 3 {\n        return\
    \ true\n    }\n    var triples = [Int]()\n    var triples_sum = 0\n    for x in\
    \ l {\n        triples_sum += x\n        if triples_sum < 0 {\n            triples_sum\
    \ = 0\n        } else {\n            triples.append(x)\n        }\n    }\n   \
    \ let result = triples.count >= 3 && !triples.contains(triples_sum)\n    return\
    \ result", "    var sum = 0\n    for k in l {\n        sum += k\n    }\n    return\
    \ sum == 0", "    var i = 0\n    var sum : Int = 0\n    var triple = false\n \
    \   for _ in 0 ..< l.count {\n        if i == 0 {\n            sum = l[i]\n  \
    \      } else {\n            sum += l[i]\n            if sum == 0 {\n        \
    \        triple = true\n            } else {\n                triple = false\n\
    \            }\n        }\n        i += 1\n    }\n    return triple", "\tl ==\
    \ nil || len(l) < 3 || l[0] + l[1] + l[2] < 0", '    return triples_sum_to_zero(l,
    l: l, l: l)', "    var result = 0\n    for x in l {\n        result += x\n   \
    \ }\n    for x in l {\n        result -= x\n        if result < 0 {\n        \
    \    return false\n        }\n    }\n    return true", "  if l.count < 3 {\n \
    \   return false\n  }\n  var last: Int\n  for idx in 0..<3 {\n    last = l[idx+2]\n\
    \    if last == 0 || l[idx] == 0 {\n      continue\n    }\n    if last != l[idx]\
    \ + l[idx+1] {\n      return true\n    }\n  }\n  return false", "    // if l contains\
    \ three 0s or all 0s then the array contains three zeros or all 0s\n    return\
    \ l.count > 2 || (l.count == 2 && l[0] == l[1] == l[2])", "  let h = l.count\n\
    \  if h < 3 {\n    return false\n  }\n  var i = 0\n  var j = h - 1\n  var k =\
    \ 0\n  var c = 0\n  while i <= j {\n    if l[i] > 0 {\n      c += 1\n    }\n \
    \   i += 1\n  }\n  while k <= j {\n    if l[k] <= 0 {\n      c += 1\n    }\n \
    \   k += 1\n  }\n  return c == 3 && c == l && c > 0", "    var sum = 0\n    var\
    \ triple = 0\n    for i in l {\n        sum += i\n        triple = 3*sum\n   \
    \     if triple+i >= 0 {\n            return true\n        }\n    }\n    return\
    \ false", "  let size = l.count\n  var sums = [0] * (size + 1)\n\n  for i in 0..<size\
    \ {\n    sums[i + 1] = sums[i] + l[i]\n  }\n\n  var j = 0\n  for k = 0 to (size\
    \ - 2) {\n    if sums[k] > 0 && sums[k + 1] > 0 && sums[k + 2] > 0 {\n      break\n\
    \    }\n\n    sums[k + 1] = sums[k] + l[k]\n  }\n  if sums[j] == 0 {\n    return\
    \ true\n  }\n  return false", "\tswitch len(l) {\n\tcase 0:\n\t\treturn false\n\
    \tcase 1:\n\t\treturn l[0] == 0\n\tcase 2:\n\t\treturn l[0] == 0 && l[1] == 0\n\
    \tdefault:\n\t\tswitch {\n\t\tcase l[0] == l[1]:\n\t\t\treturn true\n\t\tcase\
    \ l[1] > l[0]:\n\t\t\treturn l[0] == 0\n\t\tcase l[1] < l[0]:\n\t\t\treturn l[1]\
    \ == 0\n\t\t}\n\t}", "\tswitch len(l) {\n\tcase 0:\n\t\treturn true\n\tcase 1:\n\
    \t\treturn l[0] == 0\n\tcase 2:\n\t\treturn l[0] == 0 && l[1] == 0\n\tcase 3:\n\
    \t\treturn l[0] == 0 || l[1] == 0 || l[2] == 0\n\tdefault:\n\t\tfor i := 1; i\
    \ < len(l); i++ {\n\t\t\tfor j := i - 1; j >= 0; j-- {\n\t\t\t\tif l[j] + l[j+1]\
    \ == 0 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true\n\
    \t}", "    let maxSum = l.max()!\n    for i in 0..<l.count {\n        let j =\
    \ i+1\n        let sum = l[i] + l[j] + l[j]\n        if sum == 0 && maxSum > 0\
    \ {\n            return true\n        }\n        if sum > maxSum {\n         \
    \   maxSum = sum\n        }\n    }\n    return false", "\tlet mut sum = 0;\n\t\
    for el in l {\n\t\tsum += el;\n\t}\n\tfor el in l {\n\t\tif el != 0 {\n\t\t\t\
    return el == 0 && sum == 0;\n\t\t}\n\t}\n\treturn false;", "    switch l {\n \
    \   case _: case let l as Int:\n        if l <= 0 {\n            return false\n\
    \        }\n        if l == 1 {\n            return true\n        }\n        if\
    \ l == 2 {\n            return true\n        }\n        return false\n    case\
    \ let l as [Int]:\n        let set = Array(Set(l))\n        let hasOne = set.contains(1)\n\
    \        let hasTwo = set.contains(2)\n        let hasThree = set.contains(3)\n\
    \        return hasOne && hasTwo && hasThree\n    }", "  var s = l[0]\n  for x\
    \ in l[1:] {\n    if s == x {\n      continue\n    }\n    if s > x {\n      s\
    \ = x\n    }\n  }\n  return s == 0", "\tif l == nil {\n\t\treturn false\n\t}\n\
    \tif len(l) <= 2 {\n\t\treturn true\n\t}\n\tlLen := len(l)\n\tl := l[:lLen - 1]\n\
    \tfor i := 1; i < lLen-1; i++ {\n\t\ttotal := 0\n\t\tfor j := 0; j < i; j++ {\n\
    \t\t\ttotal += l[j]\n\t\t\tif total > 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t\
    if total != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true", "    var first\
    \ = 0, second = 0, third = 0, sum = 0\n    for x in l {\n        sum = first +\
    \ second + third\n        first = second\n        second = third\n        third\
    \ = x\n        if sum == 0 {\n            return true\n        }\n    }\n    return\
    \ false", "\tif l == nil {\n\t\treturn false\n\t}\n\tguard let l = l as? [Int]\
    \ else {\n\t\treturn false\n\t}\n\t// TODO: Optimize for small inputs\n\tlet nums\
    \ = l.sorted()\n\treturn nums.reduce(true) { $0 && nums.contains($1) + nums.contains($2)\
    \ }", "    var i = 0\n    var j = i + 1\n    var k = 0\n    for x in l {\n   \
    \     if k == 3 {\n            break\n        }\n        for y in l {\n      \
    \      for z in l {\n                if i == x && j == y && k == z {\n       \
    \             return true\n                }\n                i += 1\n       \
    \         j += 1\n                k += 1\n            }\n        }\n    }\n  \
    \  return false", "    var sum = 0\n    for x in l {\n        sum += x\n    }\n\
    \    return sum == 0", "  var triples: [(Int, Int, Int)] = [(0,0,0)]\n  for num\
    \ in l {\n    for trip in triples {\n      if trip[1]+trip[2]+trip[0] == num {\n\
    \        trip = (trip[1], trip[2], trip[0]+1)\n      }\n    }\n  }\n  return triples.count\
    \ == 3 && triples.contains[0] == triples.contains[1] && triples.contains[1] ==\
    \ triples.contains[2]", '    return triples_sum_to_zero_impl(l)']
stop_tokens:
- "\n}"
