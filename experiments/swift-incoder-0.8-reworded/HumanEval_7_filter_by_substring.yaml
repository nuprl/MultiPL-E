name: HumanEval_7_filter_by_substring
language: swift
prompt: "\n/// Filter an input array of strings only for ones that contain given substring\n\
  /// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as\
  \ [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"\
  array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings:\
  \ [String], substring: String) -> [String] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(filter_by_substring(strings: [] as [String],\
  \ substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\"\
  ) == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
  , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") ==\
  \ [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
  \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
  grunt\", \"prune\"])"
completions: ['    return strings.filter({ $0.contains(substring) })', "  guard let\
    \ pattern = try? NSRegularExpression(pattern: substring, options: []) else { return\
    \ strings }\n  return strings.filter { pattern!.matches($0, options: []) }", " \
    \   var filtered = [String]()\n    strings.forEach() {\n        if strings.index(of:\
    \ substring) != nil {\n            filtered = filtered + this\n        }\n   \
    \ }\n    return filtered", '    return filter_string_for_substring(strings, substring,
    false)', "    var result = [String]()\n    for string in strings {\n        if\
    \ string.contains(substring) {\n            result.append(string)\n        }\n\
    \    }\n    return result", "    let start = substring.startIndex\n    let end\
    \ = substring.endIndex\n    return strings.filter() {\n        substring($0, start,\
    \ end) == true\n    }", '  return strings.filter({ $0.hasPrefix(substring) })',
  '    strings.filter { $0.contains(substring) }', "    let filtered: [String] = strings.filter\
    \ {\n        let index = $0.index(substring, options: .caseInsensitive)\n    \
    \    return index != nil\n    }\n    return filtered", "    var result = strings\n\
    \    for string in strings {\n        if string.contains(substring) {\n      \
    \      result = result.filter{ $0 != string }\n        }\n    }\n    return result",
  "    let strings = strings.filter { $0.contains(substring) }\n    return strings",
  "    var filtered = strings\n    for i := 0; i < len(strings); i++ {\n        if\
    \ strings[i].contains(substring) {\n            filtered = filtered[filtered.indices.filter{\
    \ $0 != i }: filtered.indices.dropFirst()]\n        }\n    }\n    return filtered",
  "    guard let firstIndex = strings.firstIndex(of: substring) else { return strings\
    \ }\n    return strings.indices.contains(firstIndex) ? strings[firstIndex..<strings.endIndex]\
    \ : strings", "    var filteredStrings: [String] = []\n    strings.enumerated().forEach\
    \ { idx, str in\n        if str.hasSuffix(substring) {\n            filteredStrings.append(str)\n\
    \        }\n    }\n    return filteredStrings", "\tstrings := strings.MapBySlice(func(i\
    \ int) func(j int) bool {\n\t\treturn strings.Contains(strings[i], substring)\n\
    \t})\n\treturn strings", "    \n    var filtered: [String] = []\n    \n    for\
    \ string in strings {\n        \n        if string.contains(substring) {\n   \
    \         \n            filtered.append(string)\n        }\n    }\n    \n    return\
    \ filtered", "  guard !strings.isEmpty else {\n    return strings\n  }\n\n  let\
    \ filtered = strings\n    .enumerated()\n    .filter { index, string in\n    \
    \  let containsSubstring = string.lowercased().rangeOfString(substring) != nil\n\
    \      guard containsSubstring else {\n        return false\n      }\n      return\
    \ index == 0\n    }\n    .map { index, string -> String in\n      return string\n\
    \    }\n  \n  return filtered", '    return removeAll(strings.filter({ $0.contains(substring)
    }))', "    let mut index = -1\n    let mut indexEnd = strings.len()\n    for stringIdx\
    \ in 0..<strings.len() {\n        if strings[stringIdx].contains(substring) {\n\
    \            if index == -1 {\n                index = stringIdx\n           \
    \     indexEnd = stringIdx\n            } else {\n                indexEnd = stringIdx\n\
    \            }\n        }\n    }\n    if index != -1 {\n        let range = (index\
    \ + 1, indexEnd)\n        return strings.subslice(range)\n    } else {\n     \
    \   return strings\n    }", "    var strings_ = strings[:]\n\n    if substring.characters.count\
    \ == 0 {\n        return strings_\n    }\n    if substring.isEmpty {\n       \
    \ return strings_\n    }\n\n    if strings_.count == 0 {\n        return []\n\
    \    }\n\n    let lower = substring.lowercased()\n    var filtered: [String] =\
    \ []\n    for string in strings_ {\n        if string.lowercased().hasSuffix(lower)\
    \ {\n            filtered.append(string)\n        }\n    }\n\n    return filtered",
  "    let filtered = strings.filter { $0.contains(substring) }\n    return filtered\
    \ as [String]", "    if !strings.contains { case s.contains(substring) => true\
    \ } { return strings }\n\n    var result = strings\n    for (index, s) in strings.enumerated()\
    \ {\n        if s.contains(substring) {\n            result = result.filter()\
    \ {\n                !strings.isPrefix(substring) || $0.contains(substring)\n\
    \            }\n        }\n    }\n    return result", '    return filter(strings,
    stringMatching(substring))', "    let substrIndex = strings.index(of: substring)\n\
    \    if substrIndex == NSNotFound {\n        return strings\n    }\n    let filteredStrings\
    \ = strings.filter() { $0.range(of: substring, options: .caseInsensitive) != nil\
    \ }\n    return filteredStrings", "  var filtered = ArraySlice(strings).filter({\
    \ s -> s.contains(substring) })\n  if filtered.isEmpty() {\n    return strings\n\
    \  }\n  return filtered", "\tvar filtered: [String] = []\n\tfor _, str := range\
    \ strings {\n\t\tif strings.Contains(str, substring) {\n\t\t\tfiltered = append(filtered,\
    \ str)\n\t\t}\n\t}\n\treturn filtered", "\treturn filter_by_substrings(strings,\
    \ substrings)", "  var filtered = strings\n  filtered = filtered.filter() { $0.contains(substring)\
    \ }\n  return filtered", "    var result: [String] = []\n    for string in strings\
    \ {\n        if string.contains(substring) {\n            result.append(string)\n\
    \        }\n    }\n    return result", "    if substring.isEmpty {\n        return\
    \ strings\n    }\n    filtered = strings.filter { $0.rangeOfString(substring)\
    \ == nil }\n    return filtered", '    return filter(strings, substring)', " \
    \   strings.filter { str -> Bool in\n        let idx = str.index(of: substring)\n\
    \        return idx != nil\n    }", "    let regex = try NSRegularExpression(pattern:\
    \ \".*\" + substring + \".*\")\n    let filtered = strings.filter {\n        guard\
    \ let match = regex.firstMatch(in: $0, options: .anchored) else {\n          \
    \  return false\n        }\n        return match.rangeAt(1..<match.range.length).location\
    \ == match.range.length\n    }\n    return filtered", "    guard substring !=\
    \ \"\" else {\n        return strings\n    }\n    \n    var filtered: [String]\
    \ = []\n    for string in strings {\n        if string.contains(substring) {\n\
    \            filtered.append(string)\n        }\n    }\n    return filtered",
  "  var filtered: [String] = []\n  for string in strings {\n    if string.contains(substring)\
    \ {\n      filtered.append(string)\n    }\n  }\n  return filtered", "    for string\
    \ in strings {\n        if string.contains(substring) {\n            return strings\n\
    \        }\n    }\n    return []", "\tvar filtered = strings\n\t_ = filtered.removeAll{\
    \ $0.contains(substring) }\n\treturn filtered", '    return filter_by_substrings(strings,
    []string(substring))', "\tfor _, s := range strings {\n\t\tif strings.Contains(s,\
    \ substring) {\n\t\t\tstrings = append(strings[:strings.Index(s)], strings.[strings.Index(s)+1:]...)\n\
    \t\t}\n\t}\n\treturn strings", "  var filtered = strings\n  for string in strings\
    \ {\n    if string.hasSuffix(substring) {\n      filtered = filtered + [string]\n\
    \    }\n  }\n  return filtered", '  return strings.filter({ substring in $0 })',
  "    let filtered = strings.filter({ (s) -> Bool in\n        return s.contains(substring)\n\
    \    })\n    return filtered", "    var filtered = [String]()\n    for string\
    \ in strings {\n        if string.contains(substring) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered", "    var result = [String]()\n    for\
    \ s in strings {\n        if s.contains(substring) {\n            result.append(s)\n\
    \        }\n    }\n    return result", "    let substrings = [substring]\n   \
    \ if let prefix = substring.startIndex {\n        substrings.append(string.substring(from:\
    \ prefix))\n    }\n    return filter_by_substring(strings: strings, substrings:\
    \ substrings)", '    return strings.filter({ $0.contains(substring) })', '    return
    strings.filter { $0.lowercased().contains(substring.lowercased()) }', '    return
    filters.filter(strings => strings.contains(substring))', "    return strings.filter\
    \ { (value) -> Bool in\n        return value.range(of: substring, options: .caseInsensitive)\
    \ != nil\n    }", '    return filter_by_substring(strings: strings, substring:
    substring, exclude: false)', "  return strings.filter { (string : String) -> Bool\
    \ in\n    if string.rangeOfString(substring) != nil {\n      return true\n   \
    \ }\n    return false\n  }", "    guard let index = strings.firstIndex(of: substring)\
    \ else { return strings }\n    let range = (index..<strings.endIndex).offset(by:\
    \ (substring.characters.count - 1))\n    let result = strings.filter({ (string:\
    \ String) -> Bool in\n        return string.range(of: substring, options: .caseInsensitive)\
    \ != nil\n    })\n    return result", "    let filteredStrings = strings.filter\
    \ { $0.contains(substring) }\n    return filteredStrings", "    var result = [String]()\n\
    \    for string in strings {\n        if string.contains(substring) {\n      \
    \      result.append(string)\n        }\n    }\n    return result", "    // Use\
    \ a for loop instead of filter or indexOf because we want to avoid copying strings.\n\
    \    var result: [String] = []\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            result.append(string)\n        }\n    }\n    return result",
  "    guard substring != \"\" else {\n        return strings\n    }\n\n    var filtered\
    \ = [String]()\n    for string in strings {\n        if string.rangeOfString(substring)\
    \ != nil {\n            filtered = append(filtered, string)\n        }\n    }\n\
    \n    return filtered", "    var filteredStrings = [String]()\n    for s in strings\
    \ {\n        if substring in s {\n            filteredStrings.append(s)\n    \
    \    }\n    }\n    return filteredStrings", "    return strings.filter { (substring:\
    \ String) -> Bool in\n        let index = substring.index(of: substring)\n   \
    \     if index != nil { return true }\n        return false\n    }", "    guard\
    \ strings.count > 0 else { return strings }\n\n    var filtered_strings = [String]()\n\
    \    for string in strings {\n        if string.lowercaseString.contains(substring)\
    \ {\n            filtered_strings.append(string)\n        }\n    }\n    return\
    \ filtered_strings", "    // Filter strings\n    let filtered = strings.filter\
    \ { (input: String) -> Bool in\n        return input.rangeOfString(substring)\
    \ != nil\n    }\n    // Return filtered strings\n    return filtered", "\tvar\
    \ filtered [String] = []\n\n\tfor index, value := range strings {\n\t\tif value.contains(substring)\
    \ {\n\t\t\tfiltered = append(filtered, value)\n\t\t}\n\t}\n\n\treturn filtered",
  "\tif strings.IsSubset(substring) {\n\t\treturn strings\n\t}\n\tvar filtered_strings\
    \ = strings\n\tfor _, s := range strings {\n\t\tif strings.Contains(s, substring)\
    \ {\n\t\t\tfiltered_strings = append(filtered_strings, s)\n\t\t}\n\t}\n\treturn\
    \ filtered_strings", '    return filter(strings, contains: substring)', "    var\
    \ filtered = strings\n\n    for string in strings {\n        if string.hasSuffix(substring)\
    \ {\n            filtered = filtered.filter({$0 != string})\n        }\n    }\n\
    \    return filtered", "\tlet index = strings.indexOfSubstring(substring)\n\t\
    return strings.filter{_ in\n\t\tlet result = index == 0 || strings[index-1] ==\
    \ substring\n\t\tindex--\n\t\treturn result\n\t}", '    return strings.filter({
    $0.contains(substring) })', "    var stringCopy = strings\n    var result = []\n\
    \    for index in 0..<stringCopy.count {\n        let string = stringCopy[index]\n\
    \        let count = string.count(substring)\n        if count > 0 {\n       \
    \     result = result + [string]\n        }\n    }\n    return result", "    if\
    \ !strings.isEmpty {\n        let indexes = strings.map {\n            strings.index($0,\
    \ options: .caseInsensitive)\n        }\n        let indexes_to_remove = indexes.enumerated().filter\
    \ { index, element in\n            let elementIndex = element.pointee\n      \
    \      let lowercase_substring = substring.lowercased()\n            return elementIndex\
    \ < lowercase_substring.count &&\n                lowercase_substring[elementIndex]\
    \ == element\n        }\n        strings.removeSubrange(indexes_to_remove.map{\
    \ $0.element })\n    }\n    return strings", "    var filtered_strings = strings\n\
    \    for s in strings {\n        if s.contains(substring) {\n            filtered_strings\
    \ = filtered_strings.filter({ $0 != s })\n        }\n    }\n    return filtered_strings",
  "\tfiltered = strings.filter({ substring in $0 })\n\treturn filtered", "  var filtered:\
    \ [String] = []\n  strings.forEach({ substringedString in\n    if substringedString.hasPrefix(substring)\
    \ {\n      filtered = append(filtered, substringedString)\n    }\n  })\n  return\
    \ filtered", "    // find longest substring starting at index 0\n    var index\
    \ = -1\n    let maxLen = substring.length\n    for str in strings {\n        let\
    \ subLen = str.length - str.characters.count\n        if subLen > maxLen {\n \
    \           maxLen = subLen\n            index = str.characters.indexOfSubstring(substring,\
    \ from: 0)\n        }\n    }\n\n    // if no match was found, just return original\
    \ array\n    if index < 0 {\n        return strings\n    }\n\n    // find all\
    \ matching strings, starting from original index\n    var filtered = Array()\n\
    \    for str in strings {\n        if str.characters.indexOfSubstring(substring,\
    \ from: index) != nil {\n            filtered.append(str)\n        }\n    }\n\
    \    return filtered", '  return strings.filter({ $0.contains(substring) })',
  "    var filtered = strings[:]\n    for s in filtered {\n        if s.contains(substring)\
    \ {\n            continue\n        }\n        filtered.remove(s)\n    }\n    return\
    \ filtered", "    let matched = strings.filter({ $0.contains(substring) })\n \
    \   return matched", '    return strings.filter { substring in $0 }', '    return
    strings.filter{ $0.contains(substring) }', "    // Filter only strings where the\
    \ substring is included in any of the string parts\n    let filtered = strings\n\
    \        .flatMap({ $0.components(separatedBy: substring) })\n        .filter({\
    \ !$0.isEmpty })\n    \n    // Remove empty strings\n    filtered = filtered.filter({\
    \ !$0.isEmpty })\n\n    return filtered", "    var res: [String] = []\n    for\
    \ s in strings {\n        if s.contains(substring) {\n            res.append(s)\n\
    \        }\n    }\n    return res", "\treturn filter_by_strings(strings, strings_contains,\
    \ substring)", '    return filter(strings, substring).filter(!contains)', "  \
    \  var filtered_strings: [String] = []\n    for (index, value) in strings.enumerated()\
    \ {\n        if value.hasPrefix(substring) {\n            filtered_strings.append(value)\n\
    \        }\n    }\n    return filtered_strings", '    return filterBySubstringImpl(strings,
    substring, true)', "    if strings.IsEmpty {\n        return strings\n    }\n\n\
    \    var newStrings: [String] = []\n\n    for s in strings {\n        if strings.HasSuffix(substring,\
    \ s) {\n            newStrings.append(s)\n        }\n    }\n\n    return newStrings",
  "    let pattern = NSPredicate(format: \"self CONTAINS %@\", substring)\n    return\
    \ strings.filter { pattern?.evaluate(with: $0) }", "    if substring == \"\" {\n\
    \        return strings\n    }\n    \n    var results = [String]()\n    var idx\
    \ = 0\n    for idx in 0 ..< strings.count {\n        if strings.elementAt(idx).hasPrefix(substring)\
    \ {\n            results.append(strings.elementAt(idx))\n        }\n    }\n  \
    \  \n    return results", "    var filteredStrings = strings\n    for string in\
    \ strings {\n        if string.contains(substring) {\n            filteredStrings.remove(at:\
    \ 0)\n            break\n        }\n    }\n    return filteredStrings", "    var\
    \ filtered = strings\n    for string in strings {\n        if string.hasSuffix(substring)\
    \ {\n            filtered = filtered[..<filtered.index(string.startIndex, offsetBy:\
    \ -1)]\n        }\n    }\n    return filtered", '  strings.filter { $0.contains(substring)
    }', "    let filtered = strings.filter { (string: String) -> Bool in\n       \
    \ let index = (string as NSString).rangeOfString(substring, options: NSString.CompareOptions.CaseInsensitiveSearch)\n\
    \        return (index != NSNotFound)\n    }\n    return filtered", "    var result:\
    \ [String] = []\n    for s in strings {\n        if substring in s {\n       \
    \     result.append(s)\n        }\n    }\n    return result", "    var filtered\
    \ = strings\n    for str in strings {\n        if str == substring {\n       \
    \     filtered = []\n            break\n        }\n        filtered = append(filtered,\
    \ str)\n    }\n    return filtered", "    var result = [String]()\n    for string\
    \ in strings {\n        if string.contains(substring) {\n            result.append(string)\n\
    \        }\n    }\n    return result", "    let filtered = strings.filter { (s)\
    \ in\n        return s.rangeOfString(substring) != nil\n    }\n    return filtered",
  '  return strings.filter { substrings.contains($0) }', "    return strings.filter\
    \ { str in\n        let index = str.lowercaseString.index(str.lowercaseString.startIndex,\
    \ offsetBy: substring.lowercaseString.startIndex)\n        return index != nil\n\
    \    }", "    var filtered = [String]()\n    for str in strings {\n        if\
    \ substring.hasPrefix(str) {\n            filtered = append(filtered, str)\n \
    \       }\n    }\n    return filtered", "    guard strings.count > 0 && substring.count\
    \ > 0 else { return strings }\n    let startIndex = strings.indexWhere(String.contains,\
    \ substring)\n    if startIndex < 0 {\n        return strings\n    }\n    let\
    \ subStringLen = substring.length\n    let filteredStrings = strings[0..<startIndex].map\
    \ {\n        return String(strings[startIndex..<startIndex+subStringLen])\n  \
    \  }\n    return filteredStrings", "    var filtered = [String]()\n    strings.forEach\
    \ { string in\n        if string.lowercased().contains(substring) {\n        \
    \    filtered = filtered + [string]\n        }\n    }\n    return filtered", " \
    \   var filtered = [String]()\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            filtered = append(filtered, string)\n        }\n    }\n    return\
    \ filtered", "    var filteredStrings = [String]()\n    for aString in strings\
    \ {\n        if aString.rangeOfString(substring) != nil {\n            filteredStrings.append(aString)\n\
    \        }\n    }\n    return filteredStrings", "    var filtered = [String]()\n\
    \    for s in strings {\n        if s.contains(substring) {\n            filtered.append(s)\n\
    \        }\n    }\n    return filtered", "    for s in strings {\n        if s.contains(substring)\
    \ {\n            return strings\n        }\n    }\n    return []", "  guard let\
    \ first = strings.firstIndex(of: substring), let last = strings.index(of: substring,\
    \ after: first) else {\n    return strings\n  }\n  return strings.suffix(from:\
    \ first ..< last)", "    var ret = [String]()\n    for s in strings {\n      \
    \  if s.contains(substring) {\n            ret.append(s)\n        }\n    }\n \
    \   return ret", "    if substring == \"\" {\n        return strings\n    }\n\n\
    \    var filtered: [String] = []\n    for s in strings {\n        if s.hasPrefix(substring)\
    \ {\n            filtered = append(filtered, s)\n        }\n    }\n    return\
    \ filtered", "    var filteredStrings = strings\n    for s in strings {\n    \
    \    if s.lowercaseString.contains(substring) {\n            filteredStrings.remove(s)\n\
    \        }\n    }\n    return filteredStrings", "    var output = [String]()\n\
    \    for s in strings {\n        if s.contains(substring) {\n            output.append(s)\n\
    \        }\n    }\n    return output", "    guard let stringArray = strings.map(String.init)\
    \ else {\n        return []\n    }\n    guard let index = stringArray.index(of:\
    \ substring) else {\n        return []\n    }\n    return stringArray[index..<index+1]",
  "  var matches = strings\n  var filtered = strings\n  matches.filter { match in\n\
    \    if let index = match.range(of: substring) {\n      filtered = filtered.filter\
    \ { !$0.contains(substring) }\n      if filtered.count == 1 {\n        return\
    \ true\n      }\n    }\n    return false\n  }\n  return filtered", "    guard\
    \ let substringIndex = strings.firstIndex(of: substring) else { return strings\
    \ }\n    return strings.filter { $0.startIndex..<substringIndex.advanced(by: substringIndex.distance(from:\
    \ strings.startIndex, to: substringIndex)) == substringIndex }", "    let predicate\
    \ = NSPredicate(format: \"self CONTAINS %@\", argumentArray: [substring])\n  \
    \  return objects.filter(predicate)", "    for s in strings {\n        if strings.contains(substring)\
    \ {\n            return strings\n        }\n    }\n    return []", '    return
    filter(strings, substring)', "    if !strings.contains(substring) { return strings\
    \ }\n    var filtered: [String] = []\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            filtered = append(filtered, s)\n        }\n    }\n    return\
    \ filtered", "\treturn filter_by(\n\t\tstrings,\n\t\tfunc(s String) bool {\n\t\
    \t\treturn strings.Contains(s, substring)\n\t\t})", "    let filtered = strings.filter\
    \ { (string: String) -> Bool in\n        return string.rangeOfString(substring)\
    \ != nil\n    }\n    return filtered", "  return strings.filter {\n    $0.hasSuffix(substring)\n\
    \  }", '    return filter_by_substrings(strings, substring, true)', "    var filtered:\
    \ [String] = []\n    for string in strings {\n        if string.hasSuffix(substring)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered",
  "  return strings.filter {\n    substring in $0\n  }", "    var result = [String]()\n\
    \    for str in strings {\n        if str.contains(substring) {\n            result.append(str)\n\
    \        }\n    }\n    return result", "    let startIndex = strings.startIndex.advanced(by:\
    \ substring.count).successor()\n    return strings.indices.contains(startIndex)\n\
    \        ? strings.filter() {\n              return strings[$0] == substring\n\
    \          }\n        : strings", "\tresult = filter(strings, substring)\n\treturn",
  "\tfilteredStrings := [String]()\n\tfor _, string := range strings {\n\t\tif strings.Contains(string,\
    \ substring) {\n\t\t\tfilteredStrings = append(filteredStrings, string)\n\t\t\
    }\n\t}\n\treturn filteredStrings", "    var result: [String] = []\n    for string\
    \ in strings {\n        if string.hasSuffix(substring) {\n            result.append(string)\n\
    \        }\n    }\n    return result", '  return strings.filter({ $0.contains(substring)
    })', "    var stringResult = strings\n\n    for string in strings {\n        if\
    \ string.lowercaseString.contains(substring.lowercaseString) {\n            stringResult.append(string)\n\
    \        }\n    }\n\n    return stringResult", "    guard !substring.isEmpty else\
    \ { return strings }\n    return strings.filter { $0.hasSuffix(substring) }",
  "    for string in strings {\n        if string.contains(substring) {\n        \
    \    return strings\n        }\n    }\n    return []", "    for s in strings {\n\
    \        if substring == s {\n            return strings\n        }\n    }\n \
    \   return []", '  return strings.filter({ $0.contains(substring) })', "    var\
    \ filtered = strings\n    for str in strings {\n        if str.contains(substring)\
    \ {\n            filtered = filtered.filter{$0 != str}\n        }\n    }\n   \
    \ return filtered", "    guard !strings.isEmpty else {\n        return []\n  \
    \  }\n    return strings.filter { $0.contains(substring) }", "\tconst start =\
    \ substring.startIndex.encodedOffset\n\tconst end = substring.endIndex.encodedOffset\n\
    \treturn strings.filter({ string in\n\t\tlet range = (string as NSString).range(of:\
    \ substring)\n\t\treturn range.contains(range)\n\t})", "    var new_strings: [String]\
    \ = []\n    for string in strings {\n        if string.hasPrefix(substring) {\n\
    \            new_strings += [string]\n        }\n    }\n    return new_strings",
  '  return filter(strings, substring)', '  return strings.filter({ $0.contains(substring)
    })', '    return filter_by_substring_indexed(strings, 0, substring, 1)', "   \
    \ var filtered: [String] = []\n    for string in strings {\n        let substringIndex\
    \ = string.range(of: substring)\n        if substringIndex.lowerBound == nil ||\
    \ substringIndex.upperBound == nil {\n            continue\n        }\n      \
    \  filtered.append(string)\n    }\n    return filtered", "    var filtered = [String]()\n\
    \    for element in strings {\n        if element.contains(substring) {\n    \
    \        filtered = filtered + [element]\n        }\n    }\n    return filtered",
  '    return filter_by_substring(strings, substring, caseSensitive: true)', "   \
    \ var filtered = strings\n    for i in 0..<strings.count {\n        if strings.[i]\
    \ == substring {\n            filtered[i] = \"\"\n        }\n    }\n    return\
    \ filtered", "    var filteredStrings = strings\n    for str in strings {\n  \
    \      if str.hasPrefix(substring) {\n            filteredStrings.remove(str)\n\
    \        }\n    }\n    return filteredStrings", '    return strings.filter { $0.contains(substring)
    }', "  let filteredStrings = strings.filter { $0.contains(substring) }\n  return\
    \ filteredStrings", "\tresult := make([]String, 0)\n\n\tfor _, s := range strings\
    \ {\n\t\tif strings.Index(s, substring) != -1 {\n\t\t\tresult = append(result,\
    \ s)\n\t\t}\n\t}\n\n\treturn result", "    return strings.filter {\n        contains($0,\
    \ substring)\n    }", '    return filter_by_substring(strings, substring: substring,
    keepOriginal: false)', "\tresult := [String]()\n\tfor _, s := range strings {\n\
    \t\tif strings.Contains(s, substring) {\n\t\t\tresult = append(result, s)\n\t\t\
    }\n\t}\n\treturn result", '    return filter_by_substring(strings.ToTypedArray(),
    substring.ToTypedArray())', "    // TODO: use filterString()\n    return strings.filter({\
    \ str in\n        let index = str.index(str.startIndex, offsetBy: 0)\n       \
    \ let stringLength = str.characters.count\n        let subIndex = str.index(index,\
    \ offsetBy: substring.characters.count)\n        let substringLength = substring.characters.count\n\
    \        let isSubstring = (str.characters.suffixFrom(index) == substring)\n \
    \       return !isSubstring ||\n            (substringLength > 0 &&\n        \
    \    str.characters.prefix(substringLength) == substring.characters)\n       \
    \ })", "    var result = [String]()\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            result.append(s)\n        }\n    }\n    return result", "  var\
    \ filtered: [String] = []\n  for string in strings {\n    if string.contains(substring)\
    \ {\n      filtered.append(string)\n    }\n  }\n  return filtered", "    let count\
    \ = strings.count\n    let substringCount = substring.characters.count\n    return\
    \ (0..<count).filter { i in\n        strings[i].characters.count == substringCount\
    \ &&\n            (strings[i].characters.lowercased().hasSuffix(substring) ||\n\
    \            strings[i].lowercased().hasSuffix(substring))\n    }", "    guard\
    \ let index = strings.index(where: { $0.contains(substring) }) else {\n      \
    \  return strings\n    }\n    return strings.drop(index).append(strings.suffix(from:\
    \ index))", "\tintersection := strings.Intersect(strings.SplitN(strings.Join(strings,\
    \ \"\"), substring, 2))\n\treturn strings.Split(intersection, substring)", '    return
    strings.filter({$0.contains(substring)})', "    var filtered = [String]()\n  \
    \  for (index, item) in strings.enumerated() {\n        if substring == item {\n\
    \            filtered = append(filtered, item)\n        }\n    }\n    return filtered",
  "    let filtered = strings.filter { (string: String) -> Bool in\n        let sub\
    \ = string.lowercaseString.rangeOfString(substring)\n        return sub != nil\
    \ && sub.upperBound != NSNotFound\n    }\n    return filtered", "  let substrings\
    \ = substring.characters.split{$0 == \",\"}\n  let substringsCount = substrings.count\n\
    \n  guard substringsCount > 0 else {\n    return strings\n  }\n\n  var filtered\
    \ = Set<String>()\n\n  for s in strings {\n    let start = substring.characters.index($0,\
    \ options: .caseInsensitive)\n    let end = start.advanced(by: substringsCount)\n\
    \n    if start != end {\n      filtered.insert(s[start..<end])\n    }\n  }\n\n\
    \  return [filtered.allObjects]", "  return strings.filter { string -> Bool in\n\
    \    string.hasPrefix(substring)\n  }", "\tsubstring = substring.lowercased()\n\
    \treturn strings.filter { $0.lowercased().contains(substring) }", "    var filteredStrings\
    \ = strings\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            filteredStrings.remove(at: filteredStrings.index(of: string))\n\
    \        }\n    }\n    return filteredStrings", "    var filteredStrings: [String]\
    \ = []\n\n    for string in strings {\n        if string.hasPrefix(substring)\
    \ {\n            filteredStrings.append(string)\n        }\n    }\n\n    return\
    \ filteredStrings", "    var result = strings[:]\n    for i in 0..<strings.count\
    \ {\n        if strings[i].lowercased().contains(substring.lowercased()) {\n \
    \           result = result.filter{ $0 != strings[i] }\n        }\n    }\n   \
    \ return result", "    var filteredStrings = strings\n    for s in strings {\n\
    \        if s.contains(substring) {\n            filteredStrings.remove(s)\n \
    \       }\n    }\n    return filteredStrings", "    var result = [String]()\n\
    \    for string in strings {\n        if string.contains(substring) {\n      \
    \      result.append(string)\n        }\n    }\n    return result", "    if !strings.HasSuffix(substring)\
    \ {\n        return strings\n    }\n    \n    var filtered: [String] = []\n  \
    \  for s in strings {\n        if s.hasPrefix(substring) {\n            filtered\
    \ = filtered + [s]\n        }\n    }\n    return filtered", "  let mut result\
    \ = Vec::new();\n  for str in strings {\n    if str.contains(substring) {\n  \
    \    result.push(str);\n    }\n  }\n  return result", "\tvar result [String] =\
    \ []\n\tfor _, s := range strings {\n\t\tif strings.Contains(s, substring) {\n\
    \t\t\tresult = append(result, s)\n\t\t}\n\t}\n\treturn result", "    guard let\
    \ index = strings.firstIndex(of: substring) else { return strings }\n    return\
    \ strings[index..<strings.endIndex].compactMap {\n        strings.firstIndex(of:\
    \ $0)\n    }.map { strings.first }", '    return filter_by_substring_inplace(strings,
    substring, false)', "\tvar filtered_strings = [String]()\n\tfor s in strings {\n\
    \t\tif s.contains(substring) {\n\t\t\tfiltered_strings.append(s)\n\t\t}\n\t}\n\
    \treturn filtered_strings", "    var strings_ = strings.slice()\n    for idx :=\
    \ range strings_ {\n        if strings_[idx].contains(substring) {\n         \
    \   strings_.remove(at: idx)\n        }\n    }\n    return strings_", "\tvar filtered\
    \ = strings\n\tfor _, str := range strings {\n\t\tif strings.Contains(str, substring)\
    \ {\n\t\t\tfiltered = append(filtered, str)\n\t\t}\n\t}\n\treturn filtered", "\t\
    return filter_by_substrings(strings.slice(), substring.asCString())", "  guard\
    \ substring != \"\" else { return strings }\n  return strings.filter({ (string)\
    \ -> Bool in\n    let rangeOfSubstring = string.rangeOfString(substring)\n   \
    \ return rangeOfSubstring?.location == nil\n  })", "    // TODO(Andrew): If this\
    \ becomes an issue we can add a [String: Int] or [String: Bool] parameter\n  \
    \  let result = strings.filter { (string: String) -> Bool in\n        return string.hasPrefix(substring)\n\
    \    }\n    return result", '    return strings.filter({ substring in $0 })',
  "\tfilteredStrings := strings.filter({ $0.contains(substring) })\n\treturn filteredStrings",
  "    guard !substring.isEmpty else { return strings }\n\n    var filtered = [String]()\n\
    \    for s in strings {\n        if s.range(of: substring)?.lowerBound == nil\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered", " \
    \   let filtered = strings.filter { (s) in\n        return s.contains(substring)\n\
    \    }\n    return filtered", "\tfilter := strings.Filter(func(s string) bool\
    \ {\n\t\treturn strings.Contains(s, substring)\n\t})\n\treturn strings.SliceToArray(filter,\
    \ []byte(substring))", "\treturn strings.filter({ $0.contains(substring) })",
  "\treturn strings.filter{ s -> Bool in\n\t\treturn s.range(of: substring) != nil\n\
    \t}", '    strings.filter { substring in $0 }', "    if !strings.HasSuffix(substring)\
    \ {\n        strings = strings.Suffix(strings.LastIndexOf(substring))\n    }\n\
    \n    if strings.IsEmpty() {\n        return strings\n    }\n\n    strings.Remove(strings.LastIndex(substring))\n\
    \n    return strings", '  return strings.filter({ $0.contains(substring) })',
  "    if let prefix = substring.first {\n        for s in strings {\n           \
    \ if s.starts(with: prefix) {\n                return strings.filter{$0 != substring}\n\
    \            }\n        }\n        return strings\n    }\n\n    return strings",
  "    var filtered: [String] = []\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered",
  '  strings.filter({ string.contains(substring) })', "    var result = [String]()\n\
    \    for s in strings {\n        if s.contains(substring) {\n            result.append(s)\n\
    \        }\n    }\n    return result", "    var result: [String] = []\n    for\
    \ string in strings {\n        if string.contains(substring) {\n            result.append(string)\n\
    \        }\n    }\n    return result", "    let pattern = NSPredicate(format:\
    \ \"SELF contains[c] %@\", argumentArray: [substring])\n    let array = NSArray(array:\
    \ strings).filteredArrayUsingPredicate(pattern)\n    return array as! [String]",
  "    let filteredStrings = strings.filter { $0.contains(substring) }\n    return\
    \ filteredStrings", "    let filteredStrings = strings.filter { $0.hasSuffix(substring)\
    \ }\n    return filteredStrings", "    var filtered: [String] = []\n    for string\
    \ in strings {\n        if string.lowercaseString.rangeOfString(substring) !=\
    \ nil {\n            filtered.append(string)\n        }\n    }\n    return filtered",
  "    if strings.isEmpty() {\n        return strings\n    }\n    var result = strings.filter\
    \ { $0.contains(substring) }\n    return result", '    strings.filter { $0.contains(substring)
    }']
stop_tokens:
- "\n}"
