language: swift
name: HumanEval_98_count_upper
results:
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for index in s.characters.indices {\n\
    \        if s.isUpper(index) {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5kvpx3q5.swift:12:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in s.characters.indices {\n             \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp5kvpx3q5.swift:13:14:\
    \ error: value of type 'String' has no member 'isUpper'\n        if s.isUpper(index)\
    \ {\n           ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s == \"\" {\n        return 0\n    }\n    if let chars\
    \ = s.unicodeScalars {\n        let start = chars.startIndex\n        if let upper\
    \ = unicodeScalars.range(of: \"\\u{0000}\\u{0400}-\\u{0500}\\u{0510}-\\u{0519}\\\
    u{1D00}-\\u{1D7F}\") {\n            let end = upper.upperBound\n            return\
    \ s.distance(from: start, to: end) / 2\n        }\n    }\n    return 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpf19mc0mo.swift:16:24: error: cannot find 'unicodeScalars' in scope\n\
    \        if let upper = unicodeScalars.range(of: \"\\u{0000}\\u{0400}-\\u{0500}\\\
    u{0510}-\\u{0519}\\u{1D00}-\\u{1D7F}\") {\n                       ^~~~~~~~~~~~~~\n\
    /tmp/tmpf19mc0mo.swift:14:8: error: initializer for conditional binding must have\
    \ Optional type, not 'String.UnicodeScalarView'\n    if let chars = s.unicodeScalars\
    \ {\n       ^           ~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count_upper(s, s.characters.start)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4i4xjaep.swift:11:40: error: extra argument in call\n    return\
    \ count_upper(s, s.characters.start)\n                      ~~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmp4i4xjaep.swift:11:40: error: value of type 'String' has no member 'start'\n\
    \    return count_upper(s, s.characters.start)\n                          ~~~~~~~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for index in s.indices(of: CharacterSet.uppercaseLetters)\
    \ {\n        if index % 2 == 0 {\n            count += 1\n        }\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9bsc8ofb.swift:12:32: error: cannot find 'CharacterSet' in scope\n\
    \    for index in s.indices(of: CharacterSet.uppercaseLetters) {\n           \
    \                    ^~~~~~~~~~~~\n/tmp/tmp9bsc8ofb.swift:12:20: error: cannot\
    \ call value of non-function type 'DefaultIndices<String>'\n    for index in s.indices(of:\
    \ CharacterSet.uppercaseLetters) {\n                   ^\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for index in 0..<s.characters.count\
    \ {\n        if CharacterSet(s.characters[index]).isUppercase() {\n          \
    \  count += 1\n        } else if CharacterSet(s.characters[index]).isUppercase()\
    \ && index%2 == 0 {\n            count += 2\n        } else if CharacterSet(s.characters[index]).isUppercase()\
    \ && index%2 == 1 {\n            count += 2\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplq3t7vd3.swift:12:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<s.characters.count {\n           \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmplq3t7vd3.swift:13:12: error: cannot find 'CharacterSet' in scope\n   \
    \     if CharacterSet(s.characters[index]).isUppercase() {\n           ^~~~~~~~~~~~\n\
    /tmp/tmplq3t7vd3.swift:15:19: error: cannot find 'CharacterSet' in scope\n   \
    \     } else if CharacterSet(s.characters[index]).isUppercase() && index%2 ==\
    \ 0 {\n                  ^~~~~~~~~~~~\n/tmp/tmplq3t7vd3.swift:17:19: error: cannot\
    \ find 'CharacterSet' in scope\n        } else if CharacterSet(s.characters[index]).isUppercase()\
    \ && index%2 == 1 {\n                  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for c in s {\n        if c.isUpper()\
    \ {\n            if c.isUpper() && count%2 == 0 {\n                count += 1\n\
    \            }\n            count = 0\n        } else {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5s5g3hqf.swift:13:14: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if c.isUpper() {\n           ~ ^~~~~~~\n/tmp/tmp5s5g3hqf.swift:14:18:\
    \ error: value of type 'Character' has no member 'isUpper'\n            if c.isUpper()\
    \ && count%2 == 0 {\n               ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tvar n = 0\n\tfor _, c := range s {\n\t\tif isUpper(c) &&\
    \ evenInd(c, i) {\n\t\t\tn++\n\t\t}\n\t}\n\treturn n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpik_vsehx.swift:12:7: error: expected 'in' after for-each pattern\n\
    \        for _, c := range s {\n             ^\n/tmp/tmpik_vsehx.swift:12:7: error:\
    \ expected Sequence expression for for-each loop\n        for _, c := range s\
    \ {\n             ^\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    vowels := countUpper\n    if vowels == nil {\n       \
    \ vowels = make(map[rune]int)\n        for i := runeA; i <= runeZ; i++ {\n   \
    \         vowels[i] = 0\n        }\n    }\n    return vowels[s[startIndexOfVowels()]]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpveua7ui3.swift:11:11: error: consecutive statements on a line must\
    \ be separated by ';'\n    vowels := countUpper\n          ^\n          ;\n/tmp/tmpveua7ui3.swift:11:12:\
    \ error: expected expression\n    vowels := countUpper\n           ^\n/tmp/tmpveua7ui3.swift:13:32:\
    \ error: expected ',' separator\n        vowels = make(map[rune]int)\n       \
    \                        ^\n                               ,\n/tmp/tmpveua7ui3.swift:14:16:\
    \ error: expected type\n        for i := runeA; i <= runeZ; i++ {\n          \
    \     ^\n                <#type#>\n/tmp/tmpveua7ui3.swift:14:16: error: expected\
    \ 'in' after for-each pattern\n        for i := runeA; i <= runeZ; i++ {\n   \
    \            ^\n/tmp/tmpveua7ui3.swift:14:16: error: expected Sequence expression\
    \ for for-each loop\n        for i := runeA; i <= runeZ; i++ {\n             \
    \  ^\n/tmp/tmpveua7ui3.swift:11:5: error: cannot find 'vowels' in scope\n    vowels\
    \ := countUpper\n    ^~~~~~\n/tmp/tmpveua7ui3.swift:12:8: error: cannot find 'vowels'\
    \ in scope\n    if vowels == nil {\n       ^~~~~~\n/tmp/tmpveua7ui3.swift:13:9:\
    \ error: cannot find 'vowels' in scope\n        vowels = make(map[rune]int)\n\
    \        ^~~~~~\n/tmp/tmpveua7ui3.swift:13:18: error: cannot find 'make' in scope\n\
    \        vowels = make(map[rune]int)\n                 ^~~~\n/tmp/tmpveua7ui3.swift:13:23:\
    \ error: cannot find 'map' in scope\n        vowels = make(map[rune]int)\n   \
    \                   ^~~\n/tmp/tmpveua7ui3.swift:13:27: error: cannot find 'rune'\
    \ in scope\n        vowels = make(map[rune]int)\n                          ^~~~\n\
    /tmp/tmpveua7ui3.swift:13:32: error: cannot find 'int' in scope\n        vowels\
    \ = make(map[rune]int)\n                               ^~~\n/tmp/tmpveua7ui3.swift:18:12:\
    \ error: cannot find 'vowels' in scope\n    return vowels[s[startIndexOfVowels()]]\n\
    \           ^~~~~~\n/tmp/tmpveua7ui3.swift:18:21: error: cannot find 'startIndexOfVowels'\
    \ in scope\n    return vowels[s[startIndexOfVowels()]]\n                    ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.characters.filter { $0 >= 'A' && $0 <= 'Z' &&\
    \ $0 % 2 == 0 }.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpc74jtj8z.swift:11:40: error: single-quoted string literal found,\
    \ use '\"'\n    return s.characters.filter { $0 >= 'A' && $0 <= 'Z' && $0 % 2\
    \ == 0 }.count\n                                       ^~~\n                 \
    \                      \"A\"\n/tmp/tmpc74jtj8z.swift:11:53: error: single-quoted\
    \ string literal found, use '\"'\n    return s.characters.filter { $0 >= 'A' &&\
    \ $0 <= 'Z' && $0 % 2 == 0 }.count\n                                         \
    \           ^~~\n                                                    \"Z\"\n/tmp/tmpc74jtj8z.swift:11:60:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'Int'\n    return s.characters.filter { $0 >= 'A' && $0 <= 'Z'\
    \ && $0 % 2 == 0 }.count\n                                                   \
    \        ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if let vowels = vowels {\n        for (i, c) in s.characters.enumerated()\
    \ {\n            if vowels.contains(c) {\n                if i % 2 == 0 {\n  \
    \                  return 1 + count_upper(s.substringFromIndex(i + 1))\n     \
    \           }\n            }\n        }\n    }\n    return 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpa_sa74ru.swift:11:21: error: cannot find 'vowels' in scope\n  \
    \  if let vowels = vowels {\n                    ^~~~~~\n/tmp/tmpa_sa74ru.swift:12:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ (i, c) in s.characters.enumerated() {\n                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpa_sa74ru.swift:15:44:\
    \ error: missing argument label 's:' in call\n                    return 1 + count_upper(s.substringFromIndex(i\
    \ + 1))\n                                           ^\n                      \
    \                     s: \n/tmp/tmpa_sa74ru.swift:15:46: error: value of type\
    \ 'String' has no member 'substringFromIndex'\n                    return 1 +\
    \ count_upper(s.substringFromIndex(i + 1))\n                                 \
    \          ~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s.isEmpty { return 0 }\n\n    var upperCount = 0\n\
    \    for index in 0..<s.count {\n        if s[index].isUpper() {\n           \
    \ upperCount += 1\n            if index % 2 == 0 {\n                upperCount\
    \ += 1\n            }\n        }\n    }\n    return upperCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxyfa82nm.swift:15:21: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if s[index].isUpper() {\n           ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.unicodeScalars.filter({ $0.isUppercase }).filter({\
    \ $0.isEvenIndex }).count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphz50qc_x.swift:11:41: error: value of type 'Unicode.Scalar' has\
    \ no member 'isUppercase'\n    return s.unicodeScalars.filter({ $0.isUppercase\
    \ }).filter({ $0.isEvenIndex }).count\n                                     ~~\
    \ ^~~~~~~~~~~\n/tmp/tmphz50qc_x.swift:11:68: error: value of type 'Unicode.Scalar'\
    \ has no member 'isEvenIndex'\n    return s.unicodeScalars.filter({ $0.isUppercase\
    \ }).filter({ $0.isEvenIndex }).count\n                                      \
    \                          ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let mut i: Int = 0\n    for c in s.chars() {\n       \
    \ if c >= 'A' && c <= 'Z' {\n            if i % 2 == 0 { i += 1 }\n        } else\
    \ {\n            i += 0\n        }\n    }\n    return i\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpkojzovw9.swift:11:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut i: Int =\
    \ 0\n            ^\n/tmp/tmpkojzovw9.swift:11:13: note: join the identifiers together\n\
    \    let mut i: Int = 0\n        ~~~~^\n        muti\n/tmp/tmpkojzovw9.swift:11:13:\
    \ note: join the identifiers together with camel-case\n    let mut i: Int = 0\n\
    \        ~~~~^\n        mutI\n/tmp/tmpkojzovw9.swift:13:17: error: single-quoted\
    \ string literal found, use '\"'\n        if c >= 'A' && c <= 'Z' {\n        \
    \        ^~~\n                \"A\"\n/tmp/tmpkojzovw9.swift:13:29: error: single-quoted\
    \ string literal found, use '\"'\n        if c >= 'A' && c <= 'Z' {\n        \
    \                    ^~~\n                            \"Z\"\n/tmp/tmpkojzovw9.swift:12:16:\
    \ error: value of type 'String' has no member 'chars'\n    for c in s.chars()\
    \ {\n             ~ ^~~~~\n/tmp/tmpkojzovw9.swift:19:12: error: cannot find 'i'\
    \ in scope\n    return i\n           ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count_of_vowels(s, is_vowel)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpe9i3jyrd.swift:11:12: error: cannot find 'count_of_vowels' in scope\n\
    \    return count_of_vowels(s, is_vowel)\n           ^~~~~~~~~~~~~~~\n/tmp/tmpe9i3jyrd.swift:11:31:\
    \ error: cannot find 'is_vowel' in scope\n    return count_of_vowels(s, is_vowel)\n\
    \                              ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if let s = String(s) {\n        return s.count{ $0.unicodeScalars.isUppercase\
    \ }\n    } else {\n        return 0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyg8vw_ur.swift:12:18: error: cannot call value of non-function\
    \ type 'Int'\n        return s.count{ $0.unicodeScalars.isUppercase }\n      \
    \           ^\n/tmp/tmpyg8vw_ur.swift:11:8: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n    if let s = String(s) {\n\
    \       ^       ~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var n = s.length\n    for i := 0; i < n; i++ {\n     \
    \   var ch = s[i]\n        if ch >= 'A' && ch <= 'Z' {\n            var code =\
    \ ch - 'A'\n            if code % 2 == 1 {\n                n--\n            }\n\
    \        }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmptezy2ogs.swift:12:12: error: expected type\n    for i := 0; i <\
    \ n; i++ {\n           ^\n            <#type#>\n/tmp/tmptezy2ogs.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < n; i++ {\n\
    \           ^\n/tmp/tmptezy2ogs.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < n; i++ {\n           ^\n/tmp/tmptezy2ogs.swift:14:18:\
    \ error: single-quoted string literal found, use '\"'\n        if ch >= 'A' &&\
    \ ch <= 'Z' {\n                 ^~~\n                 \"A\"\n/tmp/tmptezy2ogs.swift:14:31:\
    \ error: single-quoted string literal found, use '\"'\n        if ch >= 'A' &&\
    \ ch <= 'Z' {\n                              ^~~\n                           \
    \   \"Z\"\n/tmp/tmptezy2ogs.swift:15:29: error: single-quoted string literal found,\
    \ use '\"'\n            var code = ch - 'A'\n                            ^~~\n\
    \                            \"A\"\n/tmp/tmptezy2ogs.swift:11:15: error: value\
    \ of type 'String' has no member 'length'\n    var n = s.length\n            ~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tlet vowels = \"AEIOUaeiou\".characters\n\tvar count = 1\n\
    \tfor c in s.characters {\n\t\tif vowels.contains(c) && c % 2 == 0 {\n\t\t\tcount\
    \ += 1\n\t\t}\n\t}\n\treturn count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpcjvna9z9.swift:11:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        let vowels = \"AEIOUaeiou\".characters\n      \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpcjvna9z9.swift:13:13: error: 'characters' is unavailable:\
    \ Please use String directly\n        for c in s.characters {\n              \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcjvna9z9.swift:14:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \                if vowels.contains(c) && c % 2 == 0 {\n                     \
    \                    ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let vowels = \"AEIOUaeiou\"\n    return s.characters.filter({\
    \ vowels.contains($0) }).filter({ $0 % 2 == 1}).count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpajjeiqxe.swift:12:66: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Int'\n    return s.characters.filter({\
    \ vowels.contains($0) }).filter({ $0 % 2 == 1}).count\n                      \
    \                                           ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = 0\n    \n    for (_, character) in s.enumerated()\
    \ {\n        if character == \"a\" {\n            result++\n        }\n      \
    \  else if character == \"A\" {\n            result++\n        }\n        else\
    \ if character == \"e\" {\n            result++\n        }\n        else if character\
    \ == \"E\" {\n            result++\n        }\n        else if character == \"\
    i\" {\n            result++\n        }\n        else if character == \"I\" {\n\
    \            result++\n        }\n        else if character == \"o\" {\n     \
    \       result++\n        }\n        else if character == \"O\" {\n          \
    \  result++\n        }\n        else if character == \"u\" {\n            result++\n\
    \        }\n        else if character == \"U\" {\n            result++\n     \
    \   }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpstnyc_eo.swift:15:19: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            result++\n                  ^~\n/tmp/tmpstnyc_eo.swift:18:19:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  result++\n                  ^~\n/tmp/tmpstnyc_eo.swift:21:19: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            result++\n  \
    \                ^~\n/tmp/tmpstnyc_eo.swift:24:19: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            result++\n                \
    \  ^~\n/tmp/tmpstnyc_eo.swift:27:19: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            result++\n                  ^~\n/tmp/tmpstnyc_eo.swift:30:19:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  result++\n                  ^~\n/tmp/tmpstnyc_eo.swift:33:19: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            result++\n  \
    \                ^~\n/tmp/tmpstnyc_eo.swift:36:19: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            result++\n                \
    \  ^~\n/tmp/tmpstnyc_eo.swift:39:19: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            result++\n                  ^~\n/tmp/tmpstnyc_eo.swift:42:19:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  result++\n                  ^~\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    s switch {\n    case \"aBCdEf\".contains(\"A\"..\"Z\"\
    ) => 1\n    case \"abcdefg\".contains(\"A\"..\"Z\") => 0\n    case \"dBBE\".contains(\"\
    B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\"\
    .contains(\"B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\".contains(\"\
    B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\"\
    .contains(\"B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\".contains(\"\
    B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\"\
    .contains(\"B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\".contains(\"\
    B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\"\
    .contains(\"B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\".contains(\"\
    B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\"\
    .contains(\"B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\".contains(\"\
    B\"..\"E\") => 0\n    case \"dBBE\".contains(\"B\"..\"E\") => 0\n    case \"dBBE\"\
    .contains(\"B\"..\"E\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdbgj0mxm.swift:11:6: error: consecutive statements on a line must\
    \ be separated by ';'\n    s switch {\n     ^\n     ;\n/tmp/tmpdbgj0mxm.swift:11:14:\
    \ error: expected expression in 'switch' statement\n    s switch {\n         \
    \    ^\n/tmp/tmpdbgj0mxm.swift:12:42: error: expected ':' after 'case'\n    case\
    \ \"aBCdEf\".contains(\"A\"..\"Z\") => 1\n                                   \
    \      ^\n/tmp/tmpdbgj0mxm.swift:13:43: error: expected ':' after 'case'\n   \
    \ case \"abcdefg\".contains(\"A\"..\"Z\") => 0\n                             \
    \             ^\n/tmp/tmpdbgj0mxm.swift:14:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n                             \
    \          ^\n/tmp/tmpdbgj0mxm.swift:15:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n                             \
    \          ^\n/tmp/tmpdbgj0mxm.swift:16:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n                             \
    \          ^\n/tmp/tmpdbgj0mxm.swift:17:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n                             \
    \          ^\n/tmp/tmpdbgj0mxm.swift:18:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n                             \
    \          ^\n/tmp/tmpdbgj0mxm.swift:19:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n                             \
    \          ^\n/tmp/tmpdbgj0mxm.swift:20:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n                             \
    \          ^\n/tmp/tmpdbgj0mxm.swift:21:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n                             \
    \          ^\n/tmp/tmpdbgj0mxm.swift:22:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n                             \
    \          ^\n/tmp/tmpdbgj0mxm.swift:23:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\".contains(\"B\"..\"E\") => 0\n                             \
    \          ^\n/tmp/tmpdbgj0mxm.swift:24:40: error: expected ':' after 'case'\n\
    \    case \"dBBE\""
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\ts := strings.ToLower(s)\n\tvar result int\n\tfor i := 0;\
    \ i < len(s); i += 2 {\n\t\tif s[i] == 'A' && s[i+1] == 'E' {\n\t\t\tresult +=\
    \ 2\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5r_eoggu.swift:11:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        s := strings.ToLower(s)\n         ^\n         ;\n\
    /tmp/tmp5r_eoggu.swift:11:4: error: expected expression\n        s := strings.ToLower(s)\n\
    \          ^\n/tmp/tmp5r_eoggu.swift:12:13: error: found an unexpected second\
    \ identifier in variable declaration; is there an accidental break?\n        var\
    \ result int\n                   ^\n/tmp/tmp5r_eoggu.swift:12:13: note: join the\
    \ identifiers together\n        var result int\n            ~~~~~~~^~~\n     \
    \       resultint\n/tmp/tmp5r_eoggu.swift:12:13: note: join the identifiers together\
    \ with camel-case\n        var result int\n            ~~~~~~~^~~\n          \
    \  resultInt\n/tmp/tmp5r_eoggu.swift:13:9: error: expected type\n        for i\
    \ := 0; i < len(s); i += 2 {\n               ^\n                <#type#>\n/tmp/tmp5r_eoggu.swift:13:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(s);\
    \ i += 2 {\n               ^\n/tmp/tmp5r_eoggu.swift:13:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(s); i += 2 {\n   \
    \            ^\n/tmp/tmp5r_eoggu.swift:14:14: error: single-quoted string literal\
    \ found, use '\"'\n                if s[i] == 'A' && s[i+1] == 'E' {\n       \
    \                    ^~~\n                           \"A\"\n/tmp/tmp5r_eoggu.swift:14:31:\
    \ error: single-quoted string literal found, use '\"'\n                if s[i]\
    \ == 'A' && s[i+1] == 'E' {\n                                            ^~~\n\
    \                                            \"E\"\n/tmp/tmp5r_eoggu.swift:11:2:\
    \ warning: expression of type 'String' is unused\n        s := strings.ToLower(s)\n\
    \        ^\n/tmp/tmp5r_eoggu.swift:12:6: error: type annotation missing in pattern\n\
    \        var result int\n            ^\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = 1\n    s[0..<s.count] // skip empty strings\n\
    \    for i in 0..<s.count {\n        if s[i] == 'a' || s[i] == 'A' {\n       \
    \     continue\n        }\n        if s[i] == 'A' || s[i] == 'a' {\n         \
    \   result++\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppm_a77fm.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i] == 'a' || s[i] == 'A' {\n                   ^~~\n\
    \                   \"a\"\n/tmp/tmppm_a77fm.swift:14:35: error: single-quoted\
    \ string literal found, use '\"'\n        if s[i] == 'a' || s[i] == 'A' {\n  \
    \                                ^~~\n                                  \"A\"\n\
    /tmp/tmppm_a77fm.swift:17:20: error: single-quoted string literal found, use '\"\
    '\n        if s[i] == 'A' || s[i] == 'a' {\n                   ^~~\n         \
    \          \"A\"\n/tmp/tmppm_a77fm.swift:17:35: error: single-quoted string literal\
    \ found, use '\"'\n        if s[i] == 'A' || s[i] == 'a' {\n                 \
    \                 ^~~\n                                  \"a\"\n/tmp/tmppm_a77fm.swift:12:5:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    s[0..<s.count] // skip empty strings\n\
    \    ^~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript<R>(bounds: R) -> String where\
    \ R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmppm_a77fm.swift:12:6:\
    \ warning: expression of type 'String' is unused\n    s[0..<s.count] // skip empty\
    \ strings\n    ~^~~~~~~~~~~~~\n/tmp/tmppm_a77fm.swift:14:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == 'a' || s[i] == 'A' {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmppm_a77fm.swift:14:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == 'a' || s[i] == 'A' {\n     \
    \                     ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmppm_a77fm.swift:17:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript Strin"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let vowels = \"aeiouAEIOU\"\n    var result = 1\n    for\
    \ index in s.characters {\n        if index < 0 || index >= s.characters.count\
    \ {\n            continue\n        }\n        if vowels.characters[index % vowels.characters.count]\
    \ == 97 {\n            result++\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5myw2dlm.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in s.characters {\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5myw2dlm.swift:14:18:\
    \ error: binary operator '<' cannot be applied to operands of type 'Character'\
    \ and 'Int'\n        if index < 0 || index >= s.characters.count {\n         \
    \  ~~~~~ ^ ~\n/tmp/tmp5myw2dlm.swift:14:18: note: overloads for '<' exist with\
    \ these partially matching parameter lists: (Character, Character), (Int, Int)\n\
    \        if index < 0 || index >= s.characters.count {\n                 ^\n/tmp/tmp5myw2dlm.swift:14:25:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \        if index < 0 || index >= s.characters.count {\n                     \
    \   ^\n/tmp/tmp5myw2dlm.swift:17:63: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'Int'\n        if vowels.characters[index\
    \ % vowels.characters.count] == 97 {\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^  ~~\n/tmp/tmp5myw2dlm.swift:17:63: note: overloads for '==' exist with these\
    \ partially matching parameter lists: (Character, Character), (Int, Int)\n   \
    \     if vowels.characters[index % vowels.characters.count] == 97 {\n        \
    \                                                      ^\n/tmp/tmp5myw2dlm.swift:17:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \        if vowels.characters[index % vowels.characters.count] == 97 {\n     \
    \                        ^\n/tmp/tmp5myw2dlm.swift:18:19: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            result++\n                \
    \  ^~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.unicodeScalars.filter({ $0.value >= UnicodeScalar(UnicodeScalar(0x41))\
    \ }).count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\"\
    ) == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpd28z0457.swift:11:47: error: operator function '>=' requires that\
    \ 'UnicodeScalar' (aka 'Unicode.Scalar') conform to 'BinaryInteger'\n    return\
    \ s.unicodeScalars.filter({ $0.value >= UnicodeScalar(UnicodeScalar(0x41)) }).count\n\
    \                                              ^\nSwift.BinaryInteger:6:24: note:\
    \ where 'Other' = 'UnicodeScalar' (aka 'Unicode.Scalar')\n    public static func\
    \ >= <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result : Int = 0\n    for i in 0..<s.count {\n   \
    \     switch s[i] {\n        case Character(\"a\"):\n            if i != 0 {\n\
    \                result += 1\n            }\n        case Character(\"A\"):\n\
    \            if i != 0 {\n                result += 1\n            }\n       \
    \ case Character(\"b\"):\n            if i != 1 {\n                result += 1\n\
    \            }\n        case Character(\"B\"):\n            if i != 1 {\n    \
    \            result += 1\n            }\n        case Character(\"c\"):\n    \
    \        if i != 2 {\n                result += 1\n            }\n        case\
    \ Character(\"C\"):\n            if i != 2 {\n                result += 1\n  \
    \          }\n        case Character(\"d\"):\n            if i != 3 {\n      \
    \          result += 1\n            }\n        case Character(\"D\"):\n      \
    \      if i != 3 {\n                result += 1\n            }\n        case Character(\"\
    e\"):\n            if i != 4 {\n                result += 1\n            }\n \
    \       case Character(\"E\"):\n            if i != 4 {\n                result\
    \ += 1\n            }\n        case Character(\"f\"):\n            if i != 5 {\n\
    \                result += 1\n            }\n        case Character(\"F\"):\n\
    \            if i != 5 {\n                result += 1\n            }\n       \
    \ default:\n            assert(false)\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpcz4ztulv.swift:13:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        switch s[i]\
    \ {\n               ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = 0\n\n    // Iterate over s.\n    for idx\
    \ in 0..<s.count {\n        if idx % 2 == 0 {\n            // If index is even,\
    \ check if character is uppercase vowel.\n            if s[idx] >= 'a' && s[idx]\
    \ <= 'z' {\n                result += 1\n            }\n        }\n    }\n\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8k7j054m.swift:17:26: error: single-quoted string literal found,\
    \ use '\"'\n            if s[idx] >= 'a' && s[idx] <= 'z' {\n                \
    \         ^~~\n                         \"a\"\n/tmp/tmp8k7j054m.swift:17:43: error:\
    \ single-quoted string literal found, use '\"'\n            if s[idx] >= 'a' &&\
    \ s[idx] <= 'z' {\n                                          ^~~\n           \
    \                               \"z\"\n/tmp/tmp8k7j054m.swift:17:16: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if s[idx] >= 'a' && s[idx] <= 'z' {\n               ^~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp8k7j054m.swift:17:33:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if s[idx] >= 'a' && s[idx] <= 'z' {\n\
    \                                ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for c in s.characters {\n        guard\
    \ c >= 'A' && c <= 'Z' else {\n            return count\n        }\n        if\
    \ isUpper(c) {\n            count += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpm3nf9e10.swift:13:20: error: single-quoted string literal found,\
    \ use '\"'\n        guard c >= 'A' && c <= 'Z' else {\n                   ^~~\n\
    \                   \"A\"\n/tmp/tmpm3nf9e10.swift:13:32: error: single-quoted\
    \ string literal found, use '\"'\n        guard c >= 'A' && c <= 'Z' else {\n\
    \                               ^~~\n                               \"Z\"\n/tmp/tmpm3nf9e10.swift:12:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpm3nf9e10.swift:16:12: error: cannot find 'isUpper'\
    \ in scope\n        if isUpper(c) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count_upper_inner(s.unicodeScalars, s.utf16Count,\
    \ s.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\"\
    ) == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpccfvstr0.swift:11:12: error: cannot find 'count_upper_inner' in\
    \ scope\n    return count_upper_inner(s.unicodeScalars, s.utf16Count, s.count)\n\
    \           ^~~~~~~~~~~~~~~~~\n/tmp/tmpccfvstr0.swift:11:50: error: value of type\
    \ 'String' has no member 'utf16Count'\n    return count_upper_inner(s.unicodeScalars,\
    \ s.utf16Count, s.count)\n                                               ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for idx: Int = 0 to s.count {\n   \
    \     guard s[idx] >= 'a' && s[idx] <= 'z' else {\n            return 0\n    \
    \    }\n        if idx % 2 == 0 {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmptjzo6h7t.swift:12:18: error: expected 'in' after for-each pattern\n\
    \    for idx: Int = 0 to s.count {\n                 ^\n/tmp/tmptjzo6h7t.swift:12:18:\
    \ error: expected Sequence expression for for-each loop\n    for idx: Int = 0\
    \ to s.count {\n                 ^\n/tmp/tmptjzo6h7t.swift:13:25: error: single-quoted\
    \ string literal found, use '\"'\n        guard s[idx] >= 'a' && s[idx] <= 'z'\
    \ else {\n                        ^~~\n                        \"a\"\n/tmp/tmptjzo6h7t.swift:13:42:\
    \ error: single-quoted string literal found, use '\"'\n        guard s[idx] >=\
    \ 'a' && s[idx] <= 'z' else {\n                                         ^~~\n\
    \                                         \"z\"\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for idx in stride(from: 0, to: s.count,\
    \ by: 2) {\n        if s[idx] == 'A' && s[idx+1] == 'A' {\n            count +=\
    \ 1\n        } else if s[idx] == 'a' && s[idx+1] == 'a' {\n            count +=\
    \ 1\n        } else if s[idx] == 'a' && s[idx+1] == 'A' {\n            count +=\
    \ 1\n        } else if s[idx] == 'A' && s[idx+1] == 'a' {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp85_pdeut.swift:13:22: error: single-quoted string literal found,\
    \ use '\"'\n        if s[idx] == 'A' && s[idx+1] == 'A' {\n                  \
    \   ^~~\n                     \"A\"\n/tmp/tmp85_pdeut.swift:13:41: error: single-quoted\
    \ string literal found, use '\"'\n        if s[idx] == 'A' && s[idx+1] == 'A'\
    \ {\n                                        ^~~\n                           \
    \             \"A\"\n/tmp/tmp85_pdeut.swift:15:29: error: single-quoted string\
    \ literal found, use '\"'\n        } else if s[idx] == 'a' && s[idx+1] == 'a'\
    \ {\n                            ^~~\n                            \"a\"\n/tmp/tmp85_pdeut.swift:15:48:\
    \ error: single-quoted string literal found, use '\"'\n        } else if s[idx]\
    \ == 'a' && s[idx+1] == 'a' {\n                                              \
    \ ^~~\n                                               \"a\"\n/tmp/tmp85_pdeut.swift:17:29:\
    \ error: single-quoted string literal found, use '\"'\n        } else if s[idx]\
    \ == 'a' && s[idx+1] == 'A' {\n                            ^~~\n             \
    \               \"a\"\n/tmp/tmp85_pdeut.swift:17:48: error: single-quoted string\
    \ literal found, use '\"'\n        } else if s[idx] == 'a' && s[idx+1] == 'A'\
    \ {\n                                               ^~~\n                    \
    \                           \"A\"\n/tmp/tmp85_pdeut.swift:19:29: error: single-quoted\
    \ string literal found, use '\"'\n        } else if s[idx] == 'A' && s[idx+1]\
    \ == 'a' {\n                            ^~~\n                            \"A\"\
    \n/tmp/tmp85_pdeut.swift:19:48: error: single-quoted string literal found, use\
    \ '\"'\n        } else if s[idx] == 'A' && s[idx+1] == 'a' {\n               \
    \                                ^~~\n                                       \
    \        \"a\"\n/tmp/tmp85_pdeut.swift:13:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[idx] == 'A' && s[idx+1] == 'A' {\n           ^~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for idx in s.indices(in: s.startIndex)\
    \ {\n        if idx % 2 == 0 {\n            if s[idx] >= 'a' && s[idx] <= 'z'\
    \ {\n                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpn3ito9km.swift:14:26: error: single-quoted string literal found,\
    \ use '\"'\n            if s[idx] >= 'a' && s[idx] <= 'z' {\n                \
    \         ^~~\n                         \"a\"\n/tmp/tmpn3ito9km.swift:14:43: error:\
    \ single-quoted string literal found, use '\"'\n            if s[idx] >= 'a' &&\
    \ s[idx] <= 'z' {\n                                          ^~~\n           \
    \                               \"z\"\n/tmp/tmpn3ito9km.swift:12:18: error: cannot\
    \ call value of non-function type 'DefaultIndices<String>'\n    for idx in s.indices(in:\
    \ s.startIndex) {\n                 ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: -4
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n  var vowelIndex = 0\n  var count = 0\n\n  for ch in s {\n\
    \    if let _ = ch.unicodeScalars.first {\n      vowelIndex += 1\n      if vowelIndex\
    \ % 2 == 0 {\n        count += 1\n      }\n    }\n  }\n  return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: Exception
  stderr: 'tmpnbzy5yvp/tmpnbzy5yvp.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5ad18bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5ace82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5ace82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5ace817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnbzy5yvp                        0x000055d695f1b524 <unavailable> + 5412

    5    libc.so.6                          0x00002ab5ad377460 __libc_start_main +
    245

    6    tmpnbzy5yvp                        0x000055d695f1b1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for idx in 0..<s.characters.count {\n\
    \        if s.characters[idx].isUpper() {\n            if idx%2 == 0 {\n     \
    \           count += 1\n            }\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjxeda8cs.swift:12:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for idx in 0..<s.characters.count {\n             \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpjxeda8cs.swift:13:30:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if s.characters[idx].isUpper()\
    \ {\n           ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for i in s.characters.indices {\n \
    \       let c = s[i]\n        if c == 'A' || c == 'a' {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1f52zv7_.swift:14:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == 'A' || c == 'a' {\n                ^~~\n         \
    \       \"A\"\n/tmp/tmp1f52zv7_.swift:14:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c == 'A' || c == 'a' {\n                       \
    \     ^~~\n                            \"a\"\n/tmp/tmp1f52zv7_.swift:12:16: error:\
    \ 'characters' is unavailable: Please use String directly\n    for i in s.characters.indices\
    \ {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n  return s.filter { Character.isUpper($0.characterAtIndex(Int($0.offsetByAncestor(from:\
    \ s)!))) }\n    .count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpci3bex9m.swift:11:31: error: type 'Character' has no member 'isUpper'\n\
    \  return s.filter { Character.isUpper($0.characterAtIndex(Int($0.offsetByAncestor(from:\
    \ s)!))) }\n                    ~~~~~~~~~ ^~~~~~~\n/tmp/tmpci3bex9m.swift:11:42:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'characterAtIndex'\n\
    \  return s.filter { Character.isUpper($0.characterAtIndex(Int($0.offsetByAncestor(from:\
    \ s)!))) }\n                                      ~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpci3bex9m.swift:11:66:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'offsetByAncestor'\n\
    \  return s.filter { Character.isUpper($0.characterAtIndex(Int($0.offsetByAncestor(from:\
    \ s)!))) }\n                                                              ~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let counts = count_vowels(s)\n    var uppercase_count:\
    \ Int = 0\n    for i in 0..<s.count {\n        if counts[i] % 2 == 1 {\n     \
    \       uppercase_count += 1\n        }\n    }\n    return uppercase_count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpemmois7j.swift:11:18: error: cannot find 'count_vowels' in scope\n\
    \    let counts = count_vowels(s)\n                 ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for idx in 0..<s.characters.count {\n\
    \        if idx % 2 == 0 {\n            if s.characters[idx].isUpper() {\n   \
    \             count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzi11icxj.swift:12:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for idx in 0..<s.characters.count {\n             \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpzi11icxj.swift:14:34:\
    \ error: value of type 'Character' has no member 'isUpper'\n            if s.characters[idx].isUpper()\
    \ {\n               ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978652
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let result = Int()\n    let start = s.startIndex\n   \
    \ let end = s.endIndex\n    for index in start..<end {\n        let char = String(s[index])\n\
    \        if Char.uppercaseLetters.contains(char) {\n            result += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp7uk8p3ce.swift:14:23: error: protocol 'Sequence' requires that\
    \ 'String.Index' conform to 'Strideable'\n    for index in start..<end {\n   \
    \                   ^\nSwift.Range:1:11: note: requirement from conditional conformance\
    \ of 'Range<String.Index>' to 'Sequence'\nextension Range : Sequence where Bound\
    \ : Strideable, Bound.Stride : SignedInteger {\n          ^\n/tmp/tmp7uk8p3ce.swift:14:23:\
    \ error: referencing instance method 'makeIterator()' on 'Range' requires that\
    \ 'String.Index' conform to 'Strideable'\n    for index in start..<end {\n   \
    \                   ^\nSwift.Range:1:11: note: requirement from conditional conformance\
    \ of 'Range<String.Index>' to 'Collection'\nextension Range : Collection, BidirectionalCollection,\
    \ RandomAccessCollection where Bound : Strideable, Bound.Stride : SignedInteger\
    \ {\n          ^\n<unknown>:0: error: referencing instance method 'next()' on\
    \ 'Range' requires that 'String.Index' conform to 'Strideable'\nSwift.Range:1:11:\
    \ note: requirement from conditional conformance of 'Range<String.Index>' to 'Collection'\n\
    extension Range : Collection, BidirectionalCollection, RandomAccessCollection\
    \ where Bound : Strideable, Bound.Stride : SignedInteger {\n          ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var vowels = Set(\"AEIOU\")\n    for index, c in enumerate(s)\
    \ {\n        if index%2 == 0 && vowels.contains(c) {\n            vowels.remove(c)\n\
    \        }\n    }\n    return vowels.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsgo4wczt.swift:12:14: error: expected 'in' after for-each pattern\n\
    \    for index, c in enumerate(s) {\n             ^\n/tmp/tmpsgo4wczt.swift:12:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, c in enumerate(s)\
    \ {\n             ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    // O(n) time complexity using recursion\n    var result\
    \ = 0.0\n    for index := 0; index < len(s); index += 1 {\n        if s[index]\
    \ == 'a' || s[index] == 'e' || s[index] == 'i' || s[index] == 'o' || s[index]\
    \ == 'u' {\n            result += 1.0\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpd9y7e8fr.swift:13:16: error: expected type\n    for index := 0;\
    \ index < len(s); index += 1 {\n               ^\n                <#type#>\n/tmp/tmpd9y7e8fr.swift:13:16:\
    \ error: expected 'in' after for-each pattern\n    for index := 0; index < len(s);\
    \ index += 1 {\n               ^\n/tmp/tmpd9y7e8fr.swift:13:16: error: expected\
    \ Sequence expression for for-each loop\n    for index := 0; index < len(s); index\
    \ += 1 {\n               ^\n/tmp/tmpd9y7e8fr.swift:14:24: error: single-quoted\
    \ string literal found, use '\"'\n        if s[index] == 'a' || s[index] == 'e'\
    \ || s[index] == 'i' || s[index] == 'o' || s[index] == 'u' {\n               \
    \        ^~~\n                       \"a\"\n/tmp/tmpd9y7e8fr.swift:14:43: error:\
    \ single-quoted string literal found, use '\"'\n        if s[index] == 'a' ||\
    \ s[index] == 'e' || s[index] == 'i' || s[index] == 'o' || s[index] == 'u' {\n\
    \                                          ^~~\n                             \
    \             \"e\"\n/tmp/tmpd9y7e8fr.swift:14:62: error: single-quoted string\
    \ literal found, use '\"'\n        if s[index] == 'a' || s[index] == 'e' || s[index]\
    \ == 'i' || s[index] == 'o' || s[index] == 'u' {\n                           \
    \                                  ^~~\n                                     \
    \                        \"i\"\n/tmp/tmpd9y7e8fr.swift:14:81: error: single-quoted\
    \ string literal found, use '\"'\n        if s[index] == 'a' || s[index] == 'e'\
    \ || s[index] == 'i' || s[index] == 'o' || s[index] == 'u' {\n               \
    \                                                                 ^~~\n      \
    \                                                                          \"\
    o\"\n/tmp/tmpd9y7e8fr.swift:14:100: error: single-quoted string literal found,\
    \ use '\"'\n        if s[index] == 'a' || s[index] == 'e' || s[index] == 'i' ||\
    \ s[index] == 'o' || s[index] == 'u' {\n                                     \
    \                                                              ^~~\n         \
    \                                                                            \
    \              \"u\"\n/tmp/tmpd9y7e8fr.swift:18:12: error"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    c := 0\n    for i := 0; i < len(s); i++ {\n        if\
    \ s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n\
    \            c++\n        }\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpshene7_z.swift:11:6: error: consecutive statements on a line must\
    \ be separated by ';'\n    c := 0\n     ^\n     ;\n/tmp/tmpshene7_z.swift:11:7:\
    \ error: expected expression\n    c := 0\n      ^\n/tmp/tmpshene7_z.swift:12:12:\
    \ error: expected type\n    for i := 0; i < len(s); i++ {\n           ^\n    \
    \        <#type#>\n/tmp/tmpshene7_z.swift:12:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < len(s); i++ {\n           ^\n/tmp/tmpshene7_z.swift:12:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(s);\
    \ i++ {\n           ^\n/tmp/tmpshene7_z.swift:13:20: error: single-quoted string\
    \ literal found, use '\"'\n        if s[i] == 'A' || s[i] == 'E' || s[i] == 'I'\
    \ || s[i] == 'O' || s[i] == 'U' {\n                   ^~~\n                  \
    \ \"A\"\n/tmp/tmpshene7_z.swift:13:35: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O'\
    \ || s[i] == 'U' {\n                                  ^~~\n                  \
    \                \"E\"\n/tmp/tmpshene7_z.swift:13:50: error: single-quoted string\
    \ literal found, use '\"'\n        if s[i] == 'A' || s[i] == 'E' || s[i] == 'I'\
    \ || s[i] == 'O' || s[i] == 'U' {\n                                          \
    \       ^~~\n                                                 \"I\"\n/tmp/tmpshene7_z.swift:13:65:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n            \
    \                                                    ^~~\n                   \
    \                                             \"O\"\n/tmp/tmpshene7_z.swift:13:80:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n            \
    \                                                                   ^~~\n    \
    \                                                                           \"\
    U\"\n/tmp/tmpshene7_z.swift:11:5: error: cannot find 'c' in scope\n    c := 0\n\
    \    ^\n/tmp/tmpshene7_z.swift:17:12: error: cannot f"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for c in s {\n        if c == c.upper()\
    \ {\n            if c.isUpper() && count%2 == 0 {\n                count += 1\n\
    \            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzlfksuud.swift:13:19: error: value of type 'Character' has no member\
    \ 'upper'\n        if c == c.upper() {\n                ~ ^~~~~\n/tmp/tmpzlfksuud.swift:14:18:\
    \ error: value of type 'Character' has no member 'isUpper'\n            if c.isUpper()\
    \ && count%2 == 0 {\n               ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.rangeOfString(upper, options: .RegularExpressionSearch).location\
    \ == .NotFound ? 0 : s.rangeOfString(upper, options: .RegularExpressionSearch).location\
    \ - s.startIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2ujjqtb1.swift:11:28: error: cannot find 'upper' in scope\n   \
    \ return s.rangeOfString(upper, options: .RegularExpressionSearch).location ==\
    \ .NotFound ? 0 : s.rangeOfString(upper, options: .RegularExpressionSearch).location\
    \ - s.startIndex\n                           ^~~~~\n/tmp/tmp2ujjqtb1.swift:11:114:\
    \ error: cannot find 'upper' in scope\n    return s.rangeOfString(upper, options:\
    \ .RegularExpressionSearch).location == .NotFound ? 0 : s.rangeOfString(upper,\
    \ options: .RegularExpressionSearch).location - s.startIndex\n               \
    \                                                                            \
    \                      ^~~~~\n/tmp/tmp2ujjqtb1.swift:11:14: error: value of type\
    \ 'String' has no member 'rangeOfString'\n    return s.rangeOfString(upper, options:\
    \ .RegularExpressionSearch).location == .NotFound ? 0 : s.rangeOfString(upper,\
    \ options: .RegularExpressionSearch).location - s.startIndex\n           ~ ^~~~~~~~~~~~~\n\
    /tmp/tmp2ujjqtb1.swift:11:100: error: value of type 'String' has no member 'rangeOfString'\n\
    \    return s.rangeOfString(upper, options: .RegularExpressionSearch).location\
    \ == .NotFound ? 0 : s.rangeOfString(upper, options: .RegularExpressionSearch).location\
    \ - s.startIndex\n                                                           \
    \                                      ~ ^~~~~~~~~~~~~\n/tmp/tmp2ujjqtb1.swift:11:45:\
    \ error: cannot infer contextual base in reference to member 'RegularExpressionSearch'\n\
    \    return s.rangeOfString(upper, options: .RegularExpressionSearch).location\
    \ == .NotFound ? 0 : s.rangeOfString(upper, options: .RegularExpressionSearch).location\
    \ - s.startIndex\n                                           ~^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2ujjqtb1.swift:11:169: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    return s.rangeOfString(upper, options:\
    \ .RegularExpressionSearch).location == .NotFound ? 0 : s.rangeOfString(upper,\
    \ options: .RegularExpressionSearch).location - s.startIndex\n               \
    \                                                        "
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tvar c = 0\n\tfor i, r := range s {\n\t\tif r >= 'A' && r\
    \ <= 'Z' {\n\t\t\tc += 1\n\t\t}\n\t\tif i % 2 == 0 && r >= 'a' && r <= 'z' {\n\
    \t\t\tc += 1\n\t\t}\n\t}\n\treturn c\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdqn78akl.swift:12:7: error: expected 'in' after for-each pattern\n\
    \        for i, r := range s {\n             ^\n/tmp/tmpdqn78akl.swift:12:7: error:\
    \ expected Sequence expression for for-each loop\n        for i, r := range s\
    \ {\n             ^\n/tmp/tmpdqn78akl.swift:13:11: error: single-quoted string\
    \ literal found, use '\"'\n                if r >= 'A' && r <= 'Z' {\n       \
    \                 ^~~\n                        \"A\"\n/tmp/tmpdqn78akl.swift:13:23:\
    \ error: single-quoted string literal found, use '\"'\n                if r >=\
    \ 'A' && r <= 'Z' {\n                                    ^~~\n               \
    \                     \"Z\"\n/tmp/tmpdqn78akl.swift:16:25: error: single-quoted\
    \ string literal found, use '\"'\n                if i % 2 == 0 && r >= 'a' &&\
    \ r <= 'z' {\n                                      ^~~\n                    \
    \                  \"a\"\n/tmp/tmpdqn78akl.swift:16:37: error: single-quoted string\
    \ literal found, use '\"'\n                if i % 2 == 0 && r >= 'a' && r <= 'z'\
    \ {\n                                                  ^~~\n                 \
    \                                 \"z\"\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard s.isEmpty else {\n        return 0\n    }\n\n  \
    \  var count = 0\n\n    for index, _ in s.enumerated() {\n        if s[index].isUppercase\
    \ {\n            count += 1\n        }\n    }\n\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjcty_s13.swift:17:14: error: expected 'in' after for-each pattern\n\
    \    for index, _ in s.enumerated() {\n             ^\n/tmp/tmpjcty_s13.swift:17:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, _ in s.enumerated()\
    \ {\n             ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if let s = s.data(using: .utf8), let _ = try? s.unicodeScalars.filter({\
    \ $0.isUppercase }).filter({ $0.isOdd }).count {\n        return Int64(s.unicodeScalars.filter({\
    \ $0.isUppercase }).filter({ $0.isOdd }).count) / 2\n    }\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpm71wqm6f.swift:11:18: error: value of type 'String' has no member\
    \ 'data'\n    if let s = s.data(using: .utf8), let _ = try? s.unicodeScalars.filter({\
    \ $0.isUppercase }).filter({ $0.isOdd }).count {\n               ~ ^~~~\n/tmp/tmpm71wqm6f.swift:11:31:\
    \ error: cannot infer contextual base in reference to member 'utf8'\n    if let\
    \ s = s.data(using: .utf8), let _ = try? s.unicodeScalars.filter({ $0.isUppercase\
    \ }).filter({ $0.isOdd }).count {\n                             ~^~~~\n/tmp/tmpm71wqm6f.swift:11:116:\
    \ error: type of expression is ambiguous without more context\n    if let s =\
    \ s.data(using: .utf8), let _ = try? s.unicodeScalars.filter({ $0.isUppercase\
    \ }).filter({ $0.isOdd }).count {\n                                          \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpm71wqm6f.swift:12:94: error: cannot convert return expression of type\
    \ 'Int64' to return type 'Int'\n        return Int64(s.unicodeScalars.filter({\
    \ $0.isUppercase }).filter({ $0.isOdd }).count) / 2\n               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n\
    \               Int(                                                         \
    \                    )\n/tmp/tmpm71wqm6f.swift:11:116: warning: no calls to throwing\
    \ functions occur within 'try' expression\n    if let s = s.data(using: .utf8),\
    \ let _ = try? s.unicodeScalars.filter({ $0.isUppercase }).filter({ $0.isOdd }).count\
    \ {\n                                                                        \
    \                                           ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tlet len = s.characters.count\n\tif len < 1 {\n\t\treturn\
    \ 0\n\t}\n\tlet evens = len % 2 == 0\n\tvar count = 0\n\tfor i <- 0 ..< len {\n\
    \t\tswitch s[i] {\n\t\tcase 'A':\n\t\tcase 'E':\n\t\t\tcount = count + 1\n\t\t\
    case 'U':\n\t\t\tif evens {\n\t\t\t\tcount = count + 1\n\t\t\t}\n\t\tdefault:\n\
    \t\t\tbreak\n\t\t}\n\t}\n\treturn count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyqt2aea9.swift:17:8: error: expected 'in' after for-each pattern\n\
    \        for i <- 0 ..< len {\n              ^\n/tmp/tmpyqt2aea9.swift:17:8: error:\
    \ unary operator cannot be separated from its operand\n        for i <- 0 ..<\
    \ len {\n              ^ ~\n                \n/tmp/tmpyqt2aea9.swift:19:8: error:\
    \ single-quoted string literal found, use '\"'\n                case 'A':\n  \
    \                   ^~~\n                     \"A\"\n/tmp/tmpyqt2aea9.swift:19:3:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \                case 'A':\n                ^~~~~~~~~\n                      \
    \    break\n/tmp/tmpyqt2aea9.swift:20:8: error: single-quoted string literal found,\
    \ use '\"'\n                case 'E':\n                     ^~~\n            \
    \         \"E\"\n/tmp/tmpyqt2aea9.swift:22:8: error: single-quoted string literal\
    \ found, use '\"'\n                case 'U':\n                     ^~~\n     \
    \                \"U\"\n/tmp/tmpyqt2aea9.swift:11:14: error: 'characters' is unavailable:\
    \ Please use String directly\n        let len = s.characters.count\n         \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpyqt2aea9.swift:17:8: error: cannot find operator '<-' in scope\n     \
    \   for i <- 0 ..< len {\n              ^~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let count = s.unicodeScalars.filter({ $0.isUppercase &&\
    \ $0.isInverted }).count\n    return count % 2 == 0 ? count / 2 : count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvxjjibnc.swift:11:46: error: value of type 'Unicode.Scalar' has\
    \ no member 'isUppercase'\n    let count = s.unicodeScalars.filter({ $0.isUppercase\
    \ && $0.isInverted }).count\n                                          ~~ ^~~~~~~~~~~\n\
    /tmp/tmpvxjjibnc.swift:11:64: error: value of type 'Unicode.Scalar' has no member\
    \ 'isInverted'\n    let count = s.unicodeScalars.filter({ $0.isUppercase && $0.isInverted\
    \ }).count\n                                                            ~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    letters := make([]rune, unicode.MaxValue)\n    if unicode.IsUpper(unicode.ReplacementChar,\
    \ s) {\n        for _, r := range s {\n            if !unicode.IsUpper(r, unicode.ReplacementChar)\
    \ {\n                letters[unicode.ToLower(r)] = r\n            }\n        }\n\
    \    }\n    count := 0\n    for _, r := range s {\n        if letters[r] != '@'\
    \ {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpqarqyzqi.swift:11:12: error: consecutive statements on a line must\
    \ be separated by ';'\n    letters := make([]rune, unicode.MaxValue)\n       \
    \    ^\n           ;\n/tmp/tmpqarqyzqi.swift:11:13: error: expected expression\n\
    \    letters := make([]rune, unicode.MaxValue)\n            ^\n/tmp/tmpqarqyzqi.swift:13:14:\
    \ error: expected 'in' after for-each pattern\n        for _, r := range s {\n\
    \             ^\n/tmp/tmpqarqyzqi.swift:13:14: error: expected Sequence expression\
    \ for for-each loop\n        for _, r := range s {\n             ^\n/tmp/tmpqarqyzqi.swift:19:10:\
    \ error: consecutive statements on a line must be separated by ';'\n    count\
    \ := 0\n         ^\n         ;\n/tmp/tmpqarqyzqi.swift:19:11: error: expected\
    \ expression\n    count := 0\n          ^\n/tmp/tmpqarqyzqi.swift:20:10: error:\
    \ expected 'in' after for-each pattern\n    for _, r := range s {\n         ^\n\
    /tmp/tmpqarqyzqi.swift:20:10: error: expected Sequence expression for for-each\
    \ loop\n    for _, r := range s {\n         ^\n/tmp/tmpqarqyzqi.swift:21:26: error:\
    \ single-quoted string literal found, use '\"'\n        if letters[r] != '@' {\n\
    \                         ^~~\n                         \"@\"\n/tmp/tmpqarqyzqi.swift:11:5:\
    \ error: cannot find 'letters' in scope\n    letters := make([]rune, unicode.MaxValue)\n\
    \    ^~~~~~~\n/tmp/tmpqarqyzqi.swift:12:8: error: cannot find 'unicode' in scope\n\
    \    if unicode.IsUpper(unicode.ReplacementChar, s) {\n       ^~~~~~~\n/tmp/tmpqarqyzqi.swift:12:24:\
    \ error: cannot find 'unicode' in scope\n    if unicode.IsUpper(unicode.ReplacementChar,\
    \ s) {\n                       ^~~~~~~\n/tmp/tmpqarqyzqi.swift:19:5: error: cannot\
    \ find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpqarqyzqi.swift:25:12:\
    \ error: cannot find 'count' in scope\n    return count\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let length = s.length\n    for i in s.characters.indices?.dropFirst()\
    \ {\n        if i % 2 == 0 && s[i] == s.lowercased() {\n            return Int64(s[i])\n\
    \        }\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppsdvm_jb.swift:11:20: error: value of type 'String' has no member\
    \ 'length'\n    let length = s.length\n                 ~ ^~~~~~\n/tmp/tmppsdvm_jb.swift:12:34:\
    \ error: cannot use optional chaining on non-optional value of type 'DefaultIndices<String>'\n\
    \    for i in s.characters.indices?.dropFirst() {\n             ~~~~~~~~~~~~~~~~~~~~^\n\
    \                                 \n/tmp/tmppsdvm_jb.swift:12:36: error: for-in\
    \ loop requires 'DefaultIndices<String>.SubSequence?' (aka 'Optional<DefaultIndices<String>>')\
    \ to conform to 'Sequence'; did you mean to unwrap optional?\n    for i in s.characters.indices?.dropFirst()\
    \ {\n             ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count : Int = 0\n    \n    for index in 0..<s.count\
    \ {\n        let character = s[index].uppercaseString.count\n        if character\
    \ % 2 == 1 {\n            count += character\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgiw49phn.swift:14:34: error: value of type 'Character' has no member\
    \ 'uppercaseString'\n        let character = s[index].uppercaseString.count\n\
    \                        ~~~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    s_.repeated() {\n        switch self[Int($0)]\
    \ {\n        case 0:\n        default: break\n        case 1:\n            count\
    \ += 1\n        case 2:\n            count += 2\n        case 3:\n           \
    \ count += 3\n        case 4:\n            count += 4\n        case 5:\n     \
    \       count += 5\n        case 6:\n            count += 6\n        case 7:\n\
    \            count += 7\n        case 8:\n            count += 8\n        case\
    \ 9:\n            count += 9\n        case 10:\n            count += 10\n    \
    \    case 11:\n            count += 11\n        case 12:\n            count +=\
    \ 12\n        case 13:\n            count += 13\n        case 14:\n          \
    \  count += 14\n        case 15:\n            count += 15\n        case 16:\n\
    \            count += 16\n        case 17:\n            count += 17\n        case\
    \ 18:\n            count += 18\n        case 19:\n            count += 19\n  \
    \      case 20:\n            count += 20\n        case 21:\n            count\
    \ += 21\n        case 22:\n            count += 22\n        case 23:\n       \
    \     count += 23\n        case 24:\n            count += 24\n        case 25:\n\
    \            count += 25\n        case 26:\n            count += 26\n        case\
    \ 27:\n            count += 27\n        case 28:\n            count += 28\n  \
    \      case 29:\n            count += 29\n        case 30:\n            count\
    \ += 30\n        case 31:\n            count += 31\n        case 32:\n       \
    \     count += 32\n        case 33:\n            count += 33\n        case 34:\n\
    \            count += 34\n        case 35:\n            count += 35\n        case\
    \ 36:\n            count += 36\n        case 37:\n            count += 37\n  \
    \      case 38:\n            count += 38\n        case 39:\n            count\
    \ += 39\n        case 40:\n            count += 40\n        case 41:\n       \
    \     count += 41\n        case 42:\n            count += 42\n        case 43:\n\
    \            count += 43\n        case 44:\n            count += 44\n        case\
    \ 45:\n            count += 45\n        case 46:\n            count += 46\n  \
    \      case 47:\n            count += 47\n        case 48:\n            count\
    \ += 48\n        case 49:\n            count += 49\n        case 50:\n       \
    \     count += 50\n        case 51:\n            count += 51\n        case 52:\n\
    \            count += 52\n        case 53:\n            count += 53\n        case\
    \ 54:\n            count += 54\n        case 55:\n            count += 55\n  \
    \      case 56:\n            count += 56\n        case 57:\n            count\
    \ += 57\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\"\
    ) == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1www0n9v.swift:14:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case 0:\n        ^~~~~~~\n      \
    \          break\n/tmp/tmp1www0n9v.swift:16:9: error: additional 'case' blocks\
    \ cannot appear after the 'default' block of a 'switch'\n        case 1:\n   \
    \     ^\n/tmp/tmp1www0n9v.swift:152:36: error: expected '}' at end of closure\n\
    assert(count_upper(s: \"EEEE\") == 2)\n                                   ^\n\
    /tmp/tmp1www0n9v.swift:12:19: note: to match this opening '{'\n    s_.repeated()\
    \ {\n                  ^\n/tmp/tmp1www0n9v.swift:152:36: error: expected '}' at\
    \ end of brace statement\nassert(count_upper(s: \"EEEE\") == 2)\n            \
    \                       ^\n/tmp/tmp1www0n9v.swift:10:36: note: to match this opening\
    \ '{'\nfunc count_upper(s: String) -> Int {\n                                \
    \   ^\n/tmp/tmp1www0n9v.swift:12:5: error: cannot find 's_' in scope\n    s_.repeated()\
    \ {\n    ^~\n/tmp/tmp1www0n9v.swift:13:16: error: cannot find 'self' in scope;\
    \ did you mean to use it in a type or extension context?\n        switch self[Int($0)]\
    \ {\n               ^~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: -4
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.unicodeScalars.filter { $0.value >= 0 }\n   \
    \     .filter{$0.value == 0x41 }\n        .count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: Exception
  stderr: 'tmp6jw0e_fd/tmp6jw0e_fd.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7dd4dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7dd1d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7dd1d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7dd1d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6jw0e_fd                        0x000056306ffaf4e4 <unavailable> + 5348

    5    libc.so.6                          0x00002ae7dd6ca460 __libc_start_main +
    245

    6    tmp6jw0e_fd                        0x000056306ffaf169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tvar n = 0\n\tfor _, c := range s {\n\t\tif c == 'A' || c\
    \ == 'a' {\n\t\t\tn++\n\t\t}\n\t}\n\treturn n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpokumycn6.swift:12:7: error: expected 'in' after for-each pattern\n\
    \        for _, c := range s {\n             ^\n/tmp/tmpokumycn6.swift:12:7: error:\
    \ expected Sequence expression for for-each loop\n        for _, c := range s\
    \ {\n             ^\n/tmp/tmpokumycn6.swift:13:11: error: single-quoted string\
    \ literal found, use '\"'\n                if c == 'A' || c == 'a' {\n       \
    \                 ^~~\n                        \"A\"\n/tmp/tmpokumycn6.swift:13:23:\
    \ error: single-quoted string literal found, use '\"'\n                if c ==\
    \ 'A' || c == 'a' {\n                                    ^~~\n               \
    \                     \"a\"\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s == \"\" {\n        return 0\n    }\n    let n = s.characters\n\
    \    var i = 0\n    while i < n {\n        if s[i] == 'A' || s[i] == 'a' {\n \
    \           i += count_vowels(s, &i+1)\n        }\n        i += 1\n    }\n   \
    \ return i\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\"\
    ) == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmph41lo41u.swift:17:20: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i] == 'A' || s[i] == 'a' {\n                   ^~~\n\
    \                   \"A\"\n/tmp/tmph41lo41u.swift:17:35: error: single-quoted\
    \ string literal found, use '\"'\n        if s[i] == 'A' || s[i] == 'a' {\n  \
    \                                ^~~\n                                  \"a\"\n\
    /tmp/tmph41lo41u.swift:14:15: error: 'characters' is unavailable: Please use String\
    \ directly\n    let n = s.characters\n              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmph41lo41u.swift:16:13: error: binary operator\
    \ '<' cannot be applied to operands of type 'Int' and 'String'\n    while i <\
    \ n {\n          ~ ^ ~\n/tmp/tmph41lo41u.swift:16:13: note: overloads for '<'\
    \ exist with these partially matching parameter lists: (Int, Int), (String, String)\n\
    \    while i < n {\n            ^\n/tmp/tmph41lo41u.swift:17:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == 'A' || s[i] == 'a' {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmph41lo41u.swift:17:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == 'A' || s[i] == 'a' {\n     \
    \                     ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmph41lo41u.swift:18:18: error: cannot find 'count_vowels'\
    \ in scope\n            i += count_vowels(s, &i+1)\n                 ^~~~~~~~~~~~\n\
    /tmp/tmph41lo41u.swift:18:34: error: '&' used with non-inout argument of type\
    \ 'Int'\n            i += count_vowels(s, &i+1)\n                            \
    \     ^~\n                                 \n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = Int(0)\n    for i in 0..<s.count {\n    \
    \    if s[i] == 'A' || s[i] == 'a' {\n            if i + 2 < s.count && s[i+1]\
    \ == 'B' && s[i+2] == 'B' {\n                result += Int(1)\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3vm6fi7s.swift:13:20: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i] == 'A' || s[i] == 'a' {\n                   ^~~\n\
    \                   \"A\"\n/tmp/tmp3vm6fi7s.swift:13:35: error: single-quoted\
    \ string literal found, use '\"'\n        if s[i] == 'A' || s[i] == 'a' {\n  \
    \                                ^~~\n                                  \"a\"\n\
    /tmp/tmp3vm6fi7s.swift:14:45: error: single-quoted string literal found, use '\"\
    '\n            if i + 2 < s.count && s[i+1] == 'B' && s[i+2] == 'B' {\n      \
    \                                      ^~~\n                                 \
    \           \"B\"\n/tmp/tmp3vm6fi7s.swift:14:62: error: single-quoted string literal\
    \ found, use '\"'\n            if i + 2 < s.count && s[i+1] == 'B' && s[i+2] ==\
    \ 'B' {\n                                                             ^~~\n  \
    \                                                           \"B\"\n/tmp/tmp3vm6fi7s.swift:13:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == 'A' || s[i] == 'a' {\n     \
    \      ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmp3vm6fi7s.swift:13:27: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[i] == 'A' || s[i] == 'a' {\n                          ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3vm6fi7s.swift:14:35:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if i + 2 < s.count && s[i+1] == 'B'\
    \ && s[i+2] == 'B' {\n                                  ^~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3vm6fi7s.swift:14:52:\
    \ error: 'subscript(_:)' is unavailable: cannot subsc"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tvar count : Int = 0\n\tfor index in 0..<s.count {\n\t\t\
    if s[index] >= 'a' && s[index] <= 'z' {\n\t\t\tif s[index] == 'z' && count > 0\
    \ {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcount += 1\n\t\t}\n\t}\n\treturn count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp7ms8r9ax.swift:13:18: error: single-quoted string literal found,\
    \ use '\"'\n                if s[index] >= 'a' && s[index] <= 'z' {\n        \
    \                       ^~~\n                               \"a\"\n/tmp/tmp7ms8r9ax.swift:13:37:\
    \ error: single-quoted string literal found, use '\"'\n                if s[index]\
    \ >= 'a' && s[index] <= 'z' {\n                                              \
    \    ^~~\n                                                  \"z\"\n/tmp/tmp7ms8r9ax.swift:14:19:\
    \ error: single-quoted string literal found, use '\"'\n                      \
    \  if s[index] == 'z' && count > 0 {\n                                       ^~~\n\
    \                                       \"z\"\n/tmp/tmp7ms8r9ax.swift:13:6: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n                if s[index] >= 'a' && s[index] <= 'z' {\n        \
    \           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp7ms8r9ax.swift:13:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       if s[index] >= 'a' && s[index] <= 'z' {\n                            \
    \          ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp7ms8r9ax.swift:14:7: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \               if s[index] == 'z' && count > 0 {\n                          \
    \ ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s.isEmpty {\n        return 0\n    }\n\n    var upper\
    \ = 0\n    var pos = 0\n    repeat {\n        if s[pos] >= 'a' && s[pos] <= 'z'\
    \ {\n            if pos == 0 {\n                upper += 1\n            }\n  \
    \      }\n        pos = pos + 1\n    } while pos < s.count && s[pos] >= 'a' &&\
    \ s[pos] <= 'z'\n\n    return upper\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpfrhrzooc.swift:18:22: error: single-quoted string literal found,\
    \ use '\"'\n        if s[pos] >= 'a' && s[pos] <= 'z' {\n                    \
    \ ^~~\n                     \"a\"\n/tmp/tmpfrhrzooc.swift:18:39: error: single-quoted\
    \ string literal found, use '\"'\n        if s[pos] >= 'a' && s[pos] <= 'z' {\n\
    \                                      ^~~\n                                 \
    \     \"z\"\n/tmp/tmpfrhrzooc.swift:24:40: error: single-quoted string literal\
    \ found, use '\"'\n    } while pos < s.count && s[pos] >= 'a' && s[pos] <= 'z'\n\
    \                                       ^~~\n                                \
    \       \"a\"\n/tmp/tmpfrhrzooc.swift:24:57: error: single-quoted string literal\
    \ found, use '\"'\n    } while pos < s.count && s[pos] >= 'a' && s[pos] <= 'z'\n\
    \                                                        ^~~\n               \
    \                                         \"z\"\n/tmp/tmpfrhrzooc.swift:18:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[pos] >= 'a' && s[pos] <= 'z' {\n \
    \          ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpfrhrzooc.swift:18:29: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[pos] >= 'a' && s[pos] <= 'z' {\n                            ^~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfrhrzooc.swift:24:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    } while pos < s.count && s[pos] >= 'a' && s[pos]\
    \ <= 'z'\n                             ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfrhrzooc.swift:24:47: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String "
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    chars := s.characters\n\n    var n = 0\n    var inVowel\
    \ = false\n    for i in 0 ..< s.characters.count {\n        if chars[i] == 'A'\
    \ || chars[i] == 'a' {\n            if !inVowel {\n                inVowel = true\n\
    \                n += 1\n            }\n        } else {\n            if inVowel\
    \ {\n                inVowel = false\n            }\n        }\n    }\n    return\
    \ n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") ==\
    \ 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdpx7q3ab.swift:11:10: error: consecutive statements on a line must\
    \ be separated by ';'\n    chars := s.characters\n         ^\n         ;\n/tmp/tmpdpx7q3ab.swift:11:11:\
    \ error: expected expression\n    chars := s.characters\n          ^\n/tmp/tmpdpx7q3ab.swift:16:24:\
    \ error: single-quoted string literal found, use '\"'\n        if chars[i] ==\
    \ 'A' || chars[i] == 'a' {\n                       ^~~\n                     \
    \  \"A\"\n/tmp/tmpdpx7q3ab.swift:16:43: error: single-quoted string literal found,\
    \ use '\"'\n        if chars[i] == 'A' || chars[i] == 'a' {\n                \
    \                          ^~~\n                                          \"a\"\
    \n/tmp/tmpdpx7q3ab.swift:11:5: error: cannot find 'chars' in scope\n    chars\
    \ := s.characters\n    ^~~~~\n/tmp/tmpdpx7q3ab.swift:15:22: error: 'characters'\
    \ is unavailable: Please use String directly\n    for i in 0 ..< s.characters.count\
    \ {\n                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpdpx7q3ab.swift:16:12: error: cannot find 'chars' in scope\n\
    \        if chars[i] == 'A' || chars[i] == 'a' {\n           ^~~~~\n/tmp/tmpdpx7q3ab.swift:16:31:\
    \ error: cannot find 'chars' in scope\n        if chars[i] == 'A' || chars[i]\
    \ == 'a' {\n                              ^~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.isUpper(s.startIndex) ? s.count() : 0;\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgzhokqmu.swift:11:14: error: value of type 'String' has no member\
    \ 'isUpper'\n    return s.isUpper(s.startIndex) ? s.count() : 0;\n           ~\
    \ ^~~~~~~\n/tmp/tmpgzhokqmu.swift:11:40: error: cannot call value of non-function\
    \ type 'Int'\n    return s.isUpper(s.startIndex) ? s.count() : 0;\n          \
    \                             ^    ~~\n                                      \
    \      \n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    // Only use a single for loop.\n    var count = 0\n  \
    \  var isUpper = true\n    for x in s.characters {\n        if x == x.uppercaseValue\
    \ {\n            count += 1\n        } else if isUpper {\n            count =\
    \ 0\n            isUpper = false\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpk4ha22w6.swift:14:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for x in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpk4ha22w6.swift:15:19:\
    \ error: value of type 'Character' has no member 'uppercaseValue'\n        if\
    \ x == x.uppercaseValue {\n                ~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    var prev: Character?\n    for x in\
    \ s.characters {\n        if Character.isUpper(x) && (!prev || CharacterInfo.isVowel(x,\
    \ prev!)) {\n            count += 1\n        }\n        prev = &x\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpu98sxk_b.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for x in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpu98sxk_b.swift:14:46:\
    \ error: cannot find 'CharacterInfo' in scope\n        if Character.isUpper(x)\
    \ && (!prev || CharacterInfo.isVowel(x, prev!)) {\n                          \
    \                   ^~~~~~~~~~~~~\n/tmp/tmpu98sxk_b.swift:14:22: error: type 'Character'\
    \ has no member 'isUpper'\n        if Character.isUpper(x) && (!prev || CharacterInfo.isVowel(x,\
    \ prev!)) {\n           ~~~~~~~~~ ^~~~~~~\n/tmp/tmpu98sxk_b.swift:14:38: error:\
    \ optional type 'Character?' cannot be used as a boolean; test for '== nil' instead\n\
    \        if Character.isUpper(x) && (!prev || CharacterInfo.isVowel(x, prev!))\
    \ {\n                                    ~^\n                                \
    \     (    == nil)\n/tmp/tmpu98sxk_b.swift:17:14: error: cannot assign value of\
    \ type 'Character' to type 'Character?'\n        prev = &x\n             ^\n/tmp/tmpu98sxk_b.swift:17:16:\
    \ error: '&' may only be used to pass an argument to inout parameter\n       \
    \ prev = &x\n               ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let sLower = String(cString: s).lowercased()\n    var\
    \ count = 0\n    for i in 0..<sLower.characters.count {\n        if sLower[i]\
    \ == sLower[i].toUpper() {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\"\
    ) == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpa9h4ladl.swift:11:18: warning: 'init(cString:)' is deprecated:\
    \ Use a copy of the String argument\n    let sLower = String(cString: s).lowercased()\n\
    \                 ^\n/tmp/tmpa9h4ladl.swift:13:25: error: 'characters' is unavailable:\
    \ Please use String directly\n    for i in 0..<sLower.characters.count {\n   \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpa9h4ladl.swift:14:35: error: value of type 'Character' has no member\
    \ 'toUpper'\n        if sLower[i] == sLower[i].toUpper() {\n                 \
    \       ~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.countUp(s.startIndex, s.endIndex, true)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3f_gr0ta.swift:11:14: error: value of type 'String' has no member\
    \ 'countUp'\n    return s.countUp(s.startIndex, s.endIndex, true)\n          \
    \ ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let sArr = s.characters\n    var evenIndex = 0\n    let\
    \ upperVowelCount = 0\n    var char: unichar\n\n    for char in sArr {\n     \
    \   if char == unichar(uppercase + 1) {\n            evenIndex++\n        } else\
    \ {\n            if evenIndex % 2 == 0 {\n                upperVowelCount++\n\
    \            }\n            evenIndex = 0\n        }\n    }\n    return upperVowelCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8inf27md.swift:11:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    let sArr = s.characters\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8inf27md.swift:14:15:\
    \ error: cannot find type 'unichar' in scope\n    var char: unichar\n        \
    \      ^~~~~~~\n/tmp/tmp8inf27md.swift:17:20: error: cannot find 'unichar' in\
    \ scope\n        if char == unichar(uppercase + 1) {\n                   ^~~~~~~\n\
    /tmp/tmp8inf27md.swift:17:28: error: cannot find 'uppercase' in scope\n      \
    \  if char == unichar(uppercase + 1) {\n                           ^~~~~~~~~\n\
    /tmp/tmp8inf27md.swift:18:22: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            evenIndex++\n                     ^~\n/tmp/tmp8inf27md.swift:21:32:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      upperVowelCount++\n                               ^~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\treturn count_upto_indexed(s.lowercased(), \"aeiou\", 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp73mzlnzr.swift:11:9: error: cannot find 'count_upto_indexed' in\
    \ scope\n        return count_upto_indexed(s.lowercased(), \"aeiou\", 0)\n   \
    \            ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.countUpTo(s.endIndex, options: .anchored)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpz1pa1oj7.swift:11:14: error: value of type 'String' has no member\
    \ 'countUpTo'\n    return s.countUpTo(s.endIndex, options: .anchored)\n      \
    \     ~ ^~~~~~~~~\n/tmp/tmpz1pa1oj7.swift:11:46: error: cannot infer contextual\
    \ base in reference to member 'anchored'\n    return s.countUpTo(s.endIndex, options:\
    \ .anchored)\n                                            ~^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    // TODO: Optimize using SIMD if supported.\n    if s.isEmpty\
    \ {\n        return 0\n    }\n    let mut vowels = 0\n    let len = s.count\n\
    \    for i in 0..len-1 {\n        if s[i] == 'A' || s[i] == 'E' || s[i] == 'I'\
    \ || s[i] == 'O' || s[i] == 'U' {\n            vowels += 1\n        }\n    }\n\
    \    return vowels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpw0gdv_wl.swift:15:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut vowels =\
    \ 0\n            ^\n/tmp/tmpw0gdv_wl.swift:15:13: note: join the identifiers together\n\
    \    let mut vowels = 0\n        ~~~~^~~~~~\n        mutvowels\n/tmp/tmpw0gdv_wl.swift:15:13:\
    \ note: join the identifiers together with camel-case\n    let mut vowels = 0\n\
    \        ~~~~^~~~~~\n        mutVowels\n/tmp/tmpw0gdv_wl.swift:18:20: error: single-quoted\
    \ string literal found, use '\"'\n        if s[i] == 'A' || s[i] == 'E' || s[i]\
    \ == 'I' || s[i] == 'O' || s[i] == 'U' {\n                   ^~~\n           \
    \        \"A\"\n/tmp/tmpw0gdv_wl.swift:18:35: error: single-quoted string literal\
    \ found, use '\"'\n        if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i]\
    \ == 'O' || s[i] == 'U' {\n                                  ^~~\n           \
    \                       \"E\"\n/tmp/tmpw0gdv_wl.swift:18:50: error: single-quoted\
    \ string literal found, use '\"'\n        if s[i] == 'A' || s[i] == 'E' || s[i]\
    \ == 'I' || s[i] == 'O' || s[i] == 'U' {\n                                   \
    \              ^~~\n                                                 \"I\"\n/tmp/tmpw0gdv_wl.swift:18:65:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n            \
    \                                                    ^~~\n                   \
    \                                             \"O\"\n/tmp/tmpw0gdv_wl.swift:18:80:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n            \
    \                                                                   ^~~\n    \
    \                                                                           \"\
    U\"\n/tmp/tmpw0gdv_wl.swift:17:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 0..len-1 {\n              ^~\n           \
    \   ...\n/tmp/tmpw0gdv_wl.swift:22:12: error: cannot find 'vowels' in scope\n\
    \    return vowels\n           ^~~~~"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let vowels = \"aeiouAEIOU\"\n    return s.unicodeScalars.filter({\
    \ $0.value > 64 && vowels.contains(String($0.value)) }).count { $0.value % 2 ==\
    \ 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\"\
    ) == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpe1qal9td.swift:12:92: error: cannot call value of non-function\
    \ type 'Int'\n    return s.unicodeScalars.filter({ $0.value > 64 && vowels.contains(String($0.value))\
    \ }).count { $0.value % 2 == 1 }\n                                           \
    \                                                ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let vowels = \"aeiou\"\n    let chars = s.characters\n\
    \    var i = 0\n    while i < s.count {\n        if chars[i] == vowels.first {\n\
    \            i += 2\n            continue\n        }\n        return chars[i]\
    \ == vowels.last\n    }\n    return s.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpep87znys.swift:12:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpep87znys.swift:15:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if chars[i] == vowels.first {\n       \
    \    ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpep87znys.swift:19:25: error: cannot convert return expression\
    \ of type 'Bool' to return type 'Int'\n        return chars[i] == vowels.last\n\
    \               ~~~~~~~~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    scanUpper { _ in\n        guard let i = Int($0.index),\
    \ s.utf16.count > i else { return 0 }\n        let upper = s.utf16[i] >= 0x41\
    \ && s.utf16[i] <= 0x5A\n        guard upper else { return 0 }\n        guard\
    \ s.utf16[(i + 1) % s.utf16.count] == 0x5A else { return 0 }\n        return 1\
    \ + count_upper(s.substringWithRange(i..<(i + 2)))\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpii69382u.swift:12:27: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments\n        guard let i =\
    \ Int($0.index), s.utf16.count > i else { return 0 }\n                       \
    \   ^\n/tmp/tmpii69382u.swift:11:5: error: cannot find 'scanUpper' in scope\n\
    \    scanUpper { _ in\n    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s == \"\" {\n        return 0\n    }\n    let (count,\
    \ _) = s.characters.enumerate()\n                .map { UnicodeScalar($0).isUppercase()\
    \ }\n                .partition(true)\n                .map { $0 == true }\n \
    \               .map { $0.count }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsve4o27t.swift:18:18: error: type of expression is ambiguous without\
    \ more context\n                .map { $0.count }\n~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for i := 0; i < len(s); i++ {\n   \
    \     switch s[i] {\n        case 'A':\n        case 'E':\n        case 'I':\n\
    \        case 'O':\n        case 'U':\n            count += 1\n        default:\n\
    \            break\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpcu1xz6bp.swift:12:12: error: expected type\n    for i := 0; i <\
    \ len(s); i++ {\n           ^\n            <#type#>\n/tmp/tmpcu1xz6bp.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(s); i++\
    \ {\n           ^\n/tmp/tmpcu1xz6bp.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(s); i++ {\n           ^\n/tmp/tmpcu1xz6bp.swift:14:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'A':\n   \
    \          ^~~\n             \"A\"\n/tmp/tmpcu1xz6bp.swift:14:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'A':\n        ^~~~~~~~~\n                  break\n/tmp/tmpcu1xz6bp.swift:15:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'E':\n   \
    \          ^~~\n             \"E\"\n/tmp/tmpcu1xz6bp.swift:15:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'E':\n        ^~~~~~~~~\n                  break\n/tmp/tmpcu1xz6bp.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'I':\n   \
    \          ^~~\n             \"I\"\n/tmp/tmpcu1xz6bp.swift:16:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'I':\n        ^~~~~~~~~\n                  break\n/tmp/tmpcu1xz6bp.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'O':\n   \
    \          ^~~\n             \"O\"\n/tmp/tmpcu1xz6bp.swift:17:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'O':\n        ^~~~~~~~~\n                  break\n/tmp/tmpcu1xz6bp.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'U':\n   \
    \          ^~~\n             \"U\"\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 1\n    for index1 in indices(s) {\n      \
    \  if s[index1] == 'A' || s[index1] == 'E' || s[index1] == 'I' || s[index1] ==\
    \ 'O' ||\n            s[index1] == 'U' || s[index1] == 'a' || s[index1] == 'e'\
    \ || s[index1] == 'i' ||\n            s[index1] == 'o' || s[index1] == 'u' {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplxnk3fy8.swift:13:25: error: single-quoted string literal found,\
    \ use '\"'\n        if s[index1] == 'A' || s[index1] == 'E' || s[index1] == 'I'\
    \ || s[index1] == 'O' ||\n                        ^~~\n                      \
    \  \"A\"\n/tmp/tmplxnk3fy8.swift:13:45: error: single-quoted string literal found,\
    \ use '\"'\n        if s[index1] == 'A' || s[index1] == 'E' || s[index1] == 'I'\
    \ || s[index1] == 'O' ||\n                                            ^~~\n  \
    \                                          \"E\"\n/tmp/tmplxnk3fy8.swift:13:65:\
    \ error: single-quoted string literal found, use '\"'\n        if s[index1] ==\
    \ 'A' || s[index1] == 'E' || s[index1] == 'I' || s[index1] == 'O' ||\n       \
    \                                                         ^~~\n              \
    \                                                  \"I\"\n/tmp/tmplxnk3fy8.swift:13:85:\
    \ error: single-quoted string literal found, use '\"'\n        if s[index1] ==\
    \ 'A' || s[index1] == 'E' || s[index1] == 'I' || s[index1] == 'O' ||\n       \
    \                                                                            \
    \ ^~~\n                                                                      \
    \              \"O\"\n/tmp/tmplxnk3fy8.swift:14:26: error: single-quoted string\
    \ literal found, use '\"'\n            s[index1] == 'U' || s[index1] == 'a' ||\
    \ s[index1] == 'e' || s[index1] == 'i' ||\n                         ^~~\n    \
    \                     \"U\"\n/tmp/tmplxnk3fy8.swift:14:46: error: single-quoted\
    \ string literal found, use '\"'\n            s[index1] == 'U' || s[index1] ==\
    \ 'a' || s[index1] == 'e' || s[index1] == 'i' ||\n                           \
    \                  ^~~\n                                             \"a\"\n/tmp/tmplxnk3fy8.swift:14:66:\
    \ error: single-quoted string literal found, use '\"'\n            s[index1] ==\
    \ 'U' || s[index1] == 'a' || s[index1] == 'e' || s[index1] == 'i' ||\n       \
    \                                                          ^~~\n             \
    \                                                    \"e\"\n/tmp/tmplxnk3fy8.swift:14:86:\
    \ error: single-quoted string literal found, use '\"'\n  "
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var i = 0\n    for c in s.unicodeScalars {\n        if\
    \ c == 0x4E { i += 1 }\n    }\n    return i\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjsf38heq.swift:13:14: error: referencing operator function '=='\
    \ on 'BinaryInteger' requires that 'Unicode.Scalar' conform to 'BinaryInteger'\n\
    \        if c == 0x4E { i += 1 }\n             ^\nSwift.BinaryInteger:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension BinaryInteger {\n          ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.isEmpty ? 0 : 1\n        + s.filter { $0.isUppercase\
    \ }.count { $0 % 2 == 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpky9q137r.swift:12:39: error: cannot call value of non-function\
    \ type 'Int'\n        + s.filter { $0.isUppercase }.count { $0 % 2 == 1 }\n  \
    \                                    ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count_up(s.chars().filter({ $0 >= 'a' && $0 <=\
    \ 'z' })).map { $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpj3pkg433.swift:11:46: error: single-quoted string literal found,\
    \ use '\"'\n    return count_up(s.chars().filter({ $0 >= 'a' && $0 <= 'z' })).map\
    \ { $0 }\n                                             ^~~\n                 \
    \                            \"a\"\n/tmp/tmpj3pkg433.swift:11:59: error: single-quoted\
    \ string literal found, use '\"'\n    return count_up(s.chars().filter({ $0 >=\
    \ 'a' && $0 <= 'z' })).map { $0 }\n                                          \
    \                ^~~\n                                                       \
    \   \"z\"\n/tmp/tmpj3pkg433.swift:11:12: error: cannot find 'count_up' in scope\n\
    \    return count_up(s.chars().filter({ $0 >= 'a' && $0 <= 'z' })).map { $0 }\n\
    \           ^~~~~~~~\n/tmp/tmpj3pkg433.swift:11:23: error: value of type 'String'\
    \ has no member 'chars'\n    return count_up(s.chars().filter({ $0 >= 'a' && $0\
    \ <= 'z' })).map { $0 }\n                    ~ ^~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s.isEmpty { return 0 }\n    var uppers = 0\n    var\
    \ i = 0\n    while i < s.count {\n        guard s[i] == 'A' || s[i] == 'a' ||\
    \ s[i] == 'E' || s[i] == 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i]\
    \ == 'o' || s[i] == 'U' || s[i] == 'u' else {\n            i += 1 // Not an uppercase\
    \ vowel\n            continue\n        }\n        uppers += 1\n        i += 1\
    \ // Increment index to next uppercase vowel\n    }\n    return uppers\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpat76bs7n.swift:15:23: error: single-quoted string literal found,\
    \ use '\"'\n        guard s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] ==\
    \ 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] == 'U'\
    \ || s[i] == 'u' else {\n                      ^~~\n                      \"A\"\
    \n/tmp/tmpat76bs7n.swift:15:38: error: single-quoted string literal found, use\
    \ '\"'\n        guard s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] == 'e'\
    \ || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] == 'U' ||\
    \ s[i] == 'u' else {\n                                     ^~~\n             \
    \                        \"a\"\n/tmp/tmpat76bs7n.swift:15:53: error: single-quoted\
    \ string literal found, use '\"'\n        guard s[i] == 'A' || s[i] == 'a' ||\
    \ s[i] == 'E' || s[i] == 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i]\
    \ == 'o' || s[i] == 'U' || s[i] == 'u' else {\n                              \
    \                      ^~~\n                                                 \
    \   \"E\"\n/tmp/tmpat76bs7n.swift:15:68: error: single-quoted string literal found,\
    \ use '\"'\n        guard s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] ==\
    \ 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] == 'U'\
    \ || s[i] == 'u' else {\n                                                    \
    \               ^~~\n                                                        \
    \           \"e\"\n/tmp/tmpat76bs7n.swift:15:83: error: single-quoted string literal\
    \ found, use '\"'\n        guard s[i] == 'A' || s[i] == 'a' || s[i] == 'E' ||\
    \ s[i] == 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i]\
    \ == 'U' || s[i] == 'u' else {\n                                             \
    \                                     ^~~\n                                  \
    \                                                \"I\"\n/tmp/tmpat76bs7n.swift:15:98:\
    \ error: single-quoted string literal found, use '\"'\n        guard s[i] == 'A'\
    \ || s[i] == 'a' || s[i] == 'E' || s[i] == 'e' || s[i] == 'I' || s[i] == 'i' ||\
    \ s[i] == 'O' || s[i] == 'o' || s[i] == 'U' || s[i] == 'u' e"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var n = 0\n    if s == \"\" {\n        return 0\n    }\n\
    \    for c in s.characters {\n        if isUppercase(c) {\n            if isEvenIndex(c)\
    \ {\n                n += 1\n            }\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpbo9slqpb.swift:15:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbo9slqpb.swift:16:12:\
    \ error: cannot find 'isUppercase' in scope\n        if isUppercase(c) {\n   \
    \        ^~~~~~~~~~~\n/tmp/tmpbo9slqpb.swift:17:16: error: cannot find 'isEvenIndex'\
    \ in scope\n            if isEvenIndex(c) {\n               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for c in s {\n        guard case let\
    \ .UpperLetter(c, index) = c else {\n            preconditionFailure()\n     \
    \   }\n        if index % 2 == 0 {\n            count = count + 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp38vrribp.swift:13:25: error: type 'Character' has no member 'UpperLetter'\n\
    \        guard case let .UpperLetter(c, index) = c else {\n                  \
    \     ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n\n    for idx in indices(s) {\n       \
    \ guard s[idx].isUppercase() else { continue }\n        count += Int(idx) % 2\
    \ == 0\n    }\n\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4w8ztoz3.swift:13:16: error: cannot find 'indices' in scope\n \
    \   for idx in indices(s) {\n               ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    \n    if let s = s {\n        var counter = 1\n      \
    \  for c in s.characters {\n            if isUppercase(Int(c)) {\n           \
    \     counter += 1\n            }\n        }\n        return counter\n    }\n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp39ynudcm.swift:14:20: error: 'characters' is unavailable: Please\
    \ use String directly\n        for c in s.characters {\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp39ynudcm.swift:15:16:\
    \ error: cannot find 'isUppercase' in scope\n            if isUppercase(Int(c))\
    \ {\n               ^~~~~~~~~~~\n/tmp/tmp39ynudcm.swift:15:28: error: no exact\
    \ matches in call to initializer \n            if isUppercase(Int(c)) {\n    \
    \                       ^\n/tmp/tmp39ynudcm.swift:15:28: note: found candidate\
    \ with type '(Float16) -> Int'\n            if isUppercase(Int(c)) {\n       \
    \                    ^\n/tmp/tmp39ynudcm.swift:15:28: note: found candidate with\
    \ type '(Float) -> Int'\n            if isUppercase(Int(c)) {\n              \
    \             ^\n/tmp/tmp39ynudcm.swift:15:28: note: found candidate with type\
    \ '(Double) -> Int'\n            if isUppercase(Int(c)) {\n                  \
    \         ^\n/tmp/tmp39ynudcm.swift:15:28: note: found candidate with type '(Float80)\
    \ -> Int'\n            if isUppercase(Int(c)) {\n                           ^\n\
    /tmp/tmp39ynudcm.swift:15:28: note: found candidate with type '(Builtin.Int64)\
    \ -> Int'\n            if isUppercase(Int(c)) {\n                           ^\n\
    /tmp/tmp39ynudcm.swift:15:28: note: found candidate with type '(Builtin.Word)\
    \ -> Int'\n            if isUppercase(Int(c)) {\n                           ^\n\
    /tmp/tmp39ynudcm.swift:15:28: note: found candidate with type '(String) -> Int?'\n\
    \            if isUppercase(Int(c)) {\n                           ^\n/tmp/tmp39ynudcm.swift:12:8:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \    if let s = s {\n       ^       ~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard s.isEmpty == false else { return 0 }\n    guard\
    \ s.count > 0 else { return 0 }\n    var n = 0\n    var prev = 0\n    for _, b\
    \ in s.enumerated() {\n        if b == 'a' {\n            if prev % 2 != 0 {\n\
    \                n += 1\n            }\n        } else if b == 'e' {\n       \
    \     if prev % 2 == 0 {\n                n += 1\n            }\n        } else\
    \ if b == 'i' {\n            if prev % 2 == 0 {\n                n += 1\n    \
    \        }\n        } else if b == 'o' {\n            if prev % 2 != 0 {\n   \
    \             n += 1\n            }\n        } else if b == 'u' {\n          \
    \  if prev % 2 == 0 {\n                n += 1\n            }\n        } else if\
    \ b == 'A' {\n            if prev % 2 != 0 {\n                n += 1\n       \
    \     }\n        } else if b == 'E' {\n            if prev % 2 == 0 {\n      \
    \          n += 1\n            }\n        } else if b == 'I' {\n            if\
    \ prev % 2 == 0 {\n                n += 1\n            }\n        } else if b\
    \ == 'O' {\n            if prev % 2 != 0 {\n                n += 1\n         \
    \   }\n        } else if b == 'U' {\n            if prev % 2 == 0 {\n        \
    \        n += 1\n            }\n        }\n        prev = b\n    }\n    return\
    \ n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") ==\
    \ 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmptxexborw.swift:15:10: error: expected 'in' after for-each pattern\n\
    \    for _, b in s.enumerated() {\n         ^\n/tmp/tmptxexborw.swift:15:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, b in s.enumerated()\
    \ {\n         ^\n/tmp/tmptxexborw.swift:16:17: error: single-quoted string literal\
    \ found, use '\"'\n        if b == 'a' {\n                ^~~\n              \
    \  \"a\"\n/tmp/tmptxexborw.swift:20:24: error: single-quoted string literal found,\
    \ use '\"'\n        } else if b == 'e' {\n                       ^~~\n       \
    \                \"e\"\n/tmp/tmptxexborw.swift:24:24: error: single-quoted string\
    \ literal found, use '\"'\n        } else if b == 'i' {\n                    \
    \   ^~~\n                       \"i\"\n/tmp/tmptxexborw.swift:28:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if b == 'o' {\n             \
    \          ^~~\n                       \"o\"\n/tmp/tmptxexborw.swift:32:24: error:\
    \ single-quoted string literal found, use '\"'\n        } else if b == 'u' {\n\
    \                       ^~~\n                       \"u\"\n/tmp/tmptxexborw.swift:36:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if b ==\
    \ 'A' {\n                       ^~~\n                       \"A\"\n/tmp/tmptxexborw.swift:40:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if b ==\
    \ 'E' {\n                       ^~~\n                       \"E\"\n/tmp/tmptxexborw.swift:44:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if b ==\
    \ 'I' {\n                       ^~~\n                       \"I\"\n/tmp/tmptxexborw.swift:48:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if b ==\
    \ 'O' {\n                       ^~~\n                       \"O\"\n/tmp/tmptxexborw.swift:52:24:\
    \ error: single-quoted string literal found, use '\"'\n        } else if b ==\
    \ 'U' {\n                       ^~~\n                       \"U\"\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for c in s {\n        if c.isUpper()\
    \ {\n            count += 1\n        }\n        if c.isUpper() && c != s.firstUpper()\
    \ {\n            count -= 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppm1fytd9.swift:13:14: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if c.isUpper() {\n           ~ ^~~~~~~\n/tmp/tmppm1fytd9.swift:16:14:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if c.isUpper()\
    \ && c != s.firstUpper() {\n           ~ ^~~~~~~\n/tmp/tmppm1fytd9.swift:16:34:\
    \ error: value of type 'String' has no member 'firstUpper'\n        if c.isUpper()\
    \ && c != s.firstUpper() {\n                               ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    \n    let count = s.characters.reduce(0) { accumulator,\
    \ character in\n        accumulator + (character >= 'A' && character <= 'Z' ?\
    \ 0 : 1)\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4bro1wmn.swift:13:37: error: single-quoted string literal found,\
    \ use '\"'\n        accumulator + (character >= 'A' && character <= 'Z' ? 0 :\
    \ 1)\n                                    ^~~\n                              \
    \      \"A\"\n/tmp/tmp4bro1wmn.swift:13:57: error: single-quoted string literal\
    \ found, use '\"'\n        accumulator + (character >= 'A' && character <= 'Z'\
    \ ? 0 : 1)\n                                                        ^~~\n    \
    \                                                    \"Z\"\n/tmp/tmp4bro1wmn.swift:12:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    let count\
    \ = s.characters.reduce(0) { accumulator, character in\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tlet a = s.characters\n\tlet l = a.count\n\tvar vowels =\
    \ 0\n\tvar even = false\n\tfor n in 0 ..< l {\n\t\tlet c = a[n]\n\t\tswitch c\
    \ {\n\t\tcase \"A\":\n\t\t\tif even {\n\t\t\t\tvowels += 1\n\t\t\t}\n\t\tcase\
    \ \"E\":\n\t\t\tif even {\n\t\t\t\tvowels += 1\n\t\t\t}\n\t\tcase \"I\":\n\t\t\
    \tif even {\n\t\t\t\tvowels += 1\n\t\t\t}\n\t\tcase \"O\":\n\t\t\tif even {\n\t\
    \t\t\tvowels += 1\n\t\t\t}\n\t\tcase \"U\":\n\t\t\tif even {\n\t\t\t\tvowels +=\
    \ 1\n\t\t\t}\n\t\tdefault:\n\t\t\teven = !even\n\t\t}\n\t}\n\treturn vowels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpr833l9dp.swift:11:12: error: 'characters' is unavailable: Please\
    \ use String directly\n        let a = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpr833l9dp.swift:16:11:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let c = a[n]\n                \
    \        ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.characters.reduce(0, combine: {$0 + $1.unicodeScalars.filter({\
    \ $0.isUppercase }).count })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6_nuudq0.swift:11:31: error: extraneous argument label 'combine:'\
    \ in call\n    return s.characters.reduce(0, combine: {$0 + $1.unicodeScalars.filter({\
    \ $0.isUppercase }).count })\n                              ^   ~~~~~~~~~\n  \
    \                                \n/tmp/tmp6_nuudq0.swift:11:80: error: value\
    \ of type 'Unicode.Scalar' has no member 'isUppercase'\n    return s.characters.reduce(0,\
    \ combine: {$0 + $1.unicodeScalars.filter({ $0.isUppercase }).count })\n     \
    \                                                                       ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let vowels = \"AEIOUaeiou\"\n    var count = 0\n    for\
    \ c in s {\n        if vowels.contains(String.fromCString(c)) {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpnjit56cc.swift:14:35: error: type 'String' has no member 'fromCString'\n\
    \        if vowels.contains(String.fromCString(c)) {\n                       \
    \    ~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let len = s.count\n    if len <= 0 {\n        return 0\n\
    \    }\n    var i = 0\n    var evens = len / 2\n    var even = 0\n    for _ in\
    \ 0..<evens {\n        if s[i] >= 'A' && s[i] <= 'Z' {\n            even += 1\n\
    \        }\n        i += 2\n    }\n    return even\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsj4_0rfw.swift:19:20: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i] >= 'A' && s[i] <= 'Z' {\n                   ^~~\n\
    \                   \"A\"\n/tmp/tmpsj4_0rfw.swift:19:35: error: single-quoted\
    \ string literal found, use '\"'\n        if s[i] >= 'A' && s[i] <= 'Z' {\n  \
    \                                ^~~\n                                  \"Z\"\n\
    /tmp/tmpsj4_0rfw.swift:19:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if s[i] >= 'A' && s[i]\
    \ <= 'Z' {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpsj4_0rfw.swift:19:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] >= 'A' && s[i] <= 'Z' {\n                          ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpsj4_0rfw.swift:16:9:\
    \ warning: variable 'evens' was never mutated; consider changing to 'let' constant\n\
    \    var evens = len / 2\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s.isEmpty {\n        return 0\n    }\n    var result\
    \ = 1\n    for c in s.characters.dropFirst() {\n        if c == c.uppercased()\
    \ {\n            result += 1\n        } else if c.isUpper() {\n            break\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp81g6x9sl.swift:15:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters.dropFirst() {\n             \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp81g6x9sl.swift:16:14:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if c == c.uppercased() {\n           ~ ^  ~~~~~~~~~~~~~~\n\
    /tmp/tmp81g6x9sl.swift:16:14: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ if c == c.uppercased() {\n             ^\n/tmp/tmp81g6x9sl.swift:18:21: error:\
    \ value of type 'Character' has no member 'isUpper'\n        } else if c.isUpper()\
    \ {\n                  ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    \n    let vowels = \"AEIOUaeiou\"\n    \n    let letters\
    \ = map(s) { Character($0) }\n    \n    var count = 0\n    \n    letters.forEach\
    \ { letter in\n        if vowels.contains(letter) {\n            count += 1\n\
    \        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpp37vsp7z.swift:14:19: error: cannot find 'map' in scope\n    let\
    \ letters = map(s) { Character($0) }\n                  ^~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = 0\n    for idx in range(len(s) - 1, -1, -1)\
    \ {\n        if s[idx].isUpper() {\n            result += 1\n            if idx\
    \ % 2 == 0 {\n                result += count_upper(s[idx+1:])\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpazmjm90x.swift:16:46: error: expected ',' separator\n         \
    \       result += count_upper(s[idx+1:])\n                                   \
    \          ^\n                                             ,\n/tmp/tmpazmjm90x.swift:16:46:\
    \ error: expected expression in list of expressions\n                result +=\
    \ count_upper(s[idx+1:])\n                                             ^\n/tmp/tmpazmjm90x.swift:12:16:\
    \ error: cannot find 'range' in scope\n    for idx in range(len(s) - 1, -1, -1)\
    \ {\n               ^~~~~\n/tmp/tmpazmjm90x.swift:12:22: error: cannot find 'len'\
    \ in scope\n    for idx in range(len(s) - 1, -1, -1) {\n                     ^~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for c in s {\n        if isUpper(c)\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpbgfkpel1.swift:13:12: error: cannot find 'isUpper' in scope\n \
    \       if isUpper(c) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824549
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count_letters(s, is_vowel)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzt14to1m.swift:11:12: error: cannot find 'count_letters' in scope\n\
    \    return count_letters(s, is_vowel)\n           ^~~~~~~~~~~~~\n/tmp/tmpzt14to1m.swift:11:29:\
    \ error: cannot find 'is_vowel' in scope\n    return count_letters(s, is_vowel)\n\
    \                            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count(s, upperCaseLetter)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpig26zqtf.swift:11:12: error: cannot find 'count' in scope\n   \
    \ return count(s, upperCaseLetter)\n           ^~~~~\n/tmp/tmpig26zqtf.swift:11:21:\
    \ error: cannot find 'upperCaseLetter' in scope\n    return count(s, upperCaseLetter)\n\
    \                    ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s.isEmpty {\n        return 0\n    }\n    var count\
    \ = 0\n    for idx in 0..<s.count {\n        guard s.startIndex.successor().advancedBy(idx).uppercased()\
    \ else {\n            continue // not an uppercase character\n        }\n    \
    \    count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_vv4ef8t.swift:16:28: error: value of type 'String.Index' has no\
    \ member 'successor'\n        guard s.startIndex.successor().advancedBy(idx).uppercased()\
    \ else {\n              ~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for c in s.characters {\n        if\
    \ c.isUpper() {\n            if isEven(c.index) {\n                count += 1\n\
    \            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpumoj1fi8.swift:12:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpumoj1fi8.swift:13:14:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if c.isUpper()\
    \ {\n           ~ ^~~~~~~\n/tmp/tmpumoj1fi8.swift:14:16: error: cannot find 'isEven'\
    \ in scope\n            if isEven(c.index) {\n               ^~~~~~\n/tmp/tmpumoj1fi8.swift:14:25:\
    \ error: value of type 'Character' has no member 'index'\n            if isEven(c.index)\
    \ {\n                      ~ ^~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard s.starts(with: \"aBCdEf\") else { return 0 }\n \
    \   var cnt = 0\n    for index in stride(from: 0, to: s.characters.count, by:\
    \ 2) {\n        guard s.characters.element(at: index).isUppercase,\n         \
    \     s.characters.element(at: index).isLowercase else {\n            return cnt\n\
    \        }\n        cnt += 1\n    }\n    return cnt\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyojehaih.swift:13:40: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in stride(from: 0, to: s.characters.count,\
    \ by: 2) {\n                                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpyojehaih.swift:14:28: error: value of\
    \ type 'String' has no member 'element'\n        guard s.characters.element(at:\
    \ index).isUppercase,\n              ~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpyojehaih.swift:15:28:\
    \ error: value of type 'String' has no member 'element'\n              s.characters.element(at:\
    \ index).isLowercase else {\n              ~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    // https://swift.org/blog/swift-evolution-part-3-tuples/\n\
    \    return (s.characters\n        .enumerate()\n        .map { i, char in\n \
    \           if i % 2 == 0 {\n                let index = upperIndex(of: char)\n\
    \                if index > -1 {\n                    return index\n         \
    \       }\n            }\n            return nil\n        }\n        .compactMap\
    \ { $0 }\n        .count())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp13kz1uc6.swift:16:29: error: cannot find 'upperIndex' in scope\n\
    \                let index = upperIndex(of: char)\n                          \
    \  ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let mut n = 0\n    for i in s.indices(s.startIndex..<s.endIndex)\
    \ {\n        if s[i..<i+1].isUpper() {\n            n += 1\n        }\n    }\n\
    \    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4avfybt7.swift:11:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut n = 0\n\
    \            ^\n/tmp/tmp4avfybt7.swift:11:13: note: join the identifiers together\n\
    \    let mut n = 0\n        ~~~~^\n        mutn\n/tmp/tmp4avfybt7.swift:11:13:\
    \ note: join the identifiers together with camel-case\n    let mut n = 0\n   \
    \     ~~~~^\n        mutN\n/tmp/tmp4avfybt7.swift:12:16: error: cannot call value\
    \ of non-function type 'DefaultIndices<String>'\n    for i in s.indices(s.startIndex..<s.endIndex)\
    \ {\n               ^\n/tmp/tmp4avfybt7.swift:17:12: error: cannot find 'n' in\
    \ scope\n    return n\n           ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    \n    var countUpper = 0\n    \n    for i in 0 ..< s.count\
    \ {\n        \n        let chart = s[i]\n        \n        if !chart.isUppercase\
    \ {\n            countUpper += 1\n        }\n    }\n    \n    return countUpper\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpm2t3invw.swift:16:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let chart\
    \ = s[i]\n                    ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tlet len = s.count\n\tlet cap = s.unicodeScalars.filter {\n\
    \t\t$0.value > UnicodeScalar(\"A\") && ($0.value < UnicodeScalar(\"Z\"))\n\t}.count\n\
    \treturn len - cap\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpeigmdg16.swift:13:12: error: operator function '>' requires that\
    \ 'UnicodeScalar' (aka 'Unicode.Scalar') conform to 'BinaryInteger'\n        \
    \        $0.value > UnicodeScalar(\"A\") && ($0.value < UnicodeScalar(\"Z\"))\n\
    \                         ^\nSwift.BinaryInteger:7:24: note: where 'Other' = 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    public static func > <Other>(lhs: Self, rhs: Other)\
    \ -> Bool where Other : BinaryInteger\n                       ^\n/tmp/tmpeigmdg16.swift:13:46:\
    \ error: operator function '<' requires that 'UnicodeScalar' (aka 'Unicode.Scalar')\
    \ conform to 'BinaryInteger'\n                $0.value > UnicodeScalar(\"A\")\
    \ && ($0.value < UnicodeScalar(\"Z\"))\n                                     \
    \                      ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    public static func < <Other>(lhs: Self, rhs: Other)\
    \ -> Bool where Other : BinaryInteger\n                       ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count_chars(s, isUpper)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpbhqvr5r2.swift:11:12: error: cannot find 'count_chars' in scope\n\
    \    return count_chars(s, isUpper)\n           ^~~~~~~~~~~\n/tmp/tmpbhqvr5r2.swift:11:27:\
    \ error: cannot find 'isUpper' in scope\n    return count_chars(s, isUpper)\n\
    \                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard\n        s.startsWith(\"a\") || s.startsWith(\"\
    A\"),\n        let uppercaseLetters = map(s.unicodeScalars.filter({ $0.value >\
    \ 0x41 }), { $0.value })\n    else {\n        return 0\n    }\n    let count =\
    \ _countEvenIndices(uppercaseLetters)\n    if let firstLetter = uppercaseLetters.first\
    \ {\n        if count > 0 && firstLetter.value > 0x41 {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2quij2ya.swift:12:11: error: value of type 'String' has no member\
    \ 'startsWith'\n        s.startsWith(\"a\") || s.startsWith(\"A\"),\n        ~\
    \ ^~~~~~~~~~\n/tmp/tmp2quij2ya.swift:12:32: error: value of type 'String' has\
    \ no member 'startsWith'\n        s.startsWith(\"a\") || s.startsWith(\"A\"),\n\
    \                             ~ ^~~~~~~~~~\n/tmp/tmp2quij2ya.swift:13:32: error:\
    \ cannot find 'map' in scope\n        let uppercaseLetters = map(s.unicodeScalars.filter({\
    \ $0.value > 0x41 }), { $0.value })\n                               ^~~\n/tmp/tmp2quij2ya.swift:17:17:\
    \ error: cannot find '_countEvenIndices' in scope\n    let count = _countEvenIndices(uppercaseLetters)\n\
    \                ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n\n    for i := 0; i < len(s); i += 2 {\n\
    \        if s[i] == 'A' && s[i+1] == 'A' {\n            count += 1\n        }\n\
    \    }\n\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpew5pwqv7.swift:13:12: error: expected type\n    for i := 0; i <\
    \ len(s); i += 2 {\n           ^\n            <#type#>\n/tmp/tmpew5pwqv7.swift:13:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(s); i +=\
    \ 2 {\n           ^\n/tmp/tmpew5pwqv7.swift:13:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(s); i += 2 {\n           ^\n/tmp/tmpew5pwqv7.swift:14:20:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ && s[i+1] == 'A' {\n                   ^~~\n                   \"A\"\n/tmp/tmpew5pwqv7.swift:14:37:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ && s[i+1] == 'A' {\n                                    ^~~\n              \
    \                      \"A\"\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count_sub_str_indexes(\n        s, count_sub_str_predicate(SubStrPredicate(startIndex:\
    \ 0, endIndex: s.count, isUpperCase: true), s.startIndex))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpv05nhc34.swift:11:12: error: cannot find 'count_sub_str_indexes'\
    \ in scope\n    return count_sub_str_indexes(\n           ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpv05nhc34.swift:12:12: error: cannot find 'count_sub_str_predicate' in\
    \ scope\n        s, count_sub_str_predicate(SubStrPredicate(startIndex: 0, endIndex:\
    \ s.count, isUpperCase: true), s.startIndex))\n           ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpv05nhc34.swift:12:36: error: cannot find 'SubStrPredicate' in scope\n\
    \        s, count_sub_str_predicate(SubStrPredicate(startIndex: 0, endIndex: s.count,\
    \ isUpperCase: true), s.startIndex))\n                                   ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let evens = s[0..<s.count/4] // even indices\n    let\
    \ vowels = \"AEIOU\".map({ $0.unicodeScalars.first!.value }) //vowels\n    let\
    \ uppers = evens.filter({ vowels.contains($0) }) // uppers\n    return uppers.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp5vc_gpjp.swift:11:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \    let evens = s[0..<s.count/4] // even indices\n                ^~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp5vc_gpjp.swift:13:49: error: cannot\
    \ convert value of type 'String.Element' (aka 'Character') to expected argument\
    \ type 'UInt32'\n    let uppers = evens.filter({ vowels.contains($0) }) // uppers\n\
    \                                                ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var even = false\n    var count = 0\n    for c in s.characters\
    \ {\n        if c.isUpper() {\n            count += 1\n        } else {\n    \
    \        if even {\n                count += 1\n            }\n            even\
    \ = !even\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdxxtm82e.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdxxtm82e.swift:14:14:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if c.isUpper()\
    \ {\n           ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    func isVowel(x: UInt8) -> Bool {\n        let xc = UnicodeScalar(x)\n\
    \        return xc.isUppercase() && xc.value != UnicodeScalar.Other\n    }\n \
    \   var count = 0\n    for i in 0..<s.count {\n        if !isVowel(UInt8(i)) {\n\
    \            continue\n        }\n        if s.startIndex + i%2 == 0 {\n     \
    \       count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmps13da1eg.swift:13:19: error: value of type 'UnicodeScalar' (aka\
    \ 'Unicode.Scalar') has no member 'isUppercase'\n        return xc.isUppercase()\
    \ && xc.value != UnicodeScalar.Other\n               ~~ ^~~~~~~~~~~\n/tmp/tmps13da1eg.swift:13:62:\
    \ error: type 'UnicodeScalar' (aka 'Unicode.Scalar') has no member 'Other'\n \
    \       return xc.isUppercase() && xc.value != UnicodeScalar.Other\n         \
    \                                      ~~~~~~~~~~~~~ ^~~~~\n/tmp/tmps13da1eg.swift:17:21:\
    \ error: missing argument label 'x:' in call\n        if !isVowel(UInt8(i)) {\n\
    \                    ^\n                    x: \n/tmp/tmps13da1eg.swift:20:14:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        if s.startIndex + i%2 == 0 {\n             ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count_chars(s, is_upper, is_even)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1trunoxf.swift:11:12: error: cannot find 'count_chars' in scope\n\
    \    return count_chars(s, is_upper, is_even)\n           ^~~~~~~~~~~\n/tmp/tmp1trunoxf.swift:11:27:\
    \ error: cannot find 'is_upper' in scope\n    return count_chars(s, is_upper,\
    \ is_even)\n                          ^~~~~~~~\n/tmp/tmp1trunoxf.swift:11:37:\
    \ error: cannot find 'is_even' in scope\n    return count_chars(s, is_upper, is_even)\n\
    \                                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for c in s {\n        if let idx =\
    \ c.unicodeScalars.first {\n            switch idx.value {\n            case 0x3042:\n\
    \            case 0x3043:\n                count += 1\n            default:\n\
    \                break\n            }\n        } else {\n            break\n \
    \       }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzh5a4265.swift:15:13: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n            case 0x3042:\n            ^~~~~~~~~~~~\n\
    \                         break\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result : Int = 0\n    for i in 0..<s.count {\n   \
    \     if s[i] >= 'a' && s[i] <= 'z' {\n            result += 1\n        } else\
    \ if s[i] > 'a' && s[i] <= 'z' {\n            result -= 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmprog1p7sa.swift:13:20: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i] >= 'a' && s[i] <= 'z' {\n                   ^~~\n\
    \                   \"a\"\n/tmp/tmprog1p7sa.swift:13:35: error: single-quoted\
    \ string literal found, use '\"'\n        if s[i] >= 'a' && s[i] <= 'z' {\n  \
    \                                ^~~\n                                  \"z\"\n\
    /tmp/tmprog1p7sa.swift:15:26: error: single-quoted string literal found, use '\"\
    '\n        } else if s[i] > 'a' && s[i] <= 'z' {\n                         ^~~\n\
    \                         \"a\"\n/tmp/tmprog1p7sa.swift:15:41: error: single-quoted\
    \ string literal found, use '\"'\n        } else if s[i] > 'a' && s[i] <= 'z'\
    \ {\n                                        ^~~\n                           \
    \             \"z\"\n/tmp/tmprog1p7sa.swift:13:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[i] >= 'a' && s[i] <= 'z' {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmprog1p7sa.swift:13:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] >= 'a' && s[i] <= 'z' {\n                          ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprog1p7sa.swift:15:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if s[i] > 'a' && s[i] <= 'z' {\n\
    \                  ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmprog1p7sa.swift:15:33: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        }\
    \ else if s[i] > 'a' && s[i] <= 'z' {\n                                ^~~~\n\
    Swift.String:3:12: note: "
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for x in s {\n        if x == 'A' ||\
    \ x == 'a' {\n            count += 1\n        } else if x == 'B' || x == 'b' {\n\
    \            count += 1\n        } else if x == 'C' || x == 'c' {\n          \
    \  count += 1\n        } else if x == 'D' || x == 'd' {\n            count +=\
    \ 1\n        } else if x == 'E' || x == 'e' {\n            count += 1\n      \
    \  } else if x == 'F' || x == 'f' {\n            count += 1\n        } else if\
    \ x == 'G' || x == 'g' {\n            count += 1\n        } else if x == 'H' ||\
    \ x == 'h' {\n            count += 1\n        } else if x == 'I' || x == 'i' {\n\
    \            count += 1\n        } else if x == 'J' || x == 'j' {\n          \
    \  count += 1\n        } else if x == 'K' || x == 'k' {\n            count +=\
    \ 1\n        } else if x == 'L' || x == 'l' {\n            count += 1\n      \
    \  } else if x == 'M' || x == 'm' {\n            count += 1\n        } else if\
    \ x == 'N' || x == 'n' {\n            count += 1\n        } else if x == 'O' ||\
    \ x == 'o' {\n            count += 1\n        } else if x == 'P' || x == 'p' {\n\
    \            count += 1\n        } else if x == 'Q' || x == 'q' {\n          \
    \  count += 1\n        } else if x == 'R' || x == 'r' {\n            count +=\
    \ 1\n        } else if x == 'S' || x == 's' {\n            count += 1\n      \
    \  } else if x == 'T' || x == 't' {\n            count += 1\n        } else if\
    \ x == 'U' || x == 'u' {\n            count += 1\n        } else if x == 'V' ||\
    \ x == 'v' {\n            count += 1\n        } else if x == 'W' || x == 'w' {\n\
    \            count += 1\n        } else if x == 'X' || x == 'x' {\n          \
    \  count += 1\n        } else if x == 'Y' || x == 'y' {\n            count +=\
    \ 1\n        } else if x == 'Z' || x == 'z' {\n            count += 1\n      \
    \  } else if x == 'a' || x == 'A' {\n            count += 1\n        } else if\
    \ x == 'b' || x == 'B' {\n            count += 1\n        } else if x == 'c' ||\
    \ x == 'C' {\n            count += 1\n        } else if x == 'd' || x == 'D' {\n\
    \            count += 1\n        } else if x == 'e' || x == 'E' {\n          \
    \  count += 1\n        } else if x == 'f' || x == 'F' {\n            count +=\
    \ 1\n        } else if x == 'g' || x == 'G' {\n            count += 1\n      \
    \  } else if x == 'h' || x == 'H' {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_ctyo4wx.swift:13:17: error: single-quoted string literal found,\
    \ use '\"'\n        if x == 'A' || x == 'a' {\n                ^~~\n         \
    \       \"A\"\n/tmp/tmp_ctyo4wx.swift:13:29: error: single-quoted string literal\
    \ found, use '\"'\n        if x == 'A' || x == 'a' {\n                       \
    \     ^~~\n                            \"a\"\n/tmp/tmp_ctyo4wx.swift:15:24: error:\
    \ single-quoted string literal found, use '\"'\n        } else if x == 'B' ||\
    \ x == 'b' {\n                       ^~~\n                       \"B\"\n/tmp/tmp_ctyo4wx.swift:15:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if x ==\
    \ 'B' || x == 'b' {\n                                   ^~~\n                \
    \                   \"b\"\n/tmp/tmp_ctyo4wx.swift:17:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if x == 'C' || x == 'c' {\n \
    \                      ^~~\n                       \"C\"\n/tmp/tmp_ctyo4wx.swift:17:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if x ==\
    \ 'C' || x == 'c' {\n                                   ^~~\n                \
    \                   \"c\"\n/tmp/tmp_ctyo4wx.swift:19:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if x == 'D' || x == 'd' {\n \
    \                      ^~~\n                       \"D\"\n/tmp/tmp_ctyo4wx.swift:19:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if x ==\
    \ 'D' || x == 'd' {\n                                   ^~~\n                \
    \                   \"d\"\n/tmp/tmp_ctyo4wx.swift:21:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if x == 'E' || x == 'e' {\n \
    \                      ^~~\n                       \"E\"\n/tmp/tmp_ctyo4wx.swift:21:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if x ==\
    \ 'E' || x == 'e' {\n                                   ^~~\n                \
    \                   \"e\"\n/tmp/tmp_ctyo4wx.swift:23:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if x == 'F' || x == 'f' {\n \
    \                      ^~~\n                       \"F\"\n/tmp/tmp_ctyo4wx.swift:23:36:\
    \ erro"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    var isUppercase = false\n    for index,\
    \ _ := range s {\n        if index % 2 == 0 {\n            if s[index] == s[index].upper()\
    \ {\n                count++\n            }\n        } else {\n            isUppercase\
    \ = true\n        }\n    }\n    if !isUppercase {\n        return 0\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzr1fft8n.swift:13:14: error: expected 'in' after for-each pattern\n\
    \    for index, _ := range s {\n             ^\n/tmp/tmpzr1fft8n.swift:13:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, _ := range\
    \ s {\n             ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.scan(\"[aeiouAEIOU]\".toRegex()).filter { $0.index\
    \ == $0.upperBound}.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpnay69oor.swift:11:14: error: value of type 'String' has no member\
    \ 'scan'\n    return s.scan(\"[aeiouAEIOU]\".toRegex()).filter { $0.index == $0.upperBound}.count\n\
    \           ~ ^~~~\n/tmp/tmpnay69oor.swift:11:34: error: value of type 'String'\
    \ has no member 'toRegex'\n    return s.scan(\"[aeiouAEIOU]\".toRegex()).filter\
    \ { $0.index == $0.upperBound}.count\n                  ~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    // Count all uppercase letters.\n    var upperCaseCount\
    \ = 0\n\n    // Iterate over odd indices.\n    for i in 0..<s.characters.count\
    \ {\n        let character = s[i] // get the character at this index\n       \
    \ if Character(character).isUppercase {\n            upperCaseCount += 1 // count\
    \ that character\n        }\n\n        // Handle the even indices.\n        if\
    \ i % 2 == 0 {\n            upperCaseCount += 1 // count that character\n    \
    \    }\n    }\n\n    return upperCaseCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp59cilcbc.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<s.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp59cilcbc.swift:16:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let character = s[i] // get the character\
    \ at this index\n                        ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp59cilcbc.swift:17:12: error: no exact\
    \ matches in call to initializer \n        if Character(character).isUppercase\
    \ {\n           ^\nSwift.Character:5:23: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(extendedGraphemeClusterLiteral:)')\n    @inlinable\
    \ public init(extendedGraphemeClusterLiteral value: Character)\n             \
    \         ^\nSwift.ExpressibleByExtendedGraphemeClusterLiteral:2:12: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(unicodeScalarLiteral:)')\n \
    \   public init(unicodeScalarLiteral value: Self.ExtendedGraphemeClusterLiteralType)\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard s.count > 0 else {\n        return 0\n    }\n\n\
    \    var evenIndex = 0\n    var vowelCount = 0\n    for letter in s {\n      \
    \  guard letter >= 'A' && letter <= 'Z' else {\n            return vowelCount\n\
    \        }\n\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n            vowelCount += 1\n        }\n        if\
    \ letter % 2 == 0 {\n            evenIndex += 1\n        }\n    }\n\n    if evenIndex\
    \ % 2 == 0 {\n        return vowelCount\n    }\n\n    return 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpa09tlfes.swift:18:25: error: single-quoted string literal found,\
    \ use '\"'\n        guard letter >= 'A' && letter <= 'Z' else {\n            \
    \            ^~~\n                        \"A\"\n/tmp/tmpa09tlfes.swift:18:42:\
    \ error: single-quoted string literal found, use '\"'\n        guard letter >=\
    \ 'A' && letter <= 'Z' else {\n                                         ^~~\n\
    \                                         \"Z\"\n/tmp/tmpa09tlfes.swift:22:22:\
    \ error: single-quoted string literal found, use '\"'\n        if letter == 'a'\
    \ || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n    \
    \                 ^~~\n                     \"a\"\n/tmp/tmpa09tlfes.swift:22:39:\
    \ error: single-quoted string literal found, use '\"'\n        if letter == 'a'\
    \ || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n    \
    \                                  ^~~\n                                     \
    \ \"e\"\n/tmp/tmpa09tlfes.swift:22:56: error: single-quoted string literal found,\
    \ use '\"'\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n                                                \
    \       ^~~\n                                                       \"i\"\n/tmp/tmpa09tlfes.swift:22:73:\
    \ error: single-quoted string literal found, use '\"'\n        if letter == 'a'\
    \ || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n    \
    \                                                                    ^~~\n   \
    \                                                                     \"o\"\n\
    /tmp/tmpa09tlfes.swift:22:90: error: single-quoted string literal found, use '\"\
    '\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o'\
    \ || letter == 'u' {\n                                                       \
    \                                  ^~~\n                                     \
    \                                                    \"u\"\n/tmp/tmpa09tlfes.swift:25:12:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \        if letter % 2 == 0 {\n           ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if let len = s.characters.count {\n        var count =\
    \ 0\n        for idx in 0..<len {\n            let c = s[idx] as UnicodeScalar\n\
    \            if c == c.uppercase && idx % 2 == 0 {\n                count += 1\n\
    \            }\n        }\n        return count\n    }\n    return 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_mvaip6f.swift:11:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    if let len = s.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp_mvaip6f.swift:14:28:\
    \ error: cannot convert value of type 'Character' to type 'UnicodeScalar' (aka\
    \ 'Unicode.Scalar') in coercion\n            let c = s[idx] as UnicodeScalar\n\
    \                    ~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmp_mvaip6f.swift:11:8: error:\
    \ initializer for conditional binding must have Optional type, not 'Int'\n   \
    \ if let len = s.characters.count {\n       ^         ~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard len(s) >= 2 else { return 0 }\n    var count = 0\n\
    \    for c in s {\n        if c == 'A' || c == 'E' || c == 'I' || c == 'O' ||\
    \ c == 'U' {\n            count += 1\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyf4odqi9.swift:14:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\
    \ {\n                ^~~\n                \"A\"\n/tmp/tmpyf4odqi9.swift:14:29:\
    \ error: single-quoted string literal found, use '\"'\n        if c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                           \
    \ ^~~\n                            \"E\"\n/tmp/tmpyf4odqi9.swift:14:41: error:\
    \ single-quoted string literal found, use '\"'\n        if c == 'A' || c == 'E'\
    \ || c == 'I' || c == 'O' || c == 'U' {\n                                    \
    \    ^~~\n                                        \"I\"\n/tmp/tmpyf4odqi9.swift:14:53:\
    \ error: single-quoted string literal found, use '\"'\n        if c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n                           \
    \                         ^~~\n                                              \
    \      \"O\"\n/tmp/tmpyf4odqi9.swift:14:65: error: single-quoted string literal\
    \ found, use '\"'\n        if c == 'A' || c == 'E' || c == 'I' || c == 'O' ||\
    \ c == 'U' {\n                                                               \
    \ ^~~\n                                                                \"U\"\n\
    /tmp/tmpyf4odqi9.swift:11:11: error: cannot find 'len' in scope\n    guard len(s)\
    \ >= 2 else { return 0 }\n          ^~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for i := 0; i < len(s); i++ {\n   \
    \     if s[i] == unicode.ToUpper(s[i]) {\n            if i % 2 == 0 {\n      \
    \          count += 1\n            }\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpm7hvvchp.swift:12:12: error: expected type\n    for i := 0; i <\
    \ len(s); i++ {\n           ^\n            <#type#>\n/tmp/tmpm7hvvchp.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(s); i++\
    \ {\n           ^\n/tmp/tmpm7hvvchp.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(s); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\treturn count_upper_indices(s, 0)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjjaxznx_.swift:11:9: error: cannot find 'count_upper_indices' in\
    \ scope\n        return count_upper_indices(s, 0)\n               ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tvar i uint = 0\n\tfor i := 0; i < len(s); i++ {\n\t\tif\
    \ s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n\t\
    \t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\treturn i + 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppx3wmav7.swift:11:8: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var i uint =\
    \ 0\n              ^\n/tmp/tmppx3wmav7.swift:11:8: note: join the identifiers\
    \ together\n        var i uint = 0\n            ~~^~~~\n            iuint\n/tmp/tmppx3wmav7.swift:11:8:\
    \ note: join the identifiers together with camel-case\n        var i uint = 0\n\
    \            ~~^~~~\n            iUint\n/tmp/tmppx3wmav7.swift:12:9: error: expected\
    \ type\n        for i := 0; i < len(s); i++ {\n               ^\n            \
    \    <#type#>\n/tmp/tmppx3wmav7.swift:12:9: error: expected 'in' after for-each\
    \ pattern\n        for i := 0; i < len(s); i++ {\n               ^\n/tmp/tmppx3wmav7.swift:12:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < len(s); i++ {\n               ^\n/tmp/tmppx3wmav7.swift:13:14: error: single-quoted\
    \ string literal found, use '\"'\n                if s[i] == 'A' || s[i] == 'E'\
    \ || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n                           ^~~\n\
    \                           \"A\"\n/tmp/tmppx3wmav7.swift:13:29: error: single-quoted\
    \ string literal found, use '\"'\n                if s[i] == 'A' || s[i] == 'E'\
    \ || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n                           \
    \               ^~~\n                                          \"E\"\n/tmp/tmppx3wmav7.swift:13:44:\
    \ error: single-quoted string literal found, use '\"'\n                if s[i]\
    \ == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n     \
    \                                                    ^~~\n                   \
    \                                      \"I\"\n/tmp/tmppx3wmav7.swift:13:59: error:\
    \ single-quoted string literal found, use '\"'\n                if s[i] == 'A'\
    \ || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n            \
    \                                                            ^~~\n           \
    \                                                             \"O\"\n/tmp/tmppx3wmav7.swift:13:74:\
    \ error: single-quoted string literal found, use '\"'\n             "
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var n = 0\n    for x in s.characters {\n        guard\
    \ x > 'a' && x < 'z' else {\n            continue\n        }\n\n        guard\
    \ x >= 'a' && x <= 'z' else {\n            continue\n        }\n        n = n\
    \ + (x - 'a') * (x - 'a') > 1\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp0p6kocgn.swift:13:19: error: single-quoted string literal found,\
    \ use '\"'\n        guard x > 'a' && x < 'z' else {\n                  ^~~\n \
    \                 \"a\"\n/tmp/tmp0p6kocgn.swift:13:30: error: single-quoted string\
    \ literal found, use '\"'\n        guard x > 'a' && x < 'z' else {\n         \
    \                    ^~~\n                             \"z\"\n/tmp/tmp0p6kocgn.swift:17:20:\
    \ error: single-quoted string literal found, use '\"'\n        guard x >= 'a'\
    \ && x <= 'z' else {\n                   ^~~\n                   \"a\"\n/tmp/tmp0p6kocgn.swift:17:32:\
    \ error: single-quoted string literal found, use '\"'\n        guard x >= 'a'\
    \ && x <= 'z' else {\n                               ^~~\n                   \
    \            \"z\"\n/tmp/tmp0p6kocgn.swift:20:22: error: single-quoted string\
    \ literal found, use '\"'\n        n = n + (x - 'a') * (x - 'a') > 1\n       \
    \              ^~~\n                     \"a\"\n/tmp/tmp0p6kocgn.swift:20:34:\
    \ error: single-quoted string literal found, use '\"'\n        n = n + (x - 'a')\
    \ * (x - 'a') > 1\n                                 ^~~\n                    \
    \             \"a\"\n/tmp/tmp0p6kocgn.swift:12:16: error: 'characters' is unavailable:\
    \ Please use String directly\n    for x in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0p6kocgn.swift:20:9:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n        n = n\
    \ + (x - 'a') * (x - 'a') > 1\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978751
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var i = 0\n    for c in s {\n        if c == c[0] && c\
    \ == 'A' || c == 'a' {\n            i += 1\n        }\n    }\n    return i\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyhtvps8m.swift:13:30: error: single-quoted string literal found,\
    \ use '\"'\n        if c == c[0] && c == 'A' || c == 'a' {\n                 \
    \            ^~~\n                             \"A\"\n/tmp/tmpyhtvps8m.swift:13:42:\
    \ error: single-quoted string literal found, use '\"'\n        if c == c[0] &&\
    \ c == 'A' || c == 'a' {\n                                         ^~~\n     \
    \                                    \"a\"\n/tmp/tmpyhtvps8m.swift:13:18: error:\
    \ value of type 'Character' has no subscripts\n        if c == c[0] && c == 'A'\
    \ || c == 'a' {\n                ~^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\treturn count_upper_internal(s.characters) + count_upper_internal(s.characters)\
    \ + count_upper_internal(s.characters) + count_upper_internal(s.characters) +\
    \ count_upper_internal(s.characters)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxv8c15ys.swift:11:9: error: cannot find 'count_upper_internal'\
    \ in scope\n        return count_upper_internal(s.characters) + count_upper_internal(s.characters)\
    \ + count_upper_internal(s.characters) + count_upper_internal(s.characters) +\
    \ count_upper_internal(s.characters)\n               ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxv8c15ys.swift:11:46:\
    \ error: cannot find 'count_upper_internal' in scope\n        return count_upper_internal(s.characters)\
    \ + count_upper_internal(s.characters) + count_upper_internal(s.characters) +\
    \ count_upper_internal(s.characters) + count_upper_internal(s.characters)\n  \
    \                                                  ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxv8c15ys.swift:11:83:\
    \ error: cannot find 'count_upper_internal' in scope\n        return count_upper_internal(s.characters)\
    \ + count_upper_internal(s.characters) + count_upper_internal(s.characters) +\
    \ count_upper_internal(s.characters) + count_upper_internal(s.characters)\n  \
    \                                                                            \
    \           ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxv8c15ys.swift:11:120: error: cannot\
    \ find 'count_upper_internal' in scope\n        return count_upper_internal(s.characters)\
    \ + count_upper_internal(s.characters) + count_upper_internal(s.characters) +\
    \ count_upper_internal(s.characters) + count_upper_internal(s.characters)\n  \
    \                                                                            \
    \                                                ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxv8c15ys.swift:11:157:\
    \ error: cannot find 'count_upper_internal' in scope\n        return count_upper_internal(s.characters)\
    \ + count_upper_internal(s.characters) + count_upper_internal(s.characters) +\
    \ count_upper_internal(s.characters) + count_upper_internal(s.characters)\n  \
    \                                                                            \
    \                                                                            \
    \         ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxv8c15ys.swift:11:9: error: the compiler\
    \ is unable to type-check this expression in reasonable"
  stdout: ''
  timestamp: 1659978747
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var counter = s.count\n    repeat {\n        let index\
    \ = s.index(after: s.startIndex, offsetBy: 2)\n        let char = s[index]\n \
    \       guard char.isUppercase else { break }\n        counter -= 1\n    } while\
    \ true\n    return counter\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpfzt9xkt2.swift:13:23: error: no exact matches in call to instance\
    \ method 'index'\n        let index = s.index(after: s.startIndex, offsetBy: 2)\n\
    \                      ^\nSwift.String:9:17: note: incorrect labels for candidate\
    \ (have: '(after:offsetBy:)', expected: '(_:offsetBy:)')\n    public func index(_\
    \ i: String.Index, offsetBy distance: Int) -> String.Index\n                ^\n\
    Swift.Collection:6:28: note: incorrect labels for candidate (have: '(after:offsetBy:)',\
    \ expected: '(_:offsetBy:)')\n    @inlinable public func index(_ i: Self.Index,\
    \ offsetBy distance: Int) -> Self.Index\n                           ^\nSwift.BidirectionalCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(after:offsetBy:)', expected: '(_:offsetBy:)')\n\
    \    @inlinable public func index(_ i: Self.Index, offsetBy distance: Int) ->\
    \ Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var counter = 0\n    s.characters\n        .enumerate()\n\
    \        .forEach { index, char in in\n            if char.isUpper() {\n     \
    \           counter += 1\n            } else if index%2 == 0 && char.isUpper()\
    \ {\n                counter += 1\n            }\n        }\n    return counter\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpttpzyjmn.swift:14:35: error: expected expression\n        .forEach\
    \ { index, char in in\n                                  ^\n/tmp/tmpttpzyjmn.swift:13:10:\
    \ error: value of type 'String' has no member 'enumerate'\n        .enumerate()\n\
    \         ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\treturn s.searchString(upperCaseString, options: .CaseInsensitive)\
    \ != nil ? 1\n\t\t: s.searchString(upperCaseString) != nil ? 0\n\t\t: 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpcgrjt465.swift:11:24: error: cannot find 'upperCaseString' in scope\n\
    \        return s.searchString(upperCaseString, options: .CaseInsensitive) !=\
    \ nil ? 1\n                              ^~~~~~~~~~~~~~~\n/tmp/tmpcgrjt465.swift:12:20:\
    \ error: cannot find 'upperCaseString' in scope\n                : s.searchString(upperCaseString)\
    \ != nil ? 0\n                                 ^~~~~~~~~~~~~~~\n/tmp/tmpcgrjt465.swift:11:11:\
    \ error: value of type 'String' has no member 'searchString'\n        return s.searchString(upperCaseString,\
    \ options: .CaseInsensitive) != nil ? 1\n               ~ ^~~~~~~~~~~~\n/tmp/tmpcgrjt465.swift:11:51:\
    \ error: cannot infer contextual base in reference to member 'CaseInsensitive'\n\
    \        return s.searchString(upperCaseString, options: .CaseInsensitive) !=\
    \ nil ? 1\n                                                        ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpcgrjt465.swift:12:7: error: value of type 'String' has no member 'searchString'\n\
    \                : s.searchString(upperCaseString) != nil ? 0\n              \
    \    ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var total = 0\n    for i : Int in stride(from: s.characters.startIndex,\
    \ to: s.endIndex, by: 2) {\n        if s[i] == \"A\" {\n            total += 1\n\
    \        } else if s[i] == \"E\" {\n            total += 1\n        } else if\
    \ s[i] == \"I\" {\n            total += 1\n        } else if s[i] == \"O\" {\n\
    \            total += 1\n        } else if s[i] == \"U\" {\n            total\
    \ += 1\n        } else if s[i] == \"a\" {\n            total += 1\n        } else\
    \ if s[i] == \"e\" {\n            total += 1\n        } else if s[i] == \"i\"\
    \ {\n            total += 1\n        } else if s[i] == \"o\" {\n            total\
    \ += 1\n        } else if s[i] == \"u\" {\n            total += 1\n        }\n\
    \    }\n    return total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpu5hofa9w.swift:12:20: error: global function 'stride(from:to:by:)'\
    \ requires that 'String.Index' conform to 'Strideable'\n    for i : Int in stride(from:\
    \ s.characters.startIndex, to: s.endIndex, by: 2) {\n                   ^\nSwift.stride:1:24:\
    \ note: where 'T' = 'String.Index'\n@inlinable public func stride<T>(from start:\
    \ T, to end: T, by stride: T.Stride) -> StrideTo<T> where T : Strideable\n   \
    \                    ^\n/tmp/tmpu5hofa9w.swift:12:20: error: cannot convert sequence\
    \ element type 'String.Index' to expected type 'Int'\n    for i : Int in stride(from:\
    \ s.characters.startIndex, to: s.endIndex, by: 2) {\n                   ^\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var n = count_upper_i(s.utf8)\n    if n >= len(s) {\n\
    \        n = len(s)\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6x29duhb.swift:11:13: error: cannot find 'count_upper_i' in scope\n\
    \    var n = count_upper_i(s.utf8)\n            ^~~~~~~~~~~~~\n/tmp/tmp6x29duhb.swift:12:13:\
    \ error: cannot find 'len' in scope\n    if n >= len(s) {\n            ^~~\n/tmp/tmp6x29duhb.swift:13:13:\
    \ error: cannot find 'len' in scope\n        n = len(s)\n            ^~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: -4
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for c in s {\n        if (\"AEIOU\"\
    .contains(String(c))) {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\"\
    ) == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: Exception
  stderr: 'tmpqrdpc7fa/tmpqrdpc7fa.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44d412fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44d3e26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44d3e26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44d3e257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqrdpc7fa                        0x000055cb1e25c5a2 <unavailable> + 5538

    5    libc.so.6                          0x00002b44d431b460 __libc_start_main +
    245

    6    tmpqrdpc7fa                        0x000055cb1e25c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    func count(index: Int) -> Int {\n        let char = s.character(at:\
    \ index)\n        switch (char) {\n        case .upper, .lower:\n            return\
    \ 0\n        default:\n            return 1\n        }\n    }\n    return s.enumerated().reduce(0)\
    \ { $0 + count($1) + count($2) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxhqqfy5y.swift:12:22: error: value of type 'String' has no member\
    \ 'character'\n        let char = s.character(at: index)\n                   ~\
    \ ^~~~~~~~~\n/tmp/tmpxhqqfy5y.swift:20:27: error: no exact matches in call to\
    \ instance method 'reduce'\n    return s.enumerated().reduce(0) { $0 + count($1)\
    \ + count($2) }\n                          ^\n/tmp/tmpxhqqfy5y.swift:20:27: note:\
    \ candidate has partially matching parameter list (Int, (Int, EnumeratedSequence<String>.Iterator.Element)\
    \ throws -> Int)\n    return s.enumerated().reduce(0) { $0 + count($1) + count($2)\
    \ }\n                          ^\n/tmp/tmpxhqqfy5y.swift:20:27: note: found candidate\
    \ with type '(__owned @escaping (Int, Int, Int) -> Int, (inout @escaping (Int,\
    \ Int, Int) -> Int, EnumeratedSequence<String>.Iterator.Element) throws -> ())\
    \ throws -> (Int, Int, Int) -> Int' (aka '(__owned @escaping (Int, Int, Int) ->\
    \ Int, (inout @escaping (Int, Int, Int) -> Int, (offset: Int, element: Character))\
    \ throws -> ()) throws -> (Int, Int, Int) -> Int')\n    return s.enumerated().reduce(0)\
    \ { $0 + count($1) + count($2) }\n                          ^\n/tmp/tmpxhqqfy5y.swift:20:50:\
    \ error: missing argument label 'index:' in call\n    return s.enumerated().reduce(0)\
    \ { $0 + count($1) + count($2) }\n                                           \
    \      ^\n                                                 index: \n/tmp/tmpxhqqfy5y.swift:20:62:\
    \ error: missing argument label 'index:' in call\n    return s.enumerated().reduce(0)\
    \ { $0 + count($1) + count($2) }\n                                           \
    \                  ^\n                                                       \
    \      index: \n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tlet a = s.characters\n\tlet p = a.startIndex\n\n\tvar c\
    \ = 0\n\tfor i in 0..<s.characters.count {\n\t\tif s[i] == s.characters[p] {\n\
    \t\t\tc++\n\t\t\tp++\n\t\t}\n\t}\n\n\treturn c\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyompbfwg.swift:11:12: error: 'characters' is unavailable: Please\
    \ use String directly\n        let a = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpyompbfwg.swift:15:17:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ i in 0..<s.characters.count {\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpyompbfwg.swift:16:6: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                if s[i] == s.characters[p] {\n                   ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpyompbfwg.swift:16:16:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \     if s[i] == s.characters[p] {\n                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpyompbfwg.swift:17:5:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \              c++\n                         ^~\n/tmp/tmpyompbfwg.swift:18:5:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \              p++\n                         ^~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard s.utf8.count % 2 == 0 else {\n        return 0\n\
    \    }\n\n    var upper = 0\n    for i in 0 ..< s.utf8.count {\n        guard\
    \ s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' else\
    \ {\n            return 0\n        }\n\n        if i % 2 == 0 {\n            upper\
    \ += 1\n        }\n    }\n\n    return upper\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpqcuvi03r.swift:17:23: error: single-quoted string literal found,\
    \ use '\"'\n        guard s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'u' else {\n                      ^~~\n                     \
    \ \"a\"\n/tmp/tmpqcuvi03r.swift:17:38: error: single-quoted string literal found,\
    \ use '\"'\n        guard s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'u' else {\n                                     ^~~\n      \
    \                               \"e\"\n/tmp/tmpqcuvi03r.swift:17:53: error: single-quoted\
    \ string literal found, use '\"'\n        guard s[i] == 'a' || s[i] == 'e' ||\
    \ s[i] == 'i' || s[i] == 'o' || s[i] == 'u' else {\n                         \
    \                           ^~~\n                                            \
    \        \"i\"\n/tmp/tmpqcuvi03r.swift:17:68: error: single-quoted string literal\
    \ found, use '\"'\n        guard s[i] == 'a' || s[i] == 'e' || s[i] == 'i' ||\
    \ s[i] == 'o' || s[i] == 'u' else {\n                                        \
    \                           ^~~\n                                            \
    \                       \"o\"\n/tmp/tmpqcuvi03r.swift:17:83: error: single-quoted\
    \ string literal found, use '\"'\n        guard s[i] == 'a' || s[i] == 'e' ||\
    \ s[i] == 'i' || s[i] == 'o' || s[i] == 'u' else {\n                         \
    \                                                         ^~~\n              \
    \                                                                    \"u\"\n/tmp/tmpqcuvi03r.swift:17:15:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        guard s[i] == 'a' || s[i] == 'e' || s[i]\
    \ == 'i' || s[i] == 'o' || s[i] == 'u' else {\n              ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpqcuvi03r.swift:17:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        guard s[i] == 'a' || s[i] == 'e' || s[i]\
    \ == 'i' || s[i] == 'o' || s[i] == 'u' else"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var n = s.length\n    var even = 0\n    for _ in 0..<n\
    \ {\n        switch s[_] {\n        case \"A\",\"E\",\"I\",\"O\",\"U\": even++\n\
    \        default: break\n        }\n    }\n    return even\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpr0l8agar.swift:11:15: error: value of type 'String' has no member\
    \ 'length'\n    var n = s.length\n            ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count_upper_func(s, \"\")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplkp7_ryn.swift:11:12: error: cannot find 'count_upper_func' in\
    \ scope\n    return count_upper_func(s, \"\")\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    vowels_count := 0\n    for i := 0; i < len(s); i++ {\n\
    \        if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] ==\
    \ 'U' {\n            vowels_count++\n        }\n    }\n    return vowels_count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6zci7pov.swift:11:17: error: consecutive statements on a line must\
    \ be separated by ';'\n    vowels_count := 0\n                ^\n            \
    \    ;\n/tmp/tmp6zci7pov.swift:11:18: error: expected expression\n    vowels_count\
    \ := 0\n                 ^\n/tmp/tmp6zci7pov.swift:12:12: error: expected type\n\
    \    for i := 0; i < len(s); i++ {\n           ^\n            <#type#>\n/tmp/tmp6zci7pov.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(s); i++\
    \ {\n           ^\n/tmp/tmp6zci7pov.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(s); i++ {\n           ^\n/tmp/tmp6zci7pov.swift:13:20:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n            \
    \       ^~~\n                   \"A\"\n/tmp/tmp6zci7pov.swift:13:35: error: single-quoted\
    \ string literal found, use '\"'\n        if s[i] == 'A' || s[i] == 'E' || s[i]\
    \ == 'I' || s[i] == 'O' || s[i] == 'U' {\n                                  ^~~\n\
    \                                  \"E\"\n/tmp/tmp6zci7pov.swift:13:50: error:\
    \ single-quoted string literal found, use '\"'\n        if s[i] == 'A' || s[i]\
    \ == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n                    \
    \                             ^~~\n                                          \
    \       \"I\"\n/tmp/tmp6zci7pov.swift:13:65: error: single-quoted string literal\
    \ found, use '\"'\n        if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i]\
    \ == 'O' || s[i] == 'U' {\n                                                  \
    \              ^~~\n                                                         \
    \       \"O\"\n/tmp/tmp6zci7pov.swift:13:80: error: single-quoted string literal\
    \ found, use '\"'\n        if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i]\
    \ == 'O' || s[i] == 'U' {\n                                                  \
    \                             ^~~\n                                          \
    \                                     \"U\"\n/tmp/tmp6zci7pov.swift:11:5: error:\
    \ cannot find 'vowels_count' in "
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 1\n    for i in s.characters {\n        guard\
    \ i != s.lowercaseString else { return 0 }\n        if i.isUppercase {\n     \
    \       count += 1\n        } else if i.isUppercase && count > 1 {\n         \
    \   return 0\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpy_n6xl0r.swift:12:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpy_n6xl0r.swift:13:22:\
    \ error: value of type 'String' has no member 'lowercaseString'\n        guard\
    \ i != s.lowercaseString else { return 0 }\n                   ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = 1\n    for i in\n        0 ..< s.characters.count,\n\
    \        let c = s.characters[i]\n        if c == c.uppercaseValue {\n       \
    \     result++\n        }\n        guard i % 2 == 0 else {\n            break\n\
    \        }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp79o0n0wj.swift:13:33: error: expected '{' to start the body of\
    \ for-each loop\n        0 ..< s.characters.count,\n                         \
    \       ^\n/tmp/tmp79o0n0wj.swift:13:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        0 ..< s.characters.count,\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp79o0n0wj.swift:14:30:\
    \ error: cannot find 'i' in scope\n        let c = s.characters[i]\n         \
    \                    ^\n/tmp/tmp79o0n0wj.swift:16:19: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            result++\n                \
    \  ^~\n/tmp/tmp79o0n0wj.swift:18:15: error: cannot find 'i' in scope\n       \
    \ guard i % 2 == 0 else {\n              ^\n/tmp/tmp79o0n0wj.swift:19:13: error:\
    \ 'break' is only allowed inside a loop, if, do, or switch\n            break\n\
    \            ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = 0\n    for idx in 0..<s.count {\n       \
    \ if s.isUpper { result += 1 }\n        idx += 2\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvo4nma7y.swift:13:14: error: value of type 'String' has no member\
    \ 'isUpper'\n        if s.isUpper { result += 1 }\n           ~ ^~~~~~~\n/tmp/tmpvo4nma7y.swift:14:13:\
    \ error: left side of mutating operator isn't mutable: 'idx' is a 'let' constant\n\
    \        idx += 2\n        ~~~ ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if isUpper(s, true) {\n        return s.countUpToIndex\
    \ {\n            if $0 % 2 == 0 { return true }\n            else { return false\
    \ }\n        }\n    } else {\n        return 0\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"\
    abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphiakv3o_.swift:11:8: error: cannot find 'isUpper' in scope\n  \
    \  if isUpper(s, true) {\n       ^~~~~~~\n/tmp/tmphiakv3o_.swift:12:18: error:\
    \ value of type 'String' has no member 'countUpToIndex'\n        return s.countUpToIndex\
    \ {\n               ~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    // precondition(s.isLower)\n\n    let mut count = 0\n\n\
    \    for c in s.characters {\n        if c.isUpper() {\n            count = count\
    \ + 1\n            if c.isUpper() {\n                count = count + 1\n     \
    \       }\n        }\n    }\n\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp7upr78wt.swift:13:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut count =\
    \ 0\n            ^\n/tmp/tmp7upr78wt.swift:13:13: note: join the identifiers together\n\
    \    let mut count = 0\n        ~~~~^~~~~\n        mutcount\n/tmp/tmp7upr78wt.swift:13:13:\
    \ note: join the identifiers together with camel-case\n    let mut count = 0\n\
    \        ~~~~^~~~~\n        mutCount\n/tmp/tmp7upr78wt.swift:15:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7upr78wt.swift:16:14: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if c.isUpper() {\n           ~ ^~~~~~~\n/tmp/tmp7upr78wt.swift:17:13:\
    \ error: cannot find 'count' in scope\n            count = count + 1\n       \
    \     ^~~~~\n/tmp/tmp7upr78wt.swift:17:21: error: cannot find 'count' in scope\n\
    \            count = count + 1\n                    ^~~~~\n/tmp/tmp7upr78wt.swift:18:18:\
    \ error: value of type 'Character' has no member 'isUpper'\n            if c.isUpper()\
    \ {\n               ~ ^~~~~~~\n/tmp/tmp7upr78wt.swift:19:17: error: cannot find\
    \ 'count' in scope\n                count = count + 1\n                ^~~~~\n\
    /tmp/tmp7upr78wt.swift:19:25: error: cannot find 'count' in scope\n          \
    \      count = count + 1\n                        ^~~~~\n/tmp/tmp7upr78wt.swift:24:12:\
    \ error: cannot find 'count' in scope\n    return count\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    // The array is unsorted, so sort in place.\n    var vowels:\
    \ [Int] = []\n    for c in s.characters {\n        switch c {\n        case 'a':\n\
    \            vowels.append(0)\n        case 'e':\n            vowels.append(1)\n\
    \        case 'i':\n            vowels.append(2)\n        case 'o':\n        \
    \    vowels.append(3)\n        case 'u':\n            vowels.append(4)\n     \
    \   default:\n            return 0\n        }\n    }\n    vowels.sort()\n    var\
    \ count = 0\n    var pos = 0\n    for ix in 0..<vowels.count {\n        count\
    \ += vowels[ix] == 2 ? 1 : 0\n        pos += vowels[ix] == 2 ? 1 : 0\n       \
    \ if pos == 2 {\n            break\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmflr8m6a.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpmflr8m6a.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpmflr8m6a.swift:19:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmpmflr8m6a.swift:21:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'o':\n             ^~~\n             \"o\"\n/tmp/tmpmflr8m6a.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmpmflr8m6a.swift:13:16: error: 'characters'\
    \ is unavailable: Please use String directly\n    for c in s.characters {\n  \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\treturn s.split(\"\").reduce(0) {\n\t\tacc, _, _ in\n\t\t\
    acc + Int(s[Int(arc4random_uniform(UInt32(s.characters.count)))]) == c ? 1 : 0\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") ==\
    \ 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmppyomv4my.swift:13:19: error: cannot find 'arc4random_uniform' in\
    \ scope\n                acc + Int(s[Int(arc4random_uniform(UInt32(s.characters.count)))])\
    \ == c ? 1 : 0\n                                ^~~~~~~~~~~~~~~~~~\n/tmp/tmppyomv4my.swift:13:72:\
    \ error: cannot find 'c' in scope\n                acc + Int(s[Int(arc4random_uniform(UInt32(s.characters.count)))])\
    \ == c ? 1 : 0\n                                                             \
    \                        ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    var lastIndex = s.startIndex\n    var\
    \ ch: String\n\n    while lastIndex != s.endIndex {\n        ch = s[lastIndex]\n\
    \        if ch >= 'a' && ch <= 'z' {\n            count += 1\n        }\n    \
    \    lastIndex++\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsdfihbxr.swift:17:18: error: single-quoted string literal found,\
    \ use '\"'\n        if ch >= 'a' && ch <= 'z' {\n                 ^~~\n      \
    \           \"a\"\n/tmp/tmpsdfihbxr.swift:17:31: error: single-quoted string literal\
    \ found, use '\"'\n        if ch >= 'a' && ch <= 'z' {\n                     \
    \         ^~~\n                              \"z\"\n/tmp/tmpsdfihbxr.swift:16:15:\
    \ error: cannot assign value of type 'Character' to type 'String'\n        ch\
    \ = s[lastIndex]\n             ~^~~~~~~~~~~\n/tmp/tmpsdfihbxr.swift:20:18: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        lastIndex++\n\
    \                 ^~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count_up_to(s.count, s.characters.filter({ $0.isUppercase()\
    \ })).filter({ $0.isOdd }).count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_k202zfz.swift:11:12: error: cannot find 'count_up_to' in scope\n\
    \    return count_up_to(s.count, s.characters.filter({ $0.isUppercase() })).filter({\
    \ $0.isOdd }).count\n           ^~~~~~~~~~~\n/tmp/tmp_k202zfz.swift:11:58: error:\
    \ cannot call value of non-function type 'Bool'\n    return count_up_to(s.count,\
    \ s.characters.filter({ $0.isUppercase() })).filter({ $0.isOdd }).count\n    \
    \                                                     ^          ~~\n        \
    \                                                            \n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for idx in indices(s, 2) {\n      \
    \  if s[idx].isUpper() {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\"\
    ) == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8k7_6oe7.swift:12:16: error: cannot find 'indices' in scope\n \
    \   for idx in indices(s, 2) {\n               ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var i = 0\n    while i < s.count && s[i] == s[i] {\n \
    \       i += 1\n    }\n    if i < s.count {\n        let j = i + 1\n        while\
    \ j < s.count && s[j] == s[j] {\n            j += 1\n        }\n        if i <\
    \ j {\n            i += j - i\n        }\n    }\n    return i\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpydqtk7l1.swift:12:26: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    while i < s.count\
    \ && s[i] == s[i] {\n                         ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpydqtk7l1.swift:12:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    while i < s.count && s[i] == s[i] {\n                                 ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpydqtk7l1.swift:17:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        while j < s.count && s[j] == s[j] {\n \
    \                            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpydqtk7l1.swift:17:38: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        while j < s.count && s[j] == s[j] {\n                               \
    \      ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpydqtk7l1.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'j' is a 'let' constant\n            j += 1\n            ~ ^\n/tmp/tmpydqtk7l1.swift:16:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let j = i + 1\n    \
    \    ^~~\n        var\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: -4
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result : Int = 0\n    s.forEach { char in\n      \
    \  if char == \"A\" || char == \"a\" {\n            result += 1\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: Exception
  stderr: 'tmpm2h0i9t5/tmpm2h0i9t5.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0de77d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0de74c8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0de74c8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0de74c77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm2h0i9t5                        0x00005583c9e2a4db <unavailable> + 5339

    5    libc.so.6                          0x00002b0de79bd460 __libc_start_main +
    245

    6    tmpm2h0i9t5                        0x00005583c9e2a0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for idx in 0 ..< s.count {\n      \
    \  if idx % 2 == 0 && s[idx].unicodeScalars.isUppercase {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2dcgkazv.swift:13:29: error: referencing subscript 'subscript(_:)'\
    \ on 'Collection' requires the types 'String.SubSequence' (aka 'Substring') and\
    \ 'Slice<String>' be equivalent\n        if idx % 2 == 0 && s[idx].unicodeScalars.isUppercase\
    \ {\n                            ^\nSwift.Collection:1:11: note: where 'Self.SubSequence'\
    \ = 'String.SubSequence' (aka 'Substring'), 'Slice<Self>' = 'Slice<String>'\n\
    extension Collection where Self.SubSequence == Slice<Self> {\n          ^\n/tmp/tmp2dcgkazv.swift:13:30:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Range<String.Index>'\n\
    \        if idx % 2 == 0 && s[idx].unicodeScalars.isUppercase {\n            \
    \                 ^\n/tmp/tmp2dcgkazv.swift:13:35: error: value of type 'Slice<String>'\
    \ has no member 'unicodeScalars'\n        if idx % 2 == 0 && s[idx].unicodeScalars.isUppercase\
    \ {\n                           ~~~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: -4
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    \n    // Your code here\n    \n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: Exception
  stderr: 'tmpjtmnb0ow/tmpjtmnb0ow.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4495153c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4494e4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4494e4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4494e497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjtmnb0ow                        0x0000563cd48fa264 <unavailable> + 4708

    5    libc.so.6                          0x00002b449533f460 __libc_start_main +
    245

    6    tmpjtmnb0ow                        0x0000563cd48f9ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = Int(0)\n    for i := 0; i < len(s); i +=\
    \ 2 {\n        if s[i] == 'A' || s[i] == 'a' {\n            result += Int(1)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2d7s6gy0.swift:12:12: error: expected type\n    for i := 0; i <\
    \ len(s); i += 2 {\n           ^\n            <#type#>\n/tmp/tmp2d7s6gy0.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(s); i +=\
    \ 2 {\n           ^\n/tmp/tmp2d7s6gy0.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(s); i += 2 {\n           ^\n/tmp/tmp2d7s6gy0.swift:13:20:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'a' {\n                   ^~~\n                   \"A\"\n/tmp/tmp2d7s6gy0.swift:13:35:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'a' {\n                                  ^~~\n                  \
    \                \"a\"\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    for i := 0; i < len(s); i += 2 {\n        if s[i] == 'A' || s[i] ==\
    \ 'a' {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_o4wd5vl.swift:15:12: error: expected type\n    for i := 0; i <\
    \ len(s); i += 2 {\n           ^\n            <#type#>\n/tmp/tmp_o4wd5vl.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(s); i +=\
    \ 2 {\n           ^\n/tmp/tmp_o4wd5vl.swift:15:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(s); i += 2 {\n           ^\n/tmp/tmp_o4wd5vl.swift:16:20:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'a' {\n                   ^~~\n                   \"A\"\n/tmp/tmp_o4wd5vl.swift:16:35:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'a' {\n                                  ^~~\n                  \
    \                \"a\"\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = 0..<len(s)\n    for index in 0..<len(s) {\n\
    \        var isUpper = false\n        switch s[index] {\n        case 'a':\n \
    \       case 'e':\n        case 'i':\n        case 'o':\n        case 'u':\n \
    \       case 'A':\n        case 'E':\n        case 'I':\n        case 'O':\n \
    \       case 'U':\n            isUpper = true\n        default:\n            isUpper\
    \ = false\n        }\n        if index&1 == 0 && !isUpper {\n            result[index]\
    \ = result[index] + 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp0a0bsh1a.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp0a0bsh1a.swift:15:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmp0a0bsh1a.swift:16:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmp0a0bsh1a.swift:16:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmp0a0bsh1a.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmp0a0bsh1a.swift:17:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmp0a0bsh1a.swift:18:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmp0a0bsh1a.swift:18:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmp0a0bsh1a.swift:19:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmp0a0bsh1a.swift:19:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'u':\n        ^~~~~~~~~\n                  break\n/tmp/tmp0a0bsh1a.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'A':\n   \
    \          ^~~\n             \"A\"\n/tmp/tmp0a0bsh1a.swift:20:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'A':\n        ^~~~~~~~~\n                  break\n/tmp/tmp0a0bsh1a.swift:21:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'E':\n   \
    \          ^~~\n             \"E\"\n/tmp/tmp0a0bsh1a.swift:21:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        "
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    \n    \n    let vowels = \"aeiou\"\n    \n    \n    \n\
    \    var count = 0\n    \n    \n    for index in 0..<s.count {\n        \n   \
    \     if s[index].isUpper() {\n            \n            \n            \n    \
    \        \n            if index%2==0 {\n                \n                \n \
    \               \n                for vowelIndex in 0..<vowels.count {\n     \
    \               \n                    \n                    \n               \
    \     if vowels[vowelIndex] == s[index] {\n                        \n        \
    \                \n                        count += 1\n                      \
    \  break\n                    }\n                    \n                }\n   \
    \             \n            }\n            \n            \n            \n    \
    \        else {\n                \n                \n                \n      \
    \          for vowelIndex in 0..<vowels.count {\n                    \n      \
    \              \n                    \n                    if vowels[vowelIndex]\
    \ == s[index] {\n                        \n                        \n        \
    \                count += 1\n                        break\n                 \
    \   }\n                    \n                }\n                \n           \
    \ }\n        }\n        \n        \n    }\n    \n    \n    \n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmplcjclfkl.swift:22:21: error: value of type 'Character' has no member\
    \ 'isUpper'\n        if s[index].isUpper() {\n           ~~~~~~~~ ^~~~~~~\n/tmp/tmplcjclfkl.swift:35:24:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                    if vowels[vowelIndex] == s[index]\
    \ {\n                       ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmplcjclfkl.swift:35:46: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                    if vowels[vowelIndex] == s[index] {\n                   \
    \                          ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmplcjclfkl.swift:56:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                    if vowels[vowelIndex] == s[index] {\n                   \
    \    ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmplcjclfkl.swift:56:46: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \           if vowels[vowelIndex] == s[index] {\n                            \
    \                 ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = 1\n    for i in 0..<s.count {\n        if\
    \ s[i] >= 'A' && s[i] <= 'Z' {\n            if s[i] == 'Z' || s[i] == 'z' {\n\
    \                result -= 1\n            }\n        } else if s[i] >= 'a' &&\
    \ s[i] <= 'z' {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmptuwhh_m3.swift:13:20: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i] >= 'A' && s[i] <= 'Z' {\n                   ^~~\n\
    \                   \"A\"\n/tmp/tmptuwhh_m3.swift:13:35: error: single-quoted\
    \ string literal found, use '\"'\n        if s[i] >= 'A' && s[i] <= 'Z' {\n  \
    \                                ^~~\n                                  \"Z\"\n\
    /tmp/tmptuwhh_m3.swift:14:24: error: single-quoted string literal found, use '\"\
    '\n            if s[i] == 'Z' || s[i] == 'z' {\n                       ^~~\n \
    \                      \"Z\"\n/tmp/tmptuwhh_m3.swift:14:39: error: single-quoted\
    \ string literal found, use '\"'\n            if s[i] == 'Z' || s[i] == 'z' {\n\
    \                                      ^~~\n                                 \
    \     \"z\"\n/tmp/tmptuwhh_m3.swift:17:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if s[i] >= 'a' && s[i] <= 'z' {\n          \
    \                ^~~\n                          \"a\"\n/tmp/tmptuwhh_m3.swift:17:42:\
    \ error: single-quoted string literal found, use '\"'\n        } else if s[i]\
    \ >= 'a' && s[i] <= 'z' {\n                                         ^~~\n    \
    \                                     \"z\"\n/tmp/tmptuwhh_m3.swift:13:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if s[i] >= 'A' && s[i] <= 'Z' {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptuwhh_m3.swift:13:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] >= 'A' && s[i] <= 'Z' {\n     \
    \                     ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmptuwhh_m3.swift:14:16: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if s[i] == 'Z' || s[i] == 'z' {\n               ^~~~\nS"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    vowels.iter() {\n        if s[$0] > 'Z' { vowels[$0] =\
    \ 0 }\n    }\n    var counter = 0\n    for c in s.chars() {\n        vowels[c]\
    \ &^= 1\n        vowels[c - 'A'] &^= 1\n        vowels[c - 'a'] &^= 1\n    }\n\
    \    vowels.iter() {\n        counter += 1 &^ 1\n    }\n    return counter\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpx2qc33l6.swift:12:20: error: single-quoted string literal found,\
    \ use '\"'\n        if s[$0] > 'Z' { vowels[$0] = 0 }\n                   ^~~\n\
    \                   \"Z\"\n/tmp/tmpx2qc33l6.swift:17:20: error: single-quoted\
    \ string literal found, use '\"'\n        vowels[c - 'A'] &^= 1\n            \
    \       ^~~\n                   \"A\"\n/tmp/tmpx2qc33l6.swift:18:20: error: single-quoted\
    \ string literal found, use '\"'\n        vowels[c - 'a'] &^= 1\n            \
    \       ^~~\n                   \"a\"\n/tmp/tmpx2qc33l6.swift:11:5: error: cannot\
    \ find 'vowels' in scope\n    vowels.iter() {\n    ^~~~~~\n/tmp/tmpx2qc33l6.swift:12:26:\
    \ error: cannot find 'vowels' in scope\n        if s[$0] > 'Z' { vowels[$0] =\
    \ 0 }\n                         ^~~~~~\n/tmp/tmpx2qc33l6.swift:15:16: error: value\
    \ of type 'String' has no member 'chars'\n    for c in s.chars() {\n         \
    \    ~ ^~~~~\n/tmp/tmpx2qc33l6.swift:20:5: error: cannot find 'vowels' in scope\n\
    \    vowels.iter() {\n    ^~~~~~\n/tmp/tmpx2qc33l6.swift:21:22: error: cannot\
    \ find operator '&^' in scope\n        counter += 1 &^ 1\n                   \
    \  ^~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var i = 0\n    for c in s {\n        if (c == 'A' || c\
    \ == 'a') {\n            i += 1\n        }\n    }\n    return i\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzaco2d1j.swift:13:18: error: single-quoted string literal found,\
    \ use '\"'\n        if (c == 'A' || c == 'a') {\n                 ^~~\n      \
    \           \"A\"\n/tmp/tmpzaco2d1j.swift:13:30: error: single-quoted string literal\
    \ found, use '\"'\n        if (c == 'A' || c == 'a') {\n                     \
    \        ^~~\n                             \"a\"\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count: Int = 0\n    for c in s {\n        guard c\
    \ >= 'A' && c <= 'Z' else {\n            continue\n        }\n        guard c\
    \ % 2 == 0 else {\n            continue\n        }\n        guard c <= 'E' else\
    \ {\n            continue\n        }\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmprakzcxd4.swift:13:20: error: single-quoted string literal found,\
    \ use '\"'\n        guard c >= 'A' && c <= 'Z' else {\n                   ^~~\n\
    \                   \"A\"\n/tmp/tmprakzcxd4.swift:13:32: error: single-quoted\
    \ string literal found, use '\"'\n        guard c >= 'A' && c <= 'Z' else {\n\
    \                               ^~~\n                               \"Z\"\n/tmp/tmprakzcxd4.swift:19:20:\
    \ error: single-quoted string literal found, use '\"'\n        guard c <= 'E'\
    \ else {\n                   ^~~\n                   \"E\"\n/tmp/tmprakzcxd4.swift:16:15:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \        guard c % 2 == 0 else {\n              ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for index in 0..<s.count {\n      \
    \  if s[index].unicodeScalars.isUppercase {\n            count += 1\n        \
    \    if index%2 == 0 {\n                count += 1\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_d6s2omb.swift:13:36: error: value of type 'Character.UnicodeScalarView'\
    \ (aka 'String.UnicodeScalarView') has no member 'isUppercase'\n        if s[index].unicodeScalars.isUppercase\
    \ {\n           ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return count(s, isVowel, isUpper, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyq8j__fm.swift:11:12: error: cannot find 'count' in scope\n   \
    \ return count(s, isVowel, isUpper, 0)\n           ^~~~~\n/tmp/tmpyq8j__fm.swift:11:21:\
    \ error: cannot find 'isVowel' in scope\n    return count(s, isVowel, isUpper,\
    \ 0)\n                    ^~~~~~~\n/tmp/tmpyq8j__fm.swift:11:30: error: cannot\
    \ find 'isUpper' in scope\n    return count(s, isVowel, isUpper, 0)\n        \
    \                     ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard\n        let index = s.index(after: s.startIndex,\
    \ offsetBy: 2)\n        else {\n            return 0\n    }\n    \n    let characters\
    \ = s.characters\n    \n    var count = 0\n    for (_, element) in characters.enumerated()\
    \ {\n        if CharacterSet.uppercaseLetters.contains(element) {\n          \
    \  count += 1\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2yuc5932.swift:12:23: error: no exact matches in call to instance\
    \ method 'index'\n        let index = s.index(after: s.startIndex, offsetBy: 2)\n\
    \                      ^\nSwift.String:9:17: note: incorrect labels for candidate\
    \ (have: '(after:offsetBy:)', expected: '(_:offsetBy:)')\n    public func index(_\
    \ i: String.Index, offsetBy distance: Int) -> String.Index\n                ^\n\
    Swift.Collection:6:28: note: incorrect labels for candidate (have: '(after:offsetBy:)',\
    \ expected: '(_:offsetBy:)')\n    @inlinable public func index(_ i: Self.Index,\
    \ offsetBy distance: Int) -> Self.Index\n                           ^\nSwift.BidirectionalCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(after:offsetBy:)', expected: '(_:offsetBy:)')\n\
    \    @inlinable public func index(_ i: Self.Index, offsetBy distance: Int) ->\
    \ Self.Index\n                           ^\n/tmp/tmp2yuc5932.swift:17:24: error:\
    \ 'characters' is unavailable: Please use String directly\n    let characters\
    \ = s.characters\n                       ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp2yuc5932.swift:21:12: error: cannot find\
    \ 'CharacterSet' in scope\n        if CharacterSet.uppercaseLetters.contains(element)\
    \ {\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for index, _ in\n        Zip2(self.s.characters.count,\
    \ s.characters.count, combine: +)\n            .enumerated() {\n        let isEvenIndex\
    \ = index % 2 == 0\n        let isUpper = self.s[index] == self.s[index].uppercased()\n\
    \        if isEvenIndex && isUpper {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpc_l4f_r3.swift:12:14: error: expected 'in' after for-each pattern\n\
    \    for index, _ in\n             ^\n/tmp/tmpc_l4f_r3.swift:12:14: error: expected\
    \ Sequence expression for for-each loop\n    for index, _ in\n             ^\n\
    /tmp/tmpc_l4f_r3.swift:16:23: error: cannot find 'self' in scope; did you mean\
    \ to use it in a type or extension context?\n        let isUpper = self.s[index]\
    \ == self.s[index].uppercased()\n                      ^~~~\n/tmp/tmpc_l4f_r3.swift:16:40:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n        let isUpper = self.s[index] == self.s[index].uppercased()\n\
    \                                       ^~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    func isUpper(x: String) -> Bool {\n        x.isUpper\n\
    \    }\n    return s.countWhere(isUpper)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp1d4ojkke.swift:12:11: error: value of type 'String' has no member\
    \ 'isUpper'\n        x.isUpper\n        ~ ^~~~~~~\n/tmp/tmp1d4ojkke.swift:14:14:\
    \ error: value of type 'String' has no member 'countWhere'\n    return s.countWhere(isUpper)\n\
    \           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tswitch {\n\tcase s == \"\": // 0 uppercase characters\n\t\
    \treturn 0\n\tcase s[startIndex] == 'Z':\n\t\treturn 0\n\tcase s[startIndex] ==\
    \ 'z':\n\t\treturn 0\n\tcase s[startIndex] == 'A':\n\t\treturn 1\n\tcase s[startIndex]\
    \ == 'a':\n\t\treturn 1\n\tdefault:\n\t\tswitch {\n\t\tcase s[startIndex] == 'B':\n\
    \t\t\treturn 1\n\t\tcase s[startIndex] == 'b':\n\t\t\treturn 1\n\t\tcase s[startIndex]\
    \ == 'C':\n\t\t\treturn 2\n\t\tcase s[startIndex] == 'c':\n\t\t\treturn 2\n\t\t\
    case s[startIndex] == 'D':\n\t\t\treturn 3\n\t\tcase s[startIndex] == 'd':\n\t\
    \t\treturn 3\n\t\tcase s[startIndex] == 'E':\n\t\t\treturn 4\n\t\tcase s[startIndex]\
    \ == 'e':\n\t\t\treturn 4\n\t\tcase s[startIndex] == 'F':\n\t\t\treturn 5\n\t\t\
    case s[startIndex] == 'f':\n\t\t\treturn 5\n\t\tcase s[startIndex] == 'G':\n\t\
    \t\treturn 6\n\t\tcase s[startIndex] == 'g':\n\t\t\treturn 6\n\t\tcase s[startIndex]\
    \ == 'H':\n\t\t\treturn 7\n\t\tcase s[startIndex] == 'h':\n\t\t\treturn 7\n\t\t\
    case s[startIndex] == 'I':\n\t\t\treturn 8\n\t\tcase s[startIndex] == 'i':\n\t\
    \t\treturn 8\n\t\tcase s[startIndex] == 'J':\n\t\t\treturn 9\n\t\tcase s[startIndex]\
    \ == 'j':\n\t\t\treturn 9\n\t\tcase s[startIndex] == 'K':\n\t\t\treturn 10\n\t\
    \tcase s[startIndex] == 'k':\n\t\t\treturn 10\n\t\tcase s[startIndex] == 'L':\n\
    \t\t\treturn 11\n\t\tcase s[startIndex] == 'l':\n\t\t\treturn 11\n\t\tcase s[startIndex]\
    \ == 'M':\n\t\t\treturn 12\n\t\tcase s[startIndex] == 'm':\n\t\t\treturn 12\n\t\
    \tcase s[startIndex] == 'N':\n\t\t\treturn 13\n\t\tcase s[startIndex] == 'n':\n\
    \t\t\treturn 13\n\t\tcase s[startIndex] == 'O':\n\t\t\treturn 14\n\t\tcase s[startIndex]\
    \ == 'o':\n\t\t\treturn 14\n\t\tcase s[startIndex] == 'P':\n\t\t\treturn 15\n\t\
    \tcase s[startIndex] == 'p':\n\t\t\treturn 15\n\t\tcase s[startIndex] == 'Q':\n\
    \t\t\treturn 16\n\t\tcase s[startIndex] == 'q':\n\t\t\treturn 16\n\t\tcase s[startIndex]\
    \ == 'R':\n\t\t\treturn 17\n\t\tcase s[startIndex] == 'r':\n\t\t\treturn 17\n\t\
    \tcase s[startIndex] == 'S':\n\t\t\treturn 18\n\t\tcase s[startIndex] == 's':\n\
    \t\t\treturn 18\n\t\tcase s[startIndex] == 'T':\n\t\t\treturn 19\n\t\tcase s[startIndex]\
    \ == 't':\n\t\t\treturn 19\n\t\tcase s[startIndex] == 'U':\n\t\t\treturn 20\n\t\
    \tcase s[startIndex] == 'u':\n\t\t\treturn 20\n\t\tcase \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_pm9gfbs.swift:11:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp_pm9gfbs.swift:14:24: error: single-quoted\
    \ string literal found, use '\"'\n        case s[startIndex] == 'Z':\n       \
    \                       ^~~\n                              \"Z\"\n/tmp/tmp_pm9gfbs.swift:16:24:\
    \ error: single-quoted string literal found, use '\"'\n        case s[startIndex]\
    \ == 'z':\n                              ^~~\n                              \"\
    z\"\n/tmp/tmp_pm9gfbs.swift:18:24: error: single-quoted string literal found,\
    \ use '\"'\n        case s[startIndex] == 'A':\n                             \
    \ ^~~\n                              \"A\"\n/tmp/tmp_pm9gfbs.swift:20:24: error:\
    \ single-quoted string literal found, use '\"'\n        case s[startIndex] ==\
    \ 'a':\n                              ^~~\n                              \"a\"\
    \n/tmp/tmp_pm9gfbs.swift:23:10: error: expected expression in 'switch' statement\n\
    \                switch {\n                       ^\n/tmp/tmp_pm9gfbs.swift:24:25:\
    \ error: single-quoted string literal found, use '\"'\n                case s[startIndex]\
    \ == 'B':\n                                      ^~~\n                       \
    \               \"B\"\n/tmp/tmp_pm9gfbs.swift:26:25: error: single-quoted string\
    \ literal found, use '\"'\n                case s[startIndex] == 'b':\n      \
    \                                ^~~\n                                      \"\
    b\"\n/tmp/tmp_pm9gfbs.swift:28:25: error: single-quoted string literal found,\
    \ use '\"'\n                case s[startIndex] == 'C':\n                     \
    \                 ^~~\n                                      \"C\"\n/tmp/tmp_pm9gfbs.swift:30:25:\
    \ error: single-quoted string literal found, use '\"'\n                case s[startIndex]\
    \ == 'c':\n                                      ^~~\n                       \
    \               \"c\"\n/tmp/tmp_pm9gfbs.swift:32:25: error: single-quoted string\
    \ literal found, use '\"'\n                case s[startIndex] == 'D':\n      \
    \                                ^~~\n                                      \"\
    D\"\n/tmp/tmp_pm9gfbs.swift:34:25: e"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tguard !s.isEmpty else { return 0 }\n\tlet chars = Array(s)\n\
    \tvar count = 0\n\tfor c in chars {\n\t\tguard c >= \"A\" && c <= \"Z\" else {\
    \ continue }\n\t\tcount += UInt32(c - \"A\") + 1\n\t}\n\treturn count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpi7pyud9r.swift:16:21: error: referencing operator function '-'\
    \ on 'SIMD' requires that 'Unicode.Scalar' conform to 'SIMD'\n               \
    \ count += UInt32(c - \"A\") + 1\n                                  ^\nSwift.SIMD:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension SIMD where Self.Scalar : FloatingPoint\
    \ {\n          ^\n/tmp/tmpi7pyud9r.swift:16:12: error: cannot convert value of\
    \ type 'UInt32' to expected argument type 'Int'\n                count += UInt32(c\
    \ - \"A\") + 1\n                         ^\n                         Int(    \
    \       )\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let len = s.length\n    let vowels = \"aeiouAEIOU\".utf8\n\
    \n    let vowelIndex = 0\n    var count = 0\n\n    for _ in 0..<len - 1 {\n  \
    \      let idx = s.unicodeScalars[vowelIndex].value - 'a'.value\n        let ch\
    \ = String(s.unicodeScalars[vowelIndex + 1].value)\n        if vowels[idx].contains(ch)\
    \ {\n            count += 1\n        }\n        vowelIndex += 2\n    }\n\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpac7gke6x.swift:18:56: error: single-quoted string literal found,\
    \ use '\"'\n        let idx = s.unicodeScalars[vowelIndex].value - 'a'.value\n\
    \                                                       ^~~\n                \
    \                                       \"a\"\n/tmp/tmpac7gke6x.swift:11:17: error:\
    \ value of type 'String' has no member 'length'\n    let len = s.length\n    \
    \          ~ ^~~~~~\n/tmp/tmpac7gke6x.swift:18:60: error: value of type 'String'\
    \ has no member 'value'\n        let idx = s.unicodeScalars[vowelIndex].value\
    \ - 'a'.value\n                                                       ~~~ ^~~~~\n\
    /tmp/tmpac7gke6x.swift:18:36: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.UnicodeScalarView.Index' (aka 'String.Index')\n      \
    \  let idx = s.unicodeScalars[vowelIndex].value - 'a'.value\n                \
    \                   ^\n/tmp/tmpac7gke6x.swift:19:53: error: cannot convert value\
    \ of type 'Int' to expected argument type 'String.UnicodeScalarView.Index' (aka\
    \ 'String.Index')\n        let ch = String(s.unicodeScalars[vowelIndex + 1].value)\n\
    \                                                    ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for i := 0; i < len(s); i++ {\n   \
    \     if s[i] == 'A' || s[i] == 'a' {\n            count += 1\n        } else\
    \ if s[i] == 'B' || s[i] == 'b' {\n            count += 1\n        } else if s[i]\
    \ == 'C' || s[i] == 'c' {\n            count += 1\n        } else if s[i] == 'D'\
    \ || s[i] == 'd' {\n            count += 1\n        } else if s[i] == 'E' || s[i]\
    \ == 'e' {\n            count += 1\n        } else if s[i] == 'F' || s[i] == 'f'\
    \ {\n            count += 1\n        } else if s[i] == 'G' || s[i] == 'g' {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpr5pg2bf6.swift:12:12: error: expected type\n    for i := 0; i <\
    \ len(s); i++ {\n           ^\n            <#type#>\n/tmp/tmpr5pg2bf6.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(s); i++\
    \ {\n           ^\n/tmp/tmpr5pg2bf6.swift:12:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(s); i++ {\n           ^\n/tmp/tmpr5pg2bf6.swift:13:20:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'a' {\n                   ^~~\n                   \"A\"\n/tmp/tmpr5pg2bf6.swift:13:35:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'A'\
    \ || s[i] == 'a' {\n                                  ^~~\n                  \
    \                \"a\"\n/tmp/tmpr5pg2bf6.swift:15:27: error: single-quoted string\
    \ literal found, use '\"'\n        } else if s[i] == 'B' || s[i] == 'b' {\n  \
    \                        ^~~\n                          \"B\"\n/tmp/tmpr5pg2bf6.swift:15:42:\
    \ error: single-quoted string literal found, use '\"'\n        } else if s[i]\
    \ == 'B' || s[i] == 'b' {\n                                         ^~~\n    \
    \                                     \"b\"\n/tmp/tmpr5pg2bf6.swift:17:27: error:\
    \ single-quoted string literal found, use '\"'\n        } else if s[i] == 'C'\
    \ || s[i] == 'c' {\n                          ^~~\n                          \"\
    C\"\n/tmp/tmpr5pg2bf6.swift:17:42: error: single-quoted string literal found,\
    \ use '\"'\n        } else if s[i] == 'C' || s[i] == 'c' {\n                 \
    \                        ^~~\n                                         \"c\"\n\
    /tmp/tmpr5pg2bf6.swift:19:27: error: single-quoted string literal found, use '\"\
    '\n        } else if s[i] == 'D' || s[i] == 'd' {\n                          ^~~\n\
    \                          \"D\"\n/tmp/tmpr5pg2bf6.swift:19:42: error: single-quoted\
    \ string literal found, use '\"'\n        } else if s[i] == 'D' || s[i] == 'd'\
    \ {\n                                         ^~~\n                          \
    \               \"d\"\n/tmp/tmpr5pg2bf6.swift:21:27: error: single-quoted string\
    \ literal found, use '\"'\n        } else"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n  return s.countUpTo(s.endIndex, inRange: 0..<s.utf16.count)/2\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyzdh43q9.swift:11:12: error: value of type 'String' has no member\
    \ 'countUpTo'\n  return s.countUpTo(s.endIndex, inRange: 0..<s.utf16.count)/2\n\
    \         ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = 0\n    for c in s.characters {\n        if\
    \ isUpper(c) && isEven(c - 'a') {\n            result += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxfdd1wme.swift:13:37: error: single-quoted string literal found,\
    \ use '\"'\n        if isUpper(c) && isEven(c - 'a') {\n                     \
    \               ^~~\n                                    \"a\"\n/tmp/tmpxfdd1wme.swift:12:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpxfdd1wme.swift:13:12: error: cannot find 'isUpper'\
    \ in scope\n        if isUpper(c) && isEven(c - 'a') {\n           ^~~~~~~\n/tmp/tmpxfdd1wme.swift:13:26:\
    \ error: cannot find 'isEven' in scope\n        if isUpper(c) && isEven(c - 'a')\
    \ {\n                         ^~~~~~\n/tmp/tmpxfdd1wme.swift:13:35: error: binary\
    \ operator '-' cannot be applied to operands of type 'Character' and 'String'\n\
    \        if isUpper(c) && isEven(c - 'a') {\n                                ~\
    \ ^ ~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.searchString(uppercaseVowels, options: .CaseInsensitive)\
    \ != nil ? s.distance(s.startIndex, to: s.startIndex.advanced(by: s.searchString(uppercaseVowels,\
    \ options: .CaseInsensitive)!)) : 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyo3xm4hn.swift:11:27: error: cannot find 'uppercaseVowels' in scope\n\
    \    return s.searchString(uppercaseVowels, options: .CaseInsensitive) != nil\
    \ ? s.distance(s.startIndex, to: s.startIndex.advanced(by: s.searchString(uppercaseVowels,\
    \ options: .CaseInsensitive)!)) : 0\n                          ^~~~~~~~~~~~~~~\n\
    /tmp/tmpyo3xm4hn.swift:11:150: error: cannot find 'uppercaseVowels' in scope\n\
    \    return s.searchString(uppercaseVowels, options: .CaseInsensitive) != nil\
    \ ? s.distance(s.startIndex, to: s.startIndex.advanced(by: s.searchString(uppercaseVowels,\
    \ options: .CaseInsensitive)!)) : 0\n                                        \
    \                                                                            \
    \                                 ^~~~~~~~~~~~~~~\n/tmp/tmpyo3xm4hn.swift:11:14:\
    \ error: value of type 'String' has no member 'searchString'\n    return s.searchString(uppercaseVowels,\
    \ options: .CaseInsensitive) != nil ? s.distance(s.startIndex, to: s.startIndex.advanced(by:\
    \ s.searchString(uppercaseVowels, options: .CaseInsensitive)!)) : 0\n        \
    \   ~ ^~~~~~~~~~~~\n/tmp/tmpyo3xm4hn.swift:11:54: error: cannot infer contextual\
    \ base in reference to member 'CaseInsensitive'\n    return s.searchString(uppercaseVowels,\
    \ options: .CaseInsensitive) != nil ? s.distance(s.startIndex, to: s.startIndex.advanced(by:\
    \ s.searchString(uppercaseVowels, options: .CaseInsensitive)!)) : 0\n        \
    \                                            ~^~~~~~~~~~~~~~~\n/tmp/tmpyo3xm4hn.swift:11:90:\
    \ error: missing argument label 'from:' in call\n    return s.searchString(uppercaseVowels,\
    \ options: .CaseInsensitive) != nil ? s.distance(s.startIndex, to: s.startIndex.advanced(by:\
    \ s.searchString(uppercaseVowels, options: .CaseInsensitive)!)) : 0\n        \
    \                                                                            \
    \     ^\n                                                                    \
    \                      from: \n/tmp/tmpyo3xm4hn.swift:11:122: error: value of\
    \ type 'String.Index' has no member 'advanced'\n    return s.searchString(uppercaseVowels"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s == \"\" {\n        return 0\n    }\n\n    var evenIndexes\
    \ = [Int]()\n    var total = 0\n\n    for i in 0..<s.count {\n        let index\
    \ = s[i] - 'a'\n        if index % 2 != 0 {\n            evenIndexes.append(index)\n\
    \        }\n    }\n\n    for i in 0..<evenIndexes.count {\n        total += Int(s[evenIndexes[i]])\
    \ - 'A' + 1\n    }\n\n    return total\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpemkas4k8.swift:19:28: error: single-quoted string literal found,\
    \ use '\"'\n        let index = s[i] - 'a'\n                           ^~~\n \
    \                          \"a\"\n/tmp/tmpemkas4k8.swift:26:43: error: single-quoted\
    \ string literal found, use '\"'\n        total += Int(s[evenIndexes[i]]) - 'A'\
    \ + 1\n                                          ^~~\n                       \
    \                   \"A\"\n/tmp/tmpemkas4k8.swift:19:26: error: binary operator\
    \ '-' cannot be applied to operands of type 'Character' and 'String'\n       \
    \ let index = s[i] - 'a'\n                    ~~~~ ^ ~~~\n/tmp/tmpemkas4k8.swift:26:9:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n        total\
    \ += Int(s[evenIndexes[i]]) - 'A' + 1\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978750
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tlet vowels = vowel_map.map[s].filter(isVowel).map(toLower)\n\
    \tlet evens = vowels.filter(isEven).count\n\treturn evens\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpa3kvfmya.swift:11:15: error: cannot find 'vowel_map' in scope\n\
    \        let vowels = vowel_map.map[s].filter(isVowel).map(toLower)\n        \
    \             ^~~~~~~~~\n/tmp/tmpa3kvfmya.swift:11:39: error: cannot find 'isVowel'\
    \ in scope\n        let vowels = vowel_map.map[s].filter(isVowel).map(toLower)\n\
    \                                             ^~~~~~~\n/tmp/tmpa3kvfmya.swift:11:52:\
    \ error: cannot find 'toLower' in scope\n        let vowels = vowel_map.map[s].filter(isVowel).map(toLower)\n\
    \                                                          ^~~~~~~\n/tmp/tmpa3kvfmya.swift:12:28:\
    \ error: cannot find 'isEven' in scope\n        let evens = vowels.filter(isEven).count\n\
    \                                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 1\n    for c in s {\n        if isUpper(c)\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpq3k0kw36.swift:13:12: error: cannot find 'isUpper' in scope\n \
    \       if isUpper(c) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.characters.reduce(0) { $0 + $1.isUppercase()\
    \ ? 1 : 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\"\
    ) == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvh_dl85f.swift:11:31: error: missing argument label 'into:' in\
    \ call\n    return s.characters.reduce(0) { $0 + $1.isUppercase() ? 1 : 0 }\n\
    \                              ^\n                               into: \n/tmp/tmpvh_dl85f.swift:11:25:\
    \ error: no 'reduce' candidates produce the expected contextual result type 'Int'\n\
    \    return s.characters.reduce(0) { $0 + $1.isUppercase() ? 1 : 0 }\n       \
    \                 ^\nSwift.Sequence:3:28: note: 'reduce(into:_:)' produces '(String,\
    \ _) -> Int', not the expected contextual result type 'Int'\n    @inlinable public\
    \ func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult:\
    \ (_ partialResult: inout Result, Self.Element) throws -> ()) rethrows -> Result\n\
    \                           ^\nSwift.Sequence:3:28: note: 'reduce(into:_:)' produces\
    \ '(Duration, _) -> Int', not the expected contextual result type 'Int'\n    @inlinable\
    \ public func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult:\
    \ (_ partialResult: inout Result, Self.Element) throws -> ()) rethrows -> Result\n\
    \                           ^\nSwift.Sequence:3:28: note: 'reduce(into:_:)' produces\
    \ '(Float16, _) -> Int', not the expected contextual result type 'Int'\n    @inlinable\
    \ public func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult:\
    \ (_ partialResult: inout Result, Self.Element) throws -> ()) rethrows -> Result\n\
    \                           ^\nSwift.Sequence:3:28: note: 'reduce(into:_:)' produces\
    \ '(Float, _) -> Int', not the expected contextual result type 'Int'\n    @inlinable\
    \ public func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult:\
    \ (_ partialResult: inout Result, Self.Element) throws -> ()) rethrows -> Result\n\
    \                           ^\nSwift.Sequence:3:28: note: 'reduce(into:_:)' produces\
    \ '(Double, _) -> Int', not the expected contextual result type 'Int'\n    @inlinable\
    \ public func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult:\
    \ (_ partialResult: inout Result, Self.Element) throws -> "
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    \n    let vowels = \"aeiouAEIOU\"\n    \n    let vowelCount\
    \ = s.characters.filter {\n        let c = $0\n        return vowels.contains(c)\n\
    \    }.count\n    \n    if vowelCount % 2 == 0 {\n        return 0\n    } else\
    \ {\n        return 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp07mijb_9.swift:14:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelCount = s.characters.filter {\n          \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for c in s.characters {\n        guard\
    \ isUpper(c) else {\n            continue // skip non-letters\n        }\n   \
    \     if isEven(c - 'a') {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\"\
    ) == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpebterl89.swift:16:23: error: single-quoted string literal found,\
    \ use '\"'\n        if isEven(c - 'a') {\n                      ^~~\n        \
    \              \"a\"\n/tmp/tmpebterl89.swift:12:16: error: 'characters' is unavailable:\
    \ Please use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpebterl89.swift:13:15:\
    \ error: cannot find 'isUpper' in scope\n        guard isUpper(c) else {\n   \
    \           ^~~~~~~\n/tmp/tmpebterl89.swift:16:12: error: cannot find 'isEven'\
    \ in scope\n        if isEven(c - 'a') {\n           ^~~~~~\n/tmp/tmpebterl89.swift:16:21:\
    \ error: binary operator '-' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if isEven(c - 'a') {\n                  ~ ^ ~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\treturn count_upper_indexed(s: s, startIndex: 0, endIndex:\
    \ s.count-1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpnsbiav1w.swift:11:9: error: cannot find 'count_upper_indexed' in\
    \ scope\n        return count_upper_indexed(s: s, startIndex: 0, endIndex: s.count-1)\n\
    \               ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard s.isEmpty == false else {\n        return 0\n  \
    \  }\n    var count = 0\n    \n    for i in 0..<s.characters.count {\n       \
    \ if s[i] == s[s.characters.count - 1] && s[i] == s.characters.first! {\n    \
    \        count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpbicgbbpw.swift:16:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<s.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpbicgbbpw.swift:17:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == s[s.characters.count - 1] &&\
    \ s[i] == s.characters.first! {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpbicgbbpw.swift:17:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == s[s.characters.count - 1] && s[i] == s.characters.first! {\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpbicgbbpw.swift:17:24: error: 'characters'\
    \ is unavailable: Please use String directly\n        if s[i] == s[s.characters.count\
    \ - 1] && s[i] == s.characters.first! {\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpbicgbbpw.swift:17:49: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == s[s.characters.count - 1] && s[i] == s.characters.first! {\n\
    \                                                ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpbicgbbpw.swift:17:59: error:\
    \ 'characters' is unavailable: Please use String directly\n        if s[i] ==\
    \ s[s.characters.count - 1] && s[i] == s.characters.first! {\n               \
    \                                           ^~~"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n  result := 0\n  for i := 0; i < len(s); i += 2 {\n    if\
    \ s[i] == 'A' || s[i] == 'a' {\n      result += s[i+1] != 'A' && s[i+1] != 'a'\n\
    \    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpg8vrpvwv.swift:11:9: error: consecutive statements on a line must\
    \ be separated by ';'\n  result := 0\n        ^\n        ;\n/tmp/tmpg8vrpvwv.swift:11:10:\
    \ error: expected expression\n  result := 0\n         ^\n/tmp/tmpg8vrpvwv.swift:12:10:\
    \ error: expected type\n  for i := 0; i < len(s); i += 2 {\n         ^\n     \
    \     <#type#>\n/tmp/tmpg8vrpvwv.swift:12:10: error: expected 'in' after for-each\
    \ pattern\n  for i := 0; i < len(s); i += 2 {\n         ^\n/tmp/tmpg8vrpvwv.swift:12:10:\
    \ error: expected Sequence expression for for-each loop\n  for i := 0; i < len(s);\
    \ i += 2 {\n         ^\n/tmp/tmpg8vrpvwv.swift:13:16: error: single-quoted string\
    \ literal found, use '\"'\n    if s[i] == 'A' || s[i] == 'a' {\n             \
    \  ^~~\n               \"A\"\n/tmp/tmpg8vrpvwv.swift:13:31: error: single-quoted\
    \ string literal found, use '\"'\n    if s[i] == 'A' || s[i] == 'a' {\n      \
    \                        ^~~\n                              \"a\"\n/tmp/tmpg8vrpvwv.swift:14:27:\
    \ error: single-quoted string literal found, use '\"'\n      result += s[i+1]\
    \ != 'A' && s[i+1] != 'a'\n                          ^~~\n                   \
    \       \"A\"\n/tmp/tmpg8vrpvwv.swift:14:44: error: single-quoted string literal\
    \ found, use '\"'\n      result += s[i+1] != 'A' && s[i+1] != 'a'\n          \
    \                                 ^~~\n                                      \
    \     \"a\"\n/tmp/tmpg8vrpvwv.swift:11:3: error: cannot find 'result' in scope\n\
    \  result := 0\n  ^~~~~~\n/tmp/tmpg8vrpvwv.swift:17:10: error: cannot find 'result'\
    \ in scope\n  return result\n         ^~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\t\n\tlet letterCount = s.characters.reduce(0) { (res, c)\
    \ in\n\t\t\n\t\tif let _ = c.unicodeScalars.filter({ $0.isUpperCase }).first {\n\
    \t\t\tres += 1\n\t\t}\n\t\t\n\t\treturn res\n\t}\n\t\n\treturn letterCount / 2\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2_8j06ri.swift:14:43: error: value of type 'Unicode.Scalar' has\
    \ no member 'isUpperCase'\n                if let _ = c.unicodeScalars.filter({\
    \ $0.isUpperCase }).first {\n                                                \
    \     ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard s.characters.count >= 1 else { return 0 }\n    var\
    \ count = 0\n    for index in stride(from: 0, to: s.characters.count, by: 2) {\n\
    \        guard s[index].isUppercase else { return count }\n        count += 1\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpt4xmoy1v.swift:11:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard s.characters.count >= 1 else { return 0 }\n \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpt4xmoy1v.swift:13:40: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in stride(from: 0, to: s.characters.count, by: 2) {\n\
    \                                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpt4xmoy1v.swift:14:15: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        guard\
    \ s[index].isUppercase else { return count }\n              ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\treturn count_upper_impl(s, s.utf16)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpy3b005as.swift:11:9: error: cannot find 'count_upper_impl' in scope\n\
    \        return count_upper_impl(s, s.utf16)\n               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper(s.utf8)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpx_hdmy79.swift:11:5: error: cannot find 'countUpper' in scope\n\
    \    countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper.countUpper(s.utf8)\n\
    \    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n  var count = 0\n  for index in 0..<s.characters.count {\n\
    \    if s[index].isUpper() && index % 2 == 0 {\n      count += 1\n    }\n  }\n\
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"\
    aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp6bpclpai.swift:12:22: error: 'characters' is unavailable: Please\
    \ use String directly\n  for index in 0..<s.characters.count {\n             \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6bpclpai.swift:13:17:\
    \ error: value of type 'Character' has no member 'isUpper'\n    if s[index].isUpper()\
    \ && index % 2 == 0 {\n       ~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for index in 0..<s.count {\n      \
    \  guard s[index].isUppercase else { continue }\n        if index%2 == 0 { count\
    \ += 1; continue }\n        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjmx66m8y.swift:13:15: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        guard s[index].isUppercase\
    \ else { continue }\n              ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: -4
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.filter { $0 <= \"z\" && $0 > \"a\" }.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: Exception
  stderr: 'tmpw7ldsgsb/tmpw7ldsgsb.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b763f803c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b763f4fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b763f4fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b763f4f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw7ldsgsb                        0x000055b3c4297554 <unavailable> + 5460

    5    libc.so.6                          0x00002b763f9ef460 __libc_start_main +
    245

    6    tmpw7ldsgsb                        0x000055b3c42971d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var count = 0\n    for idx in 0..<s.characters.count {\n\
    \        if idx % 2 == 0 { //even index\n            if let c = s.characters[idx]\
    \ as? Character where c.isUppercase {\n                count += 1\n          \
    \  }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") ==\
    \ 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\n\
    assert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s:\
    \ \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjwd54uz6.swift:14:56: error: expected ',' joining parts of a multi-clause\
    \ condition\n            if let c = s.characters[idx] as? Character where c.isUppercase\
    \ {\n                                                      ~^~~~~\n          \
    \                                            ,\n/tmp/tmpjwd54uz6.swift:12:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for idx\
    \ in 0..<s.characters.count {\n                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpjwd54uz6.swift:14:42: warning: conditional\
    \ cast from 'Character' to 'Character' always succeeds\n            if let c =\
    \ s.characters[idx] as? Character where c.isUppercase {\n                    \
    \                     ^\n/tmp/tmpjwd54uz6.swift:14:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if let c = s.characters[idx] as? Character where c.isUppercase {\n\
    \                       ^~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpjwd54uz6.swift:14:26: error: 'characters'\
    \ is unavailable: Please use String directly\n            if let c = s.characters[idx]\
    \ as? Character where c.isUppercase {\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var result = 0\n    for index, character in s.unicodeScalars.enumerated()\
    \ {\n        if character > 0xFF {\n            return -1\n        }\n       \
    \ if character <= 0x00 && character == 0x20 {\n            result++\n        }\n\
    \        if character <= 0x5F && character == 0x5F && !(index % 2 == 0) {\n  \
    \          result++\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmetxhco4.swift:12:14: error: expected 'in' after for-each pattern\n\
    \    for index, character in s.unicodeScalars.enumerated() {\n             ^\n\
    /tmp/tmpmetxhco4.swift:12:14: error: expected Sequence expression for for-each\
    \ loop\n    for index, character in s.unicodeScalars.enumerated() {\n        \
    \     ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var n = s.count\n    for i in 0 ..< n {\n        if s[i]\
    \ == s[i][0] {\n            n -= 1\n        }\n        if s[i] == s[i+1] && s[i]\
    \ != 'a' && s[i+1] != 'A' {\n            n -= 1\n        }\n        if s[i] ==\
    \ 'a' || s[i] == 'A' {\n            n -= 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp9lou5l62.swift:16:38: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i] == s[i+1] && s[i] != 'a' && s[i+1] != 'A' {\n    \
    \                                 ^~~\n                                     \"\
    a\"\n/tmp/tmp9lou5l62.swift:16:55: error: single-quoted string literal found,\
    \ use '\"'\n        if s[i] == s[i+1] && s[i] != 'a' && s[i+1] != 'A' {\n    \
    \                                                  ^~~\n                     \
    \                                 \"A\"\n/tmp/tmp9lou5l62.swift:19:20: error:\
    \ single-quoted string literal found, use '\"'\n        if s[i] == 'a' || s[i]\
    \ == 'A' {\n                   ^~~\n                   \"a\"\n/tmp/tmp9lou5l62.swift:19:35:\
    \ error: single-quoted string literal found, use '\"'\n        if s[i] == 'a'\
    \ || s[i] == 'A' {\n                                  ^~~\n                  \
    \                \"A\"\n/tmp/tmp9lou5l62.swift:13:21: error: subscript 'subscript(_:)'\
    \ requires that 'Int' conform to 'RangeExpression'\n        if s[i] == s[i][0]\
    \ {\n                    ^\nSwift.String:5:12: note: where 'R' = 'Int'\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmp9lou5l62.swift:16:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == s[i+1] && s[i] != 'a' && s[i+1] != 'A' {\n           ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9lou5l62.swift:16:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == s[i+1] && s[i] != 'a' && s[i+1]\
    \ != 'A' {\n                   ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp9lou5l62.swift:16:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == s[i+1] && s"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s.isEmpty {\n        return 0\n    }\n\n    var upperCount\
    \ = 0\n    var currentChar = s[0]\n    for c in s.dropFirst() {\n        if c\
    \ == currentChar {\n            upperCount += 1\n        } else {\n          \
    \  break\n        }\n        currentChar = c\n    }\n\n    return upperCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpjr0cb7gq.swift:16:23: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var currentChar\
    \ = s[0]\n                      ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tlet alphabet = UnicodeScalars.uppercase\n\tvar count = 0\n\
    \tvar i : Int = 0\n\tfor c in self.indices(s) {\n\t\tif c.unicodeScalars.contains(&alphabet)\
    \ {\n\t\t\tcount = count + 1\n\t\t}\n\t\ti = i + 1\n\t\tif i >= self.length {\n\
    \t\t\treturn count\n\t\t}\n\t}\n\treturn count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\"\
    ) == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") ==\
    \ 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\n\
    assert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpy33t92n7.swift:11:17: error: cannot find 'UnicodeScalars' in scope\n\
    \        let alphabet = UnicodeScalars.uppercase\n                       ^~~~~~~~~~~~~~\n\
    /tmp/tmpy33t92n7.swift:14:11: error: cannot find 'self' in scope; did you mean\
    \ to use it in a type or extension context?\n        for c in self.indices(s)\
    \ {\n                 ^~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return s.reduce(0) { acc, _ in\n        switch acc {\n\
    \        case 0:\n            return 1\n        case 1:\n            switch s.characters[Int(acc.2)]\
    \ {\n            case ('a', 'A'):\n                return 1\n            case\
    \ ('b', 'B'):\n                return 2\n            case ('c', 'C'):\n      \
    \          return 3\n            case ('d', 'D'):\n                return 4\n\
    \            case ('e', 'E'):\n                return 5\n            case ('f',\
    \ 'F'):\n                return 6\n            case ('g', 'G'):\n            \
    \    return 7\n            case ('h', 'H'):\n                return 8\n      \
    \      case ('i', 'I'):\n                return 9\n            case ('j', 'J'):\n\
    \                return 10\n            case ('k', 'K'):\n                return\
    \ 11\n            case ('l', 'L'):\n                return 12\n            case\
    \ ('m', 'M'):\n                return 13\n            case ('n', 'N'):\n     \
    \           return 14\n            case ('o', 'O'):\n                return 15\n\
    \            case ('p', 'P'):\n                return 16\n            case ('q',\
    \ 'Q'):\n                return 17\n            case ('r', 'R'):\n           \
    \     return 18\n            case ('s', 'S'):\n                return 19\n   \
    \         case ('t', 'T'):\n                return 20\n            case ('u',\
    \ 'U'):\n                return 21\n            case ('v', 'V'):\n           \
    \     return 22\n            case ('w', 'W'):\n                return 23\n   \
    \         case ('x', 'X'):\n                return 24\n            case ('y',\
    \ 'Y'):\n                return 25\n            case ('z', 'Z'):\n           \
    \     return 26\n            default:\n                return acc\n          \
    \  }\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpaprjw_k7.swift:17:19: error: single-quoted string literal found,\
    \ use '\"'\n            case ('a', 'A'):\n                  ^~~\n            \
    \      \"a\"\n/tmp/tmpaprjw_k7.swift:17:24: error: single-quoted string literal\
    \ found, use '\"'\n            case ('a', 'A'):\n                       ^~~\n\
    \                       \"A\"\n/tmp/tmpaprjw_k7.swift:19:19: error: single-quoted\
    \ string literal found, use '\"'\n            case ('b', 'B'):\n             \
    \     ^~~\n                  \"b\"\n/tmp/tmpaprjw_k7.swift:19:24: error: single-quoted\
    \ string literal found, use '\"'\n            case ('b', 'B'):\n             \
    \          ^~~\n                       \"B\"\n/tmp/tmpaprjw_k7.swift:21:19: error:\
    \ single-quoted string literal found, use '\"'\n            case ('c', 'C'):\n\
    \                  ^~~\n                  \"c\"\n/tmp/tmpaprjw_k7.swift:21:24:\
    \ error: single-quoted string literal found, use '\"'\n            case ('c',\
    \ 'C'):\n                       ^~~\n                       \"C\"\n/tmp/tmpaprjw_k7.swift:23:19:\
    \ error: single-quoted string literal found, use '\"'\n            case ('d',\
    \ 'D'):\n                  ^~~\n                  \"d\"\n/tmp/tmpaprjw_k7.swift:23:24:\
    \ error: single-quoted string literal found, use '\"'\n            case ('d',\
    \ 'D'):\n                       ^~~\n                       \"D\"\n/tmp/tmpaprjw_k7.swift:25:19:\
    \ error: single-quoted string literal found, use '\"'\n            case ('e',\
    \ 'E'):\n                  ^~~\n                  \"e\"\n/tmp/tmpaprjw_k7.swift:25:24:\
    \ error: single-quoted string literal found, use '\"'\n            case ('e',\
    \ 'E'):\n                       ^~~\n                       \"E\"\n/tmp/tmpaprjw_k7.swift:27:19:\
    \ error: single-quoted string literal found, use '\"'\n            case ('f',\
    \ 'F'):\n                  ^~~\n                  \"f\"\n/tmp/tmpaprjw_k7.swift:27:24:\
    \ error: single-quoted string literal found, use '\"'\n            case ('f',\
    \ 'F'):\n                       ^~~\n                       \"F\"\n/tmp/tmpaprjw_k7.swift:29:19:\
    \ error: single-quoted string literal found, use '\"'\n            case ('g',\
    \ 'G'):\n                  ^~~\n        "
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var i: Int = 0\n    for c in s.characters {\n        if\
    \ c.isUpper() && c.isOdd() {\n            i += 1\n        }\n    }\n    return\
    \ i\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") ==\
    \ 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp7vto6whv.swift:12:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp7vto6whv.swift:13:14:\
    \ error: value of type 'Character' has no member 'isUpper'\n        if c.isUpper()\
    \ && c.isOdd() {\n           ~ ^~~~~~~\n/tmp/tmp7vto6whv.swift:13:29: error: value\
    \ of type 'Character' has no member 'isOdd'\n        if c.isUpper() && c.isOdd()\
    \ {\n                          ~ ^~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    var i = 0\n    for c in s {\n        if c == 'A' || c\
    \ == 'a' {\n            i += 2\n        } else if c == 'E' || c == 'e' {\n   \
    \         i += 2\n        } else if c == 'I' || c == 'i' {\n            i += 1\n\
    \        } else if c == 'O' || c == 'o' {\n            i += 1\n        } else\
    \ if c == 'U' || c == 'u' {\n            i += 1\n        }\n    }\n    return\
    \ i\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") ==\
    \ 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\"\
    ) == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\n\
    assert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpm61vylby.swift:13:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == 'A' || c == 'a' {\n                ^~~\n         \
    \       \"A\"\n/tmp/tmpm61vylby.swift:13:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c == 'A' || c == 'a' {\n                       \
    \     ^~~\n                            \"a\"\n/tmp/tmpm61vylby.swift:15:24: error:\
    \ single-quoted string literal found, use '\"'\n        } else if c == 'E' ||\
    \ c == 'e' {\n                       ^~~\n                       \"E\"\n/tmp/tmpm61vylby.swift:15:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c ==\
    \ 'E' || c == 'e' {\n                                   ^~~\n                \
    \                   \"e\"\n/tmp/tmpm61vylby.swift:17:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c == 'I' || c == 'i' {\n \
    \                      ^~~\n                       \"I\"\n/tmp/tmpm61vylby.swift:17:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c ==\
    \ 'I' || c == 'i' {\n                                   ^~~\n                \
    \                   \"i\"\n/tmp/tmpm61vylby.swift:19:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c == 'O' || c == 'o' {\n \
    \                      ^~~\n                       \"O\"\n/tmp/tmpm61vylby.swift:19:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c ==\
    \ 'O' || c == 'o' {\n                                   ^~~\n                \
    \                   \"o\"\n/tmp/tmpm61vylby.swift:21:24: error: single-quoted\
    \ string literal found, use '\"'\n        } else if c == 'U' || c == 'u' {\n \
    \                      ^~~\n                       \"U\"\n/tmp/tmpm61vylby.swift:21:36:\
    \ error: single-quoted string literal found, use '\"'\n        } else if c ==\
    \ 'U' || c == 'u' {\n                                   ^~~\n                \
    \                   \"u\"\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    if s.isEmpty {\n        return 0\n    }\n    let mut upper\
    \ = 0\n    for &c in s.chars().filter(|&c| *c >= 'A' && *c <= 'Z') {\n       \
    \ *c -= 'A' as u8\n        if *c > 0 {\n            upper += 1\n        }\n  \
    \  }\n    return upper\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmphxaz_cjf.swift:14:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut upper =\
    \ 0\n            ^\n/tmp/tmphxaz_cjf.swift:14:13: note: join the identifiers together\n\
    \    let mut upper = 0\n        ~~~~^~~~~\n        mutupper\n/tmp/tmphxaz_cjf.swift:14:13:\
    \ note: join the identifiers together with camel-case\n    let mut upper = 0\n\
    \        ~~~~^~~~~\n        mutUpper\n/tmp/tmphxaz_cjf.swift:15:9: error: expected\
    \ pattern\n    for &c in s.chars().filter(|&c| *c >= 'A' && *c <= 'Z') {\n   \
    \     ^\n/tmp/tmphxaz_cjf.swift:15:12: error: expected '{' to start the body of\
    \ for-each loop\n    for &c in s.chars().filter(|&c| *c >= 'A' && *c <= 'Z') {\n\
    \           ^\n/tmp/tmphxaz_cjf.swift:15:43: error: single-quoted string literal\
    \ found, use '\"'\n    for &c in s.chars().filter(|&c| *c >= 'A' && *c <= 'Z')\
    \ {\n                                          ^~~\n                         \
    \                 \"A\"\n/tmp/tmphxaz_cjf.swift:15:56: error: single-quoted string\
    \ literal found, use '\"'\n    for &c in s.chars().filter(|&c| *c >= 'A' && *c\
    \ <= 'Z') {\n                                                       ^~~\n    \
    \                                                   \"Z\"\n/tmp/tmphxaz_cjf.swift:16:15:\
    \ error: single-quoted string literal found, use '\"'\n        *c -= 'A' as u8\n\
    \              ^~~\n              \"A\"\n/tmp/tmphxaz_cjf.swift:15:9: error: '&'\
    \ may only be used to pass an argument to inout parameter\n    for &c in s.chars().filter(|&c|\
    \ *c >= 'A' && *c <= 'Z') {\n        ^\n/tmp/tmphxaz_cjf.swift:21:12: error: cannot\
    \ find 'upper' in scope\n    return upper\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    let vowels = \"AEIOUaeiouAEIOU\"\n    let count1 = s.characters.count\n\
    \    let count2 = s.uppercased().characters.count\n    return count1 - count2\
    \ + vowels.characters.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_9r5w0mk.swift:12:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let count1 = s.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp_9r5w0mk.swift:13:33:\
    \ error: 'characters' is unavailable: Please use String directly\n    let count2\
    \ = s.uppercased().characters.count\n                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_9r5w0mk.swift:14:37:\
    \ error: 'characters' is unavailable: Please use String directly\n    return count1\
    \ - count2 + vowels.characters.count\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    return countSubstrings(s, upperCase, 2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_facarzz.swift:11:12: error: cannot find 'countSubstrings' in scope\n\
    \    return countSubstrings(s, upperCase, 2)\n           ^~~~~~~~~~~~~~~\n/tmp/tmp_facarzz.swift:11:31:\
    \ error: cannot find 'upperCase' in scope\n    return countSubstrings(s, upperCase,\
    \ 2)\n                              ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n    guard s.characters.count > 0 else {\n        return 0\n\
    \    }\n    var count = 0\n    for c in s.characters {\n        if c == c.uppercase\
    \ {\n            count += Int(c.isUppercase())\n        } else if !c.isUppercase()\
    \ {\n            return count\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s:\
    \ \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s:\
    \ \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\"\
    ) == 0)\nassert(count_upper(s: \"EEEE\") == 2)"
  status: SyntaxError
  stderr: "/tmp/tmposxz_iay.swift:11:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard s.characters.count > 0 else {\n            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmposxz_iay.swift:15:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmposxz_iay.swift:16:19: error: value of type 'Character'\
    \ has no member 'uppercase'\n        if c == c.uppercase {\n                ~\
    \ ^~~~~~~~~\n/tmp/tmposxz_iay.swift:17:28: error: cannot call value of non-function\
    \ type 'Bool'\n            count += Int(c.isUppercase())\n                   \
    \        ^          ~~\n                                      \n/tmp/tmposxz_iay.swift:18:22:\
    \ error: cannot call value of non-function type 'Bool'\n        } else if !c.isUppercase()\
    \ {\n                     ^          ~~\n                                \n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "\n/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(s: \"aBCdEf\")\n/// 1\n/// >>> count_upper(s:\
    \ \"abcdefg\")\n/// 0\n/// >>> count_upper(s: \"dBBE\")\n/// 0\nfunc count_upper(s:\
    \ String) -> Int {\n\tvar cnt : Int = 0\n\tfor i in s.indices {\n\t\tswitch s[i]\
    \ {\n\t\tcase 'A' : cnt++ ; break\n\t\tcase 'E' : cnt++ ; break\n\t\tcase 'I'\
    \ : cnt++ ; break\n\t\tcase 'O' : cnt++ ; break\n\t\tcase 'U' : cnt++ ; break\n\
    \t\t}\n\t}\n\treturn cnt\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s:\
    \ \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s:\
    \ \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"\
    U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\"\
    ) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp126f78rm.swift:14:8: error: single-quoted string literal found,\
    \ use '\"'\n                case 'A' : cnt++ ; break\n                     ^~~\n\
    \                     \"A\"\n/tmp/tmp126f78rm.swift:15:8: error: single-quoted\
    \ string literal found, use '\"'\n                case 'E' : cnt++ ; break\n \
    \                    ^~~\n                     \"E\"\n/tmp/tmp126f78rm.swift:16:8:\
    \ error: single-quoted string literal found, use '\"'\n                case 'I'\
    \ : cnt++ ; break\n                     ^~~\n                     \"I\"\n/tmp/tmp126f78rm.swift:17:8:\
    \ error: single-quoted string literal found, use '\"'\n                case 'O'\
    \ : cnt++ ; break\n                     ^~~\n                     \"O\"\n/tmp/tmp126f78rm.swift:18:8:\
    \ error: single-quoted string literal found, use '\"'\n                case 'U'\
    \ : cnt++ ; break\n                     ^~~\n                     \"U\"\n/tmp/tmp126f78rm.swift:14:17:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      case 'A' : cnt++ ; break\n                              ^~\n/tmp/tmp126f78rm.swift:15:17:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      case 'E' : cnt++ ; break\n                              ^~\n/tmp/tmp126f78rm.swift:16:17:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      case 'I' : cnt++ ; break\n                              ^~\n/tmp/tmp126f78rm.swift:17:17:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      case 'O' : cnt++ ; break\n                              ^~\n/tmp/tmp126f78rm.swift:18:17:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      case 'U' : cnt++ ; break\n                              ^~\n/tmp/tmp126f78rm.swift:13:3:\
    \ error: switch must be exhaustive\n                switch s[i] {\n          \
    \      ^\n/tmp/tmp126f78rm.swift:13:3: note: do you want to add a default clause?\n\
    \                switch s[i] {\n                ^\n"
  stdout: ''
  timestamp: 1659978732
