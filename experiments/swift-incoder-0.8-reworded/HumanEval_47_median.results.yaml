language: swift
name: HumanEval_47_median
results:
- exit_code: -4
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var l = l\n  l.sort()\n  return Double(l[(l.count\
    \ + 1) >> 1]) / Double(l.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: Exception
  stderr: 'tmpxevan2no/tmpxevan2no.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14ab3c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14ab0c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14ab0c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14ab0bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxevan2no                        0x00005586a83ca4f1 <unavailable> + 5361

    5    libc.so.6                          0x00002b14ab5b5460 __libc_start_main +
    245

    6    tmpxevan2no                        0x00005586a83ca139 <unavailable> + 4409

    '
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  return median(l, Double.NaN)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpko9_tqrt.swift:8:27: error: extra argument in call\n  return median(l,\
    \ Double.NaN)\n               ~~~~~~~~~~~^~~~\n/tmp/tmpko9_tqrt.swift:8:27: error:\
    \ type 'Double' has no member 'NaN'\n  return median(l, Double.NaN)\n        \
    \           ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tif l == nil {\n\t\treturn 0.0\n\t}\n\tvar\
    \ x = 0.0\n\tvar n = Double(len(l))\n\tfor x in l {\n\t\tn += 1.0 / Double(x)\n\
    \t}\n\treturn n / Double(len(l))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpn253_29c.swift:8:7: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns false\n        if l == nil {\n           ~ ^\
    \  ~~~\n/tmp/tmpn253_29c.swift:12:17: error: cannot find 'len' in scope\n    \
    \    var n = Double(len(l))\n                       ^~~\n/tmp/tmpn253_29c.swift:16:20:\
    \ error: cannot find 'len' in scope\n        return n / Double(len(l))\n     \
    \                     ^~~\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  return median(l: l, isSorted: false)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpf5g_jbim.swift:8:33: error: extra argument 'isSorted' in call\n\
    \  return median(l: l, isSorted: false)\n               ~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var lo = Double.max, hi = Double.min\n\
    \    for x in l {\n        if x < lo {\n            lo = x\n        } else if\
    \ x > hi {\n            hi = x\n        }\n    }\n    return (lo + hi) / 2\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpwyh073ol.swift:8:21: error: type 'Double' has no member 'max'\n\
    \    var lo = Double.max, hi = Double.min\n             ~~~~~~ ^~~\n/tmp/tmpwyh073ol.swift:8:38:\
    \ error: type 'Double' has no member 'min'\n    var lo = Double.max, hi = Double.min\n\
    \                              ~~~~~~ ^~~\n/tmp/tmpwyh073ol.swift:16:16: error:\
    \ cannot convert value of type 'String' to expected argument type 'Double'\n \
    \   return (lo + hi) / 2\n               ^\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: -4
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var sum = 0\n    for value in l {\n   \
    \     sum += value\n    }\n    return Double(sum) / Double(l.count)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: Exception
  stderr: 'tmp1w6m0_7t/tmp1w6m0_7t.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89cd421c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89cd118b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89cd118988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89cd1177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1w6m0_7t                        0x00005608803605cd <unavailable> + 5581

    5    libc.so.6                          0x00002b89cd60d460 __libc_start_main +
    245

    6    tmp1w6m0_7t                        0x0000560880360129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var m = 0\n  var n = l.count\n  var temp\
    \ = 0\n  for _ in 0..<n {\n    temp += l[m]\n    m = (m + 1) % n\n  }\n  return\
    \ temp / Double(n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp_p740oru.swift:15:10: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n  return temp / Double(n)\n         ^\n\
    \         Double( )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tsortedArray(l)\n\tcount := Int(l.count)\n\
    \tsortedCount := Int(l.sortedArray.count)\n\tif count == 0 {\n\t\treturn 0\n\t\
    }\n\n\tif sortedCount == 0 {\n\t\treturn l[0]\n\t}\n\n\treturn Double(l.sortedArray[count\
    \ / 2] + l.sortedArray[count / 2 - 1]) / 2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmppkrqgr0d.swift:9:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        count := Int(l.count)\n             ^\n       \
    \      ;\n/tmp/tmppkrqgr0d.swift:9:8: error: expected expression\n        count\
    \ := Int(l.count)\n              ^\n/tmp/tmppkrqgr0d.swift:8:2: error: cannot\
    \ find 'sortedArray' in scope\n        sortedArray(l)\n        ^~~~~~~~~~~\n/tmp/tmppkrqgr0d.swift:9:2:\
    \ error: cannot find 'count' in scope\n        count := Int(l.count)\n       \
    \ ^~~~~\n/tmp/tmppkrqgr0d.swift:11:5: error: cannot find 'count' in scope\n  \
    \      if count == 0 {\n           ^~~~~\n/tmp/tmppkrqgr0d.swift:15:5: error:\
    \ cannot find 'sortedCount' in scope\n        if sortedCount == 0 {\n        \
    \   ^~~~~~~~~~~\n/tmp/tmppkrqgr0d.swift:16:11: error: cannot convert return expression\
    \ of type 'Int' to return type 'Double'\n                return l[0]\n       \
    \                ~^~~\n                       Double( )\n/tmp/tmppkrqgr0d.swift:19:30:\
    \ error: cannot find 'count' in scope\n        return Double(l.sortedArray[count\
    \ / 2] + l.sortedArray[count / 2 - 1]) / 2\n                                 \
    \   ^~~~~\n/tmp/tmppkrqgr0d.swift:19:57: error: cannot find 'count' in scope\n\
    \        return Double(l.sortedArray[count / 2] + l.sortedArray[count / 2 - 1])\
    \ / 2\n                                                               ^~~~~\n\
    /tmp/tmppkrqgr0d.swift:19:9: error: the compiler is unable to type-check this\
    \ expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        return Double(l.sortedArray[count / 2] + l.sortedArray[count\
    \ / 2 - 1]) / 2\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978558
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    l.sort()\n    if l.length % 2 == 1 {\n\
    \        return l[l.length / 2]\n    } else {\n        return (l[l.length / 2]\
    \ + l[l.length / 2 - 1]) / 2\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpdqxe6zgl.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmpdqxe6zgl.swift:9:10:\
    \ error: value of type '[Int]' has no member 'length'\n    if l.length % 2 ==\
    \ 1 {\n       ~ ^~~~~~\n/tmp/tmpdqxe6zgl.swift:10:17: error: cannot convert return\
    \ expression of type 'Int' to return type 'Double'\n        return l[l.length\
    \ / 2]\n               ~^~~~~~~~~~~~~~\n               Double(        )\n/tmp/tmpdqxe6zgl.swift:10:20:\
    \ error: value of type '[Int]' has no member 'length'\n        return l[l.length\
    \ / 2]\n                 ~ ^~~~~~\n/tmp/tmpdqxe6zgl.swift:12:21: error: value\
    \ of type '[Int]' has no member 'length'\n        return (l[l.length / 2] + l[l.length\
    \ / 2 - 1]) / 2\n                  ~ ^~~~~~\n/tmp/tmpdqxe6zgl.swift:12:39: error:\
    \ value of type '[Int]' has no member 'length'\n        return (l[l.length / 2]\
    \ + l[l.length / 2 - 1]) / 2\n                                    ~ ^~~~~~\n/tmp/tmpdqxe6zgl.swift:12:56:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return (l[l.length / 2] + l[l.length / 2 - 1]) / 2\n               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n\
    \               Double(                                    )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let size = l.count\n    guard size != 0\
    \ else { return Double.infinity }\n    let mid = floor(size / 2)\n    return median2(l,\
    \ mid)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp5zb583wb.swift:10:15: error: cannot find 'floor' in scope\n   \
    \ let mid = floor(size / 2)\n              ^~~~~\n/tmp/tmp5zb583wb.swift:11:12:\
    \ error: cannot find 'median2' in scope\n    return median2(l, mid)\n        \
    \   ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l = l\n    if l == nil || l.count <\
    \ 2 {\n        return 0\n    }\n\n    var sorted = sortInPlace(r)\n    if sorted\
    \ == nil {\n        return 0\n    }\n\n    var middle = (sorted.count - 1) / 2\n\
    \    var l = sorted[middle]\n    var r = sorted[(middle + 1)]\n\n    if (r - l)\
    \ * 2 >= l {\n        return (l + r) / 2\n    }\n\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp_7y53wd2.swift:9:10: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns false\n    if l == nil || l.count < 2 {\n  \
    \     ~ ^  ~~~\n/tmp/tmp_7y53wd2.swift:13:18: error: cannot find 'sortInPlace'\
    \ in scope\n    var sorted = sortInPlace(r)\n                 ^~~~~~~~~~~\n/tmp/tmp_7y53wd2.swift:13:30:\
    \ error: use of local variable 'r' before its declaration\n    var sorted = sortInPlace(r)\n\
    \                             ^\n/tmp/tmp_7y53wd2.swift:20:9: note: 'r' declared\
    \ here\n    var r = sorted[(middle + 1)]\n        ^\n/tmp/tmp_7y53wd2.swift:23:19:\
    \ error: cannot convert value of type 'String' to expected argument type 'Double'\n\
    \        return (l + r) / 2\n                  ^\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.isEmpty { return 0.0 }\n\n    let\
    \ n = l.count\n    let middle = Double(l.count / 2)\n    let leftMedian = median(l.prefix(middle))\n\
    \    let rightMedian = median(l.suffix(middle))\n    let median = leftMedian +\
    \ rightMedian / 2.0\n\n    if n < 3.0 {\n        return l[n]\n    }\n\n    //\
    \ median = (left + right) / 2.0\n    return median\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp8_ts9ehw.swift:12:29: error: missing argument label 'l:' in call\n\
    \    let leftMedian = median(l.prefix(middle))\n                            ^\n\
    \                            l: \n/tmp/tmp8_ts9ehw.swift:12:38: error: missing\
    \ argument label 'while:' in call\n    let leftMedian = median(l.prefix(middle))\n\
    \                                     ^\n                                    \
    \ while: \n/tmp/tmp8_ts9ehw.swift:12:38: error: cannot convert value of type 'Double'\
    \ to expected argument type '(Int) throws -> Bool'\n    let leftMedian = median(l.prefix(middle))\n\
    \                                     ^\n/tmp/tmp8_ts9ehw.swift:13:30: error:\
    \ missing argument label 'l:' in call\n    let rightMedian = median(l.suffix(middle))\n\
    \                             ^\n                             l: \n/tmp/tmp8_ts9ehw.swift:13:39:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \    let rightMedian = median(l.suffix(middle))\n                            \
    \          ^\n                                      Int(  )\n/tmp/tmp8_ts9ehw.swift:16:10:\
    \ error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    if n < 3.0 {\n       ~ ^ ~~~\n/tmp/tmp8_ts9ehw.swift:16:10: note: overloads\
    \ for '<' exist with these partially matching parameter lists: (Int, Int)\n  \
    \  if n < 3.0 {\n         ^\n/tmp/tmp8_ts9ehw.swift:17:17: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n        return l[n]\n\
    \               ~^~~\n               Double( )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tif l == nil {\n\t\tthrow Abort(\"median of\
    \ empty list\")\n\t}\n\tif l.Len() == 0 {\n\t\tthrow Abort(\"median of empty list\"\
    )\n\t}\n\tvar l []Int\n\tl = append(l, l[0])\n\tsort.Sort(l)\n\tl.Sort()\n\tidx\
    \ := l.Len()/2\n\treturn l.At(idx)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpu8lhg5gs.swift:14:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        var l []Int\n             ^\n             ;\n/tmp/tmpu8lhg5gs.swift:14:10:\
    \ error: consecutive statements on a line must be separated by ';'\n        var\
    \ l []Int\n                ^\n                ;\n/tmp/tmpu8lhg5gs.swift:18:5:\
    \ error: consecutive statements on a line must be separated by ';'\n        idx\
    \ := l.Len()/2\n           ^\n           ;\n/tmp/tmpu8lhg5gs.swift:18:6: error:\
    \ expected expression\n        idx := l.Len()/2\n            ^\n/tmp/tmpu8lhg5gs.swift:8:7:\
    \ warning: comparing non-optional value of type '[Int]' to 'nil' always returns\
    \ false\n        if l == nil {\n           ~ ^  ~~~\n/tmp/tmpu8lhg5gs.swift:9:9:\
    \ error: cannot find 'Abort' in scope\n                throw Abort(\"median of\
    \ empty list\")\n                      ^~~~~\n/tmp/tmpu8lhg5gs.swift:11:7: error:\
    \ value of type '[Int]' has no member 'Len'\n        if l.Len() == 0 {\n     \
    \      ~ ^~~\n/tmp/tmpu8lhg5gs.swift:12:9: error: cannot find 'Abort' in scope\n\
    \                throw Abort(\"median of empty list\")\n                     \
    \ ^~~~~\n/tmp/tmpu8lhg5gs.swift:14:6: error: type annotation missing in pattern\n\
    \        var l []Int\n            ^\n/tmp/tmpu8lhg5gs.swift:14:8: error: empty\
    \ collection literal requires an explicit type\n        var l []Int\n        \
    \      ^~\n/tmp/tmpu8lhg5gs.swift:14:8: warning: expression of type '[Any]' is\
    \ unused\n        var l []Int\n              ^~\n/tmp/tmpu8lhg5gs.swift:14:10:\
    \ error: expected member name or constructor call after type name\n        var\
    \ l []Int\n                ^\n/tmp/tmpu8lhg5gs.swift:14:10: note: add arguments\
    \ after the type to construct a value of the type\n        var l []Int\n     \
    \           ^\n                   ()\n/tmp/tmpu8lhg5gs.swift:14:10: note: use\
    \ '.self' to reference the type object\n        var l []Int\n                ^\n\
    \                   .self\n/tmp/tmpu8lhg5gs.swift:14:10: warning: expression of\
    \ type 'Int.Type' is unused\n        var l []Int\n                ^~~\n/tmp/tmpu8lhg5gs.swift:15:6:\
    \ error: cannot find 'append' in"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var l = l as! [Int]\n  l.sortInPlace()\n\
    \  return l[(l.count - 1) / 2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpeo5ts7ox.swift:8:13: warning: forced cast of '[Int]' to same type\
    \ has no effect\n  var l = l as! [Int]\n            ^~~~~~~~~\n            \n\
    /tmp/tmpeo5ts7ox.swift:9:5: error: value of type '[Int]' has no member 'sortInPlace'\n\
    \  l.sortInPlace()\n  ~ ^~~~~~~~~~~\n/tmp/tmpeo5ts7ox.swift:10:11: error: cannot\
    \ convert return expression of type 'Int' to return type 'Double'\n  return l[(l.count\
    \ - 1) / 2]\n         ~^~~~~~~~~~~~~~~~~~~\n         Double(             )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    func medianRec(l: [Int]) -> Double {\n\
    \        let len = l.count\n        guard len > 1 else { return Double(l[0]) }\n\
    \        let mid = len / 2\n        let first = l[mid]\n        let second = l[len\
    \ - mid]\n        if second > first {\n            return medianRec(l[..mid])\n\
    \        } else {\n            return medianRec(l[mid..])\n        }\n    }\n\
    \    return medianRec(l)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpo24wggsw.swift:15:32: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n            return medianRec(l[..mid])\n              \
    \                 ^~\n                               ...\n/tmp/tmpo24wggsw.swift:15:30:\
    \ error: missing argument label 'l:' in call\n            return medianRec(l[..mid])\n\
    \                             ^\n                             l: \n/tmp/tmpo24wggsw.swift:17:35:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n           \
    \ return medianRec(l[mid..])\n                                  ^~\n         \
    \                         ...\n/tmp/tmpo24wggsw.swift:17:30: error: missing argument\
    \ label 'l:' in call\n            return medianRec(l[mid..])\n               \
    \              ^\n                             l: \n/tmp/tmpo24wggsw.swift:20:22:\
    \ error: missing argument label 'l:' in call\n    return medianRec(l)\n      \
    \               ^\n                     l: \n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var tmp Double = Double()\n    for i in\
    \ l {\n        tmp = i\n    }\n    return Double(tmp)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpcv_upnh8.swift:8:13: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n    var tmp Double =\
    \ Double()\n            ^\n/tmp/tmpcv_upnh8.swift:8:13: note: join the identifiers\
    \ together\n    var tmp Double = Double()\n        ~~~~^~~~~~\n        tmpDouble\n\
    /tmp/tmpcv_upnh8.swift:10:15: error: cannot assign value of type 'Int' to type\
    \ 'Double'\n        tmp = i\n              ^\n              Double( )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: -4
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var l = l\n  l.sort()\n  if l.count == 0\
    \ {\n    return 0\n  }\n  return Double(l.first!) / Double(l.count) * 100\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: Exception
  stderr: 'tmp4m5j9lqp/tmp4m5j9lqp.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f6449fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f64196b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f64196988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f641957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4m5j9lqp                        0x000056396f90b5d1 <unavailable> + 5585

    5    libc.so.6                          0x00002b7f6468b460 __libc_start_main +
    245

    6    tmp4m5j9lqp                        0x000056396f90b219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let a = l.sort()\n    return (Double(a[a.count\
    \ / 2]) + Double(a[a.count / 2 - 1])) / 2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmplrz3gn6a.swift:8:15: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    let a = l.sort()\n            ~ ^\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var n = (l[0] as Int) + Double(l.count)\
    \ / 2.0\n    var i = 1\n    while (i < l.count) {\n        n = n - l[i]\n    \
    \    i += 1\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpkk5f_mqs.swift:8:27: error: binary operator '+' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    var n = (l[0] as Int) + Double(l.count)\
    \ / 2.0\n            ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkk5f_mqs.swift:8:27:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    var n = (l[0] as Int) + Double(l.count) /\
    \ 2.0\n                          ^\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  l.sort()\n  if l.count > 1 {\n    return\
    \ (l[0] + l[l.count/2]) / Double(l.count/2)\n  }\n  return l[0]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpl4xt3xqb.swift:8:5: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n  l.sort()\n  ~ ^\n/tmp/tmpl4xt3xqb.swift:10:18:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \    return (l[0] + l[l.count/2]) / Double(l.count/2)\n                 ^\n  \
    \         Double(              )\n/tmp/tmpl4xt3xqb.swift:12:11: error: cannot\
    \ convert return expression of type 'Int' to return type 'Double'\n  return l[0]\n\
    \         ~^~~\n         Double( )\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var sorted: [Int] = l\n  sorted.sort()\n\
    \  if sorted.count == 0 || sorted.last == sorted.first {\n    return Double(0)\n\
    \  }\n  return sorted.last + Double(sorted.count - 1) / 2.0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp_5jk9egq.swift:13:17: error: cannot convert value of type 'Int?'\
    \ to expected argument type 'Double'\n  return sorted.last + Double(sorted.count\
    \ - 1) / 2.0\n                ^\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.count < 2 {\n        return Double(l[0])\n\
    \    }\n    let sorted = l.sorted()\n    let median = (sorted[(sorted.count /\
    \ 2) - 1] + sorted[(sorted.count / 2)])/2\n    return median\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpj1dotmfy.swift:13:12: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return median\n           ^~~~~~\n \
    \          Double( )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return median(l, 0, len(l) - 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpgykd7u35.swift:8:25: error: cannot find 'len' in scope\n    return\
    \ median(l, 0, len(l) - 1)\n                        ^~~\n/tmp/tmpgykd7u35.swift:8:18:\
    \ error: extra arguments at positions #2, #3 in call\n    return median(l, 0,\
    \ len(l) - 1)\n                 ^\n/tmp/tmpgykd7u35.swift:7:6: note: 'median(l:)'\
    \ declared here\nfunc median(l: [Int]) -> Double {\n     ^\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var nums = l\n    var numLen = nums.count\n\
    \    if numLen == 0 {\n        return 0\n    }\n    if numLen == 1 {\n       \
    \ return nums[0]\n    }\n    var numsSorted = nums.sorted()\n    let midIdx =\
    \ numLen / 2\n    return Double(numsSorted[midIdx])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmphlqnhcgv.swift:14:20: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return nums[0]\n               ~~~~^~~\n\
    \               Double()\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let n = countElements(l)\n    if n < 1\
    \ {\n        return Double.nan\n    }\n    let mid = n / 2\n    return (l as NSArray).valueForKeyPath(\"\
    @minIndex\").doubleValue +\n        (l as NSArray).valueForKeyPath(\"@maxIndex\"\
    ).doubleValue - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpilg0azrs.swift:8:13: error: cannot find 'countElements' in scope\n\
    \    let n = countElements(l)\n            ^~~~~~~~~~~~~\n/tmp/tmpilg0azrs.swift:13:18:\
    \ error: cannot find type 'NSArray' in scope\n    return (l as NSArray).valueForKeyPath(\"\
    @minIndex\").doubleValue +\n                 ^~~~~~~\n/tmp/tmpilg0azrs.swift:14:15:\
    \ error: cannot find type 'NSArray' in scope\n        (l as NSArray).valueForKeyPath(\"\
    @maxIndex\").doubleValue - 1\n              ^~~~~~~\n/tmp/tmpilg0azrs.swift:13:27:\
    \ error: value of type '[Int]' has no member 'valueForKeyPath'\n    return (l\
    \ as NSArray).valueForKeyPath(\"@minIndex\").doubleValue +\n           ~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~\n/tmp/tmpilg0azrs.swift:14:24: error: value of type '[Int]'\
    \ has no member 'valueForKeyPath'\n        (l as NSArray).valueForKeyPath(\"@maxIndex\"\
    ).doubleValue - 1\n        ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  return median(l, l.count())\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmprogb0llo.swift:8:22: error: cannot call value of non-function type\
    \ 'Int'\n  return median(l, l.count())\n                     ^    ~~\n       \
    \                   \n/tmp/tmprogb0llo.swift:8:22: error: extra argument in call\n\
    \  return median(l, l.count())\n               ~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return l.sorted()[l.sorted().count / 2]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpfjhbjgp7.swift:8:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return l.sorted()[l.sorted().count /\
    \ 2]\n           ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n           Double(        \
    \                 )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return Double(l.sorted { $0.isOdd && $1.isOdd\
    \ ? $0 < $1 : $0 > $1 }[l..<(l.count / 2)].count)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp5f1mfnrg.swift:8:33: error: value of type 'Int' has no member 'isOdd'\n\
    \    return Double(l.sorted { $0.isOdd && $1.isOdd ? $0 < $1 : $0 > $1 }[l..<(l.count\
    \ / 2)].count)\n                             ~~ ^~~~~\n/tmp/tmp5f1mfnrg.swift:8:45:\
    \ error: value of type 'Int' has no member 'isOdd'\n    return Double(l.sorted\
    \ { $0.isOdd && $1.isOdd ? $0 < $1 : $0 > $1 }[l..<(l.count / 2)].count)\n   \
    \                                      ~~ ^~~~~\n/tmp/tmp5f1mfnrg.swift:8:73:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    return Double(l.sorted { $0.isOdd && $1.isOdd ? $0 < $1 : $0 > $1 }[l..<(l.count\
    \ / 2)].count)\n                                                             \
    \           ^\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    l.sort()\n    var mid: Int\n    if l.count\
    \ <= 1 {\n        return l[0]\n    }\n    if l.count % 2 == 0 {\n        mid =\
    \ l.count / 2\n        return l[mid]\n    } else {\n        mid = (l.count - 1)\
    \ / 2\n        if l[mid] < 0 {\n            mid--\n        }\n        return l[mid]\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpmpufuvpy.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmpmpufuvpy.swift:11:17:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return l[0]\n               ~^~~\n               Double( )\n/tmp/tmpmpufuvpy.swift:15:17:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return l[mid]\n               ~^~~~~\n               Double( )\n/tmp/tmpmpufuvpy.swift:19:16:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  mid--\n               ^~\n/tmp/tmpmpufuvpy.swift:21:17: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n        return l[mid]\n\
    \               ~^~~~~\n               Double( )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  switch l.count {\n  case 0:\n    return 0\n\
    \  case 1:\n    return l[0]\n  case 2:\n    return (l[0] + l[1]) / 2.0\n  default:\n\
    \    switch l.count / 2 {\n    case 0: return l[0]\n    case 1: return l[1]\n\
    \    default:\n      var high, low: Int\n      switch l.count {\n      case 2:\
    \ return (l[0] + l[1]) / 2\n      case 3: return (l[0] + l[1] + l[2]) / 3.0\n\
    \      case 4: return (l[0] + l[1] + l[2] + l[3]) / 4.0\n      case 5: return\
    \ (l[0] + l[1] + l[2] + l[3] + l[4]) / 5.0\n      case 6: return (l[0] + l[1]\
    \ + l[2] + l[3] + l[4] + l[5]) / 6.0\n      case 7: return (l[0] + l[1] + l[2]\
    \ + l[3] + l[4] + l[5] + l[6]) / 7.0\n      case 8: return (l[0] + l[1] + l[2]\
    \ + l[3] + l[4] + l[5] + l[6] + l[7]) / 8.0\n      case 9: return (l[0] + l[1]\
    \ + l[2] + l[3] + l[4] + l[5] + l[6] + l[7] + l[8]) / 9.0\n      case 10: return\
    \ (l[0] + l[1] + l[2] + l[3] + l[4] + l[5] + l[6] + l[7] + l[8] + l[9]) / 10.0\n\
    \      default:\n        high = l[0]\n        low = l[0]\n        for v in l[1..]\
    \ {\n          if high < v {\n            high = v\n          }\n          if\
    \ low > v {\n            low = v\n          }\n        }\n        return (high\
    \ + low) / 2.0\n      }\n    }\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpx2yv9mvu.swift:12:13: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return l[0]\n           ~^~~\n     \
    \      Double( )\n/tmp/tmpx2yv9mvu.swift:14:18: error: cannot convert value of\
    \ type 'Int' to expected argument type 'Double'\n    return (l[0] + l[1]) / 2.0\n\
    \                 ^\n           Double(      )\n/tmp/tmpx2yv9mvu.swift:17:21:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \    case 0: return l[0]\n                   ~^~~\n                   Double(\
    \ )\n/tmp/tmpx2yv9mvu.swift:18:21: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    case 1: return l[1]\n              \
    \     ~^~~\n                   Double( )\n/tmp/tmpx2yv9mvu.swift:22:36: error:\
    \ cannot convert return expression of type 'Int' to return type 'Double'\n   \
    \   case 2: return (l[0] + l[1]) / 2\n                     ~~~~~~~~~~~~~~^~~\n\
    \                     Double(          )\n/tmp/tmpx2yv9mvu.swift:23:35: error:\
    \ cannot convert value of type 'Int' to expected argument type 'Double'\n    \
    \  case 3: return (l[0] + l[1] + l[2]) / 3.0\n                               \
    \   ^\n                     Double(             )\n/tmp/tmpx2yv9mvu.swift:24:42:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \      case 4: return (l[0] + l[1] + l[2] + l[3]) / 4.0\n                    \
    \                     ^\n                     Double(                    )\n/tmp/tmpx2yv9mvu.swift:25:22:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n      case 5:\
    \ return (l[0] + l[1] + l[2] + l[3] + l[4]) / 5.0\n                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpx2yv9mvu.swift:26:22: error: the compiler is unable to type-check this\
    \ expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n      case 6: return (l[0] + l[1] + l[2] + l[3] + l[4] + l[5])\
    \ / 6.0\n                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpx2yv9mv"
  stdout: ''
  timestamp: 1659978669
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    assert(l.count > 0, \"Median requires at\
    \ least one element\")\n    var m = Double(0)\n    for v in l {\n        m = v\
    \ < m ? v : m\n    }\n    return m / Double(l.count)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpvvl6j5qv.swift:11:17: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        m = v < m ? v : m\n               \
    \ ^\n                Int( )\n/tmp/tmpvvl6j5qv.swift:11:21: error: result values\
    \ in '? :' expression have mismatching types 'Int' and 'Double'\n        m = v\
    \ < m ? v : m\n                    ^\n                    Double( )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let count = l.count\n    guard count >\
    \ 0 else {\n        return 0\n    }\n    guard count <= 100 else {\n        return\
    \ 0\n    }\n    guard count <= 1000000 else {\n        return 0\n    }\n    var\
    \ largest = l.max()\n    var smallest = l.min()\n    var midpoint: Double = 0\n\
    \    if count > 1 {\n        midpoint = Double((largest + smallest) / 2)\n   \
    \ }\n    return midpoint\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp0z1pxlzr.swift:22:36: error: binary operator '+' cannot be applied\
    \ to two 'Int?' operands\n        midpoint = Double((largest + smallest) / 2)\n\
    \                           ~~~~~~~ ^ ~~~~~~~~\n/tmp/tmp0z1pxlzr.swift:22:36:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        midpoint = Double((largest + smallest) / 2)\n          \
    \                         ^\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  return median(l, Double(l.count), Double(l.count)\
    \ / 2, Double(l.count) / 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpt_49fj59.swift:8:16: error: extra arguments at positions #2, #3,\
    \ #4 in call\n  return median(l, Double(l.count), Double(l.count) / 2, Double(l.count)\
    \ / 2)\n               ^\n/tmp/tmpt_49fj59.swift:7:6: note: 'median(l:)' declared\
    \ here\nfunc median(l: [Int]) -> Double {\n     ^\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l == nil || len(l) == 0 {\n        return\
    \ 0\n    }\n    sort(l)\n    return l[len(l)-1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpmb2n20m2.swift:8:20: error: cannot find 'len' in scope\n    if\
    \ l == nil || len(l) == 0 {\n                   ^~~\n/tmp/tmpmb2n20m2.swift:11:5:\
    \ error: cannot find 'sort' in scope\n    sort(l)\n    ^~~~\n/tmp/tmpmb2n20m2.swift:12:14:\
    \ error: cannot find 'len' in scope\n    return l[len(l)-1]\n             ^~~\n\
    /tmp/tmpmb2n20m2.swift:12:13: error: cannot convert return expression of type\
    \ 'Int' to return type 'Double'\n    return l[len(l)-1]\n           ~^~~~~~~~~~\n\
    \           Double(    )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var result = 0.0\n    let n = l.count\n\
    \    for i in 0..<n {\n        let x = l[i]\n        result = result + x\n   \
    \ }\n    result = result / Double(n)\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp1venrkd1.swift:12:27: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n        result = result + x\n          \
    \                ^\n                          Double( )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let sortedArray = Array(l)\n    if sortedArray.count\
    \ % 2 == 0 {\n        let median = (sortedArray[sortedArray.count/2-1] + sortedArray[sortedArray.count/2+1])\
    \ / 2.0\n        return median\n    } else {\n        return sortedArray[sortedArray.count/2-1]\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpq17who3t.swift:10:96: error: binary operator '/' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n        let median = (sortedArray[sortedArray.count/2-1]\
    \ + sortedArray[sortedArray.count/2+1]) / 2.0\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~\n/tmp/tmpq17who3t.swift:10:96: note: overloads for '/' exist with these\
    \ partially matching parameter lists: (Double, Double), (Duration, Double), (Int,\
    \ Int)\n        let median = (sortedArray[sortedArray.count/2-1] + sortedArray[sortedArray.count/2+1])\
    \ / 2.0\n                                                                    \
    \                           ^\n/tmp/tmpq17who3t.swift:13:27: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n        return sortedArray[sortedArray.count/2-1]\n\
    \               ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n               Double(   \
    \                        )\n"
  stdout: ''
  timestamp: 1659978546
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  let n = Double(l.count)\n  if n % 2 == 1\
    \ {\n    l.sort{$0 > $1}\n  }\n  return l[(l.count - 1) / 2]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpmym48tvj.swift:9:8: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n  if n % 2 == 1 {\n       ^\nSwift.%:2:13:\
    \ note: '%' has been explicitly marked unavailable here\npublic func % <T>(lhs:\
    \ T, rhs: T) -> T where T : BinaryFloatingPoint\n            ^\n/tmp/tmpmym48tvj.swift:10:7:\
    \ error: cannot use mutating member on immutable value: 'l' is a 'let' constant\n\
    \    l.sort{$0 > $1}\n    ~ ^\n/tmp/tmpmym48tvj.swift:12:11: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n  return l[(l.count\
    \ - 1) / 2]\n         ~^~~~~~~~~~~~~~~~~~~\n         Double(             )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return sorted(l).median\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpp6gp1bgs.swift:8:12: error: cannot find 'sorted' in scope\n   \
    \ return sorted(l).median\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var sortedL = l as! [Int]\n  sortedL.sort()\n\
    \  if sortedL.count < 2 {\n    return 0\n  }\n  return sortedL[(sortedL.count\
    \ - 1)/2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpgh_7bg8y.swift:8:19: warning: forced cast of '[Int]' to same type\
    \ has no effect\n  var sortedL = l as! [Int]\n                  ^~~~~~~~~\n  \
    \                \n/tmp/tmpgh_7bg8y.swift:13:17: error: cannot convert return\
    \ expression of type 'Int' to return type 'Double'\n  return sortedL[(sortedL.count\
    \ - 1)/2]\n         ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n         Double(         \
    \              )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    l.sort()\n    return (l.count / 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp2tqu2k17.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmp2tqu2k17.swift:9:21:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \    return (l.count / 2)\n           ~~~~~~~~~^~~~\n           Double(      )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var lo = l.sort()\n  if lo.count < 2 {\n\
    \    return 0\n  }\n  lo.removeLast()\n  lo.removeLast()\n  lo.removeLast()\n\
    \  lo.removeLast()\n  return Double(lo.last!) / 2\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpmvp37o43.swift:8:14: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n  var lo = l.sort()\n           ~ ^\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    switch l.count {\n    case 0:\n       \
    \ return Double(0)\n    case 1 :\n        return l[0]\n    case 2 :\n        return\
    \ 0.5 * (l[0] + l[1])\n    case 3 :\n        return 0.75 * (l[0] + l[1] + l[2])\n\
    \    default :\n        return Double((l[0] + l[1] + l[2])/2.0)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpsdf9fd_w.swift:12:17: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l[0]\n               ~^~~\n\
    \               Double( )\n/tmp/tmpsdf9fd_w.swift:14:28: error: cannot convert\
    \ value of type 'Int' to expected argument type 'Double'\n        return 0.5 *\
    \ (l[0] + l[1])\n                           ^\n                     Double(  \
    \    )\n/tmp/tmpsdf9fd_w.swift:16:36: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n        return 0.75 * (l[0] + l[1] + l[2])\n\
    \                                   ^\n                      Double(         \
    \    )\n/tmp/tmpsdf9fd_w.swift:18:43: error: binary operator '/' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n        return Double((l[0] + l[1] +\
    \ l[2])/2.0)\n                      ~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmpsdf9fd_w.swift:18:43:\
    \ note: overloads for '/' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n        return Double((l[0] + l[1] + l[2])/2.0)\n\
    \                                          ^\n"
  stdout: ''
  timestamp: 1659978545
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var m = Double(0)\n    var r = Double(0)\n\
    \    for v in l {\n        m = (v + r) / 2\n        if (r < 0 || m > r) r = m\n\
    \    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmplzrx4cq4.swift:12:29: error: expected '{' after 'if' condition\n\
    \        if (r < 0 || m > r) r = m\n                            ^\n/tmp/tmplzrx4cq4.swift:11:14:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \        m = (v + r) / 2\n             ^\n             Double( )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var min = Double(l.count)\n  var max = Double(l.count)\n\
    \  for i, v := range l {\n    if v < min {\n      min = v\n    } else if v > max\
    \ {\n      max = v\n    }\n  }\n  if min == max {\n    return min\n  }\n  return\
    \ Double(l.count) / Double(l.count) + min / Double(l.count) + max / Double(l.count)\
    \ / 2.0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp_hgh9ta3.swift:10:8: error: expected 'in' after for-each pattern\n\
    \  for i, v := range l {\n       ^\n/tmp/tmp_hgh9ta3.swift:10:8: error: expected\
    \ Sequence expression for for-each loop\n  for i, v := range l {\n       ^\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    switch l.count {\n    case 0: return Double(0)\n\
    \    case 1: return l[0]\n    case 2: return (l[0] + l[1]) / 2\n    default:\n\
    \        var left = 0\n        var right = l.count - 1\n        var mid = (left\
    \ + right) / 2\n        guard left < right else { return Double(0) }\n       \
    \ guard mid != right else { return Double(0) }\n        while left < right {\n\
    \            guard l[mid] < l[right] else { right = mid }\n            guard mid\
    \ != left else { left = mid }\n            mid = (left + right) / 2\n        }\n\
    \        return l[mid]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpqa7wj912.swift:10:21: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    case 1: return l[0]\n              \
    \     ~^~~\n                   Double( )\n/tmp/tmpqa7wj912.swift:11:34: error:\
    \ cannot convert return expression of type 'Int' to return type 'Double'\n   \
    \ case 2: return (l[0] + l[1]) / 2\n                   ~~~~~~~~~~~~~~^~~\n   \
    \                Double(          )\n/tmp/tmpqa7wj912.swift:23:17: error: cannot\
    \ convert return expression of type 'Int' to return type 'Double'\n        return\
    \ l[mid]\n               ~^~~~~\n               Double( )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    // Compute mean of sorted elements.\n \
    \   var sum: Double = 0\n    var count: Int = 0\n    for element in l {\n    \
    \    sum += element\n        count += 1\n    }\n\n    // Compute median.\n   \
    \ var median: Double\n    if count < 2 {\n        median = sum / Double(count)\n\
    \    } else {\n        median = sum / Double(count - 1)\n    }\n\n    // Return\
    \ the median value.\n    return median\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpj_52vn7_.swift:12:16: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n        sum += element\n               ^\n\
    \               Double()\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let sortArray = Array(l)\n    let sortedCount\
    \ = sortArray.count\n    let halfCount = Int(ceil(Double(sortedCount) / 2.0))\n\
    \    let sortedHalfCount = Int(ceil(halfCount / 2.0))\n\n    // Swap last and\
    \ first elements.\n    if sortedHalfCount > 0 {\n        let temp = sortArray[sortedHalfCount\
    \ - 1]\n        sortArray[sortedHalfCount - 1] = sortArray[0]\n        sortArray[0]\
    \ = temp\n    }\n\n    let sortedArray = sortArray[0..<sortedHalfCount]\n\n  \
    \  return sortedArray.sortedLast(by: {$0 > $1}).reduce(0.0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp25_958m1.swift:10:25: error: cannot find 'ceil' in scope\n    let\
    \ halfCount = Int(ceil(Double(sortedCount) / 2.0))\n                        ^~~~\n\
    /tmp/tmp25_958m1.swift:11:31: error: cannot find 'ceil' in scope\n    let sortedHalfCount\
    \ = Int(ceil(halfCount / 2.0))\n                              ^~~~\n/tmp/tmp25_958m1.swift:17:18:\
    \ error: cannot assign through subscript: 'sortArray' is a 'let' constant\n  \
    \      sortArray[0] = temp\n        ~~~~~~~~~^\n/tmp/tmp25_958m1.swift:8:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let sortArray = Array(l)\n   \
    \ ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  if l.isEmpty() {\n    return Double.nan\n\
    \  }\n  let l = l.sorted(by: >)\n  let middle = Double(l.count)\n  var left: [Int]\
    \ = []\n  var right: [Int] = []\n  for i in 0..<middle {\n    if i < middle /\
    \ 2 {\n      left.append(l[i])\n    } else {\n      right.append(l[i])\n    }\n\
    \  }\n  if right == nil && middle == 1 {\n    return left[0]\n  } else if right\
    \ == nil {\n    return right[0]\n  } else if left == nil {\n    return left[0]\n\
    \  }\n  return (right[0] + left[0]) / 2\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpcxo1x5aa.swift:8:8: error: cannot call value of non-function type\
    \ 'Bool'\n  if l.isEmpty() {\n       ^      ~~\n              \n/tmp/tmpcxo1x5aa.swift:15:13:\
    \ error: protocol 'Sequence' requires that 'Double' conform to 'SignedInteger'\n\
    \  for i in 0..<middle {\n            ^\nSwift.Range:1:11: note: requirement from\
    \ conditional conformance of 'Range<Double>' to 'Sequence'\nextension Range :\
    \ Sequence where Bound : Strideable, Bound.Stride : SignedInteger {\n        \
    \  ^\n/tmp/tmpcxo1x5aa.swift:15:13: error: referencing instance method 'makeIterator()'\
    \ on 'Range' requires that 'Double' conform to 'SignedInteger'\n  for i in 0..<middle\
    \ {\n            ^\nSwift.Range:1:11: note: requirement from conditional conformance\
    \ of 'Range<Double>' to 'Collection'\nextension Range : Collection, BidirectionalCollection,\
    \ RandomAccessCollection where Bound : Strideable, Bound.Stride : SignedInteger\
    \ {\n          ^\n<unknown>:0: error: referencing instance method 'next()' on\
    \ 'Range' requires that 'Double' conform to 'SignedInteger'\nSwift.Range:1:11:\
    \ note: requirement from conditional conformance of 'Range<Double>' to 'Collection'\n\
    extension Range : Collection, BidirectionalCollection, RandomAccessCollection\
    \ where Bound : Strideable, Bound.Stride : SignedInteger {\n          ^\n/tmp/tmpcxo1x5aa.swift:22:12:\
    \ warning: comparing non-optional value of type '[Int]' to 'nil' always returns\
    \ false\n  if right == nil && middle == 1 {\n     ~~~~~ ^  ~~~\n/tmp/tmpcxo1x5aa.swift:23:16:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \    return left[0]\n           ~~~~^~~\n           Double()\n/tmp/tmpcxo1x5aa.swift:24:19:\
    \ warning: comparing non-optional value of type '[Int]' to 'nil' always returns\
    \ false\n  } else if right == nil {\n            ~~~~~ ^  ~~~\n/tmp/tmpcxo1x5aa.swift:25:17:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \    return right[0]\n           ~~~~~^~~\n           Double( )\n/tmp/tmpcxo1x5aa.swift:26:18:\
    \ warning: comparing non-optional value of type '[Int]' to 'nil' always returns\
    \ false\n  "
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let l = l.sorted()\n    if l.count < 2\
    \ {\n        return l[0]\n    }\n    if l.count == 2 {\n        return l[0] /\
    \ 2\n    }\n    let middle = Int((l.count - 1) / 2)\n    return l[middle]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpp4gwqy39.swift:10:17: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l[0]\n               ~^~~\n\
    \               Double( )\n/tmp/tmpp4gwqy39.swift:13:21: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n        return l[0]\
    \ / 2\n               ~~~~~^~~\n               Double( )\n/tmp/tmpp4gwqy39.swift:16:13:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \    return l[middle]\n           ~^~~~~~~~\n           Double(  )\n"
  stdout: ''
  timestamp: 1659978539
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var sum = 0\n    var count = 0\n    for\
    \ x in l {\n        sum += x\n        count += 1\n    }\n    if count == 0 {\n\
    \        return 0\n    }\n    if count == 1 {\n        return sum / Double(count)\n\
    \    }\n    var middle = count / 2\n    return sum / Double(middle) + Double(sum\
    \ % middle) / Double(count - middle)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp6gnq84b6.swift:18:16: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n        return sum / Double(count)\n   \
    \            ^\n               Double( )\n/tmp/tmp6gnq84b6.swift:21:12: error:\
    \ the compiler is unable to type-check this expression in reasonable time; try\
    \ breaking up the expression into distinct sub-expressions\n    return sum / Double(middle)\
    \ + Double(sum % middle) / Double(count - middle)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978560
- exit_code: -4
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var result = Double(0)\n    var count =\
    \ 1\n    for i in l {\n        result += Double(i) / Double(count)\n        count\
    \ += 1\n    }\n    return result / Double(l.count)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: Exception
  stderr: 'tmp1_c_k489/tmp1_c_k489.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f73019c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f72d10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f72d10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f72d0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1_c_k489                        0x0000558b14e644e1 <unavailable> + 5345

    5    libc.so.6                          0x00002b3f73205460 __libc_start_main +
    245

    6    tmp1_c_k489                        0x0000558b14e64129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  let n = l.count\n  if n == 0 {\n    return\
    \ 0.0\n  }\n\n  let mid = Int(ceil(Double(n) / 2))\n  let left = l.subarray(0,\
    \ mid)\n  let right = l.subarray(mid, l)\n  return median(left) + median(right)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpavw6qocv.swift:13:17: error: cannot find 'ceil' in scope\n  let\
    \ mid = Int(ceil(Double(n) / 2))\n                ^~~~\n/tmp/tmpavw6qocv.swift:14:16:\
    \ error: value of type '[Int]' has no member 'subarray'\n  let left = l.subarray(0,\
    \ mid)\n             ~ ^~~~~~~~\n/tmp/tmpavw6qocv.swift:15:17: error: value of\
    \ type '[Int]' has no member 'subarray'\n  let right = l.subarray(mid, l)\n  \
    \            ~ ^~~~~~~~\n/tmp/tmpavw6qocv.swift:16:17: error: missing argument\
    \ label 'l:' in call\n  return median(left) + median(right)\n                ^\n\
    \                l: \n/tmp/tmpavw6qocv.swift:16:32: error: missing argument label\
    \ 'l:' in call\n  return median(left) + median(right)\n                      \
    \         ^\n                               l: \n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  let count = l.count\n  let sorted = l.sorted()\n\
    \  return Double(sorted[(count - 1) / 2]!)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpv69zap7w.swift:10:40: error: cannot force unwrap value of non-optional\
    \ type 'Int'\n  return Double(sorted[(count - 1) / 2]!)\n                ~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                       \n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  return median(l.asDoubles(), l.count)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmph4t9h64e.swift:8:34: error: extra argument in call\n  return median(l.asDoubles(),\
    \ l.count)\n               ~~~~~~~~~~~~~~~~~~^~~~~~\n/tmp/tmph4t9h64e.swift:8:19:\
    \ error: value of type '[Int]' has no member 'asDoubles'\n  return median(l.asDoubles(),\
    \ l.count)\n                ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var l = l\n  l += l[l.startIndex]\n  l =\
    \ l.sorted { $0 < $1 }\n  guard l.count % 2 == 1 else {\n    return Double(l.last!)\
    \ / 2.0\n  }\n  guard l.count > 1 else {\n    return Double(l.first!) / 2.0\n\
    \  }\n  return Double(l.last! + l.first!) / 2.0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp5gt7y1gx.swift:9:9: error: cannot convert value of type 'Int' to\
    \ expected argument type 'Array<Int>'\n  l += l[l.startIndex]\n        ^\n/tmp/tmp5gt7y1gx.swift:9:9:\
    \ error: no exact matches in call to subscript \n  l += l[l.startIndex]\n    \
    \    ^\nSwift.Array:3:35: note: candidate expects value of type 'Array<Int>' for\
    \ parameter #2 (got 'Int')\n    @inlinable public static func += (lhs: inout [Element],\
    \ rhs: [Element])\n                                  ^\nSwift.Array:17:23: note:\
    \ candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n\
    \    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {\
    \ get set }\n                      ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\nSwift.MutableCollection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var lLen = l.count\n    guard lLen > 0\
    \ else { return 0 }\n    var m = (lLen + 1) / 2\n    var mPos = l.index(of: m)\n\
    \    if mPos == l.endIndex {\n        return l[mPos]\n    }\n    else {\n    \
    \    return (l[mPos] - l[mPos - 1]) / 2.0 + l[mPos - 1]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpfvx42j4m.swift:11:18: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    var mPos = l.index(of: m)\n                 ^\n/tmp/tmpfvx42j4m.swift:11:18:\
    \ note: use 'firstIndex(of:)' instead\n    var mPos = l.index(of: m)\n       \
    \          ^~~~~\n                 firstIndex\n/tmp/tmpfvx42j4m.swift:13:18: error:\
    \ value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped\
    \ to a value of type 'Array<Int>.Index' (aka 'Int')\n        return l[mPos]\n\
    \                 ^\n/tmp/tmpfvx42j4m.swift:13:18: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        return l[mPos]\n\
    \                 ^\n                      ?? <#default value#>\n/tmp/tmpfvx42j4m.swift:13:18:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return l[mPos]\n                 ^\n                     !\n\
    /tmp/tmpfvx42j4m.swift:13:17: error: cannot convert return expression of type\
    \ 'Int' to return type 'Double'\n        return l[mPos]\n               ~^~~~~~\n\
    \               Double()\n/tmp/tmpfvx42j4m.swift:16:16: error: the compiler is\
    \ unable to type-check this expression in reasonable time; try breaking up the\
    \ expression into distinct sub-expressions\n        return (l[mPos] - l[mPos -\
    \ 1]) / 2.0 + l[mPos - 1]\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978564
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l = l.sorted()\n    if l.count % 2\
    \ == 0 {\n        return l.sorted()[l.count / 2]\n    } else {\n        return\
    \ l.sorted()[(l.count / 2) - 1]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpvf2ew596.swift:10:26: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l.sorted()[l.count / 2]\n\
    \               ~~~~~~~~~~^~~~~~~~~~~~~\n               Double(              \
    \  )\n/tmp/tmpvf2ew596.swift:12:26: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l.sorted()[(l.count / 2)\
    \ - 1]\n               ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n               Double( \
    \                     )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return math.floor((l.sortedLastIndex()\
    \ ?? l.count / 2) / 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp91jg05_s.swift:8:12: error: cannot find 'math' in scope\n    return\
    \ math.floor((l.sortedLastIndex() ?? l.count / 2) / 2)\n           ^~~~\n/tmp/tmp91jg05_s.swift:8:26:\
    \ error: value of type '[Int]' has no member 'sortedLastIndex'\n    return math.floor((l.sortedLastIndex()\
    \ ?? l.count / 2) / 2)\n                       ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tif l == nil {\n\t\treturn 0.0\n\t}\n\treturn\
    \ median0(l)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp0mow2u_u.swift:8:7: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns false\n        if l == nil {\n           ~ ^\
    \  ~~~\n/tmp/tmp0mow2u_u.swift:11:9: error: cannot find 'median0' in scope\n \
    \       return median0(l)\n               ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var count = 0\n    var max = 0\n    var\
    \ mid = 0\n    for e in l {\n        if e > max {\n            max = e\n     \
    \       mid = count\n        }\n        count += 1.0\n    }\n    if count < l.count\
    \ {\n        return Double(max) + Double(mid)\n    }\n    return Double(max)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmph_a9tfq5.swift:16:18: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        count += 1.0\n                 ^\n\
    \                 Int( )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var result: Double = 0\n    var count =\
    \ 1\n    for i in l {\n        if i < result {\n            result = i\n     \
    \   } else {\n            count += 1\n        }\n    }\n    if count % 2 == 0\
    \ {\n        return (result + result[count/2]) / 2.0\n    } else {\n        return\
    \ result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp0wj_rxor.swift:11:14: error: binary operator '<' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n        if i < result {\n          \
    \ ~ ^ ~~~~~~\n/tmp/tmp0wj_rxor.swift:11:14: note: overloads for '<' exist with\
    \ these partially matching parameter lists: (Int, Int)\n        if i < result\
    \ {\n             ^\n/tmp/tmp0wj_rxor.swift:12:22: error: cannot assign value\
    \ of type 'Int' to type 'Double'\n            result = i\n                   \
    \  ^\n                     Double( )\n/tmp/tmp0wj_rxor.swift:18:32: error: value\
    \ of type 'Double' has no subscripts\n        return (result + result[count/2])\
    \ / 2.0\n                         ~~~~~~^\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return math.median(l)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmps8g56jc8.swift:8:12: error: cannot find 'math' in scope\n    return\
    \ math.median(l)\n           ^~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return l.sorted().reduce(0.0) {\n     \
    \   return $0 + $1.truncatingRemainder() / Double(l.count-1)\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpqrq69584.swift:9:24: error: value of type 'Int' has no member 'truncatingRemainder'\n\
    \        return $0 + $1.truncatingRemainder() / Double(l.count-1)\n          \
    \          ~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  let n = l.count\n  assert(n >= 1, \"median\
    \ of an empty list\")\n  if n == 1 {\n    return l[0]\n  }\n  var center = Double(n\
    \ - 1)\n  var lowHalf = Array(0..<n)\n  var highHalf = Array(0..<n)\n  var pivot\
    \ = Double(n)\n  for i in 0 ..< n {\n    if l[i] < low {\n      lowHalf.append(l[i])\n\
    \    } else if l[i] > high {\n      highHalf.append(l[i])\n    } else {\n    \
    \  lowHalf.append(l[i])\n      highHalf.append(l[i])\n    }\n  }\n\n  pivot =\
    \ median(lowHalf)\n  for idx in lowHalf.indices {\n    l[idx] = lowHalf[idx]\n\
    \  }\n  for idx in highHalf.indices {\n    l[idx] = highHalf[idx]\n  }\n  if n\
    \ == 1 {\n    return pivot\n  }\n  pivot = median(highHalf)\n  for idx in highHalf.indices\
    \ {\n    l[idx] = highHalf[idx]\n  }\n  for idx in lowHalf.indices {\n    l[idx]\
    \ = lowHalf[idx]\n  }\n\n  return pivot\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp2cqavnw1.swift:11:13: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return l[0]\n           ~^~~\n     \
    \      Double( )\n/tmp/tmp2cqavnw1.swift:18:15: error: cannot find 'low' in scope\n\
    \    if l[i] < low {\n              ^~~\n/tmp/tmp2cqavnw1.swift:20:22: error:\
    \ cannot find 'high' in scope\n    } else if l[i] > high {\n                 \
    \    ^~~~\n/tmp/tmp2cqavnw1.swift:28:18: error: missing argument label 'l:' in\
    \ call\n  pivot = median(lowHalf)\n                 ^\n                 l: \n\
    /tmp/tmp2cqavnw1.swift:30:6: error: cannot assign through subscript: 'l' is a\
    \ 'let' constant\n    l[idx] = lowHalf[idx]\n    ~^\n/tmp/tmp2cqavnw1.swift:33:6:\
    \ error: cannot assign through subscript: 'l' is a 'let' constant\n    l[idx]\
    \ = highHalf[idx]\n    ~^\n/tmp/tmp2cqavnw1.swift:38:18: error: missing argument\
    \ label 'l:' in call\n  pivot = median(highHalf)\n                 ^\n       \
    \          l: \n/tmp/tmp2cqavnw1.swift:40:6: error: cannot assign through subscript:\
    \ 'l' is a 'let' constant\n    l[idx] = highHalf[idx]\n    ~^\n/tmp/tmp2cqavnw1.swift:43:6:\
    \ error: cannot assign through subscript: 'l' is a 'let' constant\n    l[idx]\
    \ = lowHalf[idx]\n    ~^\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var sorted: Double = 0.0\n    var size\
    \ = l.count\n\n    for number in l {\n        sorted = sorted + (number / Double(size))\
    \ * Double(l.count)\n        size = size - 1\n    }\n\n    return sorted\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpbjcsz6_c.swift:12:28: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n        sorted = sorted + (number / Double(size))\
    \ * Double(l.count)\n                           ^\n                          \
    \ Double( )\n"
  stdout: ''
  timestamp: 1659978549
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  if l == nil {\n    return 0.0\n  }\n  let\
    \ count = l.count\n  if count == 0 {\n    return 0.0\n  }\n  if count == 1 {\n\
    \    return l[0]\n  }\n  if count == 2 {\n    return (l[0] + l[1]) / 2.0\n  }\n\
    \  let middle = count / 2.0\n  var i = count - 1\n  var m = (l[0] + l[1]) / 2.0\n\
    \  for ; i > middle; i-- {\n    if l[i] < m {\n      m = l[i]\n    }\n  }\n  return\
    \ m\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) ==\
    \ 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5])\
    \ == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2,\
    \ 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp4q24i_dv.swift:24:3: error: C-style for statement has been removed\
    \ in Swift 3\n  for ; i > middle; i-- {\n  ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmp4q24i_dv.swift:8:8:\
    \ warning: comparing non-optional value of type '[Int]' to 'nil' always returns\
    \ false\n  if l == nil {\n     ~ ^  ~~~\n/tmp/tmp4q24i_dv.swift:16:13: error:\
    \ cannot convert return expression of type 'Int' to return type 'Double'\n   \
    \ return l[0]\n           ~^~~\n           Double( )\n/tmp/tmp4q24i_dv.swift:19:18:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \    return (l[0] + l[1]) / 2.0\n                 ^\n           Double(      )\n\
    /tmp/tmp4q24i_dv.swift:21:22: error: binary operator '/' cannot be applied to\
    \ operands of type 'Int' and 'Double'\n  let middle = count / 2.0\n          \
    \     ~~~~~ ^ ~~~\n/tmp/tmp4q24i_dv.swift:21:22: note: overloads for '/' exist\
    \ with these partially matching parameter lists: (Double, Double), (Duration,\
    \ Double), (Int, Int)\n  let middle = count / 2.0\n                     ^\n/tmp/tmp4q24i_dv.swift:23:25:\
    \ error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'\n\
    \  var m = (l[0] + l[1]) / 2.0\n          ~~~~~~~~~~~~~ ^ ~~~\n/tmp/tmp4q24i_dv.swift:23:25:\
    \ note: overloads for '/' exist with these partially matching parameter lists:\
    \ (Double, Double), (Duration, Double), (Int, Int)\n  var m = (l[0] + l[1]) /\
    \ 2.0\n                        ^\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return l.sorted { $0 < $1 }.mid\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpqvgb4pin.swift:8:33: error: value of type '[Int]' has no member\
    \ 'mid'\n    return l.sorted { $0 < $1 }.mid\n           ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.count <= 1 {\n        return Double(l.first!)\n\
    \    }\n\n    // Sort array and get middle index\n    var midIndex = (l.count\
    \ - 1) / 2\n    if l.count % 2 == 0 {\n        // even\n        midIndex += 1\n\
    \    }\n\n    // If median is odd, get the first or last value\n    if midIndex\
    \ % 2 == 0 {\n        return Double(l.sortedLast!)\n    } else {\n        return\
    \ Double(l.sortedFirst!)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpfc_mg7d_.swift:21:25: error: value of type '[Int]' has no member\
    \ 'sortedLast'\n        return Double(l.sortedLast!)\n                      ~\
    \ ^~~~~~~~~~\n/tmp/tmpfc_mg7d_.swift:23:25: error: value of type '[Int]' has no\
    \ member 'sortedFirst'\n        return Double(l.sortedFirst!)\n              \
    \        ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return Array(l).sorted().reduce(0,{ (sum,\
    \ cur) -> Double in\n        if sum == 0 { return cur }\n        if cur == sum\
    \ { return Double(cur) }\n        return Double(sum) / Double(cur)\n    })\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp6sj1inj5.swift:9:30: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        if sum == 0 { return cur }\n   \
    \                          ^~~\n                             Double( )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  let n = l.count\n  if n < 2 {\n    return\
    \ l[0]\n  }\n  let i = Int(n/2)\n  return (l[i] - l[i-1]) * (n/2) + (l[n-1] -\
    \ l[n]) / 2.0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpjdxnuv_d.swift:10:13: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return l[0]\n           ~^~~\n     \
    \      Double( )\n/tmp/tmpjdxnuv_d.swift:13:10: error: the compiler is unable\
    \ to type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n  return (l[i] - l[i-1]) * (n/2) + (l[n-1] -\
    \ l[n]) / 2.0\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978564
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var ls = l.slice()\n    var med = Int(ls.count\
    \ / 2)\n\n    if ls.count % 2 == 0 {\n        // even number of elements\n   \
    \     for (i, e) in ls.enumerated() {\n            if i < med {\n            \
    \    ls[i] = ls[i + 1]\n            } else {\n                ls[i] = ls[i - 1]\n\
    \            }\n        }\n        return ls[med].doubleValue()\n    }\n\n   \
    \ // odd number of elements\n    var low = Int(ls.count / 2)\n    var high = Int(ls.count\
    \ / 2) - Int(med)\n    var mid = low\n\n    var leftAverage: Double = 0\n    var\
    \ rightAverage: Double = 0\n\n    for (i, _) in ls.enumerated() {\n        if\
    \ i < med {\n            leftAverage += Double(i)\n        } else {\n        \
    \    rightAverage += Double(i)\n        }\n    }\n\n    leftAverage = leftAverage\
    \ / Double(ls.count / 2)\n    rightAverage = rightAverage / Double(ls.count /\
    \ 2 - med)\n\n    return rightAverage + leftAverage\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp3zcc_y7r.swift:8:16: error: value of type '[Int]' has no member\
    \ 'slice'\n    var ls = l.slice()\n             ~ ^~~~~\n/tmp/tmp3zcc_y7r.swift:31:5:\
    \ error: failed to produce diagnostic for expression; please submit a bug report\
    \ (https://swift.org/contributing/#reporting-bugs) and include the project\n \
    \   for (i, _) in ls.enumerated() {\n    ^\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\treturn median(l, Double(0))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpcd2sbuvy.swift:8:19: error: extra argument in call\n        return\
    \ median(l, Double(0))\n                     ~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var a = l.sorted()\n    return (a[a.count\
    \ / 2 - 1] + a[a.count / 2]) / 2.0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp4bxui4wu.swift:9:32: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n    return (a[a.count / 2 - 1] + a[a.count\
    \ / 2]) / 2.0\n                               ^\n           Double(          \
    \                    )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  if l.count < 2 {\n    return Double.nan\n\
    \  }\n  var sorted = l.sorted()\n  if sorted.first == sorted.last {\n    return\
    \ sorted[sorted.first]\n  }\n  var middle = sorted.first\n  var upper = sorted.last\n\
    \  var lower = sorted.first\n  var median = sorted[(middle + upper) / 2]\n  for\
    \ index in (middle + lower).stride(through: 0) {\n    if sorted[index] < median\
    \ {\n      lower = index + 1\n    } else if sorted[index] > median {\n      upper\
    \ = index\n    } else {\n      return median\n    }\n  }\n  return median\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpj6002f3k.swift:13:26: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return sorted[sorted.first]\n   \
    \                      ^\n/tmp/tmpj6002f3k.swift:13:26: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    return sorted[sorted.first]\n\
    \                         ^\n                               ?? <#default value#>\n\
    /tmp/tmpj6002f3k.swift:13:26: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    return sorted[sorted.first]\n    \
    \                     ^\n                              !\n/tmp/tmpj6002f3k.swift:13:18:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \    return sorted[sorted.first]\n           ~~~~~~^~~~~~~~~~~~~~\n          \
    \ Double(             )\n/tmp/tmpj6002f3k.swift:18:31: error: binary operator\
    \ '+' cannot be applied to two 'Int?' operands\n  var median = sorted[(middle\
    \ + upper) / 2]\n                       ~~~~~~ ^ ~~~~~\n/tmp/tmpj6002f3k.swift:18:31:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n  var median = sorted[(middle + upper) / 2]\n                  \
    \            ^\n/tmp/tmpj6002f3k.swift:19:24: error: binary operator '+' cannot\
    \ be applied to two 'Int?' operands\n  for index in (middle + lower).stride(through:\
    \ 0) {\n                ~~~~~~ ^ ~~~~~\n/tmp/tmpj6002f3k.swift:19:24: note: overloads\
    \ for '+' exist with these partially matching parameter lists: (Int, Int)\n  for\
    \ index in (middle + lower).stride(through: 0) {\n                       ^\n/tmp/tmpj6002f3k.swift:19:33:\
    \ error: value of type 'Int' has no member 'stride'\n  for index in (middle +\
    \ lower).stride(through: 0) {\n               ~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var sorted = l.sorted()\n    var middle\
    \ = (sorted.count / 2)\n    if sorted.count % 2 == 1 {\n        return sorted[middle]\n\
    \    }\n    return Double(sorted[middle-1]) + Double(sorted[middle])\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp6ec3n87x.swift:11:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return sorted[middle]\n        \
    \       ~~~~~~^~~~~~~~\n               Double(       )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l == nil || l.isEmpty() {\n        return\
    \ 0\n    }\n    if l.count == 0 {\n        return 0\n    }\n\n    // Sort the\
    \ array in ascending order\n    var sortedArray = l.sorted()\n\n    if sortedArray.count\
    \ % 2 == 0 {\n        // Even number of elements.\n        let midPoint = sortedArray.count\
    \ / 2\n        return sortedArray[midPoint]\n    } else {\n        // Odd number\
    \ of elements.\n        let midPoint = (sortedArray.count - 1) / 2\n        return\
    \ Double(sortedArray[midPoint]) + Double(sortedArray[midPoint - 1])\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpdqg4vwsw.swift:8:22: error: cannot call value of non-function type\
    \ 'Bool'\n    if l == nil || l.isEmpty() {\n                     ^      ~~\n \
    \                           \n/tmp/tmpdqg4vwsw.swift:21:27: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n        return sortedArray[midPoint]\n\
    \               ~~~~~~~~~~~^~~~~~~~~~\n               Double(              )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let size = l.count\n    if size == 0 {\n\
    \        return Double.nan\n    }\n    if size == 1 {\n        return l[0]\n \
    \   }\n    let mid = size / 2\n    return median(Array(l.prefix(mid)), median(Array(l.suffix(mid))),\
    \ median(Array(l.dropFirst(mid))), median(Array(l.dropLast(mid))))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpbvfxphkp.swift:13:17: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l[0]\n               ~^~~\n\
    \               Double( )\n/tmp/tmpbvfxphkp.swift:16:18: error: extra arguments\
    \ at positions #2, #3, #4 in call\n    return median(Array(l.prefix(mid)), median(Array(l.suffix(mid))),\
    \ median(Array(l.dropFirst(mid))), median(Array(l.dropLast(mid))))\n         \
    \        ^\n/tmp/tmpbvfxphkp.swift:7:6: note: 'median(l:)' declared here\nfunc\
    \ median(l: [Int]) -> Double {\n     ^\n/tmp/tmpbvfxphkp.swift:16:48: error: missing\
    \ argument label 'l:' in call\n    return median(Array(l.prefix(mid)), median(Array(l.suffix(mid))),\
    \ median(Array(l.dropFirst(mid))), median(Array(l.dropLast(mid))))\n         \
    \                                      ^\n                                   \
    \            l: \n/tmp/tmpbvfxphkp.swift:16:78: error: missing argument label\
    \ 'l:' in call\n    return median(Array(l.prefix(mid)), median(Array(l.suffix(mid))),\
    \ median(Array(l.dropFirst(mid))), median(Array(l.dropLast(mid))))\n         \
    \                                                                    ^\n     \
    \                                                                        l: \n\
    /tmp/tmpbvfxphkp.swift:16:111: error: missing argument label 'l:' in call\n  \
    \  return median(Array(l.prefix(mid)), median(Array(l.suffix(mid))), median(Array(l.dropFirst(mid))),\
    \ median(Array(l.dropLast(mid))))\n                                          \
    \                                                                    ^\n     \
    \                                                                            \
    \                             l: \n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return Double(l.sort().last!) / Double(l.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpwbk87c_z.swift:8:28: error: value of tuple type '()' has no member\
    \ 'last'\n    return Double(l.sort().last!) / Double(l.count)\n              \
    \    ~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var count = Double(0.0)\n    for number\
    \ in l {\n        count += 1.0\n    }\n    if count < 1.0 {\n        return Double(l[0])\n\
    \    }\n    var index = Int(count * Double.pi)\n    var middleIndex = Int(Double.pi\
    \ * Double.pi)\n    if index > middleIndex {\n        index = middleIndex\n  \
    \  }\n    var middleValue = Double(0.0)\n    for number in l {\n        if number\
    \ >= Double(index - Double.pi / 2.0) {\n            middleValue += 1.0\n     \
    \   }\n        index -= Double.pi / 2.0\n    }\n    return middleValue / Double(l.count\
    \ - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpvtggs95s.swift:22:35: error: binary operator '-' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n        if number >= Double(index -\
    \ Double.pi / 2.0) {\n                            ~~~~~ ^ ~~~~~~~~~~~~~~~\n/tmp/tmpvtggs95s.swift:22:35:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n        if number >= Double(index - Double.pi\
    \ / 2.0) {\n                                  ^\n/tmp/tmpvtggs95s.swift:22:22:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        if number >= Double(index - Double.pi / 2.0) {\n                    \
    \ ^\n                     Int(                           )\n/tmp/tmpvtggs95s.swift:25:28:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        index -= Double.pi / 2.0\n                           ^\n            \
    \     Int(           )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var counts: Dictionary<Int, Int> = [:]\n\
    \    for x in l {\n        counts[x] = (counts[x] ?? 0) + 1\n    }\n    var sum:\
    \ Double = 0\n    for x in counts {\n        sum += x / Double(counts[x])\n  \
    \  }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpx19szlt6.swift:14:16: error: cannot convert value of type '(key:\
    \ Int, value: Int)' to expected argument type 'Double'\n        sum += x / Double(counts[x])\n\
    \               ^\n/tmp/tmpx19szlt6.swift:14:20: error: no exact matches in call\
    \ to initializer \n        sum += x / Double(counts[x])\n                   ^\n\
    /tmp/tmpx19szlt6.swift:14:20: note: found candidate with type '((key: Int, value:\
    \ Int)) -> Double'\n        sum += x / Double(counts[x])\n                   ^\n\
    /tmp/tmpx19szlt6.swift:14:20: note: candidate expects value of type 'Int' for\
    \ parameter #1 (got '(key: Int, value: Int)')\n        sum += x / Double(counts[x])\n\
    \                   ^\n/tmp/tmpx19szlt6.swift:14:33: error: no exact matches in\
    \ call to subscript \n        sum += x / Double(counts[x])\n                 \
    \               ^\n/tmp/tmpx19szlt6.swift:14:33: note: found candidate with type\
    \ '(Dictionary<Int, Int>.Index) -> (key: Int, value: Int)'\n        sum += x /\
    \ Double(counts[x])\n                                ^\n/tmp/tmpx19szlt6.swift:14:33:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got '(key: Int,\
    \ value: Int)')\n        sum += x / Double(counts[x])\n                      \
    \          ^\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return l.sorted(by: <, >).reduce(<, >)\
    \ / Double(l.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp7mck255s.swift:8:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return l.sorted(by: <, >).reduce(<, >) / Double(l.count)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978561
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l = l as! [Int]\n    l.sort()\n   \
    \ let mid = Int((Double(l.count) / 2.0) + 0.5)\n    return l[mid]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpmt01_7f6.swift:8:15: warning: forced cast of '[Int]' to same type\
    \ has no effect\n    var l = l as! [Int]\n              ^~~~~~~~~\n          \
    \    \n/tmp/tmpmt01_7f6.swift:11:13: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return l[mid]\n           ~^~~~~\n \
    \          Double( )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.isEmpty  {\n        return Double.nan\n\
    \    }\n    let l = l.sorted()\n    let mid = l.count / 2\n    return l[mid]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp1u8ddy4v.swift:13:13: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return l[mid]\n           ~^~~~~\n \
    \          Double( )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  let count = countElements(l)\n  if count\
    \ == 0 {\n    return Double(Int(0)) // avoid div by 0\n  }\n  guard count > 1\
    \ else { return Double(Int(0)) // avoid div by 0\n  }\n  let sortedList = l.sorted()\n\
    \  return sortedList[count / 2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmplq773a73.swift:8:15: error: cannot find 'countElements' in scope\n\
    \  let count = countElements(l)\n              ^~~~~~~~~~~~~\n/tmp/tmplq773a73.swift:15:20:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \  return sortedList[count / 2]\n         ~~~~~~~~~~^~~~~~~~~~~\n         Double(\
    \              )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var ls = [Int]()\n    var counts = [Int]()\n\
    \    for x in l {\n        ls.append(x)\n        counts.append(1)\n    }\n   \
    \ guard ls.count != counts.count else { return 0.0 }\n    for x in ls {\n    \
    \    counts[Int((x - Int((ls.sort { $0 < $1 }[0]) + 1.0))/2.0 + 1)] += 1\n   \
    \ }\n    var total = Double(0)\n    var result = 0\n    for x in counts {\n  \
    \      total += x / Double(l.count)\n    }\n    if total == 0.0 { return 0.0 }\n\
    \    for x in counts {\n        if x % 2 == 0 { result += total * Double(x % 2)\
    \ } else { result -= total * Double(x % 2) }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpkvdf6ech.swift:16:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        counts[Int((x - Int((ls.sort { $0 < $1 }[0]) + 1.0))/2.0\
    \ + 1)] += 1\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkvdf6ech.swift:21:18: error: cannot convert value of type 'Int' to expected\
    \ argument type 'Double'\n        total += x / Double(l.count)\n             \
    \    ^\n                 Double( )\n/tmp/tmpkvdf6ech.swift:25:41: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        if x\
    \ % 2 == 0 { result += total * Double(x % 2) } else { result -= total * Double(x\
    \ % 2) }\n                                        ^\n                        \
    \          Int(                 )\n/tmp/tmpkvdf6ech.swift:25:82: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        if x\
    \ % 2 == 0 { result += total * Double(x % 2) } else { result -= total * Double(x\
    \ % 2) }\n                                                                   \
    \              ^\n                                                           \
    \                Int(                 )\n/tmp/tmpkvdf6ech.swift:27:12: error:\
    \ cannot convert return expression of type 'Int' to return type 'Double'\n   \
    \ return result\n           ^~~~~~\n           Double( )\n"
  stdout: ''
  timestamp: 1659978563
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var middle = l[0]\n    for element in l\
    \ {\n        if element > middle {\n            middle = element\n        }\n\
    \    }\n    return middle\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp3cwrk13c.swift:14:12: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return middle\n           ^~~~~~\n \
    \          Double( )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let length = l.count\n    var sortedArray\
    \ = Array(l)\n    sortedArray.sort()\n    let middleIndex = sortedArray.count\
    \ / 2\n    if sortedArray.count % 2 == 0 {\n        return sortedArray[middleIndex]\n\
    \    } else {\n        return Double(sortedArray[(sortedArray.count - 1) / 2]\
    \ + sortedArray[middleIndex])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmppcougd8y.swift:13:27: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return sortedArray[middleIndex]\n\
    \               ~~~~~~~~~~~^~~~~~~~~~~~~\n               Double(             \
    \    )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  return l.sorted { $0 < $1 }.count / Double(l.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpyhv29o1u.swift:8:31: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n  return l.sorted { $0 < $1 }.count / Double(l.count)\n\
    \                              ^\n         Double(                   )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var count = countElements(l)\n    guard\
    \ count > 0 else { return Double.nan}\n\n    let sortedList = sorted(l)\n    var\
    \ median: Double = 0\n    if count % 2 == 0 {\n        median = (sortedList[count\
    \ / 2 - 1] + sortedList[count / 2]) / 2\n    } else {\n        median = sortedList[count\
    \ / 2]\n    }\n    return median\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpr1ch3ucc.swift:8:17: error: cannot find 'countElements' in scope\n\
    \    var count = countElements(l)\n                ^~~~~~~~~~~~~\n/tmp/tmpr1ch3ucc.swift:11:22:\
    \ error: cannot find 'sorted' in scope\n    let sortedList = sorted(l)\n     \
    \                ^~~~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let sortedArray = l.sorted()\n    let index\
    \ = sortedArray.endIndex.predecessor()\n    let count = sortedArray.count\n  \
    \  if count == 0 { return Double.infinity}\n    let middle = Double(index) / Double(count)\n\
    \    return middle\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpk7qf2elb.swift:9:38: error: value of type 'Int' has no member 'predecessor'\n\
    \    let index = sortedArray.endIndex.predecessor()\n                ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  return sort(l).median()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpsit63fe6.swift:8:10: error: cannot find 'sort' in scope\n  return\
    \ sort(l).median()\n         ^~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.count < 2 {\n        return Double(l[0])\n\
    \    }\n    var l = l.sorted()\n    var mid = Double(l.count / 2)\n    var m1\
    \ = l[mid]\n    var m2 = l[mid-1]\n    if (m2 < m1) {\n        return m1 + (l[mid+1]\
    \ - m1)\n    }\n    return mid\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpgq27ul4p.swift:13:15: error: no exact matches in call to subscript\
    \ \n    var m1 = l[mid]\n              ^\nSwift.Array:16:23: note: candidate expects\
    \ value of type 'Int' for parameter #1 (got 'Double')\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note:\
    \ candidate expects value of type 'Range<Int>' for parameter #1 (got 'Double')\n\
    \    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {\
    \ get set }\n                      ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Double')\n  \
    \  @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\nSwift.MutableCollection:3:23: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Double')\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get set }\n                      ^\n/tmp/tmpgq27ul4p.swift:14:16: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n    var m2 =\
    \ l[mid-1]\n               ^\n               Int( )\n/tmp/tmpgq27ul4p.swift:16:19:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return m1 + (l[mid+1] - m1)\n               ~~~^~~~~~~~~~~~~~~~~\n  \
    \             Double(             )\n/tmp/tmpgq27ul4p.swift:16:24: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ m1 + (l[mid+1] - m1)\n                       ^\n                       Int(\
    \ )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let len = l.count\n    var minVal = l[0]\n\
    \    var maxVal = l[0]\n    for i in 1..<len {\n        if l[i] < minVal {\n \
    \           minVal = l[i]\n        }\n        if l[i] > maxVal {\n           \
    \ maxVal = l[i]\n        }\n    }\n    return (len/2.0) * (minVal + maxVal)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpnk9_8o_o.swift:19:16: error: binary operator '/' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    return (len/2.0) * (minVal + maxVal)\n\
    \            ~~~^~~~\n/tmp/tmpnk9_8o_o.swift:19:16: note: overloads for '/' exist\
    \ with these partially matching parameter lists: (Duration, Double), (Int, Int)\n\
    \    return (len/2.0) * (minVal + maxVal)\n               ^\n/tmp/tmpnk9_8o_o.swift:19:22:\
    \ error: no '*' candidates produce the expected contextual result type 'Double'\n\
    \    return (len/2.0) * (minVal + maxVal)\n                     ^\nSwift.Int:9:24:\
    \ note: '*' produces 'Int', not the expected contextual result type 'Double'\n\
    \    public static func * (lhs: Int, rhs: Int) -> Int\n                      \
    \ ^\nSwift.DurationProtocol:5:17: note: '*' produces 'Duration', not the expected\
    \ contextual result type 'Double'\n    static func * (lhs: Self, rhs: Int) ->\
    \ Self\n                ^\nSwift.Int:9:24: note: '*' produces 'Int', not the expected\
    \ contextual result type 'Double'\n    public static func * (lhs: Int, rhs: Int)\
    \ -> Int\n                       ^\nSwift.Numeric:5:17: note: '*' produces 'Int',\
    \ not the expected contextual result type 'Double'\n    static func * (lhs: Self,\
    \ rhs: Self) -> Self\n                ^\nSwift.BinaryInteger:22:26: note: '*'\
    \ produces 'Int', not the expected contextual result type 'Double'\n    override\
    \ static func * (lhs: Self, rhs: Self) -> Self\n                         ^\nSwift.Int:9:24:\
    \ note: '*' produces 'Int', not the expected contextual result type 'Double'\n\
    \    public static func * (lhs: Int, rhs: Int) -> Int\n                      \
    \ ^\nSwift.Numeric:5:17: note: '*' produces 'Int', not the expected contextual\
    \ result type 'Double'\n    static func * (lhs: Self, rhs: Self) -> Self\n   \
    \             ^\nSwift.BinaryInteger:22:26: note: '*' produces 'Int', not the\
    \ expected contextual result type 'Double'\n    override static func * (lhs: Self,\
    \ rhs: Self) -> Self\n                         ^\nSwift.Int:9:24: note: '*' produces\
    \ 'Int', not the expected contextual result type 'Double'\n    public static func\
    \ * (lhs: Int"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    assert(l.isSorted)\n    var middleIdx:\
    \ Int = 0\n    var middleVal: Double\n    var count = 0\n\n    // iterate through\
    \ the sorted array l to find median\n    for idx <- 0 ..< l.count {\n        if\
    \ count > 0 {\n            if l[idx] > middleVal {\n                // move middle\
    \ pointer\n                middleIdx = idx\n                // reset the count\n\
    \                count = 0\n            }\n            // increment count\n  \
    \          count += 1\n        } else {\n            // initialize middle value,\
    \ set count\n            middleVal = l[idx]\n            middleIdx = idx\n   \
    \         count = 1\n        }\n    }\n    // now we know median of array\n  \
    \  return l[middleIdx]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpvd97o5_x.swift:14:13: error: expected 'in' after for-each pattern\n\
    \    for idx <- 0 ..< l.count {\n            ^\n/tmp/tmpvd97o5_x.swift:14:13:\
    \ error: unary operator cannot be separated from its operand\n    for idx <- 0\
    \ ..< l.count {\n            ^ ~\n              \n/tmp/tmpvd97o5_x.swift:8:14:\
    \ error: value of type '[Int]' has no member 'isSorted'\n    assert(l.isSorted)\n\
    \           ~ ^~~~~~~~\n/tmp/tmpvd97o5_x.swift:14:13: error: cannot find operator\
    \ '<-' in scope\n    for idx <- 0 ..< l.count {\n            ^~\n/tmp/tmpvd97o5_x.swift:32:13:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \    return l[middleIdx]\n           ~^~~~~~~~~~~\n           Double(     )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let n = l.count\n    if n == 0 {\n    \
    \    return 0\n    }\n    return l[n/2].truncatingRemainder(dividingBy: n)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpjxagq44h.swift:12:19: error: value of type 'Int' has no member\
    \ 'truncatingRemainder'\n    return l[n/2].truncatingRemainder(dividingBy: n)\n\
    \           ~~~~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var l2 = l.slice()\n  l2.sort()\n  if l2.count\
    \ < 2 {\n    return l[0]\n  }\n\n  return (l2[l2.count / 2] + l2[l2.count / 2\
    \ - 1]) / 2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpcehvksf9.swift:8:14: error: value of type '[Int]' has no member\
    \ 'slice'\n  var l2 = l.slice()\n           ~ ^~~~~\n/tmp/tmpcehvksf9.swift:11:13:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \    return l[0]\n           ~^~~\n           Double( )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var m = 0.0\n    for i in l {\n       \
    \ m += i * i\n    }\n    return m / Double(l.count)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmprpdbwtqq.swift:10:16: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n        m += i * i\n               ^\n \
    \            Double( )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  switch l.count {\n  case 0: return Double(l.first)\n\
    \  case 1: return Double(l.first)\n  case 2: return Double(l.first)\n  default:\
    \ return median(l[l.count/2])\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpo4_5vi6k.swift:9:27: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n  case 0: return Double(l.first)\n  \
    \                        ^\n/tmp/tmpo4_5vi6k.swift:9:27: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n  case 0:\
    \ return Double(l.first)\n                          ^\n                      \
    \          ?? <#default value#>\n/tmp/tmpo4_5vi6k.swift:9:27: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n  case 0:\
    \ return Double(l.first)\n                          ^\n                      \
    \         !\n/tmp/tmpo4_5vi6k.swift:10:27: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n  case 1: return Double(l.first)\n\
    \                          ^\n/tmp/tmpo4_5vi6k.swift:10:27: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n  case 1:\
    \ return Double(l.first)\n                          ^\n                      \
    \          ?? <#default value#>\n/tmp/tmpo4_5vi6k.swift:10:27: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n  case 1:\
    \ return Double(l.first)\n                          ^\n                      \
    \         !\n/tmp/tmpo4_5vi6k.swift:11:27: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n  case 2: return Double(l.first)\n\
    \                          ^\n/tmp/tmpo4_5vi6k.swift:11:27: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n  case 2:\
    \ return Double(l.first)\n                          ^\n                      \
    \          ?? <#default value#>\n/tmp/tmpo4_5vi6k.swift:11:27: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n  case 2:\
    \ return Double(l.first)\n                          ^\n                      \
    \         !\n/tmp/tmpo4_5vi6k.swift:12:26: error: missing argument label 'l:'\
    \ in call\n  default: return median(l[l.count/2])\n                         ^\n\
    \                         l: \n/tmp/tmpo4_5vi6k.swift:12:27: error: cannot convert\
    \ v"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    l.sort()\n    l { (lhs, rhs) in\n     \
    \   if lhs > rhs {\n            return lhs\n        }\n        return rhs\n  \
    \  }\n    return l[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmps7nsnqu8.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmps7nsnqu8.swift:9:5:\
    \ error: cannot call value of non-function type '[Int]'\n    l { (lhs, rhs) in\n\
    \    ^\n/tmp/tmps7nsnqu8.swift:15:13: error: cannot convert return expression\
    \ of type 'Int' to return type 'Double'\n    return l[0]\n           ~^~~\n  \
    \         Double( )\n"
  stdout: ''
  timestamp: 1659978540
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l == nil || l.isEmpty() {\n        return\
    \ 0\n    }\n    var avg = average(l: l)\n    var min = -Int.MAX\n    var max =\
    \ Int.MIN\n    for x in l {\n        if x < min {\n            min = x\n     \
    \   }\n        if x > max {\n            max = x\n        }\n    }\n    if max\
    \ < 0 {\n        max = -max\n    }\n    return min + (max - min) / 2\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpdu0u6b85.swift:8:22: error: cannot call value of non-function type\
    \ 'Bool'\n    if l == nil || l.isEmpty() {\n                     ^      ~~\n \
    \                           \n/tmp/tmpdu0u6b85.swift:11:15: error: cannot find\
    \ 'average' in scope\n    var avg = average(l: l)\n              ^~~~~~~\n/tmp/tmpdu0u6b85.swift:12:20:\
    \ error: type 'Int' has no member 'MAX'\n    var min = -Int.MAX\n            \
    \   ~~~ ^~~\n/tmp/tmpdu0u6b85.swift:13:19: error: type 'Int' has no member 'MIN'\n\
    \    var max = Int.MIN\n              ~~~ ^~~\n/tmp/tmpdu0u6b85.swift:25:16: error:\
    \ no '+' candidates produce the expected contextual result type 'Double'\n   \
    \ return min + (max - min) / 2\n               ^\nSwift.Duration:6:24: note: '+'\
    \ produces 'Duration', not the expected contextual result type 'Double'\n    public\
    \ static func + (lhs: Duration, rhs: Duration) -> Duration\n                 \
    \      ^\n_Concurrency.ContinuousClock.Instant:9:35: note: '+' produces 'ContinuousClock.Instant',\
    \ not the expected contextual result type 'Double'\n    @inlinable public static\
    \ func + (lhs: ContinuousClock.Instant, rhs: Duration) -> ContinuousClock.Instant\n\
    \                                  ^\n_Concurrency.SuspendingClock.Instant:16:24:\
    \ note: '+' produces 'SuspendingClock.Instant', not the expected contextual result\
    \ type 'Double'\n    public static func + (lhs: SuspendingClock.Instant, rhs:\
    \ Duration) -> SuspendingClock.Instant\n                       ^\nSwift.AdditiveArithmetic:3:17:\
    \ note: '+' produces 'Duration', not the expected contextual result type 'Double'\n\
    \    static func + (lhs: Self, rhs: Self) -> Self\n                ^\nSwift.Duration:6:24:\
    \ note: '+' produces 'Duration', not the expected contextual result type 'Double'\n\
    \    public static func + (lhs: Duration, rhs: Duration) -> Duration\n       \
    \                ^\n_Concurrency.ContinuousClock.Instant:9:35: note: '+' produces\
    \ 'ContinuousClock.Instant', not the expected contextual result type 'Double'\n\
    \    @inlinable public static func + (lhs: ContinuousClock.Instant, rhs: Duration)\
    \ -> ContinuousClock.Instant\n             "
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    l.sort()\n    let middle = Int(l.count\
    \ / 2)\n    return Double(l[middle])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpt2ntkgge.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tvar s = 0.0;\n\tvar m = 0.0;\n\tvar n = 0.0;\n\
    \tfor k := 0..<l.count-1 {\n\t\ts += l[k];\n\t\tif l[k] > m {\n\t\t\tm = l[k];\n\
    \t\t}\n\t\tif l[k] < n {\n\t\t\tn = l[k];\n\t\t}\n\t}\n\treturn  s/(l.count-1);\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpun5kntiz.swift:11:9: error: expected type\n        for k := 0..<l.count-1\
    \ {\n               ^\n                <#type#>\n/tmp/tmpun5kntiz.swift:11:9:\
    \ error: expected 'in' after for-each pattern\n        for k := 0..<l.count-1\
    \ {\n               ^\n/tmp/tmpun5kntiz.swift:11:9: error: expected Sequence expression\
    \ for for-each loop\n        for k := 0..<l.count-1 {\n               ^\n/tmp/tmpun5kntiz.swift:20:20:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \        return  s/(l.count-1);\n                          ^\n               \
    \   Double(    )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let sortedL = l.sorted()\n    let mid =\
    \ sortedL.count / 2\n    if sortedL.count % 2 != 0 {\n        return (sortedL[mid]\
    \ + sortedL[mid-1]) / 2\n    }\n    return sortedL[mid]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp0htoozkg.swift:11:48: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return (sortedL[mid] + sortedL[mid-1])\
    \ / 2\n               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n               Double(\
    \                            )\n/tmp/tmp0htoozkg.swift:13:19: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n    return sortedL[mid]\n\
    \           ~~~~~~~^~~~~\n           Double(     )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    l.sort()\n    switch l.count {\n    case\
    \ 0:\n        return Double(Int.max)\n    case 1:\n        return l[0]\n    default:\n\
    \        let mid = (l.endIndex - l.startIndex) / 2.0\n        return (l[mid -\
    \ 1] + l[mid]) / 2.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpl1ngy25i.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmpl1ngy25i.swift:13:17:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return l[0]\n               ~^~~\n               Double( )\n/tmp/tmpl1ngy25i.swift:15:47:\
    \ error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'\n\
    \        let mid = (l.endIndex - l.startIndex) / 2.0\n                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~\n/tmp/tmpl1ngy25i.swift:15:47: note: overloads for '/' exist with these\
    \ partially matching parameter lists: (Double, Double), (Duration, Double), (Int,\
    \ Int)\n        let mid = (l.endIndex - l.startIndex) / 2.0\n                \
    \                              ^\n/tmp/tmpl1ngy25i.swift:16:28: error: cannot\
    \ convert value of type 'Int' to expected argument type 'Double'\n        return\
    \ (l[mid - 1] + l[mid]) / 2.0\n                           ^\n               Double(\
    \              )\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var v = l.sorted()\n  guard v.count > 1 else\
    \ { return v[0] }\n  var low = Double(v[0]),\n      high = Double(v[v.count -\
    \ 1])\n  guard low < high else { return v[0] }\n  while !(v[0] == 0 && v[v.count\
    \ - 1] == 0) && low + 1 < high {\n    low += 1\n  }\n  while !(v[0] == 0 && v[v.count\
    \ - 1] == 0) && low > high {\n    high -= 1\n  }\n  guard low >= high else { return\
    \ v[0] }\n  var med = (low + high) / 2\n  for i in 1..v.count - 1 {\n    if v[i]\
    \ < med {\n      med = v[i]\n    }\n  }\n  return med\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp8lfd4ivu.swift:9:36: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n  guard v.count > 1 else { return v[0] }\n\
    \                                  ~^~~\n                                  Double(\
    \ )\n/tmp/tmp8lfd4ivu.swift:12:35: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n  guard low < high else { return v[0] }\n\
    \                                 ~^~~\n                                 Double(\
    \ )\n/tmp/tmp8lfd4ivu.swift:19:36: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n  guard low >= high else { return v[0] }\n\
    \                                  ~^~~\n                                  Double(\
    \ )\n/tmp/tmp8lfd4ivu.swift:21:13: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n  for i in 1..v.count - 1 {\n            ^~\n         \
    \   ...\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var count = 0\n    var sum = Double(0.0)\n\
    \    for value in l {\n        sum += value\n        count += 1\n    }\n    return\
    \ sum / Double(count) \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpc5hb5n7q.swift:11:16: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n        sum += value\n               ^\n\
    \               Double( )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tvar sortedList = l.sorted()\n\tvar firstMiddleIndex\
    \ = sortedList.count / 2\n\tvar secondMiddleIndex = firstMiddleIndex + 1\n\tvar\
    \ thirdMiddleIndex = secondMiddleIndex + 1\n\tvar medianValue = sortedList[firstMiddleIndex]\n\
    \tif firstMiddleIndex > 0 {\n\t\tmedianValue = sortedList[secondMiddleIndex] +\
    \ (sortedList[thirdMiddleIndex] - sortedList[firstMiddleIndex])\n\t}\n\treturn\
    \ medianValue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpam5gl0r0.swift:16:9: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return medianValue\n           \
    \    ^~~~~~~~~~~\n               Double(    )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tif l == nil || l.isEmpty {\n\t\treturn 0\n\
    \t}\n\tvar i, j int // index and count\n\tvar n = l.count\n\n\tswitch l.count\
    \ {\n\tcase 0:\n\t\treturn 0\n\tcase 1:\n\t\treturn l[0]\n\tcase 2:\n\t\treturn\
    \ ((l[0] + l[1]) / 2)\n\tcase 3:\n\t\treturn ((l[0] + l[1] + l[2]) / 3)\n\tcase\
    \ 4:\n\t\treturn (((l[0] + l[1]) / 2) + l[2])\n\tcase 5:\n\t\treturn (((l[0] +\
    \ l[1]) / 2) + l[2] + l[3])\n\tcase 6:\n\t\treturn (((l[0] + l[1]) / 2) + l[2]\
    \ + l[3] + l[4])\n\tcase 7:\n\t\treturn (((l[0] + l[1]) / 2) + l[2] + l[3] + l[4]\
    \ + l[5])\n\tdefault:\n\t\tj := 1\n\t\ti = 2\n\t\tfor ; i <= n; i += j {\n\t\t\
    \tj++\n\t\t}\n\n\t\tswitch i {\n\t\tcase 1:\n\t\t\treturn ((l[0] + l[1]) / 2)\n\
    \t\tcase 2:\n\t\t\treturn ((l[0] + l[1] + l[2]) / 3)\n\t\tcase 3:\n\t\t\treturn\
    \ (((l[0] + l[1]) / 2) + l[2])\n\t\tcase 4:\n\t\t\treturn (((l[0] + l[1]) / 2)\
    \ + l[2] + l[3])\n\t\tcase 5:\n\t\t\treturn (((l[0] + l[1]) / 2) + l[2] + l[3]\
    \ + l[4])\n\t\tcase 6:\n\t\t\treturn (((l[0] + l[1]) / 2) + l[2] + l[3] + l[4]\
    \ + l[5])\n\t\tcase 7:\n\t\t\treturn (((l[0] + l[1]) / 2) + l[2] + l[3] + l[4]\
    \ + l[5] + l[6])\n\t\tdefault:\n\t\t\treturn l[(n - 1) / 2]\n\t\t}\n\t}\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpj5jm6fld.swift:11:11: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var i, j int\
    \ // index and count\n                 ^\n/tmp/tmpj5jm6fld.swift:11:11: note:\
    \ join the identifiers together\n        var i, j int // index and count\n   \
    \            ~~^~~\n               jint\n/tmp/tmpj5jm6fld.swift:11:11: note: join\
    \ the identifiers together with camel-case\n        var i, j int // index and\
    \ count\n               ~~^~~\n               jInt\n/tmp/tmpj5jm6fld.swift:32:4:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \       j := 1\n                 ^\n                 ;\n/tmp/tmpj5jm6fld.swift:32:5:\
    \ error: expected expression\n                j := 1\n                  ^\n/tmp/tmpj5jm6fld.swift:34:3:\
    \ error: C-style for statement has been removed in Swift 3\n                for\
    \ ; i <= n; i += j {\n                ^   ~~~~~~~~~~~~~~~~\n/tmp/tmpj5jm6fld.swift:8:7:\
    \ warning: comparing non-optional value of type '[Int]' to 'nil' always returns\
    \ false\n        if l == nil || l.isEmpty {\n           ~ ^  ~~~\n/tmp/tmpj5jm6fld.swift:11:6:\
    \ error: type annotation missing in pattern\n        var i, j int // index and\
    \ count\n            ^\n/tmp/tmpj5jm6fld.swift:11:9: error: type annotation missing\
    \ in pattern\n        var i, j int // index and count\n               ^\n/tmp/tmpj5jm6fld.swift:18:11:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \                return l[0]\n                       ~^~~\n                  \
    \     Double( )\n/tmp/tmpj5jm6fld.swift:20:25: error: cannot convert return expression\
    \ of type 'Int' to return type 'Double'\n                return ((l[0] + l[1])\
    \ / 2)\n                       ~~~~~~~~~~~~~~~^~~~\n                       Double(\
    \            )\n/tmp/tmpj5jm6fld.swift:22:32: error: cannot convert return expression\
    \ of type 'Int' to return type 'Double'\n                return ((l[0] + l[1]\
    \ + l[2]) / 3)\n                       ~~~~~~~~~~~~~~~~~~~~~~^~~~\n          \
    \             Double(                   )\n/tmp/tmpj5jm6fld.sw"
  stdout: ''
  timestamp: 1659978676
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var mid = ceil(l.count / 2)\n    if l.count\
    \ % 2 == 0 {\n        return Double(min(l[mid], l[mid-1]))\n    } else {\n   \
    \     return Double(max(l[mid], l[mid-1]))\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpbt7iiqzp.swift:8:15: error: cannot find 'ceil' in scope\n    var\
    \ mid = ceil(l.count / 2)\n              ^~~~\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let n = l.count\n    let minValue = l.min()\
    \ ?? 0\n    let maxValue = l.max() ?? 0\n\n    let midValue: Double = ((minValue\
    \ + maxValue) / 2.0).rounded(.toNearestOrAwayFromZero)\n\n    let counts: [Int]\
    \ = []\n    var sum = 0.0\n    for (index, value) in l.enumerated() {\n      \
    \  sum += value\n        guard let indexDouble = Double(index) else {\n      \
    \      fatalError(\"index \\(index) cannot be converted to Double\")\n       \
    \ }\n        if indexDouble == midValue {\n            counts.append(1)\n    \
    \    } else {\n            counts.append(0)\n        }\n    }\n    return sum\
    \ / Double(counts.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpqyfn_ycx.swift:12:39: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n    let midValue: Double = ((minValue +\
    \ maxValue) / 2.0).rounded(.toNearestOrAwayFromZero)\n                       \
    \               ^\n                            Double(              )\n/tmp/tmpqyfn_ycx.swift:17:16:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \        sum += value\n               ^\n               Double( )\n/tmp/tmpqyfn_ycx.swift:18:15:\
    \ error: initializer for conditional binding must have Optional type, not 'Double'\n\
    \        guard let indexDouble = Double(index) else {\n              ^       \
    \          ~~~~~~~~~~~~~\n/tmp/tmpqyfn_ycx.swift:22:20: error: cannot use mutating\
    \ member on immutable value: 'counts' is a 'let' constant\n            counts.append(1)\n\
    \            ~~~~~~ ^\n/tmp/tmpqyfn_ycx.swift:14:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let counts: [Int] = []\n    ^~~\n    var\n/tmp/tmpqyfn_ycx.swift:24:20:\
    \ error: cannot use mutating member on immutable value: 'counts' is a 'let' constant\n\
    \            counts.append(0)\n            ~~~~~~ ^\n/tmp/tmpqyfn_ycx.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let counts: [Int] = []\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    guard l.count > 1 else {\n        return\
    \ Double(l.sorted()[l.count / 2])\n    }\n    guard l.count % 2 == 0 else {\n\
    \        return median(l.sorted(), l.count / 2)\n    }\n    let median1 = median(l.sorted(),\
    \ l.count / 2)\n    let median2 = median(l.sorted().suffix(l.count / 2), l.count\
    \ / 2)\n    if median2 < median1 {\n        return median1\n    } else {\n   \
    \     return median2\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpdlv98m1d.swift:12:43: error: extra argument in call\n        return\
    \ median(l.sorted(), l.count / 2)\n                     ~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmpdlv98m1d.swift:14:46: error: extra argument in call\n    let median1 =\
    \ median(l.sorted(), l.count / 2)\n                        ~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmpdlv98m1d.swift:15:66: error: extra argument in call\n    let median2 =\
    \ median(l.sorted().suffix(l.count / 2), l.count / 2)\n                      \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var min = Double.leastPositiveFinite\n\
    \    var max = Double.greatestNegativeFinite\n    for val in l {\n        min\
    \ = min(min, val)\n        max = max(max, val)\n    }\n    return Double((max\
    \ + min) / 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp49wp7bl2.swift:8:22: error: type 'Double' has no member 'leastPositiveFinite'\n\
    \    var min = Double.leastPositiveFinite\n              ~~~~~~ ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp49wp7bl2.swift:9:22: error: type 'Double' has no member 'greatestNegativeFinite'\n\
    \    var max = Double.greatestNegativeFinite\n              ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.count <= 1 {\n        return 0.0\n\
    \    }\n    if l.count == 2 {\n        return l[0]\n    }\n    return Double(l[l.count\
    \ / 2])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpl_349j6f.swift:12:17: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l[0]\n               ~^~~\n\
    \               Double( )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let sorted = l.sorted()\n    if sorted.count\
    \ <= 1 {\n        return sorted[0]\n    }\n    return Double(sorted[sorted.count\
    \ / 2]) + Double(sorted[sorted.count / 2 - 1]) / 2\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp_ro0xqzu.swift:10:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return sorted[0]\n             \
    \  ~~~~~~^~~\n               Double(  )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l == nil {\n        return Double(0)\n\
    \    }\n\n    var m = Double(0)\n    var count = 0\n    for idx in l {\n     \
    \   count++\n        if idx == l[0] {\n            m = idx\n            break\n\
    \        }\n    }\n\n    if count > 1 {\n        var index = 0\n        var m1\
    \ = m\n        for idx in l {\n            if idx == l[index] {\n            \
    \    m1 = idx\n            } else {\n                m1 = Double(0)\n        \
    \        break\n            }\n            index++\n        }\n\n        // if\
    \ both indexes have same value\n        if m1 == m {\n            return m\n \
    \       }\n\n        // if both indexes have same value\n        if m1 == m {\n\
    \            return m\n        }\n\n        // if both indexes have different\
    \ value\n        return m1 + 0.5\n    }\n    return m\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpdrqvuyjp.swift:8:10: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns false\n    if l == nil {\n       ~ ^  ~~~\n\
    /tmp/tmpdrqvuyjp.swift:15:14: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        count++\n             ^~\n/tmp/tmpdrqvuyjp.swift:17:17:\
    \ error: cannot assign value of type 'Int' to type 'Double'\n            m = idx\n\
    \                ^~~\n                Double( )\n/tmp/tmpdrqvuyjp.swift:27:22:\
    \ error: cannot assign value of type 'Int' to type 'Double'\n                m1\
    \ = idx\n                     ^~~\n                     Double( )\n/tmp/tmpdrqvuyjp.swift:32:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  index++\n                 ^~\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tvar x = 0.0\n\tvar median = Double(0.0)\n\
    \tvar count = 0\n\tfor element in l {\n\t\tx += element\n\t\tcount += 1\n\t\t\
    if count > 1 {\n\t\t\tx = x / Double(count)\n\t\t}\n\t\tmedian = median + x\n\t\
    }\n\tmedian = median / Double(count)\n\treturn median\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpjmqtold7.swift:12:8: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n                x += element\n         \
    \            ^\n                     Double()\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var m = Double(0)\n    var count = 0\n\
    \    for x in l {\n        if x < m {\n            m = x\n            count =\
    \ 0\n        }\n        count += 1\n    }\n    if count <= 1 {\n        return\
    \ m\n    }\n    if count % 2 == 0 {\n        return (m + l[count-1]) / 2\n   \
    \ }\n    return (m - l[count-1]) / 2\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp7nye0p15.swift:11:14: error: binary operator '<' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n        if x < m {\n           ~ ^ ~\n\
    /tmp/tmp7nye0p15.swift:11:14: note: overloads for '<' exist with these partially\
    \ matching parameter lists: (Int, Int)\n        if x < m {\n             ^\n/tmp/tmp7nye0p15.swift:12:17:\
    \ error: cannot assign value of type 'Int' to type 'Double'\n            m = x\n\
    \                ^\n                Double( )\n/tmp/tmp7nye0p15.swift:21:22: error:\
    \ cannot convert value of type 'Int' to expected argument type 'Double'\n    \
    \    return (m + l[count-1]) / 2\n                     ^\n                   \
    \ Double(   )\n/tmp/tmp7nye0p15.swift:23:18: error: cannot convert value of type\
    \ 'Int' to expected argument type 'Double'\n    return (m - l[count-1]) / 2\n\
    \                 ^\n                Double(   )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  if l.count <= 1 {\n    return 0\n  }\n\n\
    \  let h = l.sorted()\n  return Double(h.mid())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpqytv1o51.swift:13:19: error: value of type '[Int]' has no member\
    \ 'mid'\n  return Double(h.mid())\n                ~ ^~~\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.isEmpty() {\n        return Double.nan\n\
    \    }\n    let s = l.sorted { $0 < $1 }\n    return (s.count - 1.0) / Double(s.count).rounded(.toNearestOrEven)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp5pr2b_3y.swift:8:10: error: cannot call value of non-function type\
    \ 'Bool'\n    if l.isEmpty() {\n         ^      ~~\n                \n/tmp/tmp5pr2b_3y.swift:12:15:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \    return (s.count - 1.0) / Double(s.count).rounded(.toNearestOrEven)\n    \
    \          ^\n            Double()\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var avg := 0\n    var count := 0\n    for\
    \ _, n in l.enumerated() {\n        avg += n\n        count++\n    }\n    if count\
    \ > 0 {\n        return avg / Double(count)\n    }\n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpjhdra16p.swift:8:14: error: expected type\n    var avg := 0\n \
    \            ^\n              <#type#>\n/tmp/tmpjhdra16p.swift:9:16: error: expected\
    \ type\n    var count := 0\n               ^\n                <#type#>\n/tmp/tmpjhdra16p.swift:10:10:\
    \ error: expected 'in' after for-each pattern\n    for _, n in l.enumerated()\
    \ {\n         ^\n/tmp/tmpjhdra16p.swift:10:10: error: expected Sequence expression\
    \ for for-each loop\n    for _, n in l.enumerated() {\n         ^\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let n = l.count\n    let mut m = Double.zero\n\
    \    let mut largest = Double.nan\n    for e in l.reversed() {\n        m += e\n\
    \        if m > largest {\n            largest = m\n        }\n    }\n    return\
    \ largest / Double(n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp1w_z2lvw.swift:9:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut m = Double.zero\n\
    \            ^\n/tmp/tmp1w_z2lvw.swift:9:13: note: join the identifiers together\n\
    \    let mut m = Double.zero\n        ~~~~^\n        mutm\n/tmp/tmp1w_z2lvw.swift:9:13:\
    \ note: join the identifiers together with camel-case\n    let mut m = Double.zero\n\
    \        ~~~~^\n        mutM\n/tmp/tmp1w_z2lvw.swift:10:13: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \   let mut largest = Double.nan\n            ^\n/tmp/tmp1w_z2lvw.swift:10:13:\
    \ note: join the identifiers together\n    let mut largest = Double.nan\n    \
    \    ~~~~^~~~~~~\n        mutlargest\n/tmp/tmp1w_z2lvw.swift:10:13: note: join\
    \ the identifiers together with camel-case\n    let mut largest = Double.nan\n\
    \        ~~~~^~~~~~~\n        mutLargest\n/tmp/tmp1w_z2lvw.swift:10:9: error:\
    \ invalid redeclaration of 'mut'\n    let mut largest = Double.nan\n        ^\n\
    /tmp/tmp1w_z2lvw.swift:9:9: note: 'mut' previously declared here\n    let mut\
    \ m = Double.zero\n        ^\n/tmp/tmp1w_z2lvw.swift:12:9: error: cannot find\
    \ 'm' in scope\n        m += e\n        ^\n/tmp/tmp1w_z2lvw.swift:13:12: error:\
    \ cannot find 'm' in scope\n        if m > largest {\n           ^\n/tmp/tmp1w_z2lvw.swift:13:16:\
    \ error: cannot find 'largest' in scope\n        if m > largest {\n          \
    \     ^~~~~~~\n/tmp/tmp1w_z2lvw.swift:14:13: error: cannot find 'largest' in scope\n\
    \            largest = m\n            ^~~~~~~\n/tmp/tmp1w_z2lvw.swift:14:23: error:\
    \ cannot find 'm' in scope\n            largest = m\n                      ^\n\
    /tmp/tmp1w_z2lvw.swift:17:12: error: cannot find 'largest' in scope\n    return\
    \ largest / Double(n)\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    // find middle of array\n    // return\
    \ average of middle 2 elements\n    let len = (l as NSArray).count / 2\n    let\
    \ median = (l[Int(len)] as Double) + (l[Int(len - 1)] * (1.0 - (l[Int(len)] as\
    \ Double)))\n    return median\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmppl_nqws8.swift:10:21: error: cannot find type 'NSArray' in scope\n\
    \    let len = (l as NSArray).count / 2\n                    ^~~~~~~\n/tmp/tmppl_nqws8.swift:11:46:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \    let median = (l[Int(len)] as Double) + (l[Int(len - 1)] * (1.0 - (l[Int(len)]\
    \ as Double)))\n                                             ^\n             \
    \                               Double(        )\n/tmp/tmppl_nqws8.swift:11:31:\
    \ error: cannot convert value of type 'Int' to type 'Double' in coercion\n   \
    \ let median = (l[Int(len)] as Double) + (l[Int(len - 1)] * (1.0 - (l[Int(len)]\
    \ as Double)))\n                  ~~~~~~~~~~~~^~~~~~~~~\n                  Double(\
    \              )\n/tmp/tmppl_nqws8.swift:11:83: error: cannot convert value of\
    \ type 'Int' to type 'Double' in coercion\n    let median = (l[Int(len)] as Double)\
    \ + (l[Int(len - 1)] * (1.0 - (l[Int(len)] as Double)))\n                    \
    \                                                  ~~~~~~~~~~~~^~~~~~~~~\n   \
    \                                                                   Double(  \
    \            )\n"
  stdout: ''
  timestamp: 1659978547
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var n = l.count\n    guard n > 1 else {\
    \ return Double(l.first) }\n    var sum = l.map { $0 + $1 }.reduce(0, combine:\
    \ +) / Double(n)\n    for element in l.dropFirst() {\n        let difference =\
    \ sum - element\n        sum -= element\n        if difference > 0 { return Double(element)\
    \ }\n    }\n    return Double(sum)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpnrtpgn5m.swift:9:40: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard n > 1 else { return Double(l.first)\
    \ }\n                                       ^\n/tmp/tmpnrtpgn5m.swift:9:40: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    guard n > 1 else { return Double(l.first) }\n                           \
    \            ^\n                                             ?? <#default value#>\n\
    /tmp/tmpnrtpgn5m.swift:9:40: note: force-unwrap using '!' to abort execution if\
    \ the optional value contains 'nil'\n    guard n > 1 else { return Double(l.first)\
    \ }\n                                       ^\n                              \
    \              !\n/tmp/tmpnrtpgn5m.swift:10:21: error: contextual closure type\
    \ '(Int) throws -> Double' expects 1 argument, but 2 were used in closure body\n\
    \    var sum = l.map { $0 + $1 }.reduce(0, combine: +) / Double(n)\n         \
    \           ^\n/tmp/tmpnrtpgn5m.swift:10:39: error: extraneous argument label\
    \ 'combine:' in call\n    var sum = l.map { $0 + $1 }.reduce(0, combine: +) /\
    \ Double(n)\n                                      ^   ~~~~~~~~~\n           \
    \                               \n"
  stdout: ''
  timestamp: 1659978554
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var sortedArr = l.sorted()\n    var mid\
    \ = sortedArr.count/2\n    return sortedArr[mid]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmptdr4gg8j.swift:10:21: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return sortedArr[mid]\n           ~~~~~~~~~^~~~~\n\
    \           Double(       )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  if l.isEmpty {\n    return Double.nan\n \
    \ }\n  let (low, high) = l.span()\n  return (low + high) / 2.0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp_zlb4xb6.swift:11:23: error: value of type '[Int]' has no member\
    \ 'span'\n  let (low, high) = l.span()\n                    ~ ^~~~\n/tmp/tmp_zlb4xb6.swift:12:15:\
    \ error: cannot convert value of type 'String' to expected argument type 'Double'\n\
    \  return (low + high) / 2.0\n              ^\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let min = min(l)\n    let max = max(l)\n\
    \    guard min < max else { return Double(0.0) }\n    return (l.sorted().last?.pointee\
    \ ?? Double(l.last!))\n        + ((l.sorted { $0 < $1 }.first?.pointee ?? Double(l.first!))\n\
    \            - min) / Double(max.pointee - min.pointee)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp9mi_npqx.swift:8:20: error: missing argument for parameter #2 in\
    \ call\n    let min = min(l)\n                   ^\n                   , <#[Int]#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp9mi_npqx.swift:9:20:\
    \ error: missing argument for parameter #2 in call\n    let max = max(l)\n   \
    \                ^\n                   , <#[Int]#>\nSwift.max:1:24: note: 'max'\
    \ declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n/tmp/tmp9mi_npqx.swift:11:12: error: the\
    \ compiler is unable to type-check this expression in reasonable time; try breaking\
    \ up the expression into distinct sub-expressions\n    return (l.sorted().last?.pointee\
    \ ?? Double(l.last!))\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978572
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    l.sort()\n    return Double(l[len(l) /\
    \ 2])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpidq5vtuh.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmpidq5vtuh.swift:9:21:\
    \ error: cannot find 'len' in scope\n    return Double(l[len(l) / 2])\n      \
    \              ^~~\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l = l as! [Int]\n    var pivot: Int\n\
    \    var length: Int\n    var middle: Int\n    pivot = l.count / 2\n    middle\
    \ = pivot % l.count\n    if l.count % 2 == 0 {\n        return l[middle]\n   \
    \ }\n    length = pivot - middle\n    if length > 0 {\n        return median(l[..middle])\n\
    \    } else {\n        return median(l.suffix(middle))\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpde4_i3pj.swift:8:15: warning: forced cast of '[Int]' to same type\
    \ has no effect\n    var l = l as! [Int]\n              ^~~~~~~~~\n          \
    \    \n/tmp/tmpde4_i3pj.swift:15:17: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l[middle]\n             \
    \  ~^~~~~~~~\n               Double(  )\n/tmp/tmpde4_i3pj.swift:19:25: error:\
    \ cannot find operator '..' in scope; did you mean '...'?\n        return median(l[..middle])\n\
    \                        ^~\n                        ...\n/tmp/tmpde4_i3pj.swift:19:23:\
    \ error: missing argument label 'l:' in call\n        return median(l[..middle])\n\
    \                      ^\n                      l: \n/tmp/tmpde4_i3pj.swift:21:23:\
    \ error: missing argument label 'l:' in call\n        return median(l.suffix(middle))\n\
    \                      ^\n                      l: \n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var even = 0.0, odd = 0.0\n    for element\
    \ in l {\n        if element % 2 == 0 {\n            even += element\n       \
    \ } else {\n            odd += element\n        }\n    }\n    return (even + odd)\
    \ / Double(l.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpey0h5q30.swift:11:21: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n            even += element\n          \
    \          ^\n                    Double()\n/tmp/tmpey0h5q30.swift:13:20: error:\
    \ cannot convert value of type 'Int' to expected argument type 'Double'\n    \
    \        odd += element\n                   ^\n                   Double()\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let count = countElements(l)\n    var low\
    \ = Double(0)\n    var high = Double(0)\n    for x in l {\n        if x < low\
    \ {\n            low = x\n        }\n        if x > high {\n            high =\
    \ x\n        }\n    }\n    if count <= 1 {\n        return low\n    }\n    if\
    \ count == 2 {\n        return low + (high - low) / 2.0\n    }\n    var median\
    \ = (low + high) / 2.0\n    for x in l {\n        if x < median {\n          \
    \  median = x\n        }\n    }\n    return median\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp4ztmta24.swift:8:17: error: cannot find 'countElements' in scope\n\
    \    let count = countElements(l)\n                ^~~~~~~~~~~~~\n/tmp/tmp4ztmta24.swift:12:14:\
    \ error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \        if x < low {\n           ~ ^ ~~~\n/tmp/tmp4ztmta24.swift:12:14: note:\
    \ overloads for '<' exist with these partially matching parameter lists: (Int,\
    \ Int)\n        if x < low {\n             ^\n/tmp/tmp4ztmta24.swift:13:19: error:\
    \ cannot assign value of type 'Int' to type 'Double'\n            low = x\n  \
    \                ^\n                  Double( )\n/tmp/tmp4ztmta24.swift:15:14:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \        if x > high {\n           ~ ^ ~~~~\n/tmp/tmp4ztmta24.swift:15:14: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n        if x > high {\n             ^\n/tmp/tmp4ztmta24.swift:16:20: error:\
    \ cannot assign value of type 'Int' to type 'Double'\n            high = x\n \
    \                  ^\n                   Double( )\n/tmp/tmp4ztmta24.swift:27:14:\
    \ error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \        if x < median {\n           ~ ^ ~~~~~~\n/tmp/tmp4ztmta24.swift:27:14:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if x < median {\n             ^\n/tmp/tmp4ztmta24.swift:28:22:\
    \ error: cannot assign value of type 'Int' to type 'Double'\n            median\
    \ = x\n                     ^\n                     Double( )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let sorted = l.sorted()\n    let mid =\
    \ sorted.count / 2\n    var x = sorted.firstIndex(of: mid)!\n    var y = sorted.lastIndex(of:\
    \ mid)!\n    var largest = 0\n    if x < y {\n        largest = y\n    } else\
    \ {\n        largest = x\n    }\n    guard mid > 0 else {\n        return sorted[largest]\n\
    \    }\n    var index = largest\n    while index < sorted.count {\n        if\
    \ sorted[index] == mid {\n            break\n        }\n        index++\n    }\n\
    \    if index == sorted.count {\n        return mid\n    }\n    var median_i =\
    \ index\n    var median_j = index\n    while median_j < sorted.count && sorted[median_j]\
    \ == mid {\n        median_j++\n    }\n    if median_j == sorted.count {\n   \
    \     return mid\n    }\n    while median_i < sorted.count && sorted[median_i]\
    \ == mid {\n        median_i++\n    }\n    if median_i == sorted.count {\n   \
    \     return mid\n    }\n    if sorted[median_i] < sorted[median_j] {\n      \
    \  median_i, median_j = median_j, median_i\n    }\n    var left_i = median_i\n\
    \    var right_j = median_j\n    var median = (sorted[left_i] + sorted[right_j])\
    \ / 2\n    while left_i < median_j && right_j < sorted.count {\n        if sorted[left_i]\
    \ < sorted[right_j] {\n            left_i += 1;\n            right_j += 1;\n \
    \       } else {\n            left_i += 1;\n        }\n    }\n    if left_i ==\
    \ median_j {\n        return sorted[median_j]\n    }\n    if right_j == sorted.count\
    \ {\n        return sorted[median_j]\n    }\n    if sorted[left_i] < sorted[right_j]\
    \ {\n        median = sorted[left_i]\n    } else {\n        median = sorted[right_j]\n\
    \    }\n    return median\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp8ijjmhps.swift:46:17: error: consecutive statements on a line must\
    \ be separated by ';'\n        median_i, median_j = median_j, median_i\n     \
    \           ^\n                ;\n/tmp/tmp8ijjmhps.swift:46:17: error: expected\
    \ expression\n        median_i, median_j = median_j, median_i\n              \
    \  ^\n/tmp/tmp8ijjmhps.swift:19:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return sorted[largest]\n       \
    \        ~~~~~~^~~~~~~~~\n               Double(        )\n/tmp/tmp8ijjmhps.swift:26:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n/tmp/tmp8ijjmhps.swift:29:16: error: cannot convert return expression\
    \ of type 'Int' to return type 'Double'\n        return mid\n               ^~~\n\
    \               Double( )\n/tmp/tmp8ijjmhps.swift:34:17: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        median_j++\n                ^~\n\
    /tmp/tmp8ijjmhps.swift:37:16: error: cannot convert return expression of type\
    \ 'Int' to return type 'Double'\n        return mid\n               ^~~\n    \
    \           Double( )\n/tmp/tmp8ijjmhps.swift:40:17: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        median_i++\n                ^~\n\
    /tmp/tmp8ijjmhps.swift:43:16: error: cannot convert return expression of type\
    \ 'Int' to return type 'Double'\n        return mid\n               ^~~\n    \
    \           Double( )\n/tmp/tmp8ijjmhps.swift:46:9: warning: variable is unused\n\
    \        median_i, median_j = median_j, median_i\n        ^~~~~~~~\n/tmp/tmp8ijjmhps.swift:60:22:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return sorted[median_j]\n               ~~~~~~^~~~~~~~~~\n          \
    \     Double(         )\n/tmp/tmp8ijjmhps.swift:63:22: error: cannot convert return\
    \ expression of type 'Int' to return type 'Double'\n        return sorted[median_j]\n\
    \               ~~~~~~^~~~~~~~~~\n               Double(         )\n/tmp/tmp8ijjmhps.swift:70:12:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \ "
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l = [Int](l)\n    if l.count == 0 {\n\
    \        return 0\n    }\n    if l.count > 1 {\n        return midpoint(l)\n \
    \   }\n    return l[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpxy7w32vw.swift:13:16: error: cannot find 'midpoint' in scope\n\
    \        return midpoint(l)\n               ^~~~~~~~\n/tmp/tmpxy7w32vw.swift:15:13:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \    return l[0]\n           ~^~~\n           Double( )\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tl.sort()\n\tvar mid = Double(l.length) /\
    \ 2.0\n\treturn l[mid]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpvw3frsw0.swift:8:4: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n        l.sort()\n        ~ ^\n/tmp/tmpvw3frsw0.swift:9:21:\
    \ error: value of type '[Int]' has no member 'length'\n        var mid = Double(l.length)\
    \ / 2.0\n                         ~ ^~~~~~\n/tmp/tmpvw3frsw0.swift:10:10: error:\
    \ no 'subscript' candidates produce the expected contextual result type 'Double'\n\
    \        return l[mid]\n                ^\nSwift.Array:16:23: note: 'subscript(_:)'\
    \ produces 'Int', not the expected contextual result type 'Double'\n    @inlinable\
    \ public subscript(index: Int) -> Element { get set }\n                      ^\n\
    Swift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected\
    \ contextual result type 'Double'\n    @inlinable public subscript(bounds: Range<Int>)\
    \ -> ArraySlice<Element> { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659978541
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return Double(l.sorted().removeLast().hashValue\
    \ % Double(l.count)) / Double(l.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpzs75nzeu.swift:8:55: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n    return Double(l.sorted().removeLast().hashValue\
    \ % Double(l.count)) / Double(l.count)\n                                     \
    \                 ^\n                                                      Int(\
    \           )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    \n    var m = 0.0\n    var c = 0.\n   \
    \ var i = 0\n    var j = 0\n    var n = l.count\n    \n    while i < n {\n   \
    \     \n        if l[j] == 0.0 {\n            \n            i += 1\n         \
    \   \n            if i == n {\n                \n                break\n     \
    \       }\n            \n        } else {\n            \n            if c < 0.0\
    \ {\n                \n                j += 1.0\n                \n          \
    \      if j == n {\n                    \n                    break\n        \
    \        }\n                \n            }\n            \n            m += l[j]\
    \ / c\n            \n            c += 1.0\n            \n            i += 1\n\
    \            \n        }\n    }\n    \n    return m\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpl37jofsu.swift:10:14: error: expected member name following '.'\n\
    \    var c = 0.\n             ^\n/tmp/tmpl37jofsu.swift:17:17: error: binary operator\
    \ '==' cannot be applied to operands of type 'Int' and 'Double'\n        if l[j]\
    \ == 0.0 {\n           ~~~~ ^  ~~~\n/tmp/tmpl37jofsu.swift:17:17: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Int, Int)\n \
    \       if l[j] == 0.0 {\n                ^\n/tmp/tmpl37jofsu.swift:30:22: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \            j += 1.0\n                     ^\n                     Int( )\n/tmp/tmpl37jofsu.swift:39:23:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \            m += l[j] / c\n                      ^\n                 Double(\
    \ )\n/tmp/tmpl37jofsu.swift:39:23: error: binary operator '/' cannot be applied\
    \ to operands of type 'Int' and 'Duration'\n            m += l[j] / c\n      \
    \           ~~~~ ^ ~\n/tmp/tmpl37jofsu.swift:39:23: note: overloads for '/' exist\
    \ with these partially matching parameter lists: (Double, Double), (Duration,\
    \ Duration), (Int, Int)\n            m += l[j] / c\n                      ^\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  if l == nil {\n    return Double.nan\n  }\n\
    \  switch l.count {\n  case 0:\n    return Double.nan\n  case 1:\n    return l[0]\n\
    \  default:\n    median := l[0]\n    for i in 1 ..< l.count {\n      if l[i] >\
    \ median {\n        median = l[i]\n      }\n    }\n    return median\n  }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpgz_0f2ya.swift:17:11: error: consecutive statements on a line must\
    \ be separated by ';'\n    median := l[0]\n          ^\n          ;\n/tmp/tmpgz_0f2ya.swift:17:12:\
    \ error: expected expression\n    median := l[0]\n           ^\n/tmp/tmpgz_0f2ya.swift:8:8:\
    \ warning: comparing non-optional value of type '[Int]' to 'nil' always returns\
    \ false\n  if l == nil {\n     ~ ^  ~~~\n/tmp/tmpgz_0f2ya.swift:15:13: error:\
    \ cannot convert return expression of type 'Int' to return type 'Double'\n   \
    \ return l[0]\n           ~^~~\n           Double( )\n/tmp/tmpgz_0f2ya.swift:17:5:\
    \ error: function is unused\n    median := l[0]\n    ^~~~~~\n/tmp/tmpgz_0f2ya.swift:19:15:\
    \ error: type '([Int]) -> Double' cannot conform to 'BinaryInteger'\n      if\
    \ l[i] > median {\n              ^\n/tmp/tmpgz_0f2ya.swift:19:15: note: only concrete\
    \ types such as structs, enums and classes can conform to protocols\n      if\
    \ l[i] > median {\n              ^\n/tmp/tmpgz_0f2ya.swift:19:15: note: required\
    \ by operator function '>' where 'Other' = '([Int]) -> Double'\n      if l[i]\
    \ > median {\n              ^\n/tmp/tmpgz_0f2ya.swift:20:9: error: cannot assign\
    \ to value: 'median' is a function\n        median = l[i]\n        ^~~~~~\n/tmp/tmpgz_0f2ya.swift:23:12:\
    \ error: cannot convert return expression of type '([Int]) -> Double' to return\
    \ type 'Double'\n    return median\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.count < 1 {\n        return Double(0.0)\n\
    \    }\n    return l.sorted()[l.count / 2] ?? Double(l.sorted()[l.count / 2])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmps_xxrl16.swift:11:36: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return l.sorted()[l.count / 2] ?? Double(l.sorted()[l.count\
    \ / 2])\n           ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \           Double(                                                   )\n/tmp/tmps_xxrl16.swift:11:39:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \    return l.sorted()[l.count / 2] ?? Double(l.sorted()[l.count / 2])\n     \
    \                                 ^\n                                      Int(\
    \                           )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  if l == nil {\n    return Double(0)\n  }\n\
    \  l.sort()\n  let mid = l.count / 2\n  if l.count % 2 == 1 {\n    return l[mid]\n\
    \  }\n  let firstHalf = l[0 : mid]\n  let secondHalf = l[mid..<l.count]\n  return\
    \ firstHalf.reduce(0.0, +) / (firstHalf.count + secondHalf.count) * 0.5 + secondHalf.reduce(0.0,\
    \ +) / (secondHalf.count + firstHalf.count) * 0.5\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmprns7nurb.swift:16:23: error: expected ',' separator\n  let firstHalf\
    \ = l[0 : mid]\n                      ^\n                     ,\n/tmp/tmprns7nurb.swift:16:23:\
    \ error: expected expression in list of expressions\n  let firstHalf = l[0 : mid]\n\
    \                      ^\n/tmp/tmprns7nurb.swift:8:8: warning: comparing non-optional\
    \ value of type '[Int]' to 'nil' always returns false\n  if l == nil {\n     ~\
    \ ^  ~~~\n/tmp/tmprns7nurb.swift:11:5: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n  l.sort()\n  ~ ^\n/tmp/tmprns7nurb.swift:14:13:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \    return l[mid]\n           ~^~~~~\n           Double( )\n/tmp/tmprns7nurb.swift:18:10:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n  return firstHalf.reduce(0.0,\
    \ +) / (firstHalf.count + secondHalf.count) * 0.5 + secondHalf.reduce(0.0, +)\
    \ / (secondHalf.count + firstHalf.count) * 0.5\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978632
- exit_code: -4
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    switch l.count {\n    case 0: return Double(0)\n\
    \    case 1: return Double(l[0])\n    case 2: return Double(l[0]) + Double(l[1])\n\
    \    case 3: return Double(l[0]) + Double(l[1]) + Double(l[2])\n    default:\n\
    \        let sortedArray = l.sorted()\n        let middle = Int(l.count / 2)\n\
    \        return Double(sortedArray[middle - 1]) + Double(sortedArray[middle])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: Exception
  stderr: 'tmpygjc5vnt/tmpygjc5vnt.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adaf5c58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adaf594fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adaf594f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adaf594e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpygjc5vnt                        0x0000562176011641 <unavailable> + 5697

    5    libc.so.6                          0x00002adaf5e44460 __libc_start_main +
    245

    6    tmpygjc5vnt                        0x0000562176011289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978542
- exit_code: -4
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let l = l.sorted()\n    return Double(l.count\
    \ % 2 == 0 ? l[l.count / 2 - 1] : (l.count + 1) / 2)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: Exception
  stderr: 'tmply4_rul_/tmply4_rul_.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2fe9550c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2fe9247b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2fe9247988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2fe92467b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmply4_rul_                        0x0000563961a3e5ed <unavailable> + 5613

    5    libc.so.6                          0x00002b2fe973c460 __libc_start_main +
    245

    6    tmply4_rul_                        0x0000563961a3e149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return statArray(l, median)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpql8plue1.swift:8:12: error: cannot find 'statArray' in scope\n\
    \    return statArray(l, median)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return Double.max((l.sorted { $0 < $1 }).last!)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpy7f9qn2s.swift:8:19: error: type 'Double' has no member 'max'\n\
    \    return Double.max((l.sorted { $0 < $1 }).last!)\n           ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    guard l.count > 0 else { return 0.0 }\n\
    \    var sorted: Double = 0.0\n    var min: Double = -1000000000000000.0\n   \
    \ var max: Double = 1000000000000000.0\n    var median: Double = 0.0\n    var\
    \ pos: Int = 0\n    for (pos, e) in l.enumerated() {\n        sorted += Double(e)\n\
    \        if Double(e) < min { min = Double(e) }\n        if Double(e) > max {\
    \ max = Double(e) }\n    }\n    median = sorted / Double(l.count)\n    if min\
    \ == -1000000000000000.0 {\n        if median != 0.0 { median = -median }\n  \
    \  } else {\n        if median != 0.0 {\n            if median >= 0.0 { median\
    \ = -median }\n            if median <= 0.0 { median = median }\n        }\n \
    \   }\n    return median\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp_1fgir0z.swift:25:39: error: assigning a variable to itself\n \
    \           if median <= 0.0 { median = median }\n                           \
    \    ~~~~~~ ^ ~~~~~~\n/tmp/tmp_1fgir0z.swift:13:9: warning: variable 'pos' was\
    \ never used; consider replacing with '_' or removing it\n    var pos: Int = 0\n\
    \        ^~~\n        _\n/tmp/tmp_1fgir0z.swift:14:10: warning: immutable value\
    \ 'pos' was never used; consider replacing with '_' or removing it\n    for (pos,\
    \ e) in l.enumerated() {\n         ^~~\n         _\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return sort.median(l: l)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpwvyihmhk.swift:8:12: error: cannot find 'sort' in scope\n    return\
    \ sort.median(l: l)\n           ^~~~\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    // Fast path to quickly return median if\
    \ array is of length 0 or 1.\n    if l.isEmpty || l.count == 1 {\n        return\
    \ l[0]\n    }\n    \n    sortByNumber(l)\n    \n    // If length of array is odd\
    \ then median is at middle - 1.\n    // Otherwise it is at middle + 1.\n    let\
    \ (mid, leftHalf, rightHalf) = (l.count / 2, l.dropFirst(), l.dropLast())\n  \
    \  \n    // If length is odd, median is at middle - 1.\n    if rightHalf.isEmpty\
    \ {\n        return Double(mid)\n    }\n    \n    // If length is even, median\
    \ is at middle + 1.\n    if leftHalf.isEmpty {\n        return Double(mid)\n \
    \   }\n    \n    let pivot = l[mid]\n    \n    let leftHalfCount = leftHalf.count\n\
    \    let rightHalfCount = rightHalf.count\n    \n    switch {\n    case leftHalfCount\
    \ > rightHalfCount:\n        return leftHalf[mid]\n    case leftHalfCount < rightHalfCount:\n\
    \        return rightHalf[mid]\n    case leftHalfCount == rightHalfCount:\n  \
    \      // If there are more than one element in both left and right halves then\
    \ median is in between both\n        if leftHalfCount > 1 {\n            return\
    \ Double(leftHalf[0] + rightHalf[mid - 1])\n        }\n        return Double(leftHalf[0])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmperdk_luc.swift:34:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n/tmp/tmperdk_luc.swift:10:17: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n        return l[0]\n\
    \               ~^~~\n               Double( )\n/tmp/tmperdk_luc.swift:13:5: error:\
    \ cannot find 'sortByNumber' in scope\n    sortByNumber(l)\n    ^~~~~~~~~~~~\n\
    /tmp/tmperdk_luc.swift:36:24: error: cannot convert return expression of type\
    \ 'Int' to return type 'Double'\n        return leftHalf[mid]\n              \
    \ ~~~~~~~~^~~~~\n               Double(      )\n/tmp/tmperdk_luc.swift:38:25:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return rightHalf[mid]\n               ~~~~~~~~~^~~~~\n              \
    \ Double(       )\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  return median(l.map{Double($0)})\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmparihhm18.swift:8:17: error: missing argument label 'l:' in call\n\
    \  return median(l.map{Double($0)})\n                ^\n                l: \n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    l.sort()\n    if l.count % 2 == 1 {\n \
    \       // Odd number of elements\n        return (l[(l.count - 1) / 2] + l[(l.count\
    \ - 1) / 2].offsetByExact(1)) / 2\n    } else {\n        // Even number of elements\n\
    \        return l[(l.count - 1) / 2]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpbi0yhyrd.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmpbi0yhyrd.swift:11:79:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return (l[(l.count - 1) / 2] + l[(l.count - 1) / 2].offsetByExact(1))\
    \ / 2\n               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n\
    \               Double(                                                      \
    \     )\n/tmp/tmpbi0yhyrd.swift:11:61: error: value of type 'Int' has no member\
    \ 'offsetByExact'\n        return (l[(l.count - 1) / 2] + l[(l.count - 1) / 2].offsetByExact(1))\
    \ / 2\n                                       ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpbi0yhyrd.swift:14:17: error: cannot convert return expression of type\
    \ 'Int' to return type 'Double'\n        return l[(l.count - 1) / 2]\n       \
    \        ~^~~~~~~~~~~~~~~~~~~\n               Double(             )\n"
  stdout: ''
  timestamp: 1659978547
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var min: Double = Double.infinity\n  var\
    \ max: Double = -Double.infinity\n  for v in l {\n    if v < min {\n      min\
    \ = v\n    }\n    if v > max {\n      max = v\n    }\n  }\n  if min > max {\n\
    \    return Double.nan\n  }\n  if min == Double.infinity {\n    return max\n \
    \ }\n  if max == Double.infinity {\n    return min\n  }\n  return (min + max)\
    \ / 2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmplwovh_k9.swift:11:10: error: binary operator '<' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    if v < min {\n       ~ ^ ~~~\n/tmp/tmplwovh_k9.swift:11:10:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    if v < min {\n         ^\n/tmp/tmplwovh_k9.swift:12:13: error:\
    \ cannot assign value of type 'Int' to type 'Double'\n      min = v\n        \
    \    ^\n            Double( )\n/tmp/tmplwovh_k9.swift:14:10: error: binary operator\
    \ '>' cannot be applied to operands of type 'Int' and 'Double'\n    if v > max\
    \ {\n       ~ ^ ~~~\n/tmp/tmplwovh_k9.swift:14:10: note: overloads for '>' exist\
    \ with these partially matching parameter lists: (Int, Int)\n    if v > max {\n\
    \         ^\n/tmp/tmplwovh_k9.swift:15:13: error: cannot assign value of type\
    \ 'Int' to type 'Double'\n      max = v\n            ^\n            Double( )\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l1 = l.sort()\n    if (l1.count ==\
    \ 0) {\n        return 0\n    }\n    if (l1.count % 2 == 0) {\n        return\
    \ l1[(l1.count - 1) / 2]\n    }\n    else {\n        var m = (l1.count - 1) /\
    \ 2\n        return Double(l1[m]) + Double(l1[m + 1])\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpy6o8eo_b.swift:8:16: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    var l1 = l.sort()\n             ~ ^\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  var min = l[0]\n  var max = l[0]\n  for el\
    \ in l {\n    if min > el {\n      min = el\n    }\n    if max < el {\n      max\
    \ = el\n    }\n  }\n  return min + (max - min) / 2\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp8v9suzqi.swift:18:14: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n  return min + (max - min) / 2\n       \
    \  ~~~~^~~~~~~~~~~~~~~~~\n         Double(              )\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l = Array(l)\n    if l.count < 2 {\n\
    \        return 0.\n    }\n    var a = l[0]\n    var b = l[1]\n    var c = l[0]\n\
    \    var d = l[1]\n    var mid = 0\n    var midVal = 0.\n    for i = 2; i < l.count;\
    \ i++ {\n        if l[i] < a {\n            a = l[i]\n        }\n        if l[i]\
    \ > b {\n            b = l[i]\n        }\n    }\n    for (i = 1; i < l.count;\
    \ i++ {\n        if l[i] < a {\n            d = c\n            c = l[i]\n    \
    \    }\n        if l[i] > b {\n            d = c\n            c = l[i]\n     \
    \   }\n    }\n    mid = Double(l.count / 2)\n    if a < b {\n        midVal =\
    \ c / 2\n    }\n    if b < c {\n        midVal = c / 2\n    }\n    if a > b {\n\
    \        midVal = c / 2\n    }\n    if b > c {\n        midVal = c / 2\n    }\n\
    \    if a < b {\n        midVal = c / 2\n    }\n    return midVal\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpjdkkdb0y.swift:10:17: error: expected member name following '.'\n\
    \        return 0.\n                ^\n/tmp/tmpjdkkdb0y.swift:17:19: error: expected\
    \ member name following '.'\n    var midVal = 0.\n                  ^\n/tmp/tmpjdkkdb0y.swift:18:5:\
    \ error: C-style for statement has been removed in Swift 3\n    for i = 2; i <\
    \ l.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjdkkdb0y.swift:26:5:\
    \ error: C-style for statement has been removed in Swift 3\n    for (i = 1; i\
    \ < l.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjdkkdb0y.swift:52:18:\
    \ error: expected '{' to start the body of for-each loop\n    return midVal\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.count <= 1 {\n        return l[0]\n\
    \    }\n    if l.count <= 2 {\n        return l.sorted()[0] + (l.sorted()[1] -\
    \ l.sorted()[0]) / 2\n    }\n    var m = l.sorted()[0]\n    for x in l.sorted()[1..]\
    \ {\n        if x < m {\n            m = x\n        }\n    }\n    return m\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp3to7csh_.swift:9:17: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l[0]\n               ~^~~\n\
    \               Double( )\n/tmp/tmp3to7csh_.swift:12:30: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n        return l.sorted()[0]\
    \ + (l.sorted()[1] - l.sorted()[0]) / 2\n               ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \               Double(                                            )\n/tmp/tmp3to7csh_.swift:15:26:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n    for x in\
    \ l.sorted()[1..] {\n                         ^~\n                         ...\n\
    /tmp/tmp3to7csh_.swift:20:12: error: cannot convert return expression of type\
    \ 'Int' to return type 'Double'\n    return m\n           ^\n           Double(\
    \ )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return median(l, Double(0))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpqh7y20rn.swift:8:22: error: extra argument in call\n    return\
    \ median(l, Double(0))\n                 ~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978542
- exit_code: -4
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l = l as! [Int]\n    l.sort()\n   \
    \ return Double(l[(l.count - 1) >> 1] / 2)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: Exception
  stderr: 'tmp_zvti8b5/tmp_zvti8b5.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af77f2a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af77ef9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af77ef9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af77ef9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_zvti8b5                        0x00005557f5728591 <unavailable> + 5521

    5    libc.so.6                          0x00002af77f491460 __libc_start_main +
    245

    6    tmp_zvti8b5                        0x00005557f57281d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let len = Double(l.count)\n    let lsum\
    \ = l.reduce(0, combine: +).magnitude\n    var median = Double(l.count)\n    var\
    \ idx = 0\n    while idx < len {\n        let mid = (idx + len) / 2.0\n      \
    \  let m1 = l[mid]\n        let m2 = Double(m1) + (lsum / len - mid) * (-1.0)\n\
    \        let m3 = l[mid - 1]\n        median = m2 > m3 ? m2 : m3\n        idx\
    \ += 1\n    }\n    return median\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpo2_via4g.swift:9:24: error: extraneous argument label 'combine:'\
    \ in call\n    let lsum = l.reduce(0, combine: +).magnitude\n                \
    \       ^   ~~~~~~~~~\n                           \n/tmp/tmpo2_via4g.swift:12:15:\
    \ error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    while idx < len {\n          ~~~ ^ ~~~\n/tmp/tmpo2_via4g.swift:12:15: note:\
    \ overloads for '<' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    while idx < len {\n              ^\n/tmp/tmpo2_via4g.swift:13:20:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \        let mid = (idx + len) / 2.0\n                   ^\n                 \
    \  Double( )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: -4
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  if l.count <= 0 {\n    return 0\n  }\n  guard\
    \ l.count > 1 else {\n    let avg = Double(l.filter{ $0 > 0 }.count) / Double(l.count)\n\
    \    return avg\n  }\n  let sorted = l.sorted()\n  let mid = l.count / 2\n  return\
    \ Double(sorted[mid]) + Double(sorted[mid - 1]) / 2.0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: Exception
  stderr: 'tmpxq9kbzwk/tmpxq9kbzwk.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e07fcdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e07cc4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e07cc4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e07cc37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxq9kbzwk                        0x000056100a8b25d1 <unavailable> + 5585

    5    libc.so.6                          0x00002b8e081b9460 __libc_start_main +
    245

    6    tmpxq9kbzwk                        0x000056100a8b2219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    func isEven(_ i: Int) -> Bool {\n     \
    \   return i % 2 == 0\n    }\n\n    func isOdd(_ i: Int) -> Bool {\n        return\
    \ i % 2 != 0\n    }\n\n    func twos(_ i: Int) -> Int {\n        if isEven(i)\
    \ {\n            return i\n        }\n        return i + 1\n    }\n\n    var evenIndex\
    \ = 0\n    var oddIndex = 0\n    var sum = 0.0\n    for v in l {\n        if isEven(evenIndex)\
    \ && isOdd(oddIndex) {\n            sum += v\n            evenIndex += 1\n   \
    \     }\n        else if isEven(evenIndex) {\n            sum += v\n         \
    \   evenIndex += 1\n        }\n        else if isOdd(oddIndex) {\n           \
    \ sum += v\n            oddIndex += 1\n        }\n        else {\n           \
    \ sum += v\n        }\n    }\n    return sum / Double(l.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp80bgo1i1.swift:28:20: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n            sum += v\n                 \
    \  ^\n                   Double( )\n/tmp/tmp80bgo1i1.swift:32:20: error: cannot\
    \ convert value of type 'Int' to expected argument type 'Double'\n           \
    \ sum += v\n                   ^\n                   Double( )\n/tmp/tmp80bgo1i1.swift:36:20:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \            sum += v\n                   ^\n                   Double( )\n/tmp/tmp80bgo1i1.swift:40:20:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \            sum += v\n                   ^\n                   Double( )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var sorted: Int[] = l.sorted()\n    if\
    \ sorted.count == 0 {\n        return Double.nan\n    }\n\n    var half: Int =\
    \ sorted.count / 2\n    var i: Int\n    var med = 0\n    var q: Double = 0\n\n\
    \    for i in 0..<half {\n        q += Double(sorted[i])\n    }\n    q = q / half\n\
    \n    for i in 0..<half {\n        if Double(sorted[i]) > q {\n            med\
    \ += Double(sorted[i] - q)\n        }\n    }\n\n    return med + Double(sorted.last!)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp8sl3w9vq.swift:8:20: error: array types are now written with the\
    \ brackets around the element type\n    var sorted: Int[] = l.sorted()\n     \
    \              ^\n                [  \n/tmp/tmp8sl3w9vq.swift:21:13: error: cannot\
    \ convert value of type 'Int' to expected argument type 'Double'\n    q = q /\
    \ half\n            ^\n            Double( )\n/tmp/tmp8sl3w9vq.swift:25:37: error:\
    \ binary operator '-' cannot be applied to operands of type 'Int' and 'Double'\n\
    \            med += Double(sorted[i] - q)\n                          ~~~~~~~~~\
    \ ^ ~\n/tmp/tmp8sl3w9vq.swift:25:37: note: overloads for '-' exist with these\
    \ partially matching parameter lists: (Double, Double), (Int, Int)\n         \
    \   med += Double(sorted[i] - q)\n                                    ^\n/tmp/tmp8sl3w9vq.swift:25:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \            med += Double(sorted[i] - q)\n                   ^\n            \
    \       Int(                 )\n/tmp/tmp8sl3w9vq.swift:29:12: error: cannot convert\
    \ value of type 'Int' to expected argument type 'Double'\n    return med + Double(sorted.last!)\n\
    \           ^\n           Double( )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    l.sort()\n    if l.count < 2 {\n      \
    \  return l[0]\n    }\n    return Double(l.sortedSliceFrom(l.count/2)).sum / Double(l.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmph41ttcae.swift:8:7: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n/tmp/tmph41ttcae.swift:10:17:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return l[0]\n               ~^~~\n               Double( )\n/tmp/tmph41ttcae.swift:12:21:\
    \ error: value of type '[Int]' has no member 'sortedSliceFrom'\n    return Double(l.sortedSliceFrom(l.count/2)).sum\
    \ / Double(l.count)\n                  ~ ^~~~~~~~~~~~~~~\n/tmp/tmph41ttcae.swift:12:49:\
    \ error: reference to member 'sum' cannot be resolved without a contextual type\n\
    \    return Double(l.sortedSliceFrom(l.count/2)).sum / Double(l.count)\n     \
    \                                           ^\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\treturn percentile(l, 0.5)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpy7l0ohyr.swift:8:9: error: cannot find 'percentile' in scope\n\
    \        return percentile(l, 0.5)\n               ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: -4
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return Double(l.sorted()[l.count / 2])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: Exception
  stderr: 'tmpjjl64s5m/tmpjjl64s5m.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1740f32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1740c29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1740c29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1740c287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjjl64s5m                        0x000055a9fe3435ed <unavailable> + 5613

    5    libc.so.6                          0x00002b174111e460 __libc_start_main +
    245

    6    tmpjjl64s5m                        0x000055a9fe343149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659978396
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var min = Int.max\n    var max = Int.min\n\
    \    for x in l {\n        if x < min {\n            min = x\n        }\n    \
    \    if x > max {\n            max = x\n        }\n    }\n    if min == Int.min\
    \ && max == Int.max {\n        return Int.min\n    }\n    return (min + max) /\
    \ 2.0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpvw5vobgu.swift:19:20: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return Int.min\n               ~~~~^~~\n\
    \               Double()\n/tmp/tmpvw5vobgu.swift:21:17: error: cannot convert\
    \ value of type 'Int' to expected argument type 'Double'\n    return (min + max)\
    \ / 2.0\n                ^\n           Double(    )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let sorted = l.sorted()\n    if sorted.isEmpty\
    \ {\n        return 0\n    }\n    guard sorted.count >= 2 else { return sorted[0]\
    \ }\n    let median = sorted[(sorted.count - 1) >> 1]\n    return median\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpzdb09w2s.swift:12:49: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    guard sorted.count >= 2 else { return\
    \ sorted[0] }\n                                          ~~~~~~^~~\n         \
    \                                 Double(  )\n/tmp/tmpzdb09w2s.swift:14:12: error:\
    \ cannot convert return expression of type 'Int' to return type 'Double'\n   \
    \ return median\n           ^~~~~~\n           Double( )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  return median_impl(l, Double(0))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp0ofh4jw_.swift:8:10: error: cannot find 'median_impl' in scope\n\
    \  return median_impl(l, Double(0))\n         ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.isEmpty() {\n        return 0.0\n\
    \    }\n\n    var l = l as! [Int]\n    l.sort()\n\n    var middleIndex: Int =\
    \ 0\n    var middle: Double = 0.0\n\n    // use binary search to locate the middle\
    \ value\n    for i in 0 ..< l.count - 1 {\n        if l[i] > l[i + 1] {\n    \
    \        middleIndex = i + 1\n            break\n        }\n    }\n\n    // only\
    \ have one value left, return the middle value\n    if middleIndex == l.count\
    \ - 1 {\n        return l[middleIndex]\n    }\n\n    // calculate median\n   \
    \ middle = Double(l[middleIndex])\n    if middleIndex - 1 >= 0 {\n        middle\
    \ = (l[middleIndex - 1] + l[middleIndex]) / 2.0\n    }\n\n    return middle\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpy3i2oord.swift:8:10: error: cannot call value of non-function type\
    \ 'Bool'\n    if l.isEmpty() {\n         ^      ~~\n                \n/tmp/tmpy3i2oord.swift:12:15:\
    \ warning: forced cast of '[Int]' to same type has no effect\n    var l = l as!\
    \ [Int]\n              ^~~~~~~~~\n              \n/tmp/tmpy3i2oord.swift:28:17:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return l[middleIndex]\n               ~^~~~~~~~~~~~~\n              \
    \ Double(       )\n/tmp/tmpy3i2oord.swift:34:38: error: cannot convert value of\
    \ type 'Int' to expected argument type 'Double'\n        middle = (l[middleIndex\
    \ - 1] + l[middleIndex]) / 2.0\n                                     ^\n     \
    \            Double(                              )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var v = l.sort()\n    if v.count % 2 ==\
    \ 1 {\n        return v[v.reverse - 1].0 + (v[v.count / 2 - 1] + v[v.count / 2])\
    \ / 2.0\n    }\n    return v[v.count / 2].0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmphhbs7gv7.swift:8:15: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    var v = l.sort()\n            ~ ^\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tvar middle : Double\n\t\n\tif l == nil {\n\
    \t\treturn 0\n\t}\n\n\tif len(l) == 0 {\n\t\treturn 0\n\t}\n\n\tmiddle = l[0]\n\
    \t\n\tfor i := 1; i < len(l); i++ {\n\t\tif l[i] > middle {\n\t\t\tmiddle = l[i]\n\
    \t\t}\n\t}\n\n\treturn middle\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpmqlvm49p.swift:20:9: error: expected type\n        for i := 1;\
    \ i < len(l); i++ {\n               ^\n                <#type#>\n/tmp/tmpmqlvm49p.swift:20:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 1; i < len(l);\
    \ i++ {\n               ^\n/tmp/tmpmqlvm49p.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 1; i < len(l); i++ {\n      \
    \         ^\n/tmp/tmpmqlvm49p.swift:10:7: warning: comparing non-optional value\
    \ of type '[Int]' to 'nil' always returns false\n        if l == nil {\n     \
    \      ~ ^  ~~~\n/tmp/tmpmqlvm49p.swift:14:5: error: cannot find 'len' in scope\n\
    \        if len(l) == 0 {\n           ^~~\n/tmp/tmpmqlvm49p.swift:18:12: error:\
    \ cannot assign value of type 'Int' to type 'Double'\n        middle = l[0]\n\
    \                 ~^~~\n                 Double( )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return l.sorted(by: >).reduce(0.0, combine:\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) ==\
    \ 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5])\
    \ == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2,\
    \ 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp4riblh5z.swift:8:34: error: extraneous argument label 'combine:'\
    \ in call\n    return l.sorted(by: >).reduce(0.0, combine: +)\n              \
    \                   ^     ~~~~~~~~~\n                                       \n\
    /tmp/tmp4riblh5z.swift:8:49: error: cannot convert value of type '(Double) ->\
    \ Double' to expected argument type '(Double, Int) throws -> Double'\n    return\
    \ l.sorted(by: >).reduce(0.0, combine: +)\n                                  \
    \              ^\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let n = l.count\n    assert(n >= 0)\n \
    \   var max = 0\n    var sum = 0\n    var mid = 0\n    for i in 0..<n {\n    \
    \    sum = sum + l[i]\n        if sum > max {\n            max = sum\n       \
    \     mid = i\n        }\n    }\n    return (Double(max - l[mid]) / Double(n)).round()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpg3zlkzsp.swift:20:47: error: cannot convert return expression of\
    \ type '()' to return type 'Double'\n    return (Double(max - l[mid]) / Double(n)).round()\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tl := l.sorted()\n\tn := Double(l.count())\n\
    \treturn n / 2.0 + Double(l.index(l.startIndex + n - 1) / 2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpu109fcw0.swift:8:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        l := l.sorted()\n         ^\n         ;\n/tmp/tmpu109fcw0.swift:8:4:\
    \ error: expected expression\n        l := l.sorted()\n          ^\n/tmp/tmpu109fcw0.swift:8:2:\
    \ warning: expression of type '[Int]' is unused\n        l := l.sorted()\n   \
    \     ^\n/tmp/tmpu109fcw0.swift:10:9: error: cannot find 'n' in scope\n      \
    \  return n / 2.0 + Double(l.index(l.startIndex + n - 1) / 2)\n              \
    \ ^\n/tmp/tmpu109fcw0.swift:10:49: error: cannot find 'n' in scope\n        return\
    \ n / 2.0 + Double(l.index(l.startIndex + n - 1) / 2)\n                      \
    \                                 ^\n/tmp/tmpu109fcw0.swift:10:28: error: no exact\
    \ matches in call to instance method 'index'\n        return n / 2.0 + Double(l.index(l.startIndex\
    \ + n - 1) / 2)\n                                  ^\n/tmp/tmpu109fcw0.swift:10:28:\
    \ note: found candidate with type '(Int) -> Int'\n        return n / 2.0 + Double(l.index(l.startIndex\
    \ + n - 1) / 2)\n                                  ^\n/tmp/tmpu109fcw0.swift:10:28:\
    \ note: found candidate with type '(Int) -> Int'\n        return n / 2.0 + Double(l.index(l.startIndex\
    \ + n - 1) / 2)\n                                  ^\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var sorted = l.sorted()\n    if sorted.length\
    \ == 0 {\n        return 0.0\n    }\n    if sorted.first == sorted.last {\n  \
    \      return sorted[0]\n    }\n    return (sorted[sorted.first + 1] - sorted[sorted.first])\
    \ / 2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpfrpbqklp.swift:9:15: error: value of type '[Int]' has no member\
    \ 'length'\n    if sorted.length == 0 {\n       ~~~~~~ ^~~~~~\n/tmp/tmpfrpbqklp.swift:13:22:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return sorted[0]\n               ~~~~~~^~~\n               Double(  )\n\
    /tmp/tmpfrpbqklp.swift:15:27: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n    return (sorted[sorted.first + 1] - sorted[sorted.first])\
    \ / 2\n                          ^\n/tmp/tmpfrpbqklp.swift:15:27: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ return (sorted[sorted.first + 1] - sorted[sorted.first]) / 2\n             \
    \             ^\n                   (            ?? <#default value#>)\n/tmp/tmpfrpbqklp.swift:15:27:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return (sorted[sorted.first + 1] - sorted[sorted.first]) / 2\n  \
    \                        ^\n                               !\n/tmp/tmpfrpbqklp.swift:15:54:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    return (sorted[sorted.first + 1] - sorted[sorted.first]) / 2\n          \
    \                                           ^\n/tmp/tmpfrpbqklp.swift:15:54: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    return (sorted[sorted.first + 1] - sorted[sorted.first]) / 2\n          \
    \                                           ^\n                              \
    \                             ?? <#default value#>\n/tmp/tmpfrpbqklp.swift:15:54:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return (sorted[sorted.first + 1] - sorted[sorted.first]) / 2\n  \
    \                                                   ^\n                      \
    \                                    !\n/tmp/tmpfrpbqklp.swift:15:62: error: cannot\
    \ convert return expression of type 'Int' to return type 'Double'\n    return\
    \ (sorted[sorted.first + 1] - sorted[sorted.first]) / 2\n           ~~"
  stdout: ''
  timestamp: 1659978547
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return median(l, Double(l.count), Double(l.count))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpwvcbk8ma.swift:8:18: error: extra arguments at positions #2, #3\
    \ in call\n    return median(l, Double(l.count), Double(l.count))\n          \
    \       ^\n/tmp/tmpwvcbk8ma.swift:7:6: note: 'median(l:)' declared here\nfunc\
    \ median(l: [Int]) -> Double {\n     ^\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    switch l.count {\n    case 0: return Double.nan\n\
    \    case 1: return l[0]\n    case 2: return l[1]\n    default:\n        let mid\
    \ = (l.count - 1) / 2\n        var left = median(l[0 ..< mid])\n        var right\
    \ = median(l[mid..<l.count])\n        if left > right {\n            return left\n\
    \        } else {\n            return right\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpq16uhlb4.swift:10:21: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    case 1: return l[0]\n              \
    \     ~^~~\n                   Double( )\n/tmp/tmpq16uhlb4.swift:11:21: error:\
    \ cannot convert return expression of type 'Int' to return type 'Double'\n   \
    \ case 2: return l[1]\n                   ~^~~\n                   Double( )\n\
    /tmp/tmpq16uhlb4.swift:14:27: error: missing argument label 'l:' in call\n   \
    \     var left = median(l[0 ..< mid])\n                          ^\n         \
    \                 l: \n/tmp/tmpq16uhlb4.swift:14:28: error: cannot convert value\
    \ of type 'ArraySlice<Int>' to expected argument type '[Int]'\n        var left\
    \ = median(l[0 ..< mid])\n                           ^\n/tmp/tmpq16uhlb4.swift:15:28:\
    \ error: missing argument label 'l:' in call\n        var right = median(l[mid..<l.count])\n\
    \                           ^\n                           l: \n/tmp/tmpq16uhlb4.swift:15:29:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n        var right = median(l[mid..<l.count])\n                    \
    \        ^\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let size = l.count\n    if size == 0 {\n\
    \        return Double.nan\n    }\n    var hm = l[0]\n    for i in 1..<size {\n\
    \        if l[i] <= hm {\n            hm = l[i]\n        }\n    }\n    return\
    \ hm\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) ==\
    \ 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5])\
    \ == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2,\
    \ 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp57q6ge3y.swift:18:12: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return hm\n           ^~\n         \
    \  Double( )\n"
  stdout: ''
  timestamp: 1659978543
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var n = l.count\n    if n < 1 {\n     \
    \   return 0\n    }\n    if n == 1 {\n        return l[0]\n    }\n    l.sort()\n\
    \    if n % 2 == 0 {\n        return l[n/2]\n    }\n    n -= 1\n    var half1\
    \ = n/2\n    var half2 = (n+1)/2\n    return (l[half1] + l[half2])/2\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpnriuo4b1.swift:13:17: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l[0]\n               ~^~~\n\
    \               Double( )\n/tmp/tmpnriuo4b1.swift:15:7: error: cannot use mutating\
    \ member on immutable value: 'l' is a 'let' constant\n    l.sort()\n    ~ ^\n\
    /tmp/tmpnriuo4b1.swift:17:17: error: cannot convert return expression of type\
    \ 'Int' to return type 'Double'\n        return l[n/2]\n               ~^~~~~\n\
    \               Double( )\n/tmp/tmpnriuo4b1.swift:22:33: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n    return (l[half1]\
    \ + l[half2])/2\n           ~~~~~~~~~~~~~~~~~~~~~^~\n           Double(      \
    \          )\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.count < 2 {\n        return Double(l.first)\n\
    \    }\n    var a = l.sort()\n    if a.count % 2 == 0 {\n        return a[a.count\
    \ / 2 - 1] + (a[a.count / 2]) / 2.0\n    }\n    return a[a.count / 2]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp54lzydth.swift:9:25: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        return Double(l.first)\n    \
    \                    ^\n/tmp/tmp54lzydth.swift:9:25: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        return\
    \ Double(l.first)\n                        ^\n                              ??\
    \ <#default value#>\n/tmp/tmp54lzydth.swift:9:25: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        return Double(l.first)\n\
    \                        ^\n                             !\n/tmp/tmp54lzydth.swift:11:15:\
    \ error: cannot use mutating member on immutable value: 'l' is a 'let' constant\n\
    \    var a = l.sort()\n            ~ ^\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l1 = l\n    if l1.count < 2 {\n   \
    \     return 0\n    }\n    if l1.count == 2 {\n        return l1[0]\n    }\n \
    \   if l1.count > 2 {\n        l1 = l1[0..<3]\n    }\n    l1.sort()\n    return\
    \ l1[(l1.count - 1) / 2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpoxmzb4oa.swift:13:18: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l1[0]\n               ~~^~~\n\
    \               Double( )\n/tmp/tmpoxmzb4oa.swift:16:16: error: cannot assign\
    \ value of type 'ArraySlice<Int>' to type '[Int]'\n        l1 = l1[0..<3]\n  \
    \           ~~^~~~~~~\n/tmp/tmpoxmzb4oa.swift:19:14: error: cannot convert return\
    \ expression of type 'Int' to return type 'Double'\n    return l1[(l1.count -\
    \ 1) / 2]\n           ~~^~~~~~~~~~~~~~~~~~~~\n           Double(             \
    \  )\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let count = countElements(l)\n    if count\
    \ % 2 == 1 {\n        return Double(l[(count - 1) / 2] + l[count / 2] / 2)\n \
    \   }\n    return Double(l[(count - 1) / 2] + l[count / 2] / 2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp3eczkcwr.swift:8:17: error: cannot find 'countElements' in scope\n\
    \    let count = countElements(l)\n                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    let sortedArray = l.sorted()\n    if sortedArray.isEmpty\
    \ {\n        return Double(sortedArray[0])\n    }\n    let mid = Double(sortedArray.count\
    \ / 2)\n    if sortedArray.count % 2 == 0 {\n        return sortedArray[mid]\n\
    \    } else {\n        let left = sortedArray[mid]\n        let right = sortedArray[mid+1]\n\
    \        return Double(left + right) / 2.0\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp3c_zp56_.swift:14:27: error: no exact matches in call to subscript\
    \ \n        return sortedArray[mid]\n                          ^\n/tmp/tmp3c_zp56_.swift:14:27:\
    \ note: found candidate with type '(Int) -> Int'\n        return sortedArray[mid]\n\
    \                          ^\n/tmp/tmp3c_zp56_.swift:14:27: note: found candidate\
    \ with type '(Range<Int>) -> ArraySlice<Int>'\n        return sortedArray[mid]\n\
    \                          ^\n/tmp/tmp3c_zp56_.swift:14:27: note: found candidate\
    \ with type '((UnboundedRange_) -> ()) -> ArraySlice<Int>'\n        return sortedArray[mid]\n\
    \                          ^\n/tmp/tmp3c_zp56_.swift:14:27: error: no 'subscript'\
    \ candidates produce the expected contextual result type 'Double'\n        return\
    \ sortedArray[mid]\n                          ^\nSwift.Array:16:23: note: 'subscript(_:)'\
    \ produces 'Int', not the expected contextual result type 'Double'\n    @inlinable\
    \ public subscript(index: Int) -> Element { get set }\n                      ^\n\
    Swift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected\
    \ contextual result type 'Double'\n    @inlinable public subscript(bounds: Range<Int>)\
    \ -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:3:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type 'Double'\n    @inlinable public subscript(x: (UnboundedRange_) ->\
    \ ()) -> Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type 'Double'\n    @inlinable public subscript(x: (UnboundedRange_) ->\
    \ ()) -> Self.SubSequence { get set }\n                      ^\n/tmp/tmp3c_zp56_.swift:16:31:\
    \ error: no exact matches in call to subscript \n        let left = sortedArray[mid]\n\
    \                              ^\nSwift.Array:16:23: note: candidate expects value\
    \ of type 'Int' for parameter #1 (got 'Double')\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note:\
    \ candidate expe"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tcount := 0\n\tmax := 0\n\tsum := 0.0\n\n\t\
    for _, v := range l {\n\t\tsum += v\n\t\tcount++\n\n\t\tif max < v {\n\t\t\tmax\
    \ = v\n\t\t}\n\t}\n\n\tif count < 2 {\n\t\treturn 0\n\t}\n\n\tif count > max/2\
    \ {\n\t\treturn max\n\t}\n\n\treturn sum / count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpgqj7719_.swift:8:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpgqj7719_.swift:8:8:\
    \ error: expected expression\n        count := 0\n              ^\n/tmp/tmpgqj7719_.swift:12:7:\
    \ error: expected 'in' after for-each pattern\n        for _, v := range l {\n\
    \             ^\n/tmp/tmpgqj7719_.swift:12:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, v := range l {\n             ^\n/tmp/tmpgqj7719_.swift:8:2:\
    \ error: cannot find 'count' in scope\n        count := 0\n        ^~~~~\n/tmp/tmpgqj7719_.swift:21:5:\
    \ error: cannot find 'count' in scope\n        if count < 2 {\n           ^~~~~\n\
    /tmp/tmpgqj7719_.swift:25:5: error: cannot find 'count' in scope\n        if count\
    \ > max/2 {\n           ^~~~~\n/tmp/tmpgqj7719_.swift:25:13: error: generic parameter\
    \ 'T' could not be inferred\n        if count > max/2 {\n                   ^\n\
    Swift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_\
    \ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpgqj7719_.swift:25:16:\
    \ error: binary operator '/' cannot be applied to operands of type '(_, _) ->\
    \ _' and 'Int'\n        if count > max/2 {\n                   ~~~^~\n/tmp/tmpgqj7719_.swift:25:16:\
    \ note: overloads for '/' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if count > max/2 {\n                      ^\n/tmp/tmpgqj7719_.swift:26:10:\
    \ error: generic parameter 'T' could not be inferred\n                return max\n\
    \                       ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpgqj7719_.swift:26:10: error: no 'max' candidates produce\
    \ the expected contextual result type 'Double'\n                return max\n \
    \                      ^\nSwift.max:1:24: note: found candidate with type '(_,\
    \ _) -> _'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\nSwift.max:1:24: note: found candidate with typ"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.count < 2 {\n        return l[0]\n\
    \    }\n    var m = Double(l[l.count / 2])\n    var i = 0\n    for v in l {\n\
    \        if m > v {\n            m = v\n        }\n        if i == 0 {\n     \
    \       m = v\n        }\n        i += 1\n    }\n    return m\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpfwnliezs.swift:9:17: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l[0]\n               ~^~~\n\
    \               Double( )\n/tmp/tmpfwnliezs.swift:14:14: error: binary operator\
    \ '>' cannot be applied to operands of type 'Double' and 'Int'\n        if m >\
    \ v {\n           ~ ^ ~\n/tmp/tmpfwnliezs.swift:14:14: note: overloads for '>'\
    \ exist with these partially matching parameter lists: (Int, Int)\n        if\
    \ m > v {\n             ^\n/tmp/tmpfwnliezs.swift:15:17: error: cannot assign\
    \ value of type 'Int' to type 'Double'\n            m = v\n                ^\n\
    \                Double( )\n/tmp/tmpfwnliezs.swift:18:17: error: cannot assign\
    \ value of type 'Int' to type 'Double'\n            m = v\n                ^\n\
    \                Double( )\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  guard l.count > 1 else { return l[0] }\n\n\
    \  var pivot = l[0]\n  var count = 1\n\n  for n in l {\n    if n < pivot {\n \
    \     count += 1\n    } else {\n      count -= 1\n    }\n    pivot = Double(count)\
    \ / Double(l.count)\n  }\n\n  return pivot\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp6zn9h4hz.swift:8:36: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n  guard l.count > 1 else { return l[0] }\n\
    \                                  ~^~~\n                                  Double(\
    \ )\n/tmp/tmp6zn9h4hz.swift:19:27: error: cannot assign value of type 'Double'\
    \ to type 'Int'\n    pivot = Double(count) / Double(l.count)\n            ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~\n\
    \            Int(                           )\n/tmp/tmp6zn9h4hz.swift:22:10: error:\
    \ cannot convert return expression of type 'Int' to return type 'Double'\n  return\
    \ pivot\n         ^~~~~\n         Double( )\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    switch l.count {\n    case 0:\n       \
    \ return 0.0\n    case 1:\n        return l[0]\n    case 2:\n        return l.sorted\
    \ { $0 < $1 }.last!\n    case 3:\n        return l.sorted { $0 < $1 }.mid!\n \
    \   case 4:\n        return l.sorted { $0 < $1 }.first!\n    default:\n      \
    \  return l.sorted { $0 < $1 }.first!\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp7xeiv_vb.swift:12:17: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l[0]\n               ~^~~\n\
    \               Double( )\n/tmp/tmp7xeiv_vb.swift:14:41: error: cannot convert\
    \ return expression of type 'Int' to return type 'Double'\n        return l.sorted\
    \ { $0 < $1 }.last!\n               ~~~~~~~~~~~~~~~~~~~~~~~~~^\n             \
    \  Double(                   )\n/tmp/tmp7xeiv_vb.swift:16:37: error: value of\
    \ type '[Int]' has no member 'mid'\n        return l.sorted { $0 < $1 }.mid!\n\
    \               ~~~~~~~~~~~~~~~~~~~~ ^~~\n/tmp/tmp7xeiv_vb.swift:18:42: error:\
    \ cannot convert return expression of type 'Int' to return type 'Double'\n   \
    \     return l.sorted { $0 < $1 }.first!\n               ~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \               Double(                    )\n/tmp/tmp7xeiv_vb.swift:20:42: error:\
    \ cannot convert return expression of type 'Int' to return type 'Double'\n   \
    \     return l.sorted { $0 < $1 }.first!\n               ~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \               Double(                    )\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var n = 0\n    var max = 0\n    var min\
    \ = Int.min\n    for el in l {\n        if el > max {\n            max = el\n\
    \        } else if el < min {\n            min = el\n        } else {\n      \
    \      n = n + 1\n        }\n    }\n    if n < 1 {\n        return 0\n    }\n\
    \    return Double(max + ((n - 1) / Double(n))*min)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmptaagmcnc.swift:23:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return Double(max + ((n - 1) / Double(n))*min)\n      \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978568
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.isEmpty() {\n        return 0\n  \
    \  }\n\n    var hi = Double(l.count)\n    var lo = Double(0)\n    var mid = Double(0)\n\
    \    for idx in 0..<l.count {\n        if idx % 2 == 0 {\n            hi = hi\
    \ + l[idx]\n        } else {\n            lo = lo + l[idx]\n        }\n      \
    \  if idx % 2 == 0 {\n            mid = mid\n        } else {\n            mid\
    \ = mid + lo / hi\n            lo = lo - mid * hi\n            hi = hi - mid\n\
    \        }\n    }\n    return mid\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp8jabh9fi.swift:8:10: error: cannot call value of non-function type\
    \ 'Bool'\n    if l.isEmpty() {\n         ^      ~~\n                \n/tmp/tmp8jabh9fi.swift:17:24:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \            hi = hi + l[idx]\n                       ^\n                    \
    \  Double( )\n/tmp/tmp8jabh9fi.swift:19:24: error: cannot convert value of type\
    \ 'Int' to expected argument type 'Double'\n            lo = lo + l[idx]\n   \
    \                    ^\n                      Double( )\n/tmp/tmp8jabh9fi.swift:22:17:\
    \ error: assigning a variable to itself\n            mid = mid\n            ~~~\
    \ ^ ~~~\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return sortedCopy(l, l.sorted)[(Double)(l.count\
    \ / 2) - (l.count % 2)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpqgquuwvx.swift:8:12: error: cannot find 'sortedCopy' in scope\n\
    \    return sortedCopy(l, l.sorted)[(Double)(l.count / 2) - (l.count % 2)]\n \
    \          ^~~~~~~~~~\n/tmp/tmpqgquuwvx.swift:8:58: error: binary operator '-'\
    \ cannot be applied to operands of type 'Double' and 'Int'\n    return sortedCopy(l,\
    \ l.sorted)[(Double)(l.count / 2) - (l.count % 2)]\n                         \
    \          ~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmpqgquuwvx.swift:8:58:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    return sortedCopy(l, l.sorted)[(Double)(l.count\
    \ / 2) - (l.count % 2)]\n                                                    \
    \     ^\n"
  stdout: ''
  timestamp: 1659978546
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n\tvar middle : Double = 0\n\tvar count : Double\
    \ = 0\n\tvar minIndex : Double = -1\n\tvar maxIndex : Double = -1\n\tvar min :\
    \ Int = math.min(l[0], l[1], l[2])\n\tvar max : Int = math.max(l[0], l[1], l[2])\n\
    \tcount += 1.0\n\tmiddle = (min + max) / 2\n\tfor i : Int in 0..<3 {\n\t\tcount\
    \ += 1.0\n\t\tif l[i] == min {\n\t\t\tminIndex = i\n\t\t}\n\t\tif l[i] == max\
    \ {\n\t\t\tmaxIndex = i\n\t\t}\n\t\tif l[i] < min {\n\t\t\tmin = l[i]\n\t\t}\n\
    \t\tif l[i] > max {\n\t\t\tmax = l[i]\n\t\t}\n\t}\n\tif minIndex < maxIndex {\n\
    \t\treturn math.pow((count - (minIndex - maxIndex)) / 2, 0.5)\n\t}\n\treturn math.pow((count\
    \ - (maxIndex - minIndex)) / 2, 0.5)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmphyq7j9yt.swift:12:18: error: cannot find 'math' in scope\n    \
    \    var min : Int = math.min(l[0], l[1], l[2])\n                        ^~~~\n\
    /tmp/tmphyq7j9yt.swift:13:18: error: cannot find 'math' in scope\n        var\
    \ max : Int = math.max(l[0], l[1], l[2])\n                        ^~~~\n/tmp/tmphyq7j9yt.swift:15:23:\
    \ error: cannot assign value of type 'Int' to type 'Double'\n        middle =\
    \ (min + max) / 2\n                 ~~~~~~~~~~~~^~~\n                 Double(\
    \        )\n/tmp/tmphyq7j9yt.swift:19:15: error: cannot assign value of type 'Int'\
    \ to type 'Double'\n                        minIndex = i\n                   \
    \                ^\n                                   Double( )\n/tmp/tmphyq7j9yt.swift:22:15:\
    \ error: cannot assign value of type 'Int' to type 'Double'\n                \
    \        maxIndex = i\n                                   ^\n                \
    \                   Double( )\n/tmp/tmphyq7j9yt.swift:32:10: error: cannot find\
    \ 'math' in scope\n                return math.pow((count - (minIndex - maxIndex))\
    \ / 2, 0.5)\n                       ^~~~\n/tmp/tmphyq7j9yt.swift:34:9: error:\
    \ cannot find 'math' in scope\n        return math.pow((count - (maxIndex - minIndex))\
    \ / 2, 0.5)\n               ^~~~\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return average(l: l.sorted)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp3kx9j2bl.swift:8:12: error: cannot find 'average' in scope\n  \
    \  return average(l: l.sorted)\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return Double(l.sorted()).last!\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpnclph7xh.swift:8:12: error: no exact matches in call to initializer\
    \ \n    return Double(l.sorted()).last!\n           ^\n/tmp/tmpnclph7xh.swift:8:12:\
    \ note: found candidate with type '(Builtin.FPIEEE64) -> Double'\n    return Double(l.sorted()).last!\n\
    \           ^\n/tmp/tmpnclph7xh.swift:8:12: note: found candidate with type '(Substring)\
    \ -> Double?'\n    return Double(l.sorted()).last!\n           ^\n/tmp/tmpnclph7xh.swift:8:12:\
    \ note: found candidate with type '(Int) -> Double'\n    return Double(l.sorted()).last!\n\
    \           ^\n/tmp/tmpnclph7xh.swift:8:12: note: found candidate with type '(Float16)\
    \ -> Double'\n    return Double(l.sorted()).last!\n           ^\n/tmp/tmpnclph7xh.swift:8:12:\
    \ note: found candidate with type '(Float) -> Double'\n    return Double(l.sorted()).last!\n\
    \           ^\n/tmp/tmpnclph7xh.swift:8:12: note: found candidate with type '(Double)\
    \ -> Double'\n    return Double(l.sorted()).last!\n           ^\n/tmp/tmpnclph7xh.swift:8:12:\
    \ note: found candidate with type '(Float80) -> Double'\n    return Double(l.sorted()).last!\n\
    \           ^\n/tmp/tmpnclph7xh.swift:8:31: error: reference to member 'last'\
    \ cannot be resolved without a contextual type\n    return Double(l.sorted()).last!\n\
    \                              ^\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    if l.isEmpty() {\n        return 0.0\n\
    \    }\n    l.sort()\n    if l.length == 1 {\n        return l[0]\n    }\n   \
    \ var middle: Int\n    var l1 = []\n    var l2 = []\n    var median: Double\n\n\
    \    for i in 0..<(l.count / 2) {\n        l1.append(l[i])\n    }\n    for i in\
    \ 1..<l.count {\n        l2.append(l[i])\n    }\n    middle = (l1.count + l2.count\
    \ - 1) / 2\n    median = l1[middle] + l2[middle]\n    return median\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpvgkrj0ri.swift:8:10: error: cannot call value of non-function type\
    \ 'Bool'\n    if l.isEmpty() {\n         ^      ~~\n                \n/tmp/tmpvgkrj0ri.swift:11:7:\
    \ error: cannot use mutating member on immutable value: 'l' is a 'let' constant\n\
    \    l.sort()\n    ~ ^\n/tmp/tmpvgkrj0ri.swift:12:10: error: value of type '[Int]'\
    \ has no member 'length'\n    if l.length == 1 {\n       ~ ^~~~~~\n/tmp/tmpvgkrj0ri.swift:13:17:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return l[0]\n               ~^~~\n               Double( )\n/tmp/tmpvgkrj0ri.swift:16:14:\
    \ error: empty collection literal requires an explicit type\n    var l1 = []\n\
    \             ^~\n/tmp/tmpvgkrj0ri.swift:17:14: error: empty collection literal\
    \ requires an explicit type\n    var l2 = []\n             ^~\n/tmp/tmpvgkrj0ri.swift:27:16:\
    \ error: no exact matches in call to subscript \n    median = l1[middle] + l2[middle]\n\
    \               ^\n/tmp/tmpvgkrj0ri.swift:27:16: note: found candidate with type\
    \ '(Range<Int>) -> @lvalue ArraySlice<Any>'\n    median = l1[middle] + l2[middle]\n\
    \               ^\n/tmp/tmpvgkrj0ri.swift:27:16: note: found candidate with type\
    \ '((UnboundedRange_) -> ()) -> ArraySlice<Any>'\n    median = l1[middle] + l2[middle]\n\
    \               ^\n/tmp/tmpvgkrj0ri.swift:27:16: note: found candidate with type\
    \ '((UnboundedRange_) -> ()) -> @lvalue ArraySlice<Any>'\n    median = l1[middle]\
    \ + l2[middle]\n               ^\n/tmp/tmpvgkrj0ri.swift:27:29: error: no exact\
    \ matches in call to subscript \n    median = l1[middle] + l2[middle]\n      \
    \                      ^\n/tmp/tmpvgkrj0ri.swift:27:29: note: found candidate\
    \ with type '(Range<Int>) -> @lvalue ArraySlice<Any>'\n    median = l1[middle]\
    \ + l2[middle]\n                            ^\n/tmp/tmpvgkrj0ri.swift:27:29: note:\
    \ found candidate with type '((UnboundedRange_) -> ()) -> ArraySlice<Any>'\n \
    \   median = l1[middle] + l2[middle]\n                            ^\n/tmp/tmpvgkrj0ri.swift:27:29:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -> @lvalue ArraySlice<Any>'\n\
    \    median = l1[mi"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  let n = l.count\n  if n == 0 {\n    return\
    \ Double(0)\n  }\n  var s = l.sorted()\n  var mid = s.count / 2\n  if s.count\
    \ % 2 == 0 {\n    return s[mid]\n  }\n  else {\n    return (s[mid] + s[mid-1])\
    \ / 2\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpjqn92vg2.swift:15:13: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return s[mid]\n           ~^~~~~\n \
    \          Double( )\n/tmp/tmpjqn92vg2.swift:18:32: error: cannot convert return\
    \ expression of type 'Int' to return type 'Double'\n    return (s[mid] + s[mid-1])\
    \ / 2\n           ~~~~~~~~~~~~~~~~~~~~^~~\n           Double(                )\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    return l.sorted == nil ? l.sorted : median(l.sorted!)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpi13y3t7d.swift:8:28: error: cannot convert return expression of\
    \ type '() -> [Int]' to return type 'Double'\n    return l.sorted == nil ? l.sorted\
    \ : median(l.sorted!)\n           ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpi13y3t7d.swift:8:48: error: missing argument label 'l:' in call\n    return\
    \ l.sorted == nil ? l.sorted : median(l.sorted!)\n                           \
    \                    ^\n                                               l: \n/tmp/tmpi13y3t7d.swift:8:50:\
    \ error: function produces expected type '[Int]'; did you mean to call it with\
    \ '()'?\n    return l.sorted == nil ? l.sorted : median(l.sorted!)\n         \
    \                                      ~~^~~~~~\n                            \
    \                           ()\n/tmp/tmpi13y3t7d.swift:8:56: error: cannot force\
    \ unwrap value of non-optional type '() -> [Int]'\n    return l.sorted == nil\
    \ ? l.sorted : median(l.sorted!)\n                                           \
    \    ~~~~~~~~^\n                                                       \n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l = l.sort()\n    return Double(l[(l.count\
    \ - 1) / 2])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpn2zg4q3s.swift:8:15: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    var l = l.sort()\n            ~ ^\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var l = l.sorted()\n    var size = l.count\n\
    \    if size % 2 == 1 {\n        return l[(size-1) / 2]\n    } else {\n      \
    \  return (l[(size-1) / 2] + l[size/2]) / 2.0\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10,\
    \ 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp57md19qu.swift:11:17: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n        return l[(size-1) / 2]\n       \
    \        ~^~~~~~~~~~~~~~\n               Double(        )\n/tmp/tmp57md19qu.swift:13:33:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \        return (l[(size-1) / 2] + l[size/2]) / 2.0\n                        \
    \        ^\n               Double(                      )\n"
  stdout: ''
  timestamp: 1659978546
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  if l.isEmpty() {\n    return Double.nan\n\
    \  }\n\n  var l = l.sorted()\n  if l.size == 1 {\n    return l[0]\n  }\n\n  return\
    \ Double(l[l.size/2-1] + l[l.size/2])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10,\
    \ 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmplsqtrff5.swift:8:8: error: cannot call value of non-function type\
    \ 'Bool'\n  if l.isEmpty() {\n       ^      ~~\n              \n/tmp/tmplsqtrff5.swift:13:8:\
    \ error: value of type '[Int]' has no member 'size'\n  if l.size == 1 {\n    \
    \ ~ ^~~~\n/tmp/tmplsqtrff5.swift:14:13: error: cannot convert return expression\
    \ of type 'Int' to return type 'Double'\n    return l[0]\n           ~^~~\n  \
    \         Double( )\n/tmp/tmplsqtrff5.swift:17:21: error: value of type '[Int]'\
    \ has no member 'size'\n  return Double(l[l.size/2-1] + l[l.size/2])\n       \
    \           ~ ^~~~\n/tmp/tmplsqtrff5.swift:17:37: error: value of type '[Int]'\
    \ has no member 'size'\n  return Double(l[l.size/2-1] + l[l.size/2])\n       \
    \                           ~ ^~~~\n"
  stdout: ''
  timestamp: 1659978544
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var n = countOne(l) + countZero(l)\n  \
    \  if n < 0 {\n        return 0\n    }\n    return (0..n-1).reduce(0, combine:\
    \ &(+)) + min(l) / Double(n)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(median(l:\
    \ [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\n\
    assert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l:\
    \ [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpm350s_w_.swift:8:13: error: cannot find 'countOne' in scope\n \
    \   var n = countOne(l) + countZero(l)\n            ^~~~~~~~\n/tmp/tmpm350s_w_.swift:8:27:\
    \ error: cannot find 'countZero' in scope\n    var n = countOne(l) + countZero(l)\n\
    \                          ^~~~~~~~~\n/tmp/tmpm350s_w_.swift:12:14: error: cannot\
    \ find operator '..' in scope; did you mean '...'?\n    return (0..n-1).reduce(0,\
    \ combine: &(+)) + min(l) / Double(n)\n             ^~\n             ...\n/tmp/tmpm350s_w_.swift:12:12:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n    return (0..n-1).reduce(0,\
    \ combine: &(+)) + min(l) / Double(n)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978708
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n  let l = l.sorted()\n  if l.count == 0 ||\
    \ l.count == 1 || l.count == 2 {\n    return l[0]\n  }\n  if l.count % 2 == 0\
    \ {\n    return (l[l.count / 2] + l[l.count / 2 - 1]) / 2\n  }\n  return l[l.count\
    \ / 2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4,\
    \ 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp8abkkurm.swift:10:13: error: cannot convert return expression of\
    \ type 'Int' to return type 'Double'\n    return l[0]\n           ~^~~\n     \
    \      Double( )\n/tmp/tmp8abkkurm.swift:13:50: error: cannot convert return expression\
    \ of type 'Int' to return type 'Double'\n    return (l[l.count / 2] + l[l.count\
    \ / 2 - 1]) / 2\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n      \
    \     Double(                                  )\n/tmp/tmp8abkkurm.swift:15:11:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \  return l[l.count / 2]\n         ~^~~~~~~~~~~~~\n         Double(       )\n"
  stdout: ''
  timestamp: 1659978545
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    var sorted = true\n    var largest = -0.0\n\
    \    var n = l.count\n    var index = 0\n    while sorted && index < n {\n   \
    \     if l[index] > largest {\n            largest = l[index]\n        } else\
    \ if l[index] == largest {\n            sorted = false\n        }\n        index\
    \ += 1\n    }\n    if !sorted {\n        return largest / Double(n)\n    }\n \
    \   if n%2 == 0 {\n        return (l[n/2] + l[n/2-1]) / 2\n    }\n    var left\
    \ = 0\n    var right = n-1\n    var middle = Double(Int((left + right) / 2))\n\
    \    var mmed = Double(0)\n    while left < right {\n        if l[middle] == largest\
    \ {\n            mmed = middle\n            right = middle - 1\n        } else\
    \ {\n            if l[middle] < largest {\n                left = middle + 1\n\
    \            } else {\n                right = middle\n            }\n       \
    \ }\n        middle = Double(Int((left + right) / 2))\n    }\n    return mmed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l:\
    \ [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l:\
    \ [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmp59g6_4zz.swift:13:21: error: binary operator '>' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n        if l[index] > largest {\n  \
    \         ~~~~~~~~ ^ ~~~~~~~\n/tmp/tmp59g6_4zz.swift:13:21: note: overloads for\
    \ '>' exist with these partially matching parameter lists: (Int, Int)\n      \
    \  if l[index] > largest {\n                    ^\n/tmp/tmp59g6_4zz.swift:14:24:\
    \ error: cannot assign value of type 'Int' to type 'Double'\n            largest\
    \ = l[index]\n                      ~^~~~~~~\n                      Double( )\n\
    /tmp/tmp59g6_4zz.swift:15:28: error: binary operator '==' cannot be applied to\
    \ operands of type 'Int' and 'Double'\n        } else if l[index] == largest {\n\
    \                  ~~~~~~~~ ^  ~~~~~~~\n/tmp/tmp59g6_4zz.swift:15:28: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Int, Int)\n \
    \       } else if l[index] == largest {\n                           ^\n/tmp/tmp59g6_4zz.swift:24:36:\
    \ error: cannot convert return expression of type 'Int' to return type 'Double'\n\
    \        return (l[n/2] + l[n/2-1]) / 2\n               ~~~~~~~~~~~~~~~~~~~~^~~\n\
    \               Double(                )\n/tmp/tmp59g6_4zz.swift:31:13: error:\
    \ no exact matches in call to subscript \n        if l[middle] == largest {\n\
    \            ^\n/tmp/tmp59g6_4zz.swift:31:13: note: candidate expects value of\
    \ type 'Int' for parameter #1 (got '@lvalue Double')\n        if l[middle] ==\
    \ largest {\n            ^\n/tmp/tmp59g6_4zz.swift:31:13: note: candidate expects\
    \ value of type 'Range<Int>' for parameter #1 (got '@lvalue Double')\n       \
    \ if l[middle] == largest {\n            ^\n/tmp/tmp59g6_4zz.swift:31:13: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ '@lvalue Double')\n        if l[middle] == largest {\n            ^\n/tmp/tmp59g6_4zz.swift:31:13:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got '@lvalue Double')\n        if l[middle] == largest {\n            ^\n\
    /tmp/tmp59g6_4zz.swift:31:22: error: binary operator '==' cannot be applied to\
    \ operands of t"
  stdout: ''
  timestamp: 1659978545
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    l.sortInPlace()\n    let len = l.count\n\
    \    let half = len ~/ 2.0\n    return l[half]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000,\
    \ 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\n\
    assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpz6nd5fqf.swift:8:7: error: value of type '[Int]' has no member\
    \ 'sortInPlace'\n    l.sortInPlace()\n    ~ ^~~~~~~~~~~\n/tmp/tmpz6nd5fqf.swift:10:20:\
    \ error: cannot find operator '~/' in scope\n    let half = len ~/ 2.0\n     \
    \              ^~\n/tmp/tmpz6nd5fqf.swift:11:13: error: no 'subscript' candidates\
    \ produce the expected contextual result type 'Double'\n    return l[half]\n \
    \           ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Int', not the\
    \ expected contextual result type 'Double'\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note:\
    \ 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual result\
    \ type 'Double'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1659978545
- exit_code: 1
  program: "\n/// Return median of elements in the array l.\n/// >>> median(l: [3,\
    \ 1, 2, 4, 5])\n/// 3\n/// >>> median(l: [-10, 4, 6, 1000, 10, 20])\n/// 15.0\n\
    func median(l: [Int]) -> Double {\n    switch l.count {\n    case 0: return Double(0.0)\n\
    \    case 1: return Double(l[0])\n    case 2: return Double(l[0] + l[1]) / 2.0\n\
    \    default:\n        let center = (l.count - 1) / 2\n        let left  = median(l.prefix(center))\n\
    \        let right = median(l.suffix(center))\n        return left + Double(right)\
    \ / 2.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2,\
    \ 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l:\
    \ [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9,\
    \ 9, 2, 7]) == 7)"
  status: SyntaxError
  stderr: "/tmp/tmpq87nbpja.swift:14:28: error: missing argument label 'l:' in call\n\
    \        let left  = median(l.prefix(center))\n                           ^\n\
    \                           l: \n/tmp/tmpq87nbpja.swift:15:28: error: missing\
    \ argument label 'l:' in call\n        let right = median(l.suffix(center))\n\
    \                           ^\n                           l: \n"
  stdout: ''
  timestamp: 1659978545
