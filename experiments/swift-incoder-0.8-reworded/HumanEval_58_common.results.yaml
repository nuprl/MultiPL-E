language: swift
name: HumanEval_58_common
results:
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var set1 = Set<Int>(l1)\n    var set2 = Set<Int>(l2)\n\
    \    var common: [Int] = []\n\n    for value in set1.intersection(set2) {\n  \
    \      if !contains(common, value) {\n            common.append(value)\n     \
    \   }\n    }\n\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7_bivh87.swift:13:13: error: cannot find 'contains' in scope\n\
    \        if !contains(common, value) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1 == l2 { return l1 }\n    var arr: [Int] = []\n\
    \    for e in l1 {\n        if !contains(l2, e) {\n            append(arr, e)\n\
    \        }\n    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp77nbgv13.swift:11:13: error: cannot find 'contains' in scope\n\
    \        if !contains(l2, e) {\n            ^~~~~~~~\n/tmp/tmp77nbgv13.swift:12:13:\
    \ error: cannot find 'append' in scope\n            append(arr, e)\n         \
    \   ^~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1.isEmpty() || l2.isEmpty() {\n        return\
    \ []\n    }\n    \n    var result: [Int] = []\n    var j = l1[0]\n    var k =\
    \ l2[0]\n    \n    while j < k {\n        if l1[j] == l2[k] {\n            result.append(j)\n\
    \            j++\n            k++\n        } else if l1[j] > l2[k] {\n       \
    \     j = l1[j]\n        } else {\n            k = l2[k]\n        }\n    }\n \
    \   \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6s6sjjnd.swift:8:11: error: cannot call value of non-function type\
    \ 'Bool'\n    if l1.isEmpty() || l2.isEmpty() {\n          ^      ~~\n       \
    \          \n/tmp/tmp6s6sjjnd.swift:8:27: error: cannot call value of non-function\
    \ type 'Bool'\n    if l1.isEmpty() || l2.isEmpty() {\n                       \
    \   ^      ~~\n                                 \n/tmp/tmp6s6sjjnd.swift:19:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  j++\n             ^~\n/tmp/tmp6s6sjjnd.swift:20:14: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            k++\n             ^~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l: Int = 0\n    var r: Int = 0\n    var result:\
    \ [Int] = []\n    while l < l2.count {\n        r = l\n        while r < l2.count\
    \ && l1[r] == l2[l] {\n            r += 1\n        }\n        result.append(l1[l])\n\
    \        for var i = l + 1; i <= r; i++ {\n            l1.remove(at: i)\n    \
    \    }\n        l = r + 1\n    }\n    result.append(l1[0])\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_h2cle82.swift:17:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for var i = l + 1; i <= r; i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common = [Int]()\n    var x = l1[0]\n    var\
    \ y = l2[0]\n    var found = false\n    var count = 0\n    while x != y && !found\
    \ {\n        if x != y {\n            if x > y {\n                count = count\
    \ + 1\n            } else {\n                count = count - 1\n            }\n\
    \        }\n        if count == 0 {\n            common.append(x)\n          \
    \  found = true\n        }\n        x = l1[x]\n        y = l2[y]\n    }\n    return\
    \ common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d697b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d694ae561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8d694ae286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8d694ae13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8d694adbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8d692ade83 <unavailable> + 188035

    6    tmpt0y6xpnu                        0x000055cbd8039b75 <unavailable> + 7029

    7    tmpt0y6xpnu                        0x000055cbd8039473 <unavailable> + 5235

    8    libc.so.6                          0x00002b8d699a3460 __libc_start_main +
    245

    9    tmpt0y6xpnu                        0x000055cbd80390d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in 0 ..< min(l1.count,\
    \ l2.count) {\n        let a = l1[i]\n        let b = l2[i]\n        if a == b\
    \ {\n            result.append(a)\n        }\n    }\n    for i in 0 ..< min(l1.count,\
    \ l2.count) {\n        if !contains(result, l2[i]) {\n            result.append(l2[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1238kskx.swift:17:13: error: cannot find 'contains' in scope\n\
    \        if !contains(result, l2[i]) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let len = min(l1.count, l2.count)\n    let result\
    \ = Array(repeating: 0, count: len)\n\n    for i in 0..<len {\n        result[i]\
    \ = l1[i] < l2[i] ? l1[i] : l2[i]\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp9gg9xzaz.swift:12:15: error: cannot assign through subscript: 'result'\
    \ is a 'let' constant\n        result[i] = l1[i] < l2[i] ? l1[i] : l2[i]\n   \
    \     ~~~~~~^\n/tmp/tmp9gg9xzaz.swift:9:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let result = Array(repeating: 0, count: len)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // Initialize with 0s, so that we don't need to worry\
    \ about index out of bounds\n    var a = 0\n    var b = 0\n    var i = 0\n   \
    \ var j = 0\n    var n1 = l1?.count ?? 0\n    var n2 = l2?.count ?? 0\n    var\
    \ result = [Int]()\n    while a < n1 && b < n2 {\n        if l1[i] < l2[j] {\n\
    \            result.append(l1[i])\n            a++\n        } else {\n       \
    \     result.append(l2[j])\n            b++\n        }\n        i += 1\n     \
    \   j += 1\n    }\n    while a < n1 {\n        result.append(l1[i])\n        a++\n\
    \        i += 1\n    }\n    while b < n2 {\n        result.append(l2[j])\n   \
    \     b++\n        j += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppd54onv0.swift:13:16: error: cannot use optional chaining on non-optional\
    \ value of type '[Int]'\n    var n1 = l1?.count ?? 0\n             ~~^\n     \
    \          \n/tmp/tmppd54onv0.swift:14:16: error: cannot use optional chaining\
    \ on non-optional value of type '[Int]'\n    var n2 = l2?.count ?? 0\n       \
    \      ~~^\n               \n/tmp/tmppd54onv0.swift:19:14: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            a++\n            \
    \ ^~\n/tmp/tmppd54onv0.swift:22:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            b++\n             ^~\n/tmp/tmppd54onv0.swift:29:10:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        a++\n\
    \         ^~\n/tmp/tmppd54onv0.swift:34:10: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n        b++\n         ^~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n       \
    \ for j in l2 {\n            if i == j {\n                continue\n         \
    \   }\n            if !result.contains(i) {\n                result.insert(i,\
    \ at: 0)\n            }\n            if !result.contains(j) {\n              \
    \  result.insert(j, at: 0)\n            }\n            if result.count > 1 {\n\
    \                break\n            }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp23121fwn/tmp23121fwn.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f66333c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f6602ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f6602a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f660297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp23121fwn                        0x000055608a65072c <unavailable> + 5932

    5    libc.so.6                          0x00002b4f6651f460 __libc_start_main +
    245

    6    tmp23121fwn                        0x000055608a6502a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var index1 = -1\n    var\
    \ index2 = -1\n    for x in l1 {\n        for y in l2 {\n            if x == y\
    \ {\n                if index1 == -1 || index2 != y {\n                    index1\
    \ = x\n                    index2 = y\n                }\n            } else {\n\
    \                break\n            }\n        }\n        if index1 != -1 {\n\
    \            break\n        }\n        result.append(x)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp7y1_boek/tmp7y1_boek.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d92d94c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d92a8bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d92a8b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d92a8a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7y1_boek                        0x0000555b22bae66c <unavailable> + 5740

    5    libc.so.6                          0x00002b7d92f80460 __libc_start_main +
    245

    6    tmp7y1_boek                        0x0000555b22bae1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l3 = [Int]()\n    for i in 0..<min(l1.count,\
    \ l2.count) {\n        if l1[i] == l2[i] {\n            l3.append(l1[i])\n   \
    \     }\n    }\n    l3.sort()\n    return l3\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp1gbahikc/tmp1gbahikc.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c130a2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c12d99b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c12d99988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c12d987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1gbahikc                        0x000055752a5da8ac <unavailable> + 6316

    5    libc.so.6                          0x00002b9c1328e460 __libc_start_main +
    245

    6    tmp1gbahikc                        0x000055752a5da429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n       \
    \ if !contains(l2, i) {\n            result = append(result, i)\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1ifw2qyy.swift:10:13: error: cannot find 'contains' in scope\n\
    \        if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmp1ifw2qyy.swift:11:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    let sortedL1 = l1.sorted()\n\
    \    let sortedL2 = l2.sorted()\n    var i = 0\n    while i < sortedL1.count &&\
    \ i < sortedL2.count {\n        let idx1 = sortedL1[i]\n        let idx2 = sortedL2[i]\n\
    \        if idx1 == idx2 {\n            result.append(idx1)\n            i +=\
    \ 1\n        } else if idx1 < idx2 {\n            result.append(idx1)\n      \
    \      i += 1\n        } else {\n            result.append(idx2)\n           \
    \ i += 1\n        }\n    }\n    while i < sortedL1.count {\n        result.append(sortedL1[i])\n\
    \        i += 1\n    }\n    while i < sortedL2.count {\n        result.append(sortedL2[i])\n\
    \        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpmsi8j6i1/tmpmsi8j6i1.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6929e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6926ddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6926dd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6926dc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmsi8j6i1                        0x0000555b851f45fc <unavailable> + 5628

    5    libc.so.6                          0x00002ac692bd2460 __libc_start_main +
    245

    6    tmpmsi8j6i1                        0x0000555b851f4179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var res: [Int] = []\n\n    for x in l1 {\n      \
    \  for y in l2 {\n            if x == y {\n                continue\n        \
    \    }\n            if !res.contains(x) {\n                res.append(x)\n   \
    \         }\n            if !res.contains(y) {\n                res.append(y)\n\
    \            }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpvl2e0vhh/tmpvl2e0vhh.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae43054fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae430246b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae430246988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae4302457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvl2e0vhh                        0x00005562f36f567c <unavailable> + 5756

    5    libc.so.6                          0x00002ae43073b460 __libc_start_main +
    245

    6    tmpvl2e0vhh                        0x00005562f36f51f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var a = [Int](l1)\n    a.sort()\n    var b = [Int](l2)\n\
    \    b.sort()\n    var c = [Int]()\n    var i = 0\n    for k in a {\n        if\
    \ b[i] != k {\n            c[c.count] = k\n        }\n        i += 1\n    }\n\
    \    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b96c3a5dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b96c3754561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b96c3754286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b96c375413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b96c3753bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b96c35537ec <unavailable> + 186348

    6    tmp7mc5qcua                        0x0000559c1288efe2 <unavailable> + 8162

    7    tmp7mc5qcua                        0x0000559c1288e7b3 <unavailable> + 6067

    8    libc.so.6                          0x00002b96c3c49460 __libc_start_main +
    245

    9    tmp7mc5qcua                        0x0000559c1288e419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var c = [Int]()\n    var l1I = 0\n    var l2I = 0\n\
    \    while l1I < l1.count {\n        while l2I < l2.count && l1[l1I] == l2[l2I]\
    \ {\n            c[l2I] = l1[l1I]\n            l2I++\n        }\n        if l2I\
    \ < l2.count {\n            c[l2I] = l2[l2I]\n            l2I++\n        }\n \
    \       l1I++\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxf94xamm.swift:14:16: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            l2I++\n               ^~\n/tmp/tmpxf94xamm.swift:18:16:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  l2I++\n               ^~\n/tmp/tmpxf94xamm.swift:20:12: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n        l1I++\n           ^~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var unique: [Int] = l1\n    for index in l2 {\n \
    \       if !contains(unique, index) {\n            unique.append(index)\n    \
    \    }\n    }\n    return unique\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0oue_mmk.swift:10:13: error: cannot find 'contains' in scope\n\
    \        if !contains(unique, index) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var a = l1\n    var b = l2\n    var result: [Int]\
    \ = []\n    while !a.isEmpty && !b.isEmpty {\n        if a[0] < b[0] {\n     \
    \       result.append(a[0])\n            a.removeAtIndex(0)\n        } else {\n\
    \            result.append(b[0])\n            b.removeAtIndex(0)\n        }\n\
    \    }\n    while !a.isEmpty {\n        result.append(a[0])\n        a.removeAtIndex(0)\n\
    \    }\n    while !b.isEmpty {\n        result.append(b[0])\n        b.removeAtIndex(0)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph9cmm_ua.swift:14:15: error: value of type '[Int]' has no member\
    \ 'removeAtIndex'\n            a.removeAtIndex(0)\n            ~ ^~~~~~~~~~~~~\n\
    /tmp/tmph9cmm_ua.swift:17:15: error: value of type '[Int]' has no member 'removeAtIndex'\n\
    \            b.removeAtIndex(0)\n            ~ ^~~~~~~~~~~~~\n/tmp/tmph9cmm_ua.swift:22:11:\
    \ error: value of type '[Int]' has no member 'removeAtIndex'\n        a.removeAtIndex(0)\n\
    \        ~ ^~~~~~~~~~~~~\n/tmp/tmph9cmm_ua.swift:26:11: error: value of type '[Int]'\
    \ has no member 'removeAtIndex'\n        b.removeAtIndex(0)\n        ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var results = [Int]()\n    for i in l1 {\n      \
    \  if l2.contains(i) {\n            results.append(i)\n        }\n    }\n    return\
    \ results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmppukh_252/tmppukh_252.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf29831c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf29528b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf29528988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf295277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppukh_252                        0x000055f7586726cc <unavailable> + 5836

    5    libc.so.6                          0x00002adf29a1d460 __libc_start_main +
    245

    6    tmppukh_252                        0x000055f758672249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\tvar l: Int?\n\t\n\tvar commonCount: Int = 0\n\tvar\
    \ common = [Int]()\n\tfor i : Int in l1 {\n\t\tif commonCount == 0 {\n\t\t\tcommon.append(i)\n\
    \t\t} else {\n\t\t\tfor j : Int in l2 {\n\t\t\t\tif i == j {\n\t\t\t\t\tcommonCount\
    \ += 1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif commonCount > 1 {\n\t\
    \t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif commonCount > 1 {\n\t\t\t\t\
    break\n\t\t\t}\n\t\t\t\n\t\t\tcommon.append(i)\n\t\t}\n\t}\n\t\n\treturn common\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpd09zb_x1/tmpd09zb_x1.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1018583c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b101827ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b101827a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10182797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd09zb_x1                        0x0000560e8ddfe66c <unavailable> + 5740

    5    libc.so.6                          0x00002b101876f460 __libc_start_main +
    245

    6    tmpd09zb_x1                        0x0000560e8ddfe1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1 == l2 {\n        return l1\n    }\n    \n \
    \   // create hash map\n    var map = [Int: Int]()\n    \n    for value in l1\
    \ {\n        if let count = map[value] {\n            map[value] += 1 // increment\n\
    \        } else {\n            map[value] = 1\n        }\n    }\n    \n    for\
    \ value in l2 {\n        if let count = map[value] {\n            map[value] +=\
    \ 1 // increment\n        } else {\n            map[value] = 1\n        }\n  \
    \  }\n    \n    var result = [Int]()\n    for value in map {\n        if let count\
    \ = map[value] {\n            if count == 1 {\n                result.append(value)\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpol1uyw9v.swift:17:16: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n            map[value] += 1 // increment\n\
    \               ^\n/tmp/tmpol1uyw9v.swift:17:16: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n            map[value]\
    \ += 1 // increment\n               ^\n                      !\n/tmp/tmpol1uyw9v.swift:25:16:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            map[value] += 1 // increment\n               ^\n/tmp/tmpol1uyw9v.swift:25:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            map[value] += 1 // increment\n               ^\n        \
    \              !\n/tmp/tmpol1uyw9v.swift:33:28: error: cannot convert value of\
    \ type '(key: Int, value: Int)' to expected argument type 'Int'\n        if let\
    \ count = map[value] {\n                           ^\n/tmp/tmpol1uyw9v.swift:35:31:\
    \ error: cannot convert value of type '(key: Int, value: Int)' to expected argument\
    \ type 'Int'\n                result.append(value)\n                         \
    \     ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let resultSet = NSSet(array: l1)\n    let otherSet\
    \ = NSSet(array: l2)\n    let uniqueResults = resultSet.intersect(otherSet)\n\
    \    return uniqueResults.array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpubjpo7wc.swift:8:21: error: cannot find 'NSSet' in scope\n    let\
    \ resultSet = NSSet(array: l1)\n                    ^~~~~\n/tmp/tmpubjpo7wc.swift:9:20:\
    \ error: cannot find 'NSSet' in scope\n    let otherSet = NSSet(array: l2)\n \
    \                  ^~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count != l2.count else { return [] }\n\n\
    \    var result: [Int] = []\n    for i in 0..<l1.count {\n        if l1[i] ==\
    \ l2[i] {\n            result.append(l1[i])\n        }\n    }\n\n    return result.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgy33t0qg/tmpgy33t0qg.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76afd2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76afa21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76afa21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76afa207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgy33t0qg                        0x00005616c42d177c <unavailable> + 6012

    5    libc.so.6                          0x00002b76aff16460 __libc_start_main +
    245

    6    tmpgy33t0qg                        0x00005616c42d12f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var j = 0\n    for i in\
    \ 0..<min(l1.count, l2.count) {\n        if l1[i] != l2[j] {\n            result.append(l1[i])\n\
    \            j++\n        } else {\n            j++\n        }\n    }\n    if\
    \ l1.count < l2.count {\n        result = result[0..<l1.count]\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptlmjy9gz.swift:13:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            j++\n             ^~\n/tmp/tmptlmjy9gz.swift:15:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  j++\n             ^~\n/tmp/tmptlmjy9gz.swift:19:24: error: cannot assign value\
    \ of type 'ArraySlice<Int>' to type '[Int]'\n        result = result[0..<l1.count]\n\
    \                 ~~~~~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count > 0 && l2.count > 0 else {\n     \
    \   return []\n    }\n\n    var set1 = Set<Int>(l1)\n    var set2 = Set<Int>(l2)\n\
    \    var commonElements = Set<Int>()\n\n    commonElements.formUnion(set2)\n\n\
    \    for element in set1.formUnion(set2) {\n        commonElements.formRemove(element)\n\
    \    }\n\n    return commonElements.formValues()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxx2mcp66.swift:18:25: error: for-in loop requires '()' to conform\
    \ to 'Sequence'\n    for element in set1.formUnion(set2) {\n                 \
    \  ~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpxx2mcp66.swift:22:27: error: value of type 'Set<Int>'\
    \ has no member 'formValues'\n    return commonElements.formValues()\n       \
    \    ~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\tvar l1 = l1\n\tvar l2 = l2\n\tvar i, j, m\n\tvar n\
    \ = max(l1.count, l2.count)\n\tl1 = l1[0:n]\n\tl2 = l2[0:n]\n\tm = max(m, n)\n\
    \tvar u = Array(count: m, repeatedValue: Int()) // unique in l1, unique in l2\n\
    \tvar i = l1.count\n\tvar j = l2.count\n\tvar k = 0\n\tfor ; k < m && i < j; k++\
    \ {\n\t\tif l1[k] != l2[k] {\n\t\t\tif l1.removeAtIndex(k) {\n\t\t\t\tl2.removeAtIndex(k)\n\
    \t\t\t\tj--\n\t\t\t} else {\n\t\t\t\ti--\n\t\t\t}\n\t\t} else {\n\t\t\tu[k] =\
    \ l1[k]\n\t\t\ti += 1\n\t\t\tj += 1\n\t\t}\n\t}\n\treturn u\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpk50v9fij.swift:12:11: error: expected ',' separator\n        l1\
    \ = l1[0:n]\n                 ^\n                 ,\n/tmp/tmpk50v9fij.swift:12:11:\
    \ error: expected expression in list of expressions\n        l1 = l1[0:n]\n  \
    \               ^\n/tmp/tmpk50v9fij.swift:13:11: error: expected ',' separator\n\
    \        l2 = l2[0:n]\n                 ^\n                 ,\n/tmp/tmpk50v9fij.swift:13:11:\
    \ error: expected expression in list of expressions\n        l2 = l2[0:n]\n  \
    \               ^\n/tmp/tmpk50v9fij.swift:19:2: error: C-style for statement has\
    \ been removed in Swift 3\n        for ; k < m && i < j; k++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk50v9fij.swift:10:6: error: type annotation missing in pattern\n     \
    \   var i, j, m\n            ^\n/tmp/tmpk50v9fij.swift:10:9: error: type annotation\
    \ missing in pattern\n        var i, j, m\n               ^\n/tmp/tmpk50v9fij.swift:10:12:\
    \ error: type annotation missing in pattern\n        var i, j, m\n           \
    \       ^\n/tmp/tmpk50v9fij.swift:12:9: error: cannot assign value of type 'Int'\
    \ to type '[Int]'\n        l1 = l1[0:n]\n             ~~^~~~~\n/tmp/tmpk50v9fij.swift:13:9:\
    \ error: cannot assign value of type 'Int' to type '[Int]'\n        l2 = l2[0:n]\n\
    \             ~~^~~~~\n/tmp/tmpk50v9fij.swift:15:41: error: extra argument 'repeatedValue'\
    \ in call\n        var u = Array(count: m, repeatedValue: Int()) // unique in\
    \ l1, unique in l2\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = l1\n    for i in l2 {\n        if !contains(result,\
    \ i) {\n            result = append(result, i)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3jbjwo30.swift:10:13: error: cannot find 'contains' in scope\n\
    \        if !contains(result, i) {\n            ^~~~~~~~\n/tmp/tmp3jbjwo30.swift:11:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, i)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var shared: Set<Int> = Set()\n    var arr: [Int]\
    \ = []\n\n    for x in l1 {\n        shared.insert(x)\n    }\n\n    for x in l2\
    \ {\n        if shared.contains(x) {\n            shared.insert(x)\n        }\
    \ else {\n            arr.append(x)\n        }\n    }\n\n    return arr\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpcc7ugdmm/tmpcc7ugdmm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3863e6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3863b65b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3863b65988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3863b647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcc7ugdmm                        0x000055663348676c <unavailable> + 5996

    5    libc.so.6                          0x00002b386405a460 __libc_start_main +
    245

    6    tmpcc7ugdmm                        0x00005566334862e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  var l1idx = l1Indexes(l1)\n  var l2idx = l2Indexes(l2)\n\
    \  rebuildIndexes()\n  var l = l1idx.count\n  var r = l2idx.count\n\n  var out:\
    \ [Int] = []\n\n  // Search for common elements in both arrays\n  while l > 0\
    \ || r > 0 {\n    var maxIndex: Int = l > r ? l : r\n    if maxIndex == 0 {\n\
    \      return out\n    }\n\n    if l1idx[maxIndex-1] == l2idx[maxIndex-1] {\n\
    \      out.append(l1idx[maxIndex-1])\n      l -= 1\n      r -= 1\n    } else {\n\
    \      // Increment maxIndex and search again from the current position or\n \
    \     // maxIndex for all elements.\n      var currentMaxIndex = maxIndex\n  \
    \    for i in\n          0..<l1idx.count {\n        if l1idx[i] == l2idx[currentMaxIndex]\
    \ {\n          out.append(l1idx[i])\n          l -= 1\n          r -= 1\n    \
    \      currentMaxIndex -= 1\n        } else if l1idx[i] == l2idx[currentMaxIndex-1]\
    \ {\n          currentMaxIndex -= 1\n        }\n      }\n    }\n  }\n\n  return\
    \ out\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34,\
    \ 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4fho7w73.swift:8:15: error: cannot find 'l1Indexes' in scope\n\
    \  var l1idx = l1Indexes(l1)\n              ^~~~~~~~~\n/tmp/tmp4fho7w73.swift:9:15:\
    \ error: cannot find 'l2Indexes' in scope\n  var l2idx = l2Indexes(l2)\n     \
    \         ^~~~~~~~~\n/tmp/tmp4fho7w73.swift:10:3: error: cannot find 'rebuildIndexes'\
    \ in scope\n  rebuildIndexes()\n  ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    var j = 0\n    var k\
    \ = 0\n    var lastElem = l1[0]\n    for _, b in l1[j:] {\n        while k < j\
    \ {\n            k += 1\n            if l1[k] == b {\n                result.append(b)\n\
    \                lastElem = b\n                break\n            }\n        }\n\
    \    }\n    for _, b in l2[j:] {\n        while k < j {\n            k += 1\n\
    \            if l2[k] == b {\n                result.append(b)\n             \
    \   lastElem = b\n                break\n            }\n        }\n    }\n   \
    \ result.append(lastElem)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdb97tn9j.swift:12:10: error: expected 'in' after for-each pattern\n\
    \    for _, b in l1[j:] {\n         ^\n/tmp/tmpdb97tn9j.swift:12:10: error: expected\
    \ Sequence expression for for-each loop\n    for _, b in l1[j:] {\n         ^\n\
    /tmp/tmpdb97tn9j.swift:22:10: error: expected 'in' after for-each pattern\n  \
    \  for _, b in l2[j:] {\n         ^\n/tmp/tmpdb97tn9j.swift:22:10: error: expected\
    \ Sequence expression for for-each loop\n    for _, b in l2[j:] {\n         ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    var l1Len = l1.count\n\
    \    var l2Len = l2.count\n\n    for (i = 0; i < l1Len; i++) {\n        if l1.contains(l2[i])\
    \ {\n            result.append(l2[i])\n        }\n    }\n    for (i = 0; i < l2Len;\
    \ i++) {\n        if l2.contains(l1[i]) {\n            result.append(l1[i])\n\
    \        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpenkvbrbn.swift:12:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (i = 0; i < l1Len; i++) {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpenkvbrbn.swift:17:5: error: C-style for statement has been removed in\
    \ Swift 3\n    for (i = 0; i < l2Len; i++) {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ set1.intersection(set2).sorted().sorted(by: <)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n     \
    \   for j in l2 {\n            if i == j {\n                continue\n       \
    \     } else {\n                result.append(i)\n                break\n    \
    \        }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpegko5lo2/tmpegko5lo2.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bae239c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1badf30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1badf30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1badf2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpegko5lo2                        0x00005584b040560c <unavailable> + 5644

    5    libc.so.6                          0x00002b1bae425460 __libc_start_main +
    245

    6    tmpegko5lo2                        0x00005584b0405189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = Set()\n    for i in l1 {\n        result.insert(i)\n\
    \    }\n    for j in l2 {\n        result.delete(j)\n    }\n    return result.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbwudt3_n.swift:8:18: error: generic parameter 'Element' could not\
    \ be inferred\n    var result = Set()\n                 ^\n/tmp/tmpbwudt3_n.swift:8:18:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var result\
    \ = Set()\n                 ^\n                    <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1.count == 0 {\n        return l2\n    }\n  \
    \  if l2.count == 0 {\n        return l1\n    }\n    // sort the lists by their\
    \ first element\n    let (L1, L2) = (l1, l2)\n    if L1[0] != L2[0] {\n      \
    \  let firstValue = L1[0]\n        let firstIdx  = l1.index(of: firstValue)\n\
    \        let secondValue = L2[0]\n        let secondIdx  = l2.index(of: secondValue)\n\
    \        // If they are equal sort the other way.\n        if firstIdx == secondIdx\
    \ {\n            L1 = L1.sorted()\n            L2 = L2.sorted()\n        }\n \
    \   }\n    // find first common element\n    var l3 = [Int]()\n    let firstElement\
    \ = L1[0]\n    var i = 0\n    while i < L1.count {\n        if L1[i] == firstElement\
    \ {\n            l3.append(L1[i])\n            i += 1\n        }\n        i +=\
    \ 1\n    }\n    // find second common element\n    i = 0\n    while i < L2.count\
    \ {\n        if L2[i] == firstElement {\n            l3.append(L2[i])\n      \
    \      i += 1\n        }\n        i += 1\n    }\n    return l3\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4sf8o3bq.swift:18:28: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let firstIdx  = l1.index(of: firstValue)\n   \
    \                        ^\n/tmp/tmp4sf8o3bq.swift:18:28: note: use 'firstIndex(of:)'\
    \ instead\n        let firstIdx  = l1.index(of: firstValue)\n                \
    \           ^~~~~\n                           firstIndex\n/tmp/tmp4sf8o3bq.swift:20:29:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ secondIdx  = l2.index(of: secondValue)\n                            ^\n/tmp/tmp4sf8o3bq.swift:20:29:\
    \ note: use 'firstIndex(of:)' instead\n        let secondIdx  = l2.index(of: secondValue)\n\
    \                            ^~~~~\n                            firstIndex\n/tmp/tmp4sf8o3bq.swift:23:13:\
    \ error: cannot assign to value: 'L1' is a 'let' constant\n            L1 = L1.sorted()\n\
    \            ^~\n/tmp/tmp4sf8o3bq.swift:15:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let (L1, L2) = (l1, l2)\n    ^~~\n    var\n/tmp/tmp4sf8o3bq.swift:24:13:\
    \ error: cannot assign to value: 'L2' is a 'let' constant\n            L2 = L2.sorted()\n\
    \            ^~\n/tmp/tmp4sf8o3bq.swift:15:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let (L1, L2) = (l1, l2)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var commonElements = l1\n    for element in l2 {\n\
    \        if commonElements.contains(element) {\n            commonElements.remove(element)\n\
    \        }\n    }\n    return commonElements\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkv9bsr9e.swift:11:28: error: no exact matches in call to instance\
    \ method 'remove'\n            commonElements.remove(element)\n              \
    \             ^\nSwift.Array:10:37: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(at:)')\n    @inlinable public mutating func remove(at index:\
    \ Int) -> Element\n                                    ^\nSwift.RangeReplaceableCollection:9:37:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(at:)')\n   \
    \ @inlinable public mutating func remove(at position: Self.Index) -> Self.Element\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return common(common(Array.toIx(l1), Array.toIx(l2)),\
    \ Array(l1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpx3vkom_n.swift:8:18: error: missing argument labels 'l1:l2:' in\
    \ call\n    return common(common(Array.toIx(l1), Array.toIx(l2)), Array(l1))\n\
    \                 ^\n                  l1:                                   \
    \  l2: \n/tmp/tmpx3vkom_n.swift:8:25: error: missing argument labels 'l1:l2:'\
    \ in call\n    return common(common(Array.toIx(l1), Array.toIx(l2)), Array(l1))\n\
    \                        ^\n                         l1:             l2: \n/tmp/tmpx3vkom_n.swift:8:26:\
    \ error: generic parameter 'Element' could not be inferred\n    return common(common(Array.toIx(l1),\
    \ Array.toIx(l2)), Array(l1))\n                         ^\n/tmp/tmpx3vkom_n.swift:8:26:\
    \ note: explicitly specify the generic arguments to fix this issue\n    return\
    \ common(common(Array.toIx(l1), Array.toIx(l2)), Array(l1))\n                \
    \         ^\n                              <Any>\n/tmp/tmpx3vkom_n.swift:8:32:\
    \ error: type 'Array<Element>' has no member 'toIx'\n    return common(common(Array.toIx(l1),\
    \ Array.toIx(l2)), Array(l1))\n                         ~~~~~ ^~~~\n/tmp/tmpx3vkom_n.swift:8:42:\
    \ error: generic parameter 'Element' could not be inferred\n    return common(common(Array.toIx(l1),\
    \ Array.toIx(l2)), Array(l1))\n                                         ^\n/tmp/tmpx3vkom_n.swift:8:42:\
    \ note: explicitly specify the generic arguments to fix this issue\n    return\
    \ common(common(Array.toIx(l1), Array.toIx(l2)), Array(l1))\n                \
    \                         ^\n                                              <Any>\n\
    /tmp/tmpx3vkom_n.swift:8:48: error: type 'Array<Element>' has no member 'toIx'\n\
    \    return common(common(Array.toIx(l1), Array.toIx(l2)), Array(l1))\n      \
    \                                   ~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1 == l2 { return l1 }\n    let result = l1\n\
    \    if l1.count != l2.count { return l1 }\n    for i in l1 {\n        guard l2.contains(i)\
    \ else { return l1 }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp_mirelw8/tmp_mirelw8.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af89d284c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af89cf7bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af89cf7b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af89cf7a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_mirelw8                        0x00005599522f367c <unavailable> + 5756

    5    libc.so.6                          0x00002af89d470460 __libc_start_main +
    245

    6    tmp_mirelw8                        0x00005599522f31f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let s1  = Set(l1)\n    let s2  = Set(l2)\n    return\
    \ Array([s1.intersection(s2)])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpf_vi27_9.swift:10:22: error: cannot convert value of type 'Set<Int>'\
    \ to expected element type 'Int'\n    return Array([s1.intersection(s2)])\n  \
    \                   ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l1: NSArray = l1\n    var l2: NSArray = l2\n\n\
    \    var res: [Int] = []\n\n    for x in l1 {\n        for y in l2 {\n       \
    \     if x == y {\n                res.append(x)\n                break\n    \
    \        }\n        }\n    }\n\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6scinvgt.swift:8:13: error: cannot find type 'NSArray' in scope\n\
    \    var l1: NSArray = l1\n            ^~~~~~~\n/tmp/tmp6scinvgt.swift:9:13: error:\
    \ cannot find type 'NSArray' in scope\n    var l2: NSArray = l2\n            ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = Set()\n    for element in l1 {\n   \
    \     result.insert(element)\n    }\n    for element in l2 {\n        result.insert(element)\n\
    \    }\n    result.sort()\n    return Array(result)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4y7fqlo8.swift:8:18: error: generic parameter 'Element' could not\
    \ be inferred\n    var result = Set()\n                 ^\n/tmp/tmp4y7fqlo8.swift:8:18:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var result\
    \ = Set()\n                 ^\n                    <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // Check both array are of same length\n    if l1.count\
    \ != l2.count {\n        return nil\n    }\n\n    var results = [Int]()\n\n  \
    \  for i in 0..<l1.count {\n        if l1[i] == l2[i] {\n            results.append(l1[i])\n\
    \        }\n    }\n\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1k_8226j.swift:10:16: error: 'nil' is incompatible with return\
    \ type '[Int]'\n        return nil\n               ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for num1 in l1 {\n    \
    \    for num2 in l2 {\n            if num1 == num2 {\n                continue\n\
    \            }\n            if result.contains(&num1) {\n                continue\n\
    \            }\n            if result.contains(&num2) {\n                continue\n\
    \            }\n            result.append(num1)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4h9483uv.swift:14:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if result.contains(&num1) {\n                      \
    \         ^~~~~\n                               \n/tmp/tmp4h9483uv.swift:14:32:\
    \ error: cannot pass immutable value as inout argument: 'num1' is a 'let' constant\n\
    \            if result.contains(&num1) {\n                               ^~~~~\n\
    /tmp/tmp4h9483uv.swift:17:32: error: '&' used with non-inout argument of type\
    \ 'Int'\n            if result.contains(&num2) {\n                           \
    \    ^~~~~\n                               \n/tmp/tmp4h9483uv.swift:17:32: error:\
    \ cannot pass immutable value as inout argument: 'num2' is a 'let' constant\n\
    \            if result.contains(&num2) {\n                               ^~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var results = [Int]()\n    var pointers = [Int]()\n\
    \    var size1 = 0\n    var size2 = 0\n    while size1 < l1.count {\n        size2++\n\
    \    }\n    while size2 < l2.count {\n        pointers[size2] = l2\n        size2++\n\
    \    }\n    while size1 < l1.count {\n        pointers[size1] = l1\n        size1++\n\
    \    }\n    for var i = 0; i < l1.count; i++ {\n        var j = 0\n        while\
    \ j < l2.count {\n            if l1[i] == pointers[j] {\n                results.append(l1[i])\n\
    \            }\n            j++\n        }\n    }\n    return results\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp642so2wd.swift:23:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < l1.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp642so2wd.swift:13:14: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        size2++\n             ^~\n/tmp/tmp642so2wd.swift:16:27:\
    \ error: cannot assign value of type '[Int]' to subscript of type 'Int'\n    \
    \    pointers[size2] = l2\n                          ^~\n/tmp/tmp642so2wd.swift:17:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        size2++\n\
    \             ^~\n/tmp/tmp642so2wd.swift:20:27: error: cannot assign value of\
    \ type '[Int]' to subscript of type 'Int'\n        pointers[size1] = l1\n    \
    \                      ^~\n/tmp/tmp642so2wd.swift:21:14: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        size1++\n             ^~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1 == l2 { return l1 }\n    var l1 = l1\n    var\
    \ l2 = l2\n    var ret = [Int](count: l1.count, {_ in 0})\n    var isInL1 = false\n\
    \    var isInL2 = false\n    for index in 0 ..< l1.count {\n        if l1[index]\
    \ != l2[index] {\n            ret[index] = l1[index]\n            if l1[index]\
    \ == l2[index] {\n                isInL1 = true\n                isInL2 = true\n\
    \            } else {\n                if !isInL1 { isInL1 = true }\n        \
    \        if !isInL2 { isInL2 = true }\n            }\n        }\n    }\n    return\
    \ ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34,\
    \ 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0qptmykw.swift:11:20: error: incorrect argument labels in call\
    \ (have 'count:_:', expected 'unsafeUninitializedCapacity:initializingWith:')\n\
    \    var ret = [Int](count: l1.count, {_ in 0})\n                   ^~~~~~\n \
    \                   unsafeUninitializedCapacity initializingWith: \n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var array: [Int] = []\n    for element in l1 {\n\
    \        if l2.contains(element) {\n            array.append(element)\n      \
    \  }\n    }\n    return array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpf6fmtj5f/tmpf6fmtj5f.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b653b866c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b653b55db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b653b55d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b653b55c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf6fmtj5f                        0x00005607a54f767c <unavailable> + 5756

    5    libc.so.6                          0x00002b653ba52460 __libc_start_main +
    245

    6    tmpf6fmtj5f                        0x00005607a54f71f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let m = l1.count\n    let n = l2.count\n    var l\
    \ = l1\n    var r = l2\n    let k = (m - n) + 1\n    while (k > 0) {\n       \
    \ if l[0] == r[0] {\n            l.remove(at: 0)\n            r.remove(at: 0)\n\
    \            k -= 1\n        } else {\n            var index = 0\n           \
    \ guard let r1 = r.index(of: l[0]) else { return [] }\n            for element\
    \ in r {\n                if l[index] == element {\n                    index\
    \ -= 1\n                    break\n                }\n            }\n        \
    \    l.remove(at: index)\n            r.remove(at: index)\n            k -= 1\n\
    \        }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp5u340ah_.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'k' is a 'let' constant\n            k -= 1\n            ~ ^\n/tmp/tmp5u340ah_.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let k = (m - n) + 1\n  \
    \  ^~~\n    var\n/tmp/tmp5u340ah_.swift:20:30: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n            guard let r1 = r.index(of: l[0]) else\
    \ { return [] }\n                             ^\n/tmp/tmp5u340ah_.swift:20:30:\
    \ note: use 'firstIndex(of:)' instead\n            guard let r1 = r.index(of:\
    \ l[0]) else { return [] }\n                             ^~~~~\n             \
    \                firstIndex\n/tmp/tmp5u340ah_.swift:29:15: error: left side of\
    \ mutating operator isn't mutable: 'k' is a 'let' constant\n            k -= 1\n\
    \            ~ ^\n/tmp/tmp5u340ah_.swift:12:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let k = (m - n) + 1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for a in l1 {\n     \
    \   for b in l2 {\n            if a == b {\n                continue\n       \
    \     }\n            for c in result {\n                if a == c {\n        \
    \            break\n                }\n                if b == c {\n         \
    \           break\n                }\n            }\n            if a != b {\n\
    \                result.append(a)\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmp11ss32ux/tmp11ss32ux.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67ecbebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67ec8e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67ec8e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67ec8e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp11ss32ux                        0x000055922ea0660c <unavailable> + 5644

    5    libc.so.6                          0x00002b67ecdd7460 __libc_start_main +
    245

    6    tmp11ss32ux                        0x000055922ea06189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1.count > l2.count {\n        l1, l2 = l2, l1\n\
    \    }\n    var common = l1\n    for element in l2 {\n        if element != nil\
    \ {\n            for commonIndex in 0..<common.count {\n                if common[commonIndex]\
    \ == element {\n                    break\n                } else {\n        \
    \            common.removeAtIndex(commonIndex)\n                }\n          \
    \  }\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpz1mzhol9.swift:9:11: error: consecutive statements on a line must\
    \ be separated by ';'\n        l1, l2 = l2, l1\n          ^\n          ;\n/tmp/tmpz1mzhol9.swift:9:11:\
    \ error: expected expression\n        l1, l2 = l2, l1\n          ^\n/tmp/tmpz1mzhol9.swift:9:9:\
    \ warning: expression of type '[Int]' is unused\n        l1, l2 = l2, l1\n   \
    \     ^~\n/tmp/tmpz1mzhol9.swift:13:20: warning: comparing non-optional value\
    \ of type 'Int' to 'nil' always returns true\n        if element != nil {\n  \
    \         ~~~~~~~ ^  ~~~\n/tmp/tmpz1mzhol9.swift:18:28: error: value of type '[Int]'\
    \ has no member 'removeAtIndex'\n                    common.removeAtIndex(commonIndex)\n\
    \                    ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard let firstArray = l1.sorted(), let secondArray\
    \ = l2.sorted() else { return [] }\n    var result: [Int] = []\n    for x in firstArray\
    \ {\n        if secondArray.contains(x) {\n            result.append(x)\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3552jfix.swift:8:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let firstArray = l1.sorted(),\
    \ let secondArray = l2.sorted() else { return [] }\n          ^              \
    \  ~~~~~~~~~~~\n/tmp/tmp3552jfix.swift:8:41: error: initializer for conditional\
    \ binding must have Optional type, not '[Int]'\n    guard let firstArray = l1.sorted(),\
    \ let secondArray = l2.sorted() else { return [] }\n                         \
    \               ^                 ~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let num1 = l1.count\n    let num2 = l2.count\n  \
    \  var common = [Int]()\n    for i in 0..<min(num1, num2) {\n        for j in\
    \ 0..<min(num1, num2) {\n            if l1[i] == l2[j] {\n                common.append(l1[i])\n\
    \                break\n            }\n        }\n    }\n    return common\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp9sbwe7zp/tmp9sbwe7zp.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e45a7fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e45776b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e45776988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e457757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9sbwe7zp                        0x00005556e37ce7bc <unavailable> + 6076

    5    libc.so.6                          0x00002b7e45c6b460 __libc_start_main +
    245

    6    tmp9sbwe7zp                        0x00005556e37ce339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for i in l1 {\n     \
    \   if l2.contains(i) {\n            common.append(i)\n        }\n    }\n    return\
    \ common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpllm0489u/tmpllm0489u.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2f4009c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2f3d00b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2f3d00988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2f3cff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllm0489u                        0x00005635a2c5267c <unavailable> + 5756

    5    libc.so.6                          0x00002ae2f41f5460 __libc_start_main +
    245

    6    tmpllm0489u                        0x00005635a2c521f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard let l1 = l1.sorted else { return l1 }\n   \
    \ guard let l2 = l2.sorted else { return l2 }\n    let common = Array(zip(l1,\
    \ l2)).filter { l1.contains($0.0)\n        && l2.contains($1.0)\n    }.map({ $0.0\
    \ }).sorted()\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkl0o8937.swift:8:11: error: initializer for conditional binding\
    \ must have Optional type, not '() -> [Int]'\n    guard let l1 = l1.sorted else\
    \ { return l1 }\n          ^        ~~~~~~~~~\n/tmp/tmpkl0o8937.swift:9:11: error:\
    \ initializer for conditional binding must have Optional type, not '() -> [Int]'\n\
    \    guard let l2 = l2.sorted else { return l2 }\n          ^        ~~~~~~~~~\n\
    /tmp/tmpkl0o8937.swift:10:24: error: missing argument label 'arrayLiteral:' in\
    \ call\n    let common = Array(zip(l1, l2)).filter { l1.contains($0.0)\n     \
    \                  ^\n                       arrayLiteral: \n/tmp/tmpkl0o8937.swift:10:44:\
    \ error: unable to infer type of a closure parameter '$0' in the current context\n\
    \    let common = Array(zip(l1, l2)).filter { l1.contains($0.0)\n            \
    \                               ^\n/tmp/tmpkl0o8937.swift:10:44: error: unable\
    \ to infer type of a closure parameter '$1' in the current context\n    let common\
    \ = Array(zip(l1, l2)).filter { l1.contains($0.0)\n                          \
    \                 ^\n/tmp/tmpkl0o8937.swift:10:24: error: type '() -> [Int]' cannot\
    \ conform to 'Sequence'\n    let common = Array(zip(l1, l2)).filter { l1.contains($0.0)\n\
    \                       ^\n/tmp/tmpkl0o8937.swift:10:24: note: only concrete types\
    \ such as structs, enums and classes can conform to protocols\n    let common\
    \ = Array(zip(l1, l2)).filter { l1.contains($0.0)\n                       ^\n\
    /tmp/tmpkl0o8937.swift:10:24: note: required by global function 'zip' where 'Sequence1'\
    \ = '() -> [Int]'\n    let common = Array(zip(l1, l2)).filter { l1.contains($0.0)\n\
    \                       ^\n/tmp/tmpkl0o8937.swift:10:24: error: type '() -> [Int]'\
    \ cannot conform to 'Sequence'\n    let common = Array(zip(l1, l2)).filter { l1.contains($0.0)\n\
    \                       ^\n/tmp/tmpkl0o8937.swift:10:24: note: only concrete types\
    \ such as structs, enums and classes can conform to protocols\n    let common\
    \ = Array(zip(l1, l2)).filter { l1.contains($0.0)\n                       ^\n\
    /tmp/tmpkl0o8937.swift:10:24: note: required by global function 'zip' wher"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var n = l1.count\n\
    \    while i < n && j < n {\n        if l1[i] == l2[j] {\n            i += 1\n\
    \            j += 1\n        } else {\n            if l1[i] < l2[j] {\n      \
    \          i += 1\n            } else {\n                j += 1\n            }\n\
    \        }\n    }\n    while i < n {\n        i += 1\n        j += 1\n    }\n\
    \    while j < n {\n        j += 1\n    }\n    return l1[i..<j]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpa1vniya4.swift:30:14: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return l1[i..<j]\n      \
    \     ~~^~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return zip(l1, l2).filter { (_, e) in e }.map { ($0.0,\
    \ $0.1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpohefai0q.swift:8:53: error: cannot convert value of type '(Int,\
    \ Int)' to closure result type 'Int'\n    return zip(l1, l2).filter { (_, e) in\
    \ e }.map { ($0.0, $0.1) }\n                                                 \
    \   ^~~~~~~~~~~~\n/tmp/tmpohefai0q.swift:8:43: error: cannot convert value of\
    \ type 'Int' to closure result type 'Bool'\n    return zip(l1, l2).filter { (_,\
    \ e) in e }.map { ($0.0, $0.1) }\n                                          ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n\n    for e in l1 {\n   \
    \     if l2.contains(e) {\n            result.append(e)\n        }\n    }\n\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpi2hcmbyn/tmpi2hcmbyn.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac44fe10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac44fb07b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac44fb07988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac44fb067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi2hcmbyn                        0x000055c8ea97067c <unavailable> + 5756

    5    libc.so.6                          0x00002ac44fffc460 __libc_start_main +
    245

    6    tmpi2hcmbyn                        0x000055c8ea9701f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var pos1 = 0\n    var pos2\
    \ = 0\n    var len1 = l1.count\n    var len2 = l2.count\n    while pos1 < len1\
    \ && pos2 < len2 {\n        if l1[pos1] == l2[pos2] {\n            result.append(l1[pos1])\n\
    \            pos1 += 1\n            pos2 += 1\n        }\n        else if l1[pos1]\
    \ > l2[pos2] {\n            pos1 += 1\n        }\n        else if l1[pos1] < l2[pos2]\
    \ {\n            pos2 += 1\n        }\n    }\n    while pos1 < len1 {\n      \
    \  result.append(l1[pos1])\n        pos1 += 1\n    }\n    while pos2 < len2 {\n\
    \        result.append(l2[pos2])\n        pos2 += 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpquf00tva/tmpquf00tva.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acca8fdbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acca8cd2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acca8cd2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acca8cd17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpquf00tva                        0x00005622f663a5ac <unavailable> + 5548

    5    libc.so.6                          0x00002acca91c7460 __libc_start_main +
    245

    6    tmpquf00tva                        0x00005622f663a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var found = 0\n    for\
    \ x in l1 {\n        if l2.contains(x) {\n            result[found] = x\n    \
    \        found += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af102e58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af102b4f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af102b4f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af102b4f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af102b4ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af10294e7ec <unavailable> + 186348

    6    tmpbaxy1o70                        0x000055d3f28e5cf9 <unavailable> + 7417

    7    tmpbaxy1o70                        0x000055d3f28e55e3 <unavailable> + 5603

    8    libc.so.6                          0x00002af103044460 __libc_start_main +
    245

    9    tmpbaxy1o70                        0x000055d3f28e5249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in 0 ..< min(l1.count,\
    \ l2.count) {\n        if l1[i] == l2[i] {\n            result.append(l1[i])\n\
    \        }\n    }\n    for j in 0 ..< min(l1.count, l2.count) {\n        if !contains(result,\
    \ l1[j]) {\n            result.append(l1[j])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppvseuwmb.swift:15:13: error: cannot find 'contains' in scope\n\
    \        if !contains(result, l1[j]) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // Find the smallest set\n    var smallest = l1\n\
    \    var smallerSet: Set<Int> = Set()\n    for elem in l2 {\n        if smallest\
    \ == elem {\n            continue\n        } else {\n            if !smallerSet.contains(elem)\
    \ {\n                smallerSet.insert(elem)\n            } else {\n         \
    \       return []\n            }\n        }\n    }\n    if !smallerSet.contains(smallest)\
    \ {\n        smallerSet.insert(smallest)\n    }\n    return smallerSet.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4bgxprps.swift:12:21: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n        if smallest == elem {\n     \
    \      ~~~~~~~~ ^  ~~~~\n/tmp/tmp4bgxprps.swift:12:21: note: overloads for '=='\
    \ exist with these partially matching parameter lists: (Int, Int)\n        if\
    \ smallest == elem {\n                    ^\n/tmp/tmp4bgxprps.swift:23:27: error:\
    \ cannot convert value of type '[Int]' to expected argument type 'Int'\n     \
    \   smallerSet.insert(smallest)\n                          ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n       \
    \ for j in l2 {\n            if i == j {\n                result.append(i)\n \
    \           }\n        }\n    }\n    return result.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp1eclpvfl/tmp1eclpvfl.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3716789c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3716480b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3716480988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b371647f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1eclpvfl                        0x00005650a573670c <unavailable> + 5900

    5    libc.so.6                          0x00002b3716975460 __libc_start_main +
    245

    6    tmp1eclpvfl                        0x00005650a5736289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979280
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var commonCount = 0\n\
    \    while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n     \
    \       commonCount++\n        }\n        i += 1\n        j += 1\n    }\n    return\
    \ Array(l1[..<min(i, j)]).sorted() + Array(l2[..<min(i, j)])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp18t063zx.swift:13:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            commonCount++\n                       ^~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var u = [Int]()\n    for x in l1 {\n        if !contains(u,\
    \ x) {\n            u.append(x)\n        }\n    }\n    for x in l2 {\n       \
    \ if !contains(u, x) {\n            u.append(x)\n        }\n    }\n    return\
    \ u\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653,\
    \ 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5,\
    \ 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2,\
    \ 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as\
    \ [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprx70pxkp.swift:10:13: error: cannot find 'contains' in scope\n\
    \        if !contains(u, x) {\n            ^~~~~~~~\n/tmp/tmprx70pxkp.swift:15:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(u, x) {\n     \
    \       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let m = min(l1.count, l2.count)\n    var res: [Int]\
    \ = []\n    for i in 0..<m {\n        let x = l1[i] > l2[i] ? l1[i] : l2[i]\n\
    \        if res.contains(&x) {\n            continue\n        }\n        res.append(x)\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbnpbhame.swift:12:25: error: '&' used with non-inout argument of\
    \ type 'Int'\n        if res.contains(&x) {\n                        ^~\n    \
    \                    \n/tmp/tmpbnpbhame.swift:12:25: error: cannot pass immutable\
    \ value as inout argument: 'x' is a 'let' constant\n        if res.contains(&x)\
    \ {\n                        ^~\n/tmp/tmpbnpbhame.swift:11:9: note: change 'let'\
    \ to 'var' to make it mutable\n        let x = l1[i] > l2[i] ? l1[i] : l2[i]\n\
    \        ^~~\n        var\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var i = 0\n    var j =\
    \ 0\n    while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n \
    \           result.append(l1[i])\n            i += 1\n            j += 1\n   \
    \     } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n      \
    \      j += 1\n        }\n    }\n    while i < l1.count {\n        result.append(l1[i])\n\
    \        i += 1\n    }\n    while j < l2.count {\n        result.append(l2[j])\n\
    \        j += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp0nuzuzyt/tmp0nuzuzyt.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0fe9661c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0fe9358b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0fe9358988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0fe93577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0nuzuzyt                        0x0000555f2947c5ac <unavailable> + 5548

    5    libc.so.6                          0x00002b0fe984d460 __libc_start_main +
    245

    6    tmp0nuzuzyt                        0x0000555f2947c129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common = [Int]()\n    let len = min(l1.count,\
    \ l2.count)\n    for i in 0..<len {\n        if l1[i] == l2[i] {\n           \
    \ common.append(l1[i])\n        }\n    }\n    return common\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmppt7s8gl8/tmppt7s8gl8.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5ddb20c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5dd817b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5dd817988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5dd8167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppt7s8gl8                        0x0000558f90a397bc <unavailable> + 6076

    5    libc.so.6                          0x00002ae5ddd0c460 __libc_start_main +
    245

    6    tmppt7s8gl8                        0x0000558f90a39339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1: CFMutableArray = CFArrayCreateMutable(nil,\
    \ CFArrayGetCount(l1), &kCFTypeArrayCallBacks)\n    let l2: CFMutableArray = CFArrayCreateMutable(nil,\
    \ CFArrayGetCount(l2), &kCFTypeArrayCallBacks)\n\n    for i in 0..<CFArrayGetCount(l1)\
    \ {\n        CFArraySetValueAtIndex(l1, i, CFNumberCreate(kCFAllocatorSystemDefault,\
    \ CFNumberType(kCFNumberIntType)))\n    }\n    for i in 0..<CFArrayGetCount(l2)\
    \ {\n        CFArraySetValueAtIndex(l2, i, CFNumberCreate(kCFAllocatorSystemDefault,\
    \ CFNumberType(kCFNumberIntType)))\n    }\n    let common: CFArray = CFArrayIntersection(l1,\
    \ l2)\n    let result: CFMutableArray = CFArrayCreateMutable(nil, CFArrayGetCount(common),\
    \ &kCFTypeArrayCallBacks)\n    CFArraySortValues(common, &kCFTypeArrayCallBacks)\n\
    \    CFArrayAppendArray(result, common)\n\n    return CFArrayGetValueAtIndex(result,\
    \ 0) as! [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp44m6lxf0.swift:8:13: error: cannot find type 'CFMutableArray' in\
    \ scope\n    let l1: CFMutableArray = CFArrayCreateMutable(nil, CFArrayGetCount(l1),\
    \ &kCFTypeArrayCallBacks)\n            ^~~~~~~~~~~~~~\n/tmp/tmp44m6lxf0.swift:9:13:\
    \ error: cannot find type 'CFMutableArray' in scope\n    let l2: CFMutableArray\
    \ = CFArrayCreateMutable(nil, CFArrayGetCount(l2), &kCFTypeArrayCallBacks)\n \
    \           ^~~~~~~~~~~~~~\n/tmp/tmp44m6lxf0.swift:11:18: error: cannot find 'CFArrayGetCount'\
    \ in scope\n    for i in 0..<CFArrayGetCount(l1) {\n                 ^~~~~~~~~~~~~~~\n\
    /tmp/tmp44m6lxf0.swift:14:18: error: cannot find 'CFArrayGetCount' in scope\n\
    \    for i in 0..<CFArrayGetCount(l2) {\n                 ^~~~~~~~~~~~~~~\n/tmp/tmp44m6lxf0.swift:17:17:\
    \ error: cannot find type 'CFArray' in scope\n    let common: CFArray = CFArrayIntersection(l1,\
    \ l2)\n                ^~~~~~~\n/tmp/tmp44m6lxf0.swift:18:17: error: cannot find\
    \ type 'CFMutableArray' in scope\n    let result: CFMutableArray = CFArrayCreateMutable(nil,\
    \ CFArrayGetCount(common), &kCFTypeArrayCallBacks)\n                ^~~~~~~~~~~~~~\n\
    /tmp/tmp44m6lxf0.swift:19:5: error: cannot find 'CFArraySortValues' in scope\n\
    \    CFArraySortValues(common, &kCFTypeArrayCallBacks)\n    ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp44m6lxf0.swift:19:32: error: cannot find 'kCFTypeArrayCallBacks' in scope\n\
    \    CFArraySortValues(common, &kCFTypeArrayCallBacks)\n                     \
    \          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp44m6lxf0.swift:20:5: error: cannot find\
    \ 'CFArrayAppendArray' in scope\n    CFArrayAppendArray(result, common)\n    ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp44m6lxf0.swift:22:12: error: cannot find 'CFArrayGetValueAtIndex' in scope\n\
    \    return CFArrayGetValueAtIndex(result, 0) as! [Int]\n           ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l = []\n    for _, _ in l1l1l2(l1, l2) {\n  \
    \      l.append(_)\n    }\n    l = l.sort()\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpmo3c85ck.swift:9:10: error: expected 'in' after for-each pattern\n\
    \    for _, _ in l1l1l2(l1, l2) {\n         ^\n/tmp/tmpmo3c85ck.swift:9:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, _ in l1l1l2(l1, l2)\
    \ {\n         ^\n/tmp/tmpmo3c85ck.swift:8:13: error: empty collection literal\
    \ requires an explicit type\n    var l = []\n            ^~\n/tmp/tmpmo3c85ck.swift:13:12:\
    \ error: cannot convert return expression of type '[Any]' to return type '[Int]'\n\
    \    return l\n           ^\n/tmp/tmpmo3c85ck.swift:13:12: note: arguments to\
    \ generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n   \
    \ return l\n           ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = l1\n    result.sort() // TODO: use a\
    \ better algorithm to sort arrays, e.g. mergesort\n    l2.forEach { result.contains($0)\
    \ }\n    return Array(result).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzzq85yo5/tmpzzq85yo5.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0df7deec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0df7ae5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0df7ae5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0df7ae47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzzq85yo5                        0x000055777df8170c <unavailable> + 5900

    5    libc.so.6                          0x00002b0df7fda460 __libc_start_main +
    245

    6    tmpzzq85yo5                        0x000055777df81289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var sortedL1 = Array(l1)\n    var sortedL2 = Array(l2)\n\
    \    sortedL1.sort()\n    sortedL2.sort()\n    var result = [Int]()\n    for i\
    \ in 0 ..< sortedL1.count {\n        if sortedL1[i] == sortedL2[i] {\n       \
    \     result.append(sortedL1[i])\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp4j6hbmnh/tmp4j6hbmnh.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d89945c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d8963cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d8963c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d8963b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4j6hbmnh                        0x0000556bc64928bc <unavailable> + 6332

    5    libc.so.6                          0x00002b6d89b31460 __libc_start_main +
    245

    6    tmp4j6hbmnh                        0x0000556bc6492439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let sorted1 = Array(l1).sorted()\n    let sorted2\
    \ = Array(l2).sorted()\n    var result = [Int]()\n    for i in 0 ..< sorted1.count\
    \ {\n        if sorted1[i] == sorted2[i] {\n            result.append(sorted1[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmplbjpkt1k/tmplbjpkt1k.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2931104c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2930dfbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2930dfb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2930dfa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplbjpkt1k                        0x00005580bd6c484c <unavailable> + 6220

    5    libc.so.6                          0x00002b29312f0460 __libc_start_main +
    245

    6    tmplbjpkt1k                        0x00005580bd6c43c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count != l2.count else { return [] }\n \
    \   var result: [Int] = []\n    for i in 0 ..< l1.count {\n        let x = l1[i]\n\
    \        let y = l2[i]\n        if x != y {\n            result.append(x)\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp8liax2mh/tmp8liax2mh.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1d799ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1d7695b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1d7695988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1d76947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8liax2mh                        0x000055aa6851a6dc <unavailable> + 5852

    5    libc.so.6                          0x00002ad1d7b8a460 __libc_start_main +
    245

    6    tmp8liax2mh                        0x000055aa6851a259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let n1 = l1.count\n    let n2 = l2.count\n    var\
    \ common = [Int]()\n    for i in 0..<n1 {\n        for j in 0..<n2 {\n       \
    \     if l1[i] == l2[j] {\n                common.append(l1[i])\n            \
    \    break\n            }\n        }\n    }\n    return common\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpp2fcwytn/tmpp2fcwytn.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4f120c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc4ee17b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc4ee17988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc4ee167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp2fcwytn                        0x00005606ca25373c <unavailable> + 5948

    5    libc.so.6                          0x00002acc4f30c460 __libc_start_main +
    245

    6    tmpp2fcwytn                        0x00005606ca2532b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var index = 0\n    var i = 0\n    var j = 0\n   \
    \ var k = 0\n    var commonCount = 0\n    var result = [Int]()\n    while i <\
    \ len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result.append(l1[i])\n\
    \            i += 1\n            j += 1\n            commonCount++\n        }\
    \ else if l1[i] > l2[j] {\n            k += 1\n            commonCount += 1\n\
    \        } else {\n            k += 1\n            commonCount += 1\n        }\n\
    \        if k >= 2 {\n            break\n        }\n    }\n    while i < len(l1)\
    \ {\n        result.append(l1[i])\n        i += 1\n    }\n    while j < len(l2)\
    \ {\n        result.append(l2[j])\n        j += 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprc37s0k8.swift:14:15: error: cannot find 'len' in scope\n    while\
    \ i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmprc37s0k8.swift:14:30:\
    \ error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n\
    \                             ^~~\n/tmp/tmprc37s0k8.swift:19:24: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            commonCount++\n\
    \                       ^~\n/tmp/tmprc37s0k8.swift:31:15: error: cannot find 'len'\
    \ in scope\n    while i < len(l1) {\n              ^~~\n/tmp/tmprc37s0k8.swift:35:15:\
    \ error: cannot find 'len' in scope\n    while j < len(l2) {\n              ^~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var uniques = [Int]()\n    var uniquesLen = 0\n \
    \   var intersection = [Int]()\n    var intersectionLen = 0\n    for x in l1 {\n\
    \        for y in l2 {\n            if x == y {\n                intersection[intersectionLen]\
    \ = x\n                intersectionLen++\n            } else {\n             \
    \   for k in uniques {\n                    if x == k {\n                    \
    \    uniques.removeAtIndex(k)\n                        break\n               \
    \     }\n                }\n                uniques[uniquesLen] = x\n        \
    \        uniquesLen++\n            }\n        }\n    }\n    for i in 0..<uniquesLen\
    \ {\n        l1[intersection[i]] = uniques[i]\n    }\n    return l1\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpb5k5cyxk.swift:16:32: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                intersectionLen++\n                  \
    \             ^~\n/tmp/tmpb5k5cyxk.swift:20:33: error: value of type '[Int]' has\
    \ no member 'removeAtIndex'\n                        uniques.removeAtIndex(k)\n\
    \                        ~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpb5k5cyxk.swift:25:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      uniquesLen++\n                          ^~\n/tmp/tmpb5k5cyxk.swift:30:11:\
    \ error: cannot assign through subscript: 'l1' is a 'let' constant\n        l1[intersection[i]]\
    \ = uniques[i]\n        ~~^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var i = 0\n    let n =\
    \ min(l1.count, l2.count)\n    while i < n {\n        if l1[i] == l2[i] {\n  \
    \          result.append(l1[i])\n            i += 1\n        } else if l1[i] >\
    \ l2[i] {\n            i += 1\n        } else {\n            i += 1\n        }\n\
    \    }\n    result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppmulm8bt.swift:21:5: warning: variable is unused\n    result\n\
    \    ^~~~~~\n/tmp/tmppmulm8bt.swift:21:5: error: missing return in global function\
    \ expected to return '[Int]'\n    result\n    ^\n/tmp/tmppmulm8bt.swift:21:5:\
    \ note: did you mean to return the last expression?\n    result\n    ^\n    return\
    \ \n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = l1\n    var j = 0\n    for i : Int \
    \ in l1 {\n        while j < l2.count && l2[j] == i {\n            j++\n     \
    \   }\n        if j == l2.count {\n            result.append(i)\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpq_raylqn.swift:12:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            j++\n             ^~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n\n    // Check for common elements\
    \ in both arrays\n    for index in 0..<min(l1.count, l2.count) {\n        let\
    \ l1Index = index(l1, index)\n        let l2Index = index(l2, index)\n       \
    \ if l1[l1Index] == l2[l2Index] {\n            result.append(l1[l1Index])\n  \
    \      } else {\n            result.insert(l1[l1Index], at: 0)\n            result.insert(l2[l2Index],\
    \ at: 0)\n        }\n    }\n\n    // Add remaining elements to result\n    if\
    \ l1.count < l2.count {\n        for index in 1..<l2.count {\n            result.append(l2[index])\n\
    \        }\n    } else {\n        for index in 1..<l1.count {\n            result.append(l1[index])\n\
    \        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqykp3n37.swift:12:23: error: cannot call value of non-function\
    \ type 'Int'\n        let l1Index = index(l1, index)\n                      ^\n\
    /tmp/tmpqykp3n37.swift:13:23: error: cannot call value of non-function type 'Int'\n\
    \        let l2Index = index(l2, index)\n                      ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count > 0 && l2.count > 0 else {\n     \
    \   return []\n    }\n    var result = [Int]()\n    var j = 0\n    for i in 0..<l1.count\
    \ {\n        if l1[i] != l2[j] {\n            result.append(l1[i])\n         \
    \   j += 1\n        } else {\n            result.append(l2[j])\n        }\n  \
    \  }\n    result.reverse()\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp29a60bit/tmp29a60bit.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff12e54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff12b4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff12b4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff12b4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29a60bit                        0x000055a449cff80c <unavailable> + 6156

    5    libc.so.6                          0x00002aff13040460 __libc_start_main +
    245

    6    tmp29a60bit                        0x000055a449cff389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for el1 in l1 {\n     \
    \   for el2 in l2 {\n            if el1 == el2 {\n                continue\n \
    \           }\n            if contains(result, el1) {\n                continue\n\
    \            }\n            if contains(result, el2) {\n                continue\n\
    \            }\n            result.append(el1)\n            result.append(el2)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxyu680ln.swift:14:16: error: cannot find 'contains' in scope\n\
    \            if contains(result, el1) {\n               ^~~~~~~~\n/tmp/tmpxyu680ln.swift:17:16:\
    \ error: cannot find 'contains' in scope\n            if contains(result, el2)\
    \ {\n               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    guard l1.count >= l2.count\
    \ else { return result }\n    for i in 0..<l1.count {\n        if l1[i] == l2[i]\
    \ { continue }\n        if l1[i] > l2[i] { break }\n        insert(&result, l1[i])\n\
    \    }\n    for i in 0..<l2.count {\n        if l2[i] > l1[i] { break }\n    \
    \    insert(&result, l2[i])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptcbsbn59.swift:13:9: error: cannot find 'insert' in scope\n   \
    \     insert(&result, l1[i])\n        ^~~~~~\n/tmp/tmptcbsbn59.swift:17:9: error:\
    \ cannot find 'insert' in scope\n        insert(&result, l2[i])\n        ^~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1 == l2 { return l1 }\n    let sorted1 = l1.sorted()\n\
    \    let sorted2 = l2.sorted()\n    if sorted1.count == 0 || sorted2.count ==\
    \ 0 {\n        return sorted1\n    }\n    if sorted1[0] != sorted2[0] {\n    \
    \    return sorted1\n    }\n    var c = 0\n    var r = 0\n    var i = 0\n    var\
    \ j = 0\n    var k = 0\n    var r1 = 0\n    var r2 = 0\n    var maxR = 0\n   \
    \ var minR = 0\n    while i < sorted1.count && j < sorted2.count {\n        if\
    \ sorted1[i] == sorted2[j] {\n            c++\n            i++\n            j++\n\
    \            continue\n        }\n        r1 = sorted1[r]\n        r2 = sorted2[r]\n\
    \        maxR = max(maxR, r1)\n        minR = min(minR, r2)\n        if r1 < r2\
    \ {\n            k = c\n            c += r1 - r2\n            r += 1\n       \
    \     sorted1[r] = r1 - k\n            sorted2[r] = k + r2\n        } else {\n\
    \            k = c\n            c += r2 - r1\n            r += 1\n           \
    \ sorted1[r] = k + r1\n            sorted2[r] = r2 - k\n        }\n    }\n   \
    \ if i < sorted1.count {\n        r1 = sorted1[r]\n        sorted1[r] = sorted2[r]\n\
    \        sorted2[r] = r1\n    }\n    sorted1.removeDuplicates()\n    sorted2.removeDuplicates()\n\
    \    return sorted1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8whg0jh9.swift:28:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            c++\n             ^~\n/tmp/tmp8whg0jh9.swift:29:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  i++\n             ^~\n/tmp/tmp8whg0jh9.swift:30:14: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            j++\n             ^~\n/tmp/tmp8whg0jh9.swift:41:20:\
    \ error: cannot assign through subscript: 'sorted1' is a 'let' constant\n    \
    \        sorted1[r] = r1 - k\n            ~~~~~~~^\n/tmp/tmp8whg0jh9.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let sorted1 = l1.sorted()\n\
    \    ^~~\n    var\n/tmp/tmp8whg0jh9.swift:42:20: error: cannot assign through\
    \ subscript: 'sorted2' is a 'let' constant\n            sorted2[r] = k + r2\n\
    \            ~~~~~~~^\n/tmp/tmp8whg0jh9.swift:10:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let sorted2 = l2.sorted()\n    ^~~\n    var\n/tmp/tmp8whg0jh9.swift:47:20:\
    \ error: cannot assign through subscript: 'sorted1' is a 'let' constant\n    \
    \        sorted1[r] = k + r1\n            ~~~~~~~^\n/tmp/tmp8whg0jh9.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let sorted1 = l1.sorted()\n\
    \    ^~~\n    var\n/tmp/tmp8whg0jh9.swift:48:20: error: cannot assign through\
    \ subscript: 'sorted2' is a 'let' constant\n            sorted2[r] = r2 - k\n\
    \            ~~~~~~~^\n/tmp/tmp8whg0jh9.swift:10:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let sorted2 = l2.sorted()\n    ^~~\n    var\n/tmp/tmp8whg0jh9.swift:53:16:\
    \ error: cannot assign through subscript: 'sorted1' is a 'let' constant\n    \
    \    sorted1[r] = sorted2[r]\n        ~~~~~~~^\n/tmp/tmp8whg0jh9.swift:9:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let sorted1 = l1.sorted()\n  \
    \  ^~~\n    var\n/tmp/tmp8whg0jh9.swift:54:16: error: cannot assign through subscript:\
    \ 'sorted2' is a 'let' constant\n        sorted2[r] = r1\n        ~~~~~~~^\n/tmp/tmp8whg0jh9.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let sorted2 = l2.sorted()\n\
    \    ^~~\n    var\n/tmp/tmp8whg0jh9.swift:56:13: error: va"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    let maxLen = min(l1.count,\
    \ l2.count)\n    for i in 0..<maxLen {\n        if l1.count != l2.count {\n  \
    \          break\n        }\n        if l1[i] == l2[i] {\n            l1 = l1[i..<l1.count]\n\
    \            l2 = l2[i..<l2.count]\n            continue\n        }\n        if\
    \ l1[i] > l2[i] {\n            l1 = l1[i..<l1.count]\n            l2 = l2[i..<l2.count]\n\
    \        } else {\n            l1 = l1[i..<l1.count]\n            l2 = l2[i..<l2.count]\n\
    \        }\n    }\n    if l1.count != l2.count {\n        return l1\n    }\n \
    \   return l2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_l2oykaw.swift:16:20: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n            l1 = l1[i..<l1.count]\n                 ~~^~~~~~~~~~~~~~\n\
    /tmp/tmp_l2oykaw.swift:17:20: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n            l2 = l2[i..<l2.count]\n                 ~~^~~~~~~~~~~~~~\n\
    /tmp/tmp_l2oykaw.swift:21:20: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n            l1 = l1[i..<l1.count]\n                 ~~^~~~~~~~~~~~~~\n\
    /tmp/tmp_l2oykaw.swift:22:20: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n            l2 = l2[i..<l2.count]\n                 ~~^~~~~~~~~~~~~~\n\
    /tmp/tmp_l2oykaw.swift:24:20: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n            l1 = l1[i..<l1.count]\n                 ~~^~~~~~~~~~~~~~\n\
    /tmp/tmp_l2oykaw.swift:25:20: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n            l2 = l2[i..<l2.count]\n                 ~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    var result = [Int]()\n\
    \    var l1Pos = 0\n    var l2Pos = 0\n    while l1.count > 0 && l2.count > 0\
    \ {\n        let l1Key = l1[l1Pos]\n        let l2Key = l2[l2Pos]\n        if\
    \ (l1Key < l2Key) {\n            result.append(l1Key)\n            l1Pos++\n \
    \       } else {\n            result.append(l2Key)\n            l2Pos++\n    \
    \    }\n    }\n    while l1.count > 0 {\n        result.append(l1[l1Pos])\n  \
    \      l1Pos++\n    }\n    while l2.count > 0 {\n        result.append(l2[l2Pos])\n\
    \        l2Pos++\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp051uz5oc.swift:18:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            l1Pos++\n                 ^~\n/tmp/tmp051uz5oc.swift:21:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  l2Pos++\n                 ^~\n/tmp/tmp051uz5oc.swift:26:14: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n        l1Pos++\n            \
    \ ^~\n/tmp/tmp051uz5oc.swift:30:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        l2Pos++\n             ^~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set([l1])\n    let set2 = Set([l2])\n\
    \    var common: [Int] = []\n    for i in set1 {\n        if set2.contains(i)\
    \ {\n            common.append(i)\n        }\n    }\n    return common\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprxmnayg8.swift:13:20: error: no exact matches in call to instance\
    \ method 'append'\n            common.append(i)\n                   ^\nSwift.Array:7:37:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n\
    \    @inlinable public mutating func append<S>(contentsOf newElements: __owned\
    \ S) where Element == S.Element, S : Sequence\n                              \
    \      ^\nSwift.RangeReplaceableCollection:5:37: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(contentsOf:)')\n    @inlinable public mutating func\
    \ append<S>(contentsOf newElements: __owned S) where S : Sequence, Self.Element\
    \ == S.Element\n                                    ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var r: [Int] = []\n    var i = 0\n    while i < l1.count\
    \ && i < l2.count {\n        if l1[i] == l2[i] {\n            r.append(l1[i])\n\
    \        } else {\n            i += 1\n        }\n    }\n    return r\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp7ldnjowt/tmp7ldnjowt.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b34a7979c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34a7670b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b34a7670988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34a766f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ldnjowt                        0x000055f5580ac55c <unavailable> + 5468

    5    libc.so.6                          0x00002b34a7b65460 __libc_start_main +
    245

    6    tmp7ldnjowt                        0x000055f5580ac0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var i1 : [Int] = l1\n    var i2 : [Int] = l2\n  \
    \  guard i1.count != i2.count else { return i1 }\n    var c = 0\n    var result\
    \ : [Int] = []\n    while i1.count > 0 && i2.count > 0 {\n        guard i1.last\
    \ == i2.first else { return i1 }\n        \n        // Find the smallest element\
    \ to remove from both arrays\n        if c < i1.count {\n            i1.removeLast()\n\
    \        }\n        if c < i2.count {\n            i2.removeFirst()\n        }\n\
    \        c++\n    }\n    for i in i1.enumerated() {\n        result.append(i.element)\n\
    \    }\n    for i in i2.enumerated() {\n        result.append(i.element)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqkg7dhqk.swift:23:10: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        c++\n         ^~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var set1 = Set<Int>(l1)\n    var set2 = Set<Int>(l2)\n\
    \    commonSets(&set1, &set2)\n    return set1.sorted() + set2.sorted()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpg3qtm1ph.swift:10:5: error: cannot find 'commonSets' in scope\n\
    \    commonSets(&set1, &set2)\n    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var current = 0\n    for\
    \ element in l1 {\n        if l2.contains(element) {\n            result.append(element)\n\
    \        } else {\n            current = element as Int\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmprfcoh_hu/tmprfcoh_hu.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6378899c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6378590b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6378590988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b637858f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprfcoh_hu                        0x0000562d894ed6cc <unavailable> + 5836

    5    libc.so.6                          0x00002b6378a85460 __libc_start_main +
    245

    6    tmprfcoh_hu                        0x0000562d894ed249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: -1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var a = l1\n    var b = l2\n    var result = [Int]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    while i < a.count && j < b.count\
    \ {\n        if a[i] == b[j] {\n            result.append(a[i])\n            i\
    \ += 1\n            j += 1\n        }\n        if i == a.count {\n           \
    \ result.append(b[j])\n            j += 1\n        }\n        if j == b.count\
    \ {\n            result.append(a[i])\n            i += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659979370
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1 = Array(l1)\n    let l2 = Array(l2)\n    var\
    \ ret = [Int]()\n    for x in l1 {\n        for y in l2 {\n            if x ==\
    \ y {\n                continue\n            }\n            ret.append(x)\n  \
    \      }\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmptco1i1oz/tmptco1i1oz.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7aab829c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7aab520b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7aab520988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7aab51f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptco1i1oz                        0x00005634fda166dc <unavailable> + 5852

    5    libc.so.6                          0x00002b7aaba15460 __libc_start_main +
    245

    6    tmptco1i1oz                        0x00005634fda16259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l1 = l1 as NSArray\n    var l2 = l2 as NSArray\n\
    \    var set1 = NSMutableSet()\n    var set2 = NSMutableSet()\n    for i in 0..<l1.count\
    \ {\n        set1.addObject(l1.objectAtIndex(i))\n    }\n    for i in 0..<l2.count\
    \ {\n        set2.addObject(l2.objectAtIndex(i))\n    }\n    var common = NSMutableArray()\n\
    \    for obj in set1.arrayByAddingObjectsFromArray(set2.arrayByAddingObjectsFromArray(common))\
    \ {\n        if !common.containsObject(obj) {\n            common.addObject(obj)\n\
    \        }\n    }\n    return common.arrayByAddingObjectsFromArray(NSArray())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkwyjkwnw.swift:8:20: error: cannot find type 'NSArray' in scope\n\
    \    var l1 = l1 as NSArray\n                   ^~~~~~~\n/tmp/tmpkwyjkwnw.swift:9:20:\
    \ error: cannot find type 'NSArray' in scope\n    var l2 = l2 as NSArray\n   \
    \                ^~~~~~~\n/tmp/tmpkwyjkwnw.swift:10:16: error: cannot find 'NSMutableSet'\
    \ in scope\n    var set1 = NSMutableSet()\n               ^~~~~~~~~~~~\n/tmp/tmpkwyjkwnw.swift:11:16:\
    \ error: cannot find 'NSMutableSet' in scope\n    var set2 = NSMutableSet()\n\
    \               ^~~~~~~~~~~~\n/tmp/tmpkwyjkwnw.swift:18:18: error: cannot find\
    \ 'NSMutableArray' in scope\n    var common = NSMutableArray()\n             \
    \    ^~~~~~~~~~~~~~\n/tmp/tmpkwyjkwnw.swift:24:49: error: cannot find 'NSArray'\
    \ in scope\n    return common.arrayByAddingObjectsFromArray(NSArray())\n     \
    \                                           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = [Int]()\n\
    \    while i < l1.count && j < l2.count {\n        if l1[i] < l2[j] {\n      \
    \      result.append(l1[i])\n            i += 1\n        } else if l1[i] > l2[j]\
    \ {\n            result.append(l2[j])\n            j += 1\n        } else {\n\
    \            result.append (l1[i])\n            i += 1\n            j += 1\n \
    \       }\n    }\n    return result.appending(l2[i...]).sorted()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpcwbnp26a.swift:24:19: error: value of type '[Int]' has no member\
    \ 'appending'\n    return result.appending(l2[i...]).sorted()\n           ~~~~~~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for x in l1 {\n     \
    \   if l2Contains(common, x) {\n            continue\n        }\n        if l2Contains(l2,\
    \ x) {\n            common.append(x)\n        } else {\n            append(common,\
    \ x)\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpujraxk8r.swift:10:12: error: cannot find 'l2Contains' in scope\n\
    \        if l2Contains(common, x) {\n           ^~~~~~~~~~\n/tmp/tmpujraxk8r.swift:13:12:\
    \ error: cannot find 'l2Contains' in scope\n        if l2Contains(l2, x) {\n \
    \          ^~~~~~~~~~\n/tmp/tmpujraxk8r.swift:16:13: error: cannot find 'append'\
    \ in scope\n            append(common, x)\n            ^~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    \n    // Sort both arrays\
    \ by their first elements.\n    // The first element of each array will be used\
    \ in the comparison.\n    let sortedL1 = l1.sorted { $0 < $1 }\n    let sortedL2\
    \ = l2.sorted { $0 < $1 }\n    \n    // The index of the first element of each\
    \ array will be used.\n    var i = 0\n    var j = 0\n    while i < sortedL1.count\
    \ && j < sortedL2.count {\n        // Check if the elements are equal.\n     \
    \   if sortedL1[i] == sortedL2[j] {\n            i += 1\n            j += 1\n\
    \        } else {\n            // They are different. Add the remaining elements.\n\
    \            if i < sortedL1.count {\n                result.insert(sortedL1[i],\
    \ at: 0)\n                i += 1\n            } else {\n                result.insert(sortedL2[j],\
    \ at: 0)\n                j += 1\n            }\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmp_hdhvqxh/tmp_hdhvqxh.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3df5d06c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3df59fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3df59fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3df59fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_hdhvqxh                        0x000055b021d8c5cc <unavailable> + 5580

    5    libc.so.6                          0x00002b3df5ef2460 __libc_start_main +
    245

    6    tmp_hdhvqxh                        0x000055b021d8c149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var i = l1\n    var j = l2\n    var k = 0\n    while\
    \ i < n && j < n {\n        if l1[Int(i)] < l2[Int(j)] {\n            i += 1\n\
    \        } else if l1[Int(i)] > l2[Int(j)] {\n            j -= 1\n        } else\
    \ {\n            k += 1\n        }\n    }\n    while i < n {\n        k += 1\n\
    \        i += 1\n    }\n    while j < n {\n        k -= 1\n        j -= 1\n  \
    \  }\n    return [k] + [i...[j]]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpyjy0r2m2.swift:11:15: error: cannot find 'n' in scope\n    while\
    \ i < n && j < n {\n              ^\n/tmp/tmpyjy0r2m2.swift:11:24: error: cannot\
    \ find 'n' in scope\n    while i < n && j < n {\n                       ^\n/tmp/tmpyjy0r2m2.swift:11:22:\
    \ error: binary operator '<' cannot be applied to operands of type '[Int]' and\
    \ '()'\n    while i < n && j < n {\n                   ~ ^ ~\n/tmp/tmpyjy0r2m2.swift:11:22:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ ((), ()), (AnyIndex, AnyIndex), (Character, Character), (ContinuousClock.Instant,\
    \ ContinuousClock.Instant), (Duration, Duration), (Int, Int), (Int16, Int16),\
    \ (Int32, Int32), (Int64, Int64), (Int8, Int8), (Never, Never), (ObjectIdentifier,\
    \ ObjectIdentifier), (String, String), (String.Index, String.Index), (SuspendingClock.Instant,\
    \ SuspendingClock.Instant), (TaskPriority, TaskPriority), (UInt, UInt), (UInt16,\
    \ UInt16), (UInt32, UInt32), (UInt64, UInt64), (UInt8, UInt8), (Unicode.CanonicalCombiningClass,\
    \ Unicode.CanonicalCombiningClass), (Unicode.Scalar, Unicode.Scalar), (_ValidUTF8Buffer.Index,\
    \ _ValidUTF8Buffer.Index)\n    while i < n && j < n {\n                     ^\n\
    /tmp/tmpyjy0r2m2.swift:11:13: error: binary operator '<' cannot be applied to\
    \ operands of type '[Int]' and '()'\n    while i < n && j < n {\n          ~ ^\
    \ ~\n/tmp/tmpyjy0r2m2.swift:11:13: note: overloads for '<' exist with these partially\
    \ matching parameter lists: ((), ()), (AnyIndex, AnyIndex), (Character, Character),\
    \ (ContinuousClock.Instant, ContinuousClock.Instant), (Duration, Duration), (Int,\
    \ Int), (Int16, Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (Never,\
    \ Never), (ObjectIdentifier, ObjectIdentifier), (String, String), (String.Index,\
    \ String.Index), (SuspendingClock.Instant, SuspendingClock.Instant), (TaskPriority,\
    \ TaskPriority), (UInt, UInt), (UInt16, UInt16), (UInt32, UInt32), (UInt64, UInt64),\
    \ (UInt8, UInt8), (Unicode.CanonicalCombiningClass, Unicode.CanonicalCombiningClass),\
    \ (Unicode.Scalar, Unicode.Scalar), (_ValidUTF8Buffer.Index, _ValidUTF8Buffer.Index)\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n     \
    \   if l2.contains(i) {\n            result.append(i)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmp1dighxrx/tmp1dighxrx.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb4e572c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb4e269b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb4e269988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb4e2687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1dighxrx                        0x00005586445eb67c <unavailable> + 5756

    5    libc.so.6                          0x00002abb4e75e460 __libc_start_main +
    245

    6    tmp1dighxrx                        0x00005586445eb1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    var i = 0\n    while\
    \ i < l1.count && i < l2.count {\n        if l1[i] == l2[i] {\n            result.append(l1[i])\n\
    \            i += 1\n        } else {\n            if l1[i] > l2[i] {\n      \
    \          result.append(l1[i])\n                i += 1\n            } else {\n\
    \                result.append(l2[i])\n                i += 1\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpn4lotydo/tmpn4lotydo.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6278c51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6278948b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6278948988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b62789477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn4lotydo                        0x0000562a6ad2d55c <unavailable> + 5468

    5    libc.so.6                          0x00002b6278e3d460 __libc_start_main +
    245

    6    tmpn4lotydo                        0x0000562a6ad2d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var index = 0\n    while\
    \ index < l1.count && index < l2.count {\n        if l1[index] == l2[index] {\n\
    \            result.append(l1[index])\n            index++\n        } else {\n\
    \            if result.count > 0 {\n                if index == l1.count {\n \
    \                   result.append(l2[index])\n                    index++\n  \
    \              } else {\n                    break\n                }\n      \
    \      } else {\n                if index == l2.count {\n                    result.append(l1[index])\n\
    \                    index++\n                } else {\n                    break\n\
    \                }\n            }\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6vnz1m53.swift:13:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            index++\n                 ^~\n/tmp/tmp6vnz1m53.swift:18:26:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \          index++\n                         ^~\n/tmp/tmp6vnz1m53.swift:25:26:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \          index++\n                         ^~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l = [Int]()\n    for v in l1 {\n        if !contains(v,\
    \ l) {\n            l.append(v)\n        }\n    }\n    for v in l2 {\n       \
    \ if !contains(v, l) {\n            l.append(v)\n        }\n    }\n    return\
    \ l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653,\
    \ 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5,\
    \ 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2,\
    \ 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as\
    \ [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpups0jc_t.swift:10:13: error: cannot find 'contains' in scope\n\
    \        if !contains(v, l) {\n            ^~~~~~~~\n/tmp/tmpups0jc_t.swift:15:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(v, l) {\n     \
    \       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1 == l2 {\n        return l1\n    }\n    var\
    \ result = l1\n    var isPresent = false\n    for i in l2 {\n        if isPresent\
    \ == false {\n            result = l1\n            isPresent = true\n        }\
    \ else {\n            if i == result {\n                result = l1\n        \
    \        isPresent = true\n            } else {\n                result = result\n\
    \            }\n        }\n    }\n    if isPresent == false {\n        result\
    \ = l1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp60t5lkzb.swift:18:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and '[Int]'\n            if i == result {\n      \
    \         ~ ^  ~~~~~~\n/tmp/tmp60t5lkzb.swift:18:18: note: overloads for '=='\
    \ exist with these partially matching parameter lists: (Int, Int)\n          \
    \  if i == result {\n                 ^\n/tmp/tmp60t5lkzb.swift:22:24: error:\
    \ assigning a variable to itself\n                result = result\n          \
    \      ~~~~~~ ^ ~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n       \
    \ if l2.contains(i) {\n            result.append(i)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpttswzne6/tmpttswzne6.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b599cdf9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b599caf0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b599caf0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b599caef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpttswzne6                        0x00005625eb1f06cc <unavailable> + 5836

    5    libc.so.6                          0x00002b599cfe5460 __libc_start_main +
    245

    6    tmpttswzne6                        0x00005625eb1f0249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  var result: [Int] = []\n  for i in 0..<min(l1.count,\
    \ l2.count) {\n    if l1[i] == l2[i] {\n      continue\n    }\n    if l1[i] >\
    \ l2[i] {\n      result.insert(i, l1[i])\n    } else {\n      result.insert(i,\
    \ l2[i])\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpj_e6imzl.swift:14:14: error: no exact matches in call to instance\
    \ method 'insert'\n      result.insert(i, l1[i])\n             ^\nSwift.Array:11:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Element, at\
    \ i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n/tmp/tmpj_e6imzl.swift:16:14:\
    \ error: no exact matches in call to instance method 'insert'\n      result.insert(i,\
    \ l2[i])\n             ^\nSwift.Array:11:37: note: incorrect labels for candidate\
    \ (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect labels for candidate\
    \ (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Self.Element, at i: Self.Index)\n                      \
    \              ^\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let maxLength: Int = max(l1.count, l2.count)\n  \
    \  var result = [Int]()\n    let index = 0\n    while index < maxLength {\n  \
    \      if l1.count < l2.count {\n            let element = l1.count\n        \
    \    l1.append(element)\n        }\n        else if l2.count < l1.count {\n  \
    \          let element = l2.count\n            l2.append(element)\n        }\n\
    \n        if l1.count == l2.count {\n            if l1[index] == l2[index] {\n\
    \                result.append(l1[index])\n                index++\n         \
    \   }\n            else {\n                let a = l1[index]\n               \
    \ let b = l2[index]\n                while a != b {\n                    a++\n\
    \                    b++\n                }\n                result.append(a)\n\
    \                index++\n            }\n        }\n        else {\n         \
    \   let a = l1[index]\n            let b = l2[index]\n            while a != b\
    \ {\n                a++\n                b++\n            }\n            result.append(a)\n\
    \            index++\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp534sfsop.swift:14:16: error: cannot use mutating member on immutable\
    \ value: 'l1' is a 'let' constant\n            l1.append(element)\n          \
    \  ~~ ^\n/tmp/tmp534sfsop.swift:18:16: error: cannot use mutating member on immutable\
    \ value: 'l2' is a 'let' constant\n            l2.append(element)\n          \
    \  ~~ ^\n/tmp/tmp534sfsop.swift:24:22: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                index++\n                     ^~\n/tmp/tmp534sfsop.swift:30:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \          a++\n                     ^~\n/tmp/tmp534sfsop.swift:31:22: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n                 \
    \   b++\n                     ^~\n/tmp/tmp534sfsop.swift:34:22: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n                index++\n\
    \                     ^~\n/tmp/tmp534sfsop.swift:41:18: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                a++\n                 ^~\n\
    /tmp/tmp534sfsop.swift:42:18: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n                b++\n                 ^~\n/tmp/tmp534sfsop.swift:45:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  index++\n                 ^~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common = [Int]()\n    for idx in l1[0..<min(l1.count,\
    \ l2.count)] {\n        if l2[idx] == l1[idx] {\n            common.append(idx)\n\
    \        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0e4ec8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0e4bbf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae0e4bbf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae0e4bbf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae0e4bbebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae0e49bee83 <unavailable> + 188035

    6    tmpw9ffpfcb                        0x000056434fd1cf8e <unavailable> + 8078

    7    tmpw9ffpfcb                        0x000056434fd1c803 <unavailable> + 6147

    8    libc.so.6                          0x00002ae0e50b4460 __libc_start_main +
    245

    9    tmpw9ffpfcb                        0x000056434fd1c469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var c = 0\n    var d = l1\n    var e = l2\n    while\
    \ c < min(e.count, d.count) && d < e {\n        if d[c] == e[c] {\n          \
    \  c++\n        } else {\n            if d[c] > e[c] {\n                d.append(e[c])\n\
    \            } else {\n                d.append(d[c])\n            }\n       \
    \ }\n        c++\n    }\n    return d[c..<min(e.count, d.count)]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkiezt_yo.swift:11:42: error: binary operator '<' cannot be applied\
    \ to two '[Int]' operands\n    while c < min(e.count, d.count) && d < e {\n  \
    \                                       ^\nSwift.Comparable:1:17: note: candidate\
    \ requires that '[Int]' conform to 'Comparable' (requirement specified as 'Self'\
    \ : 'Comparable')\npublic protocol Comparable : Equatable {\n                ^\n\
    /tmp/tmpkiezt_yo.swift:13:14: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            c++\n             ^~\n/tmp/tmpkiezt_yo.swift:21:10:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        c++\n\
    \         ^~\n/tmp/tmpkiezt_yo.swift:23:13: error: no 'subscript' candidates produce\
    \ the expected contextual result type '[Int]'\n    return d[c..<min(e.count, d.count)]\n\
    \            ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\nSwift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue\
    \ ArraySlice<Int>', not the expected contextual result type '[Int]'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)'\
    \ produces '@lvalue ArraySlice<Int>', not the expected contextual result type\
    \ '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:2:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return commonPrepend(l1, l2, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp12w9y1ew.swift:8:12: error: cannot find 'commonPrepend' in scope\n\
    \    return commonPrepend(l1, l2, 0)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979364
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let result = [Int]()\n    let i = 0\n    let j =\
    \ l1.count - l1[0]! - 1\n\n    while (i < j) {\n        let flag = l1[i]! == l2[i]!\n\
    \n        if flag {\n            result.append(l1[i]!)\n        }\n\n        i\
    \ += 1\n        j += 1\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp50mbitpy.swift:10:29: error: cannot force unwrap value of non-optional\
    \ type 'Int'\n    let j = l1.count - l1[0]! - 1\n                       ~~~~~^\n\
    \                            \n/tmp/tmp50mbitpy.swift:13:25: error: cannot force\
    \ unwrap value of non-optional type 'Int'\n        let flag = l1[i]! == l2[i]!\n\
    \                   ~~~~~^\n                        \n/tmp/tmp50mbitpy.swift:13:35:\
    \ error: cannot force unwrap value of non-optional type 'Int'\n        let flag\
    \ = l1[i]! == l2[i]!\n                             ~~~~~^\n                  \
    \                \n/tmp/tmp50mbitpy.swift:16:20: error: no exact matches in call\
    \ to instance method 'append'\n            result.append(l1[i]!)\n           \
    \        ^\n/tmp/tmp50mbitpy.swift:16:20: note: found candidate with type '(__owned\
    \ Int) -> ()'\n            result.append(l1[i]!)\n                   ^\n/tmp/tmp50mbitpy.swift:19:11:\
    \ error: left side of mutating operator isn't mutable: 'i' is a 'let' constant\n\
    \        i += 1\n        ~ ^\n/tmp/tmp50mbitpy.swift:9:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let i = 0\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var res: [Int] = l1.prefix(min(l1.count, l2.count))\
    \ + l2.prefix(min(l1.count, l2.count))\n    if res.count == 0 {\n        return\
    \ res\n    }\n    for i in 0..<res.count {\n        if res[i] != l1[i] {\n   \
    \         if res[i] != l2[i] {\n                return res\n            }\n  \
    \          break\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbi4kddmy.swift:8:57: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to specified type '[Int]'\n    var res: [Int] = l1.prefix(min(l1.count, l2.count))\
    \ + l2.prefix(min(l1.count, l2.count))\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = l1\n    var i = index(l1, l2)\n    while\
    \ i != -1 {\n        result.removeLast()\n        i = index(l1, l2, &i)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpay00hilw.swift:9:13: error: cannot find 'index' in scope\n    var\
    \ i = index(l1, l2)\n            ^~~~~\n/tmp/tmpay00hilw.swift:12:13: error: cannot\
    \ find 'index' in scope\n        i = index(l1, l2, &i)\n            ^~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for e in l1 {\n       \
    \ if !contains(l2, e) {\n            result.append(e)\n        }\n    }\n    for\
    \ e in l2 {\n        if !contains(l1, e) {\n            result.append(e)\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmps_u2kajv.swift:10:13: error: cannot find 'contains' in scope\n\
    \        if !contains(l2, e) {\n            ^~~~~~~~\n/tmp/tmps_u2kajv.swift:15:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, e) {\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var res = l1\n    res.reserveCapacity(l2.count)\n\
    \    guard l1.count >= l2.count else { return res }\n    for i in 0..<l1.count\
    \ {\n        guard let ji = l2.firstIndex(of: l1[i]) else {\n            res.removeAll(keepingCapacity:\
    \ true)\n            return res\n        }\n        res.insert(l1[i], at: ji)\n\
    \        l1.remove(at: i)\n        l2.remove(at: ji)\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpyawm7psd.swift:17:12: error: cannot use mutating member on immutable\
    \ value: 'l1' is a 'let' constant\n        l1.remove(at: i)\n        ~~ ^\n/tmp/tmpyawm7psd.swift:18:12:\
    \ error: cannot use mutating member on immutable value: 'l2' is a 'let' constant\n\
    \        l2.remove(at: ji)\n        ~~ ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = l1\n    var i = 0\n    var j = 0\n \
    \   while i < l1.count && j < l2.count {\n        if l1[i] < l2[j] {\n       \
    \     result.remove(at: i)\n        }\n        else if l1[i] > l2[j] {\n     \
    \       result.remove(at: j)\n        }\n        i += 1\n        j += 1\n    }\n\
    \    while i < l1.count {\n        result.remove(at: i)\n        i += 1\n    }\n\
    \    while j < l2.count {\n        result.remove(at: j)\n        j += 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'Swift/Array.swift:1331: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af1fb42bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af1fb122561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af1fb122286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af1fb12213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af1fb121bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002af1fb10f018 <unavailable> + 1355800

    6    tmpksrgyldo                        0x00005560888efbea <unavailable> + 7146

    7    tmpksrgyldo                        0x00005560888ef473 <unavailable> + 5235

    8    libc.so.6                          0x00002af1fb617460 __libc_start_main +
    245

    9    tmpksrgyldo                        0x00005560888ef0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var index = 0\n    while\
    \ index < l1.count && index < l2.count {\n        if l1[index] == l2[index] {\n\
    \            result.append(l1[index])\n            index++\n        } else {\n\
    \            index++\n        }\n    }\n    if index < l1.count {\n        result\
    \ = result[0..<(index)]\n    }\n    if index < l2.count {\n        result = result.prefix(4)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpiklajubn.swift:13:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            index++\n                 ^~\n/tmp/tmpiklajubn.swift:15:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  index++\n                 ^~\n/tmp/tmpiklajubn.swift:19:24: error: cannot assign\
    \ value of type 'ArraySlice<Int>' to type '[Int]'\n        result = result[0..<(index)]\n\
    \                 ~~~~~~^~~~~~~~~~~~~\n/tmp/tmpiklajubn.swift:22:25: error: no\
    \ 'prefix' candidates produce the expected contextual result type '[Int]'\n  \
    \      result = result.prefix(4)\n                        ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<[Int]>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'ArraySlice<Int>', not the expected contextual result\
    \ type '[Int]'\n    @inlinable public __consuming func prefix(_ maxLength: Int)\
    \ -> Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return commonFunc(l1, l2, true)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpt4drofk_.swift:8:12: error: cannot find 'commonFunc' in scope\n\
    \    return commonFunc(l1, l2, true)\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = l1\n    for x in l2 {\n        if !contain(result,\
    \ x) {\n            result = append(result, x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpw6_gpisu.swift:10:13: error: cannot find 'contain' in scope\n \
    \       if !contain(result, x) {\n            ^~~~~~~\n/tmp/tmpw6_gpisu.swift:11:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, x)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Set(l1).intersection(Set(l2)).sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var commonCount = 0\n    let l1Count = l1.count\n\
    \    let l2Count = l2.count\n    for i in 0..<l1Count {\n        if l1[i] == l2[i]\
    \ {\n            commonCount++\n        }\n    }\n    commonCount = l1Count -\
    \ commonCount\n    var result: [Int] = []\n    var resultCount = 0\n    for i\
    \ in 0..<l2Count {\n        if commonCount == 0 {\n            break\n       \
    \ }\n        if l2[i] == commonCount {\n            result[resultCount] = l2[i]\n\
    \            resultCount++\n        }\n        commonCount--\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptuox5c6l.swift:13:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            commonCount++\n                       ^~\n\
    /tmp/tmptuox5c6l.swift:25:24: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            resultCount++\n                       ^~\n/tmp/tmptuox5c6l.swift:27:20:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n        commonCount--\n\
    \                   ^~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count == l2.count else { return [] }\n\n\
    \    var result = [Int]()\n    for i in l1 { result.append(i) }\n    for i in\
    \ l2 { result.removeAll(where: { $0 == i }) }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpd8ycwte6/tmpd8ycwte6.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea3c813c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea3c50ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea3c50a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea3c5097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd8ycwte6                        0x000055dff77b67bc <unavailable> + 6076

    5    libc.so.6                          0x00002aea3c9ff460 __libc_start_main +
    245

    6    tmpd8ycwte6                        0x000055dff77b6339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = Array(0..<(l1.count)).map { i in\n \
    \       l1[i] & l2[i]\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpshgrp6dv/tmpshgrp6dv.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5053a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad50509fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad50509f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad50509e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpshgrp6dv                        0x000055716b85276c <unavailable> + 5996

    5    libc.so.6                          0x00002ad505594460 __libc_start_main +
    245

    6    tmpshgrp6dv                        0x000055716b8522e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    var common = [Int]()\n\
    \    while l1.count > 0 || l2.count > 0 {\n        if l1.count == 0 {\n      \
    \      l1.append(l2[0])\n            l2.removeAtIndex(0)\n        } else if l2.count\
    \ == 0 {\n            l1.append(l2[0])\n            l2.removeAtIndex(0)\n    \
    \    } else {\n            if l1[0] > l2[0] {\n                l2.removeAtIndex(0)\n\
    \            } else {\n                l1.removeAtIndex(0)\n            }\n  \
    \      }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmps15ovh6l.swift:14:16: error: value of type '[Int]' has no member\
    \ 'removeAtIndex'\n            l2.removeAtIndex(0)\n            ~~ ^~~~~~~~~~~~~\n\
    /tmp/tmps15ovh6l.swift:17:16: error: value of type '[Int]' has no member 'removeAtIndex'\n\
    \            l2.removeAtIndex(0)\n            ~~ ^~~~~~~~~~~~~\n/tmp/tmps15ovh6l.swift:20:20:\
    \ error: value of type '[Int]' has no member 'removeAtIndex'\n               \
    \ l2.removeAtIndex(0)\n                ~~ ^~~~~~~~~~~~~\n/tmp/tmps15ovh6l.swift:22:20:\
    \ error: value of type '[Int]' has no member 'removeAtIndex'\n               \
    \ l1.removeAtIndex(0)\n                ~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l = [Int]()\n    for i in l1 {\n        if !contains(l2,\
    \ i) {\n            append(l, i)\n        }\n    }\n    return l\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_1tbeobi.swift:10:13: error: cannot find 'contains' in scope\n\
    \        if !contains(l2, i) {\n            ^~~~~~~~\n/tmp/tmp_1tbeobi.swift:11:13:\
    \ error: cannot find 'append' in scope\n            append(l, i)\n           \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  var result = [Int]()\n  var i = 0\n  var j = 0\n  while\
    \ (i < l1.count && j < l2.count) {\n    if l1[i] < l2[j] {\n      i += 1\n   \
    \   continue\n    }\n    if l1[i] > l2[j] {\n      j += 1\n      continue\n  \
    \  }\n    result.append(l1[i])\n    i += 1\n    j += 1\n  }\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpdifjow3d/tmpdifjow3d.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab411562c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab411259b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab411259988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4112587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdifjow3d                        0x0000556a4d4465ac <unavailable> + 5548

    5    libc.so.6                          0x00002ab41174e460 __libc_start_main +
    245

    6    tmpdifjow3d                        0x0000556a4d446129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count >= l2.count else { return [l1.first!]\
    \ }\n    var results = [Int]()\n    let imax = l1.count\n    let jmax = l2.count\n\
    \    for i in 0..imax {\n        let j = jmax\n        let mmax = jmax - i\n \
    \       for j in 0..mmax {\n            if l1[i] == l2[j] {\n                results.append(l1[i])\n\
    \                j -= 1\n            }\n            if j == 0 {\n            \
    \    break\n            }\n        }\n    }\n    return results\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp3cuz6dhb.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 0..imax {\n              ^~\n            \
    \  ...\n/tmp/tmp3cuz6dhb.swift:15:19: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n        for j in 0..mmax {\n                  ^~\n    \
    \              ...\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    var j = 0\n    var k\
    \ = 0\n    while j < l1.count && k < l2.count {\n        if l1[j] == l2[k] {\n\
    \            result.append(l1[j])\n            j += 1\n            k += 1\n  \
    \      } else {\n            j += 1\n        }\n    }\n    while j < l1.count\
    \ {\n        result.append(l1[j])\n        j += 1\n    }\n    while k < l2.count\
    \ {\n        result.append(l2[k])\n        k += 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpvb1_ufvu/tmpvb1_ufvu.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b34abbe7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34ab8deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b34ab8de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34ab8dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvb1_ufvu                        0x00005569719b155c <unavailable> + 5468

    5    libc.so.6                          0x00002b34abdd3460 __libc_start_main +
    245

    6    tmpvb1_ufvu                        0x00005569719b10d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    \n    var i = 0\n    var j = 0\n    var n = min(l1.count,\
    \ l2.count)\n    var common = [Int]()\n    var hash1 = l1\n    var hash2 = l2\n\
    \    \n    for _ in 0..<n {\n        while hash1[i] == hash2[j] {\n          \
    \  i += 1\n            j += 1\n            if i == n {\n                break\n\
    \            }\n        }\n        if i == hash1.count {\n            if j ==\
    \ hash2.count {\n                break\n            }\n            i += 1\n  \
    \      } else {\n            if j == hash2.count {\n                j += 1\n \
    \           }\n        }\n        common.append(hash1[i])\n    }\n    return common\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpcovur4a6/tmpcovur4a6.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae732671c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae732368b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae732368988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7323677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcovur4a6                        0x00005653694bd7bc <unavailable> + 6076

    5    libc.so.6                          0x00002ae73285d460 __libc_start_main +
    245

    6    tmpcovur4a6                        0x00005653694bd339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1.count != l2.count {\n        return nil\n \
    \   }\n\n    let mut result = Set<Int>()\n\n    for i in 0..<l1.count {\n    \
    \    if l1.contains(i) {\n            let found = l2.index(of: l1[i])\n      \
    \      if found != nil {\n                result.insert(found!)\n            }\n\
    \        }\n    }\n    return Array(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7j_q80fx.swift:12:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut result =\
    \ Set<Int>()\n            ^\n/tmp/tmp7j_q80fx.swift:12:13: note: join the identifiers\
    \ together\n    let mut result = Set<Int>()\n        ~~~~^~~~~~\n        mutresult\n\
    /tmp/tmp7j_q80fx.swift:12:13: note: join the identifiers together with camel-case\n\
    \    let mut result = Set<Int>()\n        ~~~~^~~~~~\n        mutResult\n/tmp/tmp7j_q80fx.swift:9:16:\
    \ error: 'nil' is incompatible with return type '[Int]'\n        return nil\n\
    \               ^\n/tmp/tmp7j_q80fx.swift:16:28: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n            let found = l2.index(of: l1[i])\n\
    \                           ^\n/tmp/tmp7j_q80fx.swift:16:28: note: use 'firstIndex(of:)'\
    \ instead\n            let found = l2.index(of: l1[i])\n                     \
    \      ^~~~~\n                           firstIndex\n/tmp/tmp7j_q80fx.swift:18:17:\
    \ error: cannot find 'result' in scope\n                result.insert(found!)\n\
    \                ^~~~~~\n/tmp/tmp7j_q80fx.swift:22:18: error: cannot find 'result'\
    \ in scope\n    return Array(result)\n                 ^~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let commonCount = Set(l1).intersection(l2).count\n\
    \    var common = [Int]()\n    for i in l1 {\n        if commonCount == 0 {\n\
    \            break\n        }\n        if l2.contains(i) {\n            common.append(i)\n\
    \            commonCount -= 1\n        }\n    }\n    return common\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_yiqitvp.swift:16:25: error: left side of mutating operator isn't\
    \ mutable: 'commonCount' is a 'let' constant\n            commonCount -= 1\n \
    \           ~~~~~~~~~~~ ^\n/tmp/tmp_yiqitvp.swift:8:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let commonCount = Set(l1).intersection(l2).count\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var a = l1\n    var b = l2\n    var n = a.count\n\
    \n    for i in 0..<n {\n        if (a[i] != b[i]) {\n            return common(b.dropLast(),\
    \ a.dropLast())\n        }\n    }\n\n    return a\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqitsbxsd.swift:14:26: error: missing argument labels 'l1:l2:' in\
    \ call\n            return common(b.dropLast(), a.dropLast())\n              \
    \           ^\n                          l1:           l2: \n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var index = 0\n    for\
    \ index in 0..<min(l1.count, l2.count) {\n        if l1[index] == l2[index] {\n\
    \            result.append(l1[index])\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpadkghxtr/tmpadkghxtr.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab66bc0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab66b903b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab66b903988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab66b9027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpadkghxtr                        0x0000560efe9767bc <unavailable> + 6076

    5    libc.so.6                          0x00002ab66bdf8460 __libc_start_main +
    245

    6    tmpadkghxtr                        0x0000560efe976339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  return Array(Set(l1).intersection(Set(l2)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpd8kd9pul/tmpd8kd9pul.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0683e05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0683afcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0683afc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0683afb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd8kd9pul                        0x00005556441e05fc <unavailable> + 5628

    5    libc.so.6                          0x00002b0683ff1460 __libc_start_main +
    245

    6    tmpd8kd9pul                        0x00005556441e0179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common = l1.sort()\n    for i in 0..<common.count\
    \ {\n        if common[i] == l2[i] {\n            common.removeAtIndex(common[i])\n\
    \        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpngtd7fo0.swift:8:21: error: cannot use mutating member on immutable\
    \ value: 'l1' is a 'let' constant\n    var common = l1.sort()\n              \
    \   ~~ ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var i1 = l1\n    var i2 = l2\n    var i3 = []\n \
    \   var done = false\n    while !done {\n        if i1 < i2 {\n            i3\
    \ = i3 + 1\n            i1 = i1 + 1\n        } else {\n            i2 = i2 + 1\n\
    \            if i2 == i3 {\n                done = true\n            } else {\n\
    \                i1 = i1 + 1\n            }\n        }\n    }\n    return i3\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzu7pahd5.swift:10:14: error: empty collection literal requires\
    \ an explicit type\n    var i3 = []\n             ^~\n/tmp/tmpzu7pahd5.swift:13:15:\
    \ error: binary operator '<' cannot be applied to two '[Int]' operands\n     \
    \   if i1 < i2 {\n           ~~ ^ ~~\n/tmp/tmpzu7pahd5.swift:14:23: error: cannot\
    \ convert value of type 'Int' to expected argument type 'Array<Any>'\n       \
    \     i3 = i3 + 1\n                      ^\n/tmp/tmpzu7pahd5.swift:15:23: error:\
    \ cannot convert value of type 'Int' to expected argument type 'Array<Int>'\n\
    \            i1 = i1 + 1\n                      ^\n/tmp/tmpzu7pahd5.swift:17:23:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Array<Int>'\n\
    \            i2 = i2 + 1\n                      ^\n/tmp/tmpzu7pahd5.swift:18:22:\
    \ error: cannot convert value of type '[Any]' to expected argument type 'Array<Int>'\n\
    \            if i2 == i3 {\n                     ^\n/tmp/tmpzu7pahd5.swift:18:22:\
    \ note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected\
    \ to be equal\n            if i2 == i3 {\n                     ^\n/tmp/tmpzu7pahd5.swift:21:27:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Array<Int>'\n\
    \                i1 = i1 + 1\n                          ^\n/tmp/tmpzu7pahd5.swift:25:12:\
    \ error: cannot convert return expression of type '[Any]' to return type '[Int]'\n\
    \    return i3\n           ^\n/tmp/tmpzu7pahd5.swift:25:12: note: arguments to\
    \ generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n   \
    \ return i3\n           ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1 == l2 {\n        return l1\n    }\n    if l1\
    \ == [] || l2 == [] {\n        return l1\n    }\n    var set = [Int]()\n    for\
    \ item in l1 {\n        if !contains(set, item) {\n            set = append(set,\
    \ item)\n        }\n    }\n    for item in l2 {\n        if !contains(set, item)\
    \ {\n            set = append(set, item)\n        }\n    }\n    return set\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1agp9vol.swift:16:13: error: cannot find 'contains' in scope\n\
    \        if !contains(set, item) {\n            ^~~~~~~~\n/tmp/tmp1agp9vol.swift:17:19:\
    \ error: cannot find 'append' in scope\n            set = append(set, item)\n\
    \                  ^~~~~~\n/tmp/tmp1agp9vol.swift:21:13: error: cannot find 'contains'\
    \ in scope\n        if !contains(set, item) {\n            ^~~~~~~~\n/tmp/tmp1agp9vol.swift:22:19:\
    \ error: cannot find 'append' in scope\n            set = append(set, item)\n\
    \                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = l1\n    for element in l2 {\n      \
    \  if element == result[0] {\n            result = result[1:]\n        } else\
    \ {\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpx01gk4cn.swift:11:30: error: expected ',' separator\n         \
    \   result = result[1:]\n                             ^\n                    \
    \         ,\n/tmp/tmpx01gk4cn.swift:11:30: error: expected expression in list\
    \ of expressions\n            result = result[1:]\n                          \
    \   ^\n/tmp/tmpx01gk4cn.swift:11:28: error: cannot assign value of type 'Int'\
    \ to type '[Int]'\n            result = result[1:]\n                     ~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in 0 ..< min(l1.count,\
    \ l2.count) {\n        if l1[i] == l2[i] {\n            result.append(l1[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmphzq6arox/tmphzq6arox.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2c08cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2c05c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2c05c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2c05c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphzq6arox                        0x000055efaa7d876c <unavailable> + 5996

    5    libc.so.6                          0x00002ae2c0abb460 __libc_start_main +
    245

    6    tmphzq6arox                        0x000055efaa7d82e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let mut sortedL1 = l1.sorted()\n    let mut sortedL2\
    \ = l2.sorted()\n    while sortedL1.first() != sortedL2.first() {\n        if\
    \ sortedL1.first() == sortedL2.first() {\n            if sortedL1.last() != sortedL2.last()\
    \ {\n                return sortedL1.last()\n            }\n            return\
    \ sortedL1.last()\n        }\n        if sortedL1.first() > sortedL2.first() {\n\
    \            sortedL1.removeFirst()\n        } else {\n            sortedL2.removeFirst()\n\
    \        }\n    }\n    if sortedL1.first() != sortedL2.first() {\n        return\
    \ sortedL1.last()\n    }\n    return sortedL2.last()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpshqe76py.swift:8:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut sortedL1\
    \ = l1.sorted()\n            ^\n/tmp/tmpshqe76py.swift:8:13: note: join the identifiers\
    \ together\n    let mut sortedL1 = l1.sorted()\n        ~~~~^~~~~~~~\n       \
    \ mutsortedL1\n/tmp/tmpshqe76py.swift:8:13: note: join the identifiers together\
    \ with camel-case\n    let mut sortedL1 = l1.sorted()\n        ~~~~^~~~~~~~\n\
    \        mutSortedL1\n/tmp/tmpshqe76py.swift:9:13: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \   let mut sortedL2 = l2.sorted()\n            ^\n/tmp/tmpshqe76py.swift:9:13:\
    \ note: join the identifiers together\n    let mut sortedL2 = l2.sorted()\n  \
    \      ~~~~^~~~~~~~\n        mutsortedL2\n/tmp/tmpshqe76py.swift:9:13: note: join\
    \ the identifiers together with camel-case\n    let mut sortedL2 = l2.sorted()\n\
    \        ~~~~^~~~~~~~\n        mutSortedL2\n/tmp/tmpshqe76py.swift:9:9: error:\
    \ invalid redeclaration of 'mut'\n    let mut sortedL2 = l2.sorted()\n       \
    \ ^\n/tmp/tmpshqe76py.swift:8:9: note: 'mut' previously declared here\n    let\
    \ mut sortedL1 = l1.sorted()\n        ^\n/tmp/tmpshqe76py.swift:10:11: error:\
    \ cannot find 'sortedL1' in scope\n    while sortedL1.first() != sortedL2.first()\
    \ {\n          ^~~~~~~~\n/tmp/tmpshqe76py.swift:10:31: error: cannot find 'sortedL2'\
    \ in scope\n    while sortedL1.first() != sortedL2.first() {\n               \
    \               ^~~~~~~~\n/tmp/tmpshqe76py.swift:11:12: error: cannot find 'sortedL1'\
    \ in scope\n        if sortedL1.first() == sortedL2.first() {\n           ^~~~~~~~\n\
    /tmp/tmpshqe76py.swift:11:32: error: cannot find 'sortedL2' in scope\n       \
    \ if sortedL1.first() == sortedL2.first() {\n                               ^~~~~~~~\n\
    /tmp/tmpshqe76py.swift:12:16: error: cannot find 'sortedL1' in scope\n       \
    \     if sortedL1.last() != sortedL2.last() {\n               ^~~~~~~~\n/tmp/tmpshqe76py.swift:12:35:\
    \ error: cannot find 'sortedL2' in scope\n            if sortedL1.last() != sortedL2.last()\
    \ {\n                 "
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n       \
    \ if !contains(result, x) {\n            result = result + [x]\n        }\n  \
    \  }\n    for x in l2 {\n        if !contains(result, x) {\n            result\
    \ = result + [x]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpcyg2bod2.swift:10:13: error: cannot find 'contains' in scope\n\
    \        if !contains(result, x) {\n            ^~~~~~~~\n/tmp/tmpcyg2bod2.swift:15:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(result, x) {\n\
    \            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common = [Int](count: l1.count, repeatedValue:\
    \ -1)\n    var i = 0\n    var j = 0\n    for x in l1 {\n        if common[i] ==\
    \ x {\n            i += 1\n            continue\n        }\n        for y in l2\
    \ {\n            if common[j] == y {\n                j += 1\n               \
    \ continue\n            }\n            if x < y {\n                common[j] =\
    \ x\n                j += 1\n            } else {\n                common[i] =\
    \ y\n                i += 1\n            }\n        }\n    }\n    return common\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8kzck1v5.swift:8:18: error: no exact matches in call to initializer\
    \ \n    var common = [Int](count: l1.count, repeatedValue: -1)\n             \
    \    ^\n/tmp/tmp8kzck1v5.swift:8:18: note: candidate has partially matching parameter\
    \ list (repeating: Int, count: Int)\n    var common = [Int](count: l1.count, repeatedValue:\
    \ -1)\n                 ^\n/tmp/tmp8kzck1v5.swift:8:18: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var common = [Int](count:\
    \ l1.count, repeatedValue: -1)\n                 ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n     \
    \   if contains(l2, i) {\n            result.append(i)\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp2jyu_5z8.swift:10:12: error: cannot find 'contains' in scope\n\
    \        if contains(l2, i) {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var unique = Set()\n    for elem in l1 { unique.insert(elem)\
    \ }\n    for elem in l2 { unique.insert(elem) }\n    return Array(unique)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpo1jlj9z6.swift:8:18: error: generic parameter 'Element' could not\
    \ be inferred\n    var unique = Set()\n                 ^\n/tmp/tmpo1jlj9z6.swift:8:18:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var unique\
    \ = Set()\n                 ^\n                    <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = l1\n    for i in l2 {\n        var index\
    \ = result.index {$0 === i}\n        if index >= 0 {\n            result.removeSubrange(index,\
    \ 1)\n        } else {\n            result = append(result, i)\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpskdd7l9v.swift:10:35: error: argument type 'Int' expected to be\
    \ an instance of a class or class-constrained type\n        var index = result.index\
    \ {$0 === i}\n                                  ^\n/tmp/tmpskdd7l9v.swift:10:42:\
    \ error: argument type 'Int' expected to be an instance of a class or class-constrained\
    \ type\n        var index = result.index {$0 === i}\n                        \
    \                 ^\n/tmp/tmpskdd7l9v.swift:12:42: error: extra argument in call\n\
    \            result.removeSubrange(index, 1)\n                               \
    \  ~~~~~~~~^~\n/tmp/tmpskdd7l9v.swift:14:22: error: cannot find 'append' in scope\n\
    \            result = append(result, i)\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var a = l1\n    var b = l2\n    var result = [Int]()\n\
    \    var i = 0\n    var j = 0\n    while i < a.count && j < b.count {\n      \
    \  if a[i] == b[j] {\n            result.append(a[i])\n            i += 1\n  \
    \          j += 1\n        } else if a[i] < b[j] {\n            i += 1\n     \
    \   } else {\n            j += 1\n        }\n    }\n    return result.count >\
    \ 0 ? result : [Int]()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpbg9rc23p/tmpbg9rc23p.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b591cabfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b591c7b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b591c7b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b591c7b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbg9rc23p                        0x0000559bb50d95ac <unavailable> + 5548

    5    libc.so.6                          0x00002b591ccab460 __libc_start_main +
    245

    6    tmpbg9rc23p                        0x0000559bb50d9129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l = [Int]()\n    for x in l1 {\n        for y\
    \ in l2 {\n            if x == y {\n                l.append(x)\n            \
    \    break\n            }\n        }\n    }\n    return l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpylxb9rfe/tmpylxb9rfe.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4218233c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4217f2ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4217f2a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4217f297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpylxb9rfe                        0x000056084e04866c <unavailable> + 5740

    5    libc.so.6                          0x00002b421841f460 __libc_start_main +
    245

    6    tmpylxb9rfe                        0x000056084e0481e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var array = [Int]()\n    var i = 0\n    for x in\
    \ l1 {\n        if l2[i] < x {\n            array = append(array, l2[i])\n   \
    \     }\n        i += 1\n    }\n    for x in l2 {\n        if array[0] != x {\n\
    \            array = append(array, x)\n        }\n    }\n    return array\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptvffml9d.swift:12:21: error: cannot find 'append' in scope\n  \
    \          array = append(array, l2[i])\n                    ^~~~~~\n/tmp/tmptvffml9d.swift:18:21:\
    \ error: cannot find 'append' in scope\n            array = append(array, x)\n\
    \                    ^~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // Special case: if one of the list is empty, return\
    \ the other\n    var commonArray = l1\n    if !l1.isEmpty {\n        commonArray\
    \ = l2\n    }\n    var result = [Int]()\n\n    for i in 0 ..< commonArray.count\
    \ {\n        if commonArray[i] != 0 && commonArray[i] != l1[i] {\n           \
    \ result.append(commonArray[i])\n        }\n    }\n\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpg1rqo558/tmpg1rqo558.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aadcd70fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aadcd406b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aadcd406988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aadcd4057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg1rqo558                        0x0000563123e2d7cc <unavailable> + 6092

    5    libc.so.6                          0x00002aadcd8fb460 __libc_start_main +
    245

    6    tmpg1rqo558                        0x0000563123e2d349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // Find the shared elements\n    var set = Set()\n\
    \    var common = [Int]()\n    for value in l1 {\n        if !set.contains(value)\
    \ {\n            set.insert(value)\n            common.append(value)\n       \
    \ }\n    }\n    for value in l2 {\n        if !set.contains(value) {\n       \
    \     set.insert(value)\n            common.append(value)\n        }\n    }\n\n\
    \    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpnk_mc9a3.swift:9:15: error: generic parameter 'Element' could not\
    \ be inferred\n    var set = Set()\n              ^\n/tmp/tmpnk_mc9a3.swift:9:15:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var set\
    \ = Set()\n              ^\n                 <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count != 0 || l2.count != 0 else {\n   \
    \     return []\n    }\n    \n    var a = [Int](count: l1.count + 1, repeatedValue:\
    \ 0)\n    var b = [Int](count: l2.count + 1, repeatedValue: 0)\n    \n    for\
    \ i in 0 ..< l1.count {\n        a[i+1] = l1[i]\n    }\n    for i in 0 ..< l2.count\
    \ {\n        b[i+1] = l2[i]\n    }\n    for i in 0 ..< l1.count {\n        if\
    \ a[i+1] != b[i+1] {\n            return a[i..<l1.count]\n        }\n    }\n \
    \   \n    return b[1..<l2.count]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp82c1ne_o.swift:12:13: error: no exact matches in call to initializer\
    \ \n    var a = [Int](count: l1.count + 1, repeatedValue: 0)\n            ^\n\
    /tmp/tmp82c1ne_o.swift:12:13: note: candidate has partially matching parameter\
    \ list (repeating: Int, count: Int)\n    var a = [Int](count: l1.count + 1, repeatedValue:\
    \ 0)\n            ^\n/tmp/tmp82c1ne_o.swift:12:13: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var a = [Int](count:\
    \ l1.count + 1, repeatedValue: 0)\n            ^\n/tmp/tmp82c1ne_o.swift:13:13:\
    \ error: no exact matches in call to initializer \n    var b = [Int](count: l2.count\
    \ + 1, repeatedValue: 0)\n            ^\n/tmp/tmp82c1ne_o.swift:13:13: note: candidate\
    \ has partially matching parameter list (repeating: Int, count: Int)\n    var\
    \ b = [Int](count: l2.count + 1, repeatedValue: 0)\n            ^\n/tmp/tmp82c1ne_o.swift:13:13:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var b = [Int](count: l2.count + 1, repeatedValue: 0)\n           \
    \ ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var commonElements: [Int] = []\n    for i in 0..<min(l1.count,\
    \ l2.count) {\n        if l1[i] == l2[i] {\n            commonElements.append(l1[i])\n\
    \        }\n    }\n    if l1.count < l2.count {\n        for i in l1..<l2.count\
    \ {\n            commonElements.append(l2[i])\n        }\n    }\n    return commonElements\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpjnvxmsez.swift:15:18: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        for i in l1..<l2.count {\n        \
    \         ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = Set()\n    for x in l1 {\n        if\
    \ !l2.contains(x) {\n            result.add(x)\n        }\n    }\n    return Array(result.sorted(by:\
    \ >))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34,\
    \ 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp43kvs5z9.swift:8:18: error: generic parameter 'Element' could not\
    \ be inferred\n    var result = Set()\n                 ^\n/tmp/tmp43kvs5z9.swift:8:18:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var result\
    \ = Set()\n                 ^\n                    <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return sort(Array(Set(l1).intersection(Set(l2))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpobjcg95r.swift:8:12: error: cannot find 'sort' in scope\n    return\
    \ sort(Array(Set(l1).intersection(Set(l2))))\n           ^~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var x = [Int]()\n    var y = [Int]()\n    for x in\
    \ l1 {\n        if !contains(l2, x) {\n            append(x, y)\n            append(l2,\
    \ x)\n        }\n    }\n    for y in l2 {\n        if !contains(l1, y) {\n   \
    \         append(x, y)\n            append(l1, y)\n        }\n    }\n    return\
    \ unique(x)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_rfs694k.swift:11:13: error: cannot find 'contains' in scope\n\
    \        if !contains(l2, x) {\n            ^~~~~~~~\n/tmp/tmp_rfs694k.swift:12:13:\
    \ error: cannot find 'append' in scope\n            append(x, y)\n           \
    \ ^~~~~~\n/tmp/tmp_rfs694k.swift:13:13: error: cannot find 'append' in scope\n\
    \            append(l2, x)\n            ^~~~~~\n/tmp/tmp_rfs694k.swift:17:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1, y) {\n    \
    \        ^~~~~~~~\n/tmp/tmp_rfs694k.swift:18:13: error: cannot find 'append' in\
    \ scope\n            append(x, y)\n            ^~~~~~\n/tmp/tmp_rfs694k.swift:19:13:\
    \ error: cannot find 'append' in scope\n            append(l1, y)\n          \
    \  ^~~~~~\n/tmp/tmp_rfs694k.swift:22:12: error: cannot find 'unique' in scope\n\
    \    return unique(x)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1.count != l2.count {\n        return []\n  \
    \  }\n    var result = l1\n    for i in 0..<l1.count {\n        let index1 = index(l1,\
    \ i)\n        let index2 = index(l2, i)\n        if index1 != index2 {\n     \
    \       result.removeAtIndex(index1)\n            result.removeAtIndex(index2)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmplrxm6z2q.swift:13:22: error: cannot find 'index' in scope\n   \
    \     let index1 = index(l1, i)\n                     ^~~~~\n/tmp/tmplrxm6z2q.swift:14:22:\
    \ error: cannot find 'index' in scope\n        let index2 = index(l2, i)\n   \
    \                  ^~~~~\n/tmp/tmplrxm6z2q.swift:16:20: error: value of type '[Int]'\
    \ has no member 'removeAtIndex'\n            result.removeAtIndex(index1)\n  \
    \          ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmplrxm6z2q.swift:17:20: error: value of\
    \ type '[Int]' has no member 'removeAtIndex'\n            result.removeAtIndex(index2)\n\
    \            ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for num in l1 {\n     \
    \   guard let foundIndex = l2.index(of: num) else {\n            continue\n  \
    \      }\n        if result.removeAll { $0 == foundIndex }.isEmpty {\n       \
    \     result.append(foundIndex)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpmvitv48y.swift:10:35: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        guard let foundIndex = l2.index(of: num) else\
    \ {\n                                  ^\n/tmp/tmpmvitv48y.swift:10:35: note:\
    \ use 'firstIndex(of:)' instead\n        guard let foundIndex = l2.index(of: num)\
    \ else {\n                                  ^~~~~\n                          \
    \        firstIndex\n/tmp/tmpmvitv48y.swift:13:50: error: value of tuple type\
    \ '()' has no member 'isEmpty'\n        if result.removeAll { $0 == foundIndex\
    \ }.isEmpty {\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for element in a {\n  \
    \      if b.contains(element) {\n            result.append(element)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppc_zw75f.swift:9:20: error: cannot find 'a' in scope\n    for element\
    \ in a {\n                   ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var s1 = l1\n    var s2 = l2\n    var index1 = 0\n\
    \    var index2 = 0\n    var tmp = 0\n\n    while index1 < s1.count && index2\
    \ < s2.count {\n        if s1[index1] > s2[index2] {\n            tmp = s1[index1]\n\
    \            s1[index1] = s2[index2]\n            s2[index2] = tmp\n        }\
    \ else {\n            tmp = s2[index2]\n            s2[index2] = s1[index1]\n\
    \            s1[index1] = tmp\n        }\n        index1 += 1\n        index2\
    \ += 1\n    }\n\n    let sorted1 = s1\n    let sorted2 = s2\n    let sorted1Count\
    \ = sorted1.count\n    let sorted2Count = sorted2.count\n\n    var result = [Int]()\n\
    \    if sorted1Count == sorted2Count {\n        for index1 = 0; index1 < sorted1Count;\
    \ index1 += 1 {\n            result.append(sorted1[index1])\n        }\n     \
    \   return result\n    }\n\n    if sorted1Count > sorted2Count {\n        for\
    \ index1 = 0; index1 < sorted1Count; index1 += 1 {\n            result.append(sorted1[index1])\n\
    \        }\n        return result\n    }\n\n    for index1 = 0; index1 < sorted2Count;\
    \ index1 += 1 {\n        result.append(sorted2[index1])\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptdey5efr.swift:35:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for index1 = 0; index1 < sorted1Count; index1 += 1 {\n \
    \       ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptdey5efr.swift:42:9:\
    \ error: C-style for statement has been removed in Swift 3\n        for index1\
    \ = 0; index1 < sorted1Count; index1 += 1 {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptdey5efr.swift:48:5: error: C-style for statement has been removed in\
    \ Swift 3\n    for index1 = 0; index1 < sorted2Count; index1 += 1 {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let m = min(l1.count, l2.count)\n    var u = [Int](repeating:\
    \ 0, count: m)\n    var l = [Int](repeating: 0, count: m)\n    for i in 0 ..<\
    \ m {\n        if l1[i] != l2[i] {\n            l[i] = l1[i]\n        } else {\n\
    \            u[i] = l1[i]\n        }\n    }\n    return u\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmprjvwcwk0/tmprjvwcwk0.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b028f42bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b028f122b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b028f122988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b028f1217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprjvwcwk0                        0x000055aa6c75d7cc <unavailable> + 6092

    5    libc.so.6                          0x00002b028f617460 __libc_start_main +
    245

    6    tmprjvwcwk0                        0x000055aa6c75d349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    \n    for aElem in l1 {\n\
    \        for bElem in l2 {\n            if aElem == bElem {\n                result.append(aElem)\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp53hq8r7s/tmp53hq8r7s.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e0295ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e02651b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e02651988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e026507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp53hq8r7s                        0x0000562bb27d566c <unavailable> + 5740

    5    libc.so.6                          0x00002b0e02b46460 __libc_start_main +
    245

    6    tmp53hq8r7s                        0x0000562bb27d51e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n       \
    \ if !contains(l2, x) {\n            result.append(x)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp9__ed7ml.swift:10:13: error: cannot find 'contains' in scope\n\
    \        if !contains(l2, x) {\n            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return common(Array(l1), Array(l2))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpiirf8opp.swift:8:18: error: missing argument labels 'l1:l2:' in\
    \ call\n    return common(Array(l1), Array(l2))\n                 ^\n        \
    \          l1:        l2: \n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var set = Set()\n    for i in l1 {\n        set.add(i)\n\
    \    }\n    for i in l2 {\n        if set.contains(i) {\n            set.remove(i)\n\
    \        }\n    }\n    return Array(set.array())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxkab4l30.swift:8:15: error: generic parameter 'Element' could not\
    \ be inferred\n    var set = Set()\n              ^\n/tmp/tmpxkab4l30.swift:8:15:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var set\
    \ = Set()\n              ^\n                 <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n       \
    \ if !l2.contains(i) {\n            result.append(i)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpvl8p4g11/tmpvl8p4g11.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d38094c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d37d8bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d37d8b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d37d8a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvl8p4g11                        0x0000560064cea6cc <unavailable> + 5836

    5    libc.so.6                          0x00002b7d38280460 __libc_start_main +
    245

    6    tmpvl8p4g11                        0x0000560064cea249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\tvar result = Array(count: l1.count, repeatedValue:\
    \ Int64(-1))\n\tcommonUnsafe(l1, l2, &result)\n\treturn result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpfll1q6si.swift:8:53: error: extra argument 'repeatedValue' in call\n\
    \        var result = Array(count: l1.count, repeatedValue: Int64(-1))\n     \
    \                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n/tmp/tmpfll1q6si.swift:8:21:\
    \ error: missing argument for parameter 'repeating' in call\n        var result\
    \ = Array(count: l1.count, repeatedValue: Int64(-1))\n                       \
    \    ^\n                           repeating: <#_#>, \nSwift.Array:4:23: note:\
    \ 'init(repeating:count:)' declared here\n    @inlinable public init(repeating\
    \ repeatedValue: Element, count: Int)\n                      ^\n/tmp/tmpfll1q6si.swift:9:2:\
    \ error: cannot find 'commonUnsafe' in scope\n        commonUnsafe(l1, l2, &result)\n\
    \        ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for e in l1 {\n     \
    \   if let index = commonIndex(l1, e, l2) {\n            common = common[..<index]\n\
    \            common.append(e)\n        }\n    }\n    return common\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0ao41ey6.swift:10:24: error: cannot find 'commonIndex' in scope\n\
    \        if let index = commonIndex(l1, e, l2) {\n                       ^~~~~~~~~~~\n\
    /tmp/tmp0ao41ey6.swift:11:28: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n            common = common[..<index]\n                   \
    \  ~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var commonCount = 0\n\
    \    var array1 = l1\n    var array2 = l2\n    while i < array1.count && j < array2.count\
    \ {\n        if array1[i] == array2[j] {\n            commonCount++\n        \
    \    i++\n            j++\n        } else if array1[i] < array2[j] {\n       \
    \     i++\n        } else {\n            j++\n        }\n    }\n    return array1.suffix(array1.count\
    \ - commonCount).prefix(commonCount)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpf5zn5pqv.swift:15:24: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            commonCount++\n                       ^~\n\
    /tmp/tmpf5zn5pqv.swift:16:14: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            i++\n             ^~\n/tmp/tmpf5zn5pqv.swift:17:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  j++\n             ^~\n/tmp/tmpf5zn5pqv.swift:19:14: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            i++\n             ^~\n/tmp/tmpf5zn5pqv.swift:21:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  j++\n             ^~\n/tmp/tmpf5zn5pqv.swift:24:54: error: cannot convert return\
    \ expression of type 'ArraySlice<Int>' to return type '[Int]'\n    return array1.suffix(array1.count\
    \ - commonCount).prefix(commonCount)\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    func helper(pos: Int, arr:\
    \ [Int], arr2: [Int]) -> [Int] {\n        var l1 = arr[l1pos]\n        var l2\
    \ = arr2[l2pos]\n        if l1 == l2 {\n            if l1pos == l2pos {\n    \
    \            result.append(l1)\n            }\n            return result\n   \
    \     }\n        switch l1 {\n        case .min() where l2 == .max():\n      \
    \      result.append(l1)\n            return result\n        case .min():\n  \
    \          result.append(l1)\n            return result\n        case .max():\n\
    \            result.append(l2)\n            return result\n        }\n       \
    \ if l2 < l1 {\n            arr[l1pos] = l1\n            l1pos++\n           \
    \ arr2[l2pos] = l2\n            l2pos++\n            helper(pos, arr, arr2)\n\
    \            arr[l1pos] = l1\n            l1pos++\n            arr2[l2pos] = l2\n\
    \            l2pos++\n        } else {\n            arr[l1pos] = l2\n        \
    \    l1pos++\n            arr2[l2pos] = l1\n            l2pos++\n            helper(pos,\
    \ arr, arr2)\n            arr[l1pos] = l2\n            l1pos++\n            arr2[l2pos]\
    \ = l1\n            l2pos++\n        }\n        return nil\n    }\n    l1pos =\
    \ 0\n    l2pos = 0\n    for _ in 0 ..< l1.count {\n        helper(l1pos, &l1[0..<l1.count],\
    \ &l2[0..<l2.count])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_8xysvp6.swift:10:22: error: cannot find 'l1pos' in scope\n   \
    \     var l1 = arr[l1pos]\n                     ^~~~~\n/tmp/tmp_8xysvp6.swift:11:23:\
    \ error: cannot find 'l2pos' in scope\n        var l2 = arr2[l2pos]\n        \
    \              ^~~~~\n/tmp/tmp_8xysvp6.swift:13:16: error: cannot find 'l1pos'\
    \ in scope\n            if l1pos == l2pos {\n               ^~~~~\n/tmp/tmp_8xysvp6.swift:13:25:\
    \ error: cannot find 'l2pos' in scope\n            if l1pos == l2pos {\n     \
    \                   ^~~~~\n/tmp/tmp_8xysvp6.swift:30:17: error: cannot find 'l1pos'\
    \ in scope\n            arr[l1pos] = l1\n                ^~~~~\n/tmp/tmp_8xysvp6.swift:31:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  l1pos++\n                 ^~\n/tmp/tmp_8xysvp6.swift:31:13: error: cannot find\
    \ 'l1pos' in scope\n            l1pos++\n            ^~~~~\n/tmp/tmp_8xysvp6.swift:32:18:\
    \ error: cannot find 'l2pos' in scope\n            arr2[l2pos] = l2\n        \
    \         ^~~~~\n/tmp/tmp_8xysvp6.swift:33:18: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            l2pos++\n                 ^~\n/tmp/tmp_8xysvp6.swift:33:13:\
    \ error: cannot find 'l2pos' in scope\n            l2pos++\n            ^~~~~\n\
    /tmp/tmp_8xysvp6.swift:34:19: error: missing argument labels 'pos:arr:arr2:' in\
    \ call\n            helper(pos, arr, arr2)\n                  ^\n            \
    \       pos: arr: arr2: \n/tmp/tmp_8xysvp6.swift:35:17: error: cannot find 'l1pos'\
    \ in scope\n            arr[l1pos] = l1\n                ^~~~~\n/tmp/tmp_8xysvp6.swift:36:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  l1pos++\n                 ^~\n/tmp/tmp_8xysvp6.swift:36:13: error: cannot find\
    \ 'l1pos' in scope\n            l1pos++\n            ^~~~~\n/tmp/tmp_8xysvp6.swift:37:18:\
    \ error: cannot find 'l2pos' in scope\n            arr2[l2pos] = l2\n        \
    \         ^~~~~\n/tmp/tmp_8xysvp6.swift:38:18: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            l2pos++\n                 ^~\n/tmp/tmp_8xysvp6.swift:38:13:\
    \ error: cannot find 'l2pos' in scope"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set = Set(l1 + l2)\n    let result = Array(set.sorted()).sorted()\n\
    \    return Array(result[0..<l1Length])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmppx3mn7t4.swift:10:29: error: cannot find 'l1Length' in scope\n\
    \    return Array(result[0..<l1Length])\n                            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    \n    for index in l1 {\n\
    \        if l2.contains(index) {\n            result.append(index)\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpoq8258hi/tmpoq8258hi.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad73e6e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad73e3dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad73e3db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad73e3da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoq8258hi                        0x000055d88a49e6cc <unavailable> + 5836

    5    libc.so.6                          0x00002ad73e8d0460 __libc_start_main +
    245

    6    tmpoq8258hi                        0x000055d88a49e249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count > 0 && l2.count > 0 else { return\
    \ [] }\n    var result: [Int] = []\n    for i in 0..<min(l1.count, l2.count) {\n\
    \        let a = l1[i] < l2[i] ? l1[i] : l2[i]\n        let b = l1[i] < l2[i]\
    \ ? l2[i] : l1[i]\n        if a != b {\n            result.append(a)\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmp7bqsrm87/tmp7bqsrm87.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad6696bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad6693b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad6693b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6693b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7bqsrm87                        0x000055f40048c76c <unavailable> + 5996

    5    libc.so.6                          0x00002ad6698a7460 __libc_start_main +
    245

    6    tmp7bqsrm87                        0x000055f40048c2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for number in l1 {\n  \
    \      if l2Contains(number, l2) {\n            result.append(number)\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_eknjvx7.swift:10:12: error: cannot find 'l2Contains' in scope\n\
    \        if l2Contains(number, l2) {\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common = Array(count: min(l1.count, l2.count),\
    \ repeatedValue: 0)\n    for (_, i, _) in common.Compute {\n        if i >= l1.count\
    \ {\n            break\n        }\n        if i >= l2.count {\n            break\n\
    \        }\n        if l1[i] == l2[i] {\n            common[i] = 0\n        }\
    \ else {\n            common[i] = 1\n        }\n    }\n    return common\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpfg6qamp0.swift:8:18: error: no exact matches in call to initializer\
    \ \n    var common = Array(count: min(l1.count, l2.count), repeatedValue: 0)\n\
    \                 ^\n/tmp/tmpfg6qamp0.swift:8:18: note: candidate has partially\
    \ matching parameter list (repeating: _, count: Int)\n    var common = Array(count:\
    \ min(l1.count, l2.count), repeatedValue: 0)\n                 ^\n/tmp/tmpfg6qamp0.swift:8:18:\
    \ note: candidate has partially matching parameter list (repeating: _, count:\
    \ Int)\n    var common = Array(count: min(l1.count, l2.count), repeatedValue:\
    \ 0)\n                 ^\n/tmp/tmpfg6qamp0.swift:9:5: error: failed to produce\
    \ diagnostic for expression; please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n    for (_, i, _) in common.Compute {\n    ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    func compare<T>(_ a1: T,\
    \ _ a2: T) -> Bool {\n        return a1 == a2 ? 0 : 1\n    }\n    for i in l1\
    \ {\n        if l2.contains(&i) {\n            result.append(i)\n        }\n \
    \   }\n    result.sort(by: compare)\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0nhdcd_3.swift:10:19: error: referencing operator function '=='\
    \ on 'Equatable' requires that 'T' conform to 'Equatable'\n        return a1 ==\
    \ a2 ? 0 : 1\n                  ^\nSwift.Equatable:1:17: note: where 'Self' =\
    \ 'T'\npublic protocol Equatable {\n                ^\n/tmp/tmp0nhdcd_3.swift:10:25:\
    \ error: type 'Int' cannot be used as a boolean; test for '!= 0' instead\n   \
    \     return a1 == a2 ? 0 : 1\n                        ^\n               ((  \
    \            ) != 0)\n/tmp/tmp0nhdcd_3.swift:13:24: error: '&' used with non-inout\
    \ argument of type 'Int'\n        if l2.contains(&i) {\n                     \
    \  ^~\n                       \n/tmp/tmp0nhdcd_3.swift:13:24: error: cannot pass\
    \ immutable value as inout argument: 'i' is a 'let' constant\n        if l2.contains(&i)\
    \ {\n                       ^~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1 == l2 {\n        return l1\n    }\n\n    let\
    \ i1 = l1.startIndex\n    let i2 = l2.startIndex\n    var l = i1\n    var r =\
    \ i2\n    while l <= r {\n        if l1[l] != l2[l] {\n            r = r - 1\n\
    \        }\n        else {\n            l++\n        }\n    }\n\n    return l1[l\
    \ - i1 + l2.startIndex..<l]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0ujajh53.swift:21:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            l++\n             ^~\n/tmp/tmp0ujajh53.swift:25:14:\
    \ error: cannot convert return expression of type 'ArraySlice<Int>' to return\
    \ type '[Int]'\n    return l1[l - i1 + l2.startIndex..<l]\n           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  var result: [Int] = []\n\n  l1.sort()\n  l2.sort()\n\
    \n  for element in l1 where l2[0] == element {\n    l2.remove(element)\n  }\n\n\
    \  for i in 0..<(l2.count - 1) {\n    if l1[l1Index] == l2[i] {\n      result.insert(l1Index\
    \ + 1, l2[i])\n      l1Index += 1\n    } else {\n      break\n    }\n  }\n\n \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpjx2gi96o.swift:10:6: error: cannot use mutating member on immutable\
    \ value: 'l1' is a 'let' constant\n  l1.sort()\n  ~~ ^\n/tmp/tmpjx2gi96o.swift:11:6:\
    \ error: cannot use mutating member on immutable value: 'l2' is a 'let' constant\n\
    \  l2.sort()\n  ~~ ^\n/tmp/tmpjx2gi96o.swift:14:8: error: no exact matches in\
    \ call to instance method 'remove'\n    l2.remove(element)\n       ^\n/tmp/tmpjx2gi96o.swift:14:8:\
    \ note: found candidate with type '(Int) -> Int'\n    l2.remove(element)\n   \
    \    ^\n/tmp/tmpjx2gi96o.swift:18:11: error: cannot find 'l1Index' in scope\n\
    \    if l1[l1Index] == l2[i] {\n          ^~~~~~~\n/tmp/tmpjx2gi96o.swift:19:21:\
    \ error: cannot find 'l1Index' in scope\n      result.insert(l1Index + 1, l2[i])\n\
    \                    ^~~~~~~\n/tmp/tmpjx2gi96o.swift:19:14: error: no exact matches\
    \ in call to instance method 'insert'\n      result.insert(l1Index + 1, l2[i])\n\
    \             ^\n/tmp/tmpjx2gi96o.swift:19:14: note: found candidate with type\
    \ '(__owned Int, Int) -> ()'\n      result.insert(l1Index + 1, l2[i])\n      \
    \       ^\n/tmp/tmpjx2gi96o.swift:20:7: error: cannot find 'l1Index' in scope\n\
    \      l1Index += 1\n      ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for element in l1 {\n\
    \        if l2.contains(element) {\n            result.append(element)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpif5xfy5o/tmpif5xfy5o.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b306cf7fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b306cc76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b306cc76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b306cc757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpif5xfy5o                        0x000055895469767c <unavailable> + 5756

    5    libc.so.6                          0x00002b306d16b460 __libc_start_main +
    245

    6    tmpif5xfy5o                        0x00005589546971f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n\n    for item in  l1 {\n \
    \       if !contains(result, item) {\n            result = result + [l2]\n   \
    \     }\n    }\n    for item in  l2 {\n        if !contains(result, item) {\n\
    \            result = result + [l1]\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp5qd9tknw.swift:11:13: error: cannot find 'contains' in scope\n\
    \        if !contains(result, item) {\n            ^~~~~~~~\n/tmp/tmp5qd9tknw.swift:12:32:\
    \ error: cannot convert value of type '[Int]' to expected element type 'Int'\n\
    \            result = result + [l2]\n                               ^\n/tmp/tmp5qd9tknw.swift:16:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(result, item) {\n\
    \            ^~~~~~~~\n/tmp/tmp5qd9tknw.swift:17:32: error: cannot convert value\
    \ of type '[Int]' to expected element type 'Int'\n            result = result\
    \ + [l1]\n                               ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common = l1\n    var i = 0\n    var j = 0\n \
    \   while i < common.Size && j < l2.Size {\n        if common[i] < l2[j] {\n \
    \           i += 1\n        } else if common[i] > l2[j] {\n            j += 1\n\
    \        } else {\n            common.removeAtIndex(i)\n            i += 1\n \
    \           j += 1\n        }\n    }\n    while i < common.Size {\n        common.removeAtIndex(i)\n\
    \        i += 1\n    }\n    while j < l2.Size {\n        common.removeAtIndex(j)\n\
    \        j += 1\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6b_e12_o.swift:11:22: error: value of type '[Int]' has no member\
    \ 'Size'\n    while i < common.Size && j < l2.Size {\n              ~~~~~~ ^~~~\n\
    /tmp/tmp6b_e12_o.swift:11:37: error: value of type '[Int]' has no member 'Size'\n\
    \    while i < common.Size && j < l2.Size {\n                                \
    \ ~~ ^~~~\n/tmp/tmp6b_e12_o.swift:17:20: error: value of type '[Int]' has no member\
    \ 'removeAtIndex'\n            common.removeAtIndex(i)\n            ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmp6b_e12_o.swift:22:22: error: value of type '[Int]' has no member 'Size'\n\
    \    while i < common.Size {\n              ~~~~~~ ^~~~\n/tmp/tmp6b_e12_o.swift:23:16:\
    \ error: value of type '[Int]' has no member 'removeAtIndex'\n        common.removeAtIndex(i)\n\
    \        ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp6b_e12_o.swift:26:18: error: value of type\
    \ '[Int]' has no member 'Size'\n    while j < l2.Size {\n              ~~ ^~~~\n\
    /tmp/tmp6b_e12_o.swift:27:16: error: value of type '[Int]' has no member 'removeAtIndex'\n\
    \        common.removeAtIndex(j)\n        ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for x in l1 {\n       \
    \ for y in l2 {\n            if x == y {\n                result.appendContentsOf(result)\n\
    \            } else {\n                break\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp9rf5vch5.swift:12:24: error: value of type '[Int]' has no member\
    \ 'appendContentsOf'\n                result.appendContentsOf(result)\n      \
    \          ~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = l1\n    for element in l2 {\n\
    \        if !contains(result, element) {\n            result = append(result,\
    \ element)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpyzts8ka5.swift:10:13: error: cannot find 'contains' in scope\n\
    \        if !contains(result, element) {\n            ^~~~~~~~\n/tmp/tmpyzts8ka5.swift:11:22:\
    \ error: cannot find 'append' in scope\n            result = append(result, element)\n\
    \                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    if l1 == l2 {\n        return l1\n    }\n\n    var\
    \ l1 = Array(l1)\n    var l2 = Array(l2)\n    var l1 = l1.sorted()\n    var l2\
    \ = l2.sorted()\n\n    var i = 0\n    var j = 0\n\n    while i < l1.count && j\
    \ < l2.count {\n        if l1[i] < l2[j] {\n            l1.removeAtIndex(i)\n\
    \            i -= 1\n        } else {\n            l2.removeAtIndex(j)\n     \
    \       j -= 1\n        }\n    }\n\n    return l1.append(l2.sorted())\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe8gsr_p4.swift:14:9: error: invalid redeclaration of 'l1'\n   \
    \ var l1 = l1.sorted()\n        ^\n/tmp/tmpe8gsr_p4.swift:12:9: note: 'l1' previously\
    \ declared here\n    var l1 = Array(l1)\n        ^\n/tmp/tmpe8gsr_p4.swift:15:9:\
    \ error: invalid redeclaration of 'l2'\n    var l2 = l2.sorted()\n        ^\n\
    /tmp/tmpe8gsr_p4.swift:13:9: note: 'l2' previously declared here\n    var l2 =\
    \ Array(l2)\n        ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let sorted1 = l1.sorted()\n    let sorted2 = l2.sorted()\n\
    \    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < sorted1.count\
    \ && j < sorted2.count {\n        let c1 = sorted1[i]\n        let c2 = sorted2[j]\n\
    \        if c1 == c2 {\n            result.append(c1)\n            i += 1\n  \
    \          j += 1\n        } else if c1 < c2 {\n            i += 1\n        }\
    \ else {\n            j += 1\n        }\n    }\n    result.removeAll(keepingCapacity:\
    \ true)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmp5mgx2fga/tmp5mgx2fga.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c61cb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c619aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c619ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c619ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5mgx2fga                        0x00005565bcc4f6bc <unavailable> + 5820

    5    libc.so.6                          0x00002b3c61ea3460 __libc_start_main +
    245

    6    tmp5mgx2fga                        0x00005565bcc4f239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Set(l1).intersect(Set(l2))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgnf8w2oc.swift:8:20: error: value of type 'Set<Int>' has no member\
    \ 'intersect'\n    return Set(l1).intersect(Set(l2))\n           ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common = [Int]()\n    var i = 0\n    let l1 =\
    \ ArrayUtils.fromArray(l1)\n    let l2 = ArrayUtils.fromArray(l2)\n    while (l1.count\
    \ > 0 && l2.count > 0) {\n        if (l1.0[Int32(i)] == l2.0[Int32(i)]) {\n  \
    \          common.append(l1.0[Int32(i)])\n            l1.remove(at: 0)\n     \
    \       l2.remove(at: 0)\n        } else {\n            i += 1\n        }\n  \
    \  }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpcedypftg.swift:10:14: error: cannot find 'ArrayUtils' in scope\n\
    \    let l1 = ArrayUtils.fromArray(l1)\n             ^~~~~~~~~~\n/tmp/tmpcedypftg.swift:11:14:\
    \ error: cannot find 'ArrayUtils' in scope\n    let l2 = ArrayUtils.fromArray(l2)\n\
    \             ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l = [Int]()\n    let minCount = min(l1.count,\
    \ l2.count)\n    for i in 0..<minCount {\n        if l1[i] == l2[i] {\n      \
    \      l.append(l1[i])\n        }\n    }\n    return l.sort()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7_rsiuos.swift:15:14: error: cannot convert return expression of\
    \ type '()' to return type '[Int]'\n    return l.sort()\n           ~~^~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var aSet = Set()\n    for x in l1 {\n        if aSet.contains(x)\
    \ {\n            aSet.add(x)\n        } else {\n            aSet.add(x)\n    \
    \    }\n    }\n    var bSet = Set()\n    for x in l2 {\n        if bSet.contains(x)\
    \ {\n            bSet.add(x)\n        } else {\n            bSet.add(x)\n    \
    \    }\n    }\n    var result = Set()\n    for x in aSet {\n        if !bSet.contains(x)\
    \ {\n            result.add(x)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprybt4cz_.swift:8:16: error: generic parameter 'Element' could not\
    \ be inferred\n    var aSet = Set()\n               ^\n/tmp/tmprybt4cz_.swift:8:16:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var aSet\
    \ = Set()\n               ^\n                  <<#Element: Hashable#>>\n/tmp/tmprybt4cz_.swift:16:16:\
    \ error: generic parameter 'Element' could not be inferred\n    var bSet = Set()\n\
    \               ^\n/tmp/tmprybt4cz_.swift:16:16: note: explicitly specify the\
    \ generic arguments to fix this issue\n    var bSet = Set()\n               ^\n\
    \                  <<#Element: Hashable#>>\n/tmp/tmprybt4cz_.swift:24:18: error:\
    \ generic parameter 'Element' could not be inferred\n    var result = Set()\n\
    \                 ^\n/tmp/tmprybt4cz_.swift:24:18: note: explicitly specify the\
    \ generic arguments to fix this issue\n    var result = Set()\n              \
    \   ^\n                    <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = l1\n    var i = 0\n    var j = 0\n \
    \   while i < l1.count && j < l2.count {\n        if l1[i] != l2[j] {\n      \
    \      result.remove(at: i)\n        }\n        i += 1\n        j += 1\n    }\n\
    \    if j == l2.count {\n        result.remove(at: i)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'Swift/Array.swift:1331: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b82fd881c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82fd578561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b82fd578286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b82fd57813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b82fd577bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b82fd565018 <unavailable> + 1355800

    6    tmpkvr2hqc7                        0x00005639f290eb5a <unavailable> + 7002

    7    tmpkvr2hqc7                        0x00005639f290e473 <unavailable> + 5235

    8    libc.so.6                          0x00002b82fda6d460 __libc_start_main +
    245

    9    tmpkvr2hqc7                        0x00005639f290e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979366
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return sorted(Set(l1).intersect(Set(l2)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp17oqkwi4.swift:8:12: error: cannot find 'sorted' in scope\n   \
    \ return sorted(Set(l1).intersect(Set(l2)))\n           ^~~~~~\n/tmp/tmp17oqkwi4.swift:8:27:\
    \ error: value of type 'Set<Int>' has no member 'intersect'\n    return sorted(Set(l1).intersect(Set(l2)))\n\
    \                  ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var count1 = Int()\n  \
    \  var count2 = Int()\n    for element in l1 {\n        if l2contains element\
    \ {\n            count1++ \n        }\n    }\n    for element in l2 {\n      \
    \  if l1contains element {\n            count2++\n        }\n    }\n    if count1\
    \ > count2 {\n        result += l1\n        result += l2\n    }\n    if count1\
    \ < count2 {\n        result += l2\n        result += l1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmptzfu73ez.swift:12:23: error: expected '{' after 'if' condition\n\
    \        if l2contains element {\n                      ^\n/tmp/tmptzfu73ez.swift:17:23:\
    \ error: expected '{' after 'if' condition\n        if l1contains element {\n\
    \                      ^\n/tmp/tmptzfu73ez.swift:12:12: error: cannot find 'l2contains'\
    \ in scope\n        if l2contains element {\n           ^~~~~~~~~~\n/tmp/tmptzfu73ez.swift:13:19:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  count1++ \n                  ^~\n/tmp/tmptzfu73ez.swift:17:12: error: cannot\
    \ find 'l1contains' in scope\n        if l1contains element {\n           ^~~~~~~~~~\n\
    /tmp/tmptzfu73ez.swift:18:19: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            count2++\n                  ^~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var a = [Int]()\n    var b = [Int]()\n\n    for x\
    \ in l1 {\n        if !contains(b, x) {\n            append(b, x)\n        }\n\
    \    }\n\n    for x in l2 {\n        if !contains(a, x) {\n            append(a,\
    \ x)\n        }\n    }\n\n    return arrayUnique(a)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmph553k5na.swift:12:13: error: cannot find 'contains' in scope\n\
    \        if !contains(b, x) {\n            ^~~~~~~~\n/tmp/tmph553k5na.swift:13:13:\
    \ error: cannot find 'append' in scope\n            append(b, x)\n           \
    \ ^~~~~~\n/tmp/tmph553k5na.swift:18:13: error: cannot find 'contains' in scope\n\
    \        if !contains(a, x) {\n            ^~~~~~~~\n/tmp/tmph553k5na.swift:19:13:\
    \ error: cannot find 'append' in scope\n            append(a, x)\n           \
    \ ^~~~~~\n/tmp/tmph553k5na.swift:23:12: error: cannot find 'arrayUnique' in scope\n\
    \    return arrayUnique(a)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l: Int = max(l1, l2).sorted().reduce(0) { (ac,\
    \ a) in\n        return ac > a ? ac : a\n    }\n    if l == 0 {\n        return\
    \ l1\n    }\n    if l == max(l1, l2) {\n        return l2\n    }\n    var ret:\
    \ [Int] = []\n    for i in l1 {\n        ret.insert(i, at: 0)\n    }\n    for\
    \ i in l2 {\n        ret.insert(i, at: 1)\n    }\n    return ret\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4_jmj869.swift:8:18: error: global function 'max' requires that\
    \ '[Int]' conform to 'Comparable'\n    let l: Int = max(l1, l2).sorted().reduce(0)\
    \ { (ac, a) in\n                 ^\nSwift.max:1:24: note: where 'T' = '[Int]'\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp4_jmj869.swift:14:10: error: binary operator '=='\
    \ cannot be applied to operands of type 'Int' and '[Int]'\n    if l == max(l1,\
    \ l2) {\n       ~ ^  ~~~~~~~~~~~\n/tmp/tmp4_jmj869.swift:14:10: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Int, Int)\n \
    \   if l == max(l1, l2) {\n         ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    var j = 0\n    for i\
    \ in l1 {\n        if l2[j] == i {\n            result.append(i)\n           \
    \ j++\n        } else {\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp7o66yxfj.swift:13:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            j++\n             ^~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    guard l1.count != 0 &&\
    \ l2.count != 0 else {\n        return nil\n    }\n    while l1.count > 0 && l2.count\
    \ > 0 {\n        if l1[0] < l2[0] {\n            result.insert(l1[0], at: 0)\n\
    \            l1.remove(at: 0)\n        } else {\n            result.insert(l2[0],\
    \ at: 0)\n            l2.remove(at: 0)\n        }\n    }\n    if l1.count > 0\
    \ {\n        result.extend(l1[0...])\n    }\n    if l2.count > 0 {\n        result.extend(l2[0...])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpp96ulckd.swift:10:16: error: 'nil' is incompatible with return\
    \ type '[Int]'\n        return nil\n               ^\n/tmp/tmpp96ulckd.swift:15:16:\
    \ error: cannot use mutating member on immutable value: 'l1' is a 'let' constant\n\
    \            l1.remove(at: 0)\n            ~~ ^\n/tmp/tmpp96ulckd.swift:18:16:\
    \ error: cannot use mutating member on immutable value: 'l2' is a 'let' constant\n\
    \            l2.remove(at: 0)\n            ~~ ^\n/tmp/tmpp96ulckd.swift:22:16:\
    \ error: value of type '[Int]' has no member 'extend'\n        result.extend(l1[0...])\n\
    \        ~~~~~~ ^~~~~~\n/tmp/tmpp96ulckd.swift:25:16: error: value of type '[Int]'\
    \ has no member 'extend'\n        result.extend(l2[0...])\n        ~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l1c = [Int]()\n    var l2c = [Int]()\n    for\
    \ v in l1 {\n        if !contains(l2c, v) {\n            l1c.append(v)\n     \
    \   }\n    }\n    for v in l2 {\n        if !contains(l1c, v) {\n            c2c.append(v)\n\
    \        }\n    }\n    return l1c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgm3oj7w3.swift:11:13: error: cannot find 'contains' in scope\n\
    \        if !contains(l2c, v) {\n            ^~~~~~~~\n/tmp/tmpgm3oj7w3.swift:16:13:\
    \ error: cannot find 'contains' in scope\n        if !contains(l1c, v) {\n   \
    \         ^~~~~~~~\n/tmp/tmpgm3oj7w3.swift:17:13: error: cannot find 'c2c' in\
    \ scope\n            c2c.append(v)\n            ^~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return ArrayUtils.sortUnique(ArrayUtils.subtractUnique(l1,\
    \ l2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34,\
    \ 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpxjhmb7sy.swift:8:12: error: cannot find 'ArrayUtils' in scope\n\
    \    return ArrayUtils.sortUnique(ArrayUtils.subtractUnique(l1, l2))\n       \
    \    ^~~~~~~~~~\n/tmp/tmpxjhmb7sy.swift:8:34: error: cannot find 'ArrayUtils'\
    \ in scope\n    return ArrayUtils.sortUnique(ArrayUtils.subtractUnique(l1, l2))\n\
    \                                 ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count == l2.count else { return [] }\n \
    \   var result = [Int]()\n    var index = 0\n    while index < l1.count && index\
    \ < l2.count {\n        if l1[index] == l2[index] {\n            result.append(l1[index])\n\
    \            index += 1\n            continue\n        }\n        if l1[index]\
    \ > l2[index] {\n            result.append(l1[index])\n            index += 1\n\
    \        } else {\n            result.append(l2[index])\n            index +=\
    \ 1\n        }\n    }\n    result.removeAll({ l2.contains($0) })\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpusxf52bd.swift:25:12: error: no exact matches in call to instance\
    \ method 'removeAll'\n    result.removeAll({ l2.contains($0) })\n           ^\n\
    Swift.RangeReplaceableCollection:2:37: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(where:)')\n    @inlinable public mutating func removeAll(where\
    \ shouldBeRemoved: (Self.Element) throws -> Bool) rethrows\n                 \
    \                   ^\nSwift.RangeReplaceableCollection:2:37: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(where:)')\n    @inlinable public\
    \ mutating func removeAll(where shouldBeRemoved: (Self.Element) throws -> Bool)\
    \ rethrows\n                                    ^\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var set = Set()\n    var result = Set()\n    for\
    \ a in l1 {\n        if !set.contains(a) {\n            for b in l2 {\n      \
    \          if a == b {\n                    set.insert(a)\n                  \
    \  break\n                }\n            }\n        }\n    }\n    for a in l2\
    \ {\n        if !set.contains(a) {\n            for b in l1 {\n              \
    \  if a == b {\n                    set.insert(a)\n                    break\n\
    \                }\n            }\n        }\n    }\n    return array.filter({\
    \ set.contains($0) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp6wkch71g.swift:8:15: error: generic parameter 'Element' could not\
    \ be inferred\n    var set = Set()\n              ^\n/tmp/tmp6wkch71g.swift:8:15:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var set\
    \ = Set()\n              ^\n                 <<#Element: Hashable#>>\n/tmp/tmp6wkch71g.swift:9:18:\
    \ error: generic parameter 'Element' could not be inferred\n    var result = Set()\n\
    \                 ^\n/tmp/tmp6wkch71g.swift:9:18: note: explicitly specify the\
    \ generic arguments to fix this issue\n    var result = Set()\n              \
    \   ^\n                    <<#Element: Hashable#>>\n/tmp/tmp6wkch71g.swift:30:12:\
    \ error: cannot find 'array' in scope\n    return array.filter({ set.contains($0)\
    \ })\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    if l1 == l2 { return result\
    \ }\n    for x in l1 {\n        for y in l2 {\n            if x == y { continue\
    \ }\n            guard result.contains(&y) else {\n                result.append(y)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgbdho9lp.swift:13:35: error: '&' used with non-inout argument of\
    \ type 'Int'\n            guard result.contains(&y) else {\n                 \
    \                 ^~\n                                  \n/tmp/tmpgbdho9lp.swift:13:35:\
    \ error: cannot pass immutable value as inout argument: 'y' is a 'let' constant\n\
    \            guard result.contains(&y) else {\n                              \
    \    ^~\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var res = Set()\n    for i in l1 {\n        if !res.contains(i)\
    \ {\n            res.add(i)\n        }\n    }\n    for i in l2 {\n        if !res.contains(i)\
    \ {\n            res.add(i)\n        }\n    }\n    return Array(res)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpgtoplo2z.swift:8:15: error: generic parameter 'Element' could not\
    \ be inferred\n    var res = Set()\n              ^\n/tmp/tmpgtoplo2z.swift:8:15:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var res\
    \ = Set()\n              ^\n                 <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1659979365
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n\n    for x in l1 {\n     \
    \   for y in l2 {\n            if x == y {\n                continue\n       \
    \     }\n            if !contains(&result, &x) {\n                result.append(x)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpx0xkdc2s.swift:15:17: error: cannot find 'contains' in scope\n\
    \            if !contains(&result, &x) {\n                ^~~~~~~~\n/tmp/tmpx0xkdc2s.swift:15:35:\
    \ error: cannot pass immutable value as inout argument: 'x' is a 'let' constant\n\
    \            if !contains(&result, &x) {\n                                  ^~\n"
  stdout: ''
  timestamp: 1659979366
