name: HumanEval_134_check_if_last_char_is_a_letter
language: swift
prompt: "\n/// Create a function that returns true if the last character\n/// of a\
  \ given string is an alphabetical character and is not\n/// a part of a word, and\
  \ false otherwise.\n/// Note: \"word\" is a group of characters separated by space.\n\
  /// Examples:\n/// >>> check_if_last_char_is_a_letter(txt: \"apple pie\")\n/// false\n\
  /// >>> check_if_last_char_is_a_letter(txt: \"apple pi e\")\n/// true\n/// >>> check_if_last_char_is_a_letter(txt:\
  \ \"apple pi e \")\n/// false\n/// >>> check_if_last_char_is_a_letter(txt: \"\"\
  )\n/// false\nfunc check_if_last_char_is_a_letter(txt: String) -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(check_if_last_char_is_a_letter(txt: \"apple\"\
  ) == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e\") == true)\n\
  assert(check_if_last_char_is_a_letter(txt: \"eeeee\") == false)\nassert(check_if_last_char_is_a_letter(txt:\
  \ \"A\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie \")\
  \ == false)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie 1\") == false)\n\
  assert(check_if_last_char_is_a_letter(txt: \"\") == false)\nassert(check_if_last_char_is_a_letter(txt:\
  \ \"eeeee e \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pie\"\
  ) == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e \") == false)"
completions: ["    let len = txt.characters.count\n    if len == 0 {\n        return\
    \ false\n    }\n    \n    let lastChar = txt.characters.last\n    return lastChar.isLetter()\
    \ && !lastChar.isWhitespace()", "    if txt.count > 0 {\n        let lastChar\
    \ = txt.last\n        let charArray = String(lastChar).unicodeScalars\n      \
    \  let charCount = charArray.count\n        if charCount > 0 {\n            if\
    \ charArray.last == lastChar {\n                return true\n            } else\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ false", "    // Your code here\n    if txt.isEmpty {\n        return false\n\
    \    }\n    let chars = txt.characters\n    if chars.last == \" \" {\n       \
    \ return false\n    }\n    if chars.last == chars.first?.unicodeScalars.last?.value\
    \ {\n        return true\n    }\n    return false", "    if txt.isEmpty { return\
    \ false }\n    let lastChar = txt.last!\n    \n    if lastChar.isAlphabet{\n \
    \       if !txt.hasSuffix(\" \"){ return true }\n        \n        return false\n\
    \    }\n    return true", "    let last_char = txt.characters.last\n    if last_char\
    \ == nil {\n        return false\n    }\n    if let last_char_ = last_char as?\
    \ Character {\n        if last_char_ == \" \" {\n            return false\n  \
    \      }\n        let letter = unicodeScalars.characters().first(where: { $0.isLetter()\
    \ })\n        if let letter_ = letter {\n            return !txt.rangeOfCharacter(from:\
    \ letter_..<last_char_)?.isEmpty\n        }\n    }\n    return false", '    return
    txt.last == " "', "    return txt.characters.last == txt.characters.last!\n  \
    \      && !is_word_char(txt.characters.last!)", '    return txt.characters[txt.endIndex
    - 1].isLetter && !is_word_char(txt)', "    if txt == \"\" {\n        return false\n\
    \    }\n\n    return !txt.hasSuffix(\",.;'\") && a.rangeOfCharacter(from: NSCharacterSet.letters)\
    \ != nil", "    if txt.count == 0 {\n        return false\n    }\n    let lastChar\
    \ = txt[txt.count-1]\n    return lastChar.isLetter() && lastChar != \"-\"", " \
    \   if txt.isEmpty {\n        return false\n    }\n    \n    let lastChar = txt.characters.last\
    \ ?? \"\"\n    return lastChar.isLetter && !lastChar.isWhitespace", "    txt =\
    \ txt.trimmingCharacters(in: .whitespacesAndNewlines)\n    guard txt.count > 0\
    \ else {\n        return false\n    }\n    var lastChar: Character? = nil\n  \
    \  switch txt.last {\n    case \" \":\n        lastChar = \" \"\n    case \".\"\
    :\n        lastChar = \".\"\n    case \"!\":\n        lastChar = \"!\"\n    case\
    \ \"?\":\n        lastChar = \"?\"\n    case \"_\":\n        lastChar = \"_\"\n\
    \    case \"-\":\n        lastChar = \"-\"\n    case \"(\":\n        lastChar\
    \ = \"(\"\n    case \")\":\n        lastChar = \")\"\n    case \"+\":\n      \
    \  lastChar = \"+\"\n    case \",\":\n        lastChar = \",\"\n    case \".\"\
    :\n        lastChar = \".\"\n    case \";\":\n        lastChar = \";\"\n    case\
    \ \":\":\n        lastChar = \":\"\n    case \"%\":\n        lastChar = \"%\"\n\
    \    case \"$\":\n        lastChar = \"$\"\n    case \"&\":\n        lastChar\
    \ = \"&\"\n    case \"#\":\n        lastChar = \"#\" // this must be last\n  \
    \  default:\n        lastChar = nil\n    }\n    if lastChar != nil {\n       \
    \ guard let chars = txt.components(separatedBy: lastChar!) else {\n          \
    \  return false\n        }\n        if chars.count > 1 {\n            return true\n\
    \        } else {\n            return false\n        }\n    } else {\n       \
    \ return false\n    }", "    if txt.isEmpty {\n        return false\n    }\n\n\
    \    let str = txt.characters.last\n    return str.isLetter() && str.isNotSeparator()",
  "    if txt.characters.last == \" \" {\n        return false\n    }\n    var last\
    \ = txt.characters.last - 97\n    for c in txt.characters {\n        if c < last\
    \ {\n            return false\n        }\n        last = c - 97\n    }\n    return\
    \ true", "    if !txt.isEmpty {\n        let last_char = txt.characters.last {\n\
    \            return txt[txt.startIndex.advancedBy(-1)] == last_char\n        }\n\
    \        return !is_word_char(last_char)\n    }\n    return false", "    let letter\
    \ = txt.endIndex.advancedBy(-1)\n    if let last_char = txt.substringFromIndex(letter)\
    \ {\n        let range = txt.startIndex.advancedBy(-1)..<letter\n        if txt.rangeOfCharacter(from:\
    \ alphabet, options: .withSurrogates) == nil && txt.rangeOfCharacter(from: wordChars)\
    \ == nil && txt.rangeOfCharacter(from: whitespaces) == nil && txt.rangeOfCharacter(from:\
    \ letter) == nil {\n            return true\n        } else {\n            return\
    \ false\n        }\n    } else {\n        return false\n    }", "    if txt.isEmpty\
    \ {\n        return false\n    }\n    var lastChar = txt.characters.last {\n \
    \       String($0).isLetter\n    }\n    if !lastChar.isLetter {\n        return\
    \ false\n    }\n    var lastLetter = lastChar\n    var i = 0\n    while i < txt.characters.count\
    \ {\n        if txt.characters.index(lastLetter, i) == txt.characters.count -\
    \ 1 {\n            return false\n        }\n        i += 1\n        lastLetter\
    \ = String(txt.characters.index(lastLetter, i))\n    }\n    return true", '    return
    txt.characters.last == txt.characters.last! && txt.characters.last != "_"', " \
    \   // TODO: implement this\n    return false", "    let chars = txt.characters.dropLast()\n\
    \    \n    if let lastChar = chars.last {\n        return lastChar.isLetter &&\
    \ !txt.rangeOfCharacter(from: NSCharacterSet.letters.inverted).contains\n    }\n\
    \    \n    return false", "    // Your code here\n    return !txt.hasSuffix(\"\
    ,.!?\") && txt.hasPrefix(\"a,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,",
  '    return !is_last_char_in_word(txt: txt)', "    guard txt.count > 0 else { return\
    \ false }\n    let lastChar = txt.endIndex\n    let lastCharText = txt.substring(from:\
    \ lastChar)\n    let lastCharTextSplit = lastCharText.components(separatedBy:\
    \ \" \")\n    return lastCharTextSplit.last == nil || lastCharTextSplit.last!.isEmpty\
    \ ?\n        true : lastCharTextSplit.last!.unicodeScalars.last == UnicodeScalar(\"\
    \ \")", "    let strLength = txt.characters.count\n    if strLength == 0 {\n \
    \       return false\n    }\n    return txt.characters.last!.isLetter", "    if\
    \ txt.count == 0 {\n        return false\n    }\n    if txt.count > 1 {\n    \
    \    txt.removeLast()\n    }\n    if txt.last != \" \" {\n        return true\n\
    \    }\n    return false", "    if txt == \"\" {\n        return false\n    }\n\
    \n    // the length of the string must be greater than 1 because we must return\
    \ true only if there are two characters\n    guard txt.count > 1 else { return\
    \ false }\n\n    // if the last character is an alphabetical character and the\
    \ other characters form a word, return false\n    if txt[txt.count - 1].isLetter\
    \ and contains_non_word_chars(txt[txt.count - 1 : txt.count]) {\n        return\
    \ false\n    }\n\n    return true", "    guard let text = txt.unicodeScalars.last?.value\
    \ else {\n        return false\n    }\n    if let lastChar = String(UnicodeScalar(lastChar))\
    \ {\n        guard lastChar.isLetter() else {\n            return false\n    \
    \    }\n        guard text.contains(\" \") else {\n            return false\n\
    \        }\n    }\n    return true", "    let txt = txt\n    if txt.characters.count\
    \ > 1 {\n        let lastChar = txt.characters.last\n        if lastChar == \"\
    \ \" {\n            return false\n        }\n        \n        let lastWord =\
    \ txt.components(separatedBy: \" \")\n            .filter { $0.characters.count\
    \ > 1 }\n            .map { $0.characters.last!}\n        \n        return lastWord\
    \ != nil || lastChar.isAlpha ? true : false\n    }\n    return false", '    return
    txt.endIndex.advancedBy(1).isUppercase()', "    if txt.count < 1 { return false\
    \ }\n    let last = txt.last!\n    let lastChar = last.unicodeScalars.last!.scalarValue\n\
    \    switch lastChar {\n    case UInt8(UnicodeScalar(UInt8(\"a\"))):\n    case\
    \ UInt8(UnicodeScalar(UInt8(\"z\"))):\n    case UInt8(UnicodeScalar(UInt8(\"A\"\
    ))):\n    case UInt8(UnicodeScalar(UInt8(\"Z\"))):\n        return false\n   \
    \ default:\n        return true\n    }", "    return txt.characters.last == txt.characters.last!.lowercased()\
    \ || \n        txt.characters.last == txt.characters.last!.uppercased() ||\n \
    \       txt.characters.last == txt.characters.last!.capitalized()", "    let text\
    \ = txt.characters.last\n    return text == Character(UnicodeScalar(\"a\"))\n\
    \        || text == Character(UnicodeScalar(\"z\"))\n        || text == Character(UnicodeScalar(\"\
    A\"))\n        || text == Character(UnicodeScalar(\"Z\"))\n        || (text ==\
    \ Character(UnicodeScalar(\"0\")) && text.nextUpper == Character(UnicodeScalar(\"\
    0\")))\n        || (text == Character(UnicodeScalar(\"9\")) && text.nextUpper\
    \ == Character(UnicodeScalar(\"0\")))", "    if txt != \"\" {\n        let lastChar\
    \ = txt.characters.last\n        \n        if lastChar == \" \" ||\n         \
    \   (lastChar.unicodeScalars.count > 1 && lastChar.unicodeScalars.last! > 0xD800\
    \ && lastChar.unicodeScalars.last! < 0xE000)\n        {\n            return true\n\
    \        }\n    }\n    \n    return false", "    if txt.count == 0 {\n       \
    \ return false\n    }\n    \n    if let char = txt.characters.last {\n       \
    \ let letter = String(unicodeScalars: UnicodeScalar(UnicodeScalar(char)))\n  \
    \      var stringWithoutLastLetter = txt\n        stringWithoutLastLetter.removeLast()\n\
    \        if let lastLetter = stringWithoutLastLetter.characters.last {\n     \
    \       return letter == String(unicodeScalars: UnicodeScalar(UnicodeScalar(lastLetter)))\n\
    \        }\n    }\n    return false", "    if txt.count < 1 {\n        return\
    \ false\n    }\n\n    if txt.count > 1 {\n        let last = txt[txt.count - 1]\n\
    \        if last == \"a\" || last == \"e\" || last == \"i\" || last == \"o\" ||\
    \ last == \"u\" || last == \"A\" || last == \"E\" || last == \"I\" || last ==\
    \ \"O\" || last == \"U\" {\n            return false\n        }\n    }\n\n   \
    \ return true", "    var word = txt.characters.last\n\n    if txt.characters.count\
    \ > 1 {\n        for char in word.characters.reversed() {\n            let firstChar\
    \ = txt.characters[txt.startIndex]\n            let secondChar = txt.characters[txt.startIndex-1]\n\
    \n            if char == firstChar || char == secondChar{\n                return\
    \ false\n            }\n        }\n    }\n    return true", "    if txt.isEmpty\
    \ {\n        return false\n    }\n\n    if txt.last == nil {\n        return false\n\
    \    }\n\n    let char = txt.last!\n    return char.isUppercase && !is_part_of_a_word(txt.characters.dropLast())",
  "    if txt != \"\" && txt.characters.last != \" \" {\n        return true\n   \
    \ } else {\n        return false\n    }", "    if txt.isEmpty { return false }\n\
    \    let lastChar = txt.characters.last\n    if lastChar.isLetter {\n        return\
    \ false\n    }\n    let lastWord = txt.characters.suffix(txt.characters.count\
    \ - 1).filter({ $0.isLetter })\n    return lastWord.isEmpty", "    guard txt.characters.count\
    \ >= 3 else {\n        return false\n    }\n    let last_char = txt.characters.last!\n\
    \    if let lastChar = String.UnicodeScalarView(last_char) {\n        if lastChar.value\
    \ > 0x41 && (lastChar.value < 0x5A || lastChar.value == 0x61) || lastChar.value\
    \ > 0x6E && lastChar.value < 0x7A {\n            return true\n        }\n    }\n\
    \    return false", "    let stringLength = txt.characters.count\n    if stringLength\
    \ <= 0 {\n        return false\n    }\n    let lastChar = txt.characters.last!\n\
    \    if lastChar.isUppercase || lastChar.isLowercase {\n        return false\n\
    \    }\n    if lastChar.isSpace {\n        return true\n    }\n    return true",
  "    guard txt != \"\" else {\n        return false\n    }\n    let last_char =\
    \ txt.endIndex\n    let first_char = txt.index(last_char - 1, 1)\n    guard let\
    \ first_char_type = first_char?.unicodeScalars else {\n        return false\n\
    \    }\n    let last_char_type = last_char?.unicodeScalars ?? []\n    for char_type\
    \ in first_char_type where char_type.unicodeScalars.isEmpty {\n        if char_type.unicodeScalars.contains(last_char_type)\
    \ {\n            return false\n        }\n    }\n    return true", "    if txt.characters.count\
    \ < 2 {\n        return false\n    }\n    if txt.characters.last != Character(txt.characters.last!)\
    \ {\n        return false\n    }\n    let firstSpace = txt.index(txt.startIndex,\
    \ offsetBy: txt.characters.count - 2)\n    if let firstSpace = firstSpace {\n\
    \        let lastSpace = txt.index(firstSpace, offsetBy: 1)\n        if let lastSpace\
    \ = lastSpace {\n            if let lastChar = txt.substring(from: lastSpace)\
    \ {\n                if let letter = lastChar.unicodeScalars.first {\n       \
    \             if let lastChar = Character(lastChar) {\n                      \
    \  if lastChar.isUppercase || lastChar.isLowercase {\n                       \
    \     return false\n                        }\n                    }\n       \
    \         }\n            }\n        }\n    }\n    return true", "    var isAlpha\
    \ = false\n    let words = txt.components(separatedBy: \" \")\n    for i in 0..<words.count\
    \ {\n        if words[i].rangeOfCharacter(from: CharacterSet.letters) != nil {\n\
    \            isAlpha = true\n            break\n        }\n    }\n    return !isAlpha",
  "    if txt.characters.last == Character(\" \") {\n        return true\n    }\n\
    \    return false", "    let last_char_index = txt.endIndex\n    let last_char_string\
    \ = txt.substring(from: last_char_index)\n    let is_last_char_capitalized = last_char_string.hasSuffix(\"\
    \ \")\n\n    return is_last_char_capitalized && !is_last_char_in_word(txt: txt)",
  "    guard txt.characters.count > 0 else {\n        return false\n    }\n    return\
    \ txt.last!.isAlpha", "    if txt.characters.last == \" \" { return false }\n\
    \    let txtArray = txt.components(separatedBy: \" \")\n    return txtArray.count\
    \ > 1 && txtArray.last!.hasPrefix(txt.characters.last!)", "    if !txt.isEmpty\
    \ {\n        guard let last = txt.last else { return false }\n        if let letter\
    \ = Character(last) {\n            return !txt_contains_space(txt: txt, letter:\
    \ letter)\n        } else {\n            return false\n        }\n    }\n    return\
    \ false", "    let lastCharacter = txt.last?.unicodeScalars.first!\n    let isLastCharAWord\
    \ = txt.unicodeScalars.count > 0\n    return (lastCharacter?.isUppercase) == !isLastCharAWord",
  "    let lastChar = txt.characters.last!\n    return lastChar.isUppercase && !lastChar.isWhitespace\
    \ && lastChar == \" \"", "    if txt.characters.count < 1 {\n        return false\n\
    \    }\n    var last_char = txt.characters.last!\n    if last_char.isUppercase\
    \ {\n        return true\n    }\n    let words = get_word_groups(txt: txt)\n \
    \   if words.contains(last_char) {\n        return false\n    }\n    return true",
  "    let last_char_upper = txt.last!.unicodeScalars.last!.upperBound\n    return\
    \ last_char_upper < txt.count", "    if txt.characters.last != \" \" {\n     \
    \   return txt.characters.last >= \"a\" && txt.characters.last <= \"z\"\n    }\n\
    \    return false", "    if txt.characters.last == nil {\n        return false\n\
    \    }\n    let lastCharacter = txt.characters.last!\n    if lastCharacter < 'a'\
    \ || lastCharacter > 'z' {\n        return false\n    }\n    return !is_part_of_a_word(txt:\
    \ txt.substringToIndex(advance(txt.startIndex, -1)))", "    // Create a list of\
    \ all the chars, including spaces\n    let chars = txt.characters.dropLast()\n\
    \    // Check that all but the last char are letters:\n    return chars.reduce(true)\
    \ { (previous, current) -> Bool in\n        // Skip the space:\n        guard\
    \ current == \" \" else { return false }\n        // Get the last letter:\n  \
    \      guard let lastChar = chars.last else { return false }\n        return lastChar.isLetter\
    \ && !previous\n    }", "    if txt.isEmpty {\n        return false\n    }\n \
    \   var isLastChar = true // in case any word ends with a non-letter char\n  \
    \  for character in txt.characters {\n        guard character.isLetter,\n    \
    \        character.isDigit == false,\n            character.isPunctuation == false\
    \ else {\n                // The character is not letter, digit, or punctuation\n\
    \                return false\n        }\n        if character.isLetter {\n  \
    \          isLastChar = false\n        } else {\n            isLastChar = true\n\
    \        }\n    }\n    return isLastChar", "    if txt.isEmpty { return false\
    \ }\n    let last_char = txt.characters.last ?? \"\"\n    if last_char == \" \"\
    { return false }\n    if last_char.isLetter { return true }\n    if last_char.isPunctuation\
    \ { return false }\n    return true", "    var letters = Set<Character>()\n  \
    \  letters.insert(txt.characters.last!)\n\n    if letters.count == 0 {\n     \
    \   return false\n    }\n\n    // if the last char is letter and it's not in the\
    \ middle of a word\n    if let lastChar = txt.characters.last {\n        let lastCharIsLetter\
    \ = lastChar >= \"a\" && lastChar <= \"z\"\n        let lastCharIsNotInWord =\
    \ letters.contains(lastChar)\n        return lastCharIsLetter && !lastCharIsNotInWord\n\
    \    }\n\n    return false", "    let words = [\" \", \"\\\"\", \"\\'\", \"!\"\
    , \"?\", \"\"]\n    let index = txt.characters.count - 1\n    let lastChar = txt.characters[index]\n\
    \    return !words.contains(String(lastChar))", "    if txt.isEmpty { return false\
    \ }\n    if let lastChar = txt.last {\n        if lastChar.isLetterOrDigit() {\n\
    \            return false\n        }\n    }\n    return true", "    let last_char\
    \ = txt.characters.last!\n    switch last_char {\n    case \" \", \"\\t\", \"\\\
    n\", \"\\r\", \"\\f\", \"\\v\", \"\\u00A0\", \",\":\n        return false\n  \
    \  default:\n        return true\n    }", "    let count = txt.characters.count\n\
    \    return count > 0 && txt.characters.last!.isLetter", '    return txt.characters.last
    == txt.characters.last.unicodeScalars.last!.value - 32', '    return is_last_char_in_alphabetic(txt.characters.last!,
    txt)', '    return txt.last == txt[txt.count - 1]', "    let lastCharacter = txt.last\n\
    \    if lastCharacter.isEmpty {\n        return false\n    }\n    let lastLetter\
    \ = lastCharacter.unicodeScalars.first!\n    let isLastLetterOfWord = lastLetter\
    \ != UnicodeScalar(32) && lastLetter != UnicodeScalar(126)\n    return !isLastLetterOfWord",
  "    let len: Int = txt.characters.count\n\n    if len == 0 {\n        return false\n\
    \    }\n\n    return txt[len - 1].isAlpha && !txt[len - 2].isAlpha", "    if txt.characters.last\
    \ == \" \" {\n        return false\n    }\n    \n    let chars = txt.characters\n\
    \    \n    if chars.last == \" \" || chars.last == \"\\n\" {\n        return false\n\
    \    }\n    \n    if chars.last >= 'A' && chars.last <= 'Z' {\n        return\
    \ false\n    }\n    \n    return true", "    let arr = txt.characters.split{$0\
    \ == \" \"}.map(String.init)\n    if arr.count > 0 {\n        if arr[arr.count\
    \ - 1].isLetter == false {\n            return false\n        }\n    }\n    return\
    \ true", '    return check_last_char_is_a_letter(txt, "")', "    let lastChar\
    \ = txt.characters.last\n    return lastChar.isAlpha\n        && !check_if_last_char_is_a_word(txt:\
    \ txt)", "    if txt.characters.count < 2 { return false }\n    let char = txt.characters.last\
    \ ?? \"\"\n    let isLetter = Character.isLetter(char)\n    let isNotWord = txt\
    \ != txt.trimmingCharacters(in: .whitespacesAndNewlines)\n    return isLetter\
    \ && !isNotWord", "    return txt.characters.last != ' ' && txt.characters.last\
    \ != '\\n'", '    return txt.last!.isAlpha', "    if txt.count == 0 {\n      \
    \  return false\n    }\n\n    if txt.last!.isLetter || txt.last!.isPunctuation()\
    \ {\n        return false\n    }\n\n    return true", "    // get last character\
    \ of txt\n    let last_char = txt.characters[txt.endIndex - 1]\n    if last_char\
    \ == Character(\" \") {\n        return true\n    } else if last_char.isLetter()\
    \ {\n        return false\n    } else {\n        return true\n    }", "    let\
    \ lastChar = txt.characters.last!\n    return lastChar.isLetter", "    if txt.isEmpty\
    \ {\n        return false\n    }\n\n    // Loop through the text\n    var lastChar\
    \ = \"\"\n    for charIter in txt.characters {\n        lastChar = String(charIter)\n\
    \        // Check if the character is an alphabetical letter\n        if lastChar.isLetterOrDigit()\
    \ && !lastChar.isLetterOrDigit(with: .middle) {\n            return false\n  \
    \      }\n    }\n    return true", "    if let word = (txt as NSString).rangeOfCharacter(from:\
    \ CharacterSet.letters)?.upperBound,\n       let length = (txt as NSString).length\
    \ {\n        return length >= word && length <= (txt.index(txt.startIndex, offsetBy:\
    \ word) + word.count - 1)\n    } else {\n        return false\n    }", "    let\
    \ char = txt[txt.index(txt.endIndex, offsetBy: -1)]\n    return ((char >= 'a'\
    \ && char <= 'z') || (char >= 'A' && char <= 'Z'))", '    return !is_last_char_in_a_word(txt,
    true, true)', "    return txt.count > 0 &&\n        txt.characters.last == txt.characters.last!\
    \ &&\n        !is_word_in_text(txt: txt)", "    let words = txt.components(separatedBy:\
    \ \" \")\n    return words.last == txt.characters.last && !(words.last == \" \"\
    \ || words.last == \"\")", "    if txt.characters.last == \" \" {\n        return\
    \ false\n    }\n    let chars = txt.characters\n    let lastChar = chars.last!\n\
    \    if let _ = lastChar.unicodeScalars.filter({ $0.isLetter }).first {\n    \
    \    return true\n    }\n    return false", "    if txt.count == 0 {\n       \
    \ return false\n    }\n    return txt[txt.count - 1].unicodeScalars.isLetter",
  "    if let lastChar = txt.characters.last {\n        if lastChar.isAlphabetic()\
    \ {\n            return !txt.hasLastChar()\n        }\n    }\n    return false",
  "    return txt.characters.last >= Character.UnicodeBlock.Letter &&\n        txt.characters.last\
    \ != Character.UnicodeBlock.LetterOrDigit", "    let word = txt.characters.split\
    \ { $0 == \" \" }.map(String.init)\n    return word.reduce(true) { result, word\
    \ in\n        if word.last == txt.characters.last {\n            return true\n\
    \        } else {\n            return false\n        }\n    }", "    var isLastCharALetter:\
    \ Bool = true\n    if txt.count > 0 {\n        if txt[txt.count - 1].lowercaseString.isEmpty\
    \ {\n            isLastCharALetter = false\n        }\n    }\n    return isLastCharALetter",
  '  return !check_if_last_char_is_a_letter_or_blank(txt)', "    if let letter = txt.characters.last\
    \ {\n        if letter <= 0x40 {\n            if let start = txt.rangeOfCharacter(from:\
    \ CharacterSet.letters) {\n                return start.isStart\n            }\n\
    \        }\n        return false\n    }\n    return false", "    if txt.count\
    \ < 2 { return false }\n    let txtAsString = txt.lowercaseString\n    var lastChar\
    \ = txtAsString.last\n    let isLetter = Character.isLetter(lastChar)\n    let\
    \ containsWord = txtAsString.range(of: \" \").length > 0\n    return !isLetter\
    \ && !containsWord", "    if txt == \"\" {\n        return false\n    }\n    \n\
    \    let chars = txt.characters\n    if chars.count < 1 {\n        return false\n\
    \    }\n    \n    let lastChar = chars.last!\n    \n    return !wordIsLastChar(lastChar)",
  "    guard let len = txt.utf16.count else {\n        return false\n    }\n    if\
    \ txt.utf16[len-1] > unicodeScalars.count-1 {\n        return false\n    }\n \
    \   if txt.utf16[len-1] < unicodeScalars.count {\n        return true\n    }\n\
    \    for (_, char) in unicodeScalars.enumerated() {\n        if txt.utf16[len-1]\
    \ == char {\n            return false\n        }\n    }\n    return true", '    return
    txt.last!.isAlpha', "    var letter = txt.characters.last\n    var inWord = false\n\
    \    for word in txt_words.characters.split(separator: \" \").reversed() {\n \
    \       if letter.isUppercase {\n            letter = word.characters.last\n \
    \           inWord = true\n            break\n        } else {\n            if\
    \ inWord {\n                letter = word.characters.last\n                break\n\
    \            } else {\n                inWord = false\n            }\n       \
    \ }\n    }\n    return !letter.isLetter", "    if txt.isEmpty {\n        return\
    \ false\n    }\n\n    let lastChar = txt.characters.last!\n\n    // Check if last\
    \ character is a letter\n    return lastChar >= \"a\" && lastChar <= \"z\"", " \
    \   let txt = txt.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    return txt.characters.last == txt.characters.last!.lowercased()", "    if\
    \ txt.isEmpty {\n        return false\n    }\n    var last_char: Character\n \
    \   if txt.endIndex < txt.startIndex {\n        last_char = txt[txt.startIndex]\n\
    \    } else {\n        last_char = txt[txt.endIndex]\n    }\n    return last_char.isLetter",
  "  let word = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".components(separatedBy:\
    \ \" \")\n  let lastChar = txt.characters[txt.endIndex]\n  guard lastChar.utf16Count\
    \ > 0 else {\n    return false\n  }\n  return word.contains(lastChar)", "    let\
    \ lastChar = txt.characters.last\n    let lastCharAsString = String(lastChar)\n\
    \    if lastCharAsString.isLetter == true && lastCharAsString.isPunct == false\
    \ {\n        return true\n    } else {\n        return false\n    }", "    guard\
    \ let s = txt,\n        let lastChar = s.characters.last else { return false }\n\
    \    \n    let wordCharactersArray = s.characters.split(separator: \" \")\n  \
    \  return !wordCharactersArray.contains(where: { $0.isLetter }) && lastChar !=\
    \ \"\"", '    return txt.characters.last != nil && txt.characters.last!.isAlphabetic
    && txt.characters.count >= 2', '    return (txt.characters.last == " ") && (!is_part_of_a_word(txt))',
  "    if txt.count < 1 { return false }\n    let char = txt[txt.count - 1]\n    if\
    \ char.isLetterOrDigit() {\n        return true\n    }\n    for word in txt.split(separator:\
    \ \" \") {\n        if word.hasPrefix(char) {\n            return false\n    \
    \    }\n    }\n    return true", "    let words = [\"apple\", \"pie\"]\n    for\
    \ word in words {\n        if txt.last == word[word.startIndex] {\n          \
    \  return false\n        }\n    }\n    return true", "    if txt.characters.last\
    \ == nil {\n        return false\n    }\n    let _ = txt.characters.last as! Character\n\
    \    return is_a_letter(txt.characters.last!)", "    if txt.isEmpty {\n      \
    \  return false\n    }\n    let length = txt.characters.count\n    if length ==\
    \ 1 {\n        return true\n    }\n    var lastChar = txt[length - 1]\n    let\
    \ lastCharIsAlphabet = lastChar.isAlphabetic\n    if lastCharIsAlphabet {\n  \
    \      return !firstCharInWord(txt: txt)\n    } else {\n        return true\n\
    \    }", "    if txt.isEmpty { return false }\n    let txtArr = txt.characters.split(separator:\
    \ \" \").map { String($0) }\n    let firstChar = txtArr.last!\n    if firstChar.isLetter\n\
    \    && !(txtArr.first!.starts(with: firstChar)\n        && txtArr.last!.ends(with:\
    \ firstChar)) {\n        return true\n    }\n    return false", "    let str =\
    \ txt\n    let index = str.endIndex\n    defer { index = str.startIndex }\n  \
    \  return str.characters[str.endIndex - 1].isAlphabetic && !str.characters[str.endIndex\
    \ - 1].isWhitespace", "    var txtLen = txt.characters.count\n    if (txtLen <=\
    \ 1) return false\n\n    let lastChar = txt[txtLen-1]\n\n    return lastChar.isAlpha\
    \ && ! lastChar.isWordSeparator", "    guard let lastChar = txt.characters.last\
    \ else { return false }\n    return lastChar.isLetter", "    if txt.isEmpty {\
    \ return false }\n    let lastChar = txt.last!\n    if lastChar.isLetterASCII\
    \ {\n        let isNotWord = txt.rangeOfCharacter(from: NSCharacterSet.letters.inverted)\
    \ == nil\n        return !isNotWord\n    } else {\n        return false\n    }",
  "    let endIndex = self.txt.endIndex\n    return endIndex.distance > 0 && !self.txt.substring(to:\
    \ endIndex).hasSuffix(\" \")", "    if txt.isEmpty {\n        return false\n \
    \   }\n    let lastChar = txt.suffix(1)\n    if lastChar.isEmpty {\n        return\
    \ false\n    }\n    if lastChar.rangeOfCharacter(from: CharacterSet.letters) ==\
    \ nil {\n        return false\n    }\n    if let lastCharIsAWord = lastChar.rangeOfCharacter(from:\
    \ CharacterSet.letters.inverted) == nil {\n        return false\n    }\n    return\
    \ true", "    if txt.characters.last != nil && txt.characters.last != \"\" {\n\
    \        if let char = txt.characters.last {\n            let chars = String(char).unicodeScalars\n\
    \            return chars.filter({ $0.isASCII}).count > 0\n        }\n    }\n\
    \    return false", "    if txt.count < 1 {\n        return false\n    }\n   \
    \ \n    if let _ = txt.characters.last?.unicodeScalars.first {\n        return\
    \ false\n    }\n    \n    let split = txt.components(separatedBy: \" \")\n   \
    \ \n    return split[split.count-1].isLetter", "    if txt.isEmpty {\n       \
    \ return false\n    }\n    let lastChar = txt.characters.last!\n    if lastChar.isLetter\
    \ {\n        return false\n    }\n    if txt.last?.rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil {\n        return false\n    }\n    return true", "    if !txt.isEmpty\
    \ {\n        let lastChar = txt.characters.last\n        return lastChar.isUppercase\
    \ && !txt.hasSuffix(\" \")\n    } else {\n        return false\n    }", "    if\
    \ txt.isEmpty { return false }\n    let lastChar = txt.characters.last ?? \"\"\
    \n    return lastChar.isAlpha", "    return txt.characters.last != \" \" &&\n\
    \        (txt.characters.last != \"a\" &&\n        txt.characters.last != \"e\"\
    \ &&\n        txt.characters.last != \"i\" &&\n        txt.characters.last !=\
    \ \"o\" &&\n        txt.characters.last != \"u\")", "    let characters = txt.characters\n\
    \    let last = characters.last\n    return (last != \" \" && last.isLetter)",
  "    guard let char = txt.characters.last else { return false }\n    let word =\
    \ txt.componentsSeparatedByString(\" \")\n    return char.isLetter && !word.isEmpty\
    \ && word.last!.rangeOfString(char) == nil", "    let regex = try! NSRegularExpression(pattern:\
    \ \"[a-zA-Z]$\", options: .caseInsensitive)\n    return regex.firstMatch(in: txt,\
    \ range: NSRange(txt.utf16.startIndex..., in: txt)) != nil", "    let lastChar\
    \ = txt.last!\n    return (lastChar.isLetter) && (!check_if_last_char_is_a_word(txt:\
    \ txt))", "    let words = txt.split(separator: \" \")\n    guard let lastChar\
    \ = words.last else { return false }\n    return lastChar.isAlpha", '    return
    txt.characters.last == txt.characters.first', "    if !txt.endsWith(\" \") ||\
    \ !txt.hasSuffix(\"e\") {\n        return true\n    }\n    let lastChar = txt.suffix(from:\
    \ txt.index(txt.endIndex, offsetBy: -1))\n    return lastChar.hasPrefix(CharacterSet.letters.inverted)",
  "    if txt.characters.last == \" \" {\n        return false\n    }\n    \n    if\
    \ let range = Range(start: (txt.endIndex-1), end: (txt.endIndex)) {\n        if\
    \ let char = txt.character(at: range) {\n            return Character.isLetter(char)\n\
    \        }\n    }\n    return false", "    if txt == \"\" {\n        return false\n\
    \    }\n    let text = txt.characters.reversed\n    let lastChar = text.last\n\
    \    let lastCharIsLetter = lastChar == Character(\" \")\n    let lastCharIsNotWord\
    \ = lastChar.lowercaseString != Character(\" \")\n    return !lastCharIsLetter\
    \ && !lastCharIsNotWord", '  return txt.characters.last == Character(txt.characters.last!)',
  "    guard txt.count > 0 else {\n        return false\n    }\n    if txt.endIndex\
    \ == txt.startIndex {\n        return false\n    }\n    let letter = String(txt.characters[txt.endIndex\
    \ - 1])\n    let index = txt.index(txt.endIndex, offsetBy: -1)\n    let text =\
    \ String(txt[..<index])\n    return !text.hasPrefix(letter)", "    return !txt.hasSuffix(\"\
    \ \")\n        && txt.last!.isAlpha\n        && !txt.hasPrefix(\"_\")", "    if\
    \ txt.count < 1 || txt.count > 30 { return false }\n    if let chars = txt.unicodeScalars.filter({\
    \ $0.isLetter() }).sorted(by: { $0.value > $1.value }) {\n        let lastChar\
    \ = chars.last!\n        return !chars.filter( { $0 == lastChar } ).contains(where:\
    \ { $0.isLetter() == false })\n    } else {\n        return false\n    }", " \
    \ if txt.characters.last != \" \" {\n    return txt.characters.last >= \"a\" &&\
    \ txt.characters.last <= \"z\"\n  }\n  return false", "    var txtAsArray = [String]()\n\
    \    for each in txt {\n        txtAsArray.append(each)\n    }\n    if txtAsArray.last\
    \ == \" \" {\n        return false\n    }\n    if txtAsArray.last != \"a\" &&\
    \ txtAsArray.last != \"e\" && txtAsArray.last != \"i\" && txtAsArray.last != \"\
    o\" && txtAsArray.last != \"u\" {\n        return false\n    }\n    return true",
  '    return txt.rangeOfCharacter(from: NSCharacterSet.letters.inverted) != nil',
  "    return txt.last == ' ' || is_letter(txt.last)", "    if let _ = txt.endIndex.advancedBy(-1),\
    \ let _ = txt.characters.last {\n        return !txt.characters[txt.endIndex.predecessor()].isLetter()\n\
    \    } else {\n        return false\n    }", "    if txt.count > 0 { // if txt\
    \ is empty\n        let lastChar = txt.last // get the last character\n      \
    \  return lastChar.isLetter() && !txt.contains(\"words\")\n    } else {\n    \
    \    return false\n    }", "    let lastChar = txt.last\n    let isLetter = lastChar.isLetter\n\
    \    let isNotWord = lastChar.isNotWord\n\n    return isLetter && !isNotWord",
  "    let letters = \"abcdefghijklmnopqrstuvwxyz\"\n    let letter = txt.characters(using:\
    \ String.Encoding.utf8)\n    return letters.last?.isEmpty ?? false &&\n      \
    \  !txt.contains(where: {$0 == \" \" || $0 == letters.last}) ?? false", "    if\
    \ txt.isEmpty {\n        return false\n    }\n    return txt[txt.endIndex-1].isAlpha\
    \ && !contains_word(txt, txt.endIndex-1)", "    let last = txt.characters.last\
    \ ?? \"\"\n    let lastChar = Character(last)\n    let lowerCaseLastChar = lastChar.lowercased()\n\
    \    let isFirst = lowerCaseLastChar.isFirst\n    let isLetterOrDigit = lowerCaseLastChar.isLetterOrDigit\n\
    \    return !isFirst\n        && !isLetterOrDigit\n        && !Character.isWhitespace(last)",
  "    let lastChar = txt.characters.last ?? \"\"\n    if lastChar.isEmpty {\n   \
    \     return false\n    }\n    return lastChar.unicodeScalars.filter {\n     \
    \   return $0.value > CharacterSet.alphanumerics.first!.value\n    }.isEmpty ?\
    \ true : false", "    // Your code here\n    if txt.count != 0 {\n        let\
    \ lastChar = txt.last!\n        let isLetter = Character.isLetter(lastChar)\n\
    \        let isNotWord = lastChar != \" \"\n        return !isLetter && !isNotWord\n\
    \    }\n    return false", "    if txt.isEmpty {\n        return false\n    }\n\
    \n    let lastChar = txt[txt.endIndex]\n    if let c = lastChar {\n        if\
    \ isAlphabet(c) && !isInWord(txt, lastChar) {\n            return true\n     \
    \   }\n    }\n\n    return false", "    guard txt.count > 0 else { return false\
    \ }\n    let last_char = txt.last\n    let first_letter = txt.first\n    \n  \
    \  return last_char && !is_a_word_first_letter(first_letter) && is_a_word_last_letter(last_char)",
  "  if txt.count == 0 {\n    return false\n  }\n  let lastChar = txt.last\n  guard\
    \ lastChar.unicodeScalars.count > 0 else {\n    return false\n  }\n  return lastChar.unicodeScalars.last!.isLetter",
  "    if txt.count < 2 {\n        return false\n    }\n\n    let char = txt.character(at:\
    \ txt.endIndex-1)\n    if Char.isAlphaNumeric(unicodeScalar: char) {\n       \
    \ return !is_word_start(txt)\n    }\n\n    return false", "    let word: String\
    \ = \"a b c d e f g h i j k l m n o p q r s t u v w x y z\".split(separator: \"\
    \ \")\n    let word_upper = word.map(String.init)\n    \n    for i in (0..<word.count).reversed()\
    \ {\n        if let c = word_upper[i][1], let _ = txt.index(before: c) {\n   \
    \         return false\n        }\n    }\n    \n    return true", '  return txt.characters.last
    == txt && !txt.hasSuffix(" ")', "    let result = txt.characters.last == txt.characters.last!.uppercased()\
    \ &&\n                 txt.characters.last != \" \" &&\n                 !txt.characters.last!.isLetter\n\
    \    return result", '    return txt[txt.endIndex].isLetter && !check_if_last_char_is_a_word(txt)',
  '    return txt != nil && txt.characters.last == Character(Character.uppercaseAlphabet)',
  '    return check_if_last_char_is_a_letter_in_str(txt, "")', "    // Your code goes\
    \ here\n    if let first = txt.characters.last {\n        let alphabet = CharacterSet(charactersIn:\
    \ \"abcdefghijklmnopqrstuvwxyz\")\n        let wordRange = txt.range(of: \" \"\
    )\n        \n        guard wordRange?.lowerBound == first else {\n           \
    \ return false\n        }\n        \n        return !alphabet.isSubset(of: String(txt[wordRange?.lowerBound..<first]))\n\
    \    }\n    return false", "    guard let lastChar = txt.characters.last else\
    \ {\n        return false\n    }\n    let isLetter = CharacterSet(charactersIn:\
    \ \"abcdefghijklmnopqrstuvwxyz\").contains(lastChar)\n    let isNotWord = CharacterSet(charactersIn:\
    \ \"aA!@#%^&*()_-+={}[];:.,<>/?\").isSupersetOf(CharacterSet(charactersIn: txt))\n\
    \    return !isLetter && !isNotWord", "    if let txt = txt {\n        let chars\
    \ = txt.characters.split{$0 == \" \"}\n        let lastChar = chars.last\n   \
    \     return lastChar.rangeOfCharacter(from: NSCharacterSet.letters.inverted)\
    \ == nil\n    }\n    return false", "    if txt.count == 0 {\n        return false\n\
    \    }\n\n    let first = txt.characters.first ?? \"\"\n    guard let last = txt.characters.last\
    \ else { return false }\n\n    return last.hasPrefix(first) && last.isAlphaNumeric",
  "    let splits = txt.characters.split(separator: \" \")\n    let last = splits.last!\n\
    \    guard last.isLetterOrDigit() else { return false }\n    for char in splits.dropLast()\
    \ {\n        if char.isLetterOrDigit() { return false }\n    }\n    return true",
  "    let trimmed = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n    return\
    \ trimmed.last == txt.last", "    let lastChar = txt.characters.last ?? \"\"\n\
    \    return lastChar.isLetter()", '    return txt.utf16Count().isMultiple(of:
    Character.UnicodeScalarUnit.letters) && !txt.hasSuffix(" ")', "    if txt.isEmpty\
    \ {\n        return false\n    }\n    let lastChar = txt.last!\n    if lastChar.isUppercase\
    \ {\n        return false\n    }\n    return lastChar.isLetter", "    let lastCharacter\
    \ = txt.characters.last\n    let lastCharIsLetter = (lastCharacter?.unicodeScalars.count\
    \ ?? 0) == 1 && lastCharacter!.isLetter\n    let isLastCharNotInWord = lastCharacter?.unicodeScalars.contains(\"\
    _\") ?? false\n    return !isLastCharNotInWord", "    let lastChar = txt.last!\n\
    \    let firstLetter = String(txt.prefix(upTo: txt.count - 1))\n    return lastChar.isLetter\n\
    \        && !firstLetter.isWord", "    let last_char = txt.last\n    return last_char.isAlpha\
    \ && !last_char.isDigit", "    let regex = try! NSRegularExpression(pattern: \"\
    \\\\w\")\n    return regex.firstMatch(in: txt, range: NSMakeRange(0, txt.count)).range!.location\
    \ != txt.count - 1", "    if txt.isEmpty {\n        return false\n    }\n    let\
    \ lastChar = txt.last!\n    if lastChar.isLetter() {\n        return false\n \
    \   }\n    if !is_word_first_char(txt: txt.dropLast()) {\n        return true\n\
    \    }\n    return false", '    return txt.rangeOfCharacter(from: NSCharacterSet.letters.inverted)
    != nil', "    if txt.count > 0 && txt[txt.count - 1] == \" \" {\n        return\
    \ false\n    }\n    if txt.count == 0 {\n        return false\n    }\n    if txt.count\
    \ > 1 && txt[txt.count - 2] == \" \" && txt[txt.count - 1] != \" \" {\n      \
    \  return false\n    }\n    if txt.count > 0 && txt[txt.count - 1] == \" \" {\n\
    \        return false\n    }\n    return true", "    if txt.characters.count ==\
    \ 0 {\n        return false\n    }\n    let lastChar = txt.characters.last ??\
    \ \"\"\n    if lastChar.isLetter == false || lastChar.isWhitespace {\n       \
    \ return false\n    }\n    return true", "    let word_start_index = txt.range(of:\
    \ \" \", options: .backwards)?.upperBound\n    let word_end_index = txt.index(txt.endIndex,\
    \ offsetBy: -word_start_index)\n    let last_char = txt[word_end_index]\n\n  \
    \  return (last_char.isAlphabetic && !txt.contains(\" \")) || !txt.isEmpty", " \
    \   let last_char = txt.characters.last\n    let is_non_word_char = (last_char.unicodeScalars.filter\
    \ { $0 != .Word }).isEmpty\n    let is_alpha = (last_char.unicodeScalars.filter\
    \ { $0 != .Letter }).isEmpty\n    return !is_non_word_char && !is_alpha", "  \
    \  if txt.isEmpty {\n        return false\n    }\n    let lastChar = txt.characters[txt.characters.count\
    \ - 1]\n    return lastChar.unicodeScalars.filter({ $0.isLetter }).count == 0\
    \ && lastChar.isLetter", '    return txt[txt.count - 1].isAlphabetic.notWord ?
    true : false', "    if txt.isEmpty { return false }\n    var lastChar = txt.characters.last\
    \ // Last character of the string\n    if lastChar.isLetter == false { // Last\
    \ character is not a letter\n        return false\n    }\n    // Last character\
    \ is letter\n    // Check that the last character is not a part of a word\n  \
    \  let words = txt.components(separatedBy: \" \")\n    if words.last == lastChar\
    \ { // Last character is part of a word\n        return false\n    }\n    return\
    \ true", "    guard !txt.isEmpty else { return false }\n    let lastChar = txt.last!\n\
    \    let isLetter = lastChar.rangeOfCharacter(from: NSCharacterSet.letters) !=\
    \ nil\n    return !isLetter", "    if txt.isEmpty {\n        return false\n  \
    \  }\n    let lastChar = txt.characters.last!\n    let lastCharAsStr = String(lastChar)\n\
    \    let words = txt.split(separator: \" \")\n    for word in words {\n      \
    \  if lastCharAsStr.contains(word) {\n            return false\n        }\n  \
    \  }\n    return true", "    guard let lastChar = txt.characters.last else { return\
    \ false }\n    let lastChar = String.fromCharCode(lastChar)\n\n    // check if\
    \ last char is a letter\n    if lastChar.rangeOfCharacter(from: NSCharacterSet.letters)\
    \ != nil {\n        return false\n    }\n\n    // check if last char is part of\
    \ word\n    let word: String = txt.characters.dropLast()\n    for char in word\
    \ {\n        let unicodeScalar = String.UnicodeScalarView(char).value\n      \
    \  if unicodeScalar == lastChar {\n            return false\n        }\n    }\n\
    \n    return true", "    // Your code here\n    \n    let isLastCharIsLetter =\
    \ txt.characters.last == \" \" // or maybe !txt.characters.last.isEmpty ?\n  \
    \  let isLastCharIsWord = txt.characters.last == \"a\"\n    return isLastCharIsLetter\
    \ && !isLastCharIsWord ", "    let txt2 = txt.characters.last\n\n    if txt2 ==\
    \ nil {\n        return false\n    }\n\n    let char = txt2 as NSString\n    if\
    \ let lastChar = char.character(at: char.index(char.endIndex, offsetBy: -1)) {\n\
    \        return lastChar != NSCharacterSet.letters.inverted\n    }\n\n    return\
    \ false", "    if txt.isEmpty {\n        return false\n    }\n\n    let lastCharacter\
    \ = txt.characters.last\n\n    if lastCharacter.isEmpty {\n        return false\n\
    \    }\n\n    if lastCharacter.isLetter {\n        return true\n    }\n\n    //\
    \ if last character is space or punctuation\n    if lastCharacter == \" \" {\n\
    \        return false\n    }\n\n    if lastCharacter == \",\" {\n        return\
    \ false\n    }\n\n    return true", "    if txt.characters.last == nil {\n   \
    \     return false\n    }\n    return !is_word_char_in_a_str(txt: txt, last_char:\
    \ txt.characters.last!)", "    if txt.last == nil {\n        return false\n  \
    \  }\n    if txt.last!.isLetter == false {\n        return false\n    }\n    return\
    \ true", "    if txt == \"\" {\n        return false\n    }\n    if txt[txt.endIndex\
    \ - 1].isWhitespace {\n        return false\n    }\n    if txt[txt.endIndex -\
    \ 1].isLetter {\n        return false\n    }\n    return true", "    guard !txt.isEmpty\
    \ else {\n        return false\n    }\n    let lastChar = txt.last!\n    let lastCharIsLetter\
    \ = lastChar.isLetter\n    let lastCharIsNotPartOfWord = lastChar.characters.last\
    \ != nil && !lastChar.characters.last!.isLetter\n    return lastCharIsLetter &&\
    \ !lastCharIsNotPartOfWord", "    if txt.isEmpty {\n        return false\n   \
    \ }\n    let lastChar = txt.characters.last!\n    return lastChar.isAlpha", " \
    \   if txt.isEmpty { return false }\n    if txt.count == 1 { return true }\n \
    \   let lastChar = txt.last!\n    if lastChar.isAlphabetic() {\n        return\
    \ !lastChar.isLetter() && !lastChar.isSpace()\n    }\n    return false", "   \
    \ if txt.characters.count <= 0 {\n        return false\n    }\n    if let last\
    \ = txt.characters.last {\n        var lastCharIsLetter = false\n        var lastCharIsWord\
    \ = false\n        for char in txt {\n            if char == last {\n        \
    \        lastCharIsLetter = true\n            }\n            if char.isWhitespace\
    \ {\n                lastCharIsWord = true\n            }\n        }\n       \
    \ return lastCharIsLetter && !lastCharIsWord\n    }\n    return false", "    var\
    \ txts = txt.componentsSeparatedByString(\" \")\n    if txts.count < 2 {\n   \
    \     return false\n    }\n    let last = txts[txts.count - 2]\n    return last.rangeOfCharacter(from:\
    \ NSCharacterSet.letters) != nil && !(last.rangeOfCharacter(from: NSCharacterSet.letters.inverted)\
    \ != nil)", "  if txt.characters.last == \" \" { return true }\n  return txt.characters.last\
    \ >= 'a' && txt.characters.last <= 'z'", "    let textLength = txt.characters.count\n\
    \    let lastCharIndex = textLength - 1 // last character index\n    if lastCharIndex\
    \ > 0 && txt.characters.last == txt.characters.first! { // checking for the last\
    \ character to be a space\n        let firstWordIndex = txt.rangeOfString(\" \"\
    ).startIndex\n        let lastWordIndex = txt.rangeOfString(\" \", options: .backwards).endIndex\n\
    \        let lastWord = txt.substringWithRange(Range(start: firstWordIndex, end:\
    \ lastWordIndex))\n        if lastWord.characters.last == lastWord.characters.first!\
    \ {\n            return true\n        }\n    }\n    return false", "    if txt.count\
    \ < 1 || txt.count == 0 { return false }\n    return txt[txt.count - 1].hasPrefix(CharacterSet.letters)\
    \ == false", "    var text = txt\n    text = text.removeLast()\n    if let lastChar\
    \ = text.last {\n        let lastCharString = text.substring(from: text.index(text.startIndex,\
    \ offsetBy: -1)).lowercased()\n        return !lastChar.isUppercase() && !lastCharString.contains(\"\
    \ \")\n    } else {\n        return false\n    }", '    return txt.characters.last
    == " " || isAlpha(txt.characters.last)', "    if txt.isEmpty { return false }\n\
    \    let lastChar = txt.characters.last!\n    return lastChar.isAlphabetic &&\
    \ !is_in_word(lastChar, txt)", "    let lastChar = txt.characters.last!\n    return\
    \ !contains(words: lastChar)"]
stop_tokens:
- "\n}"
