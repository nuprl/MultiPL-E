language: swift
name: HumanEval_20_find_closest_elements
results:
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // sort numbers from smallest to largest\n\
    \    let sortedNumbers = numbers.sorted()\n\n    // iterate from sorted numbers\
    \ to find the first number greater than the number passed in\n    var currentMinNumber\
    \ = sortedNumbers[0]\n\n    // set variable to the index of the next number greater\
    \ than the number passed in (as long as the numbers are sorted)\n    var currentMaxIndex\
    \ = 0\n\n    // set variable to the number passed in so that we can check if a\
    \ number passed in is greater than the smallest number in the array\n    var currentMaxNumber\
    \ = numbers[0]\n\n    for index in sortedNumbers.indices {\n        if numbers[index]\
    \ > currentMaxNumber {\n            currentMaxNumber = numbers[index]\n      \
    \      currentMaxIndex = index\n        }\n    }\n\n    // return the two numbers\
    \ that are closest to each other\n    return (sortedNumbers[currentMaxIndex],\
    \ sortedNumbers[currentMaxIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpeefp6wjd/tmpeefp6wjd.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86c181ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86c1515b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86c1515988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86c15147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeefp6wjd                        0x000055fe6a3476fe <unavailable> + 5886

    5    libc.so.6                          0x00002b86c1a0a460 __libc_start_main +
    245

    6    tmpeefp6wjd                        0x000055fe6a3472b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for n in numbers {\n\
    \        let tmpMin = min1\n        let tmpMax = max1\n        if n < min1 {\n\
    \            min2 = min1\n            min1 = n\n        }\n        if n > max1\
    \ {\n            max2 = max1\n            max1 = n\n        }\n        if tmpMin\
    \ < tmpMax {\n            min2 = min1\n            min1 = n\n        }\n     \
    \   if tmpMin > tmpMax {\n            max2 = max1\n            max1 = n\n    \
    \    }\n    }\n    return (min1, min2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpmm2smaup.swift:17:13: error: cannot assign to value: 'min2' is\
    \ a 'let' constant\n            min2 = min1\n            ^~~~\n/tmp/tmpmm2smaup.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpmm2smaup.swift:18:13: error: cannot assign to value:\
    \ 'min1' is a 'let' constant\n            min1 = n\n            ^~~~\n/tmp/tmpmm2smaup.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpmm2smaup.swift:21:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = max1\n            ^~~~\n/tmp/tmpmm2smaup.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpmm2smaup.swift:22:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = n\n            ^~~~\n/tmp/tmpmm2smaup.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpmm2smaup.swift:25:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = min1\n            ^~~~\n/tmp/tmpmm2smaup.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpmm2smaup.swift:26:13: error: cannot assign to value:\
    \ 'min1' is a 'let' constant\n            min1 = n\n            ^~~~\n/tmp/tmpmm2smaup.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpmm2smaup.swift:29:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = max1\n            ^~~~\n/tmp/tmpmm2smaup.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpmm2smaup.swift:30:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = n\n            ^~~~\n/tmp/tmpmm2smaup.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // TODO: Optimize with SIMD?\n    if numbers.count\
    \ == 0 {\n        return (numbers[0], numbers[0])\n    }\n    guard let low =\
    \ numbers.first,\n        let high = numbers.last else {\n            return (numbers[0],\
    \ numbers[0])\n    }\n    var lowFound = false\n    var highFound = false\n  \
    \  var candidate = low\n\n    for x in numbers {\n        if x != candidate {\n\
    \            let diff = abs(x - candidate)\n            if diff < abs(x - high)\
    \ {\n                candidate = x\n                lowFound = true\n        \
    \    } else if diff < abs(x - low) {\n                candidate = x\n        \
    \        highFound = true\n            }\n        }\n    }\n    return (candidate,\
    \ lowFound ? low : high)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpzq5_bnhf/tmpzq5_bnhf.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b864672fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8646426b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8646426988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86464257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzq5_bnhf                        0x0000561560a8f88e <unavailable> + 6286

    5    libc.so.6                          0x00002b864691b460 __libc_start_main +
    245

    6    tmpzq5_bnhf                        0x0000561560a8f449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // Find the closest two numbers from our\
    \ two numbers.\n    var closest = (numbers[0], numbers[0])\n    var furthest =\
    \ (numbers[0], numbers[0])\n    for i in 1..numbers.count {\n        if numbers[i]\
    \ > closest[1] {\n            closest = (numbers[i], numbers[i])\n        }\n\
    \        if numbers[i] < furthest[1] {\n            furthest = (numbers[i], numbers[i])\n\
    \        }\n    }\n    return (closest[1], furthest[1])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpi_slax41.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n/tmp/tmpi_slax41.swift:20:20: error: cannot access element using\
    \ subscript for tuple type '(Double, Double)'; did you mean to use '.1'?\n   \
    \ return (closest[1], furthest[1])\n                   ^~~\n                 \
    \  .1\n/tmp/tmpi_slax41.swift:20:33: error: cannot access element using subscript\
    \ for tuple type '(Double, Double)'; did you mean to use '.1'?\n    return (closest[1],\
    \ furthest[1])\n                                ^~~\n                        \
    \        .1\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa51509fp.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpa51509fp.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpa51509fp.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpa51509fp.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var minimum = Double()\n    var result\
    \ = Double()\n    numbers.sort { $0 > $1 }\n    for i in 0..<numbers.count {\n\
    \        if i == 0 {\n            result = numbers[i]\n        } else {\n    \
    \        if abs(numbers[i] - result) < abs(minimum - numbers[i]) {\n         \
    \       minimum = numbers[i]\n                result = numbers[i]\n          \
    \  }\n        }\n    }\n    return (result, minimum)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbeezyzru.swift:11:13: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n    numbers.sort { $0 > $1 }\n    ~~~~~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.count < 2 {\n        return\
    \ numbers[0], numbers[0]\n    }\n\n    let first: Double = numbers.sorted()[0]\n\
    \    let last: Double = numbers.sorted().last!\n\n    let firstIndex: Int = numbers.index(of:\
    \ first)!\n    let lastIndex: Int = numbers.index(of: last)!\n    if lastIndex\
    \ < firstIndex {\n        return numbers[firstIndex], numbers[lastIndex]\n   \
    \ }\n\n    let midIndex: Int = firstIndex + (lastIndex - firstIndex) / 2\n\n \
    \   let midElement = numbers[midIndex]\n\n    let closest1 = numbers.sorted()[midIndex\
    \ - 1]\n    let closest2 = numbers.sorted()[midIndex]\n\n    if closest1 < closest2\
    \ {\n        return closest1, midElement\n    } else {\n        return midElement,\
    \ closest2\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpj804q5cx.swift:10:26: error: consecutive statements on a line must\
    \ be separated by ';'\n        return numbers[0], numbers[0]\n               \
    \          ^\n                         ;\n/tmp/tmpj804q5cx.swift:10:26: error:\
    \ expected expression\n        return numbers[0], numbers[0]\n               \
    \          ^\n/tmp/tmpj804q5cx.swift:19:35: error: consecutive statements on a\
    \ line must be separated by ';'\n        return numbers[firstIndex], numbers[lastIndex]\n\
    \                                  ^\n                                  ;\n/tmp/tmpj804q5cx.swift:19:35:\
    \ error: expected expression\n        return numbers[firstIndex], numbers[lastIndex]\n\
    \                                  ^\n/tmp/tmpj804q5cx.swift:30:24: error: consecutive\
    \ statements on a line must be separated by ';'\n        return closest1, midElement\n\
    \                       ^\n                       ;\n/tmp/tmpj804q5cx.swift:30:24:\
    \ error: expected expression\n        return closest1, midElement\n          \
    \             ^\n/tmp/tmpj804q5cx.swift:32:26: error: consecutive statements on\
    \ a line must be separated by ';'\n        return midElement, closest2\n     \
    \                    ^\n                         ;\n/tmp/tmpj804q5cx.swift:32:26:\
    \ error: expected expression\n        return midElement, closest2\n          \
    \               ^\n/tmp/tmpj804q5cx.swift:10:23: error: cannot convert return\
    \ expression of type 'Double' to return type '(Double, Double)'\n        return\
    \ numbers[0], numbers[0]\n               ~~~~~~~^~~\n/tmp/tmpj804q5cx.swift:16:35:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    let firstIndex:\
    \ Int = numbers.index(of: first)!\n                                  ^\n/tmp/tmpj804q5cx.swift:16:35:\
    \ note: use 'firstIndex(of:)' instead\n    let firstIndex: Int = numbers.index(of:\
    \ first)!\n                                  ^~~~~\n                         \
    \         firstIndex\n/tmp/tmpj804q5cx.swift:17:34: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n    let lastIndex: Int = numbers.index(of: last)!\n\
    \                                 ^\n/tmp/tmpj804"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    var smallestIndex = -1\n    var largestIndex = -1\n    for index in 0..<numbers.count\
    \ - 1 {\n        let item = numbers[index]\n        if item < smallest {\n   \
    \         smallest = item\n            smallestIndex = index\n        }\n    \
    \    if item > largest {\n            largest = item\n            largestIndex\
    \ = index\n        }\n    }\n    return (numbers[smallestIndex], numbers[largestIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8aef28bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8aeef82561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8aeef82286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8aeef8213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8aeef81bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8aeed81f44 <unavailable> + 188228

    6    tmpzeicxpz_                        0x000055e6c0570f5b <unavailable> + 8027

    7    tmpzeicxpz_                        0x000055e6c05705cd <unavailable> + 5581

    8    libc.so.6                          0x00002b8aef477460 __libc_start_main +
    245

    9    tmpzeicxpz_                        0x000055e6c0570279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptky2jplv.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptky2jplv.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var closest1 = numbers[0]\n    var closest2\
    \ = numbers[0]\n    for number in numbers {\n        let distance1 = fabs(number\
    \ - closest1)\n        let distance2 = fabs(number - closest2)\n        if distance1\
    \ <= distance2 {\n            closest1 = number\n        }\n        else {\n \
    \           closest2 = number\n        }\n    }\n    return (closest1, closest2)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpt85q0b8x.swift:12:25: error: cannot find 'fabs' in scope\n    \
    \    let distance1 = fabs(number - closest1)\n                        ^~~~\n/tmp/tmpt85q0b8x.swift:13:25:\
    \ error: cannot find 'fabs' in scope\n        let distance2 = fabs(number - closest2)\n\
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.count < 2 {\n        return\
    \ (-1.0, -1.0)\n    }\n\n    let min_num = numbers[0]\n    var closest_nums =\
    \ [Double]()\n    var min_dist = Float.greatestFiniteMagnitude\n\n    for num\
    \ in numbers {\n        var temp_dist = distance(min_num, num)\n        if min_dist\
    \ > temp_dist {\n            min_dist = temp_dist\n            closest_nums =\
    \ [num]\n        } else {\n            closest_nums.append(num)\n        }\n \
    \   }\n\n    return (min_num, min_dist)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp_g9lvgvj.swift:18:25: error: cannot find 'distance' in scope\n\
    \        var temp_dist = distance(min_num, num)\n                        ^~~~~~~~\n\
    /tmp/tmp_g9lvgvj.swift:27:12: error: cannot convert return expression of type\
    \ '(Double, Float)' to return type '(Double, Double)'\n    return (min_num, min_dist)\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // Find the smallest value\n    let minValue\
    \ = min(numbers)\n    // Find the largest value\n    let maxValue = max(numbers)\n\
    \    // Find the two closest to each other\n    var closestToEachOther : Double?\
    \ = nil\n    if maxValue - minValue < 1e-10 {\n        return (minValue, maxValue)\n\
    \    }\n    for number in numbers {\n        let distance = (number - minValue).abs()\n\
    \        if closestToEachOther == nil || distance < closestToEachOther! {\n  \
    \          closestToEachOther = number\n        }\n    }\n    return (closestToEachOther!,\
    \ minValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp818za5vj.swift:10:31: error: missing argument for parameter #2\
    \ in call\n    let minValue = min(numbers)\n                              ^\n\
    \                              , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp818za5vj.swift:12:31: error: missing argument\
    \ for parameter #2 in call\n    let maxValue = max(numbers)\n                \
    \              ^\n                              , <#[Double]#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmp818za5vj.swift:15:30:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Duration'\n\
    \    if maxValue - minValue < 1e-10 {\n                             ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[1]) }\n\n  var largest = numbers[0]\n  var smallest = numbers[0]\n \
    \ var largestIndex = -1\n  var smallestIndex = -1\n\n  for index in 1..<numbers.count\
    \ {\n    let value = numbers[index]\n\n    if value > largest {\n      largest\
    \ = value\n      largestIndex = index\n    }\n\n    if value < smallest {\n  \
    \    smallest = value\n      smallestIndex = index\n    }\n  }\n\n  return (largest,\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuyh_yp5f/tmpuyh_yp5f.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fb6402c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fb60f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fb60f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fb60f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuyh_yp5f                        0x000055f0ca2c66be <unavailable> + 5822

    5    libc.so.6                          0x00002b9fb65ee460 __libc_start_main +
    245

    6    tmpuyh_yp5f                        0x000055f0ca2c6279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   fatalError(\"not enough numbers\")\n    }\n\n    var smallest: Double = numbers.first!\n\
    \    var largest: Double = numbers.last!\n    for number in numbers {\n      \
    \  let delta = abs(number - largest)\n        if delta < smallest {\n        \
    \    smallest = delta\n        } else if delta > largest {\n            largest\
    \ = delta\n        }\n    }\n    return (largest, smallest)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp4ul6rn2x/tmp4ul6rn2x.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04c882cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c8523b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c8523988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c85227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ul6rn2x                        0x0000558485b5a94e <unavailable> + 6478

    5    libc.so.6                          0x00002b04c8a18460 __libc_start_main +
    245

    6    tmp4ul6rn2x                        0x0000558485b5a509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if smallest > number {\n\
    \            smallest = number\n        }\n        if largest < number {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmppm92hgai/tmppm92hgai.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6eb9f4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6eb9c43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6eb9c43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6eb9c427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppm92hgai                        0x0000561a79ba964e <unavailable> + 5710

    5    libc.so.6                          0x00002b6eba138460 __libc_start_main +
    245

    6    tmppm92hgai                        0x0000561a79ba9209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var min1: Double = 0\n    var min2: Double\
    \ = 0\n    for number in numbers {\n        let diff1 = abs(number-number1)\n\
    \        let diff2 = abs(number-number2)\n        if diff1 < diff2 {\n       \
    \     min1 = number\n        } else {\n            min2 = number\n        }\n\
    \    }\n    return (min1, min2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpiuw_nbgn.swift:12:32: error: cannot find 'number1' in scope\n \
    \       let diff1 = abs(number-number1)\n                               ^~~~~~~\n\
    /tmp/tmpiuw_nbgn.swift:13:32: error: cannot find 'number2' in scope\n        let\
    \ diff2 = abs(number-number2)\n                               ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,\
    \ 0.0)\n    }\n    let sortedNumbers = numbers.sorted()\n    let firstClosest\
    \ = sortedNumbers.first!\n    let secondClosest = sortedNumbers.last!\n    return\
    \ (firstClosest, secondClosest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp5ny3n3wr/tmp5ny3n3wr.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b79188c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b78e7fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b78e7f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b78e7e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ny3n3wr                        0x0000558c2387674e <unavailable> + 5966

    5    libc.so.6                          0x00002b7b79374460 __libc_start_main +
    245

    6    tmp5ny3n3wr                        0x0000558c23876309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sorted_numbers = numbers.sorted(by:\
    \ { $0 < $1 })\n    return (sorted_numbers[0], sorted_numbers[1])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpq4eh3bud/tmpq4eh3bud.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14fc760c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14fc457b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14fc457988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14fc4567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq4eh3bud                        0x000055c0c02a854e <unavailable> + 5454

    5    libc.so.6                          0x00002b14fc94c460 __libc_start_main +
    245

    6    tmpq4eh3bud                        0x000055c0c02a8109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double.infinity\n    var\
    \ largest = -Double.infinity\n\n    for n in numbers {\n        if n < smallest\
    \ {\n            smallest = n\n        }\n\n        if n > largest {\n       \
    \     largest = n\n        }\n    }\n\n    return (smallest < largest ? smallest\
    \ : largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmplomdtx3o.swift:22:32: error: cannot convert return expression of\
    \ type 'Double' to return type '(Double, Double)'\n    return (smallest < largest\
    \ ? smallest : largest)\n           ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty {\n        return (numbers[0],\
    \ numbers[0])\n    }\n\n    var min: Double?\n    var max: Double?\n\n    for\
    \ number in numbers {\n        if min == nil {\n            min = number\n   \
    \         max = number\n            continue\n        }\n        if number < min!\
    \ {\n            min = number\n        }\n        if number > max! {\n       \
    \     max = number\n        }\n    }\n    return (min!, max!)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpmbrzxwrh/tmpmbrzxwrh.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae194b77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae19486eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae19486e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae19486d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmbrzxwrh                        0x000055a4e4e4f72e <unavailable> + 5934

    5    libc.so.6                          0x00002ae194d63460 __libc_start_main +
    245

    6    tmpmbrzxwrh                        0x000055a4e4e4f2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty {\n        return 0.0,\
    \ 0.0\n    }\n    \n    if numbers.count == 2 {\n        return numbers[0], numbers[1]\n\
    \    }\n    \n    let numberToClosest = numbers[0]\n    var closestIndex = 1 //\
    \ Index of first number closer to our first number\n    var closestDist = Double(Double.max)\n\
    \    for i in 0 ..< numbers.count - 1 {\n        let currentNumber = numbers[i\
    \ + 1]\n        let currentDist = distance(numberToClosest, currentNumber)\n \
    \       \n        if currentDist < closestDist {\n            closestDist = currentDist\n\
    \            closestIndex = i + 1\n        }\n    }\n    \n    return numbers[closestIndex],\
    \ numberToClosest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpznjz8bgc.swift:10:19: error: consecutive statements on a line must\
    \ be separated by ';'\n        return 0.0, 0.0\n                  ^\n        \
    \          ;\n/tmp/tmpznjz8bgc.swift:10:19: error: expected expression\n     \
    \   return 0.0, 0.0\n                  ^\n/tmp/tmpznjz8bgc.swift:14:26: error:\
    \ consecutive statements on a line must be separated by ';'\n        return numbers[0],\
    \ numbers[1]\n                         ^\n                         ;\n/tmp/tmpznjz8bgc.swift:14:26:\
    \ error: expected expression\n        return numbers[0], numbers[1]\n        \
    \                 ^\n/tmp/tmpznjz8bgc.swift:30:33: error: consecutive statements\
    \ on a line must be separated by ';'\n    return numbers[closestIndex], numberToClosest\n\
    \                                ^\n                                ;\n/tmp/tmpznjz8bgc.swift:30:33:\
    \ error: expected expression\n    return numbers[closestIndex], numberToClosest\n\
    \                                ^\n/tmp/tmpznjz8bgc.swift:10:16: error: cannot\
    \ convert return expression of type 'Double' to return type '(Double, Double)'\n\
    \        return 0.0, 0.0\n               ^~~\n/tmp/tmpznjz8bgc.swift:14:23: error:\
    \ cannot convert return expression of type 'Double' to return type '(Double, Double)'\n\
    \        return numbers[0], numbers[1]\n               ~~~~~~~^~~\n/tmp/tmpznjz8bgc.swift:19:37:\
    \ error: type 'Double' has no member 'max'\n    var closestDist = Double(Double.max)\n\
    \                             ~~~~~~ ^~~\n/tmp/tmpznjz8bgc.swift:22:27: error:\
    \ cannot find 'distance' in scope\n        let currentDist = distance(numberToClosest,\
    \ currentNumber)\n                          ^~~~~~~~\n/tmp/tmpznjz8bgc.swift:30:19:\
    \ error: cannot convert return expression of type 'Double' to return type '(Double,\
    \ Double)'\n    return numbers[closestIndex], numberToClosest\n           ~~~~~~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty {\n        return (nil,\
    \ nil)\n    }\n\n    var smallestValue = Double(numbers[0])\n    var smallestIndex\
    \ = 0\n\n    var largestValue = Double(numbers[0])\n    var largestIndex = 0\n\
    \n    for i in 0 ..< numbers.count {\n        if numbers[i] > largestValue {\n\
    \            largestValue = numbers[i]\n            largestIndex = i\n       \
    \ }\n        if numbers[i] < smallestValue {\n            smallestValue = numbers[i]\n\
    \            smallestIndex = i\n        }\n    }\n    return (largestValue, numbers[largestIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpyuk9ndt0.swift:10:17: error: 'nil' requires a contextual type\n\
    \        return (nil, nil)\n                ^\n/tmp/tmpyuk9ndt0.swift:10:22: error:\
    \ 'nil' requires a contextual type\n        return (nil, nil)\n              \
    \       ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  if numbers.count < 2 {\n    return numbers[0],\
    \ numbers[0]\n  }\n  let min1 = numbers[0]\n  let min2 = numbers[0]\n  let index1\
    \ = 1\n  let index2 = 1\n  for n in numbers {\n    if n > min1 {\n      min2 =\
    \ min1\n      min1 = n\n      index1 = index1 + 1\n    } else {\n      min2 =\
    \ n\n    }\n  }\n  return (numbers[index1], min2)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp04abtc_o.swift:10:22: error: consecutive statements on a line must\
    \ be separated by ';'\n    return numbers[0], numbers[0]\n                   \
    \  ^\n                     ;\n/tmp/tmp04abtc_o.swift:10:22: error: expected expression\n\
    \    return numbers[0], numbers[0]\n                     ^\n/tmp/tmp04abtc_o.swift:10:19:\
    \ error: cannot convert return expression of type 'Double' to return type '(Double,\
    \ Double)'\n    return numbers[0], numbers[0]\n           ~~~~~~~^~~\n/tmp/tmp04abtc_o.swift:18:7:\
    \ error: cannot assign to value: 'min2' is a 'let' constant\n      min2 = min1\n\
    \      ^~~~\n/tmp/tmp04abtc_o.swift:13:3: note: change 'let' to 'var' to make\
    \ it mutable\n  let min2 = numbers[0]\n  ^~~\n  var\n/tmp/tmp04abtc_o.swift:19:7:\
    \ error: cannot assign to value: 'min1' is a 'let' constant\n      min1 = n\n\
    \      ^~~~\n/tmp/tmp04abtc_o.swift:12:3: note: change 'let' to 'var' to make\
    \ it mutable\n  let min1 = numbers[0]\n  ^~~\n  var\n/tmp/tmp04abtc_o.swift:20:7:\
    \ error: cannot assign to value: 'index1' is a 'let' constant\n      index1 =\
    \ index1 + 1\n      ^~~~~~\n/tmp/tmp04abtc_o.swift:14:3: note: change 'let' to\
    \ 'var' to make it mutable\n  let index1 = 1\n  ^~~\n  var\n/tmp/tmp04abtc_o.swift:22:7:\
    \ error: cannot assign to value: 'min2' is a 'let' constant\n      min2 = n\n\
    \      ^~~~\n/tmp/tmp04abtc_o.swift:13:3: note: change 'let' to 'var' to make\
    \ it mutable\n  let min2 = numbers[0]\n  ^~~\n  var\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    func compare(_ aValue: Double, bValue:\
    \ Double) -> (Double, Double) {\n        var result = (aValue < bValue) ? -1 :\
    \ 1\n        let factor = (result == -1) ? -1 : 1\n        return (result * factor,\
    \ bValue * factor)\n    }\n\n    var smallestDifference = Double(FLT_MAX)\n  \
    \  var smallest = Double(FLT_MAX)\n    var largest = Double(FLT_MIN)\n    var\
    \ closest1 = Double(FLT_MAX)\n    var closest2 = Double(FLT_MAX)\n    for i in\
    \ 0..<numbers.count {\n        let (closestValue1, closestValue2) = compare(numbers[i],\
    \ numbers[i+1])\n        if (closestValue1 < smallestDifference) {\n         \
    \   smallestDifference = closestValue1\n            smallest = closestValue2\n\
    \            closest2 = closestValue1\n            closest1 = closestValue2\n\
    \        }\n        if (closestValue2 < smallestDifference) {\n            smallestDifference\
    \ = closestValue2\n            smallest = closestValue1\n            closest2\
    \ = closestValue2\n            closest1 = closestValue1\n        }\n    }\n  \
    \  return (closest1, closest2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpdli07z59.swift:12:16: error: cannot convert return expression of\
    \ type '(Int, Double)' to return type '(Double, Double)'\n        return (result\
    \ * factor, bValue * factor)\n               ^\n/tmp/tmpdli07z59.swift:12:43:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \        return (result * factor, bValue * factor)\n                         \
    \                 ^\n                                          Double( )\n/tmp/tmpdli07z59.swift:15:37:\
    \ error: cannot find 'FLT_MAX' in scope\n    var smallestDifference = Double(FLT_MAX)\n\
    \                                    ^~~~~~~\n/tmp/tmpdli07z59.swift:16:27: error:\
    \ cannot find 'FLT_MAX' in scope\n    var smallest = Double(FLT_MAX)\n       \
    \                   ^~~~~~~\n/tmp/tmpdli07z59.swift:17:26: error: cannot find\
    \ 'FLT_MIN' in scope\n    var largest = Double(FLT_MIN)\n                    \
    \     ^~~~~~~\n/tmp/tmpdli07z59.swift:18:27: error: cannot find 'FLT_MAX' in scope\n\
    \    var closest1 = Double(FLT_MAX)\n                          ^~~~~~~\n/tmp/tmpdli07z59.swift:19:27:\
    \ error: cannot find 'FLT_MAX' in scope\n    var closest2 = Double(FLT_MAX)\n\
    \                          ^~~~~~~\n/tmp/tmpdli07z59.swift:21:53: error: missing\
    \ argument label 'bValue:' in call\n        let (closestValue1, closestValue2)\
    \ = compare(numbers[i], numbers[i+1])\n                                      \
    \              ^\n                                                           \
    \      bValue: \n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty { return (0.0, 0.0)\
    \ }\n\n    var smallest1 = numbers[0]\n    var smallest2 = numbers[0]\n    var\
    \ smallestDiff = 1.0\n\n    var nextSmallestDiff = 1.000\n\n    for i in 1 ..<\
    \ numbers.count {\n        let currentDiff = abs(numbers[i] - numbers[smallest1])\n\
    \        if currentDiff < smallestDiff {\n            smallest1 = numbers[i]\n\
    \            smallestDiff = currentDiff\n        } else {\n            smallest2\
    \ = numbers[i]\n            nextSmallestDiff = currentDiff\n        }\n    }\n\
    \n    return (smallest1, smallest2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpsio1xh1q.swift:18:52: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        let currentDiff = abs(numbers[i] -\
    \ numbers[smallest1])\n                                                   ^\n\
    \                                                   Int(     )\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let n1 = Double(numbers.first!)\n    let\
    \ n2 = Double(numbers.last!)\n    var closest1 = n1\n    var closest2 = n2\n \
    \   var closestDifference = Double.max\n\n    for (index, number) in\n       \
    \     numbers.enumerated() {\n        let distance = abs(n1 - number)\n      \
    \  if (closestDifference > distance) {\n            closestDifference = distance\n\
    \            closest1 = number\n            closest2 = numbers[index + 1]\n  \
    \      }\n    }\n\n    return (closest1, closest2)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpyzjbqcot.swift:13:36: error: type 'Double' has no member 'max'\n\
    \    var closestDifference = Double.max\n                            ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted(by:\
    \ <)\n    return (sortedNumbers[0], sortedNumbers[1])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpo4rmjlw6/tmpo4rmjlw6.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b0d5c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b0d2b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b0d2b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b0d2b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo4rmjlw6                        0x000056360039154e <unavailable> + 5454

    5    libc.so.6                          0x00002b3b0d7ac460 __libc_start_main +
    245

    6    tmpo4rmjlw6                        0x0000563600391109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (0.0, 0.0) }\n\n    var smallest = Double(numbers.first!)\n    var largest =\
    \ Double(numbers.last!)\n    for number in numbers.dropFirst() {\n        if number\
    \ < smallest { smallest = number }\n        if number > largest { largest = number\
    \ }\n    }\n\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpzsk8luc7/tmpzsk8luc7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e7d170c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e7ce67b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e7ce67988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e7ce667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzsk8luc7                        0x000055a9b66a791e <unavailable> + 6430

    5    libc.so.6                          0x00002b9e7d35c460 __libc_start_main +
    245

    6    tmpzsk8luc7                        0x000055a9b66a74d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   print(\"Must have at least two numbers to find the closest ones.\")\n    \
    \    return (0.0,0.0)\n    }\n    // Select the first two numbers and find the\
    \ closest to them\n    let closestNumber = closestToNumbers(numbers: numbers)\n\
    \    return (closestNumber, numbers[numbers.index(closestNumber)])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmphad2sp0s.swift:14:25: error: cannot find 'closestToNumbers' in\
    \ scope\n    let closestNumber = closestToNumbers(numbers: numbers)\n        \
    \                ^~~~~~~~~~~~~~~~\n/tmp/tmphad2sp0s.swift:15:44: error: no exact\
    \ matches in call to instance method 'index'\n    return (closestNumber, numbers[numbers.index(closestNumber)])\n\
    \                                           ^\n/tmp/tmphad2sp0s.swift:15:44: note:\
    \ found candidate with type '(Int) -> Int'\n    return (closestNumber, numbers[numbers.index(closestNumber)])\n\
    \                                           ^\n/tmp/tmphad2sp0s.swift:15:44: note:\
    \ found candidate with type '(Int) -> Int'\n    return (closestNumber, numbers[numbers.index(closestNumber)])\n\
    \                                           ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers, offset:\
    \ 0, count: numbers.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpeagb5369.swift:9:33: error: extra arguments at positions #2, #3\
    \ in call\n    return find_closest_elements(numbers, offset: 0, count: numbers.count)\n\
    \                                ^\n/tmp/tmpeagb5369.swift:8:6: note: 'find_closest_elements(numbers:)'\
    \ declared here\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double)\
    \ {\n     ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.count == 2 {\n        return\
    \ (numbers[0], numbers[1])\n    }\n    if numbers.count == 0 {\n        return\
    \ (0.0, 0.0)\n    }\n    numbers.sort()\n    \n    var smallest = numbers[0]\n\
    \    var largest = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ < smallest {\n            smallest = numbers[i]\n        }\n        if numbers[i]\
    \ > largest {\n            largest = numbers[i]\n        }\n    }\n    return\
    \ (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp78rcfdah.swift:15:13: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n    numbers.sort()\n    ~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let n = numbers.count\n    let mut smaller\
    \ = Double.leastNormalMagnitude\n    let mut larger = Double.greatestNormalMagnitude\n\
    \    for i in 0..<n {\n        let smaller_diff = numbers[i].abs().flatMap { $0\
    \ }.min()\n        smaller = min(smaller, smaller_diff)\n        let larger_diff\
    \ = numbers[i].abs().flatMap { $0 }.max()\n        larger = max(larger, larger_diff)\n\
    \    }\n    return (smaller, larger)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppso4k40d.swift:10:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut smaller\
    \ = Double.leastNormalMagnitude\n            ^\n/tmp/tmppso4k40d.swift:10:13:\
    \ note: join the identifiers together\n    let mut smaller = Double.leastNormalMagnitude\n\
    \        ~~~~^~~~~~~\n        mutsmaller\n/tmp/tmppso4k40d.swift:10:13: note:\
    \ join the identifiers together with camel-case\n    let mut smaller = Double.leastNormalMagnitude\n\
    \        ~~~~^~~~~~~\n        mutSmaller\n/tmp/tmppso4k40d.swift:11:13: error:\
    \ found an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n    let mut larger = Double.greatestNormalMagnitude\n            ^\n\
    /tmp/tmppso4k40d.swift:11:13: note: join the identifiers together\n    let mut\
    \ larger = Double.greatestNormalMagnitude\n        ~~~~^~~~~~\n        mutlarger\n\
    /tmp/tmppso4k40d.swift:11:13: note: join the identifiers together with camel-case\n\
    \    let mut larger = Double.greatestNormalMagnitude\n        ~~~~^~~~~~\n   \
    \     mutLarger\n/tmp/tmppso4k40d.swift:11:29: error: type 'Double' has no member\
    \ 'greatestNormalMagnitude'\n    let mut larger = Double.greatestNormalMagnitude\n\
    \                     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmppso4k40d.swift:13:39:\
    \ error: value of type 'Double' has no member 'abs'\n        let smaller_diff\
    \ = numbers[i].abs().flatMap { $0 }.min()\n                           ~~~~~~~~~~\
    \ ^~~\n/tmp/tmppso4k40d.swift:14:9: error: cannot find 'smaller' in scope\n  \
    \      smaller = min(smaller, smaller_diff)\n        ^~~~~~~\n/tmp/tmppso4k40d.swift:14:23:\
    \ error: cannot find 'smaller' in scope\n        smaller = min(smaller, smaller_diff)\n\
    \                      ^~~~~~~\n/tmp/tmppso4k40d.swift:15:38: error: value of\
    \ type 'Double' has no member 'abs'\n        let larger_diff = numbers[i].abs().flatMap\
    \ { $0 }.max()\n                          ~~~~~~~~~~ ^~~\n/tmp/tmppso4k40d.swift:16:9:\
    \ error: cannot find 'larger' in scope\n        larger = max(larger, larger_diff)\n\
    \        ^~~~~~\n/tmp/tmppso4k40d.swift:16:22: error: cannot f"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = Float.greatestFiniteMagnitude\n\
    \    let max = Float.leastFiniteMagnitude\n    var minElement = Double.nan\n \
    \   var maxElement = Double.nan\n    for number in numbers {\n        if number\
    \ < min {\n            min = number\n            minElement = number\n       \
    \ } else if number > max {\n            max = number\n            maxElement =\
    \ number\n        }\n    }\n    return (minElement, maxElement)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp9pi3oiot.swift:10:21: error: type 'Float' has no member 'leastFiniteMagnitude'\n\
    \    let max = Float.leastFiniteMagnitude\n              ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9pi3oiot.swift:14:19: error: binary operator '<' cannot be applied to\
    \ operands of type 'Double' and 'Float'\n        if number < min {\n         \
    \  ~~~~~~ ^ ~~~\n/tmp/tmp9pi3oiot.swift:15:13: error: cannot assign to value:\
    \ 'min' is a 'let' constant\n            min = number\n            ^~~\n/tmp/tmp9pi3oiot.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = Float.greatestFiniteMagnitude\n\
    \    ^~~\n    var\n/tmp/tmp9pi3oiot.swift:15:19: error: cannot assign value of\
    \ type 'Double' to type 'Float'\n            min = number\n                  ^~~~~~\n\
    \                  Float()\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var closest = Double.leastNormalMagnitude\n\
    \    var close = Double.leastNormalMagnitude\n    for n in numbers {\n       \
    \ let d = abs(n - closest)\n        if d < close {\n            close = closest\n\
    \            closest = d\n        }\n    }\n    return (closest, closest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp2mcam649/tmp2mcam649.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76543c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76540beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76540be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76540bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2mcam649                        0x0000556d4f2a774e <unavailable> + 5966

    5    libc.so.6                          0x00002b76545b3460 __libc_start_main +
    245

    6    tmp2mcam649                        0x0000556d4f2a7309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min_val: Double = numbers[0]\n    let\
    \ max_val: Double = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ < min_val {\n            min_val = numbers[i]\n        } else if numbers[i]\
    \ > max_val {\n            max_val = numbers[i]\n        }\n    }\n    return\
    \ (min_val, max_val)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5iwl1mrk.swift:13:13: error: cannot assign to value: 'min_val'\
    \ is a 'let' constant\n            min_val = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmp5iwl1mrk.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let min_val: Double = numbers[0]\n    ^~~\n    var\n/tmp/tmp5iwl1mrk.swift:15:13:\
    \ error: cannot assign to value: 'max_val' is a 'let' constant\n            max_val\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmp5iwl1mrk.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let max_val: Double = numbers[0]\n  \
    \  ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // Get our min and max values\n    var\
    \ minValue: Double = -1.0\n    var maxValue: Double = 1.0\n    // Go through our\
    \ numbers and update our min and max values\n    for i in 0..<numbers.count {\n\
    \        let value = numbers[i]\n        if value < minValue {\n            minValue\
    \ = value\n        } else if value > maxValue {\n            maxValue = value\n\
    \        }\n    }\n    // If we have no numbers, return an empty tuple\n    if\
    \ numbers.count == 0 {\n        return (0.0,0.0)\n    }\n    // Get our range\n\
    \    let range: Double = maxValue - minValue\n    // If our range is too small,\
    \ make our range bigger\n    if range < MIN_RANGE {\n        range = MIN_RANGE\n\
    \    }\n    // Return our values sorted\n    return (0.0 + ((minValue - maxValue)\
    \ / Double(numbers.count)), 0.0 + ((maxValue - minValue) / Double(numbers.count)))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpmvyo2drw.swift:28:16: error: cannot find 'MIN_RANGE' in scope\n\
    \    if range < MIN_RANGE {\n               ^~~~~~~~~\n/tmp/tmpmvyo2drw.swift:29:17:\
    \ error: cannot find 'MIN_RANGE' in scope\n        range = MIN_RANGE\n       \
    \         ^~~~~~~~~\n/tmp/tmpmvyo2drw.swift:29:9: error: cannot assign to value:\
    \ 'range' is a 'let' constant\n        range = MIN_RANGE\n        ^~~~~\n/tmp/tmpmvyo2drw.swift:26:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let range: Double = maxValue\
    \ - minValue\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.5,\
    \ 0.5)\n    }\n    if numbers.count == 2 {\n        return (numbers[0], numbers[1])\n\
    \    }\n    guard let number1 = numbers.first else { return (0.0, 0.0) }\n   \
    \ guard let number2 = numbers.last else { return (number1, number1) }\n    let\
    \ difference1 = number1 - number2\n    let difference2 = number2 - number1\n \
    \   let differenceABS = difference1 * difference1 + difference2 * difference2\n\
    \    let distanceABS = differenceABS * -0.5\n    let distanceSqrt = sqrt(distanceABS)\n\
    \    let number3 = number1 + distanceSqrt\n    let number4 = number2 + distanceSqrt\n\
    \    return (number3, number4)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpou17c7fj.swift:21:24: error: cannot find 'sqrt' in scope\n    let\
    \ distanceSqrt = sqrt(distanceABS)\n                       ^~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // Your code here\n    if numbers.count\
    \ < 2 {\n        fatalError(\"not enough numbers\")\n    }\n    var smallest =\
    \ numbers[0]\n    var largest = numbers[0]\n    var index = 0\n\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n        if number < numbers[index] {\n            index = index + 1\n\
    \        }\n        if number > numbers[index] {\n            index = index -\
    \ 1\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002adf2a2adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf29fa4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002adf29fa4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002adf29fa413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002adf29fa3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002adf29da3f44 <unavailable> + 188228

    6    tmpfxck4i9k                        0x000055f60e19ef2a <unavailable> + 7978

    7    tmpfxck4i9k                        0x000055f60e19e63d <unavailable> + 5693

    8    libc.so.6                          0x00002adf2a499460 __libc_start_main +
    245

    9    tmpfxck4i9k                        0x000055f60e19e2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double = Double(Int.max)\
    \ {}\n    var largest: Double = Double(Int.min) {}\n\n    numbers.forEach { (number)\
    \ in\n        smallest = (number < smallest ? number : smallest)\n        largest\
    \ = (number > largest ? number : largest)\n    }\n\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfbz2e399.swift:9:28: error: no exact matches in call to initializer\
    \ \n    var smallest: Double = Double(Int.max) {}\n                          \
    \ ^\n/tmp/tmpfbz2e399.swift:9:28: note: candidate has partially matching parameter\
    \ list (nan: Double.RawSignificand, signaling: Bool)\n    var smallest: Double\
    \ = Double(Int.max) {}\n                           ^\n/tmp/tmpfbz2e399.swift:9:28:\
    \ note: candidate has partially matching parameter list (signOf: Double, magnitudeOf:\
    \ Double)\n    var smallest: Double = Double(Int.max) {}\n                   \
    \        ^\n/tmp/tmpfbz2e399.swift:9:28: note: candidate has partially matching\
    \ parameter list (signOf: Double, magnitudeOf: Double)\n    var smallest: Double\
    \ = Double(Int.max) {}\n                           ^\n/tmp/tmpfbz2e399.swift:10:27:\
    \ error: no exact matches in call to initializer \n    var largest: Double = Double(Int.min)\
    \ {}\n                          ^\n/tmp/tmpfbz2e399.swift:10:27: note: candidate\
    \ has partially matching parameter list (nan: Double.RawSignificand, signaling:\
    \ Bool)\n    var largest: Double = Double(Int.min) {}\n                      \
    \    ^\n/tmp/tmpfbz2e399.swift:10:27: note: candidate has partially matching parameter\
    \ list (signOf: Double, magnitudeOf: Double)\n    var largest: Double = Double(Int.min)\
    \ {}\n                          ^\n/tmp/tmpfbz2e399.swift:10:27: note: candidate\
    \ has partially matching parameter list (signOf: Double, magnitudeOf: Double)\n\
    \    var largest: Double = Double(Int.min) {}\n                          ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let numberArray = numbers.sorted()\n  \
    \  return (numberArray[0], numberArray[numberArray.count - 1])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpxbp0tbj9/tmpxbp0tbj9.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57a4453c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57a414ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57a414a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57a41497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxbp0tbj9                        0x00005622920a35de <unavailable> + 5598

    5    libc.so.6                          0x00002b57a463f460 __libc_start_main +
    245

    6    tmpxbp0tbj9                        0x00005622920a3199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n\n    let diff = numbers[0].distance(to: numbers[1])\n\
    \    let result = (numbers[0], numbers[1])\n    for i in 1 ..< numbers.count {\n\
    \        let newDiff = numbers[i].distance(to: numbers[i - 1])\n        if diff\
    \ == 0.0 {\n            diff = newDiff\n            result = (numbers[i], numbers[i\
    \ - 1])\n        } else {\n            if diff > newDiff {\n                diff\
    \ = newDiff\n                result = (numbers[i], numbers[i - 1])\n         \
    \   } else {\n                diff = 0\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpf08pqxsh.swift:16:13: error: cannot assign to value: 'diff' is\
    \ a 'let' constant\n            diff = newDiff\n            ^~~~\n/tmp/tmpf08pqxsh.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let diff = numbers[0].distance(to:\
    \ numbers[1])\n    ^~~\n    var\n/tmp/tmpf08pqxsh.swift:17:13: error: cannot assign\
    \ to value: 'result' is a 'let' constant\n            result = (numbers[i], numbers[i\
    \ - 1])\n            ^~~~~~\n/tmp/tmpf08pqxsh.swift:12:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let result = (numbers[0], numbers[1])\n    ^~~\n\
    \    var\n/tmp/tmpf08pqxsh.swift:20:17: error: cannot assign to value: 'diff'\
    \ is a 'let' constant\n                diff = newDiff\n                ^~~~\n\
    /tmp/tmpf08pqxsh.swift:11:5: note: change 'let' to 'var' to make it mutable\n\
    \    let diff = numbers[0].distance(to: numbers[1])\n    ^~~\n    var\n/tmp/tmpf08pqxsh.swift:21:17:\
    \ error: cannot assign to value: 'result' is a 'let' constant\n              \
    \  result = (numbers[i], numbers[i - 1])\n                ^~~~~~\n/tmp/tmpf08pqxsh.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = (numbers[0],\
    \ numbers[1])\n    ^~~\n    var\n/tmp/tmpf08pqxsh.swift:23:17: error: cannot assign\
    \ to value: 'diff' is a 'let' constant\n                diff = 0\n           \
    \     ^~~~\n/tmp/tmpf08pqxsh.swift:11:5: note: change 'let' to 'var' to make it\
    \ mutable\n    let diff = numbers[0].distance(to: numbers[1])\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    precondition(numbers.count >= 2)\n\n  \
    \  // find two closest numbers\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for (number, index) in numbers.enumerated() {\n        if\
    \ index == 0 {\n            continue\n        }\n\n        let candidate = numbers[index\
    \ - 1]\n\n        if candidate < smallest {\n            smallest = candidate\n\
    \        }\n\n        if candidate > largest {\n            largest = candidate\n\
    \        }\n    }\n\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd_kkxj3a.swift:19:33: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        let candidate = numbers[index - 1]\n\
    \                                ^\n                                Int( )\n/tmp/tmpd_kkxj3a.swift:22:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = candidate\n            ^~~~~~~~\n/tmp/tmpd_kkxj3a.swift:12:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n/tmp/tmpd_kkxj3a.swift:26:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = candidate\n            ^~~~~~~\n\
    /tmp/tmpd_kkxj3a.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  // Create a list of indexes of the two closest\
    \ elements\n  let indexes = find_indexes(numbers: numbers)\n  // Select two numbers\
    \ from the list of indexes\n  let (smaller, bigger) = select_numbers(indexes:\
    \ indexes)\n  // Return both values as tuple\n  return (smaller, bigger)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbztjtlxa.swift:10:17: error: cannot find 'find_indexes' in scope\n\
    \  let indexes = find_indexes(numbers: numbers)\n                ^~~~~~~~~~~~\n\
    /tmp/tmpbztjtlxa.swift:12:27: error: cannot find 'select_numbers' in scope\n \
    \ let (smaller, bigger) = select_numbers(indexes: indexes)\n                 \
    \         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0, 0)\n    }\n    let low = numbers.min()\n    let high = numbers.max()\n\
    \    if low == high {\n        return (low, low)\n    }\n\n    var smallest =\
    \ low\n    var largest = high\n\n    if numbers.count == 3 {\n        if numbers[0]\
    \ == numbers[1] {\n            if numbers[0] == numbers[2] {\n               \
    \ return (low, high)\n            } else {\n                if numbers[1] == numbers[2]\
    \ {\n                    return (numbers[0], high)\n                } else {\n\
    \                    if numbers[1] < numbers[2] {\n                        smallest\
    \ = numbers[0]\n                        largest = numbers[1]\n               \
    \     } else {\n                        smallest = numbers[1]\n              \
    \          largest = numbers[2]\n                    }\n                }\n  \
    \          }\n        } else {\n            if numbers[1] == numbers[2] {\n  \
    \              return (numbers[0], high)\n            } else {\n             \
    \   if numbers[0] < numbers[1] {\n                    smallest = numbers[0]\n\
    \                    largest = numbers[1]\n                } else {\n        \
    \            smallest = numbers[1]\n                    largest = numbers[2]\n\
    \                }\n            }\n        }\n    } else {\n        if numbers[0]\
    \ < numbers[1] {\n            smallest = numbers[0]\n            largest = numbers[1]\n\
    \        } else {\n            smallest = numbers[1]\n            largest = numbers[2]\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp4f_bv9b9.swift:15:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (low, low)\n               ^\n/tmp/tmp4f_bv9b9.swift:24:24: error: cannot convert\
    \ return expression of type '(Double?, Double?)' to return type '(Double, Double)'\n\
    \                return (low, high)\n                       ^\n/tmp/tmp4f_bv9b9.swift:27:28:\
    \ error: cannot convert return expression of type '(Double, Double?)' to return\
    \ type '(Double, Double)'\n                    return (numbers[0], high)\n   \
    \                        ^\n/tmp/tmp4f_bv9b9.swift:40:24: error: cannot convert\
    \ return expression of type '(Double, Double?)' to return type '(Double, Double)'\n\
    \                return (numbers[0], high)\n                       ^\n/tmp/tmp4f_bv9b9.swift:60:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (smallest, largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var a = numbers[0]\n    var b = numbers[0]\n\
    \    for value in numbers {\n        if value < a {\n            a = value\n \
    \       } else if value > b {\n            b = value\n        }\n    }\n    return\
    \ (a, b)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp2gspjska/tmp2gspjska.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f0fd06c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f0f9fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f0f9fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f0f9fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2gspjska                        0x000055fad997164e <unavailable> + 5710

    5    libc.so.6                          0x00002b1f0fef2460 __libc_start_main +
    245

    6    tmp2gspjska                        0x000055fad9971209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smaller = numbers.min()\n    let bigger\
    \ = numbers.max()\n    if smaller < bigger {\n        return (smaller, bigger)\n\
    \    }\n    else {\n        return (smaller, bigger * 2.0)\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp43k9bf88.swift:11:16: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if smaller < bigger {\n       ~~~~~~~ ^ ~~~~~~\n\
    /tmp/tmp43k9bf88.swift:12:16: error: cannot convert return expression of type\
    \ '(Double?, Double?)' to return type '(Double, Double)'\n        return (smaller,\
    \ bigger)\n               ^\n/tmp/tmp43k9bf88.swift:15:26: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n        return\
    \ (smaller, bigger * 2.0)\n                         ^\n/tmp/tmp43k9bf88.swift:15:26:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return (smaller, bigger * 2.0)\n                         ^\n\
    \                         (      ?? <#default value#>)\n/tmp/tmp43k9bf88.swift:15:26:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return (smaller, bigger * 2.0)\n                         ^\n\
    \                               !\n/tmp/tmp43k9bf88.swift:15:16: error: cannot\
    \ convert return expression of type '(Double?, Double)' to return type '(Double,\
    \ Double)'\n        return (smaller, bigger * 2.0)\n               ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    return (largest, smallest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp4p6jg7u1.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp4p6jg7u1.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers, from:\
    \ numbers.startIndex, to: numbers.endIndex)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkhfauyj9.swift:9:33: error: extra arguments at positions #2, #3\
    \ in call\n    return find_closest_elements(numbers, from: numbers.startIndex,\
    \ to: numbers.endIndex)\n                                ^\n/tmp/tmpkhfauyj9.swift:8:6:\
    \ note: 'find_closest_elements(numbers:)' declared here\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n     ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 2 else {\n      \
    \  return numbers[1], numbers[1]\n    }\n    let arrayOne = numbers[0]\n    let\
    \ arrayTwo = numbers[1]\n    var smallestDifference = Double.infinity\n    var\
    \ largestDifference = -Double.infinity\n    for i in 0..<numbers.count {\n   \
    \     if abs(arrayOne - numbers[i]) < smallestDifference {\n            smallestDifference\
    \ = abs(arrayOne - numbers[i])\n        }\n        if abs(arrayTwo - numbers[i])\
    \ < largestDifference {\n            largestDifference = abs(arrayTwo - numbers[i])\n\
    \        }\n    }\n    return (arrayOne, arrayTwo)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpm9s4gk3w.swift:10:26: error: consecutive statements on a line must\
    \ be separated by ';'\n        return numbers[1], numbers[1]\n               \
    \          ^\n                         ;\n/tmp/tmpm9s4gk3w.swift:10:26: error:\
    \ expected expression\n        return numbers[1], numbers[1]\n               \
    \          ^\n/tmp/tmpm9s4gk3w.swift:10:23: error: cannot convert return expression\
    \ of type 'Double' to return type '(Double, Double)'\n        return numbers[1],\
    \ numbers[1]\n               ~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  guard numbers.count >= 2 else {\n    return\
    \ (nil, nil)\n  }\n\n  var min: Double = Double(FLT_MAX)\n  var max: Double =\
    \ Double(-FLT_MAX)\n\n  for number in numbers {\n    guard number >= min && number\
    \ <= max else {\n      return (nil, nil)\n    }\n\n    if number < min {\n   \
    \   min = number\n    } else if number > max {\n      max = number\n    }\n  }\n\
    \n  return (min: min, max: max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp9e9g3xdl.swift:10:13: error: 'nil' requires a contextual type\n\
    \    return (nil, nil)\n            ^\n/tmp/tmp9e9g3xdl.swift:10:18: error: 'nil'\
    \ requires a contextual type\n    return (nil, nil)\n                 ^\n/tmp/tmp9e9g3xdl.swift:13:28:\
    \ error: cannot find 'FLT_MAX' in scope\n  var min: Double = Double(FLT_MAX)\n\
    \                           ^~~~~~~\n/tmp/tmp9e9g3xdl.swift:14:29: error: cannot\
    \ find 'FLT_MAX' in scope\n  var max: Double = Double(-FLT_MAX)\n            \
    \                ^~~~~~~\n/tmp/tmp9e9g3xdl.swift:18:15: error: 'nil' requires\
    \ a contextual type\n      return (nil, nil)\n              ^\n/tmp/tmp9e9g3xdl.swift:18:20:\
    \ error: 'nil' requires a contextual type\n      return (nil, nil)\n         \
    \          ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n\tlet smallest = numbers[0]\n\tlet largest\
    \ = numbers[0]\n\tnumbers.forEach { smallest = min(smallest, $0) }\n\tnumbers.forEach\
    \ { largest = max(largest, $0) }\n\treturn (largest, smallest)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkgvhf97d.swift:11:20: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n        numbers.forEach { smallest = min(smallest, $0)\
    \ }\n                          ^~~~~~~~\n/tmp/tmpkgvhf97d.swift:9:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let smallest = numbers[0]\n     \
    \   ^~~\n        var\n/tmp/tmpkgvhf97d.swift:12:20: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n        numbers.forEach { largest = max(largest,\
    \ $0) }\n                          ^~~~~~~\n/tmp/tmpkgvhf97d.swift:10:2: note:\
    \ change 'let' to 'var' to make it mutable\n        let largest = numbers[0]\n\
    \        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty { return (numbers[0],\
    \ numbers[0]) }\n    var smallestDiff = numbers[0].signum() - numbers[1].signum()\n\
    \    var closest1 = numbers[0]\n    var closest2 = numbers[0]\n    if numbers[1].signum()\
    \ > numbers[0].signum() {\n        closest1 = numbers[1]\n        closest2 = numbers[0]\n\
    \    }\n    for number in numbers[2..<numbers.count] {\n        var diff: Double\n\
    \        if smallestDiff == numbers[smallestDiff].signum() {\n            diff\
    \ = smallestDiff\n        } else {\n            diff = number.signum() - numbers[smallestDiff].signum()\n\
    \        }\n        if diff < 0 {\n            smallestDiff = diff\n         \
    \   closest1 = number\n            closest2 = number\n        } else {\n     \
    \       smallestDiff = -diff\n            closest2 = number\n            closest1\
    \ = number\n        }\n    }\n    return (closest1, closest2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpcfjt0gvp.swift:10:35: error: value of type 'Double' has no member\
    \ 'signum'\n    var smallestDiff = numbers[0].signum() - numbers[1].signum()\n\
    \                       ~~~~~~~~~~ ^~~~~~\n/tmp/tmpcfjt0gvp.swift:10:57: error:\
    \ value of type 'Double' has no member 'signum'\n    var smallestDiff = numbers[0].signum()\
    \ - numbers[1].signum()\n                                             ~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpcfjt0gvp.swift:13:19: error: value of type 'Double' has no member\
    \ 'signum'\n    if numbers[1].signum() > numbers[0].signum() {\n       ~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpcfjt0gvp.swift:13:41: error: value of type 'Double' has no member\
    \ 'signum'\n    if numbers[1].signum() > numbers[0].signum() {\n             \
    \                ~~~~~~~~~~ ^~~~~~\n/tmp/tmpcfjt0gvp.swift:19:50: error: reference\
    \ to member 'signum' cannot be resolved without a contextual type\n        if\
    \ smallestDiff == numbers[smallestDiff].signum() {\n                         \
    \                        ^\n/tmp/tmpcfjt0gvp.swift:22:27: error: value of type\
    \ 'Double' has no member 'signum'\n            diff = number.signum() - numbers[smallestDiff].signum()\n\
    \                   ~~~~~~ ^~~~~~\n/tmp/tmpcfjt0gvp.swift:22:60: error: reference\
    \ to member 'signum' cannot be resolved without a contextual type\n          \
    \  diff = number.signum() - numbers[smallestDiff].signum()\n                 \
    \                                          ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    \n    let min1 = min(numbers)\n    let\
    \ max1 = max(numbers)\n    \n    return min1, max1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpx6ozabb9.swift:13:16: error: consecutive statements on a line must\
    \ be separated by ';'\n    return min1, max1\n               ^\n             \
    \  ;\n/tmp/tmpx6ozabb9.swift:13:16: error: expected expression\n    return min1,\
    \ max1\n               ^\n/tmp/tmpx6ozabb9.swift:10:27: error: missing argument\
    \ for parameter #2 in call\n    let min1 = min(numbers)\n                    \
    \      ^\n                          , <#[Double]#>\nSwift.min:1:24: note: 'min'\
    \ declared here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n/tmp/tmpx6ozabb9.swift:11:27: error: missing\
    \ argument for parameter #2 in call\n    let max1 = max(numbers)\n           \
    \               ^\n                          , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers: numbers,\
    \ threshold: 1.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzvcfexxu.swift:9:63: error: extra argument 'threshold' in call\n\
    \    return find_closest_elements(numbers: numbers, threshold: 1.0)\n        \
    \                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    var bestDistance = abs(numbers[0] - numbers[1])\n    var\
    \ bestElement = (numbers[0], numbers[1])\n\n    for i in 1..numbers.count {\n\
    \        let currentDistance = abs(numbers[i] - numbers[i - 1]) + bestDistance\n\
    \        if currentDistance < bestDistance {\n            bestDistance = currentDistance\n\
    \            bestElement = (numbers[i], numbers[i - 1])\n        }\n    }\n\n\
    \    return (bestElement.0, bestElement.1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5ymes81x.swift:13:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty { return (numbers[0],\
    \ numbers[0]) }\n    var smallestDifference = Double.infinity\n    var smallestDifferenceNumber\
    \ = numbers[0]\n    var smallestDifferenceIndex = 0\n    for i in 0..<numbers.count\
    \ {\n        var difference = abs(numbers[i] - numbers[smallestDifferenceIndex])\n\
    \        if difference < smallestDifference {\n            smallestDifference\
    \ = difference\n            smallestDifferenceNumber = numbers[i]\n          \
    \  smallestDifferenceIndex = i\n        }\n    }\n    return (smallestDifferenceNumber,\
    \ numbers[smallestDifferenceIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpu2aejg9y/tmpu2aejg9y.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b093ceb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b093cbafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b093cbaf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b093cbae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu2aejg9y                        0x000055f3f053a88e <unavailable> + 6286

    5    libc.so.6                          0x00002b093d0a4460 __libc_start_main +
    245

    6    tmpu2aejg9y                        0x000055f3f053a449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double = Double.max\n   \
    \ var largest: Double = Double.min\n    for i in numbers.indices {\n        let\
    \ current: Double = numbers[i]\n        if current < smallest {\n            smallest\
    \ = current\n        }\n        if current > largest {\n            largest =\
    \ current\n        }\n    }\n    return (numbers[numbers.index(of: smallest)],\
    \ numbers[numbers.index(of: largest)])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp8ytn998p.swift:9:35: error: type 'Double' has no member 'max'\n\
    \    var smallest: Double = Double.max\n                           ~~~~~~ ^~~\n\
    /tmp/tmp8ytn998p.swift:10:34: error: type 'Double' has no member 'min'\n    var\
    \ largest: Double = Double.min\n                          ~~~~~~ ^~~\n/tmp/tmp8ytn998p.swift:20:29:\
    \ error: value of optional type 'Array<Double>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Double>.Index' (aka 'Int')\n    return\
    \ (numbers[numbers.index(of: smallest)], numbers[numbers.index(of: largest)])\n\
    \                            ^\n/tmp/tmp8ytn998p.swift:20:29: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n    return\
    \ (numbers[numbers.index(of: smallest)], numbers[numbers.index(of: largest)])\n\
    \                            ^\n                                             \
    \   ?? <#default value#>\n/tmp/tmp8ytn998p.swift:20:29: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    return (numbers[numbers.index(of:\
    \ smallest)], numbers[numbers.index(of: largest)])\n                         \
    \   ^\n                                               !\n/tmp/tmp8ytn998p.swift:20:67:\
    \ error: value of optional type 'Array<Double>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Double>.Index' (aka 'Int')\n    return\
    \ (numbers[numbers.index(of: smallest)], numbers[numbers.index(of: largest)])\n\
    \                                                                  ^\n/tmp/tmp8ytn998p.swift:20:67:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return (numbers[numbers.index(of: smallest)], numbers[numbers.index(of:\
    \ largest)])\n                                                               \
    \   ^\n                                                                      \
    \               ?? <#default value#>\n/tmp/tmp8ytn998p.swift:20:67: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ (numbers[numbers.index(of: smallest)], numbers["
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let minDistance = Double.max\n    let minIndex\
    \ = -1\n    for i in 1..<numbers.count {\n        let distance = (numbers[i] -\
    \ numbers[minIndex])\n        if distance < minDistance {\n            minDistance\
    \ = distance\n            minIndex = i\n        }\n    }\n    return (numbers[minIndex],\
    \ numbers[minIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6uqzcmnr.swift:9:30: error: type 'Double' has no member 'max'\n\
    \    let minDistance = Double.max\n                      ~~~~~~ ^~~\n/tmp/tmp6uqzcmnr.swift:15:13:\
    \ error: cannot assign to value: 'minIndex' is a 'let' constant\n            minIndex\
    \ = i\n            ^~~~~~~~\n/tmp/tmp6uqzcmnr.swift:10:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let minIndex = -1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  let min = _minimum(numbers)\n  let max =\
    \ _maximum(numbers)\n  return (min!, max!)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp0zrwut58.swift:9:13: error: cannot find '_minimum' in scope\n \
    \ let min = _minimum(numbers)\n            ^~~~~~~~\n/tmp/tmp0zrwut58.swift:10:13:\
    \ error: cannot find '_maximum' in scope\n  let max = _maximum(numbers)\n    \
    \        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp5bpdyxs7/tmp5bpdyxs7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba059be6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0598ddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0598dd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0598dc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5bpdyxs7                        0x0000558877e036be <unavailable> + 5822

    5    libc.so.6                          0x00002ba059dd2460 __libc_start_main +
    245

    6    tmp5bpdyxs7                        0x0000558877e03279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpv34aforo/tmpv34aforo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38a3a9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38a3795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38a3795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38a37947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv34aforo                        0x000056122d0bf64e <unavailable> + 5710

    5    libc.so.6                          0x00002b38a3c8a460 __libc_start_main +
    245

    6    tmpv34aforo                        0x000056122d0bf209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  if numbers.isEmpty {\n    return (0, 0)\n\
    \  }\n  numbers.sort { $0 < $1 }\n  return numbers[0..<numbers.count - 1], numbers[numbers.count\
    \ - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjvw7hbuk.swift:13:40: error: consecutive statements on a line must\
    \ be separated by ';'\n  return numbers[0..<numbers.count - 1], numbers[numbers.count\
    \ - 1]\n                                       ^\n                           \
    \            ;\n/tmp/tmpjvw7hbuk.swift:13:40: error: expected expression\n  return\
    \ numbers[0..<numbers.count - 1], numbers[numbers.count - 1]\n               \
    \                        ^\n/tmp/tmpjvw7hbuk.swift:12:11: error: cannot use mutating\
    \ member on immutable value: 'numbers' is a 'let' constant\n  numbers.sort { $0\
    \ < $1 }\n  ~~~~~~~ ^\n/tmp/tmpjvw7hbuk.swift:13:17: error: cannot convert return\
    \ expression of type 'ArraySlice<Double>' to return type '(Double, Double)'\n\
    \  return numbers[0..<numbers.count - 1], numbers[numbers.count - 1]\n       \
    \  ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sorted = numbers.sorted()\n    if numbers.count\
    \ <= 1 {\n        return (sorted[0], sorted[0])\n    }\n    var closest1 = sorted[0]\n\
    \    var closest2 = sorted[0]\n    for i in 1 ..< numbers.count {\n        let\
    \ distance = abs(sorted[i] - closest1)\n        if distance < abs(sorted[i] -\
    \ closest2) {\n            closest2 = closest1\n            closest1 = sorted[i]\n\
    \        } else {\n            closest2 = sorted[i]\n        }\n    }\n    return\
    \ (closest1, closest2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpvi6hl5x4/tmpvi6hl5x4.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace329c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace326bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace326ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace326b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvi6hl5x4                        0x000055a3d004380e <unavailable> + 6158

    5    libc.so.6                          0x00002ace32baf460 __libc_start_main +
    245

    6    tmpvi6hl5x4                        0x000055a3d00433c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double.max\n    var largest\
    \ = Double.min\n\n    for i in 0..<numbers.count {\n        var thisNumber = numbers[i]\n\
    \        if thisNumber < smallest {\n            smallest = thisNumber\n     \
    \   }\n\n        if thisNumber > largest {\n            largest = thisNumber\n\
    \        }\n    }\n\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpv29_o9io.swift:9:27: error: type 'Double' has no member 'max'\n\
    \    var smallest = Double.max\n                   ~~~~~~ ^~~\n/tmp/tmpv29_o9io.swift:10:26:\
    \ error: type 'Double' has no member 'min'\n    var largest = Double.min\n   \
    \               ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest_diff = Double.infinity\n \
    \   let smallest_distance = Double.infinity\n    var biggest_diff = Double.infinity\n\
    \    var biggest_distance = Double.infinity\n\n    var smallest_number = numbers[0]\n\
    \    var biggest_number = numbers[0]\n\n    for i in 1..<numbers.count {\n   \
    \     let current_number = numbers[i]\n        let current_diff = abs(current_number\
    \ - biggest_number)\n        let current_distance = abs(current_number - smallest_number)\n\
    \        if current_diff < smallest_diff {\n            smallest_diff = current_diff\n\
    \            smallest_number = current_number\n        }\n\n        if current_distance\
    \ < biggest_distance {\n            biggest_diff = current_diff\n            biggest_number\
    \ = current_number\n        }\n    }\n\n    return (smallest_number, biggest_number)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwuhv514l.swift:22:13: error: cannot assign to value: 'smallest_diff'\
    \ is a 'let' constant\n            smallest_diff = current_diff\n            ^~~~~~~~~~~~~\n\
    /tmp/tmpwuhv514l.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest_diff = Double.infinity\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.count < 2 {\n        return\
    \ (numbers[0], numbers[0])\n    }\n    let minValueIndex = 0\n    let maxValueIndex\
    \ = numbers.count - 1\n\n    var smallestDifference = numbers[0]\n    let smallestElement\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] - numbers[minValueIndex]\
    \ > smallestDifference {\n            smallestDifference = numbers[i] - numbers[minValueIndex]\n\
    \            smallestElement = numbers[i]\n        }\n        if numbers[i] -\
    \ numbers[maxValueIndex] < smallestDifference {\n            smallestDifference\
    \ = numbers[i] - numbers[maxValueIndex]\n            smallestElement = numbers[i]\n\
    \        }\n    }\n    return (smallestElement, numbers[minValueIndex])\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp4rf0urcx.swift:20:13: error: cannot assign to value: 'smallestElement'\
    \ is a 'let' constant\n            smallestElement = numbers[i]\n            ^~~~~~~~~~~~~~~\n\
    /tmp/tmp4rf0urcx.swift:16:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallestElement = numbers[0]\n    ^~~\n    var\n/tmp/tmp4rf0urcx.swift:24:13:\
    \ error: cannot assign to value: 'smallestElement' is a 'let' constant\n     \
    \       smallestElement = numbers[i]\n            ^~~~~~~~~~~~~~~\n/tmp/tmp4rf0urcx.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallestElement = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty() {\n        return\
    \ (numbers[0], numbers[0])\n    }\n\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n\n    for number in numbers {\n        if number > largest {\n\
    \            largest = number\n        } else if number < smallest {\n       \
    \     smallest = number\n        }\n    }\n\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpj8j15rx7.swift:9:16: error: cannot call value of non-function type\
    \ 'Bool'\n    if numbers.isEmpty() {\n               ^      ~~\n             \
    \         \n/tmp/tmpj8j15rx7.swift:18:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = number\n            ^~~~~~~\n/tmp/tmpj8j15rx7.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpj8j15rx7.swift:20:13: error: cannot assign to value:\
    \ 'smallest' is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n\
    /tmp/tmpj8j15rx7.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers, numbers,\
    \ 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp2xurt3hf.swift:9:33: error: extra arguments at positions #2, #3\
    \ in call\n    return find_closest_elements(numbers, numbers, 0)\n           \
    \                     ^\n/tmp/tmp2xurt3hf.swift:8:6: note: 'find_closest_elements(numbers:)'\
    \ declared here\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double)\
    \ {\n     ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        } else if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6_q49vjd.swift:14:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmp6_q49vjd.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmp6_q49vjd.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmp6_q49vjd.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  let sortedArray = numbers.sorted()\n  var\
    \ smallestNumber: Double = 0\n  var largestNumber: Double = Double.greatestFiniteMagnitude\n\
    \  for element in sortedArray {\n    if element < smallestNumber {\n      smallestNumber\
    \ = element\n    } else if element > largestNumber {\n      largestNumber = element\n\
    \    }\n  }\n  return smallestNumber, largestNumber\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa0ak8fkx.swift:19:24: error: consecutive statements on a line must\
    \ be separated by ';'\n  return smallestNumber, largestNumber\n              \
    \         ^\n                       ;\n/tmp/tmpa0ak8fkx.swift:19:24: error: expected\
    \ expression\n  return smallestNumber, largestNumber\n                       ^\n\
    /tmp/tmpa0ak8fkx.swift:19:10: error: cannot convert return expression of type\
    \ 'Double' to return type '(Double, Double)'\n  return smallestNumber, largestNumber\n\
    \         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallestIndex = numbers.index(of: numbers.min())\n\
    \    let largestIndex = numbers.index(of: numbers.max())\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmplu5hol81.swift:9:51: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let smallestIndex = numbers.index(of:\
    \ numbers.min())\n                                                  ^\n/tmp/tmplu5hol81.swift:9:51:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let smallestIndex = numbers.index(of: numbers.min())\n          \
    \                                        ^\n                                 \
    \                       ?? <#default value#>\n/tmp/tmplu5hol81.swift:9:51: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    let smallestIndex = numbers.index(of: numbers.min())\n                  \
    \                                ^\n                                         \
    \              !\n/tmp/tmplu5hol81.swift:10:50: error: value of optional type\
    \ 'Double?' must be unwrapped to a value of type 'Double'\n    let largestIndex\
    \ = numbers.index(of: numbers.max())\n                                       \
    \          ^\n/tmp/tmplu5hol81.swift:10:50: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let largestIndex = numbers.index(of:\
    \ numbers.max())\n                                                 ^\n       \
    \                                                ?? <#default value#>\n/tmp/tmplu5hol81.swift:10:50:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let largestIndex = numbers.index(of: numbers.max())\n           \
    \                                      ^\n                                   \
    \                   !\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double.min\n    var largest\
    \ = Double.max\n\n    guard numbers.count > 0 else {\n        return (0, 0)\n\
    \    }\n\n    numbers.forEach {\n        if $0 < smallest {\n            smallest\
    \ = $0\n        }\n        if $0 > largest {\n            largest = $0\n     \
    \   }\n    }\n\n    return (largest, smallest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpuznfi1vy.swift:9:27: error: type 'Double' has no member 'min'\n\
    \    var smallest = Double.min\n                   ~~~~~~ ^~~\n/tmp/tmpuznfi1vy.swift:10:26:\
    \ error: type 'Double' has no member 'max'\n    var largest = Double.max\n   \
    \               ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers, 0.0,\
    \ numbers[0], numbers[1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp40hqkl1v.swift:9:33: error: extra arguments at positions #2, #3,\
    \ #4 in call\n    return find_closest_elements(numbers, 0.0, numbers[0], numbers[1])\n\
    \                                ^\n/tmp/tmp40hqkl1v.swift:8:6: note: 'find_closest_elements(numbers:)'\
    \ declared here\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double)\
    \ {\n     ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,\
    \ 0.0)\n    }\n\n    var smallest_diff : Double\n    var biggest_diff : Double\n\
    \n    for number in numbers {\n        let diff = abs(number - numbers[0])\n \
    \       if smallest_diff == 0.0 || diff < smallest_diff {\n            smallest_diff\
    \ = diff\n        }\n        if biggest_diff == 0.0 || diff > biggest_diff {\n\
    \            biggest_diff = diff\n        }\n    }\n\n    return (numbers[biggest_diff\
    \ > smallest_diff ? biggest_diff - smallest_diff : 0], numbers[biggest_diff >\
    \ smallest_diff ? 0 : biggest_diff - smallest_diff])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppptt_3pt.swift:26:65: error: result values in '? :' expression\
    \ have mismatching types 'Double' and 'Int'\n    return (numbers[biggest_diff\
    \ > smallest_diff ? biggest_diff - smallest_diff : 0], numbers[biggest_diff >\
    \ smallest_diff ? 0 : biggest_diff - smallest_diff])\n                       \
    \                            ~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n                  \
    \                                 Int(                        )\n/tmp/tmppptt_3pt.swift:26:124:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \    return (numbers[biggest_diff > smallest_diff ? biggest_diff - smallest_diff\
    \ : 0], numbers[biggest_diff > smallest_diff ? 0 : biggest_diff - smallest_diff])\n\
    \                                                                            \
    \                                               ^\n                          \
    \                                                                    Int(    \
    \                                                       )\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers, nil)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxqpbhfnu.swift:9:43: error: extra argument in call\n    return\
    \ find_closest_elements(numbers, nil)\n                                ~~~~~~~~~~^~~~\n\
    /tmp/tmpxqpbhfnu.swift:9:43: error: 'nil' requires a contextual type\n    return\
    \ find_closest_elements(numbers, nil)\n                                      \
    \    ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty() {\n        return\
    \ (0, 0)\n    }\n\n    let sortedNumbers = numbers.sorted()\n    var biggestNumber\
    \ = sortedNumbers[0]\n    var smallestNumber = sortedNumbers[0]\n    let largestIndex\
    \ = sortedNumbers.count - 1\n\n    for (index, number) in sortedNumbers.enumerated()\
    \ {\n        if number < smallestNumber {\n            smallestNumber = number\n\
    \        } else if number > biggestNumber {\n            biggestNumber = number\n\
    \        }\n    }\n\n    let closestResult = (smallestNumber, biggestNumber)\n\
    \    let closestResultIndex = sortedNumbers.index(of: closestResult.0!)!\n   \
    \ return (sortedNumbers[closestResultIndex], sortedNumbers[closestResultIndex\
    \ + 1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmphza4z6wp.swift:9:16: error: cannot call value of non-function type\
    \ 'Bool'\n    if numbers.isEmpty() {\n               ^      ~~\n             \
    \         \n/tmp/tmphza4z6wp.swift:27:69: error: cannot force unwrap value of\
    \ non-optional type 'Double'\n    let closestResultIndex = sortedNumbers.index(of:\
    \ closestResult.0!)!\n                                                     ~~~~~~~~~~~~~~~^\n\
    \                                                                    \n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty { return (0.0, 0.0)\
    \ }\n    guard numbers.count > 1 else { return (numbers[0], numbers[0]) }\n  \
    \  var closest = numbers[0]\n    var minDist = abs(numbers[0])\n    var minIndex\
    \ = numbers.startIndex\n    numbers.enumerated().forEach { (i, n) in\n       \
    \ let dist = abs(n - closest)\n        if dist < minDist {\n            minDist\
    \ = dist\n            minIndex = i\n        }\n    }\n    return (numbers[minIndex],\
    \ closest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpdfyc_3oc/tmpdfyc_3oc.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba97a43cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba97a133b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba97a133988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba97a1327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdfyc_3oc                        0x0000560eb0c4588e <unavailable> + 6286

    5    libc.so.6                          0x00002ba97a628460 __libc_start_main +
    245

    6    tmpdfyc_3oc                        0x0000560eb0c45449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    \n    let min1 = numbers[0]\n    let min2\
    \ = numbers[0]\n    \n    for (index, value) in numbers.enumerated() {\n     \
    \   \n        if value < min1 {\n            min2 = min1\n            min1 = value\n\
    \        }\n        \n        else if value > min2 {\n            min2 = value\n\
    \        }\n        \n        else {\n            min1 = value\n        }\n  \
    \  }\n    \n    return (min1, min2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwssyols_.swift:16:13: error: cannot assign to value: 'min2' is\
    \ a 'let' constant\n            min2 = min1\n            ^~~~\n/tmp/tmpwssyols_.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpwssyols_.swift:17:13: error: cannot assign to value:\
    \ 'min1' is a 'let' constant\n            min1 = value\n            ^~~~\n/tmp/tmpwssyols_.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpwssyols_.swift:21:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = value\n            ^~~~\n/tmp/tmpwssyols_.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpwssyols_.swift:25:13: error: cannot assign to value:\
    \ 'min1' is a 'let' constant\n            min1 = value\n            ^~~~\n/tmp/tmpwssyols_.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty() {\n        return\
    \ (0, 0)\n    }\n    let min = numbers.min()\n    let max = numbers.max()\n  \
    \  if min == max {\n        return (0, 0)\n    }\n    \n    let closestIndex =\
    \ numbers.firstIndex({ abs($0 - min) < abs($0 - max) })\n    let closest = (numbers[closestIndex],\
    \ numbers[closestIndex])\n    if closestIndex < numbers.count - 1 {\n        let\
    \ nextClosestIndex = numbers.firstIndex({ abs($0 - closest) < abs($0 - max) })\n\
    \        let nextClosest = (numbers[nextClosestIndex], numbers[nextClosestIndex])\n\
    \        if nextClosestIndex < numbers.count - 1 {\n            closest = (nextClosest[0],\
    \ nextClosest[1])\n        }\n    }\n    return (closest[0], closest[1])\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp2toa72fv.swift:9:16: error: cannot call value of non-function type\
    \ 'Bool'\n    if numbers.isEmpty() {\n               ^      ~~\n             \
    \         \n/tmp/tmp2toa72fv.swift:18:43: error: missing argument label 'where:'\
    \ in call\n    let closestIndex = numbers.firstIndex({ abs($0 - min) < abs($0\
    \ - max) })\n                                          ^\n                   \
    \                       where: \n/tmp/tmp2toa72fv.swift:18:54: error: value of\
    \ optional type 'Double?' must be unwrapped to a value of type 'Double'\n    let\
    \ closestIndex = numbers.firstIndex({ abs($0 - min) < abs($0 - max) })\n     \
    \                                                ^\n/tmp/tmp2toa72fv.swift:18:54:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let closestIndex = numbers.firstIndex({ abs($0 - min) < abs($0 -\
    \ max) })\n                                                     ^\n          \
    \                                           (   ?? <#default value#>)\n/tmp/tmp2toa72fv.swift:18:54:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let closestIndex = numbers.firstIndex({ abs($0 - min) < abs($0 -\
    \ max) })\n                                                     ^\n          \
    \                                              !\n/tmp/tmp2toa72fv.swift:18:70:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n    let closestIndex = numbers.firstIndex({ abs($0 - min) < abs($0\
    \ - max) })\n                                                                \
    \     ^\n/tmp/tmp2toa72fv.swift:18:70: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n    let closestIndex = numbers.firstIndex({\
    \ abs($0 - min) < abs($0 - max) })\n                                         \
    \                            ^\n                                             \
    \                        (   ?? <#default value#>)\n/tmp/tmp2toa72fv.swift:18:70:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let closestIndex = nu"
  stdout: ''
  timestamp: 1660013868
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let (smallestIndex: Int, smallest: Double,\
    \ largestIndex: Int, largest: Double) = find_closest_indexes(numbers)\n    return\
    \ (numbers[smallestIndex], numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmplg8bbyxa.swift:9:86: error: cannot find 'find_closest_indexes'\
    \ in scope\n    let (smallestIndex: Int, smallest: Double, largestIndex: Int,\
    \ largest: Double) = find_closest_indexes(numbers)\n                         \
    \                                                            ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplg8bbyxa.swift:10:21: error: cannot find 'smallestIndex' in scope\n  \
    \  return (numbers[smallestIndex], numbers[largestIndex])\n                  \
    \  ^~~~~~~~~~~~~\n/tmp/tmplg8bbyxa.swift:10:45: error: cannot find 'largestIndex'\
    \ in scope\n    return (numbers[smallestIndex], numbers[largestIndex])\n     \
    \                                       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            largest = smallest\n            smallest = number\n        } else\
    \ if number > largest {\n            smallest = number\n        }\n    }\n   \
    \ return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpzeo7cqre/tmpzeo7cqre.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b551d01fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b551cd16b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b551cd16988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b551cd157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzeo7cqre                        0x000055813aba464e <unavailable> + 5710

    5    libc.so.6                          0x00002b551d20b460 __libc_start_main +
    245

    6    tmpzeo7cqre                        0x000055813aba4209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  let sortedNumbers = numbers.sorted()\n  return\
    \ (sortedNumbers.first, sortedNumbers.last)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp7_9vmfkv.swift:10:10: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n  return (sortedNumbers.first,\
    \ sortedNumbers.last)\n         ^\n"
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    var index = 0.0\n    \n    for var i = 0; i < numbers.count;\
    \ i++ {\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n\
    \            index = i\n        }\n        else if numbers[i] > largest {\n  \
    \          largest = numbers[i]\n        }\n    }\n\n    return (numbers[index],\
    \ numbers[index+1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpu6d59mu3.swift:13:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < numbers.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpu6d59mu3.swift:23:21: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n    return (numbers[index], numbers[index+1])\n\
    \                    ^\n                    Int( )\n/tmp/tmpu6d59mu3.swift:23:37:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \    return (numbers[index], numbers[index+1])\n                             \
    \       ^\n                                    Int( )\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    precondition(numbers.count > 1, \"find_closest_elements\
    \ requires at least two numbers\")\n    var smallestDifference = Double.nan\n\
    \    var smallestDifferenceIndex = -1\n    var secondSmallestDifference = Double.nan\n\
    \    var secondSmallestDifferenceIndex = -1\n    for i in 0..<numbers.count {\n\
    \        if numbers[i] > numbers[smallestDifferenceIndex] {\n            smallestDifference\
    \ = numbers[i]\n            smallestDifferenceIndex = i\n        }\n        if\
    \ numbers[i] > numbers[secondSmallestDifferenceIndex] {\n            secondSmallestDifference\
    \ = numbers[i]\n            secondSmallestDifferenceIndex = i\n        }\n   \
    \ }\n    return (numbers[smallestDifferenceIndex], numbers[secondSmallestDifferenceIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ff4f17c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ff4c0e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7ff4c0e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7ff4c0e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7ff4c0dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7ff4a0df44 <unavailable> + 188228

    6    tmpe6uzpy3j                        0x0000563b352c9010 <unavailable> + 8208

    7    tmpe6uzpy3j                        0x0000563b352c86ad <unavailable> + 5805

    8    libc.so.6                          0x00002b7ff5103460 __libc_start_main +
    245

    9    tmpe6uzpy3j                        0x0000563b352c8359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    let distances = [(0.0, 0.0)]\n    let smallest\
    \ = numbers[0]\n    let largest = numbers[0]\n    for number in numbers {\n  \
    \      let distance = (number - smallest).squareRoot()\n        distances.append((distance,\
    \ number))\n        if number > largest {\n            largest = number\n    \
    \    }\n        if number < smallest {\n            smallest = number\n      \
    \  }\n    }\n    var smallestIndex = distances.startIndex.advancedBy(0)\n    var\
    \ largestIndex = distances.endIndex.advancedBy(-1)\n    var smallestDistance =\
    \ distances[smallestIndex]\n    var largestDistance = distances[largestIndex]\n\
    \    while largestIndex < distances.endIndex {\n        smallestDistance = distances[smallestIndex]\n\
    \        largestDistance = distances[largestIndex]\n        if largestDistance\
    \ < smallestDistance {\n            smallestIndex = largestIndex\n        }\n\
    \        else {\n            largestIndex = largestIndex.advancedBy(1)\n     \
    \   }\n    }\n    return (largest, smallest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppua5a7_i.swift:17:19: error: cannot use mutating member on immutable\
    \ value: 'distances' is a 'let' constant\n        distances.append((distance,\
    \ number))\n        ~~~~~~~~~ ^\n/tmp/tmppua5a7_i.swift:12:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let distances = [(0.0, 0.0)]\n    ^~~\n   \
    \ var\n/tmp/tmppua5a7_i.swift:19:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = number\n            ^~~~~~~\n/tmp/tmppua5a7_i.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmppua5a7_i.swift:22:13: error: cannot assign to value:\
    \ 'smallest' is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n\
    /tmp/tmppua5a7_i.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmppua5a7_i.swift:25:46:\
    \ error: value of type 'Int' has no member 'advancedBy'\n    var smallestIndex\
    \ = distances.startIndex.advancedBy(0)\n                        ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmppua5a7_i.swift:26:43: error: value of type 'Int' has no\
    \ member 'advancedBy'\n    var largestIndex = distances.endIndex.advancedBy(-1)\n\
    \                       ~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  let min = min(numbers)\n  let max = max(numbers)\n\
    \  return (min.next, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmps1o6hnhb.swift:9:24: error: missing argument for parameter #2 in\
    \ call\n  let min = min(numbers)\n                       ^\n                 \
    \      , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public\
    \ func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n/tmp/tmps1o6hnhb.swift:10:24: error: missing argument for parameter #2\
    \ in call\n  let max = max(numbers)\n                       ^\n              \
    \         , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \n    for number in numbers {\n        if number < min {\n            min = number\n\
    \        } else if number > max {\n            max = number\n        }\n    }\n\
    \n    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpvu0jkjll.swift:14:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = number\n            ^~~\n/tmp/tmpvu0jkjll.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpvu0jkjll.swift:16:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = number\n            ^~~\n/tmp/tmpvu0jkjll.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallestDifference = Double.infinity\n\
    \    var largestDifference = Double.infinity\n    var smallestDiff = Double(numbers[0])\n\
    \    var largestDiff = Double(numbers[0])\n    for number in numbers {\n     \
    \   let diff = Double(number) - smallestDiff\n        if diff < smallestDifference\
    \ {\n            smallestDifference = diff\n            smallestDiff = number\n\
    \        } else {\n            largestDifference = diff\n            largestDiff\
    \ = number\n        }\n    }\n    return (smallestDiff, largestDiff)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp0dnsl_pu.swift:16:13: error: cannot assign to value: 'smallestDifference'\
    \ is a 'let' constant\n            smallestDifference = diff\n            ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0dnsl_pu.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallestDifference = Double.infinity\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var min1 = math.MaxFloat64\n    var min2\
    \ = math.MaxFloat64\n    var minIndex = -1\n    var maxIndex = -1\n    for index\
    \ in stride(from: numbers.count-1, through: 0, by: 1) {\n        let candidate\
    \ = numbers[index]\n        let distance = hypot(candidate-min1, candidate-min2)\n\
    \        if distance < min1 {\n            min1 = distance\n            minIndex\
    \ = index\n        }\n        else if distance < min2 {\n            min2 = distance\n\
    \            minIndex = index\n        }\n    }\n    return (min2, numbers[minIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6xjhrml1.swift:9:16: error: cannot find 'math' in scope\n    var\
    \ min1 = math.MaxFloat64\n               ^~~~\n/tmp/tmp6xjhrml1.swift:10:16: error:\
    \ cannot find 'math' in scope\n    var min2 = math.MaxFloat64\n              \
    \ ^~~~\n/tmp/tmp6xjhrml1.swift:15:24: error: cannot find 'hypot' in scope\n  \
    \      let distance = hypot(candidate-min1, candidate-min2)\n                \
    \       ^~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpafv142ul/tmpafv142ul.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b445fb8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b445f885b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b445f885988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b445f8847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafv142ul                        0x000056106c57c6be <unavailable> + 5822

    5    libc.so.6                          0x00002b445fd7a460 __libc_start_main +
    245

    6    tmpafv142ul                        0x000056106c57c279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty {\n        return (Double(0),\
    \ Double(0))\n    }\n    var result: (Double, Double)\n    let largest = numbers.max()\n\
    \    let smallest = numbers.min()\n    for i in numbers.indices {\n        if\
    \ abs(numbers[i] - largest) < abs(numbers[i] - smallest) {\n            result\
    \ = numbers[i], largest\n        } else if abs(numbers[i] - smallest) < abs(numbers[i]\
    \ - largest) {\n            result = numbers[i], smallest\n        } else {\n\
    \            result = (numbers[i], numbers[i])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpgacm5l9b.swift:17:32: error: consecutive statements on a line must\
    \ be separated by ';'\n            result = numbers[i], largest\n            \
    \                   ^\n                               ;\n/tmp/tmpgacm5l9b.swift:17:32:\
    \ error: expected expression\n            result = numbers[i], largest\n     \
    \                          ^\n/tmp/tmpgacm5l9b.swift:19:32: error: consecutive\
    \ statements on a line must be separated by ';'\n            result = numbers[i],\
    \ smallest\n                               ^\n                               ;\n\
    /tmp/tmpgacm5l9b.swift:19:32: error: expected expression\n            result =\
    \ numbers[i], smallest\n                               ^\n/tmp/tmpgacm5l9b.swift:16:29:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        if abs(numbers[i] - largest) < abs(numbers[i] - smallest)\
    \ {\n                            ^\n/tmp/tmpgacm5l9b.swift:16:29: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if abs(numbers[i] - largest) < abs(numbers[i] - smallest) {\n          \
    \                  ^\n                            (       ?? <#default value#>)\n\
    /tmp/tmpgacm5l9b.swift:16:29: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        if abs(numbers[i] - largest) <\
    \ abs(numbers[i] - smallest) {\n                            ^\n              \
    \                     !\n/tmp/tmpgacm5l9b.swift:16:57: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n        if abs(numbers[i]\
    \ - largest) < abs(numbers[i] - smallest) {\n                                \
    \                        ^\n/tmp/tmpgacm5l9b.swift:16:57: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        if\
    \ abs(numbers[i] - largest) < abs(numbers[i] - smallest) {\n                 \
    \                                       ^\n                                  \
    \                      (        ?? <#default value#>)\n/tmp/tmpgacm5l9b.swift:16:57:\
    \ note: force-unwrap using '!' to abort execu"
  stdout: ''
  timestamp: 1660013866
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  var smallest = numbers[0]\n  var largest\
    \ = numbers[0]\n  for number in numbers {\n    if smallest > number {\n      smallest\
    \ = number\n    }\n    if largest < number {\n      largest = number\n    }\n\
    \  }\n\n  return smallest, largest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpigdlmlse.swift:20:18: error: consecutive statements on a line must\
    \ be separated by ';'\n  return smallest, largest\n                 ^\n      \
    \           ;\n/tmp/tmpigdlmlse.swift:20:18: error: expected expression\n  return\
    \ smallest, largest\n                 ^\n/tmp/tmpigdlmlse.swift:20:10: error:\
    \ cannot convert return expression of type 'Double' to return type '(Double, Double)'\n\
    \  return smallest, largest\n         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  let min = min(numbers)\n  let max = max(numbers)\n\
    \  var closest = (min, max)\n  for (index, value) in numbers.enumerated() {\n\
    \    if value == closest {\n      return (index, value)\n    }\n    if value >\
    \ closest {\n      closest = (index, value)\n    }\n  }\n  return closest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6x1k8p09.swift:9:24: error: missing argument for parameter #2 in\
    \ call\n  let min = min(numbers)\n                       ^\n                 \
    \      , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public\
    \ func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n/tmp/tmp6x1k8p09.swift:10:24: error: missing argument for parameter #2\
    \ in call\n  let max = max(numbers)\n                       ^\n              \
    \         , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp6x1k8p09.swift:14:14: error: cannot convert return expression\
    \ of type '(Int, Double)' to return type '(Double, Double)'\n      return (index,\
    \ value)\n             ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpaeee39nv/tmpaeee39nv.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1059a90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1059787b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1059787988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10597867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaeee39nv                        0x00005586f6c0e69e <unavailable> + 5790

    5    libc.so.6                          0x00002b1059c7c460 __libc_start_main +
    245

    6    tmpaeee39nv                        0x00005586f6c0e259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013689
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (0.0, 0.0) }\n    guard numbers.count <= 6 else { return (0.0, 0.0) }\n    guard\
    \ numbers.count % 2 == 0 else { return (0.0, 0.0) }\n\n    // find the two closest\
    \ elements by moving away from both sides\n    let sortedArray = numbers.sorted()\n\
    \n    let closestLeft = sortedArray[1]\n    let closestRight = sortedArray[numbers.count\
    \ - 2]\n\n    return (closestLeft, closestRight)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpjnuabu85/tmpjnuabu85.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd79b35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd7982cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd7982c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd7982b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjnuabu85                        0x000055e14940366e <unavailable> + 5742

    5    libc.so.6                          0x00002acd79d21460 __libc_start_main +
    245

    6    tmpjnuabu85                        0x000055e149403229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = minElementIndexFrom(numbers)\n\
    \    let max = maxElementIndexFrom(numbers)\n    return (numbers[min], numbers[max])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpna507uxs.swift:9:15: error: cannot find 'minElementIndexFrom' in\
    \ scope\n    let min = minElementIndexFrom(numbers)\n              ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpna507uxs.swift:10:15: error: cannot find 'maxElementIndexFrom' in scope\n\
    \    let max = maxElementIndexFrom(numbers)\n              ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n    return (numbers.min(by: &smallest), numbers.max(by: &largest))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpcnygxi8v.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (numbers.min(by:\
    \ &smallest), numbers.max(by: &largest))\n           ^\n/tmp/tmpcnygxi8v.swift:11:29:\
    \ error: cannot convert value of type 'Double?' to expected argument type '(Double,\
    \ Double) throws -> Bool'\n    return (numbers.min(by: &smallest), numbers.max(by:\
    \ &largest))\n                            ^\n/tmp/tmpcnygxi8v.swift:11:29: error:\
    \ cannot pass immutable value as inout argument: 'smallest' is a 'let' constant\n\
    \    return (numbers.min(by: &smallest), numbers.max(by: &largest))\n        \
    \                    ^~~~~~~~~\n/tmp/tmpcnygxi8v.swift:9:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let smallest = numbers.min()\n    ^~~\n   \
    \ var\n/tmp/tmpcnygxi8v.swift:11:57: error: cannot convert value of type 'Double?'\
    \ to expected argument type '(Double, Double) throws -> Bool'\n    return (numbers.min(by:\
    \ &smallest), numbers.max(by: &largest))\n                                   \
    \                     ^\n/tmp/tmpcnygxi8v.swift:11:57: error: cannot pass immutable\
    \ value as inout argument: 'largest' is a 'let' constant\n    return (numbers.min(by:\
    \ &smallest), numbers.max(by: &largest))\n                                   \
    \                     ^~~~~~~~\n/tmp/tmpcnygxi8v.swift:10:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let largest = numbers.max()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    assert(numbers.count > 2)\n    var smallestNum\
    \ = Double(numbers.first!)\n    var largestNum = Double(numbers.last!)\n    for\
    \ (index, number) in numbers.enumerated() {\n        if (number < smallestNum)\
    \ {\n            smallestNum = number\n        }\n        if number > largestNum\
    \ {\n            largestNum = number\n        }\n    }\n    return (smallestNum,\
    \ largestNum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwvcw7l9e/tmpwvcw7l9e.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b55ee692c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b55ee389b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b55ee389988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b55ee3887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwvcw7l9e                        0x0000560e4a30a91e <unavailable> + 6430

    5    libc.so.6                          0x00002b55ee87e460 __libc_start_main +
    245

    6    tmpwvcw7l9e                        0x0000560e4a30a4d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let largest = numbers.max()\n    var smallest\
    \ = largest\n    var minIndex = 0\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number\n            minIndex = 1\n    \
    \    }\n        if number > largest {\n            largest = number\n        }\n\
    \    }\n    return (numbers[minIndex], largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp3lqqghji.swift:13:21: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        if number < smallest {\n \
    \                   ^\n/tmp/tmp3lqqghji.swift:13:21: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        if number\
    \ < smallest {\n                    ^\n                             ?? <#default\
    \ value#>\n/tmp/tmp3lqqghji.swift:13:21: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        if number < smallest\
    \ {\n                    ^\n                            !\n/tmp/tmp3lqqghji.swift:17:21:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        if number > largest {\n                    ^\n/tmp/tmp3lqqghji.swift:17:21:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if number > largest {\n                    ^\n              \
    \              ?? <#default value#>\n/tmp/tmp3lqqghji.swift:17:21: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ number > largest {\n                    ^\n                           !\n/tmp/tmp3lqqghji.swift:18:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = number\n            ^~~~~~~\n/tmp/tmp3lqqghji.swift:9:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let largest = numbers.max()\n    ^~~\n    var\n\
    /tmp/tmp3lqqghji.swift:21:12: error: cannot convert return expression of type\
    \ '(Double, Double?)' to return type '(Double, Double)'\n    return (numbers[minIndex],\
    \ largest)\n           ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var closestDistance = numbers[0]\n    var\
    \ closestIndex = 0\n    var index = 1\n    var closest = numbers[0]\n\n    for\
    \ number in numbers {\n        if number < closest {\n            closestIndex\
    \ = index\n            closest = number\n        }\n        index += 1\n     \
    \   if closestDistance > abs(closestIndex - index) {\n            closestDistance\
    \ = abs(closestIndex - index)\n            closestIndex = index\n            closest\
    \ = number\n        }\n    }\n    return (closest, closest)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp8airggt3.swift:20:28: error: binary operator '>' cannot be applied\
    \ to operands of type 'Double' and 'Int'\n        if closestDistance > abs(closestIndex\
    \ - index) {\n           ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8airggt3.swift:20:28:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if closestDistance > abs(closestIndex - index) {\n     \
    \                      ^\n/tmp/tmp8airggt3.swift:21:31: error: cannot assign value\
    \ of type 'Int' to type 'Double'\n            closestDistance = abs(closestIndex\
    \ - index)\n                              ^~~~~~~~~~~~~~~~~~~~~~~~~\n        \
    \                      Double(                  )\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers: numbers,\
    \ epsilon: Double.epsilon)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd78w4kgf.swift:9:68: error: extra argument 'epsilon' in call\n\
    \    return find_closest_elements(numbers: numbers, epsilon: Double.epsilon)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~\n\
    /tmp/tmpd78w4kgf.swift:9:68: error: type 'Double' has no member 'epsilon'\n  \
    \  return find_closest_elements(numbers: numbers, epsilon: Double.epsilon)\n \
    \                                                           ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (Double(numbers.first), Double(numbers.first)) }\n\n    var smallest = numbers[0]\n\
    \    var largest = numbers[0]\n    let numbers = numbers.dropFirst()\n    for\
    \ i in 1..numbers.count {\n        let a = numbers[i]\n        if a < smallest\
    \ {\n            smallest = a\n        }\n        if a > largest {\n         \
    \   largest = a\n        }\n    }\n\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp3xkaf7bp.swift:9:60: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    guard numbers.count >= 2 else\
    \ { return (Double(numbers.first), Double(numbers.first)) }\n                \
    \                                           ^\n/tmp/tmp3xkaf7bp.swift:9:60: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    guard numbers.count >= 2 else { return (Double(numbers.first), Double(numbers.first))\
    \ }\n                                                           ^\n          \
    \                                                       ?? <#default value#>\n\
    /tmp/tmp3xkaf7bp.swift:9:60: note: force-unwrap using '!' to abort execution if\
    \ the optional value contains 'nil'\n    guard numbers.count >= 2 else { return\
    \ (Double(numbers.first), Double(numbers.first)) }\n                         \
    \                                  ^\n                                       \
    \                         !\n/tmp/tmp3xkaf7bp.swift:9:83: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n    guard numbers.count\
    \ >= 2 else { return (Double(numbers.first), Double(numbers.first)) }\n      \
    \                                                                            ^\n\
    /tmp/tmp3xkaf7bp.swift:9:83: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    guard numbers.count >= 2 else { return\
    \ (Double(numbers.first), Double(numbers.first)) }\n                         \
    \                                                         ^\n                \
    \                                                                        ?? <#default\
    \ value#>\n/tmp/tmp3xkaf7bp.swift:9:83: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    guard numbers.count >= 2\
    \ else { return (Double(numbers.first), Double(numbers.first)) }\n           \
    \                                                                       ^\n  \
    \                                                                            \
    \         !\n/tmp/tmp3xkaf7bp.swift:"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    precondition(numbers.count > 1, \"Need\
    \ at least two values to find closest to.\")\n\n    var minDistance = Double.infinity\n\
    \    var minIndex = -1\n    var minValue = numbers[0]\n\n    for index in 1..numbers.count\
    \ {\n        let value = numbers[index]\n\n        let distance = abs(value -\
    \ minValue)\n        if distance < minDistance {\n            minDistance = distance\n\
    \            minIndex = index\n            minValue = value\n        }\n    }\n\
    \n    return (minValue, numbers[minIndex])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa2_ewgfc.swift:15:19: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for index in 1..numbers.count {\n                 \
    \ ^~\n                  ...\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let minValue = min(numbers)\n    let maxValue\
    \ = max(numbers)\n    return (minValue, maxValue)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl9h9y9cs.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let minValue = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpl9h9y9cs.swift:10:31: error: missing argument\
    \ for parameter #2 in call\n    let maxValue = max(numbers)\n                \
    \              ^\n                              , <#[Double]#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  let mut min_value = Double(Int.max)\n  let\
    \ mut max_value = Double(-Int.max)\n  for i in 0..<numbers.count {\n    if numbers[i]\
    \ < min_value {\n      min_value = numbers[i]\n    }\n    if numbers[i] > max_value\
    \ {\n      max_value = numbers[i]\n    }\n  }\n  return min_value, max_value\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp25iucaym.swift:9:11: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n  let mut min_value\
    \ = Double(Int.max)\n          ^\n/tmp/tmp25iucaym.swift:9:11: note: join the\
    \ identifiers together\n  let mut min_value = Double(Int.max)\n      ~~~~^~~~~~~~~\n\
    \      mutmin_value\n/tmp/tmp25iucaym.swift:9:11: note: join the identifiers together\
    \ with camel-case\n  let mut min_value = Double(Int.max)\n      ~~~~^~~~~~~~~\n\
    \      mutMin_value\n/tmp/tmp25iucaym.swift:10:11: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \ let mut max_value = Double(-Int.max)\n          ^\n/tmp/tmp25iucaym.swift:10:11:\
    \ note: join the identifiers together\n  let mut max_value = Double(-Int.max)\n\
    \      ~~~~^~~~~~~~~\n      mutmax_value\n/tmp/tmp25iucaym.swift:10:11: note:\
    \ join the identifiers together with camel-case\n  let mut max_value = Double(-Int.max)\n\
    \      ~~~~^~~~~~~~~\n      mutMax_value\n/tmp/tmp25iucaym.swift:19:19: error:\
    \ consecutive statements on a line must be separated by ';'\n  return min_value,\
    \ max_value\n                  ^\n                  ;\n/tmp/tmp25iucaym.swift:19:19:\
    \ error: expected expression\n  return min_value, max_value\n                \
    \  ^\n/tmp/tmp25iucaym.swift:10:7: error: invalid redeclaration of 'mut'\n  let\
    \ mut max_value = Double(-Int.max)\n      ^\n/tmp/tmp25iucaym.swift:9:7: note:\
    \ 'mut' previously declared here\n  let mut min_value = Double(Int.max)\n    \
    \  ^\n/tmp/tmp25iucaym.swift:12:21: error: cannot find 'min_value' in scope\n\
    \    if numbers[i] < min_value {\n                    ^~~~~~~~~\n/tmp/tmp25iucaym.swift:13:7:\
    \ error: cannot find 'min_value' in scope\n      min_value = numbers[i]\n    \
    \  ^~~~~~~~~\n/tmp/tmp25iucaym.swift:15:21: error: cannot find 'max_value' in\
    \ scope\n    if numbers[i] > max_value {\n                    ^~~~~~~~~\n/tmp/tmp25iucaym.swift:16:7:\
    \ error: cannot find 'max_value' in scope\n      max_value = numbers[i]\n    \
    \  ^~~~~~~~~\n/tmp/tmp25iucaym.swift:19:10: error: cannot find 'min_value' in\
    \ scope\n  return min_value, max_v"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   print(\"find_closest_elements expects at least two numbers\")\n        return\
    \ (numbers[0], numbers[0])\n    }\n\n    var smallest = Double(numbers[0])\n \
    \   var largest = Double(numbers[0])\n\n    for i in 1..<numbers.count {\n   \
    \     let current = numbers[i]\n        let currentDistance = current - largest\n\
    \        let currentDistanceAbs = abs(currentDistance)\n        if currentDistanceAbs\
    \ > largest.absValue {\n            largest = current\n        }\n        if currentDistanceAbs\
    \ < smallest.absValue {\n            smallest = current\n        }\n    }\n\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpnlymjvve.swift:21:41: error: value of type 'Double' has no member\
    \ 'absValue'\n        if currentDistanceAbs > largest.absValue {\n           \
    \                     ~~~~~~~ ^~~~~~~~\n/tmp/tmpnlymjvve.swift:24:42: error: value\
    \ of type 'Double' has no member 'absValue'\n        if currentDistanceAbs < smallest.absValue\
    \ {\n                                ~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // Check that the input array has at least\
    \ 2 elements.\n    guard numbers.count >= 2 else {\n        return (Double(0.0),\
    \ Double(0.0)) }\n\n    // Check that the input array has at least 2 elements.\n\
    \    guard numbers.count > 1 else {\n        return (numbers[0], numbers[0]) }\n\
    \n    // Find the two closest numbers to the two elements at the head of the input\
    \ array.\n    var smallestDistance = Double(Double.greatestFiniteMagnitude)\n\
    \    var secondSmallestDistance = Double(Double.greatestFiniteMagnitude)\n   \
    \ var smallestIndex = -1\n    var secondSmallestIndex = -1\n    for (i in 0..<numbers.count)\
    \ {\n        let distance = abs(numbers[i] - numbers[smallestIndex])\n       \
    \ if smallestIndex == -1 || distance < smallestDistance {\n            smallestIndex\
    \ = i\n            smallestDistance = distance }\n        distance = abs(numbers[i]\
    \ - numbers[secondSmallestIndex])\n        if secondSmallestIndex == -1 || distance\
    \ < secondSmallestDistance {\n            secondSmallestIndex = i\n          \
    \  secondSmallestDistance = distance }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[secondSmallestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkr3ocacq.swift:22:12: error: expected ',' separator\n    for (i\
    \ in 0..<numbers.count) {\n           ^\n          ,\n/tmp/tmpkr3ocacq.swift:22:12:\
    \ error: expected pattern\n    for (i in 0..<numbers.count) {\n           ^\n\
    /tmp/tmpkr3ocacq.swift:22:34: error: expected 'in' after for-each pattern\n  \
    \  for (i in 0..<numbers.count) {\n                                 ^\n/tmp/tmpkr3ocacq.swift:22:34:\
    \ error: expected Sequence expression for for-each loop\n    for (i in 0..<numbers.count)\
    \ {\n                                 ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty {\n        fatalError(\"\
    Cannot find closest element for an empty array\")\n    }\n\n    if numbers.count\
    \ < 2 {\n        fatalError(\"Must have at least two numbers to find closest elements\"\
    )\n    }\n\n    var min = numbers[0]\n    var max = numbers[0]\n    for element\
    \ in numbers {\n        if element < min {\n            min = element\n      \
    \  }\n        if element > max {\n            max = element\n        }\n    }\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpc5xlvnu8/tmpc5xlvnu8.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b35bd132c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b35bce29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b35bce29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b35bce287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc5xlvnu8                        0x00005570ad1e377e <unavailable> + 6014

    5    libc.so.6                          0x00002b35bd31e460 __libc_start_main +
    245

    6    tmpc5xlvnu8                        0x00005570ad1e3339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = Double(numbers.first!)\n    let\
    \ max = Double(numbers.last!)\n    return (min, max)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp73pfnnfb/tmp73pfnnfb.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4839781c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4839478b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4839478988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48394777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp73pfnnfb                        0x0000558df91076ae <unavailable> + 5806

    5    libc.so.6                          0x00002b483996d460 __libc_start_main +
    245

    6    tmp73pfnnfb                        0x0000558df9107269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n\n    for i in 1..numbers.count {\n        let currentNumber =\
    \ numbers[i]\n        let delta = (largest - smallest).abs()\n        if delta\
    \ > currentNumber {\n            largest = currentNumber\n        } else {\n \
    \           smallest = currentNumber\n        }\n    }\n    return smallest, largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfr7pwo1_.swift:21:20: error: consecutive statements on a line must\
    \ be separated by ';'\n    return smallest, largest\n                   ^\n  \
    \                 ;\n/tmp/tmpfr7pwo1_.swift:21:20: error: expected expression\n\
    \    return smallest, largest\n                   ^\n/tmp/tmpfr7pwo1_.swift:12:15:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n    for i in\
    \ 1..numbers.count {\n              ^~\n              ...\n/tmp/tmpfr7pwo1_.swift:21:12:\
    \ error: cannot convert return expression of type 'Double' to return type '(Double,\
    \ Double)'\n    return smallest, largest\n           ^~~~~~~~\n/tmp/tmpfr7pwo1_.swift:14:42:\
    \ error: value of type 'Double' has no member 'abs'\n        let delta = (largest\
    \ - smallest).abs()\n                    ~~~~~~~~~~~~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // If one or both of the array elements\
    \ is NaN, return them in order (smaller number, larger number).\n    if numbers[0].isNaN\
    \ || numbers[1].isNaN {\n        if numbers[0].isNaN {\n            return numbers[1],\
    \ numbers[1]\n        } else {\n            return numbers[0], numbers[0]\n  \
    \      }\n    }\n\n    // Store the difference between the two array elements.\n\
    \    var difference = numbers[0] - numbers[1]\n\n    // If difference is greater\
    \ than or equal to 0.5, return them as they are.\n    if difference >= 0.5 {\n\
    \        return numbers[0], numbers[0]\n    }\n\n    // Otherwise find the smallest\
    \ distance and swap the elements. Return that one in order (smaller number,\n\
    \    // larger number).\n    var minDistance = Double.infinity\n    var minNumber\
    \ = numbers[0]\n    for i in 0..<numbers.count {\n        if numbers[i] != numbers[0]\
    \ {\n            let distance = abs(numbers[i] - numbers[1])\n            if distance\
    \ < minDistance {\n                minDistance = distance\n                minNumber\
    \ = numbers[i]\n            }\n        }\n    }\n\n    return minNumber, minNumber\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppedpp_jm.swift:12:30: error: consecutive statements on a line must\
    \ be separated by ';'\n            return numbers[1], numbers[1]\n           \
    \                  ^\n                             ;\n/tmp/tmppedpp_jm.swift:12:30:\
    \ error: expected expression\n            return numbers[1], numbers[1]\n    \
    \                         ^\n/tmp/tmppedpp_jm.swift:14:30: error: consecutive\
    \ statements on a line must be separated by ';'\n            return numbers[0],\
    \ numbers[0]\n                             ^\n                             ;\n\
    /tmp/tmppedpp_jm.swift:14:30: error: expected expression\n            return numbers[0],\
    \ numbers[0]\n                             ^\n/tmp/tmppedpp_jm.swift:23:26: error:\
    \ consecutive statements on a line must be separated by ';'\n        return numbers[0],\
    \ numbers[0]\n                         ^\n                         ;\n/tmp/tmppedpp_jm.swift:23:26:\
    \ error: expected expression\n        return numbers[0], numbers[0]\n        \
    \                 ^\n/tmp/tmppedpp_jm.swift:40:21: error: consecutive statements\
    \ on a line must be separated by ';'\n    return minNumber, minNumber\n      \
    \              ^\n                    ;\n/tmp/tmppedpp_jm.swift:40:21: error:\
    \ expected expression\n    return minNumber, minNumber\n                    ^\n\
    /tmp/tmppedpp_jm.swift:12:27: error: cannot convert return expression of type\
    \ 'Double' to return type '(Double, Double)'\n            return numbers[1], numbers[1]\n\
    \                   ~~~~~~~^~~\n/tmp/tmppedpp_jm.swift:14:27: error: cannot convert\
    \ return expression of type 'Double' to return type '(Double, Double)'\n     \
    \       return numbers[0], numbers[0]\n                   ~~~~~~~^~~\n/tmp/tmppedpp_jm.swift:23:23:\
    \ error: cannot convert return expression of type 'Double' to return type '(Double,\
    \ Double)'\n        return numbers[0], numbers[0]\n               ~~~~~~~^~~\n\
    /tmp/tmppedpp_jm.swift:40:12: error: cannot convert return expression of type\
    \ 'Double' to return type '(Double, Double)'\n    return minNumber, minNumber\n\
    \           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    assert(numbers.count > 2)\n    let min\
    \ = numbers[0]\n    let max = numbers[0]\n    for num in numbers {\n        if\
    \ num < min {\n            min = num\n        }\n        if num > max {\n    \
    \        max = num\n        }\n    }\n\n    return (min, max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp0sar6cvx.swift:14:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = num\n            ^~~\n/tmp/tmp0sar6cvx.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmp0sar6cvx.swift:17:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = num\n            ^~~\n/tmp/tmp0sar6cvx.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else { return (0.0,\
    \ 0.0) }\n\n    let smallest = numbers.min()\n    let largest = numbers.max()\n\
    \n    if smallest == largest {\n        return smallest, smallest\n    }\n\n \
    \   var smallestDifference = largest\n    var largestDifference = smallest\n\n\
    \    for number in numbers {\n        let difference = abs(number - smallest)\n\
    \        if smallestDifference > difference {\n            smallestDifference\
    \ = difference\n            smallest = number\n        }\n\n        if largestDifference\
    \ < difference {\n            largestDifference = difference\n            largest\
    \ = number\n        }\n    }\n\n    return (smallest, largest)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppcjmc4kj.swift:15:24: error: consecutive statements on a line must\
    \ be separated by ';'\n        return smallest, smallest\n                   \
    \    ^\n                       ;\n/tmp/tmppcjmc4kj.swift:15:24: error: expected\
    \ expression\n        return smallest, smallest\n                       ^\n/tmp/tmppcjmc4kj.swift:15:16:\
    \ error: cannot convert return expression of type 'Double?' to return type '(Double,\
    \ Double)'\n        return smallest, smallest\n               ^~~~~~~~\n/tmp/tmppcjmc4kj.swift:22:39:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        let difference = abs(number - smallest)\n                \
    \                      ^\n/tmp/tmppcjmc4kj.swift:22:39: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        let difference\
    \ = abs(number - smallest)\n                                      ^\n        \
    \                              (        ?? <#default value#>)\n/tmp/tmppcjmc4kj.swift:22:39:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let difference = abs(number - smallest)\n                   \
    \                   ^\n                                              !\n/tmp/tmppcjmc4kj.swift:23:12:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        if smallestDifference > difference {\n           ^\n/tmp/tmppcjmc4kj.swift:23:12:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if smallestDifference > difference {\n           ^\n        \
    \                      ?? <#default value#>\n/tmp/tmppcjmc4kj.swift:23:12: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        if smallestDifference > difference {\n           ^\n                \
    \             !\n/tmp/tmppcjmc4kj.swift:25:13: error: cannot assign to value:\
    \ 'smallest' is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n\
    /tmp/tmppcjmc4kj.swift:11:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numb"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    guard numbers.count <= 2 else { return (0.0, 0.0)\
    \ }\n    guard numbers.count >= numbers.indices.count else { return (0.0, 0.0)\
    \ }\n    let max1 = numbers[numbers.indices.last!]\n    let min1 = numbers[numbers.indices.first!]\n\
    \    let max2 = numbers[numbers.indices.last!]\n    let min2 = numbers[numbers.indices.first!]\n\
    \n    let index1 = numbers.indices.index(of: max1)\n    let index2 = numbers.indices.index(of:\
    \ min2)\n\n    let x = max2 - min2\n    let y = max1 - min1\n\n    return (x:\
    \ x, y: y)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptprf8rye.swift:19:44: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Range<Array<Double>.Index>.Element' (aka 'Int')\n\
    \    let index1 = numbers.indices.index(of: max1)\n                          \
    \                 ^\n                                           Range<Array<Double>.Index>.Element(\
    \ )\n/tmp/tmptprf8rye.swift:20:44: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Range<Array<Double>.Index>.Element' (aka 'Int')\n\
    \    let index2 = numbers.indices.index(of: min2)\n                          \
    \                 ^\n                                           Range<Array<Double>.Index>.Element(\
    \ )\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty() {\n        return\
    \ (numbers[0], numbers[0])\n    }\n    if numbers.count == 2 {\n        return\
    \ numbers[0], numbers[1]\n    }\n    numbers.sort()\n    if numbers[0] < numbers[1]\
    \ {\n        return (numbers[0], numbers[1])\n    }\n    return (numbers[1], numbers[0])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpyjarw_ri.swift:13:26: error: consecutive statements on a line must\
    \ be separated by ';'\n        return numbers[0], numbers[1]\n               \
    \          ^\n                         ;\n/tmp/tmpyjarw_ri.swift:13:26: error:\
    \ expected expression\n        return numbers[0], numbers[1]\n               \
    \          ^\n/tmp/tmpyjarw_ri.swift:9:16: error: cannot call value of non-function\
    \ type 'Bool'\n    if numbers.isEmpty() {\n               ^      ~~\n        \
    \              \n/tmp/tmpyjarw_ri.swift:13:23: error: cannot convert return expression\
    \ of type 'Double' to return type '(Double, Double)'\n        return numbers[0],\
    \ numbers[1]\n               ~~~~~~~^~~\n/tmp/tmpyjarw_ri.swift:15:13: error:\
    \ cannot use mutating member on immutable value: 'numbers' is a 'let' constant\n\
    \    numbers.sort()\n    ~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let minDiff = Double.greatestFiniteMagnitude\n\
    \    var minValue = numbers[0]\n    var maxValue = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        let diff: Double = abs(numbers[i] - minValue)\n        if diff <\
    \ minDiff {\n            minDiff = diff\n            minValue = numbers[i]\n \
    \       } else {\n            maxValue = numbers[i]\n        }\n    }\n    return\
    \ minValue, maxValue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjub33vsg.swift:21:20: error: consecutive statements on a line must\
    \ be separated by ';'\n    return minValue, maxValue\n                   ^\n \
    \                  ;\n/tmp/tmpjub33vsg.swift:21:20: error: expected expression\n\
    \    return minValue, maxValue\n                   ^\n/tmp/tmpjub33vsg.swift:15:13:\
    \ error: cannot assign to value: 'minDiff' is a 'let' constant\n            minDiff\
    \ = diff\n            ^~~~~~~\n/tmp/tmpjub33vsg.swift:9:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let minDiff = Double.greatestFiniteMagnitude\n\
    \    ^~~\n    var\n/tmp/tmpjub33vsg.swift:21:12: error: cannot convert return\
    \ expression of type 'Double' to return type '(Double, Double)'\n    return minValue,\
    \ maxValue\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let largest = numbers.reduce(maxElement)\n\
    \    let smallest = numbers.reduce(minElement)\n    let smallerNumber = largest\
    \ - smallest + 1.0\n    if smallerNumber > 1.0 {\n        return (numbers[0],\
    \ numbers[0])\n    }\n    if smallerNumber < 1.0 {\n        return (numbers[-1],\
    \ numbers[-1])\n    }\n    for (i, number) in enumerate(numbers) {\n        if\
    \ number - largest < smallest - number {\n            return (numbers[i], numbers[i])\n\
    \        }\n    }\n    return (numbers[-1], numbers[-1])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpt3e9nwcc.swift:9:34: error: cannot find 'maxElement' in scope\n\
    \    let largest = numbers.reduce(maxElement)\n                              \
    \   ^~~~~~~~~~\n/tmp/tmpt3e9nwcc.swift:9:44: error: missing argument for parameter\
    \ #2 in call\n    let largest = numbers.reduce(maxElement)\n                 \
    \                          ^\n                                           , <#(_,\
    \ Double) throws -> _#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n \
    \   @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult:\
    \ (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n/tmp/tmpt3e9nwcc.swift:10:35: error: cannot find\
    \ 'minElement' in scope\n    let smallest = numbers.reduce(minElement)\n     \
    \                             ^~~~~~~~~~\n/tmp/tmpt3e9nwcc.swift:10:45: error:\
    \ missing argument for parameter #2 in call\n    let smallest = numbers.reduce(minElement)\n\
    \                                            ^\n                             \
    \               , <#(_, Double) throws -> _#>\nSwift.Sequence:2:28: note: 'reduce'\
    \ declared here\n    @inlinable public func reduce<Result>(_ initialResult: Result,\
    \ _ nextPartialResult: (_ partialResult: Result, Self.Element) throws -> Result)\
    \ rethrows -> Result\n                           ^\n/tmp/tmpt3e9nwcc.swift:11:44:\
    \ error: binary operator '+' cannot be applied to operands of type 'Duration'\
    \ and 'Double'\n    let smallerNumber = largest - smallest + 1.0\n           \
    \             ~~~~~~~~~~~~~~~~~~ ^ ~~~\n/tmp/tmpt3e9nwcc.swift:11:44: note: overloads\
    \ for '+' exist with these partially matching parameter lists: (Double, Double),\
    \ (Duration, Duration)\n    let smallerNumber = largest - smallest + 1.0\n   \
    \                                        ^\n/tmp/tmpt3e9nwcc.swift:18:24: error:\
    \ cannot find 'enumerate' in scope\n    for (i, number) in enumerate(numbers)\
    \ {\n                       ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallestNum = numbers.min()!\n    let\
    \ largestNum = numbers.max()!\n\n    var smallest = largestNum\n    var largest\
    \ = smallestNum\n\n    for (index, value) in numbers.enumerated() {\n        if\
    \ value < smallest {\n            smallest = value\n        }\n        if value\
    \ > largest {\n            largest = value\n        }\n    }\n\n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpci4izbjj/tmpci4izbjj.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab7e1d19c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab7e1a10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab7e1a10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7e1a0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpci4izbjj                        0x000055fdfa81983e <unavailable> + 6206

    5    libc.so.6                          0x00002ab7e1f05460 __libc_start_main +
    245

    6    tmpci4izbjj                        0x000055fdfa8193f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers: numbers,\
    \ min: Double(Double.infinity), max: Double(-Double.infinity))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp7v4qtf2s.swift:9:33: error: extra arguments at positions #2, #3\
    \ in call\n    return find_closest_elements(numbers: numbers, min: Double(Double.infinity),\
    \ max: Double(-Double.infinity))\n                                ^\n/tmp/tmp7v4qtf2s.swift:8:6:\
    \ note: 'find_closest_elements(numbers:)' declared here\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n     ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let max = numbers.max()\n    let min =\
    \ numbers.min()\n    return (min < max ? min : max, max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpr1591od9.swift:11:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (min\
    \ < max ? min : max, max)\n           ^\n/tmp/tmpr1591od9.swift:11:19: error:\
    \ value of optional type 'Double?' must be unwrapped to a value of type 'Double'\n\
    \    return (min < max ? min : max, max)\n                  ^\n/tmp/tmpr1591od9.swift:11:19:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return (min < max ? min : max, max)\n                  ^\n      \
    \                ?? <#default value#>\n/tmp/tmpr1591od9.swift:11:19: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ (min < max ? min : max, max)\n                  ^\n                     !\n\
    /tmp/tmpr1591od9.swift:11:13: error: value of optional type 'Double?' must be\
    \ unwrapped to a value of type 'Double'\n    return (min < max ? min : max, max)\n\
    \            ^\n/tmp/tmpr1591od9.swift:11:13: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    return (min < max ? min\
    \ : max, max)\n            ^\n                ?? <#default value#>\n/tmp/tmpr1591od9.swift:11:13:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return (min < max ? min : max, max)\n            ^\n            \
    \   !\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty { return (0.0, 0.0)\
    \ }\n    let closestIndex = numbers.index(of: numbers.min)!\n    let lowValue\
    \ = numbers[closestIndex]\n    let highValue = numbers[closestIndex + 1]\n   \
    \ return (lowValue, highValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd8xeiq12.swift:10:50: error: cannot convert value of type '() ->\
    \ Double?' to expected argument type 'Double'\n    let closestIndex = numbers.index(of:\
    \ numbers.min)!\n                                                 ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var largest = numbers[0]\n    var smallest\
    \ = numbers[0]\n    for number in numbers {\n        if number > largest {\n \
    \           largest = number\n        }\n        if number < smallest {\n    \
    \        smallest = number\n        }\n    }\n    return (largest, smallest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmprwgyczm0/tmprwgyczm0.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2442f9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2442c95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2442c95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2442c947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprwgyczm0                        0x0000558e0620164e <unavailable> + 5710

    5    libc.so.6                          0x00002b244318a460 __libc_start_main +
    245

    6    tmprwgyczm0                        0x0000558e06201209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    \n    let min = numbers.min()\n    let\
    \ max = numbers.max()\n    \n    return min < max ? (min, max) : ((max+min)/2,\
    \ max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpfdlt0fto.swift:13:18: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    return min < max ? (min, max)\
    \ : ((max+min)/2, max)\n                 ^\n/tmp/tmpfdlt0fto.swift:13:18: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    return min < max ? (min, max) : ((max+min)/2, max)\n                 ^\n\
    \                     ?? <#default value#>\n/tmp/tmpfdlt0fto.swift:13:18: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    return min < max ? (min, max) : ((max+min)/2, max)\n                 ^\n\
    \                    !\n/tmp/tmpfdlt0fto.swift:13:12: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n    return min\
    \ < max ? (min, max) : ((max+min)/2, max)\n           ^\n/tmp/tmpfdlt0fto.swift:13:12:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return min < max ? (min, max) : ((max+min)/2, max)\n           ^\n\
    \               ?? <#default value#>\n/tmp/tmpfdlt0fto.swift:13:12: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ min < max ? (min, max) : ((max+min)/2, max)\n           ^\n              !\n\
    /tmp/tmpfdlt0fto.swift:13:24: error: cannot convert return expression of type\
    \ '(Double?, Double?)' to return type '(Double, Double)'\n    return min < max\
    \ ? (min, max) : ((max+min)/2, max)\n                       ^\n/tmp/tmpfdlt0fto.swift:13:37:\
    \ error: cannot convert return expression of type '(Double, Double?)' to return\
    \ type '(Double, Double)'\n    return min < max ? (min, max) : ((max+min)/2, max)\n\
    \                                    ^\n/tmp/tmpfdlt0fto.swift:13:39: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   return min < max ? (min, max) : ((max+min)/2, max)\n                     \
    \                 ^\n/tmp/tmpfdlt0fto.swift:13:39: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n    return min < max\
    \ ? (min, max) : ((max+min)/"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var minNum = numbers[0]\n    var maxNum\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < minNum\
    \ {\n            minNum = numbers[i]\n        } else if numbers[i] > maxNum {\n\
    \            maxNum = numbers[i]\n        }\n    }\n    return (minNum, maxNum)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp9uptpshs/tmp9uptpshs.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a6b672c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a6b369b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a6b369988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a6b3687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9uptpshs                        0x00005605e1e6d6be <unavailable> + 5822

    5    libc.so.6                          0x00002b8a6b85e460 __libc_start_main +
    245

    6    tmp9uptpshs                        0x00005605e1e6d279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  assert(numbers.count > 1, \"There must be\
    \ at least two numbers to compare\")\n  return find_closest_elements(numbers:\
    \ numbers, results: [], min: Float64(numbers.first!), max: Float64(numbers.last!))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp3y5mq344.swift:10:31: error: extra arguments at positions #2, #3,\
    \ #4 in call\n  return find_closest_elements(numbers: numbers, results: [], min:\
    \ Float64(numbers.first!), max: Float64(numbers.last!))\n                    \
    \          ^\n/tmp/tmp3y5mq344.swift:8:6: note: 'find_closest_elements(numbers:)'\
    \ declared here\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double)\
    \ {\n     ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty { return }\n    let\
    \ minA = numbers.min()\n    let minB = numbers.min()\n    var min: Double?\n \
    \   var minIndex: Int?\n    for n in numbers {\n        let d = n - minA\n   \
    \     if d < min {\n            min = d\n            minIndex = 0\n        } else\
    \ if d > min-B {\n            min = d\n            minIndex = 1\n        }\n \
    \   }\n    if minIndex == 0 { return (numbers[0], numbers[0]) }\n    if minIndex\
    \ == 1 { return (numbers[0], numbers[1]) }\n    if minIndex == 2 {\n        return\
    \ numbers[minIndex]\n    }\n    return (numbers[minIndex], numbers[minIndex+1])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzqte5xi5.swift:9:26: error: non-void function should return a value\n\
    \    if numbers.isEmpty { return }\n                         ^\n/tmp/tmpzqte5xi5.swift:15:21:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        let d = n - minA\n                    ^\n/tmp/tmpzqte5xi5.swift:10:9:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n    let minA = numbers.min()\n        ^\n    guard   \
    \                 else { return <#default value#> }\n/tmp/tmpzqte5xi5.swift:10:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let minA = numbers.min()\n                       ^\n            \
    \                 ?? <#default value#>\n/tmp/tmpzqte5xi5.swift:10:24: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let minA\
    \ = numbers.min()\n                       ^\n                            !\n/tmp/tmpzqte5xi5.swift:15:21:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let d = n - minA\n                    ^\n                   \
    \ (    ?? <#default value#>)\n/tmp/tmpzqte5xi5.swift:15:21: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        let\
    \ d = n - minA\n                    ^\n                        !\n/tmp/tmpzqte5xi5.swift:16:16:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        if d < min {\n               ^\n/tmp/tmpzqte5xi5.swift:16:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if d < min {\n               ^\n                   ?? <#default\
    \ value#>\n/tmp/tmpzqte5xi5.swift:16:16: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        if d < min {\n     \
    \          ^\n                  !\n/tmp/tmpzqte5xi5.swift:19:27: error: cannot\
    \ find 'B' in scope\n        } else if d > min-B {\n                         \
    \ ^\n/tmp/tmpzqte5xi5.swift:27:24: error: value of optional type "
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double = -Float.infinity\n\
    \    var largest: Double = Float.infinity\n    for i in numbers.indices {\n  \
    \      if numbers[i] < smallest {\n            smallest = numbers[i]\n       \
    \ } else if numbers[i] > largest {\n            largest = numbers[i]\n       \
    \ }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpx13c3up9.swift:9:28: error: cannot convert value of type 'Float'\
    \ to specified type 'Double'\n    var smallest: Double = -Float.infinity\n   \
    \                        ^~~~~~~~~~~~~~~\n                           Double( \
    \       )\n/tmp/tmpx13c3up9.swift:10:33: error: cannot convert value of type 'Float'\
    \ to specified type 'Double'\n    var largest: Double = Float.infinity\n     \
    \                     ~~~~~~^~~~~~~~\n                          Double(      \
    \ )\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers: numbers,\
    \ epsilon: 0.001)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp__zm7606.swift:9:61: error: extra argument 'epsilon' in call\n\
    \    return find_closest_elements(numbers: numbers, epsilon: 0.001)\n        \
    \                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min: Double\n    let max: Double\n\
    \    if numbers.count <= 2 {\n        return (numbers[0], numbers[0])\n    }\n\
    \    let smallest = numbers[0]\n    let largest = numbers[0]\n    for number in\
    \ numbers {\n        if number < smallest {\n            smallest = number\n \
    \       }\n        if number > largest {\n            largest = number\n     \
    \   }\n    }\n    if smallest == largest {\n        return (smallest, smallest)\n\
    \    }\n    for (index, number) in numbers.enumerated() {\n        let difference\
    \ = abs(number - largest)\n        if difference < abs(number - smallest) {\n\
    \            min = number\n            max = numbers[index + 1]\n        }\n \
    \   }\n    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpvljj7qyu.swift:18:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpvljj7qyu.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpvljj7qyu.swift:21:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpvljj7qyu.swift:15:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var min1 = numbers[0]\n    var min2 = numbers[0]\n\
    \    var result = numbers[0]\n    for number in numbers {\n        let abs1 =\
    \ abs(number)\n        if abs1 < abs(min1) {\n            min1 = number\n    \
    \    }\n        let abs2 = abs(number)\n        if abs2 < abs(min2) {\n      \
    \      min2 = number\n        }\n        if abs1 > abs2 {\n            result\
    \ = number\n        }\n    }\n    return (result, result)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp5_zhns3l/tmp5_zhns3l.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2717652c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2717349b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2717349988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27173487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5_zhns3l                        0x000055b14ab4c73e <unavailable> + 5950

    5    libc.so.6                          0x00002b271783e460 __libc_start_main +
    245

    6    tmp5_zhns3l                        0x000055b14ab4c2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  let numbers_min = min(numbers)\n  let numbers_max\
    \ = max(numbers)\n  let difference = numbers_max - numbers_min\n  let differenceInt\
    \ = Int(difference)\n  var closest = (numbers_min, numbers_max)\n  for number\
    \ in numbers {\n    let diffInt = Int(number) - Int(numbers_min)\n    let diff\
    \ = diffInt / differenceInt\n    if diff < 0 {\n      closest = (number, numbers_max)\n\
    \    } else if diff > 0 {\n      closest = (numbers_min, number)\n    } else {\n\
    \      break\n    }\n  }\n  return closest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp1y6t7xgf.swift:9:32: error: missing argument for parameter #2 in\
    \ call\n  let numbers_min = min(numbers)\n                               ^\n \
    \                              , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp1y6t7xgf.swift:10:32: error: missing argument\
    \ for parameter #2 in call\n  let numbers_max = max(numbers)\n               \
    \                ^\n                               , <#[Double]#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  if numbers.count < 2 {\n    return (numbers[0],\
    \ numbers[1])\n  }\n  \n  var smallestDifference = Double.max\n  var smallestIndex\
    \ = -1\n  var largestDifference = Double.min\n  var largestIndex = -1\n  \n  for\
    \ index in 0 ..< numbers.count - 1 {\n    let difference = numbers[index] - numbers[smallestIndex]\n\
    \    if difference < smallestDifference {\n      smallestDifference = difference\n\
    \      smallestIndex = index\n    }\n    \n    if difference > largestDifference\
    \ {\n      largestDifference = difference\n      largestIndex = index\n    }\n\
    \  }\n  \n  return (numbers[smallestIndex], numbers[largestIndex])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp94jb2x4d.swift:13:35: error: type 'Double' has no member 'max'\n\
    \  var smallestDifference = Double.max\n                           ~~~~~~ ^~~\n\
    /tmp/tmp94jb2x4d.swift:15:34: error: type 'Double' has no member 'min'\n  var\
    \ largestDifference = Double.min\n                          ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sorted = numbers.sorted()\n    return\
    \ (sorted[0], sorted[sorted.count-1])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpne0k1nnl/tmpne0k1nnl.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba4baad8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba4ba7cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba4ba7cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba4ba7ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpne0k1nnl                        0x000055c133ef75de <unavailable> + 5598

    5    libc.so.6                          0x00002ba4bacc4460 __libc_start_main +
    245

    6    tmpne0k1nnl                        0x000055c133ef7199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let n = numbers.count\n    let min1 = numbers[0]\n\
    \    let max1 = numbers[0]\n    for i in 1..<n {\n        let min2 = numbers[i]\n\
    \        let max2 = numbers[i]\n        if min1 < min2 {\n            min1 = min2\n\
    \        }\n        if max1 > max2 {\n            max1 = max2\n        }\n   \
    \ }\n    if min1 == max1 {\n        return (min1, max1)\n    }\n    let min2 =\
    \ numbers[0]\n    let max2 = numbers[0]\n    for i in 1..<n {\n        let min3\
    \ = numbers[i]\n        let max3 = numbers[i]\n        if min2 > min3 {\n    \
    \        min2 = min3\n        }\n        if max2 > max3 {\n            max2 =\
    \ max3\n        }\n    }\n    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpyrmu3p6h.swift:16:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = min2\n            ^~~~\n/tmp/tmpyrmu3p6h.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpyrmu3p6h.swift:19:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = max2\n            ^~~~\n/tmp/tmpyrmu3p6h.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpyrmu3p6h.swift:31:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = min3\n            ^~~~\n/tmp/tmpyrmu3p6h.swift:25:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpyrmu3p6h.swift:34:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = max3\n            ^~~~\n/tmp/tmpyrmu3p6h.swift:26:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    switch numbers.count {\n    case 2:\n \
    \       let min1 = numbers[0]\n        let min2 = numbers[1]\n        let max1\
    \ = numbers[0]\n        let max2 = numbers[1]\n        return find_closest_elements(min1,\
    \ max1, min2, max2)\n    case 3:\n        let min1 = numbers[0]\n        let min2\
    \ = numbers[1]\n        let min3 = numbers[2]\n        let max1 = numbers[0]\n\
    \        let max2 = numbers[1]\n        let max3 = numbers[2]\n        return\
    \ find_closest_elements(min1, max1, min2, max2, min3, max3)\n    case 4:\n   \
    \     let min1 = numbers[0]\n        let min2 = numbers[1]\n        let min3 =\
    \ numbers[2]\n        let min4 = numbers[3]\n        let max1 = numbers[0]\n \
    \       let max2 = numbers[1]\n        let max3 = numbers[2]\n        let max4\
    \ = numbers[3]\n        return find_closest_elements(min1, max1, min2, max2, min3,\
    \ max3, min4, max4)\n    default:\n        return (0.5, 0.5)\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp3t0ur33d.swift:15:37: error: extra arguments at positions #2, #3,\
    \ #4 in call\n        return find_closest_elements(min1, max1, min2, max2)\n \
    \                                   ^\n/tmp/tmp3t0ur33d.swift:8:6: note: 'find_closest_elements(numbers:)'\
    \ declared here\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double)\
    \ {\n     ^\n/tmp/tmp3t0ur33d.swift:15:38: error: cannot convert value of type\
    \ 'Double' to expected argument type '[Double]'\n        return find_closest_elements(min1,\
    \ max1, min2, max2)\n                                     ^\n/tmp/tmp3t0ur33d.swift:23:37:\
    \ error: extra arguments at positions #2, #3, #4, #5, #6 in call\n        return\
    \ find_closest_elements(min1, max1, min2, max2, min3, max3)\n                \
    \                    ^\n/tmp/tmp3t0ur33d.swift:8:6: note: 'find_closest_elements(numbers:)'\
    \ declared here\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double)\
    \ {\n     ^\n/tmp/tmp3t0ur33d.swift:23:38: error: cannot convert value of type\
    \ 'Double' to expected argument type '[Double]'\n        return find_closest_elements(min1,\
    \ max1, min2, max2, min3, max3)\n                                     ^\n/tmp/tmp3t0ur33d.swift:33:37:\
    \ error: extra arguments at positions #2, #3, #4, #5, #6, #7, #8 in call\n   \
    \     return find_closest_elements(min1, max1, min2, max2, min3, max3, min4, max4)\n\
    \                                    ^\n/tmp/tmp3t0ur33d.swift:8:6: note: 'find_closest_elements(numbers:)'\
    \ declared here\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double)\
    \ {\n     ^\n/tmp/tmp3t0ur33d.swift:33:38: error: cannot convert value of type\
    \ 'Double' to expected argument type '[Double]'\n        return find_closest_elements(min1,\
    \ max1, min2, max2, min3, max3, min4, max4)\n                                \
    \     ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // TODO: This can be optimized more and\
    \ we could get rid of some checks\n    if numbers.count < 2 {\n        return\
    \ numbers[0], numbers[1]\n    }\n\n    // TODO: This can be optimized more and\
    \ we could get rid of some checks\n    let sorted_numbers = numbers.sorted()\n\
    \    let first_number = sorted_numbers[0]\n    let second_number = sorted_numbers[1]\n\
    \    if abs(first_number - second_number) < abs(first_number + second_number)\
    \ {\n        return (first_number, second_number)\n    }\n\n    return (second_number,\
    \ first_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptom2q6s5.swift:11:26: error: consecutive statements on a line must\
    \ be separated by ';'\n        return numbers[0], numbers[1]\n               \
    \          ^\n                         ;\n/tmp/tmptom2q6s5.swift:11:26: error:\
    \ expected expression\n        return numbers[0], numbers[1]\n               \
    \          ^\n/tmp/tmptom2q6s5.swift:11:23: error: cannot convert return expression\
    \ of type 'Double' to return type '(Double, Double)'\n        return numbers[0],\
    \ numbers[1]\n               ~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    func smallest(_ numbers: Set<Double>) ->\
    \ Double {\n        var smallest = numbers[0]\n        for number in numbers {\n\
    \            if number < smallest {\n                smallest = number\n     \
    \       }\n        }\n        return smallest\n    }\n\n    func largest(_ numbers:\
    \ Set<Double>) -> Double {\n        var largest = numbers[0]\n        for number\
    \ in numbers {\n            if number > largest {\n                largest = number\n\
    \            }\n        }\n        return largest\n    }\n\n    var smallest_2\
    \ = smallest(numbers)\n    var smallest_1 = smallest(Set(numbers))\n    var smallest_3\
    \ = smallest(numbers.sorted())\n    var smallest_4 = smallest(numbers)\n\n   \
    \ var largest_2 = largest(numbers)\n    var largest_1 = largest(Set(numbers))\n\
    \    var largest_3 = largest(numbers.sorted())\n    var largest_4 = largest(numbers)\n\
    \n    let smallest_elements = Set<Double>(numbers).sorted()\n    let largest_elements\
    \ = Set<Double>(numbers).sorted(by: { $0 > $1 })\n\n    return smallest_1, smallest_2,\
    \ smallest_3, smallest_4, smallest_5, smallest_elements\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp0z5214ad.swift:42:22: error: consecutive statements on a line must\
    \ be separated by ';'\n    return smallest_1, smallest_2, smallest_3, smallest_4,\
    \ smallest_5, smallest_elements\n                     ^\n                    \
    \ ;\n/tmp/tmp0z5214ad.swift:42:22: error: expected expression\n    return smallest_1,\
    \ smallest_2, smallest_3, smallest_4, smallest_5, smallest_elements\n        \
    \             ^\n/tmp/tmp0z5214ad.swift:10:31: error: no exact matches in call\
    \ to subscript \n        var smallest = numbers[0]\n                         \
    \     ^\nSwift.Set:4:23: note: candidate expects value of type 'Set<Double>.Index'\
    \ for parameter #1 (got 'Int')\n    @inlinable public subscript(position: Set<Element>.Index)\
    \ -> Element { get }\n                      ^\nSwift.Collection:2:23: note: candidate\
    \ expects value of type 'Range<Set<Double>.Index>' for parameter #1 (got 'Int')\n\
    \    @inlinable public subscript(bounds: Range<Self.Index>) -> Slice<Self> { get\
    \ }\n                      ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp0z5214ad.swift:20:30: error: no exact matches\
    \ in call to subscript \n        var largest = numbers[0]\n                  \
    \           ^\nSwift.Set:4:23: note: candidate expects value of type 'Set<Double>.Index'\
    \ for parameter #1 (got 'Int')\n    @inlinable public subscript(position: Set<Element>.Index)\
    \ -> Element { get }\n                      ^\nSwift.Collection:2:23: note: candidate\
    \ expects value of type 'Range<Set<Double>.Index>' for parameter #1 (got 'Int')\n\
    \    @inlinable public subscript(bounds: Range<Self.Index>) -> Slice<Self> { get\
    \ }\n                      ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp0z5214ad.swift:29:31: error: cannot conve"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallestDifference = Double.infinity\n\
    \    var smallestDifferenceIndex = -1\n    var smallestDifferenceIndex2 = -1\n\
    \    for (index, value) in numbers.enumerated() {\n        let currentDifference\
    \ = abs(value - numbers[index])\n        if currentDifference < smallestDifference\
    \ {\n            smallestDifference = currentDifference\n            smallestDifferenceIndex\
    \ = index\n        }\n        if currentDifference < smallestDifference {\n  \
    \          smallestDifference = currentDifference\n            smallestDifferenceIndex2\
    \ = index\n        }\n    }\n    return (numbers[smallestDifferenceIndex], numbers[smallestDifferenceIndex2])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp3krlkxht.swift:15:13: error: cannot assign to value: 'smallestDifference'\
    \ is a 'let' constant\n            smallestDifference = currentDifference\n  \
    \          ^~~~~~~~~~~~~~~~~~\n/tmp/tmp3krlkxht.swift:9:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let smallestDifference = Double.infinity\n\
    \    ^~~\n    var\n/tmp/tmp3krlkxht.swift:19:13: error: cannot assign to value:\
    \ 'smallestDifference' is a 'let' constant\n            smallestDifference = currentDifference\n\
    \            ^~~~~~~~~~~~~~~~~~\n/tmp/tmp3krlkxht.swift:9:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let smallestDifference = Double.infinity\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers: numbers,\
    \ index: 0, count: 1, sort: true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpminfl_5r.swift:9:33: error: extra arguments at positions #2, #3,\
    \ #4 in call\n    return find_closest_elements(numbers: numbers, index: 0, count:\
    \ 1, sort: true)\n                                ^\n/tmp/tmpminfl_5r.swift:8:6:\
    \ note: 'find_closest_elements(numbers:)' declared here\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n     ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 2 else { return (numbers[0],\
    \ numbers[0]) }\n    let sortedNumbers = numbers.sorted { $0 < $1 }\n    return\
    \ (sortedNumbers[0], sortedNumbers[1])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp01lmgkrb/tmp01lmgkrb.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f825cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f822c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f822c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f822c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01lmgkrb                        0x0000560d5516d5ae <unavailable> + 5550

    5    libc.so.6                          0x00002b8f827b7460 __libc_start_main +
    245

    6    tmp01lmgkrb                        0x0000560d5516d169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let minIndex = numbers.reduce(0, {$0 +\
    \ $1.distance($2)})\n    return numbers[minIndex], numbers[minIndex + 1]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpp4ifve1o.swift:10:29: error: consecutive statements on a line must\
    \ be separated by ';'\n    return numbers[minIndex], numbers[minIndex + 1]\n \
    \                           ^\n                            ;\n/tmp/tmpp4ifve1o.swift:10:29:\
    \ error: expected expression\n    return numbers[minIndex], numbers[minIndex +\
    \ 1]\n                            ^\n/tmp/tmpp4ifve1o.swift:9:38: error: contextual\
    \ closure type '(Double, Double) throws -> Double' expects 2 arguments, but 3\
    \ were used in closure body\n    let minIndex = numbers.reduce(0, {$0 + $1.distance($2)})\n\
    \                                     ^\n/tmp/tmpp4ifve1o.swift:9:56: error: missing\
    \ argument label 'to:' in call\n    let minIndex = numbers.reduce(0, {$0 + $1.distance($2)})\n\
    \                                                       ^\n                  \
    \                                     to: \n/tmp/tmpp4ifve1o.swift:10:19: error:\
    \ no 'subscript' candidates produce the expected contextual result type '(Double,\
    \ Double)'\n    return numbers[minIndex], numbers[minIndex + 1]\n            \
    \      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the\
    \ expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note:\
    \ 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result\
    \ type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>)\
    \ -> ArraySlice<Element> { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let minimum = numbers.min()\n    let maximum\
    \ = numbers.max()\n    let midpoint = 0.5 * (minimum + maximum)\n    var closest1\
    \ = closestElements(numbers, midpoint)\n    var closest2 = closestElements(numbers,\
    \ midpoint, false)\n    return (closest1, closest2)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpb3hwceq_.swift:11:35: error: binary operator '+' cannot be applied\
    \ to two 'Double?' operands\n    let midpoint = 0.5 * (minimum + maximum)\n  \
    \                        ~~~~~~~ ^ ~~~~~~~\n/tmp/tmpb3hwceq_.swift:11:35: note:\
    \ overloads for '+' exist with these partially matching parameter lists: (Double,\
    \ Double)\n    let midpoint = 0.5 * (minimum + maximum)\n                    \
    \              ^\n/tmp/tmpb3hwceq_.swift:12:20: error: cannot find 'closestElements'\
    \ in scope\n    var closest1 = closestElements(numbers, midpoint)\n          \
    \         ^~~~~~~~~~~~~~~\n/tmp/tmpb3hwceq_.swift:13:20: error: cannot find 'closestElements'\
    \ in scope\n    var closest2 = closestElements(numbers, midpoint, false)\n   \
    \                ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers, .ordered)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpv2g__628.swift:9:44: error: extra argument in call\n    return\
    \ find_closest_elements(numbers, .ordered)\n                                ~~~~~~~~~~~^~~~~~~~\n\
    /tmp/tmpv2g__628.swift:9:44: error: cannot infer contextual base in reference\
    \ to member 'ordered'\n    return find_closest_elements(numbers, .ordered)\n \
    \                                         ~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    if numbers.count < 2 {\n        return sortedNumbers[0], sortedNumbers[0]\n\
    \    }\n    let closestTo1 = sortedNumbers.first!\n    let closestTo2 = sortedNumbers[1]\n\
    \    let closestTo3 = sortedNumbers[2]\n    if closestTo1 <= closestTo2 {\n  \
    \      return closestTo1, closestTo2\n    }\n    if closestTo2 <= closestTo3 {\n\
    \        return closestTo2, closestTo3\n    }\n    if closestTo3 <= closestTo1\
    \ {\n        return closestTo3, closestTo1\n    }\n    return (sortedNumbers[0],\
    \ sortedNumbers[1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkf261v7r.swift:11:32: error: consecutive statements on a line must\
    \ be separated by ';'\n        return sortedNumbers[0], sortedNumbers[0]\n   \
    \                            ^\n                               ;\n/tmp/tmpkf261v7r.swift:11:32:\
    \ error: expected expression\n        return sortedNumbers[0], sortedNumbers[0]\n\
    \                               ^\n/tmp/tmpkf261v7r.swift:17:26: error: consecutive\
    \ statements on a line must be separated by ';'\n        return closestTo1, closestTo2\n\
    \                         ^\n                         ;\n/tmp/tmpkf261v7r.swift:17:26:\
    \ error: expected expression\n        return closestTo1, closestTo2\n        \
    \                 ^\n/tmp/tmpkf261v7r.swift:20:26: error: consecutive statements\
    \ on a line must be separated by ';'\n        return closestTo2, closestTo3\n\
    \                         ^\n                         ;\n/tmp/tmpkf261v7r.swift:20:26:\
    \ error: expected expression\n        return closestTo2, closestTo3\n        \
    \                 ^\n/tmp/tmpkf261v7r.swift:23:26: error: consecutive statements\
    \ on a line must be separated by ';'\n        return closestTo3, closestTo1\n\
    \                         ^\n                         ;\n/tmp/tmpkf261v7r.swift:23:26:\
    \ error: expected expression\n        return closestTo3, closestTo1\n        \
    \                 ^\n/tmp/tmpkf261v7r.swift:11:29: error: cannot convert return\
    \ expression of type 'Double' to return type '(Double, Double)'\n        return\
    \ sortedNumbers[0], sortedNumbers[0]\n               ~~~~~~~~~~~~~^~~\n/tmp/tmpkf261v7r.swift:17:16:\
    \ error: cannot convert return expression of type 'Double' to return type '(Double,\
    \ Double)'\n        return closestTo1, closestTo2\n               ^~~~~~~~~~\n\
    /tmp/tmpkf261v7r.swift:20:16: error: cannot convert return expression of type\
    \ 'Double' to return type '(Double, Double)'\n        return closestTo2, closestTo3\n\
    \               ^~~~~~~~~~\n/tmp/tmpkf261v7r.swift:23:16: error: cannot convert\
    \ return expression of type 'Double' to return type '(Double, Double)'\n     \
    \   return closestTo3, closestTo1\n               ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  return find_closest_elements1(numbers)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjmcbpl1e.swift:9:10: error: cannot find 'find_closest_elements1'\
    \ in scope\n  return find_closest_elements1(numbers)\n         ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var best1 = best2 = Double(numbers[0])\n\
    \    for i in 1..<numbers.count {\n        let candidate = numbers[i]\n      \
    \  if candidate > best1 {\n            best2 = best1\n            best1 = candidate\n\
    \        } else if candidate > best2 {\n            best2 = candidate\n      \
    \  }\n    }\n    return (best1, best2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpb902tbhg.swift:9:17: error: cannot find 'best2' in scope\n    var\
    \ best1 = best2 = Double(numbers[0])\n                ^~~~~\n/tmp/tmpb902tbhg.swift:13:13:\
    \ error: cannot find 'best2' in scope\n            best2 = best1\n           \
    \ ^~~~~\n/tmp/tmpb902tbhg.swift:15:31: error: cannot find 'best2' in scope\n \
    \       } else if candidate > best2 {\n                              ^~~~~\n/tmp/tmpb902tbhg.swift:16:13:\
    \ error: cannot find 'best2' in scope\n            best2 = candidate\n       \
    \     ^~~~~\n/tmp/tmpb902tbhg.swift:19:20: error: cannot find 'best2' in scope\n\
    \    return (best1, best2)\n                   ^~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  let min: Double = Float64(numbers[0])\n \
    \ let max: Double = Float64(numbers[1])\n  let mid: Double = min + ((max - min)\
    \ / 2)\n\n  var result: Double?\n  var minIndex: Int?\n  var maxIndex: Int?\n\n\
    \  for index in 0..<numbers.count {\n    let number: Double = numbers[index]\n\
    \n    if number < mid {\n      if let minIndex = minIndex, number < numbers[minIndex]\
    \ {\n        if result = nil, number < mid {\n          result = number\n    \
    \      minIndex = index\n        }\n      }\n    } else {\n      if let maxIndex\
    \ = maxIndex, number > numbers[maxIndex] {\n        if result = nil, number >\
    \ mid {\n          result = number\n          maxIndex = index\n        }\n  \
    \    }\n    }\n  }\n  guard result != nil else { return (nil, nil) }\n\n  return\
    \ (result ?? maxIndex, result ?? minIndex)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmplsi8pe52.swift:22:19: error: use of '=' in a boolean context, did\
    \ you mean '=='?\n        if result = nil, number < mid {\n           ~~~~~~ ^\
    \ ~~~\n                  ==\n/tmp/tmplsi8pe52.swift:24:11: error: cannot assign\
    \ to value: 'minIndex' is a 'let' constant\n          minIndex = index\n     \
    \     ^~~~~~~~\n/tmp/tmplsi8pe52.swift:29:19: error: use of '=' in a boolean context,\
    \ did you mean '=='?\n        if result = nil, number > mid {\n           ~~~~~~\
    \ ^ ~~~\n                  ==\n/tmp/tmplsi8pe52.swift:31:11: error: cannot assign\
    \ to value: 'maxIndex' is a 'let' constant\n          maxIndex = index\n     \
    \     ^~~~~~~~\n/tmp/tmplsi8pe52.swift:36:38: error: 'nil' requires a contextual\
    \ type\n  guard result != nil else { return (nil, nil) }\n                   \
    \                  ^\n/tmp/tmplsi8pe52.swift:36:43: error: 'nil' requires a contextual\
    \ type\n  guard result != nil else { return (nil, nil) }\n                   \
    \                       ^\n/tmp/tmplsi8pe52.swift:38:21: error: cannot convert\
    \ value of type 'Int?' to expected argument type 'Double'\n  return (result ??\
    \ maxIndex, result ?? minIndex)\n                    ^\n/tmp/tmplsi8pe52.swift:38:41:\
    \ error: cannot convert value of type 'Int?' to expected argument type 'Double'\n\
    \  return (result ?? maxIndex, result ?? minIndex)\n                         \
    \               ^\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallestIndex = -1\n    var largestIndex\
    \ = numbers.count - 1\n\n    var smallestDistance = Double.infinity\n    var largestDistance\
    \ = -Double.infinity\n    for i in 0..<numbers.count {\n        let distance =\
    \ hypot(numbers[i], numbers[largestIndex])\n        if distance < smallestDistance\
    \ {\n            smallestDistance = distance\n            smallestIndex = i\n\
    \        }\n        if distance > largestDistance {\n            largestDistance\
    \ = distance\n            largestIndex = i\n        }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpflus1uu6.swift:15:24: error: cannot find 'hypot' in scope\n   \
    \     let distance = hypot(numbers[i], numbers[largestIndex])\n              \
    \         ^~~~~\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 2 else {\n      \
    \  return (0.0)\n    }\n    let smallestIndex = numbers.index(of: numbers.min())!\n\
    \    let largestIndex = numbers.index(of: numbers.max())!\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpeaxqyk96.swift:10:17: error: cannot convert return expression of\
    \ type 'Double' to return type '(Double, Double)'\n        return (0.0)\n    \
    \           ~^~~~\n/tmp/tmpeaxqyk96.swift:12:51: error: value of optional type\
    \ 'Double?' must be unwrapped to a value of type 'Double'\n    let smallestIndex\
    \ = numbers.index(of: numbers.min())!\n                                      \
    \            ^\n/tmp/tmpeaxqyk96.swift:12:51: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let smallestIndex = numbers.index(of:\
    \ numbers.min())!\n                                                  ^\n     \
    \                                                   ?? <#default value#>\n/tmp/tmpeaxqyk96.swift:12:51:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let smallestIndex = numbers.index(of: numbers.min())!\n         \
    \                                         ^\n                                \
    \                       !\n/tmp/tmpeaxqyk96.swift:13:50: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n    let largestIndex\
    \ = numbers.index(of: numbers.max())!\n                                      \
    \           ^\n/tmp/tmpeaxqyk96.swift:13:50: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let largestIndex = numbers.index(of:\
    \ numbers.max())!\n                                                 ^\n      \
    \                                                 ?? <#default value#>\n/tmp/tmpeaxqyk96.swift:13:50:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let largestIndex = numbers.index(of: numbers.max())!\n          \
    \                                       ^\n                                  \
    \                    !\n"
  stdout: ''
  timestamp: 1660013863
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest: Double = numbers.min()!\n\
    \    let largest: Double = numbers.max()!\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmphi10j7_g/tmphi10j7_g.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b58a3f4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58a3c43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b58a3c43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58a3c427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphi10j7_g                        0x000055dad65da62e <unavailable> + 5678

    5    libc.so.6                          0x00002b58a4138460 __libc_start_main +
    245

    6    tmphi10j7_g                        0x000055dad65da1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty() {\n        return\
    \ (numbers[0], numbers[0])\n    }\n    if numbers.count == 2 {\n        return\
    \ (numbers[0], numbers[1])\n    }\n    if numbers.count == 3 {\n        if numbers[1]\
    \ == numbers[0] {\n            return (numbers[0], numbers[1])\n        }\n  \
    \      if numbers[0] == numbers[1] {\n            return (numbers[0], numbers[1])\n\
    \        }\n    }\n    if numbers.count == 4 {\n        let a = numbers[0]\n \
    \       let b = numbers[1]\n        let c = numbers[2]\n        let d = numbers[3]\n\
    \        var x: Double\n        var y: Double\n        let d = math.sqrt((b -\
    \ a) * (b - a) + (c - d) * (c - d))\n        if d < math.sqrt((b - c) * (b - c)\
    \ + (d - a) * (d - a) + (d - b) * (d - b)) {\n            x = (b + c) / 2.0\n\
    \            y = (d - a) / 2.0\n        } else {\n            x = (b - a) / 2.0\n\
    \            y = (d - b) / 2.0\n        }\n        return (x, y)\n    }\n    if\
    \ numbers.count > 4 {\n        let a = numbers[0]\n        let b = numbers[1]\n\
    \        let c = numbers[2]\n        let d = numbers[3]\n        let e = numbers[4]\n\
    \        var x: Double\n        var y: Double\n        let d = math.sqrt((b -\
    \ a) * (b - a) + (c - d) * (c - d))\n        let e = math.sqrt((e - d) * (e -\
    \ d) + (e - b) * (e - b))\n        if d < math.sqrt((b - c) * (b - c) + (d - a)\
    \ * (d - a) + (d - b) * (d - b) + (e - c) * (e - c)) {\n            x = (b + c)\
    \ / 2.0\n            y = (d - a) / 2.0\n        } else {\n            x = (b -\
    \ a) / 2.0\n            y = (d - b) / 2.0\n        }\n        return (x, y)\n\
    \    }\n    return (numbers[0], numbers[0])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp817sjnkl.swift:9:16: error: cannot call value of non-function type\
    \ 'Bool'\n    if numbers.isEmpty() {\n               ^      ~~\n             \
    \         \n/tmp/tmp817sjnkl.swift:30:17: error: cannot find 'math' in scope\n\
    \        let d = math.sqrt((b - a) * (b - a) + (c - d) * (c - d))\n          \
    \      ^~~~\n/tmp/tmp817sjnkl.swift:31:16: error: cannot find 'math' in scope\n\
    \        if d < math.sqrt((b - c) * (b - c) + (d - a) * (d - a) + (d - b) * (d\
    \ - b)) {\n               ^~~~\n/tmp/tmp817sjnkl.swift:48:17: error: cannot find\
    \ 'math' in scope\n        let d = math.sqrt((b - a) * (b - a) + (c - d) * (c\
    \ - d))\n                ^~~~\n/tmp/tmp817sjnkl.swift:49:17: error: cannot find\
    \ 'math' in scope\n        let e = math.sqrt((e - d) * (e - d) + (e - b) * (e\
    \ - b))\n                ^~~~\n/tmp/tmp817sjnkl.swift:50:16: error: cannot find\
    \ 'math' in scope\n        if d < math.sqrt((b - c) * (b - c) + (d - a) * (d -\
    \ a) + (d - b) * (d - b) + (e - c) * (e - c)) {\n               ^~~~\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    if smallest == largest {\n        return (smallest, smallest)\n\
    \    }\n\n    var closest = (Double(largest), largest)\n    var closestIndex =\
    \ 0\n\n    for i in 0..<numbers.count {\n        if numbers[i] != smallest {\n\
    \            continue\n        }\n\n        let distance = (numbers[i] - closest[0]).squareRoot()\n\
    \        if distance < closest[0].squareRoot() {\n            closest = (numbers[i],\
    \ numbers[i])\n            closestIndex = i\n        }\n    }\n\n    return (closest[0],\
    \ closest[1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpqoah1zwx.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpqoah1zwx.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.count == 0 {\n        return\
    \ (0.5, 0.5)\n    }\n\n    let minDistance = numbers[0]\n    let maxDistance =\
    \ numbers[0]\n\n    for i in 1..<numbers.count {\n        let distance = abs(numbers[i]\
    \ - minDistance)\n        if distance < maxDistance {\n            minDistance\
    \ = numbers[i]\n        } else {\n            maxDistance = numbers[i]\n     \
    \   }\n    }\n\n    return (minDistance, maxDistance)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpueiam490.swift:19:13: error: cannot assign to value: 'minDistance'\
    \ is a 'let' constant\n            minDistance = numbers[i]\n            ^~~~~~~~~~~\n\
    /tmp/tmpueiam490.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let minDistance = numbers[0]\n    ^~~\n    var\n/tmp/tmpueiam490.swift:21:13:\
    \ error: cannot assign to value: 'maxDistance' is a 'let' constant\n         \
    \   maxDistance = numbers[i]\n            ^~~~~~~~~~~\n/tmp/tmpueiam490.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxDistance = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    \n    // TODO: Should this return an error\
    \ if numbers is of length 0?\n    \n    if numbers.count < 2 {\n        return\
    \ (numbers[0], numbers[0])\n    }\n    \n    let arrayCount = numbers.count\n\
    \    \n    // Initialize an array to hold all elements with the same index as\
    \ the first element\n    var array: [Double] = [0]\n    \n    for i in 0..<arrayCount\
    \ {\n        array[i] = numbers[0]\n    }\n    \n    // Now loop through each\
    \ element in numbers array starting with the second element\n    for i in 1..<arrayCount\
    \ {\n        // See if each number is less than the last number in the array\n\
    \        if array[i] < array[i-1] {\n            // If so then just append the\
    \ number\n            array.append(numbers[i])\n        } else {\n           \
    \ // If not then keep a running total and check to see if the total is greater\
    \ than the new number and\n            // then append if so\n            \n  \
    \          // The running total\n            let runningTotal = array[i]\n   \
    \         \n            // The new number\n            let newNumber = numbers[i]\n\
    \            \n            // If the total is greater than the new number then\
    \ update it\n            if runningTotal > newNumber {\n                array[i]\
    \ = newNumber\n            } else {\n                // If the total is less than\
    \ the new number then check to see if the new number is greater than the previous\n\
    \                // number in the array and if it is, then just append the new\
    \ number\n                if array[i] > array[i-1] {\n                    array.append(newNumber)\n\
    \                }\n            }\n        }\n    }\n    \n    // Return the two\
    \ elements\n    return (array[0], array[1])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab11032ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab110021561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab110021286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab11002113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab110020bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab10fe2090c <unavailable> + 186636

    6    tmp2y6gu4ut                        0x0000559726e86fef <unavailable> + 8175

    7    tmp2y6gu4ut                        0x0000559726e8667d <unavailable> + 5757

    8    libc.so.6                          0x00002ab110516460 __libc_start_main +
    245

    9    tmp2y6gu4ut                        0x0000559726e86329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n  let smallest = numbers[0]\n  let largest = numbers[0]\n  for\
    \ number in numbers {\n    if number < smallest { smallest = number }\n    if\
    \ number > largest { largest = number }\n  }\n  return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmprl7s0x8o.swift:13:28: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n    if number < smallest { smallest = number }\n      \
    \                     ^~~~~~~~\n/tmp/tmprl7s0x8o.swift:10:3: note: change 'let'\
    \ to 'var' to make it mutable\n  let smallest = numbers[0]\n  ^~~\n  var\n/tmp/tmprl7s0x8o.swift:14:27:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n    if number\
    \ > largest { largest = number }\n                          ^~~~~~~\n/tmp/tmprl7s0x8o.swift:11:3:\
    \ note: change 'let' to 'var' to make it mutable\n  let largest = numbers[0]\n\
    \  ^~~\n  var\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double.greatestFiniteMagnitude\n\
    \    var largest = Double.leastNormalMagnitude\n    var smallestIndex = 0\n  \
    \  var largestIndex = 0\n\n    for i in 0 ..< numbers.count {\n        let num\
    \ = numbers[i]\n\n        if smallest > num {\n            largest = num\n   \
    \         largestIndex = i\n        } else {\n            smallest = num\n   \
    \         smallestIndex = i\n        }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpu08vfomq/tmpu08vfomq.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5106cf7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b51069eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b51069ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51069ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu08vfomq                        0x000055c5f19ff78e <unavailable> + 6030

    5    libc.so.6                          0x00002b5106ee3460 __libc_start_main +
    245

    6    tmpu08vfomq                        0x000055c5f19ff349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // Find the nearest numbers\n    let nearestNumbers\
    \ = numbers.sorted { $0 < $1 }\n    // Return them in order\n    return (nearestNumbers[0],\
    \ nearestNumbers[1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpb1__7ah6/tmpb1__7ah6.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aece0380c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aece0077b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aece0077988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aece00767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb1__7ah6                        0x0000562ec87d154e <unavailable> + 5454

    5    libc.so.6                          0x00002aece056c460 __libc_start_main +
    245

    6    tmpb1__7ah6                        0x0000562ec87d1109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers, fromIndex:\
    \ 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmph0lk1q43.swift:9:54: error: extra argument 'fromIndex' in call\n\
    \    return find_closest_elements(numbers, fromIndex: 0)\n                   \
    \             ~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var min1 = numbers[0]\n    var min2 = numbers[0]\n\
    \    var minDiff = math.MaxFloat64\n\n    for i in 1..numbers.count {\n      \
    \  var d = abs(numbers[i] - numbers[i - 1])\n        if d < minDiff {\n      \
    \      minDiff = d\n            min1 = numbers[i]\n            min2 = numbers[i\
    \ - 1]\n        } else {\n            if d > minDiff {\n                return\
    \ (min1, min2)\n            }\n        }\n    }\n    return (min1, min2)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp2f5bqy9j.swift:11:19: error: cannot find 'math' in scope\n    var\
    \ minDiff = math.MaxFloat64\n                  ^~~~\n/tmp/tmp2f5bqy9j.swift:13:15:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n    for i in\
    \ 1..numbers.count {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return numbers[0], numbers[0]\n    }\n\n    var closest: Double!\n    var nextClosest:\
    \ Double!\n    for _ in 0 ..< numbers.count - 1 {\n        nextClosest = closest\n\
    \        let closestInArray = numbers.firstIndex(where: { number in\n        \
    \    return number < nextClosest\n        })\n\n        closest = (nextClosest:\
    \ numbers[closestInArray], closest: numbers[closestInArray + 1], closestInArray:\
    \ closestInArray)\n    }\n\n    return (closest, nextClosest)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpar9oy9w0.swift:10:26: error: consecutive statements on a line must\
    \ be separated by ';'\n        return numbers[0], numbers[0]\n               \
    \          ^\n                         ;\n/tmp/tmpar9oy9w0.swift:10:26: error:\
    \ expected expression\n        return numbers[0], numbers[0]\n               \
    \          ^\n/tmp/tmpar9oy9w0.swift:10:23: error: cannot convert return expression\
    \ of type 'Double' to return type '(Double, Double)'\n        return numbers[0],\
    \ numbers[0]\n               ~~~~~~~^~~\n/tmp/tmpar9oy9w0.swift:21:19: error:\
    \ cannot assign value of type '(nextClosest: Double, closest: Double, closestInArray:\
    \ Array<Double>.Index?)' (aka '(nextClosest: Double, closest: Double, closestInArray:\
    \ Optional<Int>)') to type 'Double'\n        closest = (nextClosest: numbers[closestInArray],\
    \ closest: numbers[closestInArray + 1], closestInArray: closestInArray)\n    \
    \              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpar9oy9w0.swift:21:41: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        closest = (nextClosest: numbers[closestInArray], closest:\
    \ numbers[closestInArray + 1], closestInArray: closestInArray)\n             \
    \                           ^\n/tmp/tmpar9oy9w0.swift:21:41: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        closest\
    \ = (nextClosest: numbers[closestInArray], closest: numbers[closestInArray + 1],\
    \ closestInArray: closestInArray)\n                                        ^\n\
    \                                                       ?? <#default value#>\n\
    /tmp/tmpar9oy9w0.swift:21:41: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        closest = (nextClosest: numbers[closestInArray],\
    \ closest: numbers[closestInArray + 1], closestInArray: closestInArray)\n    \
    \                                    ^\n                                     \
    \                 !\n/tmp/tmpar9oy9w"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.isEmpty {\n        return (numbers[0],\
    \ numbers[0])\n    }\n    var sortedNumbers = numbers.sorted()\n    if sortedNumbers.first\
    \ != numbers[0] {\n        sortedNumbers = sortedNumbers.prefix(2)\n    }\n  \
    \  return sortedNumbers.last!, sortedNumbers.first!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp3_d8b2he.swift:16:31: error: consecutive statements on a line must\
    \ be separated by ';'\n    return sortedNumbers.last!, sortedNumbers.first!\n\
    \                              ^\n                              ;\n/tmp/tmp3_d8b2he.swift:16:31:\
    \ error: expected expression\n    return sortedNumbers.last!, sortedNumbers.first!\n\
    \                              ^\n/tmp/tmp3_d8b2he.swift:14:39: error: no 'prefix'\
    \ candidates produce the expected contextual result type '[Double]'\n        sortedNumbers\
    \ = sortedNumbers.prefix(2)\n                                      ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<[Double]>', not the expected contextual\
    \ result type '[Double]'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'ArraySlice<Double>', not the expected contextual result\
    \ type '[Double]'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> Self.SubSequence\n                                       ^\n/tmp/tmp3_d8b2he.swift:16:30:\
    \ error: cannot convert return expression of type 'Double' to return type '(Double,\
    \ Double)'\n    return sortedNumbers.last!, sortedNumbers.first!\n           ~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        } else if number > max {\n            max = number\n        }\n    }\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpsfktwe1w.swift:13:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = number\n            ^~~\n/tmp/tmpsfktwe1w.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpsfktwe1w.swift:15:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = number\n            ^~~\n/tmp/tmpsfktwe1w.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013688
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   return (0.0,0.0)\n    }\n    \n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    \n    for i in 1..numbers.count {\n        if numbers[i] <\
    \ smallest {\n            smallest = numbers[i]\n        } else if numbers[i]\
    \ > largest {\n            largest = numbers[i]\n        }\n    }\n    \n    return\
    \ (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp4fiv9fth.swift:16:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = Double.max\n    var largest\
    \ = Double.min\n    for i in 0..numbers.count - 1 {\n        smallest =< numbers[i]\n\
    \        largest =< numbers[i]\n        if smallest > largest {\n            (smallest,\
    \ largest) = (largest, smallest)\n        }\n    }\n    return (numbers[numbers.count\
    \ - 1], numbers[numbers.count - 2])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpg5es6177.swift:9:27: error: type 'Double' has no member 'max'\n\
    \    var smallest = Double.max\n                   ~~~~~~ ^~~\n/tmp/tmpg5es6177.swift:10:26:\
    \ error: type 'Double' has no member 'min'\n    var largest = Double.min\n   \
    \               ~~~~~~ ^~~\n/tmp/tmpg5es6177.swift:11:15: error: cannot find operator\
    \ '..' in scope; did you mean '...'?\n    for i in 0..numbers.count - 1 {\n  \
    \            ^~\n              ...\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumber = numbers.sorted()\n \
    \   return sortedNumber.first(where: {$0 > sortedNumber.last()}), sortedNumber.last(where:\
    \ {$0 < sortedNumber.first()})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmprpbx14hm.swift:10:65: error: consecutive statements on a line must\
    \ be separated by ';'\n    return sortedNumber.first(where: {$0 > sortedNumber.last()}),\
    \ sortedNumber.last(where: {$0 < sortedNumber.first()})\n                    \
    \                                            ^\n                             \
    \                                   ;\n/tmp/tmprpbx14hm.swift:10:65: error: expected\
    \ expression\n    return sortedNumber.first(where: {$0 > sortedNumber.last()}),\
    \ sortedNumber.last(where: {$0 < sortedNumber.first()})\n                    \
    \                                            ^\n/tmp/tmprpbx14hm.swift:10:25:\
    \ error: cannot convert return expression of type 'Double?' to return type '(Double,\
    \ Double)'\n    return sortedNumber.first(where: {$0 > sortedNumber.last()}),\
    \ sortedNumber.last(where: {$0 < sortedNumber.first()})\n           ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprpbx14hm.swift:10:57: error: cannot call value of non-function type 'Double?'\n\
    \    return sortedNumber.first(where: {$0 > sortedNumber.last()}), sortedNumber.last(where:\
    \ {$0 < sortedNumber.first()})\n                                             \
    \           ^   ~~\n                                                         \
    \   \n"
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n\tlet min1 = numbers.first!\n\tlet min2 = numbers.last!\n\
    \tlet minDiff = abs(min1 - min2)\n\tlet minIndex1 = numbers.firstIndex(of: min1)!\n\
    \tlet minIndex2 = numbers.firstIndex(of: min2)!\n\n\treturn (min1, min2)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp0fxx8zgn/tmp0fxx8zgn.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3eba26c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3eb71db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3eb71d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3eb71c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0fxx8zgn                        0x000055b8176087be <unavailable> + 6078

    5    libc.so.6                          0x00002ac3ebc12460 __libc_start_main +
    245

    6    tmp0fxx8zgn                        0x000055b817608379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    assert(numbers.count >= 2)\n\n    var smallest\
    \ = numbers[0]\n    var largest = numbers[0]\n    for number in numbers {\n  \
    \      if smallest > number {\n            smallest = number\n        }\n    \
    \    if largest < number {\n            largest = number\n        }\n    }\n \
    \   return smallest, largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp3_mnaamz.swift:21:20: error: consecutive statements on a line must\
    \ be separated by ';'\n    return smallest, largest\n                   ^\n  \
    \                 ;\n/tmp/tmp3_mnaamz.swift:21:20: error: expected expression\n\
    \    return smallest, largest\n                   ^\n/tmp/tmp3_mnaamz.swift:21:12:\
    \ error: cannot convert return expression of type 'Double' to return type '(Double,\
    \ Double)'\n    return smallest, largest\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var min1 = Double.MaxValue\n    var min2\
    \ = Double.MaxValue\n    var max1 = Double.MinValue\n    var max2 = Double.MinValue\n\
    \n    for number in numbers {\n        if number < min1 {\n            min2 =\
    \ min1\n            min1 = number\n        }\n        if number > max2 {\n   \
    \         max2 = max1\n            max1 = number\n        }\n    }\n\n    return\
    \ (min1, max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpuxuuqyyj.swift:9:23: error: type 'Double' has no member 'MaxValue'\n\
    \    var min1 = Double.MaxValue\n               ~~~~~~ ^~~~~~~~\n/tmp/tmpuxuuqyyj.swift:10:23:\
    \ error: type 'Double' has no member 'MaxValue'\n    var min2 = Double.MaxValue\n\
    \               ~~~~~~ ^~~~~~~~\n/tmp/tmpuxuuqyyj.swift:11:23: error: type 'Double'\
    \ has no member 'MinValue'\n    var max1 = Double.MinValue\n               ~~~~~~\
    \ ^~~~~~~~\n/tmp/tmpuxuuqyyj.swift:12:23: error: type 'Double' has no member 'MinValue'\n\
    \    var max2 = Double.MinValue\n               ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // Create a lookup table of distances from\
    \ the first number to the others\n    var lookup: [Double: Double] = [:]\n   \
    \ for num in numbers {\n        let key = (num as AnyObject).description\n   \
    \     lookup[key] = lookup[key]?.lt(num) ? num : lookup[key]!\n    }\n\n    //\
    \ Return the first two that were not None\n    for (key, value) in lookup {\n\
    \        if (value == nil) { continue }\n        return (key, value)!\n    }\n\
    \n    // We should never get here since we checked all numbers in the lookup table\n\
    \    fatalError(\"find_closest_elements ran out of numbers to find\")\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd4x5idaw.swift:12:38: error: value of type 'AnyObject' has no member\
    \ 'description'\n        let key = (num as AnyObject).description\n          \
    \        ~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpd4x5idaw.swift:13:36: error:\
    \ value of type 'Double' has no member 'lt'\n        lookup[key] = lookup[key]?.lt(num)\
    \ ? num : lookup[key]!\n                      ~~~~~~~~~~~~ ^~\n/tmp/tmpd4x5idaw.swift:13:36:\
    \ error: value of optional type 'Bool?' must be unwrapped to a value of type 'Bool'\n\
    \        lookup[key] = lookup[key]?.lt(num) ? num : lookup[key]!\n           \
    \                        ^\n/tmp/tmpd4x5idaw.swift:13:36: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        lookup[key]\
    \ = lookup[key]?.lt(num) ? num : lookup[key]!\n                              \
    \     ^\n                                           ?? <#default value#>\n/tmp/tmpd4x5idaw.swift:13:36:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        lookup[key] = lookup[key]?.lt(num) ? num : lookup[key]!\n   \
    \                                ^\n                      (                  \
    \ )!\n/tmp/tmpd4x5idaw.swift:18:19: warning: comparing non-optional value of type\
    \ 'Double' to 'nil' always returns false\n        if (value == nil) { continue\
    \ }\n            ~~~~~ ^  ~~~\n/tmp/tmpd4x5idaw.swift:19:28: error: cannot force\
    \ unwrap value of non-optional type '(Double, Double)'\n        return (key, value)!\n\
    \               ~~~~~~~~~~~~^\n                           \n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // We are going to be working with two\
    \ numbers so let's create a tuple\n    // that we can return\n    var result =\
    \ ((numbers[0]), numbers[1])\n    // Now let's sort it\n    var sortedNumbers\
    \ = numbers.sorted(by: <)\n    // Now let's loop through it making sure we keep\
    \ track of the smallest and largest\n    for i in 2..<sortedNumbers.count {\n\
    \        if abs(sortedNumbers[i-1] - sortedNumbers[i]) < abs(result[1..<2].first\
    \ - result[1..<2].last) {\n            result = (sortedNumbers[i-1], sortedNumbers[i])\n\
    \        }\n    }\n    // If we made the loop we found something\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpcqtktqgh.swift:16:67: error: cannot access element using subscript\
    \ for tuple type '((Double), Double)'; use '.' notation instead\n        if abs(sortedNumbers[i-1]\
    \ - sortedNumbers[i]) < abs(result[1..<2].first - result[1..<2].last) {\n    \
    \                                                              ^\n/tmp/tmpcqtktqgh.swift:16:89:\
    \ error: cannot access element using subscript for tuple type '((Double), Double)';\
    \ use '.' notation instead\n        if abs(sortedNumbers[i-1] - sortedNumbers[i])\
    \ < abs(result[1..<2].first - result[1..<2].last) {\n                        \
    \                                                                ^\n"
  stdout: ''
  timestamp: 1660013866
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // Find smallest number in list\n    let\
    \ smallest = numbers.min()\n    // Find biggest number in list\n    let largest\
    \ = numbers.max()\n    // Find differences between smallest and biggest number\n\
    \    let smallestDiff = smallest - largest\n    // Iterate through list to find\
    \ two closest number\n    // Return them in order\n    var closest = (smallest,\
    \ largest)\n    for x in numbers {\n        if abs(x - smallestDiff) < abs(x -\
    \ closest.0) {\n            closest = (x, smallest)\n        }\n        else if\
    \ abs(x - smallestDiff) < abs(x - closest.1) {\n            closest = (smallest,\
    \ x)\n        }\n    }\n    return (closest.0, closest.1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzkr_v2wl.swift:14:33: error: binary operator '-' cannot be applied\
    \ to two 'Double?' operands\n    let smallestDiff = smallest - largest\n     \
    \                  ~~~~~~~~ ^ ~~~~~~~\n/tmp/tmpzkr_v2wl.swift:14:33: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double, Double)\n\
    \    let smallestDiff = smallest - largest\n                                ^\n\
    /tmp/tmpzkr_v2wl.swift:19:52: error: value of optional type 'Double?' must be\
    \ unwrapped to a value of type 'Double'\n        if abs(x - smallestDiff) < abs(x\
    \ - closest.0) {\n                                                   ^\n/tmp/tmpzkr_v2wl.swift:19:52:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if abs(x - smallestDiff) < abs(x - closest.0) {\n           \
    \                                        ^\n                                 \
    \          (         ?? <#default value#>)\n/tmp/tmpzkr_v2wl.swift:19:52: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        if abs(x - smallestDiff) < abs(x - closest.0) {\n                   \
    \                                ^\n                                         \
    \           !\n/tmp/tmpzkr_v2wl.swift:22:57: error: value of optional type 'Double?'\
    \ must be unwrapped to a value of type 'Double'\n        else if abs(x - smallestDiff)\
    \ < abs(x - closest.1) {\n                                                   \
    \     ^\n/tmp/tmpzkr_v2wl.swift:22:57: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n        else if abs(x - smallestDiff)\
    \ < abs(x - closest.1) {\n                                                   \
    \     ^\n                                                (         ?? <#default\
    \ value#>)\n/tmp/tmpzkr_v2wl.swift:22:57: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        else if abs(x - smallestDiff)\
    \ < abs(x - closest.1) {\n                                                   \
    \     ^\n                                                         !\n/tmp/tmpzkr_v2wl."
  stdout: ''
  timestamp: 1660013865
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  return (0.0,0.0)\n    }\n    if numbers.count > 2 {\n        var bestDistance\
    \ = Double.max\n        var bestIndex = -1\n        for idx in 0..<numbers.count\
    \ {\n            let distance = distanceFrom(numbers[idx], numbers[bestIndex])\n\
    \            if bestDistance > distance {\n                bestDistance = distance\n\
    \                bestIndex = idx\n            }\n        }\n        return (numbers[bestIndex],\
    \ numbers[bestIndex])\n    }\n    return (numbers[0], numbers[0])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmplcysimvl.swift:13:35: error: type 'Double' has no member 'max'\n\
    \        var bestDistance = Double.max\n                           ~~~~~~ ^~~\n\
    /tmp/tmplcysimvl.swift:16:28: error: cannot find 'distanceFrom' in scope\n   \
    \         let distance = distanceFrom(numbers[idx], numbers[bestIndex])\n    \
    \                       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers: numbers,\
    \ offset: 0, distanceSquared: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppau48zui.swift:9:33: error: extra arguments at positions #2, #3\
    \ in call\n    return find_closest_elements(numbers: numbers, offset: 0, distanceSquared:\
    \ 0)\n                                ^\n/tmp/tmppau48zui.swift:8:6: note: 'find_closest_elements(numbers:)'\
    \ declared here\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double)\
    \ {\n     ^\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  // Sort the array\n  var sortedNumbers =\
    \ numbers.sorted()\n  // Return the closest two numbers\n  if sortedNumbers.count\
    \ == 2 {\n    return sortedNumbers[0], sortedNumbers[1]\n  }\n  return sortedNumbers[0],\
    \ sortedNumbers[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpdb9fhv_l.swift:13:28: error: consecutive statements on a line must\
    \ be separated by ';'\n    return sortedNumbers[0], sortedNumbers[1]\n       \
    \                    ^\n                           ;\n/tmp/tmpdb9fhv_l.swift:13:28:\
    \ error: expected expression\n    return sortedNumbers[0], sortedNumbers[1]\n\
    \                           ^\n/tmp/tmpdb9fhv_l.swift:15:26: error: consecutive\
    \ statements on a line must be separated by ';'\n  return sortedNumbers[0], sortedNumbers[1]\n\
    \                         ^\n                         ;\n/tmp/tmpdb9fhv_l.swift:15:26:\
    \ error: expected expression\n  return sortedNumbers[0], sortedNumbers[1]\n  \
    \                       ^\n/tmp/tmpdb9fhv_l.swift:13:25: error: cannot convert\
    \ return expression of type 'Double' to return type '(Double, Double)'\n    return\
    \ sortedNumbers[0], sortedNumbers[1]\n           ~~~~~~~~~~~~~^~~\n/tmp/tmpdb9fhv_l.swift:15:23:\
    \ error: cannot convert return expression of type 'Double' to return type '(Double,\
    \ Double)'\n  return sortedNumbers[0], sortedNumbers[1]\n         ~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            largest = smallest\n            smallest = number\n        } else\
    \ if number > largest {\n            largest = number\n        }\n    }\n    return\
    \ (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp1augf9jh/tmp1augf9jh.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b60d3b7fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60d3876b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b60d3876988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60d38757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1augf9jh                        0x0000555aa422e64e <unavailable> + 5710

    5    libc.so.6                          0x00002b60d3d6b460 __libc_start_main +
    245

    6    tmp1augf9jh                        0x0000555aa422e209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return (numbers[0], numbers[1])\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp9ghw_7lh/tmp9ghw_7lh.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e07ecbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e07bc2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e07bc2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e07bc17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9ghw_7lh                        0x0000558d527704de <unavailable> + 5342

    5    libc.so.6                          0x00002b9e080b7460 __libc_start_main +
    245

    6    tmp9ghw_7lh                        0x0000558d52770099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    \n    let smallestDifference = numbers[0]\
    \ - numbers[1]\n    var closestDifference = smallestDifference\n    var closestIndex\
    \ = 0\n    \n    for index in 1 ..< numbers.count {\n        let difference =\
    \ numbers[index] - numbers[index-1]\n        if difference < closestDifference\
    \ {\n            closestDifference = difference\n            closestIndex = index\n\
    \        }\n    }\n    return (numbers[closestIndex], numbers[closestIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpdzzc379x/tmpdzzc379x.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b084f1b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b084eea9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b084eea9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b084eea87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdzzc379x                        0x0000560a9b56a6be <unavailable> + 5822

    5    libc.so.6                          0x00002b084f39e460 __libc_start_main +
    245

    6    tmpdzzc379x                        0x0000560a9b56a279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var lowestDifference = Double(Int.max)\n\
    \    var highestDifference = Double(0)\n    var highestDifferenceIndex: Int =\
    \ 0\n    for index in 0..<numbers.count {\n        let difference = numbers[index]\
    \ - numbers[highestDifferenceIndex]\n        if difference < lowestDifference\
    \ {\n            lowestDifference = difference\n            highestDifferenceIndex\
    \ = index\n        } else if difference > highestDifference {\n            highestDifference\
    \ = difference\n            highestDifferenceIndex = index\n        }\n    }\n\
    \    return (numbers[highestDifferenceIndex], numbers[highestDifferenceIndex +\
    \ 1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad918f8cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad918c83561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad918c83286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad918c8313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad918c82bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad918a82f44 <unavailable> + 188228

    6    tmphzwobd95                        0x000055decd2b9f3b <unavailable> + 7995

    7    tmphzwobd95                        0x000055decd2b95cd <unavailable> + 5581

    8    libc.so.6                          0x00002ad919178460 __libc_start_main +
    245

    9    tmphzwobd95                        0x000055decd2b9279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // TODO: Check if there are any elements\
    \ that are equally close.\n    let index1 = 0\n    let index2 = numbers.count\
    \ - 1\n    let smallest1 = numbers[index1]\n    let smallest2 = numbers[index2]\n\
    \n    if numbers[index2] < numbers[index1] {\n        index2--\n    }\n\n    if\
    \ numbers[index2] < smallest1 {\n        index1++\n    }\n\n    return (numbers[index1],\
    \ numbers[index2])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpr7u6n87t.swift:16:15: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n        index2--\n              ^~\n/tmp/tmpr7u6n87t.swift:20:15:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index1++\n\
    \              ^~\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest\
    \ = max(numbers)\n    if smallest == largest {\n        return (smallest, largest)\n\
    \    }\n    let midpoint = numbers.map(Float.init).reduce(Float.init(), combine:\
    \ min)\n    let smallestClosest = numbers.filter({\n        abs($0 - midpoint)\
    \ < abs($1 - midpoint)\n    })\n    let largestClosest = numbers.filter({\n  \
    \      abs($0 - midpoint) > abs($1 - midpoint)\n    })\n    return (smallestClosest[0],\
    \ largestClosest[0])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmprmelk3jz.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmprmelk3jz.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmprmelk3jz.swift:14:50: error:\
    \ extraneous argument label 'combine:' in call\n    let midpoint = numbers.map(Float.init).reduce(Float.init(),\
    \ combine: min)\n                                                 ^          \
    \    ~~~~~~~~~\n                                                             \
    \   \n/tmp/tmprmelk3jz.swift:15:42: error: contextual closure type '(Double) throws\
    \ -> Bool' expects 1 argument, but 2 were used in closure body\n    let smallestClosest\
    \ = numbers.filter({\n                                         ^\n/tmp/tmprmelk3jz.swift:18:41:\
    \ error: contextual closure type '(Double) throws -> Bool' expects 1 argument,\
    \ but 2 were used in closure body\n    let largestClosest = numbers.filter({\n\
    \                                        ^\n"
  stdout: ''
  timestamp: 1660013870
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else { return\
    \ (numbers[0], numbers[0]) }\n\n    let smallestDiff = math.min(numbers.first,\
    \ numbers.last)\n\n    let smallestIndex = numbers.index(of: smallestDiff)\n \
    \   let largestIndex = numbers.index(of: numbers[numbers.count-1])\n\n    return\
    \ (numbers[smallestIndex], numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpiq6awky6.swift:11:24: error: cannot find 'math' in scope\n    let\
    \ smallestDiff = math.min(numbers.first, numbers.last)\n                     \
    \  ^~~~\n/tmp/tmpiq6awky6.swift:14:32: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    let largestIndex = numbers.index(of: numbers[numbers.count-1])\n\
    \                               ^\n/tmp/tmpiq6awky6.swift:14:32: note: use 'firstIndex(of:)'\
    \ instead\n    let largestIndex = numbers.index(of: numbers[numbers.count-1])\n\
    \                               ^~~~~\n                               firstIndex\n\
    /tmp/tmpiq6awky6.swift:16:45: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n    return (numbers[smallestIndex], numbers[largestIndex])\n  \
    \                                          ^\n/tmp/tmpiq6awky6.swift:14:9: note:\
    \ short-circuit using 'guard' to exit this function early if the optional value\
    \ contains 'nil'\n    let largestIndex = numbers.index(of: numbers[numbers.count-1])\n\
    \        ^\n    guard                                                        \
    \  else { return <#default value#> }\n/tmp/tmpiq6awky6.swift:14:32: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let largestIndex = numbers.index(of: numbers[numbers.count-1])\n           \
    \                    ^\n                                                     \
    \              ?? <#default value#>\n/tmp/tmpiq6awky6.swift:14:32: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let largestIndex\
    \ = numbers.index(of: numbers[numbers.count-1])\n                            \
    \   ^\n                                                                  !\n/tmp/tmpiq6awky6.swift:16:45:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return (numbers[smallestIndex], numbers[largestIndex])\n        \
    \                                    ^\n                                     \
    \                    ?? <#default value#>\n/tmp/tmpiq6aw"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let maxIndex = numbers.count\n    let maxValue\
    \ = numbers[0]\n    var minIndex = maxIndex - 1\n    var minValue = numbers[0]\n\
    \    for i in 0..<maxIndex {\n        let value = numbers[i]\n        if value\
    \ > maxValue {\n            maxValue = value\n            maxIndex = i\n     \
    \   }\n        if value < minValue {\n            minValue = value\n         \
    \   minIndex = i\n        }\n    }\n    return (minValue, maxValue)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppp54sjqq.swift:16:13: error: cannot assign to value: 'maxValue'\
    \ is a 'let' constant\n            maxValue = value\n            ^~~~~~~~\n/tmp/tmppp54sjqq.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxValue = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmppp54sjqq.swift:17:13: error: cannot assign to value:\
    \ 'maxIndex' is a 'let' constant\n            maxIndex = i\n            ^~~~~~~~\n\
    /tmp/tmppp54sjqq.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let maxIndex = numbers.count\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    if numbers.count < 2 {\n        return\
    \ (0.0,0.0)\n    }\n\n    var lowest_value = numbers[0]\n    var second_lowest_value\
    \ = numbers[0]\n\n    for number in numbers {\n        if number < lowest_value\
    \ {\n            lowest_value = number\n        } else if number > lowest_value\
    \ {\n            if second_lowest_value < number {\n                second_lowest_value\
    \ = number\n            }\n        }\n    }\n\n    return (lowest_value, second_lowest_value)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpzwegr0ud/tmpzwegr0ud.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bde3e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bde0dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bde0db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bde0da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzwegr0ud                        0x00005616641c969e <unavailable> + 5790

    5    libc.so.6                          0x00002b4bde5d0460 __libc_start_main +
    245

    6    tmpzwegr0ud                        0x00005616641c9259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count >= 2 else {\n     \
    \   fatalError(\"Not enough numbers to find\")\n    }\n    var closest = numbers[0]\n\
    \    var closestDiff = numbers[0]\n    for x in numbers {\n        let absX =\
    \ abs(x)\n        if absX < closestDiff {\n            closestDiff = absX\n  \
    \          closest = x\n        }\n    }\n    return (closest, closest)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwzc_jk_x/tmpwzc_jk_x.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89680c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8967dbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8967dbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8967dba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwzc_jk_x                        0x0000559043e9f81e <unavailable> + 6174

    5    libc.so.6                          0x00002b89682b0460 __libc_start_main +
    245

    6    tmpwzc_jk_x                        0x0000559043e9f3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    \n    if numbers.count < 2 {\n        return\
    \ (numbers[0], numbers[0])\n    }\n    \n    let sortedNumbers = numbers.sorted()\n\
    \    \n    guard numbers.count > 2 else {\n        return (sortedNumbers[0], sortedNumbers[1])\n\
    \    }\n    \n    guard sortedNumbers[1] - sortedNumbers[0] > .MachineEpsilon\
    \ else {\n        return (sortedNumbers[0], sortedNumbers[1])\n    }\n    \n \
    \   let closestOne = sortedNumbers[numbers.count - 2]\n    let secondClosestOne\
    \ = sortedNumbers[numbers.count - 1]\n    \n    return (closestOne, secondClosestOne)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpb44bhcaw.swift:20:50: error: type 'Double' has no member 'MachineEpsilon'\n\
    \    guard sortedNumbers[1] - sortedNumbers[0] > .MachineEpsilon else {\n    \
    \                                            ~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest_diff : Double = -(1.0 / Double(numbers.count))\n\
    \    var smallest_x : Double = 0\n    var largest_x : Double = 0\n    var largest_diff\
    \ : Double = -(1.0 / Double(numbers.count))\n\n    if numbers.count > 0 {\n  \
    \      var x : Double\n\n        for x in numbers {\n            var diff : Double\n\
    \            var diff : Double\n\n            if x == numbers[0] {\n         \
    \       diff = abs(x - numbers[1])\n            } else {\n                diff\
    \ = abs(x - numbers[0])\n            }\n\n            if diff < smallest_diff\
    \ {\n                smallest_diff = diff\n                smallest_x = x\n  \
    \          }\n\n            if diff > largest_diff {\n                largest_diff\
    \ = diff\n                largest_x = x\n            }\n        }\n\n        return\
    \ (smallest_x, largest_x)\n    } else {\n        return (0.0, 0.0)\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp45yz9_gw.swift:19:17: error: invalid redeclaration of 'diff'\n\
    \            var diff : Double\n                ^\n/tmp/tmp45yz9_gw.swift:18:17:\
    \ note: 'diff' previously declared here\n            var diff : Double\n     \
    \           ^\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = min(numbers, key: .init)\n  \
    \  let max = max(numbers, key: .init)\n    return min < max ? min : max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpvleasuyy.swift:9:18: error: extraneous argument label 'key:' in\
    \ call\n    let min = min(numbers, key: .init)\n                 ^         ~~~~~\n\
    \                           \n/tmp/tmpvleasuyy.swift:10:18: error: extraneous\
    \ argument label 'key:' in call\n    let max = max(numbers, key: .init)\n    \
    \             ^         ~~~~~\n                           \n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let firstIndex = find_closest_index(numbers:\
    \ numbers, first: numbers[0], second: numbers[1])\n    let secondIndex = find_closest_index(numbers:\
    \ numbers, first: numbers[1], second: numbers[0])\n    return (numbers[firstIndex],\
    \ numbers[secondIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpb2e8m0sz.swift:9:22: error: cannot find 'find_closest_index' in\
    \ scope\n    let firstIndex = find_closest_index(numbers: numbers, first: numbers[0],\
    \ second: numbers[1])\n                     ^~~~~~~~~~~~~~~~~~\n/tmp/tmpb2e8m0sz.swift:10:23:\
    \ error: cannot find 'find_closest_index' in scope\n    let secondIndex = find_closest_index(numbers:\
    \ numbers, first: numbers[1], second: numbers[0])\n                      ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // TODO: use sorting\n    var smallest\
    \ = numbers[0]\n    var largest = numbers[0]\n    for number in numbers {\n  \
    \      if number < smallest {\n            smallest = number\n        } else if\
    \ number > largest {\n            largest = number\n        }\n    }\n    return\
    \ (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp7yt7u1hk/tmp7yt7u1hk.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19218a2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1921599b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1921599988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19215987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7yt7u1hk                        0x000055ae0892d64e <unavailable> + 5710

    5    libc.so.6                          0x00002b1921a8e460 __libc_start_main +
    245

    6    tmp7yt7u1hk                        0x000055ae0892d209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var closest1 = Float.leastNormalMagnitude\n\
    \    var closest2 = Float.leastNormalMagnitude\n    for i in 0..<numbers.count\
    \ {\n        if abs(numbers[i] - closest1) < abs(numbers[i] - closest2) {\n  \
    \          closest1 = numbers[i]\n        } else if abs(numbers[i] - closest2)\
    \ < abs(numbers[i] - closest1) {\n            closest2 = numbers[i]\n        }\
    \ else {\n            return numbers[i], numbers[i]\n        }\n    }\n    return\
    \ closest1, closest2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpyvvr8ffk.swift:17:30: error: consecutive statements on a line must\
    \ be separated by ';'\n            return numbers[i], numbers[i]\n           \
    \                  ^\n                             ;\n/tmp/tmpyvvr8ffk.swift:17:30:\
    \ error: expected expression\n            return numbers[i], numbers[i]\n    \
    \                         ^\n/tmp/tmpyvvr8ffk.swift:20:20: error: consecutive\
    \ statements on a line must be separated by ';'\n    return closest1, closest2\n\
    \                   ^\n                   ;\n/tmp/tmpyvvr8ffk.swift:20:20: error:\
    \ expected expression\n    return closest1, closest2\n                   ^\n/tmp/tmpyvvr8ffk.swift:12:56:\
    \ error: binary operator '-' cannot be applied to operands of type 'Double' and\
    \ 'Float'\n        if abs(numbers[i] - closest1) < abs(numbers[i] - closest2)\
    \ {\n                                            ~~~~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpyvvr8ffk.swift:12:56:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Float, Float)\n        if abs(numbers[i] - closest1) < abs(numbers[i]\
    \ - closest2) {\n                                                       ^\n/tmp/tmpyvvr8ffk.swift:12:27:\
    \ error: binary operator '-' cannot be applied to operands of type 'Double' and\
    \ 'Float'\n        if abs(numbers[i] - closest1) < abs(numbers[i] - closest2)\
    \ {\n               ~~~~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpyvvr8ffk.swift:12:27: note:\
    \ overloads for '-' exist with these partially matching parameter lists: (Double,\
    \ Double), (Float, Float)\n        if abs(numbers[i] - closest1) < abs(numbers[i]\
    \ - closest2) {\n                          ^\n/tmp/tmpyvvr8ffk.swift:13:31: error:\
    \ cannot assign value of type 'Double' to type 'Float'\n            closest1 =\
    \ numbers[i]\n                       ~~~~~~~^~~\n                       Float(\
    \    )\n/tmp/tmpyvvr8ffk.swift:14:63: error: binary operator '-' cannot be applied\
    \ to operands of type 'Double' and 'Float'\n        } else if abs(numbers[i] -\
    \ closest2) < abs(numbers[i] - closest1) {\n                                 \
    \                  ~~~~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpyv"
  stdout: ''
  timestamp: 1660013894
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return select_closest_elements(numbers:\
    \ numbers)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl_m8hgor.swift:9:12: error: cannot find 'select_closest_elements'\
    \ in scope\n    return select_closest_elements(numbers: numbers)\n           ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    // Sort numbers in increasing order\n \
    \   let sorted = numbers.sorted { $0 < $1 }\n\n    // If sorted is empty return\
    \ nil\n    if sorted.isEmpty {\n        return (nil, nil)\n    }\n\n    // Find\
    \ two closest elements\n    let closestOne = sorted[0]\n    let closestTwo = sorted[1]\n\
    \n    // Return them as pairs\n    return (closestOne, closestTwo)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpe_vdkztl.swift:14:17: error: 'nil' requires a contextual type\n\
    \        return (nil, nil)\n                ^\n/tmp/tmpe_vdkztl.swift:14:22: error:\
    \ 'nil' requires a contextual type\n        return (nil, nil)\n              \
    \       ^\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n  if numbers.isEmpty {\n    return (0.0, Double(0.0))\n\
    \  }\n\n  let min = numbers[0]\n  let max = numbers[0]\n  var min_d = 0.0\n  var\
    \ max_d = Double(Double.greatestFiniteMagnitude)\n  for d in numbers {\n    if\
    \ d < min {\n      min_d = d\n      min = d\n    } else if d > max {\n      max_d\
    \ = d\n      max = d\n    }\n  }\n  return (min, max)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpeapmdoq1.swift:20:7: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n      min = d\n      ^~~\n/tmp/tmpeapmdoq1.swift:13:3: note:\
    \ change 'let' to 'var' to make it mutable\n  let min = numbers[0]\n  ^~~\n  var\n\
    /tmp/tmpeapmdoq1.swift:23:7: error: cannot assign to value: 'max' is a 'let' constant\n\
    \      max = d\n      ^~~\n/tmp/tmpeapmdoq1.swift:14:3: note: change 'let' to\
    \ 'var' to make it mutable\n  let max = numbers[0]\n  ^~~\n  var\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    guard numbers.count > 1 else {\n      \
    \  fatalError(\"An array of numbers of length at least two must be supplied\"\
    )\n    }\n    guard numbers.count >= 2 else {\n        fatalError(\"An array of\
    \ numbers of length at least two must be supplied\")\n    }\n\n    let sorted\
    \ = numbers.sorted()\n    guard numbers.count == 2 else {\n        fatalError(\"\
    An array of numbers of length at least two must be supplied\")\n    }\n\n    var\
    \ closest1 = sorted[0]\n    var closest2 = sorted[1]\n    guard let index1 = sorted.index(of:\
    \ closest1) else {\n        fatalError(\"The array must have a number at the zero\
    \ index\")\n    }\n\n    guard let index2 = sorted.index(of: closest2) else {\n\
    \        fatalError(\"The array must have a number at the one index\")\n    }\n\
    \n    if abs(sorted[0] - sorted[1]) < abs(sorted[index2] - sorted[index1]) {\n\
    \        closest1 = sorted[1]\n        closest2 = sorted[0]\n    }\n\n    return\
    \ (closest1, closest2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpc8hp_2ko/tmpc8hp_2ko.swift:18: Fatal error: An array of numbers of length
    at least two must be supplied

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a8a73cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a8a433b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a8a433988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a8a4327b0 _assertionFailure(_:_:file:line:flags:)
    + 365

    4    tmpc8hp_2ko                        0x000055e63539e305 <unavailable> + 8965

    5    tmpc8hp_2ko                        0x000055e63539d6cd <unavailable> + 5837

    6    libc.so.6                          0x00002b0a8a928460 __libc_start_main +
    245

    7    tmpc8hp_2ko                        0x000055e63539d379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var min_val: Double = 0.0\n    var max_val:\
    \ Double = 0.0\n\n    for i in 0 ..< numbers.count {\n        min_val = numbers[i]\n\
    \        max_val = numbers[i]\n\n        for j in 0 ..< numbers.count {\n    \
    \        if j == i { continue }\n            if numbers[j] < min_val {\n     \
    \           min_val = numbers[j]\n            }\n            if numbers[j] > max_val\
    \ {\n                max_val = numbers[j]\n            }\n        }\n\n      \
    \  return (min_val, max_val)\n    }\n\n    return (numbers[0], numbers[0])\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpt0yniqh3/tmpt0yniqh3.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e080b3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e07daab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e07daa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e07da97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt0yniqh3                        0x00005632903d06be <unavailable> + 5822

    5    libc.so.6                          0x00002b7e0829f460 __libc_start_main +
    245

    6    tmpt0yniqh3                        0x00005632903d0279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: -4
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest_diff: Double = Double.infinity\n\
    \    var closest_to_smallest = Double.nan\n    for i in 0..<numbers.count {\n\
    \        let current_diff = (numbers[i] - numbers[(i - 1) as Int]) * (numbers[(i\
    \ - 1) as Int])\n        if current_diff < smallest_diff {\n            smallest_diff\
    \ = current_diff\n            closest_to_smallest = numbers[i]\n        }\n  \
    \  }\n    return (closest_to_smallest, smallest_diff)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba7c7409c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba7c7100561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba7c7100286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba7c710013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba7c70ffbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba7c6efff44 <unavailable> + 188228

    6    tmps3e57xwj                        0x0000559ea6e32f1c <unavailable> + 7964

    7    tmps3e57xwj                        0x0000559ea6e3266d <unavailable> + 5741

    8    libc.so.6                          0x00002ba7c75f5460 __libc_start_main +
    245

    9    tmps3e57xwj                        0x0000559ea6e32319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let min = numbers.min()\n    let max =\
    \ numbers.max()\n    if min == max {\n        return (min, min)\n    }\n    //\
    \ Find the smallest difference between the min and max values\n    let diff =\
    \ abs(min - max)\n    if diff == 0 {\n        return (min, min)\n    }\n    //\
    \ Find the two numbers in which they differ, the middle number\n    let mid =\
    \ min + ((max - min) / 2)\n    // Return the two numbers in order\n    return\
    \ (mid, mid)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6rm0e737.swift:12:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min, min)\n               ^\n/tmp/tmp6rm0e737.swift:15:24: error: binary operator\
    \ '-' cannot be applied to two 'Double?' operands\n    let diff = abs(min - max)\n\
    \                   ~~~ ^ ~~~\n/tmp/tmp6rm0e737.swift:15:24: note: overloads for\
    \ '-' exist with these partially matching parameter lists: (Double, Double)\n\
    \    let diff = abs(min - max)\n                       ^\n/tmp/tmp6rm0e737.swift:17:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min, min)\n               ^\n/tmp/tmp6rm0e737.swift:20:15:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n    let mid = min + ((max - min) / 2)\n              ^\n/tmp/tmp6rm0e737.swift:20:15:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let mid = min + ((max - min) / 2)\n              ^\n            \
    \  (   ?? <#default value#>)\n/tmp/tmp6rm0e737.swift:20:15: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let mid\
    \ = min + ((max - min) / 2)\n              ^\n                 !\n/tmp/tmp6rm0e737.swift:20:27:\
    \ error: binary operator '-' cannot be applied to two 'Double?' operands\n   \
    \ let mid = min + ((max - min) / 2)\n                      ~~~ ^ ~~~\n/tmp/tmp6rm0e737.swift:20:27:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double)\n    let mid = min + ((max - min) / 2)\n                  \
    \        ^\n"
  stdout: ''
  timestamp: 1660013865
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    var smallest: Double\n    var largest:\
    \ Double\n    for i in 0..<numbers.count {\n        let distance = numbers[i]\
    \ - numbers[0]\n        if smallest == 0.0 || distance < smallest {\n        \
    \    smallest = distance\n        }\n        if largest == 0.0 || distance > largest\
    \ {\n            largest = distance\n        }\n    }\n    return (numbers[numbers.count\
    \ - 1], largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpd1dy1lz0.swift:13:12: error: variable 'smallest' used before being\
    \ initialized\n        if smallest == 0.0 || distance < smallest {\n         \
    \  ^\n/tmp/tmpd1dy1lz0.swift:9:9: note: variable defined here\n    var smallest:\
    \ Double\n        ^\n/tmp/tmpd1dy1lz0.swift:13:31: error: variable 'smallest'\
    \ used before being initialized\n        if smallest == 0.0 || distance < smallest\
    \ {\n                              ^\n/tmp/tmpd1dy1lz0.swift:9:9: note: variable\
    \ defined here\n    var smallest: Double\n        ^\n/tmp/tmpd1dy1lz0.swift:16:12:\
    \ error: variable 'largest' used before being initialized\n        if largest\
    \ == 0.0 || distance > largest {\n           ^\n/tmp/tmpd1dy1lz0.swift:10:9: note:\
    \ variable defined here\n    var largest: Double\n        ^\n/tmp/tmpd1dy1lz0.swift:16:30:\
    \ error: variable 'largest' used before being initialized\n        if largest\
    \ == 0.0 || distance > largest {\n                             ^\n/tmp/tmpd1dy1lz0.swift:10:9:\
    \ note: variable defined here\n    var largest: Double\n        ^\n/tmp/tmpd1dy1lz0.swift:20:41:\
    \ error: variable 'largest' used before being initialized\n    return (numbers[numbers.count\
    \ - 1], largest)\n                                        ^\n/tmp/tmpd1dy1lz0.swift:10:9:\
    \ note: variable defined here\n    var largest: Double\n        ^\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n\
    \    return (sortedNumbers.first, sortedNumbers.last)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpprseucb1.swift:10:12: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n    return (sortedNumbers.first,\
    \ sortedNumbers.last)\n           ^\n"
  stdout: ''
  timestamp: 1660013864
- exit_code: 1
  program: "\n/// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n    return find_closest_elements(numbers, numbers:\
    \ numbers)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpmfcjzzhy.swift:9:34: error: extra argument in call\n    return\
    \ find_closest_elements(numbers, numbers: numbers)\n                         \
    \       ~^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013864
