language: swift
name: HumanEval_93_encode
results:
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // TODO:\
    \ fill in the missing code for this function.\n    // If the length of the message\
    \ is not even,\n    // the function should return the same message\n    // It\
    \ should also return the same message if the message is empty or if the message\
    \ is one letter long.\n    return message\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpwrsxyy8b/tmpwrsxyy8b.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b956117bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9560e72b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9560e72988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9560e717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwrsxyy8b                        0x000056452b1ad307 <unavailable> + 4871

    5    libc.so.6                          0x00002b9561367460 __libc_start_main +
    245

    6    tmpwrsxyy8b                        0x000056452b1acf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let count\
    \ = message.characters.count\n    \n    if count > 2 {\n        return \"\"\n\
    \    }\n    \n    var encodedString = \"\"\n    for i in 0..<count {\n       \
    \ if i != 0 && i == count-1 {\n            encodedString += String(message.characters[i-1])\n\
    \        } else {\n            encodedString += String(message.characters[i]).swapcase()\n\
    \        }\n    }\n    \n    for _ in 0..<count {\n        encodedString += String(message.characters[i])\n\
    \    }\n    \n    return encodedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp51vk9ous.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let count = message.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp51vk9ous.swift:22:37: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n            encodedString +=\
    \ String(message.characters[i-1])\n                                    ^~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp51vk9ous.swift:22:45:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ encodedString += String(message.characters[i-1])\n                         \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp51vk9ous.swift:24:60: error: value of type 'String' has no member\
    \ 'swapcase'\n            encodedString += String(message.characters[i]).swapcase()\n\
    \                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp51vk9ous.swift:29:52:\
    \ error: cannot find 'i' in scope\n        encodedString += String(message.characters[i])\n\
    \                                                   ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let letters\
    \ = message.characters\n    var result = \"\"\n\n    for letter in letters {\n\
    \        let index = letters.indexOf(letter)\n        let replacement = englishAlphabet[index]\
    \ + englishAlphabet[index+1]\n        result = result + String(replacement)\n\
    \    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpor_rf9t3.swift:13:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    let letters = message.characters\n                \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpor_rf9t3.swift:17:29: error: value of type 'String' has no member 'indexOf'\n\
    \        let index = letters.indexOf(letter)\n                    ~~~~~~~ ^~~~~~~\n\
    /tmp/tmpor_rf9t3.swift:18:27: error: cannot find 'englishAlphabet' in scope\n\
    \        let replacement = englishAlphabet[index] + englishAlphabet[index+1]\n\
    \                          ^~~~~~~~~~~~~~~\n/tmp/tmpor_rf9t3.swift:18:52: error:\
    \ cannot find 'englishAlphabet' in scope\n        let replacement = englishAlphabet[index]\
    \ + englishAlphabet[index+1]\n                                               \
    \    ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n  return message(message:\
    \ message).message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmppfrrt2u4.swift:13:10: error: cannot call value of non-function\
    \ type 'String'\n  return message(message: message).message\n         ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    if message\
    \ == \"\" {\n        return message\n    }\n\n    var result = \"\"\n    var count\
    \ = [Character: Int]()\n    for i in 0..<message.characters.count {\n        let\
    \ current = message.character(i)\n        if !count.keys.contains(current) {\n\
    \            count[current] = 1\n        } else {\n            count[current]\
    \ = count[current] + 1\n        }\n    }\n\n    for i in 0..<count.count {\n \
    \       let current: Character = key.character(i)\n        if i == 0 {\n     \
    \       result += current\n        } else {\n            if count[current] > 1\
    \ {\n                result += current\n            } else {\n               \
    \ result += String(current.uppercased())\n            }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmppc7ivsuv.swift:19:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<message.characters.count {\n         \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmppc7ivsuv.swift:20:31: error: value of type 'String' has no member\
    \ 'character'\n        let current = message.character(i)\n                  \
    \    ~~~~~~~ ^~~~~~~~~\n/tmp/tmppc7ivsuv.swift:24:35: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n            count[current]\
    \ = count[current] + 1\n                                  ^\n/tmp/tmppc7ivsuv.swift:24:35:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            count[current] = count[current] + 1\n                   \
    \               ^\n                             (              ?? <#default value#>)\n\
    /tmp/tmppc7ivsuv.swift:24:35: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n            count[current] = count[current]\
    \ + 1\n                                  ^\n                                 \
    \          !\n/tmp/tmppc7ivsuv.swift:29:34: error: cannot find 'key' in scope\n\
    \        let current: Character = key.character(i)\n                         \
    \        ^~~\n/tmp/tmppc7ivsuv.swift:31:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += current\n\
    \                      ^\n/tmp/tmppc7ivsuv.swift:33:21: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n            if count[current]\
    \ > 1 {\n                    ^\n/tmp/tmppc7ivsuv.swift:33:21: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \   if count[current] > 1 {\n                    ^\n                         \
    \     ?? <#default value#>\n/tmp/tmppc7ivsuv.swift:33:21: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n            if\
    \ count[current] > 1 {\n            "
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    if let\
    \ vowels = \"AEIOUaeiouA\".unicodeScalars {\n        return message.unicodeScalars.map\
    \ { character -> String in\n            if let index = vowels.index(of: character)\
    \ {\n                if index == 0 {\n                    return String(character)\n\
    \                }\n                if let index = vowels.indices.dropFirst(where:\
    \ { $0 == index + 1 }), let currentCharacter = String(vowels[index - 1], radix:\
    \ 16) {\n                    return currentCharacter + String(character)\n   \
    \             }\n            }\n            return String(character)\n       \
    \ }.reduce(\"\", { result, character in\n            return result + String(Character(character).isUppercase)\
    \ ? character : String(Character(character).isLowercase) ? String(character).lowercased()\
    \ : String(character)\n        })\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp27gowt6p.swift:14:16: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        return message.unicodeScalars.map { character -> String\
    \ in\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp27gowt6p.swift:13:8:\
    \ error: initializer for conditional binding must have Optional type, not 'String.UnicodeScalarView'\n\
    \    if let vowels = \"AEIOUaeiouA\".unicodeScalars {\n       ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979319
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"AEIOUaeiou\"\n    var newMessage = \"\"\n    for letter in message {\n \
    \       if let idx = vowels.index(of: letter) {\n            newMessage += String(letter)\n\
    \            newMessage += String(letters[(idx+2)%26])\n        } else {\n   \
    \         newMessage += String(letter)\n        }\n    }\n    return newMessage\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpdb_68sp0.swift:16:29: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        if let idx = vowels.index(of: letter) {\n    \
    \                        ^\n/tmp/tmpdb_68sp0.swift:16:29: note: use 'firstIndex(of:)'\
    \ instead\n        if let idx = vowels.index(of: letter) {\n                 \
    \           ^~~~~\n                            firstIndex\n/tmp/tmpdb_68sp0.swift:18:34:\
    \ error: cannot find 'letters' in scope\n            newMessage += String(letters[(idx+2)%26])\n\
    \                                 ^~~~~~~\n/tmp/tmpdb_68sp0.swift:18:43: error:\
    \ cannot convert value of type 'String.Index' to expected argument type 'Int'\n\
    \            newMessage += String(letters[(idx+2)%26])\n                     \
    \                     ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // This\
    \ algorithm is designed to replace vowels with their \n    // letters in the english\
    \ alphabet, swapping case. \n    // The swap happens first on the second letter\
    \ of \n    // the vowel. The final swap is performed on the first letter \n  \
    \  // of the second vowel. \n    var swappedMessage = \"\"\n    \n    var englishAlphabet\
    \ = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\n          \
    \                 \"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\"\
    ,\n                           \"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\n    \n   \
    \ var vowels = [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"]\n    \n    var vowelsCount\
    \ = vowels.count\n    var englishAlphabetCount = englishAlphabet.count\n    \n\
    \    for i in 0..<(englishAlphabet.count) {\n        let firstLetter = englishAlphabet[i]\n\
    \        \n        // Find the first vowel after the current letter\n        for\
    \ j in 0..<(vowels.count) {\n            let secondLetter = vowels[j]\n      \
    \      \n            // If the letter is not a vowel, continue to the next\n \
    \           if (firstLetter == secondLetter) {\n                continue\n   \
    \         }\n            \n            // If the letter is one of the vowels,\
    \ swap the case\n            if (firstLetter == secondLetter) {\n            \
    \    let firstChar = firstLetter\n                let secondChar = secondLetter\n\
    \                \n                // Swap the case for both characters\n    \
    \            firstChar = firstChar.uppercaseString\n                secondChar\
    \ = secondChar.uppercaseString\n                \n                let firstLetterIndex\
    \ = englishAlphabet.index(of: firstChar)!\n                let secondLetterIndex\
    \ = englishAlphabet.index(of: secondChar)!\n                \n               \
    \ let firstCharIndex = englishAlphabet.index(of: firstChar)!\n               \
    \ let secondCharIndex = englishAlphabet.index(of: secondChar)!\n             \
    \   \n                swappedMessage += englishAlphabet[firstLetterIndex] + \n\
    \                                 englishAlphabet[secondLetterIndex] + \n    \
    \                             englishAlphabet[firstCharIndex] + \n           \
    \                      englishAlphabet[secondCharIndex] + \n                 \
    \                englishAlphabet[firstLetterIndex] + \n                      \
    \           englishAlphabet[secondLetterIndex] + \n                          \
    \       \" \" \n            }\n        }\n    }\n    \n    swappedMessage = swappedMessage.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    \n    return swappedMessage\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpf_bevy5n.swift:47:17: error: cannot assign to value: 'firstChar'\
    \ is a 'let' constant\n                firstChar = firstChar.uppercaseString\n\
    \                ^~~~~~~~~\n/tmp/tmpf_bevy5n.swift:43:17: note: change 'let' to\
    \ 'var' to make it mutable\n                let firstChar = firstLetter\n    \
    \            ^~~\n                var\n/tmp/tmpf_bevy5n.swift:47:39: error: value\
    \ of type 'String' has no member 'uppercaseString'\n                firstChar\
    \ = firstChar.uppercaseString\n                            ~~~~~~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpf_bevy5n.swift:48:17: error: cannot assign to value: 'secondChar' is a\
    \ 'let' constant\n                secondChar = secondChar.uppercaseString\n  \
    \              ^~~~~~~~~~\n/tmp/tmpf_bevy5n.swift:44:17: note: change 'let' to\
    \ 'var' to make it mutable\n                let secondChar = secondLetter\n  \
    \              ^~~\n                var\n/tmp/tmpf_bevy5n.swift:48:41: error:\
    \ value of type 'String' has no member 'uppercaseString'\n                secondChar\
    \ = secondChar.uppercaseString\n                             ~~~~~~~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpf_bevy5n.swift:50:56: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n                let firstLetterIndex = englishAlphabet.index(of:\
    \ firstChar)!\n                                                       ^\n/tmp/tmpf_bevy5n.swift:50:56:\
    \ note: use 'firstIndex(of:)' instead\n                let firstLetterIndex =\
    \ englishAlphabet.index(of: firstChar)!\n                                    \
    \                   ^~~~~\n                                                  \
    \     firstIndex\n/tmp/tmpf_bevy5n.swift:51:57: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n                let secondLetterIndex = englishAlphabet.index(of:\
    \ secondChar)!\n                                                        ^\n/tmp/tmpf_bevy5n.swift:51:57:\
    \ note: use 'firstIndex(of:)' instead\n                let secondLetterIndex =\
    \ englishAlphabet.index(of: secondChar)!\n                                   \
    \                     ^~~~~\n                              "
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".characters()\n  \
    \  var vowels = \"AEIOU\".characters()\n    for char in message {\n        if\
    \ vowels.contains(char) {\n            var index = 0\n            while index\
    \ < vowels.count {\n                if let index = alphabet.index(of: vowels[index],\
    \ options: []) {\n                    alphabet[index] = char\n               \
    \ }\n                index += 1\n            }\n        } else {\n           \
    \ var index = 0\n            while index < alphabet.count {\n                if\
    \ let index = alphabet.index(of: char) {\n                    alphabet[index]\
    \ = vowels[index]\n                }\n                index += 1\n           \
    \ }\n        }\n    }\n    return String(alphabet)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpn1gamr48.swift:13:75: error: cannot call value of non-function\
    \ type 'String'\n    var alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    .characters()\n                                                              \
    \            ^         ~~\n                                                  \
    \                                  \n/tmp/tmpn1gamr48.swift:14:26: error: cannot\
    \ call value of non-function type 'String'\n    var vowels = \"AEIOU\".characters()\n\
    \                         ^         ~~\n                                   \n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n\n    for letter in message {\n        if letter <= 'z' {\n        \
    \    result += \"A\" + String(letter).lowercased()\n        } else {\n       \
    \     result += String(letter).lowercased()\n        }\n    }\n\n    for vowel\
    \ in \"aeiou\" {\n        let index = result.index(of: vowel)\n        let start\
    \ = result.index(before: index)\n        let end = result.index(before: start,\
    \ offsetBy: 2)\n\n        result.remove(at: start)\n        result.remove(at:\
    \ end)\n        result.remove(at: index)\n    }\n\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_0f959wj.swift:16:22: error: single-quoted string literal found,\
    \ use '\"'\n        if letter <= 'z' {\n                     ^~~\n           \
    \          \"z\"\n/tmp/tmp_0f959wj.swift:24:28: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        let index = result.index(of: vowel)\n\
    \                           ^\n/tmp/tmp_0f959wj.swift:24:28: note: use 'firstIndex(of:)'\
    \ instead\n        let index = result.index(of: vowel)\n                     \
    \      ^~~~~\n                           firstIndex\n/tmp/tmp_0f959wj.swift:25:42:\
    \ error: value of optional type 'String.Index?' must be unwrapped to a value of\
    \ type 'String.Index'\n        let start = result.index(before: index)\n     \
    \                                    ^\n/tmp/tmp_0f959wj.swift:25:42: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     let start = result.index(before: index)\n                              \
    \           ^\n                                               ?? <#default value#>\n\
    /tmp/tmp_0f959wj.swift:25:42: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        let start = result.index(before:\
    \ index)\n                                         ^\n                       \
    \                       !\n/tmp/tmp_0f959wj.swift:26:26: error: no exact matches\
    \ in call to instance method 'index'\n        let end = result.index(before: start,\
    \ offsetBy: 2)\n                         ^\n/tmp/tmp_0f959wj.swift:26:26: note:\
    \ found candidate with type '(String.Index, Int) -> String.Index'\n        let\
    \ end = result.index(before: start, offsetBy: 2)\n                         ^\n\
    /tmp/tmp_0f959wj.swift:30:27: error: value of optional type 'String.Index?' must\
    \ be unwrapped to a value of type 'String.Index'\n        result.remove(at: index)\n\
    \                          ^\n/tmp/tmp_0f959wj.swift:30:27: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        result.remove(at:\
    \ index)\n                          ^\n                                ?? <#default\
    \ value#>\n/tmp/tmp_0f9"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    var index = 0\n    for char in message {\n        let index2 = getIndex(char,\
    \ index) \n        result += getLetter(char, index2)\n        index = index2\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4x7lwgbu.swift:16:22: error: cannot find 'getIndex' in scope\n\
    \        let index2 = getIndex(char, index) \n                     ^~~~~~~~\n\
    /tmp/tmp4x7lwgbu.swift:17:19: error: cannot find 'getLetter' in scope\n      \
    \  result += getLetter(char, index2)\n                  ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for letter in message.characters.reverse() {\n        guard let\
    \ firstLetter = letter.unicodeScalars.first else { continue }\n        let vowels\
    \ = firstLetter.value == \"A\" || firstLetter.value == \"E\" || firstLetter.value\
    \ == \"I\" || firstLetter.value == \"O\" || firstLetter.value == \"U\"\n     \
    \   let currentIndex = letter.unicodeScalars.count - 1\n        var nextLetter\
    \ = letter\n        \n        // Swap case for all letters in the message\n  \
    \      while currentIndex >= 0 && vowels {\n            nextLetter = UnicodeScalar(letter.unicodeScalars[currentIndex].value\
    \ - \"a\".unicodeScalars.first!.value)\n            currentIndex -= 1\n      \
    \  }\n        \n        // Replace all vowels in the message with the letter that\
    \ appears 2 places ahead of that vowel\n        if vowels {\n            result\
    \ += nextLetter\n        } else {\n            result += letter.unicodeScalars.first!.value\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp8f_6wtu1.swift:14:38: error: value of type 'String' has no member\
    \ 'reverse'\n    for letter in message.characters.reverse() {\n              \
    \    ~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encodedMessage\
    \ = \"\"\n    for char in message {\n        if let currentChar = char.unicodeScalars.first?.value\
    \ {\n            if currentChar >= 0x61 &&\n                currentChar <= 0x7A\
    \ {\n                encodedMessage += \"A\"\n            } else {\n         \
    \       let index = (currentChar - 0x61) / 2\n                if index != 0 {\n\
    \                    encodedMessage += String(UniChar(UnicodeScalar(UInt8(index\
    \ + 0x61))))\n                }\n            }\n        } else {\n           \
    \ encodedMessage += char\n        }\n    }\n    return encodedMessage\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpyv2_0nct.swift:22:46: error: cannot find 'UniChar' in scope\n \
    \                   encodedMessage += String(UniChar(UnicodeScalar(UInt8(index\
    \ + 0x61))))\n                                             ^~~~~~~\n/tmp/tmpyv2_0nct.swift:26:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            encodedMessage += char\n                              ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var output\
    \ = \"?\"\n    for (index, letter) in message.characters.enumerated() {\n    \
    \    var vowels = \"AEIOUaeiou\"\n        let index = letters.index(letter, options:\
    \ .forceLiteralSearch)!\n        let nextLetter = letters[(index + 1) % letters.count]\n\
    \        output += \"\\(letters.prefix(index: index) + nextLetter + letters.suffix(index:\
    \ index))\"\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_2f1y39i.swift:14:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, letter) in message.characters.enumerated()\
    \ {\n                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_2f1y39i.swift:16:21: error: cannot find 'letters'\
    \ in scope\n        let index = letters.index(letter, options: .forceLiteralSearch)!\n\
    \                    ^~~~~~~\n/tmp/tmp_2f1y39i.swift:16:53: error: cannot infer\
    \ contextual base in reference to member 'forceLiteralSearch'\n        let index\
    \ = letters.index(letter, options: .forceLiteralSearch)!\n                   \
    \                                ~^~~~~~~~~~~~~~~~~~\n/tmp/tmp_2f1y39i.swift:17:26:\
    \ error: cannot find 'letters' in scope\n        let nextLetter = letters[(index\
    \ + 1) % letters.count]\n                         ^~~~~~~\n/tmp/tmp_2f1y39i.swift:17:48:\
    \ error: cannot find 'letters' in scope\n        let nextLetter = letters[(index\
    \ + 1) % letters.count]\n                                               ^~~~~~~\n\
    /tmp/tmp_2f1y39i.swift:18:22: error: cannot find 'letters' in scope\n        output\
    \ += \"\\(letters.prefix(index: index) + nextLetter + letters.suffix(index: index))\"\
    \n                     ^~~~~~~\n/tmp/tmp_2f1y39i.swift:18:66: error: cannot find\
    \ 'letters' in scope\n        output += \"\\(letters.prefix(index: index) + nextLetter\
    \ + letters.suffix(index: index))\"\n                                        \
    \                         ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.map { letterInMessage -> String in\n        switch letterInMessage {\n\
    \        case \"A\": return \"G\"\n        case \"E\": return \"I\"\n        case\
    \ \"I\": return \"U\"\n        case \"O\": return \"A\"\n        case \"U\": return\
    \ \"I\"\n        case \"a\": return \"g\"\n        case \"e\": return \"i\"\n\
    \        case \"i\": return \"u\"\n        case \"o\": return \"a\"\n        case\
    \ \"u\": return \"i\"\n        case \"z\": return \"a\"\n        default:\n  \
    \          return letterInMessage\n        }\n    }.joined()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp1g3qh04e.swift:27:20: error: cannot convert return expression of\
    \ type 'String.Element' (aka 'Character') to return type 'String'\n          \
    \  return letterInMessage\n                   ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var output\
    \ = \"\"\n    for char in message {\n        var upperChar = char.uppercased()\n\
    \        var lower = char.lowercased()\n        var vowel = \"AEIOUaeiou\".characters()\n\
    \        for vowelIndex in 0..<vowel.count{\n            var vowelIndex = vowel.index(of:\
    \ vowel[vowelIndex], in: lower)\n            if vowelIndex != nil {\n        \
    \        var index = vowelIndex! + 2\n                if index > lower.count {\n\
    \                    index = lower.count\n                }\n                output\
    \ += upperChar[index..<lower.count]\n                upperChar = lower[index..<lower.count]\n\
    \                lower = lower[index..<lower.count]\n            }\n        }\n\
    \        output = output + upperChar + lower\n    }\n    return output\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp9fmpfqpq.swift:17:34: error: cannot call value of non-function\
    \ type 'String'\n        var vowel = \"AEIOUaeiou\".characters()\n           \
    \                      ^         ~~\n                                        \
    \   \n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tlet alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\tvar result = \"\
    \"\n\tfor ch in message.unicodeScalars {\n\t\tif let index = alphabet.unicodeScalars.index(of:\
    \ ch.value) {\n\t\t\tlet index = alphabet.unicodeScalars.index(of: ch.value, offsetBy:\
    \ 2)\n\t\t\tresult += alphabet[index!]\n\t\t} else {\n\t\t\tresult += String(ch.value)\n\
    \t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3hrkl5g.swift:16:55: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'Unicode.Scalar'\n                if let index = alphabet.unicodeScalars.index(of:\
    \ ch.value) {\n                                                              \
    \      ^\n/tmp/tmpu3hrkl5g.swift:17:40: error: no exact matches in call to instance\
    \ method 'index'\n                        let index = alphabet.unicodeScalars.index(of:\
    \ ch.value, offsetBy: 2)\n                                                   \
    \         ^\n/tmp/tmpu3hrkl5g.swift:17:40: note: candidate has partially matching\
    \ parameter list (String.UnicodeScalarView.Index, offsetBy: Int)\n           \
    \             let index = alphabet.unicodeScalars.index(of: ch.value, offsetBy:\
    \ 2)\n                                                            ^\n/tmp/tmpu3hrkl5g.swift:17:40:\
    \ note: candidate has partially matching parameter list (String.UnicodeScalarView.Index,\
    \ offsetBy: Int)\n                        let index = alphabet.unicodeScalars.index(of:\
    \ ch.value, offsetBy: 2)\n                                                   \
    \         ^\n/tmp/tmpu3hrkl5g.swift:17:40: note: candidate has partially matching\
    \ parameter list (String.UnicodeScalarView.Index, offsetBy: Int)\n           \
    \             let index = alphabet.unicodeScalars.index(of: ch.value, offsetBy:\
    \ 2)\n                                                            ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encodedMessage\
    \ = \"\"\n\n    for letter in message.characters {\n        if letter.isUppercase\
    \ {\n            encodedMessage += letter\n        } else {\n            switch\
    \ letter {\n            case \"a\", \"e\", \"i\", \"o\", \"u\":\n            \
    \    encodedMessage += letter\n            case \"A\", \"E\", \"I\", \"O\", \"\
    U\":\n                encodedMessage += letter\n            default:\n       \
    \         let index = Int(letter) - Int(\"a\")\n                encodedMessage\
    \ += String(message.substringWithRange(NSMakeRange(index, 1)))\n            }\n\
    \        }\n    }\n    return encodedMessage\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpde19d0jd.swift:15:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in message.characters {\n              \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpde19d0jd.swift:17:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            encodedMessage += letter\n \
    \                             ^\n/tmp/tmpde19d0jd.swift:21:35: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   encodedMessage += letter\n                                  ^\n/tmp/tmpde19d0jd.swift:23:35:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                encodedMessage += letter\n                                  ^\n\
    /tmp/tmpde19d0jd.swift:25:29: error: no exact matches in call to initializer \n\
    \                let index = Int(letter) - Int(\"a\")\n                      \
    \      ^\n/tmp/tmpde19d0jd.swift:25:29: note: candidate expects value of type\
    \ 'Float16' for parameter #1 (got 'Character')\n                let index = Int(letter)\
    \ - Int(\"a\")\n                            ^\n/tmp/tmpde19d0jd.swift:25:29: note:\
    \ candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \                let index = Int(letter) - Int(\"a\")\n                      \
    \      ^\n/tmp/tmpde19d0jd.swift:25:29: note: candidate expects value of type\
    \ 'Double' for parameter #1 (got 'Character')\n                let index = Int(letter)\
    \ - Int(\"a\")\n                            ^\n/tmp/tmpde19d0jd.swift:25:29: note:\
    \ candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \                let index = Int(letter) - Int(\"a\")\n                      \
    \      ^\n/tmp/tmpde19d0jd.swift:25:29: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n                let index\
    \ = Int(letter) - Int(\"a\")\n                            ^\n/tmp/tmpde19d0jd.swift:25:29:\
    \ note: candidate expects val"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let result\
    \ = \"\"\n    let vowels = vowels.characters\n\n    for char in message {\n  \
    \      if let index = vowels.index(of: char) {\n            let vowel = vowels[index]\n\
    \            let index2 = vowels.index(of: vowel, offsetBy: 1)\n            if\
    \ index2 != nil {\n                result += vowels[index!] + char\n         \
    \   } else {\n                result += vowel\n            }\n        } else {\n\
    \            result += char\n        }\n    }\n\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpp6ngh1a5.swift:14:18: error: use of local variable 'vowels' before\
    \ its declaration\n    let vowels = vowels.characters\n                 ^\n/tmp/tmpp6ngh1a5.swift:14:9:\
    \ note: 'vowels' declared here\n    let vowels = vowels.characters\n        ^\n\
    /tmp/tmpp6ngh1a5.swift:26:20: error: binary operator '+=' cannot be applied to\
    \ operands of type 'String' and 'Character'\n            result += char\n    \
    \               ^\nSwift.RangeReplaceableCollection:4:35: note: candidate requires\
    \ that 'Character' conform to 'Sequence' (requirement specified as 'Other' : 'Sequence')\n\
    \    @inlinable public static func += <Other>(lhs: inout Self, rhs: Other) where\
    \ Other : Sequence, Self.Element == Other.Element\n                          \
    \        ^\n/tmp/tmpp6ngh1a5.swift:26:20: error: left side of mutating operator\
    \ isn't mutable: 'result' is a 'let' constant\n            result += char\n  \
    \          ~~~~~~ ^\n/tmp/tmpp6ngh1a5.swift:13:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let result = \"\"\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var\
    \ result = \"\"\n    for char in message {\n        \n        let letter = UnicodeScalar(char)\n\
    \        \n        // Swaps case for all letters.\n        // Replace all vowels\
    \ in message with 2 letters ahead\n        if letter.value > 64 && letter.value\
    \ < 91 {\n            \n            result += String(UnicodeScalar(letter.value\
    \ - 64))\n            result += String(UnicodeScalar(letter.value + 2))\n    \
    \    }\n        \n        // Replace all vowels in message with 1 letter ahead\n\
    \        /*\n        if letter.value > 64 && letter.value < 91 {\n           \
    \ \n            result += String(UnicodeScalar(letter.value))\n            result\
    \ += String(UnicodeScalar(letter.value + 1))\n        }\n        */\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpujdhxhsv.swift:17:22: error: no exact matches in call to initializer\
    \ \n        let letter = UnicodeScalar(char)\n                     ^\nSwift.Unicode.Scalar:5:23:\
    \ note: candidate expects value of type 'UInt32' for parameter #1 (got 'Character')\n\
    \    @inlinable public init?(_ v: UInt32)\n                      ^\nSwift.Unicode.Scalar:6:23:\
    \ note: candidate expects value of type 'UInt16' for parameter #1 (got 'Character')\n\
    \    @inlinable public init?(_ v: UInt16)\n                      ^\nSwift.Unicode.Scalar:7:23:\
    \ note: candidate expects value of type 'UInt8' for parameter #1 (got 'Character')\n\
    \    @inlinable public init(_ v: UInt8)\n                      ^\nSwift.Unicode.Scalar:8:23:\
    \ note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got\
    \ 'Character')\n    @inlinable public init(_ v: Unicode.Scalar)\n            \
    \          ^\nSwift.Unicode.Scalar:2:23: note: candidate expects value of type\
    \ 'String' for parameter #1 (got 'Character')\n    @inlinable public init?(_ description:\
    \ String)\n                      ^\nSwift.Unicode.Scalar:2:23: note: candidate\
    \ expects value of type 'Int' for parameter #1 (got 'Character')\n    @inlinable\
    \ public init?(_ v: Int)\n                      ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    guard let\
    \ vowels = \"aeiouAEIOU\".characters.map{ String($0) }.sorted \n        else {\
    \ return message }\n    let messageAsArray = message.characters\n    let vowelsAsArray\
    \ = vowels.characters\n    let vowelIndexLookup = Array(vowelsAsArray).enumerated().map\
    \ { index, element in\n        let index = index\n        let vowel = element\n\
    \        return (index, vowel)\n    }\n    let messageWithVowels = messageAsArray.reduce(\"\
    \") {\n        (acc, nextCharacter, index, vowels) in\n        if let index =\
    \ vowelIndexLookup[(index + 1)] where index < vowels.count {\n            return\
    \ acc + String(vowels[index])\n        } else {\n            return acc + nextCharacter\n\
    \        }\n    }\n    var result = ''\n    for char in messageWithVowels {\n\
    \        result = result + String(vowels.sorted().firstIndex(of: char))\n    }\n\
    \    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp8v5qg4vw.swift:24:54: error: expected ',' joining parts of a multi-clause\
    \ condition\n        if let index = vowelIndexLookup[(index + 1)] where index\
    \ < vowels.count {\n                                                    ~^~~~~\n\
    \                                                    ,\n/tmp/tmp8v5qg4vw.swift:30:18:\
    \ error: single-quoted string literal found, use '\"'\n    var result = ''\n \
    \                ^~\n                 \"\"\n/tmp/tmp8v5qg4vw.swift:13:37: error:\
    \ 'characters' is unavailable: Please use String directly\n    guard let vowels\
    \ = \"aeiouAEIOU\".characters.map{ String($0) }.sorted \n                    \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8v5qg4vw.swift:13:51: warning: trailing closure in this context is\
    \ confusable with the body of the statement; pass as a parenthesized argument\
    \ to silence this warning\n    guard let vowels = \"aeiouAEIOU\".characters.map{\
    \ String($0) }.sorted \n                                                  ^\n\
    \                                                  (             )\n/tmp/tmp8v5qg4vw.swift:13:11:\
    \ error: initializer for conditional binding must have Optional type, not '()\
    \ -> [String]'\n    guard let vowels = \"aeiouAEIOU\".characters.map{ String($0)\
    \ }.sorted \n          ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8v5qg4vw.swift:15:34: error: 'characters' is unavailable: Please use String\
    \ directly\n    let messageAsArray = message.characters\n                    \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8v5qg4vw.swift:16:32: error: value of type '() -> [String]' has no\
    \ member 'characters'\n    let vowelsAsArray = vowels.characters\n           \
    \             ~~~~~~ ^~~~~~~~~~\n/tmp/tmp8v5qg4vw.swift:23:9: error: contextual\
    \ closure type '(String, String.Element) throws -> String' (aka '(String, Character)\
    \ throws -> String') expects 2 ar"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.characters\n        .reduce(\"\") { acc, character -> String in\n  \
    \          let (currentVowelCount, currentVowel) = character.isVowel()\n     \
    \       switch currentVowelCount {\n            case 0: return acc + character\n\
    \            case 1: return acc + currentVowel + character\n            default:\n\
    \                if character.isLetter() && ((acc.index(of: character) != acc.endIndex)\
    \ && currentVowelCount == 1) {\n                    return acc + currentVowel\
    \ + character\n                } else {\n                    return acc\n    \
    \            }\n            }\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpy4k4xcqi.swift:15:63: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'isVowel'\n            let (currentVowelCount, currentVowel)\
    \ = character.isVowel()\n                                                    ~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for i in 0..<message.characters.count {\n        let letter = message.characters[i]\n\
    \        if let vowel = vowelsMap[letter] {\n            result += vowel\n   \
    \     } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp7v1o4gul.swift:14:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<message.characters.count {\n         \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7v1o4gul.swift:15:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let letter\
    \ = message.characters[i]\n                     ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7v1o4gul.swift:15:30:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ letter = message.characters[i]\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp7v1o4gul.swift:16:24: error: cannot find\
    \ 'vowelsMap' in scope\n        if let vowel = vowelsMap[letter] {\n         \
    \              ^~~~~~~~~\n/tmp/tmp7v1o4gul.swift:19:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result\
    \ += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for letter in message {\n        var newLetter = letter\n      \
    \  var vowelIndex = 2\n        if letter == \"a\" || letter == \"e\" || letter\
    \ == \"i\" {\n            vowelIndex = 1\n        }\n        newLetter = SwiftVowels[letter][vowelIndex]\n\
    \        for vowel in SwiftVowels[letter] {\n            result += newLetter\n\
    \            vowelIndex++\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpzougs0kj.swift:20:21: error: cannot find 'SwiftVowels' in scope\n\
    \        newLetter = SwiftVowels[letter][vowelIndex]\n                    ^~~~~~~~~~~\n\
    /tmp/tmpzougs0kj.swift:21:22: error: cannot find 'SwiftVowels' in scope\n    \
    \    for vowel in SwiftVowels[letter] {\n                     ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encodedMessage\
    \ = [String]()\n    \n    // Build a dictionary to map the english letters to\
    \ the 2 letter\n    // ones ahead of them. \n    var pairs: [String: String] =\
    \ [:]\n    \n    // Iterate over the entire message and swap case\n    for i in\
    \ 0..<message.count {\n        \n        let index = Int(i) % message.count\n\
    \        \n        let character = message[index]\n        \n        // Get the\
    \ 2 letters ahead of 'character'\n        let pair = pairs[character]\n      \
    \  \n        // The letter appears 2 places ahead, swap with the letter\n    \
    \    // appearing 2 places ago.\n        if pair != nil {\n            encodedMessage.append(pair!)\n\
    \        } else {\n            encodedMessage.append(character)\n        }\n \
    \       \n        pairs[character] = message[index + 1:]\n    }\n    \n    return\
    \ encodedMessage.joinWithSeparator(\"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpxo0wwc8h.swift:37:45: error: expected ',' separator\n        pairs[character]\
    \ = message[index + 1:]\n                                            ^\n     \
    \                                       ,\n/tmp/tmpxo0wwc8h.swift:37:45: error:\
    \ expected expression in list of expressions\n        pairs[character] = message[index\
    \ + 1:]\n                                            ^\n/tmp/tmpxo0wwc8h.swift:24:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let character = message[index]\n      \
    \                  ^~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpxo0wwc8h.swift:27:25: error: no exact matches\
    \ in call to subscript \n        let pair = pairs[character]\n               \
    \         ^\nSwift.Dictionary:8:23: note: candidate expects value of type 'Dictionary<String,\
    \ String>.Index' for parameter #1 (got 'Character')\n    @inlinable public subscript(position:\
    \ Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Element { get }\n  \
    \                    ^\nSwift.Dictionary:2:23: note: candidate expects value of\
    \ type 'String' for parameter #1 (got 'Character')\n    @inlinable public subscript(key:\
    \ Key) -> Value? { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: candidate expects value of type 'Range<Dictionary<String, String>.Index>'\
    \ for parameter #1 (got 'Character')\n    @inlinable public subscript(bounds:\
    \ Range<Self.Index>) -> Slice<Self> { get }\n                      ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Character')\n    @inlinable public subscript(x: (UnboundedRange_) ->\
    \ ()) -> Self.SubSequence { get }\n                      ^\n/tmp/tmpxo0wwc8h.swift:34:35:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            encodedMessage.append(character)\n                              \
    \    ^\n/tmp/tmpxo0wwc8h.swift:37:14: error: no exac"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"aeiouAEIOU\"\n    var resultString = \"\"\n    \n    for i in 0..<message.characters.count\
    \ {\n        let letter = message.substring(with: NSRange(location: i, length:\
    \ 1))\n        let letterIndex = letter.characters.firstIndex(of: vowels)\n  \
    \      if letterIndex == nil {\n            resultString += letter\n        }\
    \ else {\n            let replacement = letter.substring(to: letterIndex!)\n \
    \           resultString += letter.substring(from: letterIndex!.advanced(by: 1))\n\
    \            resultString += replacement\n        }\n    }\n    return resultString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpkv8yn2e1.swift:16:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<message.characters.count {\n         \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpkv8yn2e1.swift:17:46: error: cannot find 'NSRange' in scope\n   \
    \     let letter = message.substring(with: NSRange(location: i, length: 1))\n\
    \                                             ^~~~~~~\n/tmp/tmpkv8yn2e1.swift:17:30:\
    \ error: value of type 'String' has no member 'substring'\n        let letter\
    \ = message.substring(with: NSRange(location: i, length: 1))\n               \
    \      ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encodedMessage\
    \ = \"\"\n    for c in message {\n        if letters[c.asciiValue] != nil {\n\
    \            if let nextLetter = letters[c.asciiValue]!.unicodeScalars.first {\n\
    \                let replacement = Character(nextLetter)\n                encodedMessage\
    \ += replacement\n            }\n        } else {\n            encodedMessage\
    \ += c\n        }\n    }\n    return encodedMessage\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ml5uf9d.swift:15:12: error: cannot find 'letters' in scope\n \
    \       if letters[c.asciiValue] != nil {\n           ^~~~~~~\n/tmp/tmp_ml5uf9d.swift:16:33:\
    \ error: cannot find 'letters' in scope\n            if let nextLetter = letters[c.asciiValue]!.unicodeScalars.first\
    \ {\n                                ^~~~~~~\n/tmp/tmp_ml5uf9d.swift:21:31: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            encodedMessage += c\n                              ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tvar result\
    \ = \"\"\n\tfor ch in message {\n\t\tch = replaceLetters(ch)\n\t\tswitch ch {\n\
    \t\tcase \"a\":\n\t\t\tresult += \"A\"\n\t\tcase \"b\":\n\t\t\tresult += \"B\"\
    \n\t\tcase \"c\":\n\t\t\tresult += \"C\"\n\t\tcase \"d\":\n\t\t\tresult += \"\
    D\"\n\t\tcase \"e\":\n\t\t\tresult += \"E\"\n\t\tcase \"f\":\n\t\t\tresult +=\
    \ \"F\"\n\t\tcase \"g\":\n\t\t\tresult += \"G\"\n\t\tcase \"h\":\n\t\t\tresult\
    \ += \"H\"\n\t\tcase \"i\":\n\t\t\tresult += \"I\"\n\t\tcase \"j\":\n\t\t\tresult\
    \ += \"J\"\n\t\tcase \"k\":\n\t\t\tresult += \"K\"\n\t\tcase \"l\":\n\t\t\tresult\
    \ += \"L\"\n\t\tcase \"m\":\n\t\t\tresult += \"M\"\n\t\tcase \"n\":\n\t\t\tresult\
    \ += \"N\"\n\t\tcase \"o\":\n\t\t\tresult += \"O\"\n\t\tcase \"p\":\n\t\t\tresult\
    \ += \"P\"\n\t\tcase \"q\":\n\t\t\tresult += \"Q\"\n\t\tcase \"r\":\n\t\t\tresult\
    \ += \"R\"\n\t\tcase \"s\":\n\t\t\tresult += \"S\"\n\t\tcase \"t\":\n\t\t\tresult\
    \ += \"T\"\n\t\tcase \"u\":\n\t\t\tresult += \"U\"\n\t\tcase \"v\":\n\t\t\tresult\
    \ += \"V\"\n\t\tcase \"w\":\n\t\t\tresult += \"W\"\n\t\tcase \"x\":\n\t\t\tresult\
    \ += \"X\"\n\t\tcase \"y\":\n\t\t\tresult += \"Y\"\n\t\tcase \"z\":\n\t\t\tresult\
    \ += \"Z\"\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpdhtn3pfu.swift:15:8: error: cannot find 'replaceLetters' in scope\n\
    \                ch = replaceLetters(ch)\n                     ^~~~~~~~~~~~~~\n\
    /tmp/tmpdhtn3pfu.swift:15:3: error: cannot assign to value: 'ch' is a 'let' constant\n\
    \                ch = replaceLetters(ch)\n                ^~\n/tmp/tmpdhtn3pfu.swift:16:3:\
    \ error: switch must be exhaustive\n                switch ch {\n            \
    \    ^\n/tmp/tmpdhtn3pfu.swift:16:3: note: do you want to add a default clause?\n\
    \                switch ch {\n                ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tletters :=\
    \ Array(message).map{ String($0) }\n\tvowels := [\"a\", \"e\", \"i\", \"o\", \"\
    u\"]\n\tresult := \"\"\n\tfor _, letter := range letters {\n\t\tresult += letter\n\
    \t\tfor _, vowel := range vowels {\n\t\t\tn := vowels.index(vowel)\n\t\t\tif n\
    \ > 0 {\n\t\t\t\tresult += vowels[(n-1)%len(vowels)]\n\t\t\t}\n\t\t}\n\t\tresult\
    \ += \" \"\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpojh8rdhy.swift:13:9: error: consecutive statements on a line must\
    \ be separated by ';'\n        letters := Array(message).map{ String($0) }\n \
    \              ^\n               ;\n/tmp/tmpojh8rdhy.swift:13:10: error: expected\
    \ expression\n        letters := Array(message).map{ String($0) }\n          \
    \      ^\n/tmp/tmpojh8rdhy.swift:16:7: error: expected 'in' after for-each pattern\n\
    \        for _, letter := range letters {\n             ^\n/tmp/tmpojh8rdhy.swift:16:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, letter\
    \ := range letters {\n             ^\n/tmp/tmpojh8rdhy.swift:18:8: error: expected\
    \ 'in' after for-each pattern\n                for _, vowel := range vowels {\n\
    \                     ^\n/tmp/tmpojh8rdhy.swift:18:8: error: expected Sequence\
    \ expression for for-each loop\n                for _, vowel := range vowels {\n\
    \                     ^\n/tmp/tmpojh8rdhy.swift:19:5: error: consecutive statements\
    \ on a line must be separated by ';'\n                        n := vowels.index(vowel)\n\
    \                         ^\n                         ;\n/tmp/tmpojh8rdhy.swift:19:6:\
    \ error: expected expression\n                        n := vowels.index(vowel)\n\
    \                          ^\n/tmp/tmpojh8rdhy.swift:13:2: error: cannot find\
    \ 'letters' in scope\n        letters := Array(message).map{ String($0) }\n  \
    \      ^~~~~~~\n/tmp/tmpojh8rdhy.swift:26:9: error: cannot find 'result' in scope\n\
    \        return result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // TODO:\
    \ Replace this implementation with the solution to the \n    // previous question\
    \ that uses the improved String/character\n    // solution. \n    let vowels =\
    \ \"aeiouAEIOU\"\n    let messageLength = message.characters.count\n    \n   \
    \ let alphabet = \"abcdefghijklmnopqrstuvwxyz\".characters\n    \n    var output\
    \ = [String]()\n    var index = 0\n    \n    // For each letter in the message\n\
    \    for letter in message.characters {\n        // Replace the vowels\n     \
    \   let vowelIndex = alphabet.index(of: letter)\n        if let vowelIndex = vowelIndex\
    \ {\n            letter = alphabet[vowelIndex + 2]\n        }\n        \n    \
    \    // Swap the letters\n        let firstIndex: Int = alphabet.index(of: letter,\
    \ offsetBy: index)\n        let secondIndex: Int = alphabet.index(of: letter,\
    \ offsetBy: index + 1)\n        \n        if firstIndex != nil && secondIndex\
    \ != nil {\n            let first = alphabet[firstIndex]\n            let second\
    \ = alphabet[secondIndex]\n            \n            output += [first, second]\n\
    \            \n            index += 2\n        }\n        \n        // Add the\
    \ letter to the output\n        output += [letter]\n    }\n    \n    return String(output)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp9v2y165c.swift:17:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    let messageLength = message.characters.count\n    \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9v2y165c.swift:19:49: error: 'characters' is unavailable:\
    \ Please use String directly\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .characters\n                                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp9v2y165c.swift:25:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    for letter in message.characters\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9v2y165c.swift:27:35: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        let vowelIndex = alphabet.index(of: letter)\n\
    \                                  ^\n/tmp/tmp9v2y165c.swift:27:35: note: use\
    \ 'firstIndex(of:)' instead\n        let vowelIndex = alphabet.index(of: letter)\n\
    \                                  ^~~~~\n                                  firstIndex\n\
    /tmp/tmp9v2y165c.swift:29:31: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            letter = alphabet[vowelIndex +\
    \ 2]\n                              ^\n/tmp/tmp9v2y165c.swift:29:13: error: cannot\
    \ assign to value: 'letter' is a 'let' constant\n            letter = alphabet[vowelIndex\
    \ + 2]\n            ^~~~~~\n/tmp/tmp9v2y165c.swift:33:45: error: extraneous argument\
    \ label 'of:' in call\n        let firstIndex: Int = alphabet.index(of: letter,\
    \ offsetBy: index)\n                                            ^~~~~\n      \
    \                                       \n/tmp/tmp9v2y165c.swift:33:50: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String.Index'\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tlet vowels:\
    \ Set<Character> = Set(\"AEIOUaeiou\")\n\treturn message.unicodeScalars.filter({\
    \ vowels.contains($0.value)}).map {\n\t\tlet index = vowels.index($0.value)!\n\
    \t\treturn message.unicodeScalars.map { \n\t\t\tlet c = String($0.value)\n\t\t\
    \tif c == $0.value {\n\t\t\t\treturn String(index)\n\t\t\t} else {\n\t\t\t\treturn\
    \ c\n\t\t\t}\n\t\t}.join()\n\t}.reduce(\"\") { (acc, c) in \n\t\treturn acc +\
    \ c\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpm5ve_jqk.swift:14:60: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'Character'\n        return message.unicodeScalars.filter({\
    \ vowels.contains($0.value)}).map {\n                                        \
    \                          ^\n/tmp/tmpm5ve_jqk.swift:15:28: error: missing argument\
    \ label 'of:' in call\n                let index = vowels.index($0.value)!\n \
    \                                        ^\n                                 \
    \        of: \n/tmp/tmpm5ve_jqk.swift:15:31: error: cannot convert value of type\
    \ 'UInt32' to expected argument type 'Character'\n                let index =\
    \ vowels.index($0.value)!\n                                            ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encoded:\
    \ String = \"\"\n    for letter in message {\n        if letter.lowercased() ==\
    \ \"a\" || letter.lowercased() == \"e\" || letter.lowercased() == \"i\" || letter.lowercased()\
    \ == \"o\" || letter.lowercased() == \"u\" {\n            encoded += letter\n\
    \        } else {\n            let position = vowels.position(of: letter)\n  \
    \          let index = (position?.element ?? 0) - 1\n            if index >= 0\
    \ {\n                let vowel = vowels[index]\n                let replacement\
    \ = vowel.uppercased()\n                encoded += String(replacement)\n     \
    \       }\n        }\n    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp0t3i2367.swift:16:24: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            encoded += letter\n        \
    \               ^\n/tmp/tmp0t3i2367.swift:18:28: error: cannot find 'vowels' in\
    \ scope\n            let position = vowels.position(of: letter)\n            \
    \               ^~~~~~\n/tmp/tmp0t3i2367.swift:21:29: error: cannot find 'vowels'\
    \ in scope\n                let vowel = vowels[index]\n                      \
    \      ^~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Create\
    \ an array that keeps track of which letters have been swapped.\n    var swapped\
    \ = [String]()\n\n    // Loop through every letter in message\n    for letter\
    \ in message {\n        // If the letter is in the swapped array\n        if swapped.contains(letter)\
    \ {\n            // If there are 2 letters ahead of it, replace the vowel\n  \
    \          index = swapped.index(of: letter)\n            swapped[index] = letter\
    \ + letters[index + 1 ..< letters.count].first!\n        } else if letters.contains(letter)\
    \ {\n            // If it's not a vowel, replace it with a vowel\n           \
    \ index = letters.index(of: letter)\n            swapped[index] = letter + letters[index\
    \ + 1 ..< letters.count].first!\n        } else {\n            // If the letter\
    \ is not in the swapped array,\n            // then it's not a vowel.\n      \
    \      swapped.append(letter)\n        }\n    }\n\n    // Reverse the array\n\
    \    return String(swapped).reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpidv5_iyo.swift:19:29: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if swapped.contains(letter) {\n\
    \                            ^\n/tmp/tmpidv5_iyo.swift:21:13: error: cannot find\
    \ 'index' in scope\n            index = swapped.index(of: letter)\n          \
    \  ^~~~~\n/tmp/tmpidv5_iyo.swift:21:39: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            index = swapped.index(of: letter)\n\
    \                                      ^\n/tmp/tmpidv5_iyo.swift:22:21: error:\
    \ cannot find 'index' in scope\n            swapped[index] = letter + letters[index\
    \ + 1 ..< letters.count].first!\n                    ^~~~~\n/tmp/tmpidv5_iyo.swift:22:39:\
    \ error: cannot find 'letters' in scope\n            swapped[index] = letter +\
    \ letters[index + 1 ..< letters.count].first!\n                              \
    \        ^~~~~~~\n/tmp/tmpidv5_iyo.swift:22:47: error: cannot find 'index' in\
    \ scope\n            swapped[index] = letter + letters[index + 1 ..< letters.count].first!\n\
    \                                              ^~~~~\n/tmp/tmpidv5_iyo.swift:22:61:\
    \ error: cannot find 'letters' in scope\n            swapped[index] = letter +\
    \ letters[index + 1 ..< letters.count].first!\n                              \
    \                              ^~~~~~~\n/tmp/tmpidv5_iyo.swift:22:30: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       swapped[index] = letter + letters[index + 1 ..< letters.count].first!\n\
    \                             ^\n/tmp/tmpidv5_iyo.swift:23:19: error: cannot find\
    \ 'letters' in scope\n        } else if letters.contains(letter) {\n         \
    \         ^~~~~~~\n/tmp/tmpidv5_iyo.swift:25:13: error: cannot find 'index' in\
    \ scope\n            index = letters.index(of: letter)\n            ^~~~~\n/tmp/tmpidv5_iyo.swift:25:21:\
    \ error: cannot find 'letters' in scope\n            index = letters.index(of:\
    \ letter)\n                    ^~~~~~~\n/tmp/tmpidv5_iyo.swift:26:21: error: cannot\
    \ find 'index' in scope\n            swapped[index] = letter + letters[i"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n  var vowels\
    \ = \"aeiouAEIOU\"\n  var message = message.lowercased()\n\n  for c in message\
    \ {\n    if vowels.contains(c.lowercased()) {\n      c = c.swapcase()\n    }\n\
    \    \n    let i = indexOf(c, vowels)\n    \n    if i == nil {\n      c += \"\
    \ \"\n    }\n    else {\n      c = String(c).dropFirst(i! + 1).append(String(c).dropFirst(i!))\n\
    \    }\n  }\n\n  return String(message)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_g0h2gpf.swift:18:7: error: cannot assign to value: 'c' is a 'let'\
    \ constant\n      c = c.swapcase()\n      ^\n/tmp/tmp_g0h2gpf.swift:18:13: error:\
    \ value of type 'Character' has no member 'swapcase'\n      c = c.swapcase()\n\
    \          ~ ^~~~~~~~\n/tmp/tmp_g0h2gpf.swift:21:13: error: cannot find 'indexOf'\
    \ in scope\n    let i = indexOf(c, vowels)\n            ^~~~~~~\n/tmp/tmp_g0h2gpf.swift:24:7:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \      c += \" \"\n      ^\n/tmp/tmp_g0h2gpf.swift:27:7: error: cannot assign\
    \ to value: 'c' is a 'let' constant\n      c = String(c).dropFirst(i! + 1).append(String(c).dropFirst(i!))\n\
    \      ^\n/tmp/tmp_g0h2gpf.swift:27:39: error: value of type 'DropFirstSequence<String>'\
    \ has no member 'append'\n      c = String(c).dropFirst(i! + 1).append(String(c).dropFirst(i!))\n\
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    if message\
    \ == \"\" {\n        return message\n    }\n    \n    let vowels = \"aeiouAEIOU\"\
    \n    var newMessage = \"\"\n    let vowelIndices = Array(0...message.characters.count).filter\
    \ { (idx: Int) -> Bool in\n        let char = message.characters.index(of: String.init(charactersIn:\
    \ message.characters)[idx])!\n        \n        return vowels.contains(String(char))\n\
    \    }\n    \n    for letter in message.characters {\n        if let idx = vowelIndices.index(of:\
    \ String(letter)) {\n            let twoLettersBeforeVowel = String(message.characters[idx\
    \ + (1 ..< message.characters.count)].characters)\n            if let vowelIndex\
    \ = vowelIndices.first {\n                let vowel = String(message.characters[vowelIndex])\n\
    \                \n                if twoLettersBeforeVowel.contains(vowel) {\n\
    \                    newMessage = newMessage + String(vowel)\n               \
    \     vowelIndices.remove(at: idx)\n                }\n            }\n       \
    \ }\n    }\n    \n    for idx in vowelIndices {\n        let char = String(message.characters[idx])\n\
    \        newMessage = newMessage + String(char)\n    }\n    \n    return newMessage\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpj9g02jpt.swift:20:60: error: extraneous argument label 'charactersIn:'\
    \ in call\n        let char = message.characters.index(of: String.init(charactersIn:\
    \ message.characters)[idx])!\n                                               \
    \            ^~~~~~~~~~~~~~~\n                                               \
    \             \n/tmp/tmpj9g02jpt.swift:25:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    for letter in message.characters {\n       \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    \n    for letter in message {\n        \n        // TODO: swap case\n\
    \        \n        // TODO: replace vowels\n    }\n    \n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmp449ks8d6/tmp449ks8d6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1df2b03c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1df27fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1df27fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1df27f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp449ks8d6                        0x000055c52f6423b7 <unavailable> + 5047

    5    libc.so.6                          0x00002b1df2cef460 __libc_start_main +
    245

    6    tmp449ks8d6                        0x000055c52f641ff9 <unavailable> + 4089

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let letters\
    \ = Array(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"\
    l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"\
    y\",\"z\")\n    let vowels = Array(\"a\",\"e\",\"i\",\"o\",\"u\")\n    let swapped\
    \ = message.characters.map { $0.lowercased().swapped().map { letters.contains($0)\
    \ ? letters[letters.firstIndex(of: $0)!] : letter } }\n    return String(swapped)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpqwklynff.swift:13:24: error: missing argument label 'arrayLiteral:'\
    \ in call\n    let letters = Array(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"\
    h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"\
    u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n                       ^\n               \
    \         arrayLiteral: \n/tmp/tmpqwklynff.swift:14:23: error: missing argument\
    \ label 'arrayLiteral:' in call\n    let vowels = Array(\"a\",\"e\",\"i\",\"o\"\
    ,\"u\")\n                      ^\n                       arrayLiteral: \n/tmp/tmpqwklynff.swift:15:138:\
    \ error: cannot find 'letter' in scope\n    let swapped = message.characters.map\
    \ { $0.lowercased().swapped().map { letters.contains($0) ? letters[letters.firstIndex(of:\
    \ $0)!] : letter } }\n                                                       \
    \                                                                            \
    \      ^~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    if message.isEmpty\
    \ {\n        return message\n    }\n    var ascii = [UInt8](count: 256, repeatedValue:\
    \ 0)\n    var message = message.lowercased()\n    message.forEach { \n       \
    \ let value = $0.asciiValue \n        if value < 97 || value > 122 {\n       \
    \     return\n        }\n        ascii[value] = value \n    }\n\n    var resultString\
    \ = \"\"\n    for i in 0..<message.count {\n        let previousVowel = message.index(message.startIndex,\
    \ offsetBy: -i)\n        if ascii[message[i]] != ascii[previousVowel] {\n    \
    \        resultString += String(ascii[message[i]])\n        }\n    }\n    return\
    \ resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmply3y2s_o.swift:16:17: error: no exact matches in call to initializer\
    \ \n    var ascii = [UInt8](count: 256, repeatedValue: 0)\n                ^\n\
    /tmp/tmply3y2s_o.swift:16:17: note: candidate has partially matching parameter\
    \ list (repeating: UInt8, count: Int)\n    var ascii = [UInt8](count: 256, repeatedValue:\
    \ 0)\n                ^\n/tmp/tmply3y2s_o.swift:16:17: note: candidate has partially\
    \ matching parameter list (repeating: UInt8, count: Int)\n    var ascii = [UInt8](count:\
    \ 256, repeatedValue: 0)\n                ^\n/tmp/tmply3y2s_o.swift:20:12: error:\
    \ value of optional type 'UInt8?' must be unwrapped to a value of type 'UInt8'\n\
    \        if value < 97 || value > 122 {\n           ^\n/tmp/tmply3y2s_o.swift:20:12:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if value < 97 || value > 122 {\n           ^\n              \
    \   ?? <#default value#>\n/tmp/tmply3y2s_o.swift:20:12: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        if value\
    \ < 97 || value > 122 {\n           ^\n                !\n/tmp/tmply3y2s_o.swift:20:26:\
    \ error: value of optional type 'UInt8?' must be unwrapped to a value of type\
    \ 'UInt8'\n        if value < 97 || value > 122 {\n                         ^\n\
    /tmp/tmply3y2s_o.swift:20:26: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n        if value < 97 || value > 122 {\n\
    \                         ^\n                               ?? <#default value#>\n\
    /tmp/tmply3y2s_o.swift:20:26: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        if value < 97 || value > 122 {\n\
    \                         ^\n                              !\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    if message.characters.count\
    \ < 3 {\n        return \"\"\n    }\n    \n    var result = \"\"\n    let vowels\
    \ = \"aeiou\"\n    for letter in message.characters {\n        let index = alphabet.index(of:\
    \ letter)!\n        if vowels.contains(String(letter)) {\n            let index\
    \ = alphabet.index(of: String(letter))!\n            result += String(alphabet[index\
    \ + (index + 1)])\n        } else {\n            result += String(alphabet[index\
    \ + (index + 1)])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpjp6yb1mk.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    if message.characters.count < 3 {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjp6yb1mk.swift:19:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in message.characters {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpjp6yb1mk.swift:20:21: error: cannot find\
    \ 'alphabet' in scope\n        let index = alphabet.index(of: letter)!\n     \
    \               ^~~~~~~~\n/tmp/tmpjp6yb1mk.swift:22:25: error: cannot find 'alphabet'\
    \ in scope\n            let index = alphabet.index(of: String(letter))!\n    \
    \                    ^~~~~~~~\n/tmp/tmpjp6yb1mk.swift:23:30: error: cannot find\
    \ 'alphabet' in scope\n            result += String(alphabet[index + (index +\
    \ 1)])\n                             ^~~~~~~~\n/tmp/tmpjp6yb1mk.swift:25:30: error:\
    \ cannot find 'alphabet' in scope\n            result += String(alphabet[index\
    \ + (index + 1)])\n                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let characters\
    \ = Array(message)\n        .filter {\n            let unicodeScalar = $0.unicodeScalars.first!\n\
    \            return unicodeScalar.value > 65 && unicodeScalar.value < 65 + 26\n\
    \        }\n\n    let replacements = [\n        \"A\"    : \"a\",\n        \"\
    B\"    : \"b\",\n        \"C\"    : \"c\",\n        \"D\"    : \"d\",\n      \
    \  \"E\"    : \"e\",\n        \"F\"    : \"f\",\n        \"G\"    : \"g\",\n \
    \       \"H\"    : \"h\",\n        \"I\"    : \"i\",\n        \"J\"    : \"j\"\
    ,\n        \"K\"    : \"k\",\n        \"L\"    : \"l\",\n        \"M\"    : \"\
    m\",\n        \"N\"    : \"n\",\n        \"O\"    : \"o\",\n        \"P\"    :\
    \ \"p\",\n        \"Q\"    : \"q\",\n        \"R\"    : \"r\",\n        \"S\"\
    \    : \"s\",\n        \"T\"    : \"t\",\n        \"U\"    : \"u\",\n        \"\
    V\"    : \"v\",\n        \"W\"    : \"w\",\n        \"X\"    : \"x\",\n      \
    \  \"Y\"    : \"y\",\n        \"Z\"    : \"z\"\n    ]\n\n    return characters\n\
    \        .map({ String($0) })\n        .map {\n            return $0.lowercased()\n\
    \                .reduce(\"\", { \n                    let previous = $1\n   \
    \                 var replacement: Character = \"\"\n                    for case\
    \ let character in $1.unicodeScalars {\n                        if case let previousCharacter\
    \ = previous.lowercased() {\n                            if let replacement =\
    \ replacements[previousCharacter] {\n                                replacement\
    \ = replacement\n                            } else {\n                      \
    \          replacement = previousCharacter\n                            }\n  \
    \                      } else {\n                            replacement = character\n\
    \                        }\n                        previous = String($0) \n \
    \                       return  replacement + String($1)\n                   \
    \ }\n                    return $0 + replacement\n                })\n       \
    \ }\n        .reduce(\"\", { $0 + $1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpjq6of42a.swift:54:50: error: cannot convert value of type 'String'\
    \ to specified type 'Character'\n                    var replacement: Character\
    \ = \"\"\n                                                 ^~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    let\
    \ chars = message.characters\n\n    var result = \"\"\n\n    for (index, char)\
    \ in chars.enumerate() {\n        let uppercase = char.uppercased()\n        let\
    \ replacement = uppercase[uppercase.index(uppercase, offsetBy: 2)]\n        result\
    \ += replacement.string(using: String.Encoding.ascii)\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpsjtfyax8.swift:14:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = message.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsjtfyax8.swift:18:32:\
    \ error: value of type 'String' has no member 'enumerate'\n    for (index, char)\
    \ in chars.enumerate() {\n                         ~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var output\
    \ = \"\"\n    for character in message {\n        let asciiCode = UInt32(character)\n\
    \        let index = asciiCode - 65\n        let twoLetterAsciiCode = asciiCode\
    \ + 64\n        switch asciiCode {\n        case 97 ... 122:\n            // Swap\
    \ case to letter that comes 2 places ahead of vowel.\n            let twoLetterAsciiCode\
    \ = asciiCode + 64\n            output += String(UnicodeScalar(twoLetterAsciiCode).value).uppercased\n\
    \        case 65 ... 90:\n            // Replace all vowels with that letter that\
    \ comes 2 places ahead of vowel.\n            let twoLetterAsciiCode = asciiCode\
    \ + 64\n            output += String(UnicodeScalar(twoLetterAsciiCode).value)\n\
    \        default:\n            output += String(asciiCode)\n        }\n    }\n\
    \    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp6xc2tepu.swift:15:25: error: no exact matches in call to initializer\
    \ \n        let asciiCode = UInt32(character)\n                        ^\nSwift.UInt32:7:12:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.UInt32:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.UInt32:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.UInt32:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.UInt32:28:12: note: candidate expects value of\
    \ type 'Builtin.Int32' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Builtin.Int32)\n           ^\nSwift.UInt32:2:23: note: candidate expects value\
    \ of type 'Unicode.Scalar' for parameter #1 (got 'Character')\n    @inlinable\
    \ public init(_ v: Unicode.Scalar)\n                      ^\nSwift.FixedWidthInteger:3:23:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Character')\n\
    \    @inlinable public init?(_ description: String)\n                      ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var messageAsMutable\
    \ = message\n    var result = \"\"\n    for char in messageAsMutable {\n     \
    \   let letterIndex = alphabet.indexOf(char) + 2\n        let letter = alphabet[letterIndex]\n\
    \        var replacement = \"\"\n        if letter == \"a\" || letter == \"e\"\
    \ || letter == \"i\" || letter == \"o\" || letter == \"u\" {\n            replacement\
    \ = alphabet[letterIndex + 1]\n        }\n        result += replacement\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpoiv9s9xg.swift:16:27: error: cannot find 'alphabet' in scope\n\
    \        let letterIndex = alphabet.indexOf(char) + 2\n                      \
    \    ^~~~~~~~\n/tmp/tmpoiv9s9xg.swift:17:22: error: cannot find 'alphabet' in\
    \ scope\n        let letter = alphabet[letterIndex]\n                     ^~~~~~~~\n\
    /tmp/tmpoiv9s9xg.swift:20:27: error: cannot find 'alphabet' in scope\n       \
    \     replacement = alphabet[letterIndex + 1]\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for letter in message {\n        let letterCode = letter.asciiValue\n\
    \        result += String(UInt8(letterCode - 65 + 1))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp6zv9nxe7.swift:16:32: error: value of optional type 'UInt8?' must\
    \ be unwrapped to a value of type 'UInt8'\n        result += String(UInt8(letterCode\
    \ - 65 + 1))\n                               ^\n/tmp/tmp6zv9nxe7.swift:15:13:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n        let letterCode = letter.asciiValue\n         \
    \   ^\n        guard                              else { return <#default value#>\
    \ }\n/tmp/tmp6zv9nxe7.swift:15:33: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        let letterCode = letter.asciiValue\n\
    \                                ^\n                                         \
    \  ?? <#default value#>\n/tmp/tmp6zv9nxe7.swift:15:33: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        let letterCode\
    \ = letter.asciiValue\n                                ^\n                   \
    \                       !\n/tmp/tmp6zv9nxe7.swift:16:32: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        result\
    \ += String(UInt8(letterCode - 65 + 1))\n                               ^\n  \
    \                             (          ?? <#default value#>)\n/tmp/tmp6zv9nxe7.swift:16:32:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        result += String(UInt8(letterCode - 65 + 1))\n              \
    \                 ^\n                                         !\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"aeiouAEIOU\"\n    let regex = NSRegularExpression.regularExpressionWithPattern(\"\
    [aeiouy]+\", options: 0, error: nil)\n    var chars: [String] = []\n    var lastChar\
    \ = \"\"\n    let maxLength = message.characters.count\n    for i in 0..<maxLength\
    \ {\n        let c = message[i]\n        var replacement = \"\"\n        if c.isLetter\
    \ {\n            if let match = regex.firstMatchInString(message.lowercaseString,\
    \ options: 0, range: NSMakeRange(i, 1)) {\n                replacement = match.stringByReplacingMatchesInString(message.lowercaseString,\
    \ options: 0, range: NSMakeRange(i, 1), withTemplate: c)\n                replacement\
    \ = replacement.stringByReplacingCharactersInRange(match.range, with: c)\n   \
    \             lastChar = replacement\n            }\n            replacement =\
    \ c.lowercaseString.substringToIndex(replacement)!\n        } else {\n       \
    \     replacement = c\n        }\n        if lastChar != replacement {\n     \
    \       lastChar = replacement\n            chars.append(replacement)\n      \
    \  } else {\n            if chars.count > 0 {\n                chars[chars.count\
    \ - 1] += c\n            } else {\n                chars.append(c)\n         \
    \   }\n        }\n    }\n    return String(chars)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpd16x8ecw.swift:14:17: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = NSRegularExpression.regularExpressionWithPattern(\"\
    [aeiouy]+\", options: 0, error: nil)\n                ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpd16x8ecw.swift:14:98:\
    \ error: 'nil' requires a contextual type\n    let regex = NSRegularExpression.regularExpressionWithPattern(\"\
    [aeiouy]+\", options: 0, error: nil)\n                                       \
    \                                                          ^\n/tmp/tmpd16x8ecw.swift:17:29:\
    \ error: 'characters' is unavailable: Please use String directly\n    let maxLength\
    \ = message.characters.count\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpd16x8ecw.swift:19:17: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let c = message[i]\n                ^~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpd16x8ecw.swift:22:97: error:\
    \ cannot find 'NSMakeRange' in scope\n            if let match = regex.firstMatchInString(message.lowercaseString,\
    \ options: 0, range: NSMakeRange(i, 1)) {\n                                  \
    \                                                              ^~~~~~~~~~~\n/tmp/tmpd16x8ecw.swift:22:61:\
    \ error: value of type 'String' has no member 'lowercaseString'\n            if\
    \ let match = regex.firstMatchInString(message.lowercaseString, options: 0, range:\
    \ NSMakeRange(i, 1)) {\n                                                    ~~~~~~~\
    \ ^~~~~~~~~~~~~~~\n/tmp/tmpd16x8ecw.swift:23:114: error: cannot find 'NSMakeRange'\
    \ in scope\n                replacement = match.stringByReplacingMatchesInString(message.lowercaseString,\
    \ options: 0, range: NSMakeRange(i, 1), withTemplate: c)\n                   \
    \                                                                            \
    \                  ^"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"AEIOU\"\n    return message\n        .characters\n        .reduce(\"\")\
    \ { $0 + String(Character(UnicodeScalar($1).value).cased())[vowels.indexOf($1)]\
    \ + String(Character(UnicodeScalar($1).value).replaceCharactersInRange(NSRange(location:\
    \ vowels.indexOf($1) + 1, length: 1), withString: String(Character(UnicodeScalar($1).value).cased())))\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") ==\
    \ \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpz1yz3c52.swift:16:168: error: cannot find 'NSRange' in scope\n\
    \        .reduce(\"\") { $0 + String(Character(UnicodeScalar($1).value).cased())[vowels.indexOf($1)]\
    \ + String(Character(UnicodeScalar($1).value).replaceCharactersInRange(NSRange(location:\
    \ vowels.indexOf($1) + 1, length: 1), withString: String(Character(UnicodeScalar($1).value).cased())))\
    \ }\n                                                                        \
    \                                                                            \
    \                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    //\
    \ Replace all vowels with the letter that appears 2 places ahead\n    // of it\
    \ in the alphabet\n    var replacement: Character = \"a\"\n    let vowels = \"\
    aeiou\"\n    for char in message {\n        if vowels.contains(char) {\n     \
    \       replacement = char.successor()\n        }\n    }\n    \n    // Swap case\
    \ for all letters\n    var converted = \"\"\n    for char in message {\n     \
    \   converted = converted.appending(cut(String(char).lowercased(), 2))\n    }\n\
    \    \n    // Replace all vowels in converted with the replacement letter\n  \
    \  for char in converted {\n        if vowels.contains(char) {\n            converted\
    \ = converted.replacingOccurrences(of: char, with: replacement)\n        }\n \
    \   }\n    \n    return converted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp13wqin9_.swift:20:32: error: value of type 'Character' has no member\
    \ 'successor'\n            replacement = char.successor()\n                  \
    \        ~~~~ ^~~~~~~~~\n/tmp/tmp13wqin9_.swift:27:41: error: cannot find 'cut'\
    \ in scope\n        converted = converted.appending(cut(String(char).lowercased(),\
    \ 2))\n                                        ^~~\n/tmp/tmp13wqin9_.swift:27:31:\
    \ error: value of type 'String' has no member 'appending'\n        converted =\
    \ converted.appending(cut(String(char).lowercased(), 2))\n                   \
    \ ~~~~~~~~~ ^~~~~~~~~\n/tmp/tmp13wqin9_.swift:33:35: error: value of type 'String'\
    \ has no member 'replacingOccurrences'\n            converted = converted.replacingOccurrences(of:\
    \ char, with: replacement)\n                        ~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"aeiou\"\n    return message.characters.reduce(\"\") { \n        let replaced\
    \ = $0.unicodeScalars.map { \n            if vowels.contains($0.value) {\n   \
    \             return String($0.value - 2)\n            } else {\n            \
    \    return String($0.value)\n            }\n        }\n        guard let last\
    \ = $0.unicodeScalars.last else { return replaced }\n        replaced.append(String(last.value))\n\
    \        return replaced.joinWithSeparator(\"\")\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpdzjagwdx.swift:14:42: error: contextual closure type '(String,\
    \ String.Element) throws -> String' (aka '(String, Character) throws -> String')\
    \ expects 2 arguments, but 1 was used in closure body\n    return message.characters.reduce(\"\
    \") { \n                                         ^\n/tmp/tmpdzjagwdx.swift:16:35:\
    \ error: cannot convert value of type 'UInt32' to expected argument type 'String.Element'\
    \ (aka 'Character')\n            if vowels.contains($0.value) {\n            \
    \                      ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encodedString\
    \ = message\n    \n    for index in 0..<message.characters.count {\n        let\
    \ char = message.characters[index]\n        \n        // swap case\n        switch\
    \ char {\n        case let upcasedChar as Character.UnicodeScalar:\n         \
    \   encodedString.replaceSubrange(index..<index + upcasedChar.value, with: upcasedChar.value)\n\
    \        default:\n            break\n        }\n    }\n    \n    // replace all\
    \ vowels\n    for vowel in \"aeiouAEIOU\" {\n        encodedString = encodedString.replacingOccurrences(of:\
    \ vowel, with: vowel.nextUp)\n    }\n    return encodedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpid75_f2c.swift:15:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<message.characters.count {\n     \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpid75_f2c.swift:16:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ char = message.characters[index]\n                   ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpid75_f2c.swift:16:28:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = message.characters[index]\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpid75_f2c.swift:20:43: error: 'UnicodeScalar'\
    \ is not a member type of struct 'Swift.Character'\n        case let upcasedChar\
    \ as Character.UnicodeScalar:\n                                ~~~~~~~~~ ^\nSwift.Character:1:23:\
    \ note: 'Character' declared here\n@frozen public struct Character : Sendable\
    \ {\n                      ^\n/tmp/tmpid75_f2c.swift:21:13: error: instance method\
    \ 'replaceSubrange(_:with:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \            encodedString.replaceSubrange(index..<index + upcasedChar.value,\
    \ with: upcasedChar.value)\n            ^\nSwift.RangeReplaceableCollection:2:37:\
    \ note: where 'Self.Index' = 'String.Index', 'R.Bound' = 'Int'\n    @inlinable\
    \ public mutating func replaceSubrange<C, R>(_ subrange: R, with newElements:\
    \ __owned C) where C : Collection, R : RangeExpression, Self.Element == C.Element,\
    \ Self.Index == R.Bound\n                                    ^\n/tmp/tmpid75_f2c.swift:29:39:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ encodedString = encodedString.replacingOccurre"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\treturn replace(replace(message,\
    \ 2, 1), 3, 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp5gxvos_b.swift:13:9: error: cannot find 'replace' in scope\n  \
    \      return replace(replace(message, 2, 1), 3, 1)\n               ^~~~~~~\n\
    /tmp/tmp5gxvos_b.swift:13:17: error: cannot find 'replace' in scope\n        return\
    \ replace(replace(message, 2, 1), 3, 1)\n                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    if message\
    \ == \"\" {\n        return \"\"\n    }\n    var letters = Array(Array(String(message).unicodeScalars))\n\
    \    var vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsWithTwoPlaces\
    \ = [\"ae\", \"ei\", \"io\", \"ou\"]\n    letters.forEach {\n        if let first\
    \ = letters.first {\n            let index = vowels.firstIndex(where: {\n    \
    \            $0.isEqualToString(String(first)\n            })\n            if\
    \ index != nil {\n                letters[0] = first\n                letters.dropFirst()\n\
    \            }\n        }\n    }\n    letters.forEach {\n        if let first\
    \ = letters.first {\n            var index = vowelsWithTwoPlaces.firstIndex(where:\
    \ {\n                $0.isEqualToString(String(first)\n            })\n      \
    \      if index != nil {\n                letters[0] = first\n               \
    \ letters.dropFirst()\n            }\n        }\n    }\n    var result = \"\"\n\
    \    letters.forEach {\n        result += String($0)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp93x5b2wt.swift:23:13: error: expected ')' in expression list\n\
    \            })\n            ^\n/tmp/tmp93x5b2wt.swift:22:35: note: to match this\
    \ opening '('\n                $0.isEqualToString(String(first)\n            \
    \                      ^\n/tmp/tmp93x5b2wt.swift:34:13: error: expected ')' in\
    \ expression list\n            })\n            ^\n/tmp/tmp93x5b2wt.swift:33:35:\
    \ note: to match this opening '('\n                $0.isEqualToString(String(first)\n\
    \                                  ^\n/tmp/tmp93x5b2wt.swift:19:21: error: contextual\
    \ type for closure argument list expects 1 argument, which cannot be implicitly\
    \ ignored\n    letters.forEach {\n                    ^\n                    \
    \ _ in \n/tmp/tmp93x5b2wt.swift:22:20: error: value of type 'String' has no member\
    \ 'isEqualToString'\n                $0.isEqualToString(String(first)\n      \
    \          ~~ ^~~~~~~~~~~~~~~\n/tmp/tmp93x5b2wt.swift:30:21: error: contextual\
    \ type for closure argument list expects 1 argument, which cannot be implicitly\
    \ ignored\n    letters.forEach {\n                    ^\n                    \
    \ _ in \n/tmp/tmp93x5b2wt.swift:33:20: error: value of type 'String' has no member\
    \ 'isEqualToString'\n                $0.isEqualToString(String(first)\n      \
    \          ~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    let\
    \ alphabet = Array(message.characters)\n    let vowels = \"AEIOU\"\n    let replacementsDict\
    \ = Dictionary(uniqueKeysWithValues: \n                                      \
    \ [\n                                          (\"A\", vowels[0]), \n        \
    \                                  (\"E\", vowels[1]), \n                    \
    \                      (\"I\", vowels[2]), \n                                \
    \          (\"O\", vowels[3]), \n                                          (\"\
    U\", vowels[4])\n                                       ]\n    )\n    \n    var\
    \ encodedString = \"\"\n    for (index, character) in alphabet.enumerate() {\n\
    \        let replacement = replacementsDict.get(character)\n        \n       \
    \ if let replacement = replacement {\n            let replacementIndex = index\
    \ - 2\n            let replacementCharacter = vowels[replacementIndex]\n     \
    \       \n            if replacementIndex >= 0 {\n                encodedString.append(replacement)\n\
    \            } else {\n                encodedString.append(replacementCharacter)\n\
    \            }\n        } else {\n            encodedString.append(character)\n\
    \        }\n    }\n    \n    return encodedString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp0mtu0otx.swift:14:34: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabet = Array(message.characters)\n        \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp0mtu0otx.swift:18:49: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \                                 (\"A\", vowels[0]), \n                     \
    \                           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp0mtu0otx.swift:19:49: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                                          (\"E\", vowels[1]), \n            \
    \                                    ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp0mtu0otx.swift:20:49: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                                          (\"I\", vowels[2]), \n            \
    \                                    ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp0mtu0otx.swift:21:49: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                                          (\"O\", vowels[3]), \n            \
    \                                    ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp0mtu0otx.swift:22:49: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message(message: \"test\", replace: \"test\", swap: \"AEIOUYaeiouy\", swapCount:\
    \ 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") ==\
    \ \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpfm8e0x91.swift:13:12: error: cannot call value of non-function\
    \ type 'String'\n    return message(message: \"test\", replace: \"test\", swap:\
    \ \"AEIOUYaeiouy\", swapCount: 2)\n           ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var message\
    \ = message\n\n    let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"\
    ]\n    let vowelsRep: [Character] = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n\n  \
    \  var result = \"\"\n    for char in message {\n        let index = message.index(of:\
    \ char) \n        var newChar = char\n\n        if char.isLetter {\n         \
    \   let nextLetter = message.index(of: char.next(), offset: 1)\n            if\
    \ nextLetter != nil { \n                newChar = vowelsRep[(nextLetter! - 1)]\n\
    \            }\n        }\n        \n        result = result + newChar\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpsgwl7e_2.swift:20:29: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = message.index(of: char) \n       \
    \                     ^\n/tmp/tmpsgwl7e_2.swift:20:29: note: use 'firstIndex(of:)'\
    \ instead\n        let index = message.index(of: char) \n                    \
    \        ^~~~~\n                            firstIndex\n/tmp/tmpsgwl7e_2.swift:24:69:\
    \ error: extra argument 'offset' in call\n            let nextLetter = message.index(of:\
    \ char.next(), offset: 1)\n                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmpsgwl7e_2.swift:24:53: error: value of type 'Character' has no member 'next'\n\
    \            let nextLetter = message.index(of: char.next(), offset: 1)\n    \
    \                                           ~~~~ ^~~~\n/tmp/tmpsgwl7e_2.swift:30:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result = result + newChar\n                          ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ String(friendlyEncoding(message))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp08tn1r3p.swift:13:19: error: cannot find 'friendlyEncoding' in\
    \ scope\n    return String(friendlyEncoding(message))\n                  ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\treturn message.characters.map({\
    \ charToCode[String($0)] }).reduce((acc: String, code: Int)-> String in\n\t\t\
    if code < 65 {\n\t\t\treturn String(code)\n\t\t}\n\t\tlet lowerChar = String(code)\
    \ - 65\n\t\treturn String(charToCode[lowerChar]) + acc\n\t).reversed()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpa8ncxhu5.swift:13:101: error: expected ',' separator\n        return\
    \ message.characters.map({ charToCode[String($0)] }).reduce((acc: String, code:\
    \ Int)-> String in\n                                                         \
    \                                                  ^\n                       \
    \                                                                            \
    \       ,\n/tmp/tmpa8ncxhu5.swift:13:101: error: expected expression in list of\
    \ expressions\n        return message.characters.map({ charToCode[String($0)]\
    \ }).reduce((acc: String, code: Int)-> String in\n                           \
    \                                                                            \
    \    ^\n/tmp/tmpa8ncxhu5.swift:19:2: error: expected expression\n        ).reversed()\n\
    \        ^\n/tmp/tmpa8ncxhu5.swift:13:34: error: cannot find 'charToCode' in scope\n\
    \        return message.characters.map({ charToCode[String($0)] }).reduce((acc:\
    \ String, code: Int)-> String in\n                                        ^~~~~~~~~~\n\
    /tmp/tmpa8ncxhu5.swift:17:26: error: cannot find 'code' in scope\n           \
    \     let lowerChar = String(code) - 65\n                                    \
    \   ^~~~\n/tmp/tmpa8ncxhu5.swift:18:17: error: cannot find 'charToCode' in scope\n\
    \                return String(charToCode[lowerChar]) + acc\n                \
    \              ^~~~~~~~~~\n/tmp/tmpa8ncxhu5.swift:18:42: error: cannot find 'acc'\
    \ in scope\n                return String(charToCode[lowerChar]) + acc\n     \
    \                                                  ^~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var\
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    var result = \"\"\n   \
    \ \n    for  letter in message {\n        \n        let index = alphabet.indexOf(letter)\n\
    \        \n        let nextIndex = alphabet.indexOf(letter, index + 1)\n     \
    \   \n        if nextIndex < 0 {\n            result += \"?\"\n            continue\n\
    \        }\n        \n        let nextLetter = alphabet[nextIndex + 1]\n     \
    \   \n        if letter.isUppercase {\n            result += alphabet[index +\
    \ (alphabet.index(nextLetter) ?? 0)]\n        } else {\n            result +=\
    \ alphabet[index + (alphabet.index(nextLetter) ?? 0) - 1]\n        }\n       \
    \ \n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpoypbcbw0.swift:20:30: error: value of type 'String' has no member\
    \ 'indexOf'\n        let index = alphabet.indexOf(letter)\n                  \
    \  ~~~~~~~~ ^~~~~~~\n/tmp/tmpoypbcbw0.swift:22:34: error: value of type 'String'\
    \ has no member 'indexOf'\n        let nextIndex = alphabet.indexOf(letter, index\
    \ + 1)\n                        ~~~~~~~~ ^~~~~~~\n/tmp/tmpoypbcbw0.swift:32:56:\
    \ error: missing argument label 'of:' in call\n            result += alphabet[index\
    \ + (alphabet.index(nextLetter) ?? 0)]\n                                     \
    \                  ^\n                                                       of:\
    \ \n/tmp/tmpoypbcbw0.swift:32:68: error: binary operator '??' cannot be applied\
    \ to operands of type 'String.Index?' and 'Int'\n            result += alphabet[index\
    \ + (alphabet.index(nextLetter) ?? 0)]\n                                     \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~\n/tmp/tmpoypbcbw0.swift:34:56: error: missing\
    \ argument label 'of:' in call\n            result += alphabet[index + (alphabet.index(nextLetter)\
    \ ?? 0) - 1]\n                                                       ^\n     \
    \                                                  of: \n/tmp/tmpoypbcbw0.swift:34:68:\
    \ error: binary operator '??' cannot be applied to operands of type 'String.Index?'\
    \ and 'Int'\n            result += alphabet[index + (alphabet.index(nextLetter)\
    \ ?? 0) - 1]\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^  ~\n"
  stdout: ''
  timestamp: 1659978727
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.unicodeScalars.map {\n        String($0.value, radix: 10)\n    }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmp67x20pj8/tmp67x20pj8.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4877713c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b487740ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b487740a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48774097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp67x20pj8                        0x00005585e5c416b7 <unavailable> + 5815

    5    libc.so.6                          0x00002b48778ff460 __libc_start_main +
    245

    6    tmp67x20pj8                        0x00005585e5c412f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"aeiouAEIOU\"\n    var encodedMessage = message\n\n    var currentLetter\
    \ = String()\n    for let letter in encodedMessage {\n        if let index = vowels.firstIndex(of:\
    \ letter) {\n            let oneLetterBefore = vowels[index - 1]\n           \
    \ let twoLettersBefore = vowels[index - 2]\n            encodedMessage = encodedMessage.replacingOccurrences(of:\
    \ letter, with: oneLetterBefore)\n            encodedMessage = encodedMessage.replacingOccurrences(of:\
    \ twoLettersBefore, with: letter)\n        } else {\n            encodedMessage\
    \ = encodedMessage.replacingOccurrences(of: letter, with: letter)\n        }\n\
    \    }\n\n    return encodedMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpak00wyal.swift:17:9: error: 'let' pattern cannot appear nested\
    \ in an already immutable context\n    for let letter in encodedMessage {\n  \
    \      ^\n/tmp/tmpak00wyal.swift:19:42: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let oneLetterBefore = vowels[index\
    \ - 1]\n                                         ^\n/tmp/tmpak00wyal.swift:20:43:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            let twoLettersBefore = vowels[index - 2]\n              \
    \                            ^\n/tmp/tmpak00wyal.swift:21:45: error: value of\
    \ type 'String' has no member 'replacingOccurrences'\n            encodedMessage\
    \ = encodedMessage.replacingOccurrences(of: letter, with: oneLetterBefore)\n \
    \                            ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpak00wyal.swift:22:45:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     encodedMessage = encodedMessage.replacingOccurrences(of: twoLettersBefore,\
    \ with: letter)\n                             ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpak00wyal.swift:24:45: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \            encodedMessage = encodedMessage.replacingOccurrences(of: letter,\
    \ with: letter)\n                             ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message(\n    letter: \"S\",\n    vowel: \"A\",\n    vowel: \"E\",\n    vowel:\
    \ \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n    vowel:\
    \ \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n    vowel:\
    \ \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n    vowel:\
    \ \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n    vowel:\
    \ \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n    vowel:\
    \ \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n    vowel:\
    \ \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n    vowel:\
    \ \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n    vowel:\
    \ \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n    vowel:\
    \ \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n    vowel:\
    \ \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n    vowel:\
    \ \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n    vowel:\
    \ \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n    vowel:\
    \ \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n    vowel:\
    \ \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n    vowel:\
    \ \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n    vowel:\
    \ \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n    vowel:\
    \ \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n    vowel:\
    \ \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n    vowel:\
    \ \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n    vowel:\
    \ \"U\",\n    vowel: \"O\",\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpp5crycnt.swift:100:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpp5crycnt.swift:13:12: error: cannot call value of non-function type\
    \ 'String'\n    return message(\n           ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for character in message {\n        var index = 0\n        var nextVowelIndex\
    \ = nextVowelIndex(character)\n        while index < len(character) && index !=\
    \ nextVowelIndex {\n            index++\n        }\n        if index == len(character)\
    \ {\n            result += character\n        } else {\n            result +=\
    \ \"\\(\\(character[index]\\))\"\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpcx1doc9h.swift:23:44: error: expected ',' separator\n         \
    \   result += \"\\(\\(character[index]\\))\"\n                               \
    \            ^\n                                           ,\n/tmp/tmpcx1doc9h.swift:23:45:\
    \ error: expected expression path in Swift key path\n            result += \"\\\
    (\\(character[index]\\))\"\n                                            ^\n/tmp/tmpcx1doc9h.swift:16:30:\
    \ error: use of local variable 'nextVowelIndex' before its declaration\n     \
    \   var nextVowelIndex = nextVowelIndex(character)\n                         \
    \    ^\n/tmp/tmpcx1doc9h.swift:16:13: note: 'nextVowelIndex' declared here\n \
    \       var nextVowelIndex = nextVowelIndex(character)\n            ^\n/tmp/tmpcx1doc9h.swift:17:23:\
    \ error: cannot find 'len' in scope\n        while index < len(character) && index\
    \ != nextVowelIndex {\n                      ^~~\n/tmp/tmpcx1doc9h.swift:18:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  index++\n                 ^~\n/tmp/tmpcx1doc9h.swift:20:21: error: cannot find\
    \ 'len' in scope\n        if index == len(character) {\n                    ^~~\n\
    /tmp/tmpcx1doc9h.swift:21:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += character\n      \
    \                ^\n/tmp/tmpcx1doc9h.swift:23:37: error: string interpolation\
    \ can only appear inside a string literal\n            result += \"\\(\\(character[index]\\\
    ))\"\n                                    ^\n/tmp/tmpcx1doc9h.swift:23:25: error:\
    \ type of expression is ambiguous without more context\n            result +=\
    \ \"\\(\\(character[index]\\))\"\n                        ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"aeiouAEIOU\"\n    let vowelIndex: Dictionary = Dictionary(uniqueKeysWithValues:\n\
    \        Array(vowels.enumerated().map({ $0.element, $0.offset+1 }))\n    )\n\
    \    return String(message.characters.flatMap { char -> String in\n        let\
    \ index = vowelIndex[char] ?? 0\n        let newChar = String(repeatElement(char.uppercased(),\
    \ index))\n        return newChar == char.uppercased() ? char.lowercased() : newChar\n\
    \    }.joinWithSeparator(\"\"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpch9fe_36.swift:15:51: error: consecutive statements on a line must\
    \ be separated by ';'\n        Array(vowels.enumerated().map({ $0.element, $0.offset+1\
    \ }))\n                                                  ^\n                 \
    \                                 ;\n/tmp/tmpch9fe_36.swift:15:51: error: expected\
    \ expression\n        Array(vowels.enumerated().map({ $0.element, $0.offset+1\
    \ }))\n                                                  ^\n/tmp/tmpch9fe_36.swift:14:34:\
    \ error: generic parameter 'Key' could not be inferred\n    let vowelIndex: Dictionary\
    \ = Dictionary(uniqueKeysWithValues:\n                                 ^\n/tmp/tmpch9fe_36.swift:14:34:\
    \ note: explicitly specify the generic arguments to fix this issue\n    let vowelIndex:\
    \ Dictionary = Dictionary(uniqueKeysWithValues:\n                            \
    \     ^\n                                           <<#Key: Hashable#>, Any>\n\
    /tmp/tmpch9fe_36.swift:21:7: error: value of type '[String.Element]' (aka 'Array<Character>')\
    \ has no member 'joinWithSeparator'\n    }.joinWithSeparator(\"\"))\n~~~~~ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tlet alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\tlet vowels = \"aeiou\"\n\tlet mapping =\
    \ vowels.reduce(\"\") { acc, char in\n\t\tlet index = alphabet.index(of: char)!\n\
    \t\tlet previous = acc[index-2] ?? \"\"\n\t\tlet next = acc[index-1] ?? \"\"\n\
    \t\treturn acc + previous + String(alphabet.index(of: next)!)\n\t}\n\treturn mapping[message.characters.map({\
    \ alphabet.index(of: $0)!}).max()]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpkyijrtnu.swift:17:27: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Range<String.Index>'\n                let previous\
    \ = acc[index-2] ?? \"\"\n                                        ^\n/tmp/tmpkyijrtnu.swift:17:22:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n                let previous = acc[index-2] ?? \"\"\n               \
    \                    ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"AEIOUaeiou\"\n    var string = String()\n    for i in 0..<message.characters.count\
    \ {\n        var c = message.characters[i]\n        \n        let index = string.characters.index(of:\
    \ c)\n        var nextVowel = string.characters[index + 1]\n        nextVowel\
    \ = nextVowel.lowercased()\n\n        if let idx = vowels.firstIndex(of: nextVowel)\
    \ {\n            let newVowel = String(vowels[idx : idx + 1])\n            let\
    \ replacement = string.substring(to: index)\n            string = string.replacingOccurrences(of:\
    \ c, with: newVowel)\n        }\n        string = string.append(c)\n    }\n  \
    \  return string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpeqr_t6wy.swift:15:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<message.characters.count {\n         \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpeqr_t6wy.swift:16:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        var c = message.characters[i]\n\
    \                ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpeqr_t6wy.swift:16:25: error: 'characters'\
    \ is unavailable: Please use String directly\n        var c = message.characters[i]\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpeqr_t6wy.swift:18:28: error: 'characters' is unavailable:\
    \ Please use String directly\n        let index = string.characters.index(of:\
    \ c)\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpeqr_t6wy.swift:18:39: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        let index = string.characters.index(of:\
    \ c)\n                                      ^\n/tmp/tmpeqr_t6wy.swift:18:39: note:\
    \ use 'firstIndex(of:)' instead\n        let index = string.characters.index(of:\
    \ c)\n                                      ^~~~~\n                          \
    \            firstIndex\n/tmp/tmpeqr_t6wy.swift:19:43: error: cannot convert value\
    \ of type 'String.Index?' to expected argument type 'Int'\n        var nextVowel\
    \ = string.characters[index + 1]\n                                          ^\n\
    /tmp/tmpeqr_t6wy.swift:23:41: error: extraneous argument label 'idx:' in subscript\n\
    \            let newVowel = String(vowels[idx : idx + 1])\n                  \
    \                   "
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for i in 0..<message.count {\n        var newChar = message[i]\n\
    \        if newChar == \" \" {\n            newChar = \"0\"\n        }\n     \
    \   result += String(crSwappingDict[newChar])\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgvgazffk.swift:15:23: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        var newChar\
    \ = message[i]\n                      ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgvgazffk.swift:19:26: error: cannot\
    \ find 'crSwappingDict' in scope\n        result += String(crSwappingDict[newChar])\n\
    \                         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let map\
    \ = [\n        \"A\": \"A\", \n        \"E\": \"E\",\n        \"I\": \"I\",\n\
    \        \"O\": \"O\",\n        \"U\": \"U\", \n        \"a\": \"a\", \n     \
    \   \"e\": \"e\",\n        \"i\": \"i\",\n        \"o\": \"o\",\n        \"u\"\
    : \"u\"\n    ]\n    let res = \"ABCDEFGHIJKLMNOPU\".characters.map({ $0 }).reduce(\"\
    \", { acc, c in\n        if let prev = map.index(of: c) {\n            return\
    \ acc + map[prev]\n        } else {\n            return acc + c\n        }\n \
    \   })\n    return message.characters.map({ res + map[$0] }).reduce(\"\") { acc,\
    \ c in\n        if let index = res.index(of: c) {\n            let prev = res[index]\n\
    \            return acc + prev.capitalized + map[prev.next!]\n        } else {\n\
    \            return acc + c\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmpuz4q3i.swift:26:23: error: type 'Dictionary<String, String>.Element'\
    \ (aka '(key: String, value: String)') cannot conform to 'Equatable'\n       \
    \ if let prev = map.index(of: c) {\n                      ^\n/tmp/tmpmpuz4q3i.swift:26:23:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        if let prev = map.index(of: c) {\n                      ^\n\
    /tmp/tmpmpuz4q3i.swift:26:23: note: required by referencing instance method 'index(of:)'\
    \ on 'Collection' where 'Self.Element' = 'Dictionary<String, String>.Element'\
    \ (aka '(key: String, value: String)')\n        if let prev = map.index(of: c)\
    \ {\n                      ^\n/tmp/tmpmpuz4q3i.swift:26:37: error: cannot convert\
    \ value of type 'String.Element' (aka 'Character') to expected argument type 'Dictionary<String,\
    \ String>.Element' (aka '(key: String, value: String)')\n        if let prev =\
    \ map.index(of: c) {\n                                    ^\n/tmp/tmpmpuz4q3i.swift:32:47:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n    return message.characters.map({ res + map[$0] }).reduce(\"\
    \") { acc, c in\n                                              ^\n/tmp/tmpmpuz4q3i.swift:32:46:\
    \ error: value of optional type 'String?' must be unwrapped to a value of type\
    \ 'String'\n    return message.characters.map({ res + map[$0] }).reduce(\"\")\
    \ { acc, c in\n                                             ^\n/tmp/tmpmpuz4q3i.swift:32:46:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return message.characters.map({ res + map[$0] }).reduce(\"\") { acc,\
    \ c in\n                                             ^\n                     \
    \                     (       ?? <#default value#>)\n/tmp/tmpmpuz4q3i.swift:32:46:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return message.characters.map({ res + map[$0] }).reduce(\"\") { acc,\
    \ c in\n                                             ^\n                     \
    \                            !\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.map { Character($0).lowercased().replaceWithCharacter(String($0.unicodeScalars.drop(2)))\
    \ }\n        .joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmps5rr6z7s.swift:13:53: error: value of type 'String' has no member\
    \ 'replaceWithCharacter'\n    return message.map { Character($0).lowercased().replaceWithCharacter(String($0.unicodeScalars.drop(2)))\
    \ }\n                         ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmps5rr6z7s.swift:13:104: error: missing argument label 'while:' in call\n\
    \    return message.map { Character($0).lowercased().replaceWithCharacter(String($0.unicodeScalars.drop(2)))\
    \ }\n                                                                        \
    \                               ^\n                                          \
    \                                                             while: \n/tmp/tmps5rr6z7s.swift:13:104:\
    \ error: cannot convert value of type 'Int' to expected argument type '(Unicode.Scalar)\
    \ throws -> Bool'\n    return message.map { Character($0).lowercased().replaceWithCharacter(String($0.unicodeScalars.drop(2)))\
    \ }\n                                                                        \
    \                               ^\n/tmp/tmps5rr6z7s.swift:13:36: error: missing\
    \ argument label 'extendedGraphemeClusterLiteral:' in call\n    return message.map\
    \ { Character($0).lowercased().replaceWithCharacter(String($0.unicodeScalars.drop(2)))\
    \ }\n                                   ^\n                                  \
    \ extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message\n        .characters\n        .map { (c) -> ((Char) -> Char)? in \n\
    \            return isVowel(c) ? nil : { \n                let index = c as UInt32\n\
    \                var index2 = 0\n                let index3 = (index + 1)\n  \
    \              return {\n                    index2\n                } \n    \
    \        }\n        }\n        .reduce(\"\") { (acc, letter, currentIndex) ->\
    \ String in\n            switch letter {\n            case let .some(letter as\
    \ String):\n                return acc + String(letter)\n            case .none:\n\
    \                return acc + String(currentIndex)\n            }\n        }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpklc8gjiz.swift:16:20: error: cannot find 'isVowel' in scope\n \
    \           return isVowel(c) ? nil : { \n                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.map{ c -> String in\n        let index = alphabet.index(of: c)\n   \
    \     if index < alphabet.count - 2 {\n            let first = alphabet.index(before:\
    \ index)\n            let second = alphabet.index(before: index + 1)\n       \
    \     let third = alphabet.index(before: index + 2)\n            let result =\
    \ (first! + second! + third!)!\n            let i = alphabet.index(of: result)\n\
    \            return alphabet[i] \n        }\n        else if index == 0 {\n  \
    \          return alphabet[alphabet.count - 1]\n        }\n        else if index\
    \ == alphabet.count - 2 {\n            return alphabet[0]\n        }\n       \
    \ else if index == alphabet.count - 3 {\n            return alphabet[alphabet.count\
    \ - 2]\n        }\n        else if index == alphabet.count - 4 {\n           \
    \ return alphabet[0]\n        }\n        else{\n            return \"-\"\n   \
    \     }\n    }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp6sk182ko.swift:14:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: c)\n                    ^~~~~~~~\n/tmp/tmp6sk182ko.swift:15:20:\
    \ error: cannot find 'alphabet' in scope\n        if index < alphabet.count -\
    \ 2 {\n                   ^~~~~~~~\n/tmp/tmp6sk182ko.swift:16:25: error: cannot\
    \ find 'alphabet' in scope\n            let first = alphabet.index(before: index)\n\
    \                        ^~~~~~~~\n/tmp/tmp6sk182ko.swift:17:26: error: cannot\
    \ find 'alphabet' in scope\n            let second = alphabet.index(before: index\
    \ + 1)\n                         ^~~~~~~~\n/tmp/tmp6sk182ko.swift:18:25: error:\
    \ cannot find 'alphabet' in scope\n            let third = alphabet.index(before:\
    \ index + 2)\n                        ^~~~~~~~\n/tmp/tmp6sk182ko.swift:20:21:\
    \ error: cannot find 'alphabet' in scope\n            let i = alphabet.index(of:\
    \ result)\n                    ^~~~~~~~\n/tmp/tmp6sk182ko.swift:21:20: error:\
    \ cannot find 'alphabet' in scope\n            return alphabet[i] \n         \
    \          ^~~~~~~~\n/tmp/tmp6sk182ko.swift:24:20: error: cannot find 'alphabet'\
    \ in scope\n            return alphabet[alphabet.count - 1]\n                \
    \   ^~~~~~~~\n/tmp/tmp6sk182ko.swift:24:29: error: cannot find 'alphabet' in scope\n\
    \            return alphabet[alphabet.count - 1]\n                           \
    \ ^~~~~~~~\n/tmp/tmp6sk182ko.swift:26:26: error: cannot find 'alphabet' in scope\n\
    \        else if index == alphabet.count - 2 {\n                         ^~~~~~~~\n\
    /tmp/tmp6sk182ko.swift:27:20: error: cannot find 'alphabet' in scope\n       \
    \     return alphabet[0]\n                   ^~~~~~~~\n/tmp/tmp6sk182ko.swift:29:26:\
    \ error: cannot find 'alphabet' in scope\n        else if index == alphabet.count\
    \ - 3 {\n                         ^~~~~~~~\n/tmp/tmp6sk182ko.swift:30:20: error:\
    \ cannot find 'alphabet' in scope\n            return alphabet[alphabet.count\
    \ - 2]\n                   ^~~~~~~~\n/tmp/tmp6sk182ko.swift:30:29: error: cannot\
    \ find 'alphabet' in scope\n            return alphabet[alphabet.count - 2]\n\
    \                            ^~~~"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tguard let\
    \ alphabet = CharacterSet.letters else {\n\t\tfatalError(\"Invalid alphabet specified\"\
    )\n\t}\n\t\n\treturn message\n\t.unicodeScalars\n\t.map { character in\n\t\tlet\
    \ charIndex = alphabet.index(of: character)\n\t\tguard charIndex != alphabet.endIndex\
    \ - 1 else { return character }\n\t\tlet previousCharIndex = alphabet.index(of:\
    \ character, offsetBy: -1)\n\t\tlet previousChar = String(alphabet[previousCharIndex])\n\
    \t\treturn previousChar.lowercased() + String(alphabet[charIndex])\n\t}\n\t.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmphtkmiu8g.swift:13:23: error: cannot find 'CharacterSet' in scope\n\
    \        guard let alphabet = CharacterSet.letters else {\n                  \
    \           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message\n        .unicodeScalars\n        .map { letter -> String in\n     \
    \       let index = letter - 'a'\n            let vowel = letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' || letter == 'y' ?\
    \ 'A' : 'a'\n            let pair = vowel + String(index + 1)\n            return\
    \ pair\n        }\n        .join(\"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmfyhdcsd.swift:16:34: error: single-quoted string literal found,\
    \ use '\"'\n            let index = letter - 'a'\n                           \
    \      ^~~\n                                 \"a\"\n/tmp/tmpmfyhdcsd.swift:17:35:\
    \ error: single-quoted string literal found, use '\"'\n            let vowel =\
    \ letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter ==\
    \ 'u' || letter == 'y' ? 'A' : 'a'\n                                  ^~~\n  \
    \                                \"a\"\n/tmp/tmpmfyhdcsd.swift:17:52: error: single-quoted\
    \ string literal found, use '\"'\n            let vowel = letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' || letter == 'y' ?\
    \ 'A' : 'a'\n                                                   ^~~\n        \
    \                                           \"e\"\n/tmp/tmpmfyhdcsd.swift:17:69:\
    \ error: single-quoted string literal found, use '\"'\n            let vowel =\
    \ letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter ==\
    \ 'u' || letter == 'y' ? 'A' : 'a'\n                                         \
    \                           ^~~\n                                            \
    \                        \"i\"\n/tmp/tmpmfyhdcsd.swift:17:86: error: single-quoted\
    \ string literal found, use '\"'\n            let vowel = letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' || letter == 'y' ?\
    \ 'A' : 'a'\n                                                                \
    \                     ^~~\n                                                  \
    \                                   \"o\"\n/tmp/tmpmfyhdcsd.swift:17:103: error:\
    \ single-quoted string literal found, use '\"'\n            let vowel = letter\
    \ == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' ||\
    \ letter == 'y' ? 'A' : 'a'\n                                                \
    \                                                      ^~~\n                 \
    \                                                                            \
    \         \"u\"\n/tmp/tmpmfyhdcsd.swift:17:120: error: single-quoted str"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"AEIOUaeiou\"\n    let indexToLetter = map([vowels.startIndex, vowels.endIndex].map({\
    \ $0 + 1 }))\n\n    return map({ (index: Int, letter: Character) -> String in\n\
    \        let index = indexToLetter(index)\n        let letter = String(indexToLetter[index\
    \ + 1])\n\n        return (letter == letter) ? letter + letter : String(letter)\n\
    \    })(message.characters)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpxycedyf8.swift:14:25: error: cannot find 'map' in scope\n    let\
    \ indexToLetter = map([vowels.startIndex, vowels.endIndex].map({ $0 + 1 }))\n\
    \                        ^~~\n/tmp/tmpxycedyf8.swift:14:72: error: cannot convert\
    \ value of type 'String.Index' to expected argument type 'Int'\n    let indexToLetter\
    \ = map([vowels.startIndex, vowels.endIndex].map({ $0 + 1 }))\n              \
    \                                                         ^\n/tmp/tmpxycedyf8.swift:16:12:\
    \ error: cannot find 'map' in scope\n    return map({ (index: Int, letter: Character)\
    \ -> String in\n           ^~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    \n    for letter in message {\n        let index = letter.unicodeScalars.indexOf(unicodeScalars.lowercaseB)\n\
    \        var a = index\n        var b = index + 1\n        if a < 0 {\n      \
    \      a = 0\n        }\n        if b < 0 {\n            b = 0\n        }\n  \
    \      if a != b {\n            let c = message.substring(a, a+1)\n          \
    \  let d = message.substring(b, b+1)\n            if c == c {\n              \
    \  result += c\n                result += d\n            }\n            else {\n\
    \                let i = message.indexOf(c, b)\n                if i != b {\n\
    \                    let e = message.substring(b, i+1)\n                    result\
    \ += c\n                    result += e\n                }\n                result\
    \ += d\n            }\n        }\n        else {\n            result += letter\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpp0as1gnj.swift:16:51: error: cannot find 'unicodeScalars' in scope\n\
    \        let index = letter.unicodeScalars.indexOf(unicodeScalars.lowercaseB)\n\
    \                                                  ^~~~~~~~~~~~~~\n/tmp/tmpp0as1gnj.swift:16:43:\
    \ error: value of type 'Character.UnicodeScalarView' (aka 'String.UnicodeScalarView')\
    \ has no member 'indexOf'\n        let index = letter.unicodeScalars.indexOf(unicodeScalars.lowercaseB)\n\
    \                    ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpp0as1gnj.swift:26:29:\
    \ error: value of type 'String' has no member 'substring'\n            let c =\
    \ message.substring(a, a+1)\n                    ~~~~~~~ ^~~~~~~~~\n/tmp/tmpp0as1gnj.swift:27:29:\
    \ error: value of type 'String' has no member 'substring'\n            let d =\
    \ message.substring(b, b+1)\n                    ~~~~~~~ ^~~~~~~~~\n/tmp/tmpp0as1gnj.swift:33:33:\
    \ error: value of type 'String' has no member 'indexOf'\n                let i\
    \ = message.indexOf(c, b)\n                        ~~~~~~~ ^~~~~~~\n/tmp/tmpp0as1gnj.swift:35:37:\
    \ error: value of type 'String' has no member 'substring'\n                  \
    \  let e = message.substring(b, i+1)\n                            ~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpp0as1gnj.swift:43:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your\
    \ code here\n    var result = [Character]()\n    var prevLetter = \"\"\n    for\
    \ letter in message {\n        switch letter {\n        case \"a\",\"e\",\"i\"\
    ,\"o\",\"u\":\n            prevLetter += \"B\"\n        case \"A\",\"E\",\"I\"\
    ,\"O\",\"U\":\n            prevLetter += \"bB\"\n        case \"t\",\"t\",\"h\"\
    ,\"k\":\n            prevLetter += \"S\"\n        case \"T\",\"T\",\"H\",\"K\"\
    :\n            prevLetter += \"sS\"\n        case \"r\",\"n\",\"g\":\n       \
    \     prevLetter += \"R\"\n        case \"R\",\"N\",\"G\":\n            prevLetter\
    \ += \"rR\"\n        case \"p\",\"f\",\"v\",\"b\",\"q\",\"x\",\"j\",\"z\":\n \
    \           prevLetter += \"W\"\n        case \"P\",\"F\",\"V\",\"B\",\"Q\",\"\
    X\",\"J\",\"Z\":\n            prevLetter += \"wW\"\n        case \"g\",\"c\",\"\
    m\",\"k\",\"s\",\"s\",\"c\",\"g\",\"s\",\"a\":\n            prevLetter += \"M\"\
    \n        case \"G\",\"C\",\"M\",\"K\",\"S\",\"S\",\"C\",\"G\",\"S\",\"A\":\n\
    \            prevLetter += \"mM\"\n        case \"w\",\"t\",\"s\",\"c\",\"m\"\
    ,\"g\",\"k\",\"s\",\"c\",\"g\",\"s\":\n            prevLetter += \"H\"\n     \
    \   case \"W\",\"T\",\"S\",\"C\",\"M\",\"G\",\"K\",\"S\",\"C\",\"G\",\"S\":\n\
    \            prevLetter += \"hH\"\n        case \"s\",\"a\",\"c\",\"m\",\"c\"\
    ,\"g\",\"k\",\"s\",\"c\",\"g\",\"s\",\"a\":\n            prevLetter += \"D\"\n\
    \        case \"S\",\"A\",\"C\",\"M\",\"C\",\"G\",\"K\",\"S\",\"C\",\"G\",\"S\"\
    ,\"A\":\n            prevLetter += \"dD\"\n        default:\n            prevLetter\
    \ += letter\n        }\n        prevLetter = prevLetter[letter]\n        result\
    \ += prevLetter\n    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpyqshv537.swift:47:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            prevLetter += letter\n     \
    \                     ^\n/tmp/tmpyqshv537.swift:22:18: warning: literal value\
    \ is already handled by previous pattern; consider removing it\n        case \"\
    t\",\"t\",\"h\",\"k\":\n                 ^~~\n/tmp/tmpyqshv537.swift:22:14: note:\
    \ first occurrence of identical literal pattern is here\n        case \"t\",\"\
    t\",\"h\",\"k\":\n             ^~~\n/tmp/tmpyqshv537.swift:24:18: warning: literal\
    \ value is already handled by previous pattern; consider removing it\n       \
    \ case \"T\",\"T\",\"H\",\"K\":\n                 ^~~\n/tmp/tmpyqshv537.swift:24:14:\
    \ note: first occurrence of identical literal pattern is here\n        case \"\
    T\",\"T\",\"H\",\"K\":\n             ^~~\n/tmp/tmpyqshv537.swift:34:14: warning:\
    \ literal value is already handled by previous pattern; consider removing it\n\
    \        case \"g\",\"c\",\"m\",\"k\",\"s\",\"s\",\"c\",\"g\",\"s\",\"a\":\n \
    \            ^~~\n/tmp/tmpyqshv537.swift:26:22: note: first occurrence of identical\
    \ literal pattern is here\n        case \"r\",\"n\",\"g\":\n                 \
    \    ^~~\n/tmp/tmpyqshv537.swift:34:26: warning: literal value is already handled\
    \ by previous pattern; consider removing it\n        case \"g\",\"c\",\"m\",\"\
    k\",\"s\",\"s\",\"c\",\"g\",\"s\",\"a\":\n                         ^~~\n/tmp/tmpyqshv537.swift:22:26:\
    \ note: first occurrence of identical literal pattern is here\n        case \"\
    t\",\"t\",\"h\",\"k\":\n                         ^~~\n/tmp/tmpyqshv537.swift:34:34:\
    \ warning: literal value is already handled by previous pattern; consider removing\
    \ it\n        case \"g\",\"c\",\"m\",\"k\",\"s\",\"s\",\"c\",\"g\",\"s\",\"a\"\
    :\n                                 ^~~\n/tmp/tmpyqshv537.swift:34:30: note: first\
    \ occurrence of identical literal pattern is here\n        case \"g\",\"c\",\"\
    m\",\"k\",\"s\",\"s\",\"c\",\"g\",\"s\",\"a\":\n                             ^~~\n\
    /tmp/tmpyqshv537.swift:34:38: warning: literal value is already handled by previous\
    \ pattern; consider removing it\n        case \"g\",\"c\",\"m\",\"k\",\"s\",\"\
    s\",\"c\",\"g\",\"s\",\"a\":\n                                     ^~~\n/tmp/tm"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    guard let\
    \ vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"] else { return \"\" }\n    var index\
    \ = 0\n    var result: String = message\n    for character in result {\n     \
    \   if character == \"a\" || character == \"e\" || character == \"i\" || character\
    \ == \"o\" || character == \"u\" {\n            result[index] = vowels[Int(index)/2]\n\
    \        } else {\n            result[index] = character\n        }\n        index\
    \ += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpi74yh4w0.swift:13:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String]'\n    guard let vowels = [\"a\",\"e\"\
    ,\"i\",\"o\",\"u\"] else { return \"\" }\n          ^            ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpi74yh4w0.swift:18:19: error: cannot assign through subscript: subscript\
    \ is get-only\n            result[index] = vowels[Int(index)/2]\n            ~~~~~~^~~~~~~\n\
    /tmp/tmpi74yh4w0.swift:18:35: error: cannot assign value of type 'String' to subscript\
    \ of type 'Character'\n            result[index] = vowels[Int(index)/2]\n    \
    \                        ~~~~~~^~~~~~~~~~~~~~\n/tmp/tmpi74yh4w0.swift:20:19: error:\
    \ cannot assign through subscript: subscript is get-only\n            result[index]\
    \ = character\n            ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // TODO:\
    \ Implement me!\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpoedjlm1c/tmpoedjlm1c.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67d0940c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67d0637b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67d0637988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67d06367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoedjlm1c                        0x0000556f5d9e4307 <unavailable> + 4871

    5    libc.so.6                          0x00002b67d0b2c460 __libc_start_main +
    245

    6    tmpoedjlm1c                        0x0000556f5d9e3f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    letters\
    \ := [String]()\n    for letter in message {\n        letters.append(letter)\n\
    \    }\n    var encodedString = \"\"\n    for letter := range letters {\n    \
    \    encodedString += replacement[letter]\n    }\n    return encodedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpku7vb117.swift:13:12: error: consecutive statements on a line must\
    \ be separated by ';'\n    letters := [String]()\n           ^\n           ;\n\
    /tmp/tmpku7vb117.swift:13:13: error: expected expression\n    letters := [String]()\n\
    \            ^\n/tmp/tmpku7vb117.swift:18:17: error: expected type\n    for letter\
    \ := range letters {\n                ^\n                 <#type#>\n/tmp/tmpku7vb117.swift:18:17:\
    \ error: expected 'in' after for-each pattern\n    for letter := range letters\
    \ {\n                ^\n/tmp/tmpku7vb117.swift:18:17: error: expected Sequence\
    \ expression for for-each loop\n    for letter := range letters {\n          \
    \      ^\n/tmp/tmpku7vb117.swift:13:5: error: cannot find 'letters' in scope\n\
    \    letters := [String]()\n    ^~~~~~~\n/tmp/tmpku7vb117.swift:15:9: error: cannot\
    \ find 'letters' in scope\n        letters.append(letter)\n        ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\t\n\t//find\
    \ all the vowels in the message\n\tvowels = Set(\"a\", \"e\", \"i\", \"o\", \"\
    u\", \"y\");\n\t\n\t//find all the letters in the message\n\tletters = Set(\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\");\n\t\n\t//create a map for storing letter pairs, so\
    \ that we can reorder the letters \n\t//while swaping letters\n\tletterPairs =\
    \ Dictionary<String, String>();\n\t\n\t//go through each letter in the message\n\
    \tfor letter in message.characters {\n\t\t//swap case for current letter\n\t\t\
    let swap = letter.lowercaseString;\n\t\t\n\t\t//if the letter is already in the\
    \ map, use that value\n\t\tif letterPairs[swap] != nil {\n\t\t\t//swap case for\
    \ new letter\n\t\t\tlet swap2 = letterPairs[swap].lowercaseString;\n\t\t\t\n\t\
    \t\t//if the letter is not in the map, add it to the map\n\t\t\tif !letterPairs[swap2]\
    \ == nil {\n\t\t\t\t//move the old letter to the end of the map\n\t\t\t\tletterPairs[swap]\
    \ = nil;\n\t\t\t\t//add new letter\n\t\t\t\tletterPairs[swap2] = letter;\n\t\t\
    \t}\n\t\t}\n\t\telse {\n\t\t\t//if the letter is not in the map, then add it to\
    \ the map\n\t\t\tletterPairs[swap] = letter;\n\t\t}\n\t}\n\t\n\t//go through each\
    \ vowel\n\tfor vowel in vowels {\n\t\t\n\t\t//move the vowel to the start of the\
    \ message\n\t\tlet swapped = message.characters.firstIndex(of: vowel);\n\t\tlet\
    \ moved = message.characters[swapped - 1]\n\t\t\n\t\t//replace vowel in message\n\
    \t\tmessage.characters[swapped - 1] = vowel;\n\t\t\n\t\t//add new letter to message\n\
    \t\tmessage.characters.insert(moved, letter);\n\t}\n\t\n\treturn message;\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpii66q7_w.swift:15:2: error: cannot find 'vowels' in scope\n   \
    \     vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n        ^~~~~~\n\
    /tmp/tmpii66q7_w.swift:15:11: error: no exact matches in call to initializer \n\
    \        vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n           \
    \      ^\n/tmp/tmpii66q7_w.swift:15:11: note: found candidate with type '(String...)\
    \ -> Set<String>'\n        vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\", \"\
    y\");\n                 ^\n/tmp/tmpii66q7_w.swift:18:2: error: cannot find 'letters'\
    \ in scope\n        letters = Set(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\");\n        ^~~~~~~\n\
    /tmp/tmpii66q7_w.swift:18:12: error: no exact matches in call to initializer \n\
    \        letters = Set(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    , \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\");\n                  ^\n/tmp/tmpii66q7_w.swift:18:12:\
    \ note: found candidate with type '(String...) -> Set<String>'\n        letters\
    \ = Set(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\",\
    \ \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\");\n                  ^\n/tmp/tmpii66q7_w.swift:22:2:\
    \ error: cannot find 'letterPairs' in scope\n        letterPairs = Dictionary<String,\
    \ String>();\n        ^~~~~~~~~~~\n/tmp/tmpii66q7_w.swift:25:24: error: 'characters'\
    \ is unavailable: Please use String directly\n        for letter in message.characters\
    \ {\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpii66q7_w.swift:27:21: error: value of type 'Character'\
    \ has no member 'lowercaseString'\n                let swap = letter.lowercaseString;\n\
    \                           ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpii66q7_w.swift:30:6:\
    \ error: cannot find 'letterPairs' in scope\n                if letterPairs[swap]\
    \ != nil {\n                   ^~~~~~~~~~~\n/tmp/tmpii66q7_w.swift:32:16: error:\
    \ cannot find 'letterPairs"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for i in 0..<message.count {\n        var c = message[i]\n     \
    \   let index = alphabet.index(of: c)!\n        let first = alphabet.index(before:\
    \ index)!\n        let last = alphabet.index(before: first)!\n        if i ==\
    \ 0 {\n            let a = alphabet.index(of: message[i])!\n            let b\
    \ = alphabet.index(of: message[a])!\n            if a == b {\n               \
    \ result += message[i]\n            } else {\n                result += message[i].capitalized\n\
    \            }\n        } else {\n            result += message[i].capitalized\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpmbk18xwt.swift:15:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        var c = message[i]\n\
    \                ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpmbk18xwt.swift:16:21: error: cannot find 'alphabet'\
    \ in scope\n        let index = alphabet.index(of: c)!\n                    ^~~~~~~~\n\
    /tmp/tmpmbk18xwt.swift:17:21: error: cannot find 'alphabet' in scope\n       \
    \ let first = alphabet.index(before: index)!\n                    ^~~~~~~~\n/tmp/tmpmbk18xwt.swift:18:20:\
    \ error: cannot find 'alphabet' in scope\n        let last = alphabet.index(before:\
    \ first)!\n                   ^~~~~~~~\n/tmp/tmpmbk18xwt.swift:20:21: error: cannot\
    \ find 'alphabet' in scope\n            let a = alphabet.index(of: message[i])!\n\
    \                    ^~~~~~~~\n/tmp/tmpmbk18xwt.swift:21:21: error: cannot find\
    \ 'alphabet' in scope\n            let b = alphabet.index(of: message[a])!\n \
    \                   ^~~~~~~~\n/tmp/tmpmbk18xwt.swift:23:34: error: no exact matches\
    \ in call to subscript \n                result += message[i]\n              \
    \                   ^\nSwift.String:3:12: note: candidate expects value of type\
    \ 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpmbk18xwt.swift:25:38:\
    \ error: value of type 'Character' has no member 'capitalized'\n             \
    \   result += message[i].capitalized\n                          ~~~~~~~~~~ ^~~~~~~~~~~\n\
    /tmp/tmpmbk18xwt.swift:28:34: error: value of type 'Character' has no member 'capitalized'\n\
    \            result += message[i].capitalized\n                      ~~~~~~~~~~\
    \ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.uppercase().replacingOccurrences(of: \"AEIOUaeiou\", with: \"E\", options:\
    \ .regularExpression)\n        .replacingOccurrences(of: \"AEIOUaeiou\", with:\
    \ \"\", options: .regularExpression)\n        .replacingOccurrences(of: \"aeiou\"\
    , with: \"E\", options: .regularExpression)\n        .replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: \"\", options: .regularExpression)\n        .replacingOccurrences(of:\
    \ \"aeiou\", with: \"I\", options: .regularExpression)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp9_m1cijr.swift:13:20: error: value of type 'String' has no member\
    \ 'uppercase'\n    return message.uppercase().replacingOccurrences(of: \"AEIOUaeiou\"\
    , with: \"E\", options: .regularExpression)\n           ~~~~~~~ ^~~~~~~~~\n/tmp/tmp9_m1cijr.swift:13:92:\
    \ error: cannot infer contextual base in reference to member 'regularExpression'\n\
    \    return message.uppercase().replacingOccurrences(of: \"AEIOUaeiou\", with:\
    \ \"E\", options: .regularExpression)\n                                      \
    \                                                    ~^~~~~~~~~~~~~~~~~\n/tmp/tmp9_m1cijr.swift:14:69:\
    \ error: cannot infer contextual base in reference to member 'regularExpression'\n\
    \        .replacingOccurrences(of: \"AEIOUaeiou\", with: \"\", options: .regularExpression)\n\
    \                                                                   ~^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9_m1cijr.swift:15:65: error: cannot infer contextual base in reference\
    \ to member 'regularExpression'\n        .replacingOccurrences(of: \"aeiou\",\
    \ with: \"E\", options: .regularExpression)\n                                \
    \                               ~^~~~~~~~~~~~~~~~~\n/tmp/tmp9_m1cijr.swift:16:69:\
    \ error: cannot infer contextual base in reference to member 'regularExpression'\n\
    \        .replacingOccurrences(of: \"AEIOUaeiou\", with: \"\", options: .regularExpression)\n\
    \                                                                   ~^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9_m1cijr.swift:17:65: error: cannot infer contextual base in reference\
    \ to member 'regularExpression'\n        .replacingOccurrences(of: \"aeiou\",\
    \ with: \"I\", options: .regularExpression)\n                                \
    \                               ~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for letter in message {\n        let vowels = \"aeiou\"\n      \
    \  let letterIndex = letters.index(of: letter)\n        let vowelIndex = vowels.firstIndex(of:\
    \ letter)\n        if letterIndex > vowelIndex {\n            let letterBefore\
    \ = letters.index(letterIndex, offsetBy: -1)\n            let letterAfter = letters.index(letterIndex,\
    \ offsetBy: 1)\n            let replacement = letters[letterIndex - 1]\n     \
    \       result.append(replacement)\n            result.append(letters[letterAfter])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpl14appru.swift:16:27: error: cannot find 'letters' in scope\n \
    \       let letterIndex = letters.index(of: letter)\n                        \
    \  ^~~~~~~\n/tmp/tmpl14appru.swift:18:26: error: value of optional type 'String.Index?'\
    \ must be unwrapped to a value of type 'String.Index'\n        if letterIndex\
    \ > vowelIndex {\n                         ^\n/tmp/tmpl14appru.swift:17:13: note:\
    \ short-circuit using 'guard' to exit this function early if the optional value\
    \ contains 'nil'\n        let vowelIndex = vowels.firstIndex(of: letter)\n   \
    \         ^\n        guard                                          else { return\
    \ <#default value#> }\n/tmp/tmpl14appru.swift:17:33: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        let vowelIndex\
    \ = vowels.firstIndex(of: letter)\n                                ^\n       \
    \                                                ?? <#default value#>\n/tmp/tmpl14appru.swift:17:33:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let vowelIndex = vowels.firstIndex(of: letter)\n            \
    \                    ^\n                                                     \
    \ !\n/tmp/tmpl14appru.swift:18:26: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        if letterIndex > vowelIndex\
    \ {\n                         ^\n                                    ?? <#default\
    \ value#>\n/tmp/tmpl14appru.swift:18:26: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        if letterIndex > vowelIndex\
    \ {\n                         ^\n                                   !\n/tmp/tmpl14appru.swift:19:32:\
    \ error: cannot find 'letters' in scope\n            let letterBefore = letters.index(letterIndex,\
    \ offsetBy: -1)\n                               ^~~~~~~\n/tmp/tmpl14appru.swift:20:31:\
    \ error: cannot find 'letters' in scope\n            let letterAfter = letters.index(letterIndex,\
    \ offsetBy: 1)\n                              ^~~~~~~\n/tmp/tmpl14appru.swift:21:31:\
    \ error: cannot find 'letters' in s"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var messageAsCharArray:\
    \ [Character] = Array(message.characters)\n    var output: String = String()\n\
    \    for var i = 0; i < messageAsCharArray.count; i++ {\n        var currentChar:\
    \ Character = messageAsCharArray[i]\n        if let currentCharIsVowel = currentChar.unicodeScalars.filter({$0.isVowel}).first\
    \ {\n            var currentCharIsNextVowel = messageAsCharArray[i.advancedBy(1)]\n\
    \            if currentCharIsNextVowel.unicodeScalars.filter({$0.isVowel}).first\
    \ {\n                let currentCharIsNextVowelIsNextChar = messageAsCharArray[i.advancedBy(2)]\n\
    \                if currentCharIsNextVowelIsNextChar.unicodeScalars.filter({$0.isVowel}).first\
    \ {\n                    let currentCharIsNextVowelIsNextCharIsNextChar = messageAsCharArray[i.advancedBy(3)]\n\
    \                    if currentCharIsNextVowelIsNextCharIsNextChar.unicodeScalars.filter({$0.isVowel}).first\
    \ {\n                        let currentCharIsNextVowelIsNextCharIsNextCharIsNextChar\
    \ = messageAsCharArray[i.advancedBy(4)]\n                        output.append(currentChar)\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return String(output)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpr0ohxvpy.swift:15:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < messageAsCharArray.count; i++ {\n    ^  \
    \ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpr0ohxvpy.swift:13:57:\
    \ error: 'characters' is unavailable: Please use String directly\n    var messageAsCharArray:\
    \ [Character] = Array(message.characters)\n                                  \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpr0ohxvpy.swift:17:75: error: value of type 'Unicode.Scalar' has no\
    \ member 'isVowel'\n        if let currentCharIsVowel = currentChar.unicodeScalars.filter({$0.isVowel}).first\
    \ {\n                                                                       ~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    \n    for letter in message {\n        let letterIndex = alphabet.indexOf(letter)\n\
    \        var newLetter: Char\n        if letterIndex < 0 {\n            newLetter\
    \ = letter\n        } else {\n            if letterIndex > 0 {\n             \
    \   newLetter = alphabet[letterIndex-1] + alphabet[letterIndex]\n            }\
    \ else {\n                newLetter = alphabet[letterIndex]\n            }\n \
    \       }\n        \n        // Only append if 2 letters ahead.\n        if letterIndex\
    \ > 1 {\n            result += newLetter\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpymarfeoa.swift:16:27: error: cannot find 'alphabet' in scope\n\
    \        let letterIndex = alphabet.indexOf(letter)\n                        \
    \  ^~~~~~~~\n/tmp/tmpymarfeoa.swift:17:24: error: cannot find type 'Char' in scope\n\
    \        var newLetter: Char\n                       ^~~~\n/tmp/tmpymarfeoa.swift:22:29:\
    \ error: cannot find 'alphabet' in scope\n                newLetter = alphabet[letterIndex-1]\
    \ + alphabet[letterIndex]\n                            ^~~~~~~~\n/tmp/tmpymarfeoa.swift:22:55:\
    \ error: cannot find 'alphabet' in scope\n                newLetter = alphabet[letterIndex-1]\
    \ + alphabet[letterIndex]\n                                                  \
    \    ^~~~~~~~\n/tmp/tmpymarfeoa.swift:24:29: error: cannot find 'alphabet' in\
    \ scope\n                newLetter = alphabet[letterIndex]\n                 \
    \           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    if let\
    \ firstLetter = message.first{\n        let twoLetters = message.dropFirst()\n\
    \        return String(twoLetters.map { $0.unicodeScalars.first }) + String(firstLetter.unicodeScalars.dropFirst())\n\
    \    }\n    return message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpywgu67xf.swift:15:16: error: no exact matches in call to initializer\
    \ \n        return String(twoLetters.map { $0.unicodeScalars.first }) + String(firstLetter.unicodeScalars.dropFirst())\n\
    \               ^\nSwift.String:4:12: note: candidate requires that the types\
    \ 'Unicode.Scalar?' and 'Character' be equivalent (requirement specified as 'S.Element'\
    \ == 'Character')\n    public init<S>(_ characters: S) where S : Sequence, S.Element\
    \ == Character\n           ^\nSwift.RangeReplaceableCollection:3:23: note: candidate\
    \ requires that the types 'String.Element' (aka 'Character') and 'Unicode.Scalar?'\
    \ be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n   \
    \ @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element ==\
    \ S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:3:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    @inlinable public\
    \ init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible\n\
    \                      ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message\n        .reduce(\"\") { acc, curr in\n            var vowels = Set.init([\"\
    a\", \"e\", \"i\", \"o\", \"u\"])\n            let splitted = curr.characters.split(separator:\
    \ \"\")\n            splitted.forEach { char in\n                if vowels.contains(char)\
    \ {\n                    vowels.insert(char.lowercased())\n                  \
    \  acc += \"\\(char.lowercased())\"\n                    vowels.remove(char.lowercased())\n\
    \                }\n            }\n            acc += String(splitted.count)\n\
    \            return acc\n        }\n        .reduce(\"\") { acc, curr in\n   \
    \         let splitted = curr.characters.split(separator: \"\")\n            let\
    \ letters = [\"a\", \"e\", \"i\", \"o\", \"u\"].sorted(by: <)\n            let\
    \ vowels = [\"\", \"a\", \"e\", \"i\", \"o\", \"u\"].sorted(by: <)\n         \
    \   var acc = \"\"\n            for char in splitted {\n                if vowels.contains(char)\
    \ {\n                    acc += \"\\(letters[vowels.index(char)]).\"\n       \
    \         } else {\n                    acc += \"\\(char).\"\n               \
    \ }\n            }\n            return acc\n        }\n        .reduce(\"\") {\
    \ acc, curr in\n            let splitted = curr.characters.split(separator: \"\
    \")\n            return acc + String(splitted.count)\n        }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpwjuhtfps.swift:16:33: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'characters'\n            let splitted = curr.characters.split(separator:\
    \ \"\")\n                           ~~~~ ^~~~~~~~~~\n/tmp/tmpwjuhtfps.swift:28:33:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'characters'\n\
    \            let splitted = curr.characters.split(separator: \"\")\n         \
    \                  ~~~~ ^~~~~~~~~~\n/tmp/tmpwjuhtfps.swift:42:33: error: value\
    \ of type 'String.Element' (aka 'Character') has no member 'characters'\n    \
    \        let splitted = curr.characters.split(separator: \"\")\n             \
    \              ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Fill\
    \ this in.\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpg0le863y/tmpg0le863y.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afcd374ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afcd3441b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afcd3441988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afcd34407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg0le863y                        0x0000556241def307 <unavailable> + 4871

    5    libc.so.6                          0x00002afcd3936460 __libc_start_main +
    245

    6    tmpg0le863y                        0x0000556241deef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message\n        .unicodeScalars\n        .filter({ !$0.isASCII })\n       \
    \ .flatMap { encode($0) }\n        .map { $0.replacingOccurrences(of: \"a...z\"\
    , with: \"A$1\") }\n        .flatMap { $0.unicodeScalars.filter { $0.isASCII }\
    \ }\n        .joined()\n        .replacingOccurrences(of: \"aeiouAEIOU\", with:\
    \ \"A$0\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbq_hlohg.swift:16:27: error: missing argument label 'message:'\
    \ in call\n        .flatMap { encode($0) }\n                          ^\n    \
    \                      message: \n/tmp/tmpbq_hlohg.swift:16:27: error: cannot\
    \ convert value of type 'Unicode.Scalar' to expected argument type 'String'\n\
    \        .flatMap { encode($0) }\n                          ^\n/tmp/tmpbq_hlohg.swift:20:10:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ .replacingOccurrences(of: \"aeiouAEIOU\", with: \"A$0\")\n         ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbq_hlohg.swift:17:19: error: value of type 'String.Element' (aka 'Character')\
    \ has no member 'replacingOccurrences'\n        .map { $0.replacingOccurrences(of:\
    \ \"a...z\", with: \"A$1\") }\n               ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbq_hlohg.swift:18:18:\
    \ error: unable to infer type of a closure parameter '$0' in the current context\n\
    \        .flatMap { $0.unicodeScalars.filter { $0.isASCII } }\n              \
    \   ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.lowercased().toUpperString.replaceAll(\"A\", \"D\")\n    .replaceAll(\"\
    B\", \"E\")\n    .replaceAll(\"C\", \"G\")\n    .replaceAll(\"D\", \"A\")\n  \
    \  .replaceAll(\"E\", \"B\")\n    .replaceAll(\"F\", \"C\")\n    .replaceAll(\"\
    G\", \"D\")\n    .replaceAll(\"H\", \"E\")\n    .replaceAll(\"I\", \"F\")\n  \
    \  .replaceAll(\"J\", \"G\")\n    .replaceAll(\"K\", \"H\")\n    .replaceAll(\"\
    L\", \"I\")\n    .replaceAll(\"M\", \"J\")\n    .replaceAll(\"N\", \"K\")\n  \
    \  .replaceAll(\"O\", \"L\")\n    .replaceAll(\"P\", \"M\")\n    .replaceAll(\"\
    Q\", \"N\")\n    .replaceAll(\"R\", \"S\")\n    .replaceAll(\"T\", \"O\")\n  \
    \  .replaceAll(\"U\", \"P\")\n    .replaceAll(\"V\", \"Q\")\n    .replaceAll(\"\
    W\", \"R\")\n    .replaceAll(\"X\", \"T\")\n    .replaceAll(\"Y\", \"U\")\n  \
    \  .replaceAll(\"Z\", \"V\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpxyngf7pe.swift:13:33: error: value of type 'String' has no member\
    \ 'toUpperString'\n    return message.lowercased().toUpperString.replaceAll(\"\
    A\", \"D\")\n           ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var outputMessage\
    \ = \"\"\n    var alphabet = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"\
    , \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\"\
    , \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n    for char in message\
    \ {\n        for index in 0..<alphabet.count {\n            if char == alphabet[index]\
    \ {\n                let nextIndex = alphabet.index(before: index)! + 1\n    \
    \            if nextIndex < alphabet.count {\n                    outputMessage.append(alphabet[nextIndex])\n\
    \                } else {\n                    outputMessage.append(char.lowercased())\n\
    \                }\n                break\n            }\n        }\n    }\n \
    \   return outputMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpz3fwjsj2.swift:17:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n            if char == alphabet[index]\
    \ {\n               ~~~~ ^  ~~~~~~~~~~~~~~~\n/tmp/tmpz3fwjsj2.swift:17:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if char == alphabet[index] {\n   \
    \                 ^\n/tmp/tmpz3fwjsj2.swift:18:62: error: cannot force unwrap\
    \ value of non-optional type 'Int'\n                let nextIndex = alphabet.index(before:\
    \ index)! + 1\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                             \n"
  stdout: ''
  timestamp: 1659978719
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpfxppth69/tmpfxppth69.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e8e705c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e8e3fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e8e3fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e8e3fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfxppth69                        0x0000555e977b0307 <unavailable> + 4871

    5    libc.so.6                          0x00002b4e8e8f1460 __libc_start_main +
    245

    6    tmpfxppth69                        0x0000555e977aff49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978573
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ : String = \"\"\n    for i in message {\n        result += String([i as Char])\
    \ + String([i as Char].isUpper) \n    }\n    let vowels : [String] = [\"\", \"\
    A\", \"I\", \"O\", \"U\"]\n    for element in vowels {\n        let startIndex\
    \ = result.characters.index(of: element)\n        let endIndex = result.characters.index(of:\
    \ element, offsetBy: 2, limitedBy: result.endIndex) \n        let substring =\
    \ String(result.characters.suffix(from: startIndex))\n        let newSubString\
    \ = String(substring).replacingOccurrences(of: element, with: element.lowercased())\n\
    \        result = result.replaceSubrange(startIndex..<endIndex, with: newSubString)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpv1xewz82.swift:15:32: error: cannot find type 'Char' in scope\n\
    \        result += String([i as Char]) + String([i as Char].isUpper) \n      \
    \                         ^~~~\n/tmp/tmpv1xewz82.swift:15:54: error: cannot find\
    \ type 'Char' in scope\n        result += String([i as Char]) + String([i as Char].isUpper)\
    \ \n                                                     ^~~~\n/tmp/tmpv1xewz82.swift:15:60:\
    \ error: value of type '[Character]' has no member 'isUpper'\n        result +=\
    \ String([i as Char]) + String([i as Char].isUpper) \n                       \
    \                        ~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpv1xewz82.swift:19:54: error:\
    \ cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let startIndex = result.characters.index(of: element)\n\
    \                                                     ^\n/tmp/tmpv1xewz82.swift:20:42:\
    \ error: no exact matches in call to instance method 'index'\n        let endIndex\
    \ = result.characters.index(of: element, offsetBy: 2, limitedBy: result.endIndex)\
    \ \n                                         ^\n/tmp/tmpv1xewz82.swift:20:42:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int, limitedBy: String.Index)\n        let endIndex = result.characters.index(of:\
    \ element, offsetBy: 2, limitedBy: result.endIndex) \n                       \
    \                  ^\n/tmp/tmpv1xewz82.swift:20:42: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int, limitedBy: String.Index)\n\
    \        let endIndex = result.characters.index(of: element, offsetBy: 2, limitedBy:\
    \ result.endIndex) \n                                         ^\n/tmp/tmpv1xewz82.swift:20:42:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int, limitedBy: String.Index)\n        let endIndex = result.characters.index(of:\
    \ element, offsetBy: 2, limitedBy: result.endIndex) \n                       \
    \                  ^\n/tmp/tmpv1xewz82.swift:22:46: error: reference to member\
    \ 'replacingOccurrences' cannot be resolved without a con"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels:\
    \ Set<Character> = [ \"a\", \"e\", \"i\", \"o\", \"u\" ]\n\n    var result: String\
    \ = \"\"\n    var currentLetter = message[0]\n\n    for char in message {\n  \
    \      if vowels.contains(char) {\n            let index = vowels.firstIndex(of:\
    \ char)\n            if index > 0 {\n                let twoLetters = vowels[index-2]\n\
    \                result += char + twoLetters\n            }\n        }\n     \
    \   else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpq_8h5bcu.swift:16:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var currentLetter\
    \ = message[0]\n                        ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpq_8h5bcu.swift:21:22: error: binary\
    \ operator '>' cannot be applied to operands of type 'Set<Character>.Index?' and\
    \ 'Int'\n            if index > 0 {\n               ~~~~~ ^ ~\n/tmp/tmpq_8h5bcu.swift:21:22:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n            if index > 0 {\n                     ^\n/tmp/tmpq_8h5bcu.swift:22:40:\
    \ error: no exact matches in call to subscript \n                let twoLetters\
    \ = vowels[index-2]\n                                       ^\n/tmp/tmpq_8h5bcu.swift:22:40:\
    \ note: candidate has partially matching parameter list (Set<Character>.Index)\n\
    \                let twoLetters = vowels[index-2]\n                          \
    \             ^\n/tmp/tmpq_8h5bcu.swift:22:40: note: candidate has partially matching\
    \ parameter list (Range<Set<Character>.Index>)\n                let twoLetters\
    \ = vowels[index-2]\n                                       ^\n/tmp/tmpq_8h5bcu.swift:22:40:\
    \ note: candidate has partially matching parameter list ((UnboundedRange_) ->\
    \ ())\n                let twoLetters = vowels[index-2]\n                    \
    \                   ^\n/tmp/tmpq_8h5bcu.swift:22:46: error: binary operator '-'\
    \ cannot be applied to operands of type 'Set<Character>.Index?' and 'Int'\n  \
    \              let twoLetters = vowels[index-2]\n                            \
    \            ~~~~~^~\n/tmp/tmpq_8h5bcu.swift:22:46: note: overloads for '-' exist\
    \ with these partially matching parameter lists: (Int, Int)\n                let\
    \ twoLetters = vowels[index-2]\n                                             ^\n\
    /tmp/tmpq_8h5bcu.swift:27:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += char\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n\n    let vowels = \"aeiou\"\n\n    for letter in message {\n      \
    \  if let upper = String(letter).uppercaseString{\n            result += upper\n\
    \        } else {\n            let index = letter.unicodeScalars.firstIndex(of:\
    \ vowels)!\n            let firstVowel = vowels.unicodeScalars.first\n       \
    \     let secondVowel = vowels.unicodeScalars.last\n            let swappedLetter\
    \ = String(firstVowel).replacingCharacters(in: index, with: String(secondVowel))\n\
    \            result += String(letter).replacingCharacters(in: index, with: swappedLetter)\n\
    \        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp6x6y465n.swift:18:39: error: value of type 'String' has no member\
    \ 'uppercaseString'\n        if let upper = String(letter).uppercaseString{\n\
    \                       ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp6x6y465n.swift:21:62:\
    \ error: cannot convert value of type 'String' to expected argument type 'Unicode.Scalar'\n\
    \            let index = letter.unicodeScalars.firstIndex(of: vowels)!\n     \
    \                                                        ^\n/tmp/tmp6x6y465n.swift:24:89:\
    \ error: no exact matches in call to initializer \n            let swappedLetter\
    \ = String(firstVowel).replacingCharacters(in: index, with: String(secondVowel))\n\
    \                                                                            \
    \            ^\n/tmp/tmp6x6y465n.swift:24:89: note: found candidate with type\
    \ '(Unicode.Scalar) -> String'\n            let swappedLetter = String(firstVowel).replacingCharacters(in:\
    \ index, with: String(secondVowel))\n                                        \
    \                                                ^\n/tmp/tmp6x6y465n.swift:24:89:\
    \ note: found candidate with type '(Unicode.Scalar?) -> String'\n            let\
    \ swappedLetter = String(firstVowel).replacingCharacters(in: index, with: String(secondVowel))\n\
    \                                                                            \
    \            ^\n/tmp/tmp6x6y465n.swift:24:89: note: found candidate with type\
    \ '(Unicode.Scalar?) -> String'\n            let swappedLetter = String(firstVowel).replacingCharacters(in:\
    \ index, with: String(secondVowel))\n                                        \
    \                                                ^\n/tmp/tmp6x6y465n.swift:24:33:\
    \ error: no exact matches in call to initializer \n            let swappedLetter\
    \ = String(firstVowel).replacingCharacters(in: index, with: String(secondVowel))\n\
    \                                ^\n/tmp/tmp6x6y465n.swift:24:33: note: found\
    \ candidate with type '(Unicode.Scalar) -> String'\n            let swappedLetter\
    \ = String(firstVowel).replacingCharacters(in: index, with: String(secondVowel))\n\
    \                          "
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let encoded\
    \ = NSMutableString(string: message)\n    for index in 0..<encoded.length {\n\
    \        let ch = encoded.characterAtIndex(index)\n        let ch = ch.uppercaseString\n\
    \        let vowelIndex = String(ch.unicodeScalars.indexOfObject(NSRange(location:\
    \ 2, length: 2)))\n        switch vowelIndex {\n        case \"E\":\n        \
    \    encoded.replaceCharactersInRange(NSRange(location: index, length: 1), withString:\
    \ \"E\")\n        case \"I\":\n            encoded.replaceCharactersInRange(NSRange(location:\
    \ index, length: 1), withString: \"I\")\n        case \"O\":\n            encoded.replaceCharactersInRange(NSRange(location:\
    \ index, length: 1), withString: \"O\")\n        case \"U\":\n            encoded.replaceCharactersInRange(NSRange(location:\
    \ index, length: 1), withString: \"U\")\n        default:\n            encoded.replaceCharactersInRange(NSRange(location:\
    \ index, length: 1), withString: ch)\n        }\n    }\n    return encoded.capitalizedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpufbi_9ct.swift:13:19: error: cannot find 'NSMutableString' in scope\n\
    \    let encoded = NSMutableString(string: message)\n                  ^~~~~~~~~~~~~~~\n\
    /tmp/tmpufbi_9ct.swift:17:65: error: cannot find 'NSRange' in scope\n        let\
    \ vowelIndex = String(ch.unicodeScalars.indexOfObject(NSRange(location: 2, length:\
    \ 2)))\n                                                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var outString\
    \ = message\n    for char in message.unicodeScalars {\n        if char.value >=\
    \ 0x41 && char.value <= 0x5A {\n            outString = outString.replacingCharacters(in:\
    \ char.unicodeScalars.allCases, with: \"A\")\n        } else {\n            outString\
    \ = outString.replacingCharacters(in: char.unicodeScalars.allCases.map { $0.value\
    \ }, with: \"a\")\n        }\n    }\n    return outString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpb0cv6wln.swift:16:35: error: value of type 'String' has no member\
    \ 'replacingCharacters'\n            outString = outString.replacingCharacters(in:\
    \ char.unicodeScalars.allCases, with: \"A\")\n                        ~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpb0cv6wln.swift:16:64: error: value of type 'Unicode.Scalar'\
    \ has no member 'unicodeScalars'\n            outString = outString.replacingCharacters(in:\
    \ char.unicodeScalars.allCases, with: \"A\")\n                               \
    \                           ~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpb0cv6wln.swift:18:35:\
    \ error: value of type 'String' has no member 'replacingCharacters'\n        \
    \    outString = outString.replacingCharacters(in: char.unicodeScalars.allCases.map\
    \ { $0.value }, with: \"a\")\n                        ~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb0cv6wln.swift:18:64: error: value of type 'Unicode.Scalar' has no member\
    \ 'unicodeScalars'\n            outString = outString.replacingCharacters(in:\
    \ char.unicodeScalars.allCases.map { $0.value }, with: \"a\")\n              \
    \                                            ~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Initialize\
    \ an output string\n    var output = \"\"\n\n    // Iterate over the characters\
    \ in the message\n    for char in message {\n        // If the character is a\
    \ vowel...\n        if char.isUppercase {\n            // Iterate over the vowels...\n\
    \            for vowel in vowels {\n                // Replace the vowel with\
    \ the letter that is two places ahead of the vowel\n                output = output.replace(vowel,\
    \ vowels[vowels.index(vowel)+1])\n            }\n            // Append the character\
    \ to the output\n            output = output + char\n        } else {\n      \
    \      // Append the character to output\n            output = output + char\n\
    \        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmprouihloz.swift:21:26: error: cannot find 'vowels' in scope\n  \
    \          for vowel in vowels {\n                         ^~~~~~\n/tmp/tmprouihloz.swift:26:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            output = output + char\n                              ^\n/tmp/tmprouihloz.swift:29:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            output = output + char\n                              ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\t\n\tvar resultString\
    \ = \"\"\n\t\n\tlet vowels = \"aeiouAEIOU\"\n\t\n\tfor char in message {\n\t\t\
    if vowels.contains(char) {\n\t\t\tlet index = vowels.index(of: char)!\n\t\t\t\
    resultString += String(message[index - 1])\n\t\t\tresultString += String(message[index\
    \ + 1])\n\t\t}\n\t\telse {\n\t\t\tresultString += char\n\t\t}\n\t}\n\treturn resultString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yt_h80k.swift:20:23: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n                        let index = vowels.index(of: char)!\n\
    \                                           ^\n/tmp/tmp3yt_h80k.swift:20:23: note:\
    \ use 'firstIndex(of:)' instead\n                        let index = vowels.index(of:\
    \ char)!\n                                           ^~~~~\n                 \
    \                          firstIndex\n/tmp/tmp3yt_h80k.swift:21:35: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \                   resultString += String(message[index - 1])\n             \
    \                                          ^\n/tmp/tmp3yt_h80k.swift:22:35: error:\
    \ cannot convert value of type 'String.Index' to expected argument type 'Int'\n\
    \                        resultString += String(message[index + 1])\n        \
    \                                               ^\n/tmp/tmp3yt_h80k.swift:25:20:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                        resultString += char\n                              \
    \          ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    let\
    \ alphabet = message.unicodeScalars\n    let vowels = \"aeiouAEIOU\"\n    \n \
    \   let mut encodedString = String()\n    for (_,c) in alphabet.enumerated() {\n\
    \        if c.unicodeScalars.count < 2 || vowels.contains(c.scalar) {\n      \
    \      encodedString += c.unicodeScalars.last.string.capitalize + c.unicodeScalars.first!.string\n\
    \        } else if c.unicodeScalars.count == 2 {\n            encodedString +=\
    \ c.unicodeScalars.first!.string + c.unicodeScalars.last!.string\n        } else\
    \ {\n            encodedString += c.unicodeScalars.first!.string + c.unicodeScalars.last!.string\
    \ + c.unicodeScalars.last!.string\n        }\n    }\n    \n    return encodedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgee7pwoo.swift:17:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut encodedString\
    \ = String()\n            ^\n/tmp/tmpgee7pwoo.swift:17:13: note: join the identifiers\
    \ together\n    let mut encodedString = String()\n        ~~~~^~~~~~~~~~~~~\n\
    \        mutencodedString\n/tmp/tmpgee7pwoo.swift:17:13: note: join the identifiers\
    \ together with camel-case\n    let mut encodedString = String()\n        ~~~~^~~~~~~~~~~~~\n\
    \        mutEncodedString\n/tmp/tmpgee7pwoo.swift:19:14: error: value of type\
    \ 'Unicode.Scalar' has no member 'unicodeScalars'\n        if c.unicodeScalars.count\
    \ < 2 || vowels.contains(c.scalar) {\n           ~ ^~~~~~~~~~~~~~\n/tmp/tmpgee7pwoo.swift:19:60:\
    \ error: value of type 'Unicode.Scalar' has no member 'scalar'\n        if c.unicodeScalars.count\
    \ < 2 || vowels.contains(c.scalar) {\n                                       \
    \                  ~ ^~~~~~\n/tmp/tmpgee7pwoo.swift:20:13: error: cannot find\
    \ 'encodedString' in scope\n            encodedString += c.unicodeScalars.last.string.capitalize\
    \ + c.unicodeScalars.first!.string\n            ^~~~~~~~~~~~~\n/tmp/tmpgee7pwoo.swift:20:32:\
    \ error: value of type 'Unicode.Scalar' has no member 'unicodeScalars'\n     \
    \       encodedString += c.unicodeScalars.last.string.capitalize + c.unicodeScalars.first!.string\n\
    \                             ~ ^~~~~~~~~~~~~~\n/tmp/tmpgee7pwoo.swift:20:74:\
    \ error: value of type 'Unicode.Scalar' has no member 'unicodeScalars'\n     \
    \       encodedString += c.unicodeScalars.last.string.capitalize + c.unicodeScalars.first!.string\n\
    \                                                                       ~ ^~~~~~~~~~~~~~\n\
    /tmp/tmpgee7pwoo.swift:21:21: error: value of type 'Unicode.Scalar' has no member\
    \ 'unicodeScalars'\n        } else if c.unicodeScalars.count == 2 {\n        \
    \          ~ ^~~~~~~~~~~~~~\n/tmp/tmpgee7pwoo.swift:22:13: error: cannot find\
    \ 'encodedString' in scope\n            encodedString += c.unicodeScalars.first!.string\
    \ + c.unicodeScalars.last!.string\n            ^~~~~~~~~~~~~\n/tmp/tmpg"
  stdout: ''
  timestamp: 1659978723
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var messageIndex\
    \ = 0\n    var result = \"\"\n    for char in message {\n        let isVowel =\
    \ Character.isLetter(char)\n        let shouldSwitchCase = isVowel && (messageIndex\
    \ % 2 == 0)\n        let isInEnglishLetterRange = Character.isLetter(message[messageIndex])\n\
    \        let shouldReplaceVowel = Character.isLetter(message[messageIndex + 1])\
    \ && (messageIndex % 2 != 0)\n        \n        if shouldSwitchCase {\n      \
    \      result += Char.swapCase(char)\n        }\n        \n        if shouldReplaceVowel\
    \ {\n            result += message[messageIndex + 1]\n        }\n        \n  \
    \      messageIndex += 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmptvxeigpm.swift:16:23: error: instance member 'isLetter' cannot\
    \ be used on type 'Character'; did you mean to use a value of this type instead?\n\
    \        let isVowel = Character.isLetter(char)\n                      ^~~~~~~~~\n\
    /tmp/tmptvxeigpm.swift:16:33: error: cannot call value of non-function type 'Bool'\n\
    \        let isVowel = Character.isLetter(char)\n                            \
    \    ^\n/tmp/tmptvxeigpm.swift:18:38: error: instance member 'isLetter' cannot\
    \ be used on type 'Character'; did you mean to use a value of this type instead?\n\
    \        let isInEnglishLetterRange = Character.isLetter(message[messageIndex])\n\
    \                                     ^~~~~~~~~\n/tmp/tmptvxeigpm.swift:18:48:\
    \ error: cannot call value of non-function type 'Bool'\n        let isInEnglishLetterRange\
    \ = Character.isLetter(message[messageIndex])\n                              \
    \                 ^\n/tmp/tmptvxeigpm.swift:19:34: error: instance member 'isLetter'\
    \ cannot be used on type 'Character'; did you mean to use a value of this type\
    \ instead?\n        let shouldReplaceVowel = Character.isLetter(message[messageIndex\
    \ + 1]) && (messageIndex % 2 != 0)\n                                 ^~~~~~~~~\n\
    /tmp/tmptvxeigpm.swift:19:44: error: cannot call value of non-function type 'Bool'\n\
    \        let shouldReplaceVowel = Character.isLetter(message[messageIndex + 1])\
    \ && (messageIndex % 2 != 0)\n                                           ^\n/tmp/tmptvxeigpm.swift:22:23:\
    \ error: cannot find 'Char' in scope\n            result += Char.swapCase(char)\n\
    \                      ^~~~\n/tmp/tmptvxeigpm.swift:26:30: error: no exact matches\
    \ in call to subscript \n            result += message[messageIndex + 1]\n   \
    \                          ^\nSwift.String:3:12: note: candidate expects value\
    \ of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (Unbound"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n\n    for i in 0..<message.characters.count {\n        let char = message.characters[i]\n\
    \        let index = (i + 1)/2\n\n        if char.isUppercase {\n            if\
    \ index == 0 {\n                result = result + char\n            } else {\n\
    \                result = result + char.uppercaseString[i - 1]\n            }\n\
    \        } else {\n            if index == 0 {\n                result = result\
    \ + char\n            } else {\n                result = result + char.lowercaseString[i\
    \ - 1]\n            }\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpcra87e27.swift:15:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<message.characters.count {\n         \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpcra87e27.swift:16:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = message.characters[i]\n                   ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcra87e27.swift:16:28:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = message.characters[i]\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpcra87e27.swift:21:35: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result = result + char\n                                  ^\n/tmp/tmpcra87e27.swift:23:40:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \       result = result + char.uppercaseString[i - 1]\n                      \
    \            ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpcra87e27.swift:27:35: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \           result = result + char\n                                  ^\n/tmp/tmpcra87e27.swift:29:40:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \       result = result + char.lowercaseString[i - 1]\n                      \
    \            ~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encodedMessage\
    \ = \"\"\n    for character in message {\n        if character == character.lowercased()\
    \ {\n            encodedMessage += character.uppercased()\n        }\n       \
    \ encodedMessage += character.lowercased()\n    }\n    return encodedMessage\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpnx2chol4.swift:15:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == character.lowercased()\
    \ {\n           ~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnx2chol4.swift:15:22:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if character == character.lowercased()\
    \ {\n                     ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = ''\n    for char in message\
    \ {\n        let index = alphabet.characters.index(of: char)\n        let charBefore\
    \ = alphabet.characters[index-1]\n        let charAfter = alphabet.characters[index+1]\n\
    \        switch char {\n        case \"a\" ... \"z\" where charBefore == \"a\"\
    \ ... \"z\":\n            result += \"T\"\n        case \"A\" ... \"Z\" where\
    \ charBefore == \"A\" ... \"Z\":\n            result += \"t\"\n        case \"\
    0\" ... \"9\" where charBefore == \"0\" ... \"9\":\n            result += \"k\"\
    \n        default:\n            result += char\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmps8ikcvev.swift:14:18: error: single-quoted string literal found,\
    \ use '\"'\n    var result = ''\n                 ^~\n                 \"\"\n\
    /tmp/tmps8ikcvev.swift:16:30: error: 'characters' is unavailable: Please use String\
    \ directly\n        let index = alphabet.characters.index(of: char)\n        \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmps8ikcvev.swift:16:41: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.characters.index(of: char)\n\
    \                                        ^\n/tmp/tmps8ikcvev.swift:16:41: note:\
    \ use 'firstIndex(of:)' instead\n        let index = alphabet.characters.index(of:\
    \ char)\n                                        ^~~~~\n                     \
    \                   firstIndex\n/tmp/tmps8ikcvev.swift:17:46: error: cannot convert\
    \ value of type 'String.Index?' to expected argument type 'Int'\n        let charBefore\
    \ = alphabet.characters[index-1]\n                                           \
    \  ^\n/tmp/tmps8ikcvev.swift:18:45: error: cannot convert value of type 'String.Index?'\
    \ to expected argument type 'Int'\n        let charAfter = alphabet.characters[index+1]\n\
    \                                            ^\n/tmp/tmps8ikcvev.swift:27:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += char\n                      ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ encode(message, lettersGuessed: lettersGuessed)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpn4syznms.swift:13:44: error: cannot find 'lettersGuessed' in scope\n\
    \    return encode(message, lettersGuessed: lettersGuessed)\n                \
    \                           ^~~~~~~~~~~~~~\n/tmp/tmpn4syznms.swift:13:44: error:\
    \ extra argument 'lettersGuessed' in call\n    return encode(message, lettersGuessed:\
    \ lettersGuessed)\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.map {\n        switch $0 {\n        case \"A\": return \"a\"\n     \
    \   case \"B\": return \"b\"\n        case \"C\": return \"c\"\n        case \"\
    D\": return \"d\"\n        case \"E\": return \"e\"\n        case \"F\": return\
    \ \"f\"\n        case \"G\": return \"g\"\n        case \"H\": return \"h\"\n\
    \        case \"I\": return \"i\"\n        case \"J\": return \"j\"\n        case\
    \ \"K\": return \"k\"\n        case \"L\": return \"l\"\n        case \"M\": return\
    \ \"m\"\n        case \"N\": return \"n\"\n        case \"O\": return \"o\"\n\
    \        case \"P\": return \"p\"\n        case \"Q\": return \"q\"\n        case\
    \ \"R\": return \"r\"\n        case \"S\": return \"s\"\n        case \"T\": return\
    \ \"t\"\n        case \"U\": return \"u\"\n        case \"V\": return \"v\"\n\
    \        case \"W\": return \"w\"\n        case \"X\": return \"x\"\n        case\
    \ \"Y\": return \"y\"\n        case \"Z\": return \"z\"\n        case \"a\": return\
    \ \"a\"\n        case \"b\": return \"b\"\n        case \"c\": return \"c\"\n\
    \        case \"d\": return \"d\"\n        case \"e\": return \"e\"\n        case\
    \ \"f\": return \"f\"\n        case \"g\": return \"g\"\n        case \"h\": return\
    \ \"h\"\n        case \"i\": return \"i\"\n        case \"j\": return \"j\"\n\
    \        case \"k\": return \"k\"\n        case \"l\": return \"l\"\n        case\
    \ \"m\": return \"m\"\n        case \"n\": return \"n\"\n        case \"o\": return\
    \ \"o\"\n        case \"p\": return \"p\"\n        case \"q\": return \"q\"\n\
    \        case \"r\": return \"r\"\n        case \"s\": return \"s\"\n        case\
    \ \"t\": return \"t\"\n        case \"u\": return \"u\"\n        case \"v\": return\
    \ \"v\"\n        case \"w\": return \"w\"\n        case \"x\": return \"x\"\n\
    \        case \"y\": return \"y\"\n        case \"z\": return \"z\"\n        default:\n\
    \            if let vowel = UnicodeScalar($0).unicodeScalars.filter({ $0.value\
    \ > 0 && $0.value < 256 }).first {\n                return String(repeatElement(vowel,\
    \ count: 2))\n            } else {\n                return String($0)\n      \
    \      }\n        }\n    }.reduce(\"\", +)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp25orw4j6.swift:74:7: error: type of expression is ambiguous without\
    \ more context\n    }.reduce(\"\", +)\n~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978930
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.unicodeScalars\n        .map { unicodeScalar: UnicodeScalar in\n   \
    \         let lowerCase = unicodeScalar.value.lowercased\n            let index\
    \ = lowercase[lowercase.length - 1]\n            if index == \"e\" {\n       \
    \         return \"a\" // lowerCase is \"\xE6\"\n            } else if index ==\
    \ \"i\" {\n                return \"o\" // lowerCase is \"\xEF\"\n           \
    \ } else if index == \"a\" {\n                return \"e\" // lowerCase is \"\xE5\
    \"\n            } else if index == \"o\" {\n                return \"i\" // lowerCase\
    \ is \"\xF4\"\n            } else {\n                return \"o\" // lowerCase\
    \ is \"\xF8\"\n            }\n        }\n        .joined()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp9wo4f7c0.swift:14:29: error: consecutive statements on a line must\
    \ be separated by ';'\n        .map { unicodeScalar: UnicodeScalar in\n      \
    \                      ^\n                            ;\n/tmp/tmp9wo4f7c0.swift:14:29:\
    \ error: expected expression\n        .map { unicodeScalar: UnicodeScalar in\n\
    \                            ^\n/tmp/tmp9wo4f7c0.swift:14:16: error: cannot find\
    \ 'unicodeScalar' in scope\n        .map { unicodeScalar: UnicodeScalar in\n \
    \              ^~~~~~~~~~~~~\n/tmp/tmp9wo4f7c0.swift:15:29: error: cannot find\
    \ 'unicodeScalar' in scope\n            let lowerCase = unicodeScalar.value.lowercased\n\
    \                            ^~~~~~~~~~~~~\n/tmp/tmp9wo4f7c0.swift:16:25: error:\
    \ cannot find 'lowercase' in scope\n            let index = lowercase[lowercase.length\
    \ - 1]\n                        ^~~~~~~~~\n/tmp/tmp9wo4f7c0.swift:16:35: error:\
    \ cannot find 'lowercase' in scope\n            let index = lowercase[lowercase.length\
    \ - 1]\n                                  ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message\n        .stringByReplacingOccurrencesOfString(\n            \"aeiouAEIOU\"\
    , withString: \"\", options: NSStringCompareOptions.CaseInsensitive,\n       \
    \     range: nil)\n        .stringByReplacingOccurrencesOfString(\n          \
    \  \"aAeiouAEIOU\", withString: \"e\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"yYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"AAYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"uUyAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"AUYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"UuyAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"UUyAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"YyAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"YYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"YYYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"YYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"YyAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"uUy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpsrmlyz0m.swift:54:13: error: unterminated string literal\n    \
    \        \"uUy\n            ^\n/tmp/tmpsrmlyz0m.swift:15:52: error: cannot find\
    \ 'NSStringCompareOptions' in scope\n            \"aeiouAEIOU\", withString: \"\
    \", options: NSStringCompareOptions.CaseInsensitive,\n                       \
    \                            ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsrmlyz0m.swift:18:54:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n            \"aAeiouAEIOU\"\
    , withString: \"e\", options: NSStringCompareOptions.CaseInsensitive,\n      \
    \                                               ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsrmlyz0m.swift:21:50:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n            \"yYAEIOU\"\
    , withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n      \
    \                                           ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsrmlyz0m.swift:24:51:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n            \"AAYAEIOU\"\
    , withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n      \
    \                                            ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsrmlyz0m.swift:27:51:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n            \"uUyAEIOU\"\
    , withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n      \
    \                                            ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsrmlyz0m.swift:30:51:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n            \"AUYAEIOU\"\
    , withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n      \
    \                                            ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsrmlyz0m.swift:33:51:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n            \"UuyAEIOU\"\
    , withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n      \
    \                                            ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsrmlyz0m.swift:36:51:\
    \ error: cannot find 'NSStringCompareOptions' in scope\n            \"UUyAEIOU\"\
    , withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n      \
    \                                            ^"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    var vowels = String()\n    for char in message {\n        let unicodeScalar\
    \ = char.unicodeScalars.first!\n        \n        if unicodeScalar.value > 0x5F\
    \ { // A consonant\n            let index = unicodeScalar.value - 0x5F\n     \
    \       result += \"K\" + String(UnicodeScalar(index).value)\n        } else if\
    \ unicodeScalar.value > 0x41 { // A vowel\n            let index = unicodeScalar.value\
    \ - 0x41\n            result += \"t\" + String(UnicodeScalar(index).value)\n \
    \           vowels += String(UnicodeScalar(index).value)\n        } else { //\
    \ A letter\n            result += String(unicodeScalar.value)\n        }\n   \
    \ }\n    if vowels.count > 0 {\n        result += String(UnicodeScalar(vowels.unicodeScalars.first!.value).value)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_g6bwjkt.swift:20:55: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to refer to member 'value'\
    \ of wrapped base type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            result\
    \ += \"K\" + String(UnicodeScalar(index).value)\n                            \
    \                          ^\n/tmp/tmp_g6bwjkt.swift:20:55: note: chain the optional\
    \ using '?' to access member 'value' only for non-'nil' base values\n        \
    \    result += \"K\" + String(UnicodeScalar(index).value)\n                  \
    \                                    ^\n                                     \
    \                  ?\n/tmp/tmp_g6bwjkt.swift:20:55: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n            result\
    \ += \"K\" + String(UnicodeScalar(index).value)\n                            \
    \                          ^\n                                               \
    \        !\n/tmp/tmp_g6bwjkt.swift:23:55: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to refer to member 'value'\
    \ of wrapped base type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            result\
    \ += \"t\" + String(UnicodeScalar(index).value)\n                            \
    \                          ^\n/tmp/tmp_g6bwjkt.swift:23:55: note: chain the optional\
    \ using '?' to access member 'value' only for non-'nil' base values\n        \
    \    result += \"t\" + String(UnicodeScalar(index).value)\n                  \
    \                                    ^\n                                     \
    \                  ?\n/tmp/tmp_g6bwjkt.swift:23:55: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n            result\
    \ += \"t\" + String(UnicodeScalar(index).value)\n                            \
    \                          ^\n                                               \
    \        !\n/tmp/tmp_g6bwjkt.swift:24:49: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to refer to member 'value'\
    \ of wrapped base type 'UnicodeScalar' (aka 'Unicod"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    var\
    \ encoded = \"\"\n    \n    for character in message {\n        \n        switch\
    \ character {\n            \n        case \" \":\n            encoded += \"S\"\
    \n            \n        case \"a\":\n            encoded += \"T\"\n          \
    \  \n        case \"b\":\n            encoded += \"G\"\n            \n       \
    \ case \"c\":\n            encoded += \"C\"\n            \n        case \"d\"\
    :\n            encoded += \"Y\"\n            \n        case \"e\":\n         \
    \   encoded += \"S\"\n            \n        case \"f\":\n            encoded +=\
    \ \"G\"\n            \n        case \"g\":\n            encoded += \"C\"\n   \
    \         \n        case \"h\":\n            encoded += \"K\"\n            \n\
    \        case \"i\":\n            encoded += \"M\"\n            \n        case\
    \ \"j\":\n            encoded += \"K\"\n            \n        case \"k\":\n  \
    \          encoded += \"K\"\n            \n        case \"l\":\n            encoded\
    \ += \"K\"\n            \n        case \"m\":\n            encoded += \"K\"\n\
    \            \n        case \"n\":\n            encoded += \"C\"\n           \
    \ \n        case \"o\":\n            encoded += \"C\"\n            \n        case\
    \ \"p\":\n            encoded += \"S\"\n            \n        case \"q\":\n  \
    \          encoded += \"G\"\n            \n        case \"r\":\n            encoded\
    \ += \"C\"\n            \n        case \"s\":\n            encoded += \"S\"\n\
    \            \n        case \"t\":\n            encoded += \"T\"\n           \
    \ \n        case \"u\":\n            encoded += \"S\"\n            \n        case\
    \ \"v\":\n            encoded += \"G\"\n            \n        case \"w\":\n  \
    \          encoded += \"C\"\n            \n        case \"x\":\n            encoded\
    \ += \"G\"\n            \n        case \"y\":\n            encoded += \"C\"\n\
    \            \n        case \"z\":\n            encoded += \"C\"\n           \
    \ \n        default:\n            \n            if isLetter(character) {\n   \
    \             \n                let currentPosition = countVowels(character)\n\
    \                \n                if currentPosition == 0 {\n               \
    \     \n                    encoded += character\n                    \n     \
    \           } else if currentPosition == 1 { //first vowel in the word\n     \
    \               \n                    let firstVowelPosition = currentPosition\
    \ - 1\n                    \n                    let firstVowel = message[firstVowelPosition]\n\
    \                    \n                    let secondVowelPosition = currentPosition\
    \ + 2\n                    \n                    let secondVowel = message[secondVowelPosition]\n\
    \                    \n                    if firstVowel == secondVowel {\n  \
    \                      \n                        encoded += firstVow\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpes7j0cl_.swift:143:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpes7j0cl_.swift:111:48: note: to match this opening\
    \ '{'\n                } else if currentPosition == 1 { //first vowel in the word\n\
    \                                               ^\n/tmp/tmpes7j0cl_.swift:143:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpes7j0cl_.swift:103:36:\
    \ note: to match this opening '{'\n            if isLetter(character) {\n    \
    \                               ^\n/tmp/tmpes7j0cl_.swift:143:84: error: expected\
    \ '}' at end of 'switch' statement\nassert(encode(message: \"I DoNt KnOw WhAt\
    \ tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                            \
    \                                                       ^\n/tmp/tmpes7j0cl_.swift:18:26:\
    \ note: to match this opening '{'\n        switch character {\n              \
    \           ^\n/tmp/tmpes7j0cl_.swift:143:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmpes7j0cl_.swift:16:30: note: to match\
    \ this opening '{'\n    for character in message {\n                         \
    \    ^\n/tmp/tmpes7j0cl_.swift:143:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpes7j0cl_.swift:12:40: note: to match this opening\
    \ '{'\nfunc encode(message: String) -> String {\n                            \
    \           ^\n/tmp/tmpes7j0cl_.swift:103:16: error: cannot find 'isLetter' in\
    \ scope\n            if isLetter(character) {\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your\
    \ code here\n    if let messageCount = message.count {\n        let result = \"\
    \"\n        for i in 0..<messageCount {\n            let currentCharacter = message[i]\n\
    \            let nextCharacter = message[i+1]\n\n            if currentCharacter.isUppercase\
    \ {\n                result += nextCharacter.uppercaseString\n            } else\
    \ if currentCharacter.isLowercase {\n                result += nextCharacter.lowercaseString\n\
    \            } else {\n                result += currentCharacter\n          \
    \  }\n        }\n        return result\n    } else {\n        return message\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpjrecs3d7.swift:17:36: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            let currentCharacter\
    \ = message[i]\n                                   ^~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpjrecs3d7.swift:18:33:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            let nextCharacter = message[i+1]\n\
    \                                ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpjrecs3d7.swift:21:41: error: value\
    \ of type 'Character' has no member 'uppercaseString'\n                result\
    \ += nextCharacter.uppercaseString\n                          ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpjrecs3d7.swift:23:41: error: value of type 'Character' has no member 'lowercaseString'\n\
    \                result += nextCharacter.lowercaseString\n                   \
    \       ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpjrecs3d7.swift:25:24: error: left\
    \ side of mutating operator isn't mutable: 'result' is a 'let' constant\n    \
    \            result += currentCharacter\n                ~~~~~~ ^\n/tmp/tmpjrecs3d7.swift:15:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let result = \"\"\n\
    \        ^~~\n        var\n/tmp/tmpjrecs3d7.swift:25:24: error: binary operator\
    \ '+=' cannot be applied to operands of type 'String' and 'Character'\n      \
    \          result += currentCharacter\n                       ^\nSwift.RangeReplaceableCollection:4:35:\
    \ note: candidate requires that 'Character' conform to 'Sequence' (requirement\
    \ specified as 'Other' : 'Sequence')\n    @inlinable public static func += <Other>(lhs:\
    \ inout Self, rhs: Other) where Other : Sequence, Self.Element == Other.Element\n\
    \                                  ^\n/tmp/tmpjrecs3d7.swift:14:8: error: initializer\
    \ for conditional binding must hav"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    let vowels = [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"]\n\n    for (index,\
    \ char) in message.characters {\n        if let vowelIndex = vowels.indexOf(char)\
    \ {\n            let aChar = String(vowels[vowelIndex+1])\n            let bChar\
    \ = String(vowels[vowelIndex-1])\n\n            let letterIndex = index(of: aChar)!\n\
    \            let letterIndex = index(of: bChar)!\n            let newChar = String(vowels[letterIndex])\n\
    \            result += newChar\n        }\n        else {\n            let letterIndex\
    \ = index(of: char)!\n            let newChar = String(vowels[letterIndex])\n\
    \            result += newChar\n        }\n    }\n\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpo7c6eucl.swift:16:34: error: tuple pattern cannot match values\
    \ of non-tuple type 'Character'\n    for (index, char) in message.characters {\n\
    \                                 ^\n/tmp/tmpo7c6eucl.swift:17:36: error: value\
    \ of type '[String]' has no member 'indexOf'\n        if let vowelIndex = vowels.indexOf(char)\
    \ {\n                            ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message\n        .map{ $0.lowercased() }\n        .map{ $0.replaceAll(\"a\"\
    , \"t\") }\n        .map{ $0.replaceAll(\"e\", \"h\") }\n        .map{ $0.replaceAll(\"\
    i\", \"k\") }\n        .map{ $0.replaceAll(\"o\", \"s\") }\n        .map{ $0.replaceAll(\"\
    u\", \"g\") }\n        .map{ $0.replaceAll(\"w\", \"w\") }\n        .map{ $0.replaceAll(\"\
    y\", \"k\") }\n        .map{ $0.replaceAll(\"b\", \"g\") }\n        .map{ $0.replaceAll(\"\
    l\", \"s\") }\n        .map{ $0.replaceAll(\"n\", \"k\") }\n        .map{ $0.replaceAll(\"\
    m\", \"c\") }\n        .map{ $0.replaceAll(\"s\", \"y\") }\n        .map{ $0.replaceAll(\"\
    c\", \"h\") }\n        .map{ $0.replaceAll(\"g\", \"s\") }\n        .map{ $0.replaceAll(\"\
    h\", \"k\") }\n        .map{ $0.replaceAll(\"k\", \"h\") }\n        .map{ $0.replaceAll(\"\
    d\", \"k\") }\n        .map{ $0.replaceAll(\"g\", \"s\") }\n        .map{ $0.replaceAll(\"\
    t\", \"a\") }\n        .map{ $0.replaceAll(\"j\", \"t\") }\n        .map{ $0.replaceAll(\"\
    z\", \"z\") }\n        .map{ $0.replaceAll(\"x\", \"g\") }\n        .map{ $0.replaceAll(\"\
    v\", \"g\") }\n        .map{ $0.replaceAll(\"z\", \"s\") }\n        .map{ $0.replaceAll(\"\
    z\", \"z\") }\n        .map{ $0.replaceAll(\"y\", \"s\") }\n        .map{ $0.replaceAll(\"\
    g\", \"t\") }\n        .map{ $0.replaceAll(\"s\", \"h\") }\n        .map{ $0.replaceAll(\"\
    c\", \"h\") }\n        .map{ $0.replaceAll(\"g\", \"s\") }\n        .map{ $0.replaceAll(\"\
    z\", \"t\") }\n        .map{ $0.replaceAll(\"d\", \"k\") }\n        .map{ $0.replaceAll(\"\
    g\", \"s\") }\n        .map{ $0.replaceAll(\"d\", \"h\") }\n        .map{ $0.replaceAll(\"\
    w\", \"w\") }\n        .map{ $0.replaceAll(\"y\", \"k\") }\n        .map{ $0.replaceAll(\"\
    a\", \"t\") }\n        .map\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpykswa7fp.swift:13:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return message\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978969
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encodedMessage\
    \ = \"\"\n\n    for symbol in message {\n        // Get the index of this symbol\
    \ in the english alphabet. \n        // If this symbol is not in the english alphabet,\
    \ \n        // move on to the next symbol. \n        let index = alphabet.index(of:\
    \ symbol)\n        if index == nil {\n            continue\n        }\n\n    \
    \    // If this symbol is a vowel, move on to the next symbol.\n        if symbol.isUppercase\
    \ {\n            encodedMessage += symbol\n            continue\n        }\n\n\
    \        // If this symbol is a lowercase letter, move on to the next symbol.\n\
    \        if symbol.isLowercase {\n            // If this symbol is before or at\
    \ the same index as this symbol\n            // on a vowel, then move on to the\
    \ next symbol.\n            if index == alphabet.index(of: symbol) {\n       \
    \         continue\n            }\n\n            // If this symbol is at the index\
    \ of this symbol on a vowel, \n            // then encode this symbol by swapping\
    \ case.\n            if alphabet[index!].isUppercase {\n                encodedMessage\
    \ += symbol\n                continue\n            }\n\n            // If this\
    \ symbol is at the index of this symbol on a lowercase \n            // letter,\
    \ encode this symbol by swapping case.\n            if alphabet[index!].isLowercase\
    \ {\n                encodedMessage += alphabet[index!]\n                continue\n\
    \            }\n        }\n\n        // If this symbol is neither a vowel nor\
    \ lowercase letter,\n        // move on to the next symbol.\n        encodedMessage\
    \ += symbol\n    }\n\n    return encodedMessage\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpboy2vop3.swift:19:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: symbol)\n                    ^~~~~~~~\n\
    /tmp/tmpboy2vop3.swift:26:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            encodedMessage += symbol\n \
    \                             ^\n/tmp/tmpboy2vop3.swift:34:25: error: cannot find\
    \ 'alphabet' in scope\n            if index == alphabet.index(of: symbol) {\n\
    \                        ^~~~~~~~\n/tmp/tmpboy2vop3.swift:40:16: error: cannot\
    \ find 'alphabet' in scope\n            if alphabet[index!].isUppercase {\n  \
    \             ^~~~~~~~\n/tmp/tmpboy2vop3.swift:41:35: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                encodedMessage\
    \ += symbol\n                                  ^\n/tmp/tmpboy2vop3.swift:47:16:\
    \ error: cannot find 'alphabet' in scope\n            if alphabet[index!].isLowercase\
    \ {\n               ^~~~~~~~\n/tmp/tmpboy2vop3.swift:48:35: error: cannot find\
    \ 'alphabet' in scope\n                encodedMessage += alphabet[index!]\n  \
    \                                ^~~~~~~~\n/tmp/tmpboy2vop3.swift:55:27: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        encodedMessage += symbol\n                          ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Write\
    \ your code here\n    if message.isEmpty {\n        return \"\"\n    }\n    var\
    \ enc = \"\"\n    var prevLetter = \"\"\n    for char in message {\n        if\
    \ char.isLetter() {\n            if prevLetter.isUpper() {\n                enc\
    \ += char.lowercaseString()\n            } else {\n                enc += char.uppercaseString()\n\
    \            }\n        } else if char.isVowel() {\n            enc += char.lowercaseString()\n\
    \        } else {\n            enc += char\n        }\n        prevLetter = char\n\
    \    }\n    return enc\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpzzna1usr.swift:20:17: error: cannot call value of non-function\
    \ type 'Bool'\n        if char.isLetter() {\n                ^       ~~\n    \
    \                    \n/tmp/tmpzzna1usr.swift:21:27: error: value of type 'String'\
    \ has no member 'isUpper'\n            if prevLetter.isUpper() {\n           \
    \    ~~~~~~~~~~ ^~~~~~~\n/tmp/tmpzzna1usr.swift:22:29: error: value of type 'Character'\
    \ has no member 'lowercaseString'\n                enc += char.lowercaseString()\n\
    \                       ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpzzna1usr.swift:24:29: error:\
    \ value of type 'Character' has no member 'uppercaseString'\n                enc\
    \ += char.uppercaseString()\n                       ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpzzna1usr.swift:26:24:\
    \ error: value of type 'Character' has no member 'isVowel'\n        } else if\
    \ char.isVowel() {\n                  ~~~~ ^~~~~~~\n/tmp/tmpzzna1usr.swift:27:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \   enc += char.lowercaseString()\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpzzna1usr.swift:29:20:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            enc += char\n                   ^\n/tmp/tmpzzna1usr.swift:31:22:\
    \ error: cannot assign value of type 'Character' to type 'String'\n        prevLetter\
    \ = char\n                     ^~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = [Character]()\n    for char in message {\n        switch char {\n        case\
    \ \"a\":\n            result.append(\"b\")\n        case \"e\":\n            result.append(\"\
    f\")\n        case \"i\":\n            result.append(\"g\")\n        case \"o\"\
    :\n            result.append(\"h\")\n        case \"u\":\n            result.append(\"\
    j\")\n        case \"y\":\n            result.append(\"k\")\n        default:\n\
    \            result.append(char)\n        }\n    }\n    var result = ArraySlice(result).map({\
    \ String($0) })\n    let newMessage = result.joinWithSeparator(\"\")\n    return\
    \ newMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp3i5nhs3h.swift:32:9: error: invalid redeclaration of 'result'\n\
    \    var result = ArraySlice(result).map({ String($0) })\n        ^\n/tmp/tmp3i5nhs3h.swift:13:9:\
    \ note: 'result' previously declared here\n    var result = [Character]()\n  \
    \      ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.\n        characters.\n        map { String($0) }.\n        map({ \n\
    \            let x = Int($0);\n            let y = x % 2\n            let z =\
    \ (x - (y ?? 0)) / 2\n            return (y ? \"T\" : \"F\") + (z ? \"H\" : \"\
    M\")\n        }).\n        joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgu2upihi.swift:13:19: error: expected member name following '.'\n\
    \    return message.\n                  ^\n/tmp/tmpgu2upihi.swift:14:19: error:\
    \ expected member name following '.'\n        characters.\n                  ^\n\
    /tmp/tmpgu2upihi.swift:15:27: error: expected member name following '.'\n    \
    \    map { String($0) }.\n                          ^\n/tmp/tmpgu2upihi.swift:21:11:\
    \ error: expected member name following '.'\n        }).\n          ^\n/tmp/tmpgu2upihi.swift:22:9:\
    \ error: cannot find 'joined' in scope\n        joined()\n        ^~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let map\
    \ = [\n        \"A\": \"A\",\n        \"A\": \"B\",\n        \"A\": \"C\",\n \
    \       \"A\": \"D\",\n        \"A\": \"E\",\n        \"A\": \"F\",\n        \"\
    A\": \"G\",\n        \"A\": \"H\",\n        \"A\": \"I\",\n        \"A\": \"J\"\
    ,\n        \"A\": \"K\",\n        \"A\": \"L\",\n        \"A\": \"M\",\n     \
    \   \"A\": \"N\",\n        \"A\": \"O\",\n        \"A\": \"P\",\n        \"A\"\
    : \"Q\",\n        \"A\": \"R\",\n        \"A\": \"S\",\n        \"A\": \"T\",\n\
    \        \"A\": \"U\",\n        \"A\": \"V\",\n        \"A\": \"W\",\n       \
    \ \"A\": \"X\",\n        \"A\": \"Y\",\n        \"A\": \"Z\",\n        \"B\":\
    \ \"B\",\n        \"B\": \"C\",\n        \"B\": \"D\",\n        \"B\": \"E\",\n\
    \        \"B\": \"F\",\n        \"B\": \"G\",\n        \"B\": \"H\",\n       \
    \ \"B\": \"I\",\n        \"B\": \"J\",\n        \"B\": \"K\",\n        \"B\":\
    \ \"L\",\n        \"B\": \"M\",\n        \"B\": \"N\",\n        \"B\": \"O\",\n\
    \        \"B\": \"P\",\n        \"B\": \"Q\",\n        \"B\": \"R\",\n       \
    \ \"B\": \"S\",\n        \"B\": \"T\",\n        \"B\": \"U\",\n        \"B\":\
    \ \"V\",\n        \"B\": \"W\",\n        \"B\": \"X\",\n        \"B\": \"Y\",\n\
    \        \"B\": \"Z\",\n        \"C\": \"C\",\n        \"C\": \"D\",\n       \
    \ \"C\": \"E\",\n        \"C\": \"F\",\n        \"C\": \"G\",\n        \"C\":\
    \ \"H\",\n        \"C\": \"I\",\n        \"C\": \"J\",\n        \"C\": \"K\",\n\
    \        \"C\": \"L\",\n        \"C\": \"M\",\n        \"C\": \"N\",\n       \
    \ \"C\": \"O\",\n        \"C\": \"P\",\n        \"C\": \"Q\",\n        \"C\":\
    \ \"R\",\n        \"C\": \"S\",\n        \"C\": \"T\",\n        \"C\": \"U\",\n\
    \        \"C\": \"V\",\n        \"C\": \"W\",\n        \"C\": \"X\",\n       \
    \ \"C\": \"Y\",\n        \"C\": \"Z\",\n        \"D\": \"D\",\n        \"D\":\
    \ \"E\",\n        \"D\": \"F\",\n        \"D\": \"G\",\n        \"D\": \"H\",\n\
    \        \"D\": \"I\",\n        \"D\": \"J\",\n        \"D\": \"K\",\n       \
    \ \"D\": \"L\",\n        \"D\": \"M\",\n        \"D\": \"N\",\n        \"D\":\
    \ \"O\",\n        \"D\": \"P\",\n        \"D\": \"Q\",\n        \"D\": \"R\",\n\
    \        \"D\": \"S\",\n        \"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpse4ja0gg.swift:105:9: error: unterminated string literal\n    \
    \    \"\n        ^\n/tmp/tmpse4ja0gg.swift:13:9: warning: initialization of immutable\
    \ value 'map' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let map = [\n    ~~~~^~~\n    _\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    return\
    \ message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmp8ph5asbp/tmp8ph5asbp.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7cb431bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7cb4012b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7cb4012988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7cb40117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8ph5asbp                        0x0000563b78d02307 <unavailable> + 4871

    5    libc.so.6                          0x00002b7cb4507460 __libc_start_main +
    245

    6    tmp8ph5asbp                        0x0000563b78d01f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.characters.map {\n        letter in letter.lowercaseString.characters.map\
    \ {\n            if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter\
    \ == \"o\" {\n                letter = letter + \"b\"\n            }\n       \
    \     if letter == \"u\" || letter == \"i\" || letter == \"o\" {\n           \
    \     letter = letter + \"v\"\n            }\n            if letter == \"a\" ||\
    \ letter == \"e\" || letter == \"i\" || letter == \"o\" {\n                letter\
    \ = letter + \"h\"\n            }\n            if letter == \"u\" || letter ==\
    \ \"i\" || letter == \"o\" {\n                letter = letter + \"j\"\n      \
    \      }\n            if letter == \"u\" || letter == \"i\" || letter == \"o\"\
    \ {\n                letter = letter + \"s\"\n            }\n            return\
    \ letter\n        }.joined()\n    }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpb4m4ev50.swift:14:26: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'lowercaseString'\n        letter in letter.lowercaseString.characters.map\
    \ {\n                  ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpb4m4ev50.swift:16:17: error:\
    \ cannot assign to value: 'letter' is a 'let' constant\n                letter\
    \ = letter + \"b\"\n                ^~~~~~\n/tmp/tmpb4m4ev50.swift:16:26: error:\
    \ cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n                letter = letter + \"b\"\n          \
    \               ^\n/tmp/tmpb4m4ev50.swift:16:33: error: cannot assign value of\
    \ type 'String' to type 'String.Element' (aka 'Character')\n                letter\
    \ = letter + \"b\"\n                         ~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encString\
    \ = \"\"\n    for _ in message.unicodeScalars {\n        switch self {\n     \
    \   case .vowel:\n            encString = encString + String.UnicodeScalarView(message)\n\
    \        case .consonant:\n            switch {\n            case (encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) == (encString.unicodeScalars.endIndex - 1)) && encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) != 0\n                || (encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) != (encString.unicodeScalars.endIndex - 1)) && encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) == 0\n                || (encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) != (encString.unicodeScalars.endIndex - 1)) && encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) == (encString.unicodeScalars.endIndex - 1)\n          \
    \      || (encString.unicodeScalars.index(of: unicodeScalar.vowel) != (encString.unicodeScalars.endIndex\
    \ - 1)) && encString.unicodeScalars.index(of: unicodeScalar.vowel) != (encString.unicodeScalars.endIndex\
    \ - 2)\n            , let index = encString.unicodeScalars.index(of: unicodeScalar.vowel)\
    \ {\n                encString = encString + String.UnicodeScalarView(message)[index]\n\
    \            }\n            default:\n                encString = encString +\
    \ String.UnicodeScalarView(message)\n            }\n        }\n    }\n    return\
    \ encString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp73ni1a3b.swift:19:20: error: expected expression in 'switch' statement\n\
    \            switch {\n                   ^\n/tmp/tmp73ni1a3b.swift:24:19: error:\
    \ 'index' must be bound in every pattern\n            , let index = encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) {\n                  ^\n/tmp/tmp73ni1a3b.swift:24:25: error:\
    \ expected ':' after 'case'\n            , let index = encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) {\n                        ^\n/tmp/tmp73ni1a3b.swift:24:25:\
    \ error: expected expression\n            , let index = encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) {\n                        ^\n/tmp/tmp73ni1a3b.swift:15:16:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n        switch self {\n               ^~~~\n/tmp/tmp73ni1a3b.swift:17:35:\
    \ error: operator function '+' requires the types 'String.Element' (aka 'Character')\
    \ and 'Unicode.Scalar' be equivalent\n            encString = encString + String.UnicodeScalarView(message)\n\
    \                                  ^\nSwift.RangeReplaceableCollection:5:35: note:\
    \ where 'Self.Element' = 'String.Element' (aka 'Character'), 'Other.Element' =\
    \ 'Unicode.Scalar'\n    @inlinable public static func + <Other>(lhs: Self, rhs:\
    \ Other) -> Self where Other : RangeReplaceableCollection, Self.Element == Other.Element\n\
    \                                  ^\n/tmp/tmp73ni1a3b.swift:17:37: error: initializer\
    \ 'init(_:)' requires the types 'Unicode.Scalar' and 'String.Element' (aka 'Character')\
    \ be equivalent\n            encString = encString + String.UnicodeScalarView(message)\n\
    \                                    ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: where 'Self.Element' = 'Unicode.Scalar', 'S.Element' = 'String.Element'\
    \ (aka 'Character')\n    @inlinable public init<S>(_ elements: S) where S : Sequence,\
    \ Self.Element == S.Element\n                      ^\n/tmp/tmp73ni1a3b.swift:28:39:\
    \ error: operator function '+' requires the types 'String.Element' (aka 'Character')\
    \ and 'Unicode.Scalar' be equivalent\n             "
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tlet vowels\
    \ = \"aeiouAEIOU\".makeIterator()\n\n\tlet indexes = (0..<message.characters.count).filter\
    \ { message[$0] == nil }\n\tvar encodedMessage = \"\"\n\n\tfor index in indexes\
    \ {\n\t\tlet currentChar = message[index]\n\n\t\tlet nextChar = vowels.next().element\
    \ ?? currentChar\n\n\t\tif currentChar == nextChar {\n\t\t\tencodedMessage +=\
    \ nextChar\n\t\t} else {\n\t\t\tencodedMessage += String(Int(nextChar) - Int(currentChar))\n\
    \t\t}\n\t}\n\n\treturn encodedMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp7u0o1f7i.swift:15:68: warning: comparing non-optional value of\
    \ type 'Character' to 'nil' always returns false\n        let indexes = (0..<message.characters.count).filter\
    \ { message[$0] == nil }\n                                                   \
    \           ~~~~~~~~~~~ ^  ~~~\n/tmp/tmp7u0o1f7i.swift:15:29: error: 'characters'\
    \ is unavailable: Please use String directly\n        let indexes = (0..<message.characters.count).filter\
    \ { message[$0] == nil }\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp7u0o1f7i.swift:15:56: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let indexes = (0..<message.characters.count).filter { message[$0] ==\
    \ nil }\n                                                              ^~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7u0o1f7i.swift:19:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let currentChar = message[index]\n\
    \                                  ^~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp7u0o1f7i.swift:21:25: error: cannot\
    \ use mutating member on immutable value: 'vowels' is a 'let' constant\n     \
    \           let nextChar = vowels.next().element ?? currentChar\n            \
    \                   ~~~~~~ ^\n/tmp/tmp7u0o1f7i.swift:13:2: note: change 'let'\
    \ to 'var' to make it mutable\n        let vowels = \"aeiouAEIOU\".makeIterator()\n\
    \        ^~~\n        var\n/tmp/tmp7u0o1f7i.swift:21:32: error: value of type\
    \ 'Character?' has no member 'element'\n                let nextChar = vowels.next().element\
    \ ?? currentChar\n                               ~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp7u0o1f7i.s"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result:\
    \ String = \"\"\n    var lastLetter = \"\"\n    for letter in message {\n    \
    \    if letter.isUppercase {\n            if lastLetter == letter {\n        \
    \        // first letter is a capital, keep it\n                result += \"A\"\
    \ + lastLetter\n            } else {\n                // first letter isn't a\
    \ capital, keep it\n                result += \"a\" + lastLetter\n           \
    \ }\n        } else {\n            if lastLetter == letter {\n               \
    \ // last letter is a capital, keep it\n                result += letter\n   \
    \         } else {\n                // last letter isn't a capital, keep it\n\
    \                result += letter + lastLetter\n            }\n        }\n   \
    \     lastLetter = letter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ipeadyu.swift:17:27: error: binary operator '==' cannot be applied\
    \ to operands of type 'String' and 'Character'\n            if lastLetter == letter\
    \ {\n               ~~~~~~~~~~ ^  ~~~~~~\n/tmp/tmp0ipeadyu.swift:17:27: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if lastLetter == letter {\n      \
    \                    ^\n/tmp/tmp0ipeadyu.swift:25:27: error: binary operator '=='\
    \ cannot be applied to operands of type 'String' and 'Character'\n           \
    \ if lastLetter == letter {\n               ~~~~~~~~~~ ^  ~~~~~~\n/tmp/tmp0ipeadyu.swift:25:27:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if lastLetter == letter\
    \ {\n                          ^\n/tmp/tmp0ipeadyu.swift:27:27: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \           result += letter\n                          ^\n/tmp/tmp0ipeadyu.swift:30:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += letter + lastLetter\n                          ^\n\
    /tmp/tmp0ipeadyu.swift:33:22: error: cannot assign value of type 'Character' to\
    \ type 'String'\n        lastLetter = letter\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var msgArr\
    \ = message.characters\n    \n    func isVowel(c: unichar) -> Bool {\n       \
    \ var iArr = c.unicodeScalars\n        for u in iArr {\n            switch u.scalarValue\
    \ {\n            case 0x2BC: // yes this is really a vowel\n                return\
    \ true\n            case 0x2D0: // 0\n            case 0x2D9: // 9\n         \
    \       return false\n            default:\n                break\n          \
    \  }\n        }\n        return false\n    }\n    \n    func encodeWithLettersBehindVowels(c1:\
    \ unichar, c2: unichar) -> unichar {\n        switch c1 {\n        case 0x30A0:\
    \ // Zero width joiner\n            return c2\n        case 0x30F0: // Latin small\
    \ letter z\n            return 0x2D0\n        case 0x30A1: // Zero width non-joiner\n\
    \            return 0x2D9\n        default:\n            return c1\n        }\n\
    \    }\n    \n    func encode(char: unichar) -> unichar {\n        switch char\
    \ {\n        case 0x30F0: // Latin small letter z\n            return 0x2D0\n\
    \        case 0x30A1: // Zero width non-joiner\n            return 0x2D9\n   \
    \     case 0x30A0: // Zero width joiner\n            return 0x2D0\n        default:\n\
    \            return char\n        }\n    }\n    \n    func encodeWithLettersBeforeVowels(char1:\
    \ unichar) -> unichar {\n        switch char1 {\n        case 0x30F0: // Latin\
    \ small letter z\n            return 0x2D0\n        case 0x30A1: // Zero width\
    \ non-joiner\n            return 0x2D9\n        case 0x30A0: // Zero width joiner\n\
    \            return 0x2D0\n        default:\n            return char1\n      \
    \  }\n    }\n    \n    func encodeWithLettersAfterVowels(char1: unichar) -> unichar\
    \ {\n        switch char1 {\n        case 0x30F0: // Latin small letter z\n  \
    \          return 0x2D0\n        case 0x30A1: // Zero width non-joiner\n     \
    \       return 0x2D9\n        case 0x30A0: // Zero width joiner\n            return\
    \ 0x2D0\n        default:\n            return char1\n        }\n    }\n    \n\
    \    func encodeWithLettersBeforeVowelsAndLettersAfterVowels(char1: unichar, char2:\
    \ unichar) -> unichar {\n        switch char1 {\n        case 0x30F0: // Latin\
    \ small letter z\n            return 0x2D0\n        case \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpu3mvdwj4.swift:21:13: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n            case 0x2D0: // 0\n          \
    \  ^~~~~~~~~~~\n                        break\n/tmp/tmpu3mvdwj4.swift:87:13: error:\
    \ expected pattern\n        case \n            ^\n/tmp/tmpu3mvdwj4.swift:87:13:\
    \ error: expected ':' after 'case'\n        case \n            ^\n/tmp/tmpu3mvdwj4.swift:107:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpu3mvdwj4.swift:83:104:\
    \ note: to match this opening '{'\n    func encodeWithLettersBeforeVowelsAndLettersAfterVowels(char1:\
    \ unichar, char2: unichar) -> unichar {\n                                    \
    \                                                                   ^\n/tmp/tmpu3mvdwj4.swift:107:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpu3mvdwj4.swift:12:40:\
    \ note: to match this opening '{'\nfunc encode(message: String) -> String {\n\
    \                                       ^\n/tmp/tmpu3mvdwj4.swift:13:26: error:\
    \ 'characters' is unavailable: Please use String directly\n    var msgArr = message.characters\n\
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpu3mvdwj4.swift:15:21: error: cannot find type 'unichar'\
    \ in scope\n    func isVowel(c: unichar) -> Bool {\n                    ^~~~~~~\n\
    /tmp/tmpu3mvdwj4.swift:31:69: error: cannot find type 'unichar' in scope\n   \
    \ func encodeWithLettersBehindVowels(c1: unichar, c2: unichar) -> unichar {\n\
    \                                                                    ^~~~~~~\n\
    /tmp/tmpu3mvdwj4.swift:31:44: error: cannot find type 'unichar' in scope\n   \
    \ func encodeWithLettersBehindVowels(c1:"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    guard let\
    \ letters = message.characters\n        else { return \"\" }\n    let vowels =\
    \ CharacterSet.vowels\n    return String(\n        letters.map { character in\n\
    \            let upperCasedCharacter = Character(character).uppercased()\n   \
    \         let i = vowels.index(of: upperCasedCharacter)!\n            let doubleVowels\
    \ = Character(characters.suffix(from: i)!).uppercased()\n            return upperCasedCharacter\
    \ + doubleVowels\n        }\n    )\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpabajlxlu.swift:13:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let letters = message.characters\n          \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpabajlxlu.swift:13:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let letters = message.characters\n\
    \          ^             ~~~~~~~~~~~~~~~~~~\n/tmp/tmpabajlxlu.swift:15:18: error:\
    \ cannot find 'CharacterSet' in scope\n    let vowels = CharacterSet.vowels\n\
    \                 ^~~~~~~~~~~~\n/tmp/tmpabajlxlu.swift:20:42: error: cannot find\
    \ 'characters' in scope\n            let doubleVowels = Character(characters.suffix(from:\
    \ i)!).uppercased()\n                                         ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encodedString\
    \ = \"\"\n    for i in 0..<message.characters.count {\n        let char = message.characters[i]\n\
    \        let vowelIndex = Character.ascii(char)\n        if vowelIndex != 0 ||\
    \ i != 0 {\n            encodedString += String(char)\n            continue\n\
    \        }\n        let lowerChar = String(char).lowercased()\n        let lowerIndex2\
    \ = Character.ascii(lowerChar)\n        let vowelIndex2 = Character.ascii(char.lowercased())\n\
    \        switch vowelIndex {\n        case vowelIndex2, vowelIndex + 1:\n    \
    \        encodedString += String(char)\n        case vowelIndex + 2:\n       \
    \     encodedString += String(lowerChar)\n        default:\n            encodedString\
    \ += String(char.lowercased())\n        }\n    }\n    return encodedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmplehirbbm.swift:14:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<message.characters.count {\n         \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplehirbbm.swift:15:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = message.characters[i]\n                   ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplehirbbm.swift:15:28:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = message.characters[i]\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmplehirbbm.swift:16:36: error: type 'Character'\
    \ has no member 'ascii'\n        let vowelIndex = Character.ascii(char)\n    \
    \                     ~~~~~~~~~ ^~~~~\n/tmp/tmplehirbbm.swift:22:37: error: type\
    \ 'Character' has no member 'ascii'\n        let lowerIndex2 = Character.ascii(lowerChar)\n\
    \                          ~~~~~~~~~ ^~~~~\n/tmp/tmplehirbbm.swift:23:37: error:\
    \ type 'Character' has no member 'ascii'\n        let vowelIndex2 = Character.ascii(char.lowercased())\n\
    \                          ~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encodedMessage\
    \ = \"\"\n    for character in message {\n        let index = alphabet.index(of:\
    \ character)\n        switch character {\n        case \"a\":\n            encodedMessage\
    \ += \"B\"\n        case \"b\":\n            encodedMessage += \"b\"\n       \
    \ case \"c\":\n            encodedMessage += \"C\"\n        case \"d\":\n    \
    \        encodedMessage += \"D\"\n        case \"e\":\n            encodedMessage\
    \ += \"E\"\n        case \"f\":\n            encodedMessage += \"F\"\n       \
    \ case \"g\":\n            encodedMessage += \"G\"\n        case \"h\":\n    \
    \        encodedMessage += \"H\"\n        case \"i\":\n            encodedMessage\
    \ += \"I\"\n        case \"j\":\n            encodedMessage += \"J\"\n       \
    \ case \"k\":\n            encodedMessage += \"K\"\n        case \"l\":\n    \
    \        encodedMessage += \"L\"\n        case \"m\":\n            encodedMessage\
    \ += \"M\"\n        case \"n\":\n            encodedMessage += \"N\"\n       \
    \ case \"o\":\n            encodedMessage += \"O\"\n        case \"p\":\n    \
    \        encodedMessage += \"P\"\n        case \"q\":\n            encodedMessage\
    \ += \"Q\"\n        case \"r\":\n            encodedMessage += \"R\"\n       \
    \ case \"s\":\n            encodedMessage += \"S\"\n        case \"t\":\n    \
    \        encodedMessage += \"T\"\n        case \"u\":\n            encodedMessage\
    \ += \"U\"\n        case \"v\":\n            encodedMessage += \"V\"\n       \
    \ case \"w\":\n            encodedMessage += \"W\"\n        case \"x\":\n    \
    \        encodedMessage += \"X\"\n        case \"y\":\n            encodedMessage\
    \ += \"Y\"\n        case \"z\":\n            encodedMessage += \"Z\"\n       \
    \ default:\n            encodedMessage += character\n        }\n    }\n    return\
    \ encodedMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp30gkq22o.swift:15:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.index(of: character)\n                    ^~~~~~~~\n\
    /tmp/tmp30gkq22o.swift:70:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            encodedMessage += character\n\
    \                              ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // TODO:\
    \ Complete this function.\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmplgtajaou/tmplgtajaou.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada08f96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada08c8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada08c8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada08c8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplgtajaou                        0x0000565263516307 <unavailable> + 4871

    5    libc.so.6                          0x00002ada09182460 __libc_start_main +
    245

    6    tmplgtajaou                        0x0000565263515f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.map { letter in \n        var first = letter.first\n        var second\
    \ = letter.first\n        var third = letter.first\n        \n        if letter\
    \ == first {\n            return letter\n        } else if letter == second {\n\
    \            first = letter.second\n            return first\n        } else if\
    \ letter == third {\n            second = letter.second\n            third = letter.second\n\
    \            return second\n        } else {\n            first = (first + second)\
    \ mod 26\n            second = (first + second) mod 26\n            third = (first\
    \ + second) mod 26\n            return String.fromCharCode(first+65) + String.fromCharCode(second+65)\
    \ + String.fromCharCode(third+65)\n        }\n    }.joinWithSeparator(\"\").capitalized\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpz3cd179g.swift:28:37: error: consecutive statements on a line must\
    \ be separated by ';'\n            first = (first + second) mod 26\n         \
    \                           ^\n                                    ;\n/tmp/tmpz3cd179g.swift:28:41:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \   first = (first + second) mod 26\n                                        ^\n\
    \                                        ;\n/tmp/tmpz3cd179g.swift:29:38: error:\
    \ consecutive statements on a line must be separated by ';'\n            second\
    \ = (first + second) mod 26\n                                     ^\n        \
    \                             ;\n/tmp/tmpz3cd179g.swift:29:42: error: consecutive\
    \ statements on a line must be separated by ';'\n            second = (first +\
    \ second) mod 26\n                                         ^\n               \
    \                          ;\n/tmp/tmpz3cd179g.swift:30:37: error: consecutive\
    \ statements on a line must be separated by ';'\n            third = (first +\
    \ second) mod 26\n                                    ^\n                    \
    \                ;\n/tmp/tmpz3cd179g.swift:30:41: error: consecutive statements\
    \ on a line must be separated by ';'\n            third = (first + second) mod\
    \ 26\n                                        ^\n                            \
    \            ;\n/tmp/tmpz3cd179g.swift:28:38: error: cannot find 'mod' in scope\n\
    \            first = (first + second) mod 26\n                               \
    \      ^~~\n/tmp/tmpz3cd179g.swift:29:39: error: cannot find 'mod' in scope\n\
    \            second = (first + second) mod 26\n                              \
    \        ^~~\n/tmp/tmpz3cd179g.swift:30:38: error: cannot find 'mod' in scope\n\
    \            third = (first + second) mod 26\n                               \
    \      ^~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\talphabetLetters.forEach\
    \ { (letter) in\n\t\tlet nextLetter = message[message.index(message.startIndex,\
    \ offsetBy: 1)].lowercased()\n\t\tswitch letter{\n\t\tcase \"a\",\"e\",\"i\",\"\
    o\",\"u\":\n\t\t\tlet nextVowel = message[message.index(message.startIndex, offsetBy:\
    \ 2)].lowercased()\n\t\t\tlet nextVowelIndex = alphabetLetters.firstIndex(of:\
    \ nextVowel)!\n\t\t\tlet newLetter = alphabetLetters[nextVowelIndex]\n\t\t\tlet\
    \ newLetterIndex = alphabetLetters.index(of: newLetter)!\n\t\t\tlet oldIndex =\
    \ message.index(message.startIndex, offsetBy: 0)\n\t\t\tlet newValue = String(message.characters.dropFirst().map\
    \ { $0 == \"a\" || $0 == \"e\" || $0 == \"i\" || $0 == \"o\" || $0 == \"u\" ?\
    \ (oldIndex + newLetterIndex + 2) : Character($0) })\n\t\t\tlet newMessage = newValue.trimmingCharacters(in:\
    \ .whitespaces)\n\t\t\tlet oldMessage = message\n\t\t\tmessage = newMessage\n\t\
    \t\tnextLetter = newLetter\n\t\t\tnextVowel = newVowel\n\t\tdefault:\n\t\t\tbreak\n\
    \t\t}\n\t}\n\treturn message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpbx4iiu8z.swift:13:2: error: cannot find 'alphabetLetters' in scope\n\
    \        alphabetLetters.forEach { (letter) in\n        ^~~~~~~~~~~~~~~\n/tmp/tmpbx4iiu8z.swift:18:25:\
    \ error: cannot find 'alphabetLetters' in scope\n                        let nextVowelIndex\
    \ = alphabetLetters.firstIndex(of: nextVowel)!\n                             \
    \                ^~~~~~~~~~~~~~~\n/tmp/tmpbx4iiu8z.swift:19:20: error: cannot\
    \ find 'alphabetLetters' in scope\n                        let newLetter = alphabetLetters[nextVowelIndex]\n\
    \                                        ^~~~~~~~~~~~~~~\n/tmp/tmpbx4iiu8z.swift:20:25:\
    \ error: cannot find 'alphabetLetters' in scope\n                        let newLetterIndex\
    \ = alphabetLetters.index(of: newLetter)!\n                                  \
    \           ^~~~~~~~~~~~~~~\n/tmp/tmpbx4iiu8z.swift:27:16: error: cannot find\
    \ 'newVowel' in scope\n                        nextVowel = newVowel\n        \
    \                            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encoded\
    \ = \"\"\n    for i in 0..<message.count {\n        var currentVowel = message[i]\n\
    \        if !isVowel(currentVowel) {\n            currentVowel = lowercaseLetters[(alphabet.indexOf(currentVowel)!\
    \ + 1)]\n        }\n        var nextVowel = message[i]\n        if isVowel(nextVowel)\
    \ {\n            nextVowel = lowercaseLetters[(alphabet.indexOf(nextVowel)! +\
    \ 1)]\n        }\n        var index = alphabet.indexOf(currentVowel)! + 1\n  \
    \      encoded = encoded.appending(\"\\(nextVowel)\", separator: \"\").appending(\"\
    \\(currentVowel)\", separator: \"\")\n    }\n    return encoded\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpw5jd8af7.swift:15:28: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        var currentVowel\
    \ = message[i]\n                           ^~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpw5jd8af7.swift:16:13: error:\
    \ cannot find 'isVowel' in scope\n        if !isVowel(currentVowel) {\n      \
    \      ^~~~~~~\n/tmp/tmpw5jd8af7.swift:17:28: error: cannot find 'lowercaseLetters'\
    \ in scope\n            currentVowel = lowercaseLetters[(alphabet.indexOf(currentVowel)!\
    \ + 1)]\n                           ^~~~~~~~~~~~~~~~\n/tmp/tmpw5jd8af7.swift:17:46:\
    \ error: cannot find 'alphabet' in scope\n            currentVowel = lowercaseLetters[(alphabet.indexOf(currentVowel)!\
    \ + 1)]\n                                             ^~~~~~~~\n/tmp/tmpw5jd8af7.swift:19:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        var nextVowel = message[i]\n          \
    \              ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpw5jd8af7.swift:20:12: error: cannot find 'isVowel' in scope\n\
    \        if isVowel(nextVowel) {\n           ^~~~~~~\n/tmp/tmpw5jd8af7.swift:21:25:\
    \ error: cannot find 'lowercaseLetters' in scope\n            nextVowel = lowercaseLetters[(alphabet.indexOf(nextVowel)!\
    \ + 1)]\n                        ^~~~~~~~~~~~~~~~\n/tmp/tmpw5jd8af7.swift:21:43:\
    \ error: cannot find 'alphabet' in scope\n            nextVowel = lowercaseLetters[(alphabet.indexOf(nextVowel)!\
    \ + 1)]\n                                          ^~~~~~~~\n/tmp/tmpw5jd8af7.swift:23:21:\
    \ error: cannot find 'alphabet' in scope\n        var index = alphabet.indexOf(currentVowel)!\
    \ + 1\n                    ^~~~~~~~\n/tmp/tmpw5jd8af7.swift:24:27: error: value\
    \ of type 'String' has no member 'appending'\n        encoded = encoded.appending(\"\
    \\(nextVowel)\", s"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tlet messageArray\
    \ = message.characters\n\t\n\tlet vowel = \"A\" \n\t\n\tlet vowelIndex = messageArray.index(of:\
    \ vowel!)\n\t\n\tlet swapCaseArray = [ \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"\
    g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"\
    t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\t\n\tlet swapCaseIndex = swapCaseArray.index(of:\
    \ messageArray[vowelIndex!])!\n\n\treturn String(messageArray[vowelIndex!].stringByReplacingOccurrencesOfString(String(swapCaseArray[swapCaseIndex]),\
    \ withString: String(swapCaseArray[swapCaseIndex+1])!))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpdxeuz5ub.swift:13:29: error: 'characters' is unavailable: Please\
    \ use String directly\n        let messageArray = message.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdxeuz5ub.swift:17:47: error: cannot convert value of\
    \ type 'String' to expected argument type 'String.Element' (aka 'Character')\n\
    \        let vowelIndex = messageArray.index(of: vowel!)\n                   \
    \                                  ^\n/tmp/tmpdxeuz5ub.swift:17:47: error: cannot\
    \ force unwrap value of non-optional type 'String'\n        let vowelIndex = messageArray.index(of:\
    \ vowel!)\n                                                ~~~~~^\n          \
    \                                           \n/tmp/tmpdxeuz5ub.swift:21:46: error:\
    \ generic parameter 'R' could not be inferred\n        let swapCaseIndex = swapCaseArray.index(of:\
    \ messageArray[vowelIndex!])!\n                                              \
    \      ^\nSwift.String:5:12: note: in call to 'subscript(_:)'\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpdxeuz5ub.swift:23:136: error: missing argument label 'validatingUTF8:'\
    \ in call\n        return String(messageArray[vowelIndex!].stringByReplacingOccurrencesOfString(String(swapCaseArray[swapCaseIndex]),\
    \ withString: String(swapCaseArray[swapCaseIndex+1])!))\n                    \
    \                                                                            \
    \                                              ^\n                           \
    \                                                                            \
    \                                       validatingUTF8: \n/tmp/tmpdxeuz5ub.swift:23:42:\
    \ error: reference to member 'stringByReplacingOccurrencesOfString' cannot be\
    \ resolved without a contextual type\n        return String(messageArray[vowelIndex!].stringByReplacingOccurrencesOfString(String(swapCaseArray[swapCaseIndex]),\
    \ withString: String(swapC"
  stdout: ''
  timestamp: 1659978726
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    \n    for letter in message {\n        result += \"tHKS\"\n    \
    \    if letter == \"A\" {\n            result += \"a\"\n        } else if letter\
    \ == \"B\" {\n            result += \"b\"\n        } else if letter == \"C\" {\n\
    \            result += \"c\"\n        } else if letter == \"D\" {\n          \
    \  result += \"d\"\n        } else if letter == \"E\" {\n            result +=\
    \ \"e\"\n        } else if letter == \"F\" {\n            result += \"f\"\n  \
    \      } else if letter == \"G\" {\n            result += \"g\"\n        } else\
    \ if letter == \"H\" {\n            result += \"h\"\n        } else if letter\
    \ == \"I\" {\n            result += \"i\"\n        } else if letter == \"J\" {\n\
    \            result += \"j\"\n        } else if letter == \"K\" {\n          \
    \  result += \"k\"\n        } else if letter == \"L\" {\n            result +=\
    \ \"l\"\n        } else if letter == \"M\" {\n            result += \"m\"\n  \
    \      } else if letter == \"N\" {\n            result += \"n\"\n        } else\
    \ if letter == \"O\" {\n            result += \"o\"\n        } else if letter\
    \ == \"P\" {\n            result += \"p\"\n        } else if letter == \"Q\" {\n\
    \            result += \"q\"\n        } else if letter == \"R\" {\n          \
    \  result += \"r\"\n        } else if letter == \"S\" {\n            result +=\
    \ \"s\"\n        } else if letter == \"T\" {\n            result += \"t\"\n  \
    \      } else if letter == \"U\" {\n            result += \"u\"\n        } else\
    \ if letter == \"V\" {\n            result += \"v\"\n        } else if letter\
    \ == \"W\" {\n            result += \"w\"\n        } else if letter == \"X\" {\n\
    \            result += \"x\"\n        } else if letter == \"Y\" {\n          \
    \  result += \"y\"\n        } else if letter == \"Z\" {\n            result +=\
    \ \"z\"\n        } else {\n            result += letter\n        }\n    }\n  \
    \  \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp11522ik_.swift:70:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let countOfA:\
    \ String = \"a\".unicodeScalars.filter{$0.isUpper}.count\n    let countOfE: String\
    \ = \"e\".unicodeScalars.filter{$0.isUpper}.count\n    let countOfI: String =\
    \ \"i\".unicodeScalars.filter{$0.isUpper}.count\n    let countOfO: String = \"\
    o\".unicodeScalars.filter{$0.isUpper}.count\n    let countOfU: String = \"u\"\
    .unicodeScalars.filter{$0.isUpper}.count\n    let countOfIJKLMNOP: String = \"\
    ijklmnop\".unicodeScalars.filter{$0.isUpper}.count\n    let countOfBCDGHJKL: String\
    \ = \"bcdefghjkl\".unicodeScalars.filter{$0.isUpper}.count\n    \n    switch message\
    \ {\n    case \"a\":\n        return \"t\"\n    case \"b\":\n        return \"\
    b\"\n    case \"c\":\n        return \"k\"\n    case \"d\":\n        return \"\
    d\"\n    case \"e\":\n        return \"k\"\n    case \"f\":\n        return \"\
    m\"\n    case \"g\":\n        return \"g\"\n    case \"h\":\n        return \"\
    h\"\n    case \"i\":\n        return \"h\"\n    case \"j\":\n        return \"\
    h\"\n    case \"k\":\n        return \"k\"\n    case \"l\":\n        return \"\
    s\"\n    case \"m\":\n        return \"g\"\n    case \"n\":\n        return \"\
    g\"\n    case \"o\":\n        return \"c\"\n    case \"p\":\n        return \"\
    c\"\n    case \"q\":\n        return \"c\"\n    case \"r\":\n        return \"\
    c\"\n    case \"s\":\n        return \"gs\"\n    case \"t\":\n        return \"\
    t\"\n    case \"u\":\n        return \"u\"\n    case \"v\":\n        return \"\
    v\"\n    case \"w\":\n        return \"w\"\n    case \"x\":\n        return \"\
    x\"\n    case \"y\":\n        return \"y\"\n    case \"z\":\n        return \"\
    z\"\n    case \"A\":\n        return \"T\"\n    case \"B\":\n        return \"\
    B\"\n    case \"C\":\n        return \"K\"\n    case \"D\":\n        return \"\
    D\"\n    case \"E\":\n        return \"K\"\n    case \"F\":\n        return \"\
    M\"\n    case \"G\":\n        return \"G\"\n    case \"H\":\n        return \"\
    H\"\n    case \"I\":\n        return \"H\"\n    case \"J\":\n        return \"\
    H\"\n    case \"K\":\n        return \"K\"\n    case \"L\":\n        return \"\
    S\"\n    case \"M\":\n        return \"G\"\n    case \"N\":\n        return \"\
    G\"\n    case \"O\":\n        return \"C\"\n    case \"P\":\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpriqp3fsq.swift:104:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"P\":\n    ^~~~~~~~~\n        \
    \      break\n/tmp/tmpriqp3fsq.swift:125:84: error: expected '}' at end of brace\
    \ statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT\
    \ kNqW wHcT Tq wRkTg\")\n                                                    \
    \                               ^\n/tmp/tmpriqp3fsq.swift:12:40: note: to match\
    \ this opening '{'\nfunc encode(message: String) -> String {\n               \
    \                        ^\n/tmp/tmpriqp3fsq.swift:13:57: error: value of type\
    \ 'Unicode.Scalar' has no member 'isUpper'\n    let countOfA: String = \"a\".unicodeScalars.filter{$0.isUpper}.count\n\
    \                                                     ~~ ^~~~~~~\n/tmp/tmpriqp3fsq.swift:13:66:\
    \ error: cannot convert value of type 'Int' to specified type 'String'\n    let\
    \ countOfA: String = \"a\".unicodeScalars.filter{$0.isUpper}.count\n         \
    \                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmpriqp3fsq.swift:14:57:\
    \ error: value of type 'Unicode.Scalar' has no member 'isUpper'\n    let countOfE:\
    \ String = \"e\".unicodeScalars.filter{$0.isUpper}.count\n                   \
    \                                  ~~ ^~~~~~~\n/tmp/tmpriqp3fsq.swift:14:66: error:\
    \ cannot convert value of type 'Int' to specified type 'String'\n    let countOfE:\
    \ String = \"e\".unicodeScalars.filter{$0.isUpper}.count\n                   \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmpriqp3fsq.swift:15:57:\
    \ error: value of type 'Unicode.Scalar' has no member 'isUpper'\n    let countOfI:\
    \ String = \"i\".unicodeScalars.filter{$0.isUpper}.count\n                   \
    \                                  ~~ ^~~~~~~\n/tmp/tmpriqp3fsq.swift:15:66: error:\
    \ cannot convert value of type 'Int' to specified type 'String'\n    let countOfI:\
    \ String = \"i\".unicodeScalars.filter{$0.isUpper}.count\n                   \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmpriqp3fsq.swift:16:57:\
    \ error: value of type 'Unicode.Scalar' has no member 'isUpper'\n    le"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tlet alphabet\
    \ = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"\
    M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"\
    Z\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"\
    m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"\
    z\"]\n\tlet vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n\tlet replacedLetters =\
    \ [\n\t\t[\"e\", \"e\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"\
    a\", \"X\"], \n\t\t[\"o\", \"O\"], \n\t\t[\"i\", \"I\"], \n\t\t[\"u\", \"U\"],\
    \ \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"\
    u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"],\
    \ \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"\
    i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"],\
    \ \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"\
    o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"],\
    \ \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"\
    a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"],\
    \ \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"\
    u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"],\
    \ \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"\
    i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"],\
    \ \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"\
    o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"],\
    \ \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpy5uffeb8.swift:74:9: error: unterminated string literal\n     \
    \           [\"u\", \"\n                      ^\n/tmp/tmpy5uffeb8.swift:13:6:\
    \ warning: initialization of immutable value 'alphabet' was never used; consider\
    \ replacing with assignment to '_' or removing it\n        let alphabet = [\"\
    A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"\
    N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\"\
    a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"\
    n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\
    \        ~~~~^~~~~~~~\n        _\n/tmp/tmpy5uffeb8.swift:14:6: warning: initialization\
    \ of immutable value 'vowels' was never used; consider replacing with assignment\
    \ to '_' or removing it\n        let vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n\
    \        ~~~~^~~~~~\n        _\n/tmp/tmpy5uffeb8.swift:15:6: warning: initialization\
    \ of immutable value 'replacedLetters' was never used; consider replacing with\
    \ assignment to '_' or removing it\n        let replacedLetters = [\n        ~~~~^~~~~~~~~~~~~~~\n\
    \        _\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n\n    for c in message {\n        let achar = String.fromCharCode(toInt64(c))\n\
    \        let achar2 = String.fromCharCode(toInt64(c + 1))\n        var achar3\
    \ = achar.lowercased()\n        achar3.removeAll(\"aeiou\")\n        achar3 =\
    \ achar3.replaceAll(with: achar2)\n        achar3 = achar3.lowercased()\n    \
    \    achar3 = achar3.replaceAll(with: \"a\")\n        achar3 = achar3.replaceAll(with:\
    \ \"e\")\n        achar3 = achar3.replaceAll(with: \"i\")\n        achar3 = achar3.replaceAll(with:\
    \ \"o\")\n        achar3 = achar3.replaceAll(with: \"u\")\n        achar3 = achar3.replaceAll(with:\
    \ \"A\")\n        achar3 = achar3.replaceAll(with: \"E\")\n        achar3 = achar3.replaceAll(with:\
    \ \"I\")\n        achar3 = achar3.replaceAll(with: \"O\")\n        achar3 = achar3.replaceAll(with:\
    \ \"U\")\n        achar3 = achar3.replaceAll(with: \"H\")\n        achar3 = achar3.replaceAll(with:\
    \ \"R\")\n        achar3 = achar3.replaceAll(with: \"L\")\n        achar3 = achar3.replaceAll(with:\
    \ \"Y\")\n        achar3 = achar3.replaceAll(with: \"S\")\n        achar3 = achar3.replaceAll(with:\
    \ \"W\")\n        achar3 = achar3.replaceAll(with: \"G\")\n        achar3 = achar3.replaceAll(with:\
    \ \"V\")\n        achar3 = achar3.replaceAll(with: \"H\")\n        achar3 = achar3.replaceAll(with:\
    \ \"D\")\n        achar3 = achar3.replaceAll(with: \"O\")\n        achar3 = achar3.replaceAll(with:\
    \ \"R\")\n        achar3 = achar3.replaceAll(with: \"L\")\n        achar3 = achar3.replaceAll(with:\
    \ \"W\")\n        achar3 = achar3.replaceAll(with: \"Y\")\n        achar3 = achar3.replaceAll(with:\
    \ \"X\")\n        achar3 = achar3.replaceAll(with: \"Z\")\n        achar3 = achar3.replaceAll(with:\
    \ \"Z\")\n        achar3 = achar3.replaceAll(with: \"Y\")\n        achar3 = achar3.replaceAll(with:\
    \ \"W\")\n        achar3 = achar3.replaceAll(with: \"G\")\n        achar3 = achar3.replaceAll(with:\
    \ \"W\")\n        achar3 = achar3.replaceAll(with: \"Y\")\n        achar3 = achar\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpe0c9y9qd.swift:75:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmpe0c9y9qd.swift:12:40: note: to match this opening\
    \ '{'\nfunc encode(message: String) -> String {\n                            \
    \           ^\n/tmp/tmpe0c9y9qd.swift:16:41: error: cannot find 'toInt64' in scope\n\
    \        let achar = String.fromCharCode(toInt64(c))\n                       \
    \                 ^~~~~~~\n/tmp/tmpe0c9y9qd.swift:16:28: error: type 'String'\
    \ has no member 'fromCharCode'\n        let achar = String.fromCharCode(toInt64(c))\n\
    \                    ~~~~~~ ^~~~~~~~~~~~\n/tmp/tmpe0c9y9qd.swift:17:42: error:\
    \ cannot find 'toInt64' in scope\n        let achar2 = String.fromCharCode(toInt64(c\
    \ + 1))\n                                         ^~~~~~~\n/tmp/tmpe0c9y9qd.swift:17:50:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \        let achar2 = String.fromCharCode(toInt64(c + 1))\n                  \
    \                               ^\n/tmp/tmpe0c9y9qd.swift:17:29: error: type 'String'\
    \ has no member 'fromCharCode'\n        let achar2 = String.fromCharCode(toInt64(c\
    \ + 1))\n                     ~~~~~~ ^~~~~~~~~~~~\n/tmp/tmpe0c9y9qd.swift:59:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // write\
    \ your code in here\n    let vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n    let\
    \ alpha = \"abcdefghijklmnopqrstuvwxyz\"\n    var encodedMessage = \"\"\n    for\
    \ character in message {\n        if let index = vowels.indexOf(character) {\n\
    \            let replacement = alpha[Int(index)+2]\n            encodedMessage\
    \ += replacement\n        } else {\n            encodedMessage += character\n\
    \        }\n    }\n    return encodedMessage\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpfjr62uvg.swift:18:31: error: value of type '[String]' has no member\
    \ 'indexOf'\n        if let index = vowels.indexOf(character) {\n            \
    \           ~~~~~~ ^~~~~~~\n/tmp/tmpfjr62uvg.swift:22:31: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            encodedMessage\
    \ += character\n                              ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tvar messageArray:\
    \ [Character] = [Character]()\n\tvar j = 0\n\tvar newMessage = \"\"\n\tfor var\
    \ i = 0; i < message.characters.count; i++ {\n\t\tlet letter = message.characters[i]\n\
    \t\tif letter == ' ' {\n\t\t\tnewMessage.append(\" \")\n\t\t} else if letter.isUpperCase\
    \ {\n\t\t\tnewMessage.append(letter)\n\t\t} else {\n\t\t\tmessageArray.append(letter)\n\
    \t\t}\n\t}\n\tvar i = 0\n\tvar currentLetter = messageArray[i]\n\t\n\twhile i\
    \ < messageArray.count {\n\t\tif i + 1 < messageArray.count {\n\t\t\tlet secondLetter\
    \ = messageArray[i + 1]\n\t\t\tif secondLetter == \"A\" {\n\t\t\t\tcurrentLetter\
    \ = \"a\"\n\t\t\t} else if secondLetter == \"E\" {\n\t\t\t\tcurrentLetter = \"\
    e\"\n\t\t\t} else if secondLetter == \"I\" {\n\t\t\t\tcurrentLetter = \"i\"\n\t\
    \t\t} else if secondLetter == \"O\" {\n\t\t\t\tcurrentLetter = \"o\"\n\t\t\t}\
    \ else if secondLetter == \"U\" {\n\t\t\t\tcurrentLetter = \"u\"\n\t\t\t}\n\t\t\
    }\n\t\tnewMessage.append(currentLetter)\n\t\ti = i + 1\n\t}\n\treturn newMessage\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpksm2lr0q.swift:16:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for var i = 0; i < message.characters.count; i++ {\n   \
    \     ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpksm2lr0q.swift:18:16:\
    \ error: single-quoted string literal found, use '\"'\n                if letter\
    \ == ' ' {\n                             ^~~\n                             \"\
    \ \"\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // TODO:\
    \ fill this in\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpkwlf2ym3/tmpkwlf2ym3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9232d13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9232a0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9232a0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9232a097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkwlf2ym3                        0x000055b6738da307 <unavailable> + 4871

    5    libc.so.6                          0x00002b9232eff460 __libc_start_main +
    245

    6    tmpkwlf2ym3                        0x000055b6738d9f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var alphabet\
    \ = [String]()\n    var vowels = [String]()\n\n    for letter in message {\n \
    \       switch letter {\n        case \"a\":\n            alphabet.append(\"a\"\
    )\n        case \"e\":\n            alphabet.append(\"e\")\n        case \"i\"\
    :\n            alphabet.append(\"i\")\n        case \"o\":\n            alphabet.append(\"\
    o\")\n        case \"u\":\n            alphabet.append(\"u\")\n        case \"\
    y\":\n            alphabet.append(\"y\")\n        default:\n            continue\n\
    \        }\n    }\n\n    for letter in message {\n        switch letter {\n  \
    \      case \"a\":\n            if alphabet.count > 0 {\n                vowels.append(alphabet[alphabet.count\
    \ - 2])\n                alphabet.removeLast()\n            } else {\n       \
    \         continue\n            }\n        case \"e\":\n            if alphabet.count\
    \ > 0 {\n                vowels.append(alphabet[alphabet.count - 2])\n       \
    \         alphabet.removeLast()\n            } else {\n                continue\n\
    \            }\n        case \"i\":\n            if alphabet.count > 0 {\n   \
    \             vowels.append(alphabet[alphabet.count - 2])\n                alphabet.removeLast()\n\
    \            } else {\n                continue\n            }\n        case \"\
    o\":\n            if alphabet.count > 0 {\n                vowels.append(alphabet[alphabet.count\
    \ - 2])\n                alphabet.removeLast()\n            } else {\n       \
    \         continue\n            }\n        case \"u\":\n            if alphabet.count\
    \ > 0 {\n                vowels.append(alphabet[alphabet.count - 2])\n       \
    \         alphabet.removeLast()\n            } else {\n                continue\n\
    \            }\n        case \"y\":\n            if alphabet.count > 0 {\n   \
    \             vowels.append(alphabet[alphabet.count - 2])\n                alphabet.removeLast()\n\
    \            } else {\n                continue\n            }\n        default:\n\
    \            continue\n        }\n    }\n\n    var message2 = \"\"\n    for letter\
    \ in message {\n        message2 += letter\n    }\n    var index = 0\n    for\
    \ letter in message2 {\n        if letter == \"a\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        if letter == \"e\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        if letter == \"i\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        if letter == \"o\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        if letter == \"u\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        if letter == \"y\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        index += 1\n    }\n\n    return message2\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpe7fxdwwl.swift:86:21: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        message2 += letter\n           \
    \         ^\n/tmp/tmpe7fxdwwl.swift:91:33: error: value of type 'String' has no\
    \ member 'substringFromIndex'\n            message2 = message2.substringFromIndex(index)\n\
    \                       ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpe7fxdwwl.swift:94:33:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n         \
    \   message2 = message2.substringFromIndex(index)\n                       ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpe7fxdwwl.swift:97:33: error: value of type 'String'\
    \ has no member 'substringFromIndex'\n            message2 = message2.substringFromIndex(index)\n\
    \                       ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpe7fxdwwl.swift:100:33:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n         \
    \   message2 = message2.substringFromIndex(index)\n                       ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpe7fxdwwl.swift:103:33: error: value of type 'String'\
    \ has no member 'substringFromIndex'\n            message2 = message2.substringFromIndex(index)\n\
    \                       ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpe7fxdwwl.swift:106:33:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n         \
    \   message2 = message2.substringFromIndex(index)\n                       ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var newMessage\
    \ = \"\"\n    for i in 0..<message.count {\n        var x = message[i]\n     \
    \   var y = message[i]\n        if x < \"a\" || x > \"z\" {\n            newMessage\
    \ += \"z\"\n        }\n        else if x > \"A\" || x < \"Z\" {\n            newMessage\
    \ += \"A\"\n        }\n        \n        if x < \"a\" || y > \"z\" {\n       \
    \     newMessage += y\n        }\n        else if y > \"A\" || x < \"Z\" {\n \
    \           newMessage += x\n        }\n    }\n    \n    return newMessage\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp49aklsgx.swift:15:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        var x = message[i]\n\
    \                ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp49aklsgx.swift:16:17: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        var y = message[i]\n                ^~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp49aklsgx.swift:25:27: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            newMessage += y\n                          ^\n/tmp/tmp49aklsgx.swift:28:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            newMessage += x\n                          ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    let\
    \ vowels = \"aeiouAEIOU\"\n    \n    guard !message.isEmpty else { return \"\"\
    }\n    \n    var stringBuilder = StringBuilder()\n    \n    var index = 0\n  \
    \  \n    while index < message.characters.count {\n        \n        let currentChar\
    \ = message.characters[index]\n        let currentCharIndex = string.Index(of:\
    \ currentChar)\n        \n        if currentCharIndex == nil {\n            break\n\
    \        }\n        \n        let nextChar = message.characters[index + 1]\n \
    \       let nextCharIndex = string.Index(of: nextChar)\n        \n        if nextCharIndex\
    \ == nil {\n            break\n        }\n        \n        let indexInMessage\
    \ = currentCharIndex! + 1 // the letter in the message\n        let indexInEnglish\
    \ = nextCharIndex! + 1 // the letter 2 places ahead\n        \n        guard indexInMessage\
    \ < message.characters.count else { return \"\"}\n        \n        guard indexInEnglish\
    \ < string.characters.count else { return \"\"}\n        \n        switch currentChar\
    \ {\n            \n        case \".\": stringBuilder.append(\".\")\n        case\
    \ \"!\": stringBuilder.append(\"!\")\n        case \"\\\"\": stringBuilder.append(\"\
    \\\"\")\n        case \"#\": stringBuilder.append(\"#\")\n        case \"$\":\
    \ stringBuilder.append(\"$\")\n        case \"%\": stringBuilder.append(\"%\"\
    )\n        case \"&\": stringBuilder.append(\"&\")\n        case \"'\": stringBuilder.append(\"\
    '\")\n        case \"(\": stringBuilder.append(\"(\")\n        case \")\": stringBuilder.append(\"\
    )\")\n        case \"*\": stringBuilder.append(\"*\")\n        case \"+\": stringBuilder.append(\"\
    +\")\n        case \",\": stringBuilder.append(\",\")\n        case \"-\": stringBuilder.append(\"\
    -\")\n        case \"/\": stringBuilder.append(\"/\")\n        case \":\": stringBuilder.append(\"\
    :\")\n        case \"<\": stringBuilder.append(\"<\")\n        case \">\": stringBuilder.append(\"\
    >\")\n        case \".\": stringBuilder.append(\".\")\n        case \"0\": stringBuilder.append(\"\
    0\")\n        case \"1\": stringBuilder.append(\"1\")\n        case \"2\": stringBuilder.append(\"\
    2\")\n        case \"3\": stringBuilder.append(\"3\")\n        case \"4\": stringBuilder.append(\"\
    4\")\n        case \"5\": stringBuilder.append(\"5\")\n        case \"6\": stringBuilder.append(\"\
    6\")\n        case \"7\": stringBuilder.append(\"7\")\n        case \"8\": stringBuilder.append(\"\
    8\")\n        case \"9\": stringBuilder.append(\"9\")\n        case \"0\": stringBuilder.append(\"\
    0\")\n        case \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpg2nf4_md.swift:77:14: error: unterminated string literal\n    \
    \    case \"\n             ^\n/tmp/tmpg2nf4_md.swift:77:15: error: expected ':'\
    \ after 'case'\n        case \"\n              ^\n/tmp/tmpg2nf4_md.swift:97:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpg2nf4_md.swift:22:44:\
    \ note: to match this opening '{'\n    while index < message.characters.count\
    \ {\n                                           ^\n/tmp/tmpg2nf4_md.swift:97:84:\
    \ error: expected '}' at end of brace statement\nassert(encode(message: \"I DoNt\
    \ KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                  \
    \                                                                 ^\n/tmp/tmpg2nf4_md.swift:12:40:\
    \ note: to match this opening '{'\nfunc encode(message: String) -> String {\n\
    \                                       ^\n/tmp/tmpg2nf4_md.swift:18:25: error:\
    \ cannot find 'StringBuilder' in scope\n    var stringBuilder = StringBuilder()\n\
    \                        ^~~~~~~~~~~~~\n/tmp/tmpg2nf4_md.swift:22:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    while index < message.characters.count\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpg2nf4_md.swift:24:27: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ currentChar = message.characters[index]\n                          ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpg2nf4_md.swift:24:35:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ currentChar = message.characters[index]\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was "
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let len\
    \ = message.count\n    var result = \"\"\n    for i in 0..<len {\n        let\
    \ letter = message[i]\n        let letterIndex = letterIndexOf(letter)\n     \
    \   if (letterIndex < 0) || (letterIndex > message.count - 2) {\n            continue\n\
    \        }\n        let letter2Index = letterIndexOf(message[letterIndex + 1])\n\
    \        if (letter2Index < 0) || (letter2Index > message.count - 2) {\n     \
    \       continue\n        }\n        let letter3 = message[letterIndex + 1]\n\
    \        let letter4 = message[letter2Index]\n        var newLetter = letter\n\
    \        if (letter3 != \"a\") && letter3 != \"e\") && letter3 != \"i\") && letter3\
    \ != \"o\") && letter3 != \"u\" {\n            newLetter = \"\\(letter).\\(letter3)\"\
    \n        }\n        if (letter4 != \"a\") && letter4 != \"e\") && letter4 !=\
    \ \"i\") && letter4 != \"o\") && letter4 != \"u\" {\n            newLetter = \"\
    \\(letter).\\(letter4).\\(letter3)\"\n        }\n        result = result.appending(\"\
    \\(newLetter)\")\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp390w5wip.swift:28:46: error: expected '{' after 'if' condition\n\
    \        if (letter3 != \"a\") && letter3 != \"e\") && letter3 != \"i\") && letter3\
    \ != \"o\") && letter3 != \"u\" {\n                                          \
    \   ^\n/tmp/tmp390w5wip.swift:31:46: error: expected '{' after 'if' condition\n\
    \        if (letter4 != \"a\") && letter4 != \"e\") && letter4 != \"i\") && letter4\
    \ != \"o\") && letter4 != \"u\" {\n                                          \
    \   ^\n/tmp/tmp390w5wip.swift:16:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let letter\
    \ = message[i]\n                     ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp390w5wip.swift:17:27: error: cannot\
    \ find 'letterIndexOf' in scope\n        let letterIndex = letterIndexOf(letter)\n\
    \                          ^~~~~~~~~~~~~\n/tmp/tmp390w5wip.swift:21:28: error:\
    \ cannot find 'letterIndexOf' in scope\n        let letter2Index = letterIndexOf(message[letterIndex\
    \ + 1])\n                           ^~~~~~~~~~~~~\n/tmp/tmp390w5wip.swift:29:25:\
    \ error: cannot assign value of type 'String' to type 'Character'\n          \
    \  newLetter = \"\\(letter).\\(letter3)\"\n                        ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp390w5wip.swift:32:25: error: cannot assign value of type 'String' to type\
    \ 'Character'\n            newLetter = \"\\(letter).\\(letter4).\\(letter3)\"\n\
    \                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp390w5wip.swift:34:25:\
    \ error: value of type 'String' has no member 'appending'\n        result = result.appending(\"\
    \\(newLetter)\")\n                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var firstLetter:\
    \ Character = \"a\"\n    var secondLetter: Character = \"A\"\n    var thirdLetter:\
    \ Character = \"e\"\n    var fourthLetter: Character = \"E\"\n    var fifthLetter:\
    \ Character = \"i\"\n    var sixthLetter: Character = \"I\"\n    var seventhLetter:\
    \ Character = \"o\"\n    var eighthLetter: Character = \"O\"\n    var ninthLetter:\
    \ Character = \"u\"\n    var tenthLetter: Character = \"U\"\n    var firstVowel:\
    \ Character = \"a\"\n    var secondVowel: Character = \"A\"\n    var thirdVowel:\
    \ Character = \"e\"\n    var fourthVowel: Character = \"E\"\n    var fifthVowel:\
    \ Character = \"i\"\n    var sixthVowel: Character = \"I\"\n    var seventhVowel:\
    \ Character = \"o\"\n    var eighthVowel: Character = \"O\"\n    var ninthVowel:\
    \ Character = \"u\"\n    var tenthVowel: Character = \"U\"\n\n    var allLetters:\
    \ [Character] = [firstLetter, secondLetter, thirdLetter, fourthLetter, fifthLetter,\
    \ sixthLetter, seventhLetter, eighthLetter, ninthLetter, tenthLetter]\n    var\
    \ allVowels: [Character] = [firstVowel, secondVowel, thirdVowel, fourthVowel,\
    \ fifthVowel, sixthVowel, seventhVowel, eighthVowel, ninthVowel, tenthVowel]\n\
    \n    var newMessage = String()\n\n    for letter in message {\n        if allLetters.contains(letter)\
    \ {\n            newMessage += letter\n        } else if allVowels.contains(letter)\
    \ {\n            newMessage += letter\n            switch letter{\n          \
    \  case \"a\":\n                newMessage = newMessage + firstVowel\n       \
    \     case \"A\":\n                newMessage = newMessage + secondVowel\n   \
    \         case \"e\":\n                newMessage = newMessage + thirdVowel\n\
    \            case \"E\":\n                newMessage = newMessage + fourthVowel\n\
    \            case \"i\":\n                newMessage = newMessage + fifthVowel\n\
    \            case \"I\":\n                newMessage = newMessage + sixthVowel\n\
    \            case \"o\":\n                newMessage = newMessage + seventhVowel\n\
    \            case \"O\":\n                newMessage = newMessage + eighthVowel\n\
    \            case \"u\":\n                newMessage = newMessage + n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp785ip1v4.swift:82:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmp785ip1v4.swift:42:46: note: to match this opening\
    \ '{'\n        } else if allVowels.contains(letter) {\n                      \
    \                       ^\n/tmp/tmp785ip1v4.swift:82:84: error: expected '}' at\
    \ end of brace statement\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmp785ip1v4.swift:39:27: note:\
    \ to match this opening '{'\n    for letter in message {\n                   \
    \       ^\n/tmp/tmp785ip1v4.swift:82:84: error: expected '}' at end of brace statement\n\
    assert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
    \ wRkTg\")\n                                                                 \
    \                  ^\n/tmp/tmp785ip1v4.swift:12:40: note: to match this opening\
    \ '{'\nfunc encode(message: String) -> String {\n                            \
    \           ^\n/tmp/tmp785ip1v4.swift:41:27: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            newMessage += letter\n\
    \                          ^\n/tmp/tmp785ip1v4.swift:43:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            newMessage\
    \ += letter\n                          ^\n/tmp/tmp785ip1v4.swift:46:43: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                newMessage = newMessage + firstVowel\n                      \
    \                    ^\n/tmp/tmp785ip1v4.swift:48:43: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                newMessage\
    \ = newMessage + secondVowel\n                                          ^\n/tmp/tmp785ip1v4.swift:50:43:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \             "
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var messageCopy\
    \ = message\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    for letter\
    \ in vowels {\n        messageCopy = messageCopy.replacingOccurrences(of: letter,\
    \ with: letters[letters.index(of: letter) + 2])\n    }\n    for letter in letters\
    \ {\n        let indexLetter = letters.index(of: letter)!\n        let indexVowel\
    \ = letters.index(of: \"a\")!\n        messageCopy = messageCopy.replacingOccurrences(of:\
    \ letter, with: letters[(indexLetter + (indexVowel - indexLetter)) - 1])\n   \
    \ }\n    return messageCopy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4giy1m2f.swift:16:74: error: cannot find 'letters' in scope\n \
    \       messageCopy = messageCopy.replacingOccurrences(of: letter, with: letters[letters.index(of:\
    \ letter) + 2])\n                                                            \
    \             ^~~~~~~\n/tmp/tmp4giy1m2f.swift:16:82: error: cannot find 'letters'\
    \ in scope\n        messageCopy = messageCopy.replacingOccurrences(of: letter,\
    \ with: letters[letters.index(of: letter) + 2])\n                            \
    \                                                     ^~~~~~~\n/tmp/tmp4giy1m2f.swift:16:35:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ messageCopy = messageCopy.replacingOccurrences(of: letter, with: letters[letters.index(of:\
    \ letter) + 2])\n                      ~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4giy1m2f.swift:18:19:\
    \ error: cannot find 'letters' in scope\n    for letter in letters {\n       \
    \           ^~~~~~~\n/tmp/tmp4giy1m2f.swift:19:27: error: cannot find 'letters'\
    \ in scope\n        let indexLetter = letters.index(of: letter)!\n           \
    \               ^~~~~~~\n/tmp/tmp4giy1m2f.swift:20:26: error: cannot find 'letters'\
    \ in scope\n        let indexVowel = letters.index(of: \"a\")!\n             \
    \            ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tlet letters\
    \ = message.characters\n\tlet result = \"\"\n\tvar index = messages.startIndex\n\
    \twhile index < messages.endIndex {\n\t\tlet value = message[index]\n\t\tlet letter\
    \ = letters[index]\n\t\tlet newLetter = letter // first letter of the alphabet\n\
    \t\tif newLetter == \"a\" || newLetter == \"i\" { // if the letter is not a vowel\n\
    \t\t\tindex += 1 // move to the next letter\n\t\t\tcontinue\n\t\t}\n\t\tif value.isLetterAndLowerCase()\
    \ { // if letter is a vowel\n\t\t\tnewLetter = String(index)\n\t\t\tindex += 1\
    \ // move to the next letter\n\t\t}\n\t\tif index != messages.startIndex {\n\t\
    \t\tresult += String(index)\n\t\t}\n\t\tresult += newLetter\n\t\tindex += 1 //\
    \ move to the next letter\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp2xthxkog.swift:13:24: error: 'characters' is unavailable: Please\
    \ use String directly\n        let letters = message.characters\n            \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp2xthxkog.swift:15:14: error: cannot find 'messages' in scope\n  \
    \      var index = messages.startIndex\n                    ^~~~~~~~\n/tmp/tmp2xthxkog.swift:16:16:\
    \ error: cannot find 'messages' in scope\n        while index < messages.endIndex\
    \ {\n                      ^~~~~~~~\n/tmp/tmp2xthxkog.swift:28:15: error: cannot\
    \ find 'messages' in scope\n                if index != messages.startIndex {\n\
    \                            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"AEIOUaeiou\"\n    var result = \"\"\n    for c in message {\n        if\
    \ vowels.contains(String(format: \"%C\", c)) {\n            var nextVowel = vowels.index(of:\
    \ String(format: \"%C\", c))!\n            result.append(String(format: \"%C\"\
    , c))\n            result.append(String(format: \"%C\", next(string: message,\
    \ currentIndex: nextVowel)))\n        } else {\n            result.append(String(format:\
    \ \"%C\", c))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp90mffsqm.swift:16:28: error: no exact matches in call to initializer\
    \ \n        if vowels.contains(String(format: \"%C\", c)) {\n                \
    \           ^\nSwift.String:4:23: note: candidate '(String) -> String' requires\
    \ 1 argument, but 2 were provided\n    @inlinable public init<T>(_ value: T) where\
    \ T : LosslessStringConvertible\n                      ^\n/tmp/tmp90mffsqm.swift:16:28:\
    \ note: candidate has partially matching parameter list (repeating: String, count:\
    \ Int)\n        if vowels.contains(String(format: \"%C\", c)) {\n            \
    \               ^\nSwift.String:3:12: note: candidate '(String) -> String' requires\
    \ 1 argument, but 2 were provided\n    public init<S>(_ other: S) where S : LosslessStringConvertible,\
    \ S : Sequence, S.Element == Character\n           ^\nSwift.String:4:12: note:\
    \ candidate '(String) -> String' requires 1 argument, but 2 were provided\n  \
    \  public init<S>(_ characters: S) where S : Sequence, S.Element == Character\n\
    \           ^\nSwift.RangeReplaceableCollection:3:23: note: candidate '(String)\
    \ -> String' requires 1 argument, but 2 were provided\n    @inlinable public init<S>(_\
    \ elements: S) where S : Sequence, Self.Element == S.Element\n               \
    \       ^\n/tmp/tmp90mffsqm.swift:17:46: error: no exact matches in call to initializer\
    \ \n            var nextVowel = vowels.index(of: String(format: \"%C\", c))!\n\
    \                                             ^\n/tmp/tmp90mffsqm.swift:17:46:\
    \ note: candidate has partially matching parameter list (String)\n           \
    \ var nextVowel = vowels.index(of: String(format: \"%C\", c))!\n             \
    \                                ^\n/tmp/tmp90mffsqm.swift:17:46: note: candidate\
    \ has partially matching parameter list (repeating: String, count: Int)\n    \
    \        var nextVowel = vowels.index(of: String(format: \"%C\", c))!\n      \
    \                                       ^\n/tmp/tmp90mffsqm.swift:17:46: note:\
    \ candidate has partially matching parameter list (String)\n            var nextVowel\
    \ = vowels.index(of: String(format: \"%C\", c))!\n                           \
    \                  ^\n/"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let letterIndexes\
    \ = message.characters.map { (letter, index) -> (char, Int) in\n        let firstVowelIndex\
    \ = letters.firstIndex(of: letter)\n        if firstVowelIndex == NSNotFound {\n\
    \            return letter, index\n        } else {\n            let vowels =\
    \ Array(letters[firstVowelIndex ..< letterIndex])\n            let lastVowelIndex\
    \ = letters.lastIndex(of: letter)\n            let count = lastVowelIndex - firstVowelIndex\
    \ + 1\n            if count == 0 {\n                return letter, index\n   \
    \         } else {\n                return letters[firstVowelIndex + 1], index\n\
    \            }\n        }\n    }\n\n    var result = \"\"\n    var lastLetterIndex\
    \ = 0\n    for (index, letter) in letterIndexes {\n        let letter = letter.first!\n\
    \        let next = letter.first!.first!\n        if letter == letters[lastLetterIndex]\
    \ {\n            result += String(letters[lastLetterIndex])\n            lastLetterIndex\
    \ += 1\n        } else {\n            result += String(letter)\n            lastLetterIndex\
    \ = index\n        }\n        result += String(letters[lastLetterIndex])\n   \
    \ }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpf8_429t0.swift:16:26: error: consecutive statements on a line must\
    \ be separated by ';'\n            return letter, index\n                    \
    \     ^\n                         ;\n/tmp/tmpf8_429t0.swift:16:26: error: expected\
    \ expression\n            return letter, index\n                         ^\n/tmp/tmpf8_429t0.swift:22:30:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \       return letter, index\n                             ^\n               \
    \              ;\n/tmp/tmpf8_429t0.swift:22:30: error: expected expression\n \
    \               return letter, index\n                             ^\n/tmp/tmpf8_429t0.swift:24:52:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \       return letters[firstVowelIndex + 1], index\n                         \
    \                          ^\n                                               \
    \    ;\n/tmp/tmpf8_429t0.swift:24:52: error: expected expression\n           \
    \     return letters[firstVowelIndex + 1], index\n                           \
    \                        ^\n/tmp/tmpf8_429t0.swift:14:31: error: cannot find 'letters'\
    \ in scope\n        let firstVowelIndex = letters.firstIndex(of: letter)\n   \
    \                           ^~~~~~~\n/tmp/tmpf8_429t0.swift:15:31: error: cannot\
    \ find 'NSNotFound' in scope\n        if firstVowelIndex == NSNotFound {\n   \
    \                           ^~~~~~~~~~\n/tmp/tmpf8_429t0.swift:18:32: error: cannot\
    \ find 'letters' in scope\n            let vowels = Array(letters[firstVowelIndex\
    \ ..< letterIndex])\n                               ^~~~~~~\n/tmp/tmpf8_429t0.swift:18:60:\
    \ error: cannot find 'letterIndex' in scope\n            let vowels = Array(letters[firstVowelIndex\
    \ ..< letterIndex])\n                                                        \
    \   ^~~~~~~~~~~\n/tmp/tmpf8_429t0.swift:19:34: error: cannot find 'letters' in\
    \ scope\n            let lastVowelIndex = letters.lastIndex(of: letter)\n    \
    \                             ^~~~~~~\n/tmp/tmpf8_429t0.swift:24:24: error: cannot\
    \ find 'letters' in scope\n                return letters[firstVowelIn"
  stdout: ''
  timestamp: 1659978720
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // TODO:\
    \ implement\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpd_z5djfi/tmpd_z5djfi.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aebadcb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aebad9afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aebad9af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aebad9ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_z5djfi                        0x000055e69a66d307 <unavailable> + 4871

    5    libc.so.6                          0x00002aebadea4460 __libc_start_main +
    245

    6    tmpd_z5djfi                        0x000055e69a66cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var alphabet\
    \ = [Character]()\n    var currentLetter = \"\"\n    var firstLetter = false //\
    \ First letter of message\n    for c in message.characters {\n        if !firstLetter\
    \ {\n            firstLetter = true\n        } else {\n            alphabet.append(c)\n\
    \        }\n    }\n    var messageLength = 0\n    for letter in message {\n  \
    \      messageLength += 1\n    }\n    var result = \"\"\n    var previousLetter\
    \ = \"\"\n    for letter in alphabet {\n        result += previousLetter\n   \
    \     previousLetter = letter\n        if letter != letter {\n            result\
    \ += letter\n            previousLetter = letter\n        }\n    }\n    for _\
    \ in 0..<messageLength {\n        result += previousLetter\n    }\n    return\
    \ String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpuso_zms_.swift:16:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in message.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpuso_zms_.swift:31:26:\
    \ error: cannot assign value of type 'Character' to type 'String'\n        previousLetter\
    \ = letter\n                         ^~~~~~\n/tmp/tmpuso_zms_.swift:33:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n/tmp/tmpuso_zms_.swift:34:30:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  previousLetter = letter\n                             ^~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result:\
    \ String = \"\"\n\n    for character in message {\n        switch character {\n\
    \        case \"a\":\n            result = \"t\"\n        case \"e\":\n      \
    \      result = \"k\"\n        case \"i\":\n            result = \"s\"\n     \
    \   case \"o\":\n            result = \"g\"\n        case \"u\":\n           \
    \ result = \"c\"\n        case \"A\":\n            result = \"t\"\n        case\
    \ \"E\":\n            result = \"k\"\n        case \"I\":\n            result\
    \ = \"s\"\n        case \"O\":\n            result = \"g\"\n        case \"U\"\
    :\n            result = \"c\"\n        case \"n\":\n            result = \"g\"\
    \n        default:\n            result = character\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp68u0p0k0.swift:40:22: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            result = character\n                     ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var chars\
    \ = message.characters\n    for case let character in chars {\n        if let\
    \ upper = Character(character).uppercased() {\n            chars.remove(at: chars.index(of:\
    \ upper)!)\n        } else {\n            chars.remove(at: chars.index(of: character)!)\n\
    \        }\n    }\n    return String(chars)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpv2gsgzri.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    var chars = message.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpv2gsgzri.swift:15:34:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      if let upper = Character(character).uppercased() {\n                  \
    \               ^\n                                 extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpv2gsgzri.swift:18:36: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n            chars.remove(at: chars.index(of: character)!)\n\
    \                                   ^\n/tmp/tmpv2gsgzri.swift:18:36: note: use\
    \ 'firstIndex(of:)' instead\n            chars.remove(at: chars.index(of: character)!)\n\
    \                                   ^~~~~\n                                  \
    \ firstIndex\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    if message\
    \ == \"\" {\n        return \"\"\n    }\n\n    let words = message.lowercased().components(separatedBy:\
    \ \" \")\n    var result = \"\"\n    for word in words {\n        result += \"\
    \\(self.encodeWord(word))\"\n    }\n\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpiwpn78fw.swift:17:38: error: value of type 'String' has no member\
    \ 'components'\n    let words = message.lowercased().components(separatedBy: \"\
    \ \")\n                ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Convert\
    \ every letter in message to the index in `a`, then find the index of the letter\
    \ `a` that is two places ahead of it\n    // and swap two letters. \n    return\
    \ String(message.characters.map({ (letter) -> Character in\n        let a = Character(letter.lowercased())\n\
    \        let b = Character(String(a) + String(2))\n        switch a {\n      \
    \  case \".\": return b.uppercased()\n        case \"a\": return b.lowercased()\n\
    \        case \"i\": return b.lowercased()\n        case \"o\": return b.lowercased()\n\
    \        case \"e\": return b.lowercased()\n        case \"u\": return b.lowercased()\n\
    \        default:\n            return b\n        }\n    }))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpusy9lsu0.swift:19:28: error: cannot convert return expression of\
    \ type 'String' to return type 'Character'\n        case \".\": return b.uppercased()\n\
    \                         ~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ encode(message: message, lower: true)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp9mavpf_k.swift:13:44: error: extra argument 'lower' in call\n \
    \   return encode(message: message, lower: true)\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Only\
    \ letters. \n    if message.isEmpty {\n        return message\n    }\n    var\
    \ messageString = \"\"\n    message.forEach {\n        let x = $0\n        var\
    \ vowels = \"AEIOUYaeiouy\"\n        var nextVowel: String?\n        for letter\
    \ in vowels {\n            if x == letter{\n                nextVowel = String(String(letter).utf16)\n\
    \            }\n        }\n        if nextVowel != nil {\n            let index\
    \ = String(String($0).utf16).indexOf(nextVowel!, range: nil, locale: nil)\n  \
    \          if index != nil {\n                let value = String(String($0).utf16).substring(with:\
    \ index!)\n                messageString += value\n            }\n        }\n\
    \    }\n    return messageString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpy3b52e6i.swift:28:50: error: value of type 'String' has no member\
    \ 'indexOf'\n            let index = String(String($0).utf16).indexOf(nextVowel!,\
    \ range: nil, locale: nil)\n                        ~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n\
    /tmp/tmpy3b52e6i.swift:28:77: error: 'nil' requires a contextual type\n      \
    \      let index = String(String($0).utf16).indexOf(nextVowel!, range: nil, locale:\
    \ nil)\n                                                                     \
    \       ^\n/tmp/tmpy3b52e6i.swift:28:90: error: 'nil' requires a contextual type\n\
    \            let index = String(String($0).utf16).indexOf(nextVowel!, range: nil,\
    \ locale: nil)\n                                                             \
    \                            ^\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encoded\
    \ = \"\"\n    for letter in message {\n        \n        encoded = encoded + getEncodedLetter(letter)\n\
    \    }\n    return encoded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp0qd6jogu.swift:16:29: error: cannot find 'getEncodedLetter' in\
    \ scope\n        encoded = encoded + getEncodedLetter(letter)\n              \
    \              ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for ch in message {\n        var newChar = ch // copy the char\n\
    \        var nextChar = ch.lowercaseString()\n        \n        // Case swap\n\
    \        if ch.isUppercase {\n            newChar = nextChar.swapFirstLetter()\n\
    \        }\n        \n        // Vowel replacement\n        if ch.isLetter  &&\
    \ nextChar == \"a\" {\n            nextChar = \"e\"\n        }\n        if ch.isLetter\
    \  && nextChar == \"e\" {\n            nextChar = \"i\"\n        }\n        if\
    \ ch.isLetter  && nextChar == \"i\" {\n            nextChar = \"o\"\n        }\n\
    \        if ch.isLetter  && nextChar == \"o\" {\n            nextChar = \"u\"\n\
    \        }\n        if ch.isLetter  && nextChar == \"u\" {\n            nextChar\
    \ = \"y\"\n        }\n        if ch.isLetter  && nextChar == \"y\" {\n       \
    \     nextChar = \"A\"\n        }\n        if ch.isLetter  && nextChar == \"A\"\
    \ {\n            nextChar = \"E\"\n        }\n        if ch.isLetter  && nextChar\
    \ == \"E\" {\n            nextChar = \"I\"\n        }\n        if ch.isLetter\
    \  && nextChar == \"I\" {\n            nextChar = \"O\"\n        }\n        if\
    \ ch.isLetter  && nextChar == \"O\" {\n            nextChar = \"U\"\n        }\n\
    \        if ch.isLetter  && nextChar == \"U\" {\n            nextChar = \"Y\"\n\
    \        }\n        if ch.isLetter  && nextChar == \"Y\" {\n            nextChar\
    \ = \"-\"\n        }\n        \n        // Add the new char\n        result +=\
    \ nextChar\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpyyj8n42j.swift:16:27: error: value of type 'Character' has no member\
    \ 'lowercaseString'\n        var nextChar = ch.lowercaseString()\n           \
    \            ~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n  let map =\
    \ \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n              characters.reduce(into:\
    \ [Character : Int](), \n                             { (dict, c) in\n       \
    \                        dict[c] = dict[c]! ?? 0\n                           \
    \    dict[c]! += 1\n                               dict\n                    \
    \         })\n  \n  let newString = message.characters.reduce(into: \"\") { (result,\
    \ c) in\n    if map.keys.contains(c) {\n      let mappedIndex = map[c]! - 1\n\
    \      result + String(UnicodeScalar(mappedIndex))\n    } else {\n      result\
    \ += c\n    }\n  }\n  return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp49lajmk5.swift:13:67: error: expected member name following '.'\n\
    \  let map = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n     \
    \                                                             ^\n/tmp/tmp49lajmk5.swift:14:15:\
    \ error: cannot find 'characters' in scope\n              characters.reduce(into:\
    \ [Character : Int](), \n              ^~~~~~~~~~\n/tmp/tmp49lajmk5.swift:17:39:\
    \ error: cannot assign through '!': 'dict' is a 'let' constant\n             \
    \                  dict[c]! += 1\n                               ~~~~   ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.characters.map {\n        $0.isUppercase ? $0.lowercased() : $0\n  \
    \  }.map {\n        let a = \"AEIOUaeiou\"\n        let b = \"BCDFGHJKLMNPRSTVWY\"\
    \n        let c = \"qwertyuiop\"\n        let d = \"aeiou\"\n        let e = \"\
    bcdfghjklmnpqrstvwxyz\"\n\n        let index = a.index(of: String($0))!\n    \
    \    let letter = b.substring(to: index+1)\n        let vowelIndex = a.index(of:\
    \ String($0))!\n        let vowel = c.substring(to: vowelIndex+1)\n        return\
    \ String($0) + letter + vowel\n    }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpgyifq_uf.swift:14:29: error: result values in '? :' expression\
    \ have mismatching types 'String' and 'String.Element' (aka 'Character')\n   \
    \     $0.isUppercase ? $0.lowercased() : $0\n                         ~~~^~~~~~~~~~~~\n\
    /tmp/tmpgyifq_uf.swift:22:33: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n        let index\
    \ = a.index(of: String($0))!\n                                ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var chars\
    \ = Array(message)\n    var swapped = true\n    var result: String = \"\"\n  \
    \  for _ in 0 ..< chars.count {\n        var c = chars.first!\n        let index\
    \ = chars.index { (char) -> Bool in\n            char = Swapping[char]\n     \
    \       swapped = false\n            swapped = swapped || Swapping[char] == Swapping[c]\n\
    \            return true\n        }\n        if index == chars.count - 1 {\n \
    \           result += \"\\(Swapping[c])\"\n        } else {\n            result\
    \ += \"\\(Swapping[c])\"\n            result += chars[index + 1]\n        }\n\
    \    }\n    return swapped ? result : result.lowercased()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpz6zg1a04.swift:19:20: error: cannot find 'Swapping' in scope\n\
    \            char = Swapping[char]\n                   ^~~~~~~~\n/tmp/tmpz6zg1a04.swift:21:34:\
    \ error: cannot find 'Swapping' in scope\n            swapped = swapped || Swapping[char]\
    \ == Swapping[c]\n                                 ^~~~~~~~\n/tmp/tmpz6zg1a04.swift:21:52:\
    \ error: cannot find 'Swapping' in scope\n            swapped = swapped || Swapping[char]\
    \ == Swapping[c]\n                                                   ^~~~~~~~\n\
    /tmp/tmpz6zg1a04.swift:25:26: error: cannot find 'Swapping' in scope\n       \
    \     result += \"\\(Swapping[c])\"\n                         ^~~~~~~~\n/tmp/tmpz6zg1a04.swift:27:26:\
    \ error: cannot find 'Swapping' in scope\n            result += \"\\(Swapping[c])\"\
    \n                         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"AEIOUaeiou\"\n    \n    // The pattern we use, using back references, is\
    \ often very useful. \n    // We use the first character of each word to encode\
    \ it, to create \n    // the vowel sequence, then use two back references to move\
    \ the \n    // second character to the end of the word.\n    var pattern = NSMutableString()\n\
    \    for char in message.characters {\n        if let index = vowels.characterIndex(of:\
    \ String(char)) {\n            pattern.append(String(char))\n            pattern.append(String(char.advanced(by:\
    \ index)))\n        }\n    }\n    \n    // We need two back references to put\
    \ the last character into the \n    // pattern for proper case replacement\n \
    \   pattern = pattern.reversed()\n    pattern = pattern.replacingOccurrences(of:\
    \ \"aeiou\", with: \"AEIOU\", options: .caseInsensitive, range: nil)\n    pattern\
    \ = pattern.reversed()\n    \n    return pattern.stringByReplacingOccurrencesOfString(\"\
    A\", withString: \"a\", options: .caseInsensitive, range: nil)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpegcutl1z.swift:19:19: error: cannot find 'NSMutableString' in scope\n\
    \    var pattern = NSMutableString()\n                  ^~~~~~~~~~~~~~~\n/tmp/tmpegcutl1z.swift:20:25:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in message.characters {\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpegcutl1z.swift:21:31: error: value of\
    \ type 'String' has no member 'characterIndex'\n        if let index = vowels.characterIndex(of:\
    \ String(char)) {\n                       ~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpegcutl1z.swift:23:40:\
    \ error: value of type 'Character' has no member 'advanced'\n            pattern.append(String(char.advanced(by:\
    \ index)))\n                                  ~~~~ ^~~~~~~~\n/tmp/tmpegcutl1z.swift:30:82:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \    pattern = pattern.replacingOccurrences(of: \"aeiou\", with: \"AEIOU\", options:\
    \ .caseInsensitive, range: nil)\n                                            \
    \                                    ~^~~~~~~~~~~~~~~\n/tmp/tmpegcutl1z.swift:30:106:\
    \ error: 'nil' requires a contextual type\n    pattern = pattern.replacingOccurrences(of:\
    \ \"aeiou\", with: \"AEIOU\", options: .caseInsensitive, range: nil)\n       \
    \                                                                            \
    \                      ^\n/tmp/tmpegcutl1z.swift:33:89: error: cannot infer contextual\
    \ base in reference to member 'caseInsensitive'\n    return pattern.stringByReplacingOccurrencesOfString(\"\
    A\", withString: \"a\", options: .caseInsensitive, range: nil)\n             \
    \                                                                          ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpegcutl1z.swift:33:113: error: 'nil' requires a contextual type\n    return\
    \ pattern.stringByReplacingOccurrencesOfString(\"A\", withString: \"a\", options:\
    \ .caseInsensitive, range: nil)\n                                            \
    \                                                 "
  stdout: ''
  timestamp: 1659978720
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // TODO:\
    \ Write this function\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpmp5pl1va/tmpmp5pl1va.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29cf9e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29cf6d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29cf6d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29cf6d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmp5pl1va                        0x000055f203e2a307 <unavailable> + 4871

    5    libc.so.6                          0x00002b29cfbcc460 __libc_start_main +
    245

    6    tmpmp5pl1va                        0x000055f203e29f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.characters.map {\n        Character($0).isUppercase ? \n           \
    \ Character($0).lowercased : \n            Character($0).uppercased }\n      \
    \  .joined()\n        .replacingOccurrences(of: \"a\", with: \"A\")\n        .replacingOccurrences(of:\
    \ \"e\", with: \"E\")\n        .replacingOccurrences(of: \"i\", with: \"I\")\n\
    \        .replacingOccurrences(of: \"o\", with: \"O\")\n        .replacingOccurrences(of:\
    \ \"u\", with: \"U\")\n        .replacingOccurrences(of: \"y\", with: \"Y\")\n\
    \        .replacingOccurrences(of: \"1\", with: \"J\")\n        .replacingOccurrences(of:\
    \ \"2\", with: \"K\")\n        .replacingOccurrences(of: \"3\", with: \"L\")\n\
    \        .replacingOccurrences(of: \"4\", with: \"M\")\n        .replacingOccurrences(of:\
    \ \"5\", with: \"N\")\n        .replacingOccurrences(of: \"6\", with: \"O\")\n\
    \        .replacingOccurrences(of: \"7\", with: \"P\")\n        .replacingOccurrences(of:\
    \ \"8\", with: \"Q\")\n        .replacingOccurrences(of: \"9\", with: \"R\")\n\
    \        .replacingOccurrences(of: \"0\", with: \"S\")\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpjn4r8cos.swift:18:10: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        .replacingOccurrences(of: \"a\", with: \"A\"\
    )\n         ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjn4r8cos.swift:14:19: error: missing\
    \ argument label 'extendedGraphemeClusterLiteral:' in call\n        Character($0).isUppercase\
    \ ? \n                  ^\n                  extendedGraphemeClusterLiteral: \n\
    /tmp/tmpjn4r8cos.swift:15:23: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n            Character($0).lowercased : \n                      ^\n\
    \                      extendedGraphemeClusterLiteral: \n/tmp/tmpjn4r8cos.swift:16:23:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \          Character($0).uppercased }\n                      ^\n             \
    \         extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let vowels\
    \ = \"aeiouAEIOU\"\n    let firstLetters = message.unicodeScalars.filter({ $0.isLetter\
    \ == true })\n    var newMessage = message\n    for firstLetter in firstLetters\
    \ {\n        var index = firstLetter.value - 65\n        newMessage = String(newMessage.characters.dropLast())\n\
    \        if let nextLetter = firstLetters.next() {\n            if nextLetter.value\
    \ == index {\n                index = nextLetter.value - 65\n            }\n \
    \       }\n        newMessage = String(newMessage.characters.prefix(index))\n\
    \        let newIndex = firstLetter.value - 65\n        newMessage = newMessage.replacingOccurrences(of:\
    \ vowels[newIndex], with: firstLetter.value)\n    }\n    return newMessage\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp8vfhpycw.swift:14:59: error: value of type 'Unicode.Scalar' has\
    \ no member 'isLetter'\n    let firstLetters = message.unicodeScalars.filter({\
    \ $0.isLetter == true })\n                                                   \
    \    ~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.characters.reduce(\"\") { \n        (result, c) -> String in\n     \
    \   result += String(UnicodeScalar(c.value).upperCase.first!)\n        switch\
    \ c.value {\n        case 0x6F...0x7A: result += \"AEIOU\"\n        case 0x40...0x47:\
    \ result += \"AEIOU\"\n        case 0x50...0x57: result += \"AEIOU\"\n       \
    \ case 0x60...0x67: result += \"AEIOU\"\n        case 0x40...0x5A: result += \"\
    AEIOU\"\n        case 0x6F...0x6E: result += \"AEIOU\"\n        case 0x40...0x5A:\
    \ result += \"AEIOU\"\n        case 0x40...0x57: result += \"AEIOU\"\n       \
    \ case 0x40...0x53: result += \"AEIOU\"\n        case 0x50...0x5A: result += \"\
    AEIOU\"\n        case 0x40...0x4D: result += \"AEIOU\"\n        case 0x40...0x59:\
    \ result += \"AEIOU\"\n        case 0x6F...0x6D: result += \"AEIOU\"\n       \
    \ case 0x40...0x4D: result += \"AEIOU\"\n        case 0x40...0x49: result += \"\
    AEIOU\"\n        case 0x40...0x59: result += \"AEIOU\"\n        case 0x40...0x4F:\
    \ result += \"AEIOU\"\n        case 0x6F...0x7A: result += \"AEIOU\"\n       \
    \ case 0x40...0x57: result += \"AEIOU\"\n        case 0x40...0x53: result += \"\
    AEIOU\"\n        case 0x40...0x4D: result += \"AEIOU\"\n        case 0x40...0x49:\
    \ result += \"AEIOU\"\n        case 0x40...0x59: result += \"AEIOU\"\n       \
    \ case 0x40...0x4F: result += \"AEIOU\"\n        case 0x40...0x59: result += \"\
    AEIOU\"\n        case 0x6F...0x6F: result += \"AEIOU\"\n        case 0x40...0x53:\
    \ result += \"AEIOU\"\n        case 0x6F...0x6F: result += \"AEIOU\"\n       \
    \ case 0x40...0x4D: result += \"AEIOU\"\n        case 0x6F...0x6F: result += \"\
    AEIOU\"\n        case 0x40...0x59: result += \"AEIOU\"\n        case 0x6F\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpslbx2h6w.swift:48:18: error: expected ':' after 'case'\n      \
    \  case 0x6F\n                 ^\n/tmp/tmpslbx2h6w.swift:68:84: error: expected\
    \ '}' at end of closure\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\"\
    ) == \"k dQnT kNqW wHcT Tq wRkTg\")\n                                        \
    \                                           ^\n/tmp/tmpslbx2h6w.swift:13:42: note:\
    \ to match this opening '{'\n    return message.characters.reduce(\"\") { \n \
    \                                        ^\n/tmp/tmpslbx2h6w.swift:68:84: error:\
    \ expected '}' at end of brace statement\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\n                       \
    \                                                            ^\n/tmp/tmpslbx2h6w.swift:12:40:\
    \ note: to match this opening '{'\nfunc encode(message: String) -> String {\n\
    \                                       ^\n/tmp/tmpslbx2h6w.swift:13:37: error:\
    \ missing argument label 'into:' in call\n    return message.characters.reduce(\"\
    \") { \n                                    ^\n                              \
    \       into: \n/tmp/tmpslbx2h6w.swift:13:31: error: cannot convert return expression\
    \ of type '(_, _) -> String' to return type 'String'\n    return message.characters.reduce(\"\
    \") { \n           ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~\n/tmp/tmpslbx2h6w.swift:15:49:\
    \ error: reference to member 'upperCase' cannot be resolved without a contextual\
    \ type\n        result += String(UnicodeScalar(c.value).upperCase.first!)\n  \
    \                                              ^\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let newString\
    \ = message\n        .unicodeScalars\n        .map { character in\n          \
    \  if let character = character {\n                if character.value > 0xFF {\n\
    \                    return \"\"\n                }\n                \n      \
    \          let previousChar = String(character.value - 1)\n                let\
    \ nextChar = String(character.value + 1)\n                let vowel = Vowels().firstIndex(of:\
    \ previousChar)\n                \n                switch vowel {\n          \
    \      case nil:\n                    return String(character)\n             \
    \   case let .none:\n                    return \"\"\n                case let\
    \ .some(i):\n                    let nextVowel = Vowels().firstIndex(of: nextChar)\n\
    \                    let vowelIndex = i + vowel\n                    let vowelIndex\
    \ = vowelIndex % 26\n                    let vowelIndex = Character(unicodeScalar:\
    \ UInt8(Int(65) + vowelIndex))\n                    let index = vowelIndex - nextVowel\
    \ + 1\n                    let index = String(index)\n                    \n \
    \                   if let nextVowelIndex = nextVowel {\n                    \
    \    index = String(nextVowelIndex - index)\n                    }\n         \
    \           \n                    return index\n                }\n          \
    \  }\n            return \"\"\n        }\n        .joined()\n        .replacingOccurrences(of:\
    \ \"A\", with: Vowels().firstIndex(of: \"a\"))\n        .replacingOccurrences(of:\
    \ \"E\", with: Vowels().firstIndex(of: \"e\"))\n        .replacingOccurrences(of:\
    \ \"I\", with: Vowels().firstIndex(of: \"i\"))\n        .replacingOccurrences(of:\
    \ \"O\", with: Vowels().firstIndex(of: \"o\"))\n        .replacingOccurrences(of:\
    \ \"U\", with: Vowels().firstIndex(of: \"u\"))\n        \n    return newString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4i970za2.swift:23:29: error: cannot find 'Vowels' in scope\n  \
    \              let vowel = Vowels().firstIndex(of: previousChar)\n           \
    \                 ^~~~~~\n/tmp/tmp4i970za2.swift:31:37: error: cannot find 'Vowels'\
    \ in scope\n                    let nextVowel = Vowels().firstIndex(of: nextChar)\n\
    \                                    ^~~~~~\n/tmp/tmp4i970za2.swift:48:46: error:\
    \ cannot find 'Vowels' in scope\n        .replacingOccurrences(of: \"A\", with:\
    \ Vowels().firstIndex(of: \"a\"))\n                                          \
    \   ^~~~~~\n/tmp/tmp4i970za2.swift:49:46: error: cannot find 'Vowels' in scope\n\
    \        .replacingOccurrences(of: \"E\", with: Vowels().firstIndex(of: \"e\"\
    ))\n                                             ^~~~~~\n/tmp/tmp4i970za2.swift:50:46:\
    \ error: cannot find 'Vowels' in scope\n        .replacingOccurrences(of: \"I\"\
    , with: Vowels().firstIndex(of: \"i\"))\n                                    \
    \         ^~~~~~\n/tmp/tmp4i970za2.swift:51:46: error: cannot find 'Vowels' in\
    \ scope\n        .replacingOccurrences(of: \"O\", with: Vowels().firstIndex(of:\
    \ \"o\"))\n                                             ^~~~~~\n/tmp/tmp4i970za2.swift:52:46:\
    \ error: cannot find 'Vowels' in scope\n        .replacingOccurrences(of: \"U\"\
    , with: Vowels().firstIndex(of: \"u\"))\n                                    \
    \         ^~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var newString\
    \ = \"\"\n    let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \    var nextVowelIndex = Int(arc4random_uniform(UInt32(vowels.count)))\n    \n\
    \    for char in message {\n        if char == char.lowercaseString {\n      \
    \      newString += char\n        } else if char.lowercaseString == char {\n \
    \           newString += char\n        } else {\n            newString += vowels[nextVowelIndex]\n\
    \            nextVowelIndex += 1\n            if nextVowelIndex >= UInt32(vowels.count)\
    \ {\n                nextVowelIndex = 0\n            }\n        }\n    }\n   \
    \ return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmppxk9cm0j.swift:15:30: error: cannot find 'arc4random_uniform' in\
    \ scope\n    var nextVowelIndex = Int(arc4random_uniform(UInt32(vowels.count)))\n\
    \                             ^~~~~~~~~~~~~~~~~~\n/tmp/tmppxk9cm0j.swift:18:25:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n        if\
    \ char == char.lowercaseString {\n                   ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmppxk9cm0j.swift:19:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            newString += char\n                         ^\n/tmp/tmppxk9cm0j.swift:20:24:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n        }\
    \ else if char.lowercaseString == char {\n                  ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmppxk9cm0j.swift:21:26: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            newString += char\n        \
    \                 ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var newMessage\
    \ = \"\"\n    for i in 0..<message.length {\n        var newCharacter = message[i]\n\
    \        var replacedCharacter = \"\"\n        for _ in 0..<2 {\n            replacedCharacter\
    \ = newCharacter\n            let index = Int(newCharacter) - Int(newCharacter)\
    \ + Int(i)\n            newCharacter = String(Int(english[index])) \n        \
    \    if newCharacter != replacedCharacter {\n                break\n         \
    \   }\n        }\n        newMessage += String(replacedCharacter)\n    }\n   \
    \ return newMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp5qu76h2w.swift:14:26: error: value of type 'String' has no member\
    \ 'length'\n    for i in 0..<message.length {\n                 ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tvar result\
    \ = \"\"\n\tfor letter in message {\n\t\tswitch letter  {\n\t\tcase \"A\":\n\t\
    \t\tresult += \"B\"\n\t\tcase \"B\":\n\t\t\tresult += \"A\"\n\t\tcase \"C\":\n\
    \t\t\tresult += \"D\"\n\t\tcase \"D\":\n\t\t\tresult += \"C\"\n\t\tcase \"E\"\
    :\n\t\t\tresult += \"F\"\n\t\tcase \"F\":\n\t\t\tresult += \"E\"\n\t\tcase \"\
    G\":\n\t\t\tresult += \"H\"\n\t\tcase \"H\":\n\t\t\tresult += \"G\"\n\t\tcase\
    \ \"I\":\n\t\t\tresult += \"J\"\n\t\tcase \"J\":\n\t\t\tresult += \"I\"\n\t\t\
    case \"K\":\n\t\t\tresult += \"L\"\n\t\tcase \"L\":\n\t\t\tresult += \"K\"\n\t\
    \tcase \"M\":\n\t\t\tresult += \"N\"\n\t\tcase \"N\":\n\t\t\tresult += \"M\"\n\
    \t\tcase \"O\":\n\t\t\tresult += \"P\"\n\t\tcase \"P\":\n\t\t\tresult += \"O\"\
    \n\t\tcase \"Q\":\n\t\t\tresult += \"R\"\n\t\tcase \"R\":\n\t\t\tresult += \"\
    Q\"\n\t\tcase \"S\":\n\t\t\tresult += \"T\"\n\t\tcase \"T\":\n\t\t\tresult +=\
    \ \"S\"\n\t\tcase \"U\":\n\t\t\tresult += \"V\"\n\t\tcase \"V\":\n\t\t\tresult\
    \ += \"U\"\n\t\tcase \"W\":\n\t\t\tresult += \"X\"\n\t\tcase \"X\":\n\t\t\tresult\
    \ += \"W\"\n\t\tcase \"Y\":\n\t\t\tresult += \"Z\"\n\t\tcase \"Z\":\n\t\t\tresult\
    \ += \"Y\"\n\t\tdefault:\n\t\t\tresult += letter\n\t\t}\n\t}\n\treturn result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpq_m3mnz4.swift:69:14: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                        result += letter\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tvar result\
    \ : String = \"\"\n\tfor index in 0..<message.characters.count {\n\t\tvar letter\
    \ = message.characters[index]\n\t\tif let vowel = vowels.index(of: letter) {\n\
    \t\t\tvar replacement = String(letters[vowel + 1])\n\t\t\tresult += replacement\n\
    \t\t}\n\t\telse {\n\t\t\tresult += letter\n\t\t}\n\t}\n\treturn result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpkan2jx9h.swift:14:27: error: 'characters' is unavailable: Please\
    \ use String directly\n        for index in 0..<message.characters.count {\n \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpkan2jx9h.swift:15:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       var letter = message.characters[index]\n                             ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkan2jx9h.swift:15:24:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \     var letter = message.characters[index]\n                               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpkan2jx9h.swift:16:18:\
    \ error: cannot find 'vowels' in scope\n                if let vowel = vowels.index(of:\
    \ letter) {\n                               ^~~~~~\n/tmp/tmpkan2jx9h.swift:17:29:\
    \ error: cannot find 'letters' in scope\n                        var replacement\
    \ = String(letters[vowel + 1])\n                                             \
    \    ^~~~~~~\n/tmp/tmpkan2jx9h.swift:21:14: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n                        result\
    \ += letter\n                                  ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    let\
    \ vowels = \"aeiouAEIOU\"\n    var result = \"\"\n    \n    for i in 0 ..< message.characters.count\
    \ {\n        let letter = String(message.characters[i])\n        if let vowelIndex\
    \ = vowels.firstIndex(of: letter) {\n            var letterIndex = 0\n       \
    \     while letterIndex < vowelIndex {\n                letterIndex += 1\n   \
    \         }\n            result.append(String(message.characters[vowelIndex +\
    \ letterIndex]))\n        } else {\n            result.append(letter)\n      \
    \  }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpasoq0h6f.swift:17:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0 ..< message.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpasoq0h6f.swift:18:29: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let letter\
    \ = String(message.characters[i])\n                            ^~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpasoq0h6f.swift:18:37:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ letter = String(message.characters[i])\n                                   \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpasoq0h6f.swift:19:51:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        if let vowelIndex = vowels.firstIndex(of: letter)\
    \ {\n                                                  ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message\n        .unicodeScalars\n        .filter{ $0.value != 0}\n        .map{\
    \ String($0) }\n        .joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpgb4r_8fa/tmpgb4r_8fa.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e7c7b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e7c4a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e7c4a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e7c4a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgb4r_8fa                        0x00005564200ae6d7 <unavailable> + 5847

    5    libc.so.6                          0x00002b8e7c99c460 __libc_start_main +
    245

    6    tmpgb4r_8fa                        0x00005564200ae319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let alphabet\
    \ = CharacterSet.letters\n    return message.uppercased()\n        .fold(\"\"\
    ) { buffer, letter in\n            let index = alphabet.index(of: letter)!\n \
    \           let substr = String(alphabet[index].description).replacingOccurrences(of:\
    \ \"V\", with: \"\")\n            return String(buffer.dropLast() + substr + buffer)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpp01wsfh2.swift:13:20: error: cannot find 'CharacterSet' in scope\n\
    \    let alphabet = CharacterSet.letters\n                   ^~~~~~~~~~~~\n/tmp/tmpp01wsfh2.swift:15:10:\
    \ error: value of type 'String' has no member 'fold'\n        .fold(\"\") { buffer,\
    \ letter in\n         ^~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n\n    for char in message {\n        let index = english.index(of: char)\
    \ // get the index of the letter \n        let replacement = english[index! +\
    \ 2]\n\n        result = result + replacement!\n    }\n\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpowlcia89.swift:16:21: error: cannot find 'english' in scope\n \
    \       let index = english.index(of: char) // get the index of the letter \n\
    \                    ^~~~~~~\n/tmp/tmpowlcia89.swift:17:27: error: cannot find\
    \ 'english' in scope\n        let replacement = english[index! + 2]\n        \
    \                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encMessage\
    \ = \"\"\n    for letter in message {\n        switch letter {\n        case \"\
    A\":\n            encMessage += \"G\"\n        case \"E\":\n            encMessage\
    \ += \"H\"\n        case \"I\":\n            encMessage += \"J\"\n        case\
    \ \"O\":\n            encMessage += \"K\"\n        case \"U\":\n            encMessage\
    \ += \"U\"\n        default:\n            encMessage += letter\n        }\n  \
    \  }\n    return encMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp1rhllpy2.swift:27:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            encMessage += letter\n     \
    \                     ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\treturn message.map{\
    \ e in\n\t\tlet idx = english.indexOf(e)\n\t\treturn idx != -1 ? english[idx +\
    \ 2] : e\n\t}.join()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpfbo0g291.swift:14:13: error: cannot find 'english' in scope\n \
    \               let idx = english.indexOf(e)\n                          ^~~~~~~\n\
    /tmp/tmpfbo0g291.swift:15:22: error: cannot find 'english' in scope\n        \
    \        return idx != -1 ? english[idx + 2] : e\n                           \
    \        ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Return\
    \ the empty string if the input message is empty.\n    if message == \"\" {\n\
    \        return \"\"\n    }\n    // Initialize a string builder to hold our encoded\
    \ message.\n    let encodedStringBuilder = StringBuilder()\n    \n    // Initialize\
    \ a variable to hold the last letter we encounter in the input.\n    var lastLetterEncountered\
    \ = \"\"\n    \n    // Iterate over the input string.\n    for letter in message\
    \ {\n        // If the last letter we encountered is equal to the current letter.\n\
    \        if lastLetterEncountered == letter {\n            // Increment the index\
    \ of the last letter we encountered.\n            lastLetterEncountered = String(lastLetterEncountered.lowercased())\n\
    \            lastLetterEncountered += String(letter)\n        } else {\n     \
    \       // If it isn't, increment the index of the last letter we encountered.\n\
    \            lastLetterEncountered += String(letter)\n        }\n        // Append\
    \ the current letter to the encoded string.\n        encodedStringBuilder.append(lastLetterEncountered)\n\
    \    }\n    \n    // Return the encoded string.\n    return encodedStringBuilder.toString()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpemhx2igh.swift:18:32: error: cannot find 'StringBuilder' in scope\n\
    \    let encodedStringBuilder = StringBuilder()\n                            \
    \   ^~~~~~~~~~~~~\n/tmp/tmpemhx2igh.swift:26:34: error: binary operator '==' cannot\
    \ be applied to operands of type 'String' and 'Character'\n        if lastLetterEncountered\
    \ == letter {\n           ~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~\n/tmp/tmpemhx2igh.swift:26:34:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if lastLetterEncountered ==\
    \ letter {\n                                 ^\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    var index = 0\n    for letter in message {\n        var replacement\
    \ = nil\n        if index == 0 { // first letter\n            replacement = english[letter]\n\
    \        } else if index == message.count { // last letter\n            replacement\
    \ = english[message.characters.count - 1]\n        } else {\n            let prev\
    \ = message.substringWithRange(NSMakeRange(index - 1, 1))\n            let next\
    \ = message.substringWithRange(NSMakeRange(index + 1, 1))\n            replacement\
    \ = english[english.indexOfElement(prev) + english.indexOfElement(next)]\n   \
    \     }\n        result += replacement\n        index++\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp7mr_koxt.swift:16:27: error: 'nil' requires a contextual type\n\
    \        var replacement = nil\n                          ^\n/tmp/tmp7mr_koxt.swift:18:27:\
    \ error: cannot find 'english' in scope\n            replacement = english[letter]\n\
    \                          ^~~~~~~\n/tmp/tmp7mr_koxt.swift:20:27: error: cannot\
    \ find 'english' in scope\n            replacement = english[message.characters.count\
    \ - 1]\n                          ^~~~~~~\n/tmp/tmp7mr_koxt.swift:22:51: error:\
    \ cannot find 'NSMakeRange' in scope\n            let prev = message.substringWithRange(NSMakeRange(index\
    \ - 1, 1))\n                                                  ^~~~~~~~~~~\n/tmp/tmp7mr_koxt.swift:22:32:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \   let prev = message.substringWithRange(NSMakeRange(index - 1, 1))\n       \
    \                ~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7mr_koxt.swift:23:51: error:\
    \ cannot find 'NSMakeRange' in scope\n            let next = message.substringWithRange(NSMakeRange(index\
    \ + 1, 1))\n                                                  ^~~~~~~~~~~\n/tmp/tmp7mr_koxt.swift:23:32:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \   let next = message.substringWithRange(NSMakeRange(index + 1, 1))\n       \
    \                ~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7mr_koxt.swift:24:27: error:\
    \ cannot find 'english' in scope\n            replacement = english[english.indexOfElement(prev)\
    \ + english.indexOfElement(next)]\n                          ^~~~~~~\n/tmp/tmp7mr_koxt.swift:24:35:\
    \ error: cannot find 'english' in scope\n            replacement = english[english.indexOfElement(prev)\
    \ + english.indexOfElement(next)]\n                                  ^~~~~~~\n\
    /tmp/tmp7mr_koxt.swift:24:66: error: cannot find 'english' in scope\n        \
    \    replacement = english[english.indexOfElement(prev) + english.indexOfElement(next)]\n\
    \                                                                 ^~~~~~~\n/tmp/tmp7mr_koxt.swift:27:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        inde"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your\
    \ code goes here.\n    var returnString = \"\"\n    for word in message.split(\"\
    \ \") {\n        var nextVowel = -1\n        for letter in word {\n          \
    \  nextVowel = nextVowel == -1 ? 0 : nextVowel + 1\n            if letter != \"\
    a\" && letter != \"e\" && letter != \"i\" && letter != \"o\" && letter != \"u\"\
    \ {\n                let index = (letter == \"k\" ? 0 : (letter == \"c\" ? 1 :\
    \ 2))\n                returnString += String(repeatElement(letter, count: index))\n\
    \            } else {\n                returnString += String(letter)\n      \
    \      }\n        }\n        returnString += \"-\"\n    }\n    return returnString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpv63g5d7x.swift:15:25: error: no exact matches in call to instance\
    \ method 'split'\n    for word in message.split(\" \") {\n                   \
    \     ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    if let\
    \ firstLetter = message.range(of: letters.first) {\n        let index = firstLetter\
    \ + 2\n        let twoLetterAheadIndex = message.range(of: letters.first!, range:\
    \ index)\n\n        var result = \"\"\n\n        for i in 0..<message.characters.count\
    \ {\n            let letterIndex = message.index(before: i)\n            let letter\
    \ = message.character(at: letterIndex)\n\n            if letterIndex == firstLetter,\
    \ letterIndex == twoLetterAheadIndex {\n                let ahead = message.index(letterIndex\
    \ + 1, offsetBy: 1)\n                let twoLetterAhead = message.character(at:\
    \ ahead)\n\n                result += twoLetterAhead\n            } else {\n \
    \               result += letter\n            }\n        }\n\n        return result\n\
    \    }\n\n    return message\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmptrile9pp.swift:13:44: error: cannot find 'letters' in scope\n \
    \   if let firstLetter = message.range(of: letters.first) {\n                \
    \                           ^~~~~~~\n/tmp/tmptrile9pp.swift:13:34: error: value\
    \ of type 'String' has no member 'range'\n    if let firstLetter = message.range(of:\
    \ letters.first) {\n                         ~~~~~~~ ^~~~~\n/tmp/tmptrile9pp.swift:15:53:\
    \ error: cannot find 'letters' in scope\n        let twoLetterAheadIndex = message.range(of:\
    \ letters.first!, range: index)\n                                            \
    \        ^~~~~~~\n/tmp/tmptrile9pp.swift:15:43: error: value of type 'String'\
    \ has no member 'range'\n        let twoLetterAheadIndex = message.range(of: letters.first!,\
    \ range: index)\n                                  ~~~~~~~ ^~~~~\n/tmp/tmptrile9pp.swift:19:30:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ i in 0..<message.characters.count {\n                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptrile9pp.swift:20:53:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \            let letterIndex = message.index(before: i)\n                    \
    \                                ^\n/tmp/tmptrile9pp.swift:21:34: error: value\
    \ of type 'String' has no member 'character'\n            let letter = message.character(at:\
    \ letterIndex)\n                         ~~~~~~~ ^~~~~~~~~\n/tmp/tmptrile9pp.swift:24:55:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \                let ahead = message.index(letterIndex + 1, offsetBy: 1)\n   \
    \                                                   ^\n/tmp/tmptrile9pp.swift:25:46:\
    \ error: value of type 'String' has no member 'character'\n                let\
    \ twoLetterAhead = message.character(at: ahead)\n                            \
    \         ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    let\
    \ messageArray = message.characters\n\n    var outputString = String()\n\n   \
    \ var previousChar = \"\"\n    var previousCharArray = [String]()\n\n    var currentChar\
    \ = \"\"\n    var currentCharArray = [String]()\n\n    for i in 0..<messageArray.count\
    \ {\n        previousChar = messageArray[i]\n        previousCharArray = previousCharArray.append(previousChar)\n\
    \n        for j in 0..<previousCharArray.count {\n            if j == 0 {\n  \
    \              currentChar = previousCharArray[j].lowercased()\n             \
    \   currentCharArray = currentCharArray.append(currentChar)\n            } else\
    \ {\n                currentChar = previousCharArray[j].lowercased()\n       \
    \         currentCharArray = currentCharArray.append(currentChar)\n          \
    \  }\n        }\n    }\n    return currentCharArray.join(\"\")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp6k44htdb.swift:14:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let messageArray = message.characters\n           \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp6k44htdb.swift:25:36: error: cannot assign value of type 'Character'\
    \ to type 'String'\n        previousChar = messageArray[i]\n                 \
    \      ~~~~~~~~~~~~^~~\n/tmp/tmp6k44htdb.swift:26:47: error: cannot assign value\
    \ of type '()' to type '[String]'\n        previousCharArray = previousCharArray.append(previousChar)\n\
    \                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6k44htdb.swift:31:53:\
    \ error: cannot assign value of type '()' to type '[String]'\n               \
    \ currentCharArray = currentCharArray.append(currentChar)\n                  \
    \                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6k44htdb.swift:34:53:\
    \ error: cannot assign value of type '()' to type '[String]'\n               \
    \ currentCharArray = currentCharArray.append(currentChar)\n                  \
    \                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6k44htdb.swift:38:29:\
    \ error: value of type '[String]' has no member 'join'\n    return currentCharArray.join(\"\
    \")\n           ~~~~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ String(message.characters.map { char in\n        let position = Array(message).indexOf(char)\n\
    \        return String(message[position - 2 ... position + 2].map { char in\n\
    \            let vowels = \"aeiou\".characters\n            let vowel = vowels.firstIndex(of:\
    \ char)!\n            return vowels.enumerated().map { index, char in\n      \
    \          index % 2 == 0 ? char : vowels[index]\n            }.joined()\n   \
    \     }.joined())\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpg8or0_gm.swift:14:39: error: value of type '[String.Element]' (aka\
    \ 'Array<Character>') has no member 'indexOf'\n        let position = Array(message).indexOf(char)\n\
    \                       ~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    \n    //\
    \ Make copy of message to encode\n    var copy = message\n    \n    // Iterate\
    \ over letters in message\n    for letter in message.characters {\n        //\
    \ Convert letter to lowercase to check case sensitivity\n        letter.lowercase()\n\
    \        \n        // Check if letter is vowel\n        switch letter {\n    \
    \    case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n    \
    \    case 'u':\n            // If letter is vowel, change vowel to letter 2 places\
    \ ahead of it\n            copy.swapCaseAtIndex(copy.startIndex.advancedBy(1))\n\
    \            break\n        default:\n            // If letter is non-vowel, change\
    \ vowel to letter 2 places ahead of it\n            copy.swapCaseAtIndex(copy.startIndex.advancedBy(1))\n\
    \            break\n        }\n    }\n    return copy\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpvmzx2czx.swift:24:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmpvmzx2czx.swift:24:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmpvmzx2czx.swift:25:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmpvmzx2czx.swift:25:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'e':\n        ^~~~~~~~~\n                  break\n/tmp/tmpvmzx2czx.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'i':\n   \
    \          ^~~\n             \"i\"\n/tmp/tmpvmzx2czx.swift:26:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'i':\n        ^~~~~~~~~\n                  break\n/tmp/tmpvmzx2czx.swift:27:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmpvmzx2czx.swift:27:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'o':\n        ^~~~~~~~~\n                  break\n/tmp/tmpvmzx2czx.swift:28:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'u':\n   \
    \          ^~~\n             \"u\"\n/tmp/tmpvmzx2czx.swift:18:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    for letter in message.characters\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvmzx2czx.swift:20:16: error: value of type 'Character'\
    \ has no member 'lowercase'\n        letter.lowercase()\n        ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpvmzx2czx.swift:30:18: error: value of type 'String' has no member 'swapCaseAtIndex'\n\
    \            copy.swapCaseAtIndex(copy.startIndex.advancedBy(1))\n           \
    \ ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpvmzx2czx.swift:30:50: error: value of type 'String.Index'\
    \ has no member 'advance"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ message.stringBySwappingLetters()\n        .stringByReplacingOccurrencesOfString(\"\
    aeiou\", withString: \"\", options: NSRegularExpressionOptions.CaseInsensitiveSearch,\
    \ range: nil)\n        .stringByReplacingOccurrencesOfString(\"A\", withString:\
    \ \"a\").stringByReplacingOccurrencesOfString(\"E\", withString: \"e\").stringByReplacingOccurrencesOfString(\"\
    I\", withString: \"i\").stringByReplacingOccurrencesOfString(\"O\", withString:\
    \ \"o\").stringByReplacingOccurrencesOfString(\"U\", withString: \"u\").stringByReplacingOccurrencesOfString(\"\
    a\", withString: \"A\").stringByReplacingOccurrencesOfString(\"e\", withString:\
    \ \"E\").stringByReplacingOccurrencesOfString(\"i\", withString: \"I\").stringByReplacingOccurrencesOfString(\"\
    o\", withString: \"O\").stringByReplacingOccurrencesOfString(\"u\", withString:\
    \ \"U\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpc6llsff7.swift:14:81: error: cannot find 'NSRegularExpressionOptions'\
    \ in scope\n        .stringByReplacingOccurrencesOfString(\"aeiou\", withString:\
    \ \"\", options: NSRegularExpressionOptions.CaseInsensitiveSearch, range: nil)\n\
    \                                                                            \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpc6llsff7.swift:13:20: error: value of\
    \ type 'String' has no member 'stringBySwappingLetters'\n    return message.stringBySwappingLetters()\n\
    \           ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpc6llsff7.swift:14:138: error:\
    \ 'nil' requires a contextual type\n        .stringByReplacingOccurrencesOfString(\"\
    aeiou\", withString: \"\", options: NSRegularExpressionOptions.CaseInsensitiveSearch,\
    \ range: nil)\n                                                              \
    \                                                                           ^\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var decodedString\
    \ = message\n    var swapped = false\n    for index in 0..<message.characters.count\
    \ {\n        if message.characters.index(index, offsetBy: 2)! > index {\n    \
    \        if let vowel = String(message.characters[index, offsetBy: 1]) {\n   \
    \             var lastVowel: Character? = nil\n                if let lastVowelIndex\
    \ = message.characters.index(message.characters.endIndex, offsetBy: -1) {\n  \
    \                  lastVowel = String(message.characters[lastVowelIndex])\n  \
    \              }\n                if lastVowel == vowel {\n                  \
    \  if !swapped {\n                        decodedString = decodedString.replacingCharacters(in:\
    \ Range(uncheckedBounds: (lower: index, upper: lastVowelIndex)), with: String(message.characters[index,\
    \ offsetBy: 1]))\n                        swapped = true\n                   \
    \ }\n                } else {\n                    decodedString = decodedString.replacingCharacters(in:\
    \ Range(uncheckedBounds: (lower: index, upper: lastVowelIndex)), with: String(message.characters[index,\
    \ offsetBy: 1]))\n                    decodedString = decodedString.replacingCharacters(in:\
    \ Range(uncheckedBounds: (lower: index, upper: index)), with: vowel)\n       \
    \         }\n            } else {\n                if !swapped {\n           \
    \         decodedString = decodedString.replacingCharacters(in: Range(uncheckedBounds:\
    \ (lower: index, upper: index)), with: String(message.characters[index, offsetBy:\
    \ 1]))\n                    swapped = true\n                }\n            }\n\
    \        }\n    }\n    return decodedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpck083cov.swift:15:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<message.characters.count {\n     \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpck083cov.swift:16:37: error: cannot convert value of type\
    \ 'Int' to expected argument type 'String.Index'\n        if message.characters.index(index,\
    \ offsetBy: 2)! > index {\n                                    ^\n/tmp/tmpck083cov.swift:16:58:\
    \ error: referencing operator function '>' on 'BinaryInteger' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n        if message.characters.index(index, offsetBy:\
    \ 2)! > index {\n                                                         ^\n\
    Swift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\nextension BinaryInteger\
    \ {\n          ^\n/tmp/tmpck083cov.swift:17:71: error: extra argument 'offsetBy'\
    \ in call\n            if let vowel = String(message.characters[index, offsetBy:\
    \ 1]) {\n                                                    ~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmpck083cov.swift:19:49: error: 'characters' is unavailable: Please use String\
    \ directly\n                if let lastVowelIndex = message.characters.index(message.characters.endIndex,\
    \ offsetBy: -1) {\n                                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpck083cov.swift:19:74:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \     if let lastVowelIndex = message.characters.index(message.characters.endIndex,\
    \ offsetBy: -1) {\n                                                          \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpck083cov.swift:20:31: error: cannot assign value of type 'String'\
    \ to type 'Character?'\n                    lastVowel"
  stdout: ''
  timestamp: 1659978721
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // write\
    \ your solution here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpmom4ha0o/tmpmom4ha0o.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f45595c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f4528cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f4528c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f4528b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmom4ha0o                        0x000056263369e307 <unavailable> + 4871

    5    libc.so.6                          0x00002b7f45781460 __libc_start_main +
    245

    6    tmpmom4ha0o                        0x000056263369df49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for i in 0..<message.count {\n        let letter = message[i]\n\
    \        let idx = alphabet.index(letter)\n        if idx != nil {\n         \
    \   let a = alphabet[idx!]\n            let b = alphabet[(idx + 1) % alphabet.count]\n\
    \            let c = alphabet[(idx + 2) % alphabet.count]\n            result\
    \ += a + \"-\" + b + \"-\" + c\n        } else {\n            result += letter\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp4zwec2f1.swift:15:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let letter\
    \ = message[i]\n                     ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp4zwec2f1.swift:16:19: error: cannot\
    \ find 'alphabet' in scope\n        let idx = alphabet.index(letter)\n       \
    \           ^~~~~~~~\n/tmp/tmp4zwec2f1.swift:18:21: error: cannot find 'alphabet'\
    \ in scope\n            let a = alphabet[idx!]\n                    ^~~~~~~~\n\
    /tmp/tmp4zwec2f1.swift:19:21: error: cannot find 'alphabet' in scope\n       \
    \     let b = alphabet[(idx + 1) % alphabet.count]\n                    ^~~~~~~~\n\
    /tmp/tmp4zwec2f1.swift:19:42: error: cannot find 'alphabet' in scope\n       \
    \     let b = alphabet[(idx + 1) % alphabet.count]\n                         \
    \                ^~~~~~~~\n/tmp/tmp4zwec2f1.swift:20:21: error: cannot find 'alphabet'\
    \ in scope\n            let c = alphabet[(idx + 2) % alphabet.count]\n       \
    \             ^~~~~~~~\n/tmp/tmp4zwec2f1.swift:20:42: error: cannot find 'alphabet'\
    \ in scope\n            let c = alphabet[(idx + 2) % alphabet.count]\n       \
    \                                  ^~~~~~~~\n/tmp/tmp4zwec2f1.swift:23:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += letter\n                      ^\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    return message.\n\
    \        chars().\n        filter({ char in alphabet }).\n        map({ char,\
    \ index in alphabet.characters.enumerated().\n            reduce(String.init(),\
    \ { $0 + String(alphabet[$1.element - 1 + index])}).\n            characters.shuffled().\n\
    \            reduce(String.init(), { $0 + String(alphabet[$1.element - 1 + $1.index])})}).\n\
    \        reduce(String.init(), { $0 + String(alphabet[$1.element - 1])})\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp1tfwk8ib.swift:14:19: error: expected member name following '.'\n\
    \    return message.\n                  ^\n/tmp/tmp1tfwk8ib.swift:15:16: error:\
    \ expected member name following '.'\n        chars().\n               ^\n/tmp/tmp1tfwk8ib.swift:16:37:\
    \ error: expected member name following '.'\n        filter({ char in alphabet\
    \ }).\n                                    ^\n/tmp/tmp1tfwk8ib.swift:17:62: error:\
    \ expected member name following '.'\n        map({ char, index in alphabet.characters.enumerated().\n\
    \                                                             ^\n/tmp/tmp1tfwk8ib.swift:18:84:\
    \ error: expected member name following '.'\n            reduce(String.init(),\
    \ { $0 + String(alphabet[$1.element - 1 + index])}).\n                       \
    \                                                            ^\n/tmp/tmp1tfwk8ib.swift:19:34:\
    \ error: expected member name following '.'\n            characters.shuffled().\n\
    \                                 ^\n/tmp/tmp1tfwk8ib.swift:20:89: error: expected\
    \ member name following '.'\n            reduce(String.init(), { $0 + String(alphabet[$1.element\
    \ - 1 + $1.index])})}).\n                                                    \
    \                                    ^\n/tmp/tmp1tfwk8ib.swift:21:9: error: cannot\
    \ find 'reduce' in scope\n        reduce(String.init(), { $0 + String(alphabet[$1.element\
    \ - 1])})\n        ^~~~~~\n"
  stdout: ''
  timestamp: 1659978725
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ encode(message: message, alphabet: EnglishAlphabet)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpav3y8wzf.swift:13:47: error: cannot find 'EnglishAlphabet' in scope\n\
    \    return encode(message: message, alphabet: EnglishAlphabet)\n            \
    \                                  ^~~~~~~~~~~~~~~\n/tmp/tmpav3y8wzf.swift:13:47:\
    \ error: extra argument 'alphabet' in call\n    return encode(message: message,\
    \ alphabet: EnglishAlphabet)\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    return\
    \ String(\n        zip(message.lowercased(), \n             count(message.lowercased(),\
    \ letterToIndex(letters.lowercased()))\n            .map { \n                index,\
    \ count in\n                if count == 2 {\n                    index.successor().lowercased()\n\
    \                } else { \n                    index.lowercased()\n         \
    \       }\n            })\n            .reduce(message) { $0 + ($1 < $2 ? letters[$1.successor()]\
    \ : letters[$1]) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encode(message: \"\
    TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpm9w5993e.swift:15:14: error: cannot find 'count' in scope\n   \
    \          count(message.lowercased(), letterToIndex(letters.lowercased()))\n\
    \             ^~~~~\n/tmp/tmpm9w5993e.swift:15:42: error: cannot find 'letterToIndex'\
    \ in scope\n             count(message.lowercased(), letterToIndex(letters.lowercased()))\n\
    \                                         ^~~~~~~~~~~~~\n/tmp/tmpm9w5993e.swift:15:56:\
    \ error: cannot find 'letters' in scope\n             count(message.lowercased(),\
    \ letterToIndex(letters.lowercased()))\n                                     \
    \                  ^~~~~~~\n/tmp/tmpm9w5993e.swift:24:48: error: cannot find 'letters'\
    \ in scope\n            .reduce(message) { $0 + ($1 < $2 ? letters[$1.successor()]\
    \ : letters[$1]) })\n                                               ^~~~~~~\n\
    /tmp/tmpm9w5993e.swift:24:74: error: cannot find 'letters' in scope\n        \
    \    .reduce(message) { $0 + ($1 < $2 ? letters[$1.successor()] : letters[$1])\
    \ })\n                                                                       \
    \  ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: -4
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Write\
    \ your code here\n    return message\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\"\
    ) == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: Exception
  stderr: 'tmpuaacht07/tmpuaacht07.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b009e221c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b009df18b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b009df18988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b009df177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuaacht07                        0x0000561ff17fb307 <unavailable> + 4871

    5    libc.so.6                          0x00002b009e40d460 __libc_start_main +
    245

    6    tmpuaacht07                        0x0000561ff17faf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\".characters.map { String($0) }\n    let vowels\
    \ = \"aeiou\".characters.map { String($0) }\n    return message.characters.map\
    \ { $0.isUpperCase ? String(alphabet[$0.unicodeScalars.first - vowels.unicodeScalars.first!.unicodeScalars.first\
    \ + vowels.unicodeScalars.last!.unicodeScalars.first!] ?? $0.unicodeScalars.first!)\
    \ : String(alphabet[$0.unicodeScalars.first - vowels.unicodeScalars.first!.unicodeScalars.first!]\
    \ ?? $0.unicodeScalars.first!) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp5em5sl4e.swift:13:49: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".characters.map\
    \ { String($0) }\n                                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5em5sl4e.swift:14:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let vowels\
    \ = \"aeiou\".characters.map { String($0) }\n                         ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5em5sl4e.swift:15:12:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n    return message.characters.map\
    \ { $0.isUpperCase ? String(alphabet[$0.unicodeScalars.first - vowels.unicodeScalars.first!.unicodeScalars.first\
    \ + vowels.unicodeScalars.last!.unicodeScalars.first!] ?? $0.unicodeScalars.first!)\
    \ : String(alphabet[$0.unicodeScalars.first - vowels.unicodeScalars.first!.unicodeScalars.first!]\
    \ ?? $0.unicodeScalars.first!) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978793
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var output\
    \ = \"\"\n    for letter in message {\n        var lowercaseLetter = letter\n\
    \        var vowels = \"\"\n        var i = lowercase.count - 1\n        while\
    \ i != -1 {\n            vowels = lowercase[i] + vowels\n            lowercase.removeAtIndex(i\
    \ - 1)\n            i -= 1\n        }\n        var i2 = lowercase.count - 1\n\
    \        while i2 != -1 {\n            lowercaseLetter = lowercaseLetter + lowercase[i2]\n\
    \            i2--\n        }\n        output = lowercaseLetter + vowels + output\n\
    \    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpk0d35vwo.swift:17:17: error: cannot find 'lowercase' in scope\n\
    \        var i = lowercase.count - 1\n                ^~~~~~~~~\n/tmp/tmpk0d35vwo.swift:19:22:\
    \ error: cannot find 'lowercase' in scope\n            vowels = lowercase[i] +\
    \ vowels\n                     ^~~~~~~~~\n/tmp/tmpk0d35vwo.swift:20:13: error:\
    \ cannot find 'lowercase' in scope\n            lowercase.removeAtIndex(i - 1)\n\
    \            ^~~~~~~~~\n/tmp/tmpk0d35vwo.swift:23:18: error: cannot find 'lowercase'\
    \ in scope\n        var i2 = lowercase.count - 1\n                 ^~~~~~~~~\n\
    /tmp/tmpk0d35vwo.swift:25:49: error: cannot find 'lowercase' in scope\n      \
    \      lowercaseLetter = lowercaseLetter + lowercase[i2]\n                   \
    \                             ^~~~~~~~~\n/tmp/tmpk0d35vwo.swift:25:47: error:\
    \ binary operator '+' cannot be applied to operands of type 'Character' and 'String'\n\
    \            lowercaseLetter = lowercaseLetter + lowercase[i2]\n             \
    \                 ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmpk0d35vwo.swift:25:47:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (ContinuousClock.Instant, Duration), (Double, Double), (Duration, Duration),\
    \ (Float, Float), (Float16, Float16), (Float80, Float80), (Int, Int), (Int16,\
    \ Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (String, String), (SuspendingClock.Instant,\
    \ Duration), (UInt, UInt), (UInt16, UInt16), (UInt32, UInt32), (UInt64, UInt64),\
    \ (UInt8, UInt8)\n            lowercaseLetter = lowercaseLetter + lowercase[i2]\n\
    \                                              ^\n/tmp/tmpk0d35vwo.swift:25:47:\
    \ error: no '+' candidates produce the expected contextual result type 'Character'\n\
    \            lowercaseLetter = lowercaseLetter + lowercase[i2]\n             \
    \                                 ^\nSwift.String:2:35: note: '+' produces 'String',\
    \ not the expected contextual result type 'Character'\n    @inlinable public static\
    \ func + (lhs: String, rhs: String) -> String\n                              \
    \    ^\nSwift.Duration:6:24: note: '+' produces 'Duration', not the expected contextu"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n\tvar result\
    \ = \"\"\n\tfor i : Int in 0..<message.count {\n\t\tswitch message[i] {\n\t\t\
    case \"A\":\n\t\t\tresult += \"t\"\n\t\tcase \"B\":\n\t\t\tresult += \"g\"\n\t\
    \tcase \"C\":\n\t\t\tresult += \"k\"\n\t\tcase \"D\":\n\t\t\tresult += \"s\"\n\
    \t\tcase \"E\":\n\t\t\tresult += \"h\"\n\t\tcase \"F\":\n\t\t\tresult += \"v\"\
    \n\t\tcase \"G\":\n\t\t\tresult += \"r\"\n\t\tcase \"H\":\n\t\t\tresult += \"\
    x\"\n\t\tcase \"I\":\n\t\t\tresult += \"a\"\n\t\tcase \"J\":\n\t\t\tresult +=\
    \ \"m\"\n\t\tcase \"K\":\n\t\t\tresult += \"n\"\n\t\tcase \"L\":\n\t\t\tresult\
    \ += \"q\"\n\t\tcase \"M\":\n\t\t\tresult += \"u\"\n\t\tcase \"N\":\n\t\t\tresult\
    \ += \"w\"\n\t\tcase \"O\":\n\t\t\tresult += \"v\"\n\t\tcase \"P\":\n\t\t\tresult\
    \ += \"z\"\n\t\tcase \"Q\":\n\t\t\tresult += \"h\"\n\t\tcase \"R\":\n\t\t\tresult\
    \ += \"w\"\n\t\tcase \"S\":\n\t\t\tresult += \"h\"\n\t\tcase \"T\":\n\t\t\tresult\
    \ += \"g\"\n\t\tcase \"U\":\n\t\t\tresult += \"z\"\n\t\tcase \"V\":\n\t\t\tresult\
    \ += \"x\"\n\t\tcase \"W\":\n\t\t\tresult += \"t\"\n\t\tcase \"X\":\n\t\t\tresult\
    \ += \"b\"\n\t\tcase \"Y\":\n\t\t\tresult += \"h\"\n\t\tcase \"Z\":\n\t\t\tresult\
    \ += \"j\"\n\t\tdefault:\n\t\t\tresult += String(message[i])\n\t\t}\n\t}\n\treturn\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpw6gbn62y.swift:15:10: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n                switch\
    \ message[i] {\n                       ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpw6gbn62y.swift:69:21: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                        result += String(message[i])\n                      \
    \                   ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    for letter in message {\n        var newLetter = \"\"\n        switch\
    \ letter {\n        case \"A\":\n            newLetter = \"T\"\n        case \"\
    B\":\n            newLetter = \"G\"\n        case \"C\":\n            newLetter\
    \ = \"C\"\n        case \"D\":\n            newLetter = \"K\"\n        case \"\
    E\":\n            newLetter = \"S\"\n        case \"F\":\n            newLetter\
    \ = \"S\"\n        case \"G\":\n            newLetter = \"G\"\n        case \"\
    H\":\n            newLetter = \"H\"\n        case \"I\":\n            newLetter\
    \ = \"K\"\n        case \"J\":\n            newLetter = \"K\"\n        case \"\
    K\":\n            newLetter = \"K\"\n        case \"L\":\n            newLetter\
    \ = \"L\"\n        case \"M\":\n            newLetter = \"M\"\n        case \"\
    N\":\n            newLetter = \"N\"\n        case \"O\":\n            newLetter\
    \ = \"O\"\n        case \"P\":\n            newLetter = \"P\"\n        case \"\
    Q\":\n            newLetter = \"K\"\n        case \"R\":\n            newLetter\
    \ = \"R\"\n        case \"S\":\n            newLetter = \"S\"\n        case \"\
    T\":\n            newLetter = \"T\"\n        case \"U\":\n            newLetter\
    \ = \"U\"\n        case \"V\":\n            newLetter = \"V\"\n        case \"\
    W\":\n            newLetter = \"W\"\n        case \"X\":\n            newLetter\
    \ = \"X\"\n        case \"Y\":\n            newLetter = \"Y\"\n        case \"\
    Z\":\n            newLetter = \"Z\"\n        default:\n            newLetter =\
    \ letter\n        }\n        result += newLetter\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp9ojqj5oy.swift:70:25: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            newLetter = letter\n                        ^~~~~~\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var encodedMessage\
    \ = \"\"\n    for character in message {\n        encodedMessage += swapCase(character)\n\
    \    }\n    return encodedMessage\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message:\
    \ \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\n\
    assert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is\
    \ a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw\
    \ WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmpx24wxida.swift:15:27: error: cannot find 'swapCase' in scope\n\
    \        encodedMessage += swapCase(character)\n                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    let alphabet\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"\
    G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"\
    R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n    var encodedMessage\
    \ = \"\"\n    for letter in message {\n        // Convert the letter to an index\
    \ from 0 to 25\n        let index = alphabet.indexOf(letter)\n        if index\
    \ > -1 {\n            // Find the index where the next letter appears\n      \
    \      let nextIndex = alphabet.indexOf(letter, index+1)\n            // If the\
    \ next letter appears, swap cases\n            if nextIndex > -1 {\n         \
    \       // Swap the letters\n                let temp = alphabet[index]\n    \
    \            alphabet[index] = alphabet[nextIndex]\n                alphabet[nextIndex]\
    \ = temp\n            }\n        }\n    }\n    for letter in alphabet {\n    \
    \    // For each letter, count how many times that letter appears in the message\n\
    \        var counter = 0\n        for letterIndex in 0..<message.characters.count\
    \ {\n            // Check if the letter is the same as the one at the current\
    \ index\n            if message.character(letterIndex) == letter {\n         \
    \       counter += 1\n            }\n        }\n        // If the letter appears\
    \ multiple times, add it to the encoded message\n        if counter > 1 {\n  \
    \          encodedMessage += \"\\(letter)\"\n        } else {\n            encodedMessage\
    \ += \"\\(\"a\")\"\n        }\n    }\n    return encodedMessage\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmphmjz82zt.swift:17:30: error: value of type '[String]' has no member\
    \ 'indexOf'\n        let index = alphabet.indexOf(letter)\n                  \
    \  ~~~~~~~~ ^~~~~~~\n/tmp/tmphmjz82zt.swift:20:38: error: value of type '[String]'\
    \ has no member 'indexOf'\n            let nextIndex = alphabet.indexOf(letter,\
    \ index+1)\n                            ~~~~~~~~ ^~~~~~~\n/tmp/tmphmjz82zt.swift:33:40:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ letterIndex in 0..<message.characters.count {\n                            \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmphmjz82zt.swift:35:24: error: value of type 'String' has no member 'character'\n\
    \            if message.character(letterIndex) == letter {\n               ~~~~~~~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var chars:\
    \ [Character] = []\n    for i in 0..<message.count {\n        let char = message[i]\n\
    \        switch char {\n        case \"a\": chars.append(Character(UnicodeScalar(\"\
    \\u0041\"))); \n        case \"b\": chars.append(Character(UnicodeScalar(\"\\\
    u0042\"))); \n        case \"c\": chars.append(Character(UnicodeScalar(\"\\u0043\"\
    ))); \n        case \"d\": chars.append(Character(UnicodeScalar(\"\\u0044\")));\
    \ \n        case \"e\": chars.append(Character(UnicodeScalar(\"\\u0045\"))); \n\
    \        case \"f\": chars.append(Character(UnicodeScalar(\"\\u0046\"))); \n \
    \       case \"g\": chars.append(Character(UnicodeScalar(\"\\u0047\"))); \n  \
    \      case \"h\": chars.append(Character(UnicodeScalar(\"\\u0048\"))); \n   \
    \     case \"i\": chars.append(Character(UnicodeScalar(\"\\u0049\"))); \n    \
    \    case \"j\": chars.append(Character(UnicodeScalar(\"\\u004A\"))); \n     \
    \   case \"k\": chars.append(Character(UnicodeScalar(\"\\u004B\"))); \n      \
    \  case \"l\": chars.append(Character(UnicodeScalar(\"\\u004C\"))); \n       \
    \ case \"m\": chars.append(Character(UnicodeScalar(\"\\u004D\"))); \n        case\
    \ \"n\": chars.append(Character(UnicodeScalar(\"\\u004E\"))); \n        case \"\
    o\": chars.append(Character(UnicodeScalar(\"\\u004F\"))); \n        case \"p\"\
    : chars.append(Character(UnicodeScalar(\"\\u0050\"))); \n        case \"q\": chars.append(Character(UnicodeScalar(\"\
    \\u0051\"))); \n        case \"r\": chars.append(Character(UnicodeScalar(\"\\\
    u0052\"))); \n        case \"s\": chars.append(Character(UnicodeScalar(\"\\u0053\"\
    ))); \n        case \"t\": chars.append(Character(UnicodeScalar(\"\\u0054\")));\
    \ \n        case \"u\": chars.append(Character(UnicodeScalar(\"\\u0055\"))); \n\
    \        case \"v\": chars.append(Character(UnicodeScalar(\"\\u0056\"))); \n \
    \       case \"w\": chars.append(Character(UnicodeScalar(\"\\u0057\"))); \n  \
    \      case \"x\": chars.append(Character(UnicodeScalar(\"\\u0058\"))); \n   \
    \     case \"y\": chars.append(Character(UnicodeScalar(\"\\u0059\"))); \n    \
    \    case \"z\": chars.append(Character(UnicodeScalar(\"\\u005A\"))); \n     \
    \   case \"A\": chars.append(Character(UnicodeScalar(\"\\u0041\"))); \n      \
    \  case \"B\": chars.append(Character(UnicodeScalar(\"\\u0042\"))); \n       \
    \ case \"C\": chars.append(Character(UnicodeScalar(\"\\u0043\"))); \n        case\
    \ \"D\": chars.append(Character(UnicodeScalar(\"\\u0044\"))); \n        case \"\
    E\": char\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\"\
    ) == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message:\
    \ \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS\
    \ KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"\
    k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmppisymirz.swift:17:58: error: expected hexadecimal code in braces\
    \ after unicode escape\n        case \"a\": chars.append(Character(UnicodeScalar(\"\
    \\u0041\"))); \n                                                         ^\n/tmp/tmppisymirz.swift:18:58:\
    \ error: expected hexadecimal code in braces after unicode escape\n        case\
    \ \"b\": chars.append(Character(UnicodeScalar(\"\\u0042\"))); \n             \
    \                                            ^\n/tmp/tmppisymirz.swift:19:58:\
    \ error: expected hexadecimal code in braces after unicode escape\n        case\
    \ \"c\": chars.append(Character(UnicodeScalar(\"\\u0043\"))); \n             \
    \                                            ^\n/tmp/tmppisymirz.swift:20:58:\
    \ error: expected hexadecimal code in braces after unicode escape\n        case\
    \ \"d\": chars.append(Character(UnicodeScalar(\"\\u0044\"))); \n             \
    \                                            ^\n/tmp/tmppisymirz.swift:21:58:\
    \ error: expected hexadecimal code in braces after unicode escape\n        case\
    \ \"e\": chars.append(Character(UnicodeScalar(\"\\u0045\"))); \n             \
    \                                            ^\n/tmp/tmppisymirz.swift:22:58:\
    \ error: expected hexadecimal code in braces after unicode escape\n        case\
    \ \"f\": chars.append(Character(UnicodeScalar(\"\\u0046\"))); \n             \
    \                                            ^\n/tmp/tmppisymirz.swift:23:58:\
    \ error: expected hexadecimal code in braces after unicode escape\n        case\
    \ \"g\": chars.append(Character(UnicodeScalar(\"\\u0047\"))); \n             \
    \                                            ^\n/tmp/tmppisymirz.swift:24:58:\
    \ error: expected hexadecimal code in braces after unicode escape\n        case\
    \ \"h\": chars.append(Character(UnicodeScalar(\"\\u0048\"))); \n             \
    \                                            ^\n/tmp/tmppisymirz.swift:25:58:\
    \ error: expected hexadecimal code in braces after unicode escape\n        case\
    \ \"i\": chars.append(Character(UnicodeScalar(\"\\u0049\"))); \n             \
    \                                            ^\n/tmp/tmppisymirz.swift:26:58:\
    \ error: expected hexa"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    // Your\
    \ code here\n    // return \"\"\n    var result = \"\"\n    for letter in message\
    \ {\n        if letter.unicodeScalars.count == 0 {\n            if letter.isUpperCase\
    \ {\n                letter = letter.lowercaseString\n            } else {\n \
    \               letter = letter.uppercaseString\n            }\n        }\n  \
    \      for _ in 0..<2 {\n            let value = getVowelValueForLetter(letter)\n\
    \            letter = String(UnicodeScalar(UInt8(value)))\n        }\n       \
    \ result += letter\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"\
    Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message:\
    \ \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"\
    I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp68_lypox.swift:18:23: error: value of type 'Character' has no member\
    \ 'isUpperCase'\n            if letter.isUpperCase {\n               ~~~~~~ ^~~~~~~~~~~\n\
    /tmp/tmp68_lypox.swift:19:17: error: cannot assign to value: 'letter' is a 'let'\
    \ constant\n                letter = letter.lowercaseString\n                ^~~~~~\n\
    /tmp/tmp68_lypox.swift:19:33: error: value of type 'Character' has no member 'lowercaseString'\n\
    \                letter = letter.lowercaseString\n                         ~~~~~~\
    \ ^~~~~~~~~~~~~~~\n/tmp/tmp68_lypox.swift:21:17: error: cannot assign to value:\
    \ 'letter' is a 'let' constant\n                letter = letter.uppercaseString\n\
    \                ^~~~~~\n/tmp/tmp68_lypox.swift:21:33: error: value of type 'Character'\
    \ has no member 'uppercaseString'\n                letter = letter.uppercaseString\n\
    \                         ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp68_lypox.swift:25:25:\
    \ error: cannot find 'getVowelValueForLetter' in scope\n            let value\
    \ = getVowelValueForLetter(letter)\n                        ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp68_lypox.swift:26:13: error: cannot assign to value: 'letter' is a 'let'\
    \ constant\n            letter = String(UnicodeScalar(UInt8(value)))\n       \
    \     ^~~~~~\n/tmp/tmp68_lypox.swift:26:22: error: cannot assign value of type\
    \ 'String' to type 'Character'\n            letter = String(UnicodeScalar(UInt8(value)))\n\
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp68_lypox.swift:28:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += letter\n                  ^\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    if let\
    \ firstLetters = message.characters.split(\"\").map(String.init).map({ String($0)\
    \ }),\n       let lettersCount = firstLetters.map({ countLetters($0) }),\n   \
    \    let vowels = letters.map({ $0.lowercased() }),\n       let vowelCount = vowels.map({\
    \ countLetters($0) }) {\n\n        let wordCount = lettersCount.reduce(0) { $0\
    \ + $1 }\n        let vowelIndex = vowels.reduce(0) { $0 + $1 }\n\n        var\
    \ output = \"\"\n        var counter = wordCount\n\n        for letter in firstLetters\
    \ {\n            if counter == 1 {\n                output += letter\n       \
    \     } else {\n                let index = counter % vowelIndex\n           \
    \     let index = index == 0 ? index : letters.indexOf(letter, offsetBy: index)\n\
    \                output += letters[index]\n                counter += 1\n    \
    \        }\n        }\n\n        return output\n    }\n\n    return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmphkyr1_tu.swift:13:52: error: missing argument label 'separator:'\
    \ in call\n    if let firstLetters = message.characters.split(\"\").map(String.init).map({\
    \ String($0) }),\n                                                   ^\n     \
    \                                              separator: \n/tmp/tmphkyr1_tu.swift:14:46:\
    \ error: cannot find 'countLetters' in scope\n       let lettersCount = firstLetters.map({\
    \ countLetters($0) }),\n                                             ^~~~~~~~~~~~\n\
    /tmp/tmphkyr1_tu.swift:15:21: error: cannot find 'letters' in scope\n       let\
    \ vowels = letters.map({ $0.lowercased() }),\n                    ^~~~~~~\n/tmp/tmphkyr1_tu.swift:16:38:\
    \ error: cannot find 'countLetters' in scope\n       let vowelCount = vowels.map({\
    \ countLetters($0) }) {\n                                     ^~~~~~~~~~~~\n/tmp/tmphkyr1_tu.swift:29:50:\
    \ error: cannot find 'letters' in scope\n                let index = index ==\
    \ 0 ? index : letters.indexOf(letter, offsetBy: index)\n                     \
    \                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978721
- exit_code: 1
  program: "\n/// Write a function that takes a message, and encodes in such a \n\
    /// way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
    \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n///\
    \ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n    var result\
    \ = \"\"\n    let letters = message.lowercased().characters\n    for letter in\
    \ letters {\n        // replace all vowels in the message with the letter that\
    \ \n        // appears 2 places ahead of that vowel in the english alphabet\n\
    \        let index = letters.indexOf(letter)\n        if index > 0 { \n      \
    \      result += String(letters[index + 1])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message:\
    \ \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\n\
    assert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message:\
    \ \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"
  status: SyntaxError
  stderr: "/tmp/tmp_2j76k7p.swift:14:40: error: 'characters' is unavailable: Please\
    \ use String directly\n    let letters = message.lowercased().characters\n   \
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_2j76k7p.swift:18:29: error: value of type 'String'\
    \ has no member 'indexOf'\n        let index = letters.indexOf(letter)\n     \
    \               ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978721
