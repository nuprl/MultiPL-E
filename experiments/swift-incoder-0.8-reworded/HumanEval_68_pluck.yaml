name: HumanEval_68_pluck
language: swift
prompt: "\n/// \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
  \ The plucked node should be the node with the smallest even value.\n/// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
  \ its index ],\n/// If there are no even values or the given array is empty, return\
  \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
  /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr: [] as\
  \ [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3, 0, 4, 2])\n\
  /// [0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
  /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
  /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfunc pluck(arr: [Int])\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
  \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
  \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
  assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) ==\
  \ [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
completions: ["    guard arr.count > 0 else {\n        return []\n    }\n    let minOddIndex\
    \ = arr.index(arr.minElement(arr.filter({$0 % 2 == 0}))!)\n    let maxOddIndex\
    \ = arr.index(arr.maxElement(arr.filter({$0 % 2 == 0}))!)\n    let minEvenValue\
    \ = arr[minOddIndex]\n    var returnValue = [minEvenValue]\n    arr[minOddIndex]\
    \ = arr[maxOddIndex]\n    arr[maxOddIndex] = minEvenValue\n    return returnValue",
  "    let len = arr.count\n    if arr.isEmpty {\n        return arr\n    }\n    if\
    \ len == 1 {\n        return arr\n    }\n    var min = arr[0]\n    var minIndex\
    \ = 0\n    var minIndex = -1\n    for index in 0..<len - 1 {\n        if arr[index]\
    \ > min {\n            min = arr[index]\n            minIndex = index\n      \
    \  }\n    }\n    return [minIndex, min]", "    if arr.isEmpty {\n        return\
    \ []\n    }\n    let n = arr.count\n    var minIndex: Int = 0\n    var minVal\
    \ = arr[0]\n    for i in 1..n {\n        if arr[i] < minVal {\n            minVal\
    \ = arr[i]\n            minIndex = i\n        }\n    }\n    if minIndex == 0 {\n\
    \        return []\n    }\n    return [minVal, minIndex]", "    \n    var largestIndex\
    \ = 0\n    var largestValue = arr[0]\n    var smallestIndex = 0\n    var smallestValue\
    \ = arr[0]\n    \n    for index, i in enumerate(arr) {\n        if i % 2 != 0\
    \ {\n            continue\n        }\n        \n        if smallestValue == i\
    \ {\n            smallestIndex = index\n            smallestValue = arr[index]\n\
    \        }\n        \n        if largestValue < i {\n            largestIndex\
    \ = index\n            largestValue = arr[index]\n        }\n    }\n    \n   \
    \ if smallestValue == arr[0] {\n        return [smallestValue]\n    }\n    \n\
    \    if largestIndex == 0 {\n        return arr\n    }\n    \n    if largestValue\
    \ == arr[largestIndex] {\n        return [largestValue, largestIndex]\n    }\n\
    \    \n    if largestValue == arr[largestIndex + 1] {\n        return [largestValue,\
    \ largestIndex + 1]\n    }\n    \n    var result = arr[0:largestIndex]\n    result.appendContentsOf(pluck(arr[largestIndex+1:]))\n\
    \    return result", "    \n    var sorted = arr\n    sorted.sort()\n    \n  \
    \  var smallest = sorted[0]\n    var smallestIndex = 0\n    \n    for index in\
    \ 0..<sorted.count {\n        \n        if sorted[index] % 2 == 0 {\n        \
    \    if smallest < sorted[index] {\n                smallest = sorted[index]\n\
    \                smallestIndex = index\n            }\n        }\n        \n \
    \   }\n    \n    return ArraySlice(sorted, 0, smallestIndex + 1)", "    let result\
    \ = Set(arr).sorted()\n    var smallest = 0\n    var index = 0\n    for node in\
    \ result {\n        if smallest == 0 || node % 2 == 0 {\n            smallest\
    \ = node\n            index = result.index(of: node)!\n        }\n    }\n    return\
    \ [smallest, index]", "    if arr.isEmpty() {\n        return []\n    }\n    var\
    \ results: [Int] = []\n    \n    // initialize a map for storing the results\n\
    \    var map: [Int: [Int]] = [:]\n    \n    for index in stride(from: 0, to: arr.count,\
    \ by: 2) {\n        let value = arr[index]\n        \n        if let [key, value]\
    \ = map[key] {\n            \n            if value == value % 2 { // found odd\
    \ value\n                // add the index of this value to the result array\n\
    \                results.append(key)\n                // update the map with key\
    \ as index\n                map[key] = [value, index]\n            }\n       \
    \ } else {\n            // add the value to the result array\n            results.append(value)\n\
    \            // add the value to the map with key as index\n            map[index]\
    \ = [value, index]\n        }\n    }\n    \n    return results", "    return arr.reduce([])\
    \ {\n        index, cur in\n        smallestEven := cur & 1 == 0\n        smallestIndex\
    \ := index\n        if smallestEven {\n            if smallestIndex == 0 {\n \
    \               smallestIndex = 1\n            }\n            else {\n       \
    \         if cur < arr[smallestIndex] {\n                    smallestIndex = smallestIndex\
    \ + 1\n                }\n            }\n        }\n        var ret : [Int]\n\
    \        if !smallestEven {\n            ret = ret.insert(smallestIndex, cur)\n\
    \        }\n        return ret\n    }", "    precondition(arr.count <= 10000,\
    \ \"The given array has too many nodes\")\n    var arr: [Int] = arr\n    var smalest_value:\
    \ Int = Int.max\n    var index_of_smallest_value: Int = Int.max\n    for index\
    \ in arr.indices {\n        if arr[index] % 2 == 0 {\n            smalest_value\
    \ = arr[index]\n            index_of_smallest_value = index\n        }\n    }\n\
    \    guard index_of_smallest_value != Int.max else {\n        return arr\n   \
    \ }\n    for index in arr.indices {\n        if arr[index] == smalest_value {\n\
    \            arr.insert(index_of_smallest_value, smalest_value)\n            return\
    \ arr\n        }\n    }\n    return [Int]()", "    // init\n    var i, j, temp,\
    \ smallest_value = arr[0]\n    var smallest_index = 0\n    i = j = 0\n\n    //\
    \ loop through to find smallest value\n    for _i in arr {\n        if _i < smallest_value\
    \ {\n            smallest_value = _i\n            i = smallest_index\n       \
    \ } else if _i == smallest_value {\n            smallest_index++\n        }\n\
    \    }\n\n    // loop through to find next smallest value\n    for _j in arr {\n\
    \        if _j == smallest_value {\n            continue\n        }\n        if\
    \ _j > smallest_value {\n            smallest_value = _j\n            i = smallest_index\n\
    \        }\n    }\n\n    // finally return result\n    var result = [smallest_value,\
    \ i]\n    return result", "    if arr.isEmpty() {\n        return arr\n    }\n\
    \    var index = 0\n    var smalest_val = arr[0]\n    var smalest_index = 0\n\
    \    var even_index = 0\n    var even_value = 0\n    for val in arr {\n      \
    \  if even_index == 0 && val % 2 == 0 {\n            even_value = val\n      \
    \      even_index = index\n        }\n        if even_index > 0 && val == even_value\
    \ {\n            even_index--\n        } else if even_index == 0 {\n         \
    \   smalest_val = val\n            smalest_index = index\n        }\n        index++\n\
    \    }\n    if even_index == 0 {\n        return [smalest_val, smalest_index]\n\
    \    }\n    if even_index > 0 {\n        return even_value..val\n    } else {\n\
    \        return smalest_val..smalest_index\n    }", "    var evenVals = [Int]()\n\
    \    for num in arr {\n        if num % 2 == 0 {\n            evenVals.append(num)\n\
    \        }\n    }\n\n    var sortedEvenVals = evenVals.sorted(by: { $0 > $1 })\n\
    \    var largestEvenVal = sortedEvenVals.last!\n    var index = sortedEvenVals.index(of:\
    \ largestEvenVal)\n    return [largestEvenVal, index]", "    var results = [Int]()\n\
    \    var maxValue: Int = 0\n    var index = 0\n    for element in arr {\n    \
    \    if element > maxValue {\n            maxValue = element\n            index\
    \ = element\n        }\n    }\n    results.append(maxValue)\n    results.append(index)\n\
    \    return results", "    var index = 0\n    var smalest_value = 0\n    var new_arr\
    \ = [Int]()\n    for node in arr {\n        if index == 0 {\n            smalest_value\
    \ = node\n            index = index + 1\n        }\n        if node < smalest_value\
    \ {\n            smalest_value = node\n            index = index + 1\n       \
    \     new_arr.append(node)\n        } else if node > smalest_value {\n       \
    \     smalest_value = node\n        }\n    }\n    return new_arr", "    var minValue\
    \ = Int()\n    var minIndex = -1\n    for node : Int in\n        arr.indices().toArray()\
    \ {\n            if node % 2 == 0 {\n                if node < minValue {\n  \
    \                  minValue = node\n                    minIndex = node\n    \
    \            }\n            }\n        }\n    return minIndex.array.toArray()",
  '    return pickEvenIndex(arr)', '    return largestEvenIndexAndValueIndex(arr)',
  "    guard arr.count > 0 else {\n        return []\n    }\n\n    // sort the array\
    \ to find the smallest even value\n    let sorted = arr.sorted()\n    if sorted.count\
    \ < 2 {\n        return []\n    }\n\n    let smallestEven = sorted.first!\n  \
    \  var minIndex: Int = 0\n    sorted.enumerate().forEach { (index, element) in\n\
    \        if element % 2 == 0 && element == smallestEven {\n            minIndex\
    \ = index\n        }\n    }\n\n    // return the result as a list\n    return\
    \ [smallestEven, minIndex]", "    \n    var result = [Int]()\n    for index in\
    \ 0..<arr.count {\n        if arr[index] % 2 == 0 {\n            result.insert(arr[index],\
    \ index)\n        }\n    }\n    return result", "    var minValue = 0\n    var\
    \ minIndex = 0\n    for (_, value) in arr.enumerated() {\n        if ((value &\
    \ 1) == 0) {\n            if value >= minValue {\n                minValue = value\n\
    \                minIndex += 1\n            }\n        } else if ((value & 1)\
    \ == 1) {\n            if value < minValue {\n                minValue = value\n\
    \                minIndex += 1\n            }\n        }\n    }\n    if minIndex\
    \ == 0 { return [] }\n    if minIndex == 1 { return [minValue] }\n    return minIndex\
    \ > 1 ? minValue : []", "    if arr == [] || len(arr) == 0 {\n        return arr\n\
    \    }\n    var evens = []Int()\n    var i = 0\n    for node in arr {\n      \
    \  if node % 2 == 0 {\n            evens.append(node)\n        } else {\n    \
    \        i = i\n            break\n        }\n    }\n    if i >= 0 {\n       \
    \ return evens\n    }\n    return []", '    return rec(arr, 0, arr.count, 0)',
  "    let sum = arr.reduce(0, combine: +);\n    let even = arr.reduce(0 * 0, combine:\
    \ (+) * $0);\n    var result: [Int] = [] as [Int]\n    while even != 0 {\n   \
    \     let pos = sum / even;\n        result.append(pos)\n        sum = sum % even\n\
    \        even = even * $0\n    }\n    return result as! [Int]", "    if arr ==\
    \ nil || arr.isEmpty() {\n        return []\n    }\n    var maxIndex = 0\n   \
    \ var maxValue = arr[0]\n    var evenIndex = 0\n    var evenValue = arr[0]\n \
    \   for index in 1..<arr.count {\n        if arr[index] > maxValue {\n       \
    \     maxValue = arr[index]\n            maxIndex = index\n        } else if arr[index]\
    \ == maxValue && index%2 == 0 {\n            evenValue = arr[index]\n        \
    \    evenIndex = index\n        }\n    }\n    return [evenValue, evenIndex]",
  "    if arr.isEmpty {\n        return []\n    }\n    var largest = 0\n    var smalest_value:\
    \ Int = 0\n    var smallest_index: Int = 0\n    for node : Int in arr {\n    \
    \    if node.isEven && node.value > largest * 2 {\n            largest = node.value\n\
    \            smalest_value = node\n            smallest_index = smallest_index\
    \ + 1\n        }\n    }\n    if smallest_index == 0 {\n        return []\n   \
    \ }\n    if smallest_index > 0 {\n        if largest * 2 == smallest_value {\n\
    \            return [ smalest_value, smallest_index ]\n        } else {\n    \
    \        return [ smallest_value ]\n        }\n    }\n    return [ smalest_value\
    \ ]", "    if arr.isEmpty {\n        return []\n    }\n\n    var smallest: Int\
    \ = 0\n    var smallestIndex: Int = 0\n    var count: Int = 0\n    for ele in\
    \ arr {\n        if ele % 2 == 0 && ele < smallest {\n            smallest = ele\n\
    \            smallestIndex = count\n        } else if ele % 2 == 0 {\n       \
    \     count += 1\n        }\n    }\n    return smallestIndex == 0 ? [smallest]\
    \ : []", "    \n    var maxValue = arr[0]\n    var maxIndex = 0\n    for value\
    \ in arr {\n        if value > maxValue {\n            maxValue = value\n    \
    \        maxIndex = 0\n        } else {\n            if value == maxValue {\n\
    \                maxIndex += 1\n            }\n        }\n    }\n    return [maxValue,\
    \ maxIndex]", "    var result = Ints(0)\n    for el in arr {\n        switch el\
    \ {\n        case 0: result.append {\n            switch Int64(result.length)\
    \ & UInt64(result.length) - 1L {\n            case 0L : fallthrough\n        \
    \    case -1L : 1\n                result.append()\n            case 1L : fallthrough\n\
    \            case 0L : 1\n            case 1L : fallthrough\n            case\
    \ 0L : 1\n                result.append()\n            case 2L : fallthrough\n\
    \            case 2L : 2\n                result.append()\n            case 3L\
    \ : fallthrough\n            case 3L : 3\n                result.append()\n  \
    \          case 4L : fallthrough\n            case 4L : 4\n                result.append()\n\
    \            case 5L : fallthrough\n            case 5L : 5\n                result.append()\n\
    \            case 6L : fallthrough\n            case 6L : 6\n                result.append()\n\
    \            case 7L : fallthrough\n            case 7L : 7\n                result.append()\n\
    \            case 8L : fallthrough\n            case 8L : 8\n                result.append()\n\
    \            case 9L : fallthrough\n            case 9L : 9\n                result.append()\n\
    \            case 10L : fallthrough\n            case 10L : 10\n             \
    \   result.append()\n            case 11L : fallthrough\n            case 11L\
    \ : 11\n                result.append()\n            case 12L : fallthrough\n\
    \            case 12L : 12\n                result.append()\n            case\
    \ 13L : fallthrough\n            case 13L : 13\n                result.append()\n\
    \            case 14L : fallthrough\n            case 14L : 14\n             \
    \   result.append()\n            case 15L : fallthrough\n            case 15L\
    \ : 15\n                result.append()\n            case 16L : fallthrough\n\
    \            case 16L : 16\n                result.append()\n            case\
    \ 17L : fallthrough\n            case 17L : 17\n                result.append()\n\
    \            case 18L : fallthrough\n            case 18L : 18\n             \
    \   result.append()\n            case 19L : fallthrough\n            case 19L\
    \ : 19\n                result.append()\n            case 20L : fallthrough\n\
    \            case 20L : 20\n                result.append()\n            case\
    \ 21L : fallthrough\n            case 21L : 21\n                result.append()\n\
    \            case 22L : fallthrough\n            case 22L : 22\n             \
    \   result.append()\n            case 23L : fallthrough\n            case 23L\
    \ : 23\n                result.append()\n            case 24L : fallthrough\n\
    \            case 24L : 24\n                result.append()\n            case\
    \ 25L : fallthrough\n            case 25L : 25\n                result.", "  \
    \  if arr == [] {\n        return arr\n    }\n    var result : [Int] = [0]\n \
    \   for value in arr {\n        result = minimumArray(result, value)\n    }\n\
    \    return result", "    \n    // First find the index of the smallest value\
    \ using binary search\n    var smallestIndex = -1\n    var smallestValue = arr[0]\n\
    \    for index in 0..<arr.count {\n        if arr[index] < smallestValue {\n \
    \           smallestValue = arr[index]\n            smallestIndex = index\n  \
    \      }\n    }\n    \n    // Now sort the array from that index so that we can\
    \ pick one of the smallest values\n    var sortedArray = Array(0..<arr.count)\n\
    \    for i in 0..<arr.count {\n        if i != smallestIndex {\n            sortedArray[i]\
    \ = arr[i]\n        }\n    }\n    \n    // Now return the node if there are multiple\
    \ of the same smallest value\n    // and the smallest value is the smallest even\
    \ value\n    if sortedArray.count > 1 {\n        // Sort the array so that we\
    \ can find the smallest even value\n        var sortedArray = Array(0..<arr.count)\n\
    \        for i in 0..<arr.count {\n            if arr[i] % 2 == 0 {\n        \
    \        sortedArray[i] = arr[i]\n            }\n        }\n        \n       \
    \ // Search for smallest even value in sorted array\n        // If no even values\
    \ are in the array return an empty array\n        var smallestEvenIndex = 0\n\
    \        var smallestEvenValue = sortedArray[0]\n        for index in 0..<sortedArray.count\
    \ {\n            if sortedArray[index] % 2 == 0 && smallestEvenValue < sortedArray[index]\
    \ {\n                smallestEvenValue = sortedArray[index]\n                smallestEvenIndex\
    \ = index\n            }\n        }\n        \n        // Return the array that\
    \ contains the smallest value\n        return Array([smallestEvenValue, smallestEvenIndex])\n\
    \    }\n    \n    // If the array is empty, just return an empty array\n    return\
    \ []", '    return pluck(arr, Int())', "    var evenValueIndex = -1\n    var min\
    \ = Int64(math.MinInt64)\n    var valueArray: [Int] = []\n    for element in arr\
    \ {\n        if element % 2 == 0 {\n            evenValueIndex += 1\n        \
    \    if element*2 == min {\n                min = element\n            }\n   \
    \     } else {\n            if evenValueIndex > 0 {\n                evenValueIndex\
    \ = 0\n                valueArray[evenValueIndex] = element\n            }\n \
    \       }\n    }\n    return valueArray", "    if arr.isEmpty {\n        return\
    \ []\n    }\n    \n    var minNode: Int = 0\n    var minIndex: Int = 0\n    \n\
    \    for index in 0..<arr.count {\n        if arr[index] % 2 == 0 {\n        \
    \    if minNode == 0 {\n                minNode = arr[index]\n               \
    \ minIndex = index\n            }\n            else {\n                if arr[index]\
    \ < minNode {\n                    minNode = arr[index]\n                    minIndex\
    \ = index\n                }\n            }\n        }\n    }\n    \n    return\
    \ [minNode, minIndex]", "    let counts = arr.countMap()\n    let sorted = arr.sorted()\n\
    \    var pluck_vals: [Int] = []\n    for i in 0..<min(sorted) {\n        pluck_vals.append(sorted[i])\n\
    \        let count = counts[sorted[i]]\n        let mut min_count = count\n  \
    \      for j in 0..<count {\n            if min_count < counts[sorted[i+j]] {\n\
    \                min_count = counts[sorted[i+j]]\n            }\n        }\n \
    \       i += min_count - 1\n    }\n    return pluck_vals", '    return sort.pickSort(arr.prefixSort(&swap),
    &pick)', "    return Array(\n        Set(arr).map() {\n            let value =\
    \ $0\n            let index = $0.hashValue\n            return value % 2 == 0\
    \ ? value : index\n        }\n    )", "    guard arr.count != 0 else { return\
    \ [] }\n    \n    arr.sort{$0 < $1}\n    var even = arr.filter { $0 % 2 == 0 }\n\
    \    if even.count == 0 { return [] }\n    guard even.count == 1 else { return\
    \ even }\n    \n    let smallestIndex = arr.index(of: min(arr))\n    if smallestIndex\
    \ == -1 { return [] }\n    return arr.remove(at: smallestIndex)", "    if arr.isEmpty\
    \ {\n        return []\n    }\n    // let smallestIndexes = Array(0..<arr.count).map{$0.filter{$0&1==0}.reduce(min)\
    \ }\n    let smallestIndexes = arr.enumerated().filter{$0.element&1 == 0}.reduce(min)\n\
    \    if smallestIndexes.count == 0 {\n        return []\n    }\n    return smallestIndexes\n\
    \        .enumerated()\n        .filter{_0.element&1==0}\n        .map{_0.element}",
  "    let len = arr.count\n    let count = stride(from: 0, to: len, by: 2).map {\n\
    \        if $0 % 2 == 1 {\n            return $0\n        }\n        return -1\n\
    \    }\n    let minCount = count.min()\n    var res = [Int](repeating: -1, count:\
    \ count)\n    for i in count {\n        if res[i] < 0 {\n            res[i] =\
    \ arr[i]\n            if arr[i] % 2 == 0 {\n                res[i] = arr[i]\n\
    \            }\n        }\n    }\n    return res", "    if arr.isEmpty {\n   \
    \     return []\n    }\n    if arr.count > 1 {\n        // sort the array by its\
    \ value\n        arr =  arr.sorted{ $0 < $1 }\n    }\n    var smallestEvenIndex\
    \ = arr.index(of: arr.min()!) + 1\n    var smallestEvenValue = arr[0]\n    //\
    \ find all the nodes with the same smallest even value\n    for i in 1..<arr.count\
    \ {\n        if arr[i] == arr[i-1]+1 {\n            smallestEvenIndex = i\n  \
    \          smallestEvenValue = arr[i]\n        }\n    }\n    return [smallestEvenValue,\
    \ smallestEvenIndex]", '    return Solution().pluck(arr)', "    let sorted = arr.sorted\
    \ { $0 < $1 }\n    var largest = sorted.last\n    var index = sorted.firstIndex{$0\
    \ == largest}\n    if index == sorted.count {\n        return []\n    }\n    var\
    \ even = sorted[index].toInt() % 2\n    var largestEven = sorted[index].toInt()\
    \ // largestEven is the smallest even value\n    largestEven = largestEven.nextUp\
    \ { $0 == even } // largestEven = largest even value after even\n    while even\
    \ != largestEven {\n        index++\n        even = sorted[index].toInt() // even\
    \ = smallest even value before largestEven\n        largestEven = sorted[index].toInt()\
    \ // largestEven = smallest even value after even\n    }\n    return sorted[index..<sorted.count]",
  "  var minIdx = 0\n  var minVal = arr[0]\n  for i in 1..<arr.count {\n    if arr[i]\
    \ < minVal {\n      minVal = arr[i]\n      minIdx = i\n    }\n  }\n  return arr[minIdx]",
  "    var min: Int = 0\n    var minIndex = 0\n    for index, element in enumerate(arr)\
    \ {\n        if element % 2 == 0 {\n            min = element\n            minIndex\
    \ = index\n        }\n    }\n    \n    if min == 0 {\n        return []\n    }\n\
    \    \n    var result: [Int] = []\n    for index, element in enumerate(arr) {\n\
    \        if index == minIndex {\n            result.append(element)\n        }\
    \ else {\n            if element == min {\n                result.append(minIndex)\n\
    \            } else {\n                result.append(element)\n            }\n\
    \        }\n    }\n    return result", "    var smallestVal = arr[0]\n    var\
    \ index = -1\n    \n    for i in 1..<arr.count {\n        if arr[i] < smallestVal\
    \ {\n            smallestVal = arr[i]\n            index = i\n        } else if\
    \ arr[i] == smallestVal {\n            if arr[i-1] % 2 == 0 {\n              \
    \  index = i\n            } else {\n                break\n            }\n   \
    \     }\n    }\n    \n    if index == -1 {\n        return []\n    }\n    return\
    \ [smallestVal, index]", "\tlet len = arr.count\n\tlet min_index = Int(arc4random_uniform(UInt32(len)))\n\
    \tlet index_of_min = arr.index(min_index) {\n\t\t$0.value % 2 == 0\n\t}\n\treturn\
    \ index_of_min", '    return pluck_helper(arr)', "    guard len(arr) > 0 else\
    \ { return [] }\n    guard arr.count > 0 else { return [] }\n\n    var res = [0]\n\
    \    var min = arr[0]\n    var minIndex = 0\n\n    for _ in 0..<arr.count {\n\
    \        if arr[minIndex] % 2 == 0 {\n            minIndex += 1\n            continue\n\
    \        }\n        if arr[minIndex] == min {\n            minIndex += 1\n   \
    \         continue\n        }\n        minIndex += 1\n        res = append(res,\
    \ arr[minIndex])\n    }\n    return res", '    return pluckByIndex(arr, 0)', " \
    \   return arr.windows.reduce([Int]()) {\n        guard case $0.index < $1.index\
    \ else {\n            return $1\n        }\n        $0\n    }.map{ ($0.element\
    \ % 2 == 0 ? $0.element : $0.index) }", "    if arr.isEmpty {\n        return\
    \ []\n    }\n    \n    guard arr.count > 0 else {\n        return []\n    }\n\n\
    \    guard arr.first! > 0 else { return [] }\n    \n    let min = arr.first!\n\
    \    let index = -1\n\n    for n in arr {\n        guard n % 2 == 0 else {\n \
    \           continue\n        }\n\n        if n < min {\n            min = n\n\
    \            index = arr.index(n) // O(n)\n        }\n    }\n    \n    return\
    \ [min, index]", "    let len = arr.count\n    \n    if len == 0 {\n        return\
    \ []\n    }\n    \n    let sorted = arr.sorted(by: { $0 < $1 })\n    \n    var\
    \ min_index = sorted[0] % 2\n    var min_val = sorted[0]\n    \n    for i in 1..<len\
    \ {\n        if sorted[i] % 2 != min_index {\n            min_index = sorted[i]\
    \ % 2\n            min_val = sorted[i]\n        }\n    }\n    \n    return min_index\
    \ == 0 ? [] : [min_val, min_index]", '    return arr', "    var even = []\n  \
    \  for i in arr {\n        if i % 2 != 0 {\n            even.append(i)\n     \
    \   }\n    }\n    let minIndex = even.min()!\n    if even.count == 0 {\n     \
    \   return []\n    } else {\n        return [minIndex, even.index(minIndex)]\n\
    \    }", "    if arr == [] {\n        return []\n    }\n    let evenValues = arr.filter{$0\
    \ % 2 == 0}\n    if evenValues.count == 0 {\n        return []\n    }\n    let\
    \ minEvenIndex = evenValues.minElement()\n    let minEvenValue = arr[minEvenIndex]\n\
    \    return minEvenValue", "    if arr == [] {\n        return arr\n    }\n  \
    \  if arr.count <= 1 {\n        return []\n    }\n\n    var index = 0\n    var\
    \ smallest = 0\n    var smalest_value = arr[0]\n    for ele in arr {\n       \
    \ if ele % 2 == 0 {\n            if smallest == 0 {\n                smallest\
    \ = ele\n                smalest_value = ele\n            } else if ele < smalest_value\
    \ {\n                smallest = ele\n                smalest_value = ele\n   \
    \         }\n        }\n        index += 1\n    }\n\n    return [smalest_value,\
    \ index]", "    if arr == [] {\n        return []\n    }\n    var result: [Int]\
    \ = []\n    if arr.isEmpty() {\n        return result\n    }\n    let first: Int\
    \ = arr[0]\n    var index = 0\n    while index < arr.count {\n        if arr[index]\
    \ % 2 == 0 {\n            result.append(arr[index])\n        }\n        if arr[index]\
    \ > first {\n            break\n        }\n        index += 1\n    }\n    if index\
    \ < arr.count {\n        return result\n    }\n    return result", '    return
    pick(arr, compare: { $0 < $1 })', "  var result = [0]\n  for i in arr {\n    if\
    \ result[0] == 0 || i % 2 == 0 {\n      result[0] = i\n      result[1] = result[1]\
    \ + 1\n    }\n  }\n  return result", "    var ans = [0]\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] % 2 == 0 && arr[i] < ans[0] {\n            ans = [0]\n\
    \        }\n        ans = append(ans, arr[i])\n    }\n    return ans", "    var\
    \ minValues = [Int]()\n    var minIndices = [Int]()\n    for i in arr {\n    \
    \    minValues.append(i)\n        if i % 2 == 0 {\n            minIndices.append(arr.index(i))\n\
    \        }\n    }\n    if minIndices.count == 0 || minValues.count == 0 || minIndices.count\
    \ == minValues.count {\n        return minIndices\n    }\n    return minIndices",
  "    var result = [Int]()\n    var minEvenIndex = 0\n    var smallestEven = arr[0]\n\
    \    arr.forEach({\n        if $0 % 2 == 0 {\n            if smallestEven < $0\
    \ {\n                smallestEven = $0\n                minEvenIndex = 0\n   \
    \         }\n        }\n        result += [$0, $0]\n    })\n    if result.count\
    \ > 0 {\n        result.forEach({\n            if $0 < smallestEven {\n      \
    \          smallestEven = $0\n                minEvenIndex = 0\n            }\n\
    \        })\n    }\n    return result", '    return largestEvenIdx(arr, 0)', " \
    \   if arr.isEmpty() {\n        return []\n    }\n    // Sort in ascending order.\n\
    \    var sorted = sort.sort(arr)\n    // Get the smallest even value in sorted\
    \ array.\n    var smallest_value = 0\n    var smallest_index = 0\n    for i in\
    \ 0..<sorted.length {\n        if sorted[i] % 2 == 0 {\n            smallest_value\
    \ = sorted[i]\n            smallest_index = i\n        }\n    }\n    var result\
    \ = [smallest_value]\n    if smallest_index != 0 {\n        var smallest_even_index\
    \ = smallest_index - 1\n        while smallest_even_index >= 0 && smallest_even_index\
    \ < sorted.length && sorted[smallest_even_index] % 2 == 0 {\n            smallest_even_index--\n\
    \        }\n        if smallest_even_index != -1 {\n            result = [smallest_value,\
    \ smallest_even_index]\n        } else {\n            // There are no even values\
    \ in the array.\n            result = []\n        }\n    } else {\n        //\
    \ There are no even values in the array.\n        result = []\n    }\n    return\
    \ result", "    \n    let n = arr.count\n    var evens = [Int]()\n    \n    for\
    \ idx in 0..<n {\n        if arr[idx] % 2 == 0 {\n            evens.append(arr[idx])\n\
    \        }\n    }\n    \n    if evens.count > 0 {\n        \n        let minValue\
    \ = evens.min()\n        let minIndex = 0\n        \n        for idx in 0..<n\
    \ {\n            if arr[idx] == minValue {\n                minIndex = idx\n \
    \           }\n        }\n        return [minValue, minIndex]\n    }\n    \n \
    \   return []", "    return pick(arr, func(i, n int64) bool {\n        n%2 ==\
    \ 0\n    })", "    let n = arr.count\n    var i = 0\n    var j = 0\n    var even\
    \ = arr[n - 1]\n    var smalest_value = 0\n    var smalest_index = 0\n    for\
    \ _ in 0..<n {\n        if even != 0 {\n            if j > smalest_index {\n \
    \               smalest_value = even\n                smalest_index = j\n    \
    \        }\n            j = 0\n        }\n        even = arr[i]\n        i++\n\
    \    }\n    if j > smalest_index {\n        smalest_value = even\n        smalest_index\
    \ = j\n    }\n    return [smalest_value, smalest_index]", "    \n    let length\
    \ = arr.count\n    if length == 0 {\n        return []\n    }\n    \n    let maxValue\
    \ = arr.max()\n    if maxValue % 2 == 0 {\n        return arr\n    }\n    \n \
    \   var currentIndex = 0\n    var smalestValue = maxValue\n    \n    while currentIndex\
    \ < length && arr[currentIndex] != maxValue && arr[currentIndex] % 2 != 0 {\n\
    \        \n        if arr[currentIndex] < maxValue {\n            currentIndex\
    \ += 1\n        }\n        \n        if arr[currentIndex] == maxValue {\n    \
    \        smalestValue = arr[currentIndex]\n            currentIndex += 1\n   \
    \     }\n    }\n    \n    var result = [Int]()\n    \n    if currentIndex == length\
    \ {\n        result = arr\n    } else {\n        while currentIndex < length {\n\
    \            if arr[currentIndex] == maxValue {\n                result = [maxValue,\
    \ currentIndex]\n                currentIndex += 1\n            } else {\n   \
    \             currentIndex += 1\n            }\n        }\n    }\n    \n    return\
    \ result", "    if arr.isEmpty() {\n        return []\n    }\n    var minValue\
    \ = arr[0]\n    var minIndex = 0\n    for val in arr {\n        if val%2 == 0\
    \ {\n            if val < minValue {\n                minValue = val\n       \
    \         minIndex = 0\n            }\n        } else if val < minValue {\n  \
    \          minValue = val\n            minIndex = 1\n        }\n    }\n    return\
    \ [minValue, minIndex]", "    if arr == nil {\n        return []\n    }\n    var\
    \ smallestEven = -1\n    var smallestIndex = 0\n    for idx, val in enumerate(arr)\
    \ {\n        if val % 2 == 0 && val != smallestEven {\n            smallestEven\
    \ = val\n            smallestIndex = idx\n        }\n    }\n    if smallestEven\
    \ != -1 {\n        return [smallestEven, smallestIndex]\n    }\n    return []",
  "\tvar smalest_value : Int\n\tvar smalest_index : Int = 0\n\t\n\tfor index, element\
    \ in enumerate(arr) {\n\t\tif element % 2 == 0 {\n\t\t\tif smalest_value > element\
    \ {\n\t\t\t\tsmalest_value = element\n\t\t\t\tsmalest_index = index\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn arr[smalest_index]", "    guard arr.isEmpty else {\n    \
    \    var result = arr\n        let value = arr.min()\n        let index = result.index(of:\
    \ value)\n        if index != nil {\n            result.remove(at: index!)\n \
    \       }\n        return result\n    }\n    return []", '  return lcsIndex(lcsIndex(arr))',
  "    if arr.isEmpty() {\n        return nil\n    }\n\n    // Find smallest even\
    \ value, smallest_even.\n    var smallest_even = arr[0]\n    // Smallest even\
    \ index, smallest_even_index.\n    var smallest_even_index = Int(0)\n    // Smallest\
    \ even value, smallest_even_value, smallest even index, smallest even value.\n\
    \    var smallest_even_value, smallest_even_index\n\n    // Smallest odd value,\
    \ smallest_odd_value.\n    var smallest_odd_value = Int(0)\n    // Smallest odd\
    \ index, smallest_odd_index.\n    var smallest_odd_index = Int(0)\n\n    // Find\
    \ smallest even value in arr.\n    smallest_even_index = 1\n    smallest_even_value\
    \ = Int(arr[0])\n\n    // Find the smallest odd value.\n    for i in 1..<arr.count\
    \ {\n        if arr[i] < smallest_even_value {\n            smallest_even_index\
    \ = i\n            smallest_even_value = Int(arr[i])\n        } else if arr[i]\
    \ == smallest_even_value {\n            if smallest_even_index < i {\n       \
    \         smallest_even_index = i\n                smallest_even_value = Int(arr[i])\n\
    \            }\n        }\n    }\n\n    // Find the smallest odd value.\n    for\
    \ i in 1..<arr.count {\n        if arr[i] < smallest_odd_value {\n           \
    \ smallest_odd_index = i\n            smallest_odd_value = Int(arr[i])\n     \
    \   } else if arr[i] == smallest_odd_value {\n            if smallest_odd_index\
    \ < i {\n                smallest_odd_index = i\n                smallest_odd_value\
    \ = Int(arr[i])\n            }\n        }\n    }\n\n    // If the odd index is\
    \ smaller than the even index, return the even index.\n    // If the odd index\
    \ is greater than the even index, return the odd index.\n    return smallest_odd_index\
    \ < smallest_even_index ? smallest_even_index : smallest_odd_index", "    \n \
    \   arr.sortInPlace()\n    \n    if arr.isEmpty() {\n        return []\n    }\n\
    \    \n    var smallestValue : Int = 0\n    var index : Int = 0\n    \n    \n\
    \    var node : Int = 0\n    \n    \n    for node in arr {\n        \n       \
    \ \n        \n        if node < smallestValue {\n            smallestValue = node\n\
    \            index = 0\n        }\n        \n        \n        if node % 2 ==\
    \ 0 {\n            smallestValue = node\n            index = 1\n        }\n  \
    \      \n        \n    }\n    \n    if smallestValue == 0 {\n        return []\n\
    \    }\n    return [smallestValue, index]", "    let n = arr.count\n    if n <\
    \ 2 {\n        return []\n    }\n    var evenValues = arr[0..n-1]\n    var smallEvenValues\
    \ = arr[0..n-1]\n    for i in 0..n-1 {\n        if evenValues[i]%2 != 0 {\n  \
    \          evenValues = evenValues.prefix(2)\n            smallEvenValues = smallEvenValues.prefix(2)\n\
    \            break\n        }\n    }\n    if n == 1 {\n        let smallEvenIndex\
    \ = smallEvenValues.firstIndex(of: 0)\n        if smallEvenIndex < 0 {\n     \
    \       return []\n        } else {\n            return smallEvenValues[smallEvenIndex]\n\
    \        }\n    }\n    var smallEvenIndex = 0\n    for i in 0..<n {\n        if\
    \ evenValues[i]%2 == 0 && smallEvenValues[i]%2 == 0 {\n            smallEvenIndex\
    \ = i\n            break\n        }\n    }\n    return smallEvenValues[smallEvenIndex]",
  "    var result = [Int]()\n    var current = [Int]()\n    for i in arr {\n     \
    \   current = [Int]()\n        current.append(i)\n        let index = current.index(of:\
    \ i as! Int, in: arr.indices)\n        if index < 0 {\n            current.sort()\n\
    \            if current[0] % 2 == 0 {\n                result.append(current[0])\n\
    \            } else {\n                result.append(current[1])\n           \
    \ }\n        } else {\n            result.append(index)\n        }\n    }\n  \
    \  return result as! [Int]", "    // TODO: Fill out your solution here\n    var\
    \ res: [Int] = []\n    var index = 0\n    for i in arr {\n        if i % 2 ==\
    \ 0 {\n            res[index] = i\n            index += 1\n        }\n    }\n\
    \    return res", "    let minVal = arr.reduce(0, {$0 + $1})\n    var min = minVal\n\
    \    var index: Int = 0\n\n    for i in arr {\n        if i % 2 == 0 {\n     \
    \       if i == min {\n                minVal += 1\n                min = minVal\n\
    \                index += 1\n            } else {\n                minVal += 1\n\
    \                min = minVal\n                index++\n            }\n      \
    \  }\n    }\n\n    if arr.isEmpty() {\n        return []\n    }\n    return [min,\
    \ index]", "    guard arr.isEmpty == false else { return [] }\n    var largest\
    \ = [Int]()\n    var largestIndex = 0\n    for index in 0..<arr.count {\n    \
    \    if arr[index] % 2 == 0 {\n            largest.append(arr[index])\n      \
    \      largestIndex = index\n        }\n    }\n    return largest", "    if isEmpty(arr)\
    \ {\n        return []\n    }\n    var result: [Int] = []\n    var minValue =\
    \ arr[0]\n    var minIndex = 0\n    for i : Int in 0..<arr.count {\n        if\
    \ arr[i] < minValue {\n            minValue = arr[i]\n            minIndex = i\n\
    \        }\n    }\n    result.append(minValue)\n    result.append(minIndex)\n\
    \    return result", "    \n    var i = 0\n    var maxIndex = 0\n    var maxValue\
    \ = 0\n    \n    for value in arr {\n        if value < maxValue {\n         \
    \   continue\n        }\n        \n        if maxValue == 0 {\n            maxValue\
    \ = value\n            maxIndex = i\n        }\n        \n        if value ==\
    \ maxValue {\n            maxIndex++\n        }\n        \n        maxValue =\
    \ value\n        i = i + 1\n    }\n    \n    return arr[maxIndex..<arr.count]",
  "    var result = IntArray()\n    var minValue = Int()\n    var minIndex = -1\n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] < minValue {\n       \
    \     minValue = arr[i]\n            minIndex = i\n        }\n    }\n    if minValue\
    \ == 0 {\n        result[0] = minValue\n    } else {\n        result[0] = minValue\n\
    \        for i := 0; i < len(arr); i++ {\n            if arr[i] == minValue {\n\
    \                result[1] = i\n                return\n            }\n      \
    \  }\n    }\n    return result", "    var result = [Int]()\n    var minIndex =\
    \ -1\n    var minValue = arr[0]\n    for i := 0; i < arr.length; i++ {\n     \
    \   if arr[i] >= minValue {\n            result[minIndex] = arr[i]\n         \
    \   if arr[i] < minValue {\n                minValue = arr[i]\n              \
    \  minIndex = i\n            }\n        }\n    }\n    if minIndex == -1 {\n  \
    \      return result\n    }\n    return minIndex == 0 ? result : [minValue]",
  "    \n    let len = arr.count\n    \n    if len == 0 {\n        return arr\n  \
    \  }\n    \n    var even = [Int]()\n    var index = 0\n    var smalest_value =\
    \ 0\n    \n    for node in arr {\n        let value = node.value % 2 == 0 ? node.value\
    \ : node.value + 1\n        if value < smalest_value {\n            smalest_value\
    \ = value\n            even = [Int]()\n        }\n        if value < smalest_value\
    \ && value < even.count {\n            even.append(value)\n            index +=\
    \ 1 // if current value is already in even, add 1 to index\n        }\n    }\n\
    \    \n    if even.count == 1 {\n        return even\n    } else {\n        if\
    \ even.count > 0 {\n            return even\n        } else {\n            return\
    \ [index]\n        }\n    }", "    if arr == nil || arr.isEmpty() {\n        return\
    \ []\n    }\n    var result = [Int]()\n    var node = arr[0]\n    var index =\
    \ arr[0]\n    if arr.isEmpty() {\n        return result\n    }\n    for ele in\
    \ arr {\n        if ele % 2 == 0 && ele < node {\n            result.append(ele)\n\
    \            node = ele\n            index = ele\n        } else {\n         \
    \   if ele == node {\n                result.append(index)\n                index\
    \ = ele\n            } else {\n                result.append(ele)\n          \
    \      node = ele\n                index = ele\n            }\n        }\n   \
    \ }\n    return result", "    \n    var even = [Int]()\n    var index = Int()\n\
    \    \n    \n    for node in arr {\n        if node % 2 == 0 {\n            \n\
    \            \n            if even.count > 0 {\n                \n           \
    \     if node < even.minElement() {\n                    \n                  \
    \  \n                    index = even.indexOf(node)\n                    even.removeAll(at:\
    \ index)\n                }\n            } else {\n                \n        \
    \        even.append(node)\n                index = even.indexOf(node)\n     \
    \       }\n        }\n    }\n    \n    \n    if even.count > 0 {\n        index\
    \ = even.indexOf(0)\n        even.removeAll(at: index)\n    }\n    \n    return\
    \ even as [Int]", '    return helper(arr, false)', "    if arr.isEmpty {\n   \
    \     return []\n    }\n\n    // Sort the array and find the smallest even value\n\
    \    let sortedArr = arr.sorted(by: >)\n    if arr.contains(sortedArr.min() %\
    \ 2 == 0) {\n        return sortedArr.min()\n    }\n\n    var result = [Int]()\n\
    \    var index = 0\n    var evenMin = sortedArr.min()\n    var evenIndex = 0\n\
    \n    for n in sortedArr {\n        if n % 2 == 0 {\n            // The first\
    \ two nodes here are the smallest even values.\n            // The current node\
    \ is the next node with the smallest index.\n            if evenMin == n {\n \
    \               evenMin = sortedArr[index]\n                evenIndex = index\n\
    \            }\n\n            index += 1\n        } else {\n            // The\
    \ first two nodes here are the smallest even values.\n            // The current\
    \ node is the next node with the smallest index.\n            if evenMin == n\
    \ {\n                result.append(sortedArr[evenIndex])\n                evenIndex\
    \ += 1\n            }\n        }\n    }\n\n    return result", "    var evenValues\
    \ = [Int]()\n    var indexOfSmallestEvenValue = -1\n    var indexOfSmallestIndex\
    \ = 0\n    for i in arr {\n        if i % 2 == 0 {\n            evenValues.append(i)\n\
    \            if indexOfSmallestEvenValue == -1 || i < indexOfSmallestEvenValue\
    \ {\n                indexOfSmallestEvenValue = i\n                indexOfSmallestIndex\
    \ = indexOfSmallestEvenValue\n            }\n        }\n    }\n    if indexOfSmallestEvenValue\
    \ != -1 && indexOfSmallestEvenValue < indexOfSmallestIndex {\n        indexOfSmallestIndex\
    \ = indexOfSmallestEvenValue\n    }\n    if indexOfSmallestIndex == -1 {\n   \
    \     return nil\n    }\n    return [evenValues[indexOfSmallestIndex], indexOfSmallestIndex]",
  "    sort.Sort(&arr)\n    var res [Int]\n    var min = 0\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] % 2 == 0 {\n            res[min] = arr[i]\n       \
    \     min++\n        }\n    }\n    if min == len(arr) {\n        return []\n \
    \   }\n    min -= 1\n    return res[0:min]", "    let len = arr.count\n    var\
    \ picked = 0\n    var minValue = IntMax\n    var minIndex = -1\n    for i in 0..<len\
    \ {\n        if arr[i] > minValue {\n            minIndex = i\n            minValue\
    \ = arr[i]\n        }\n    }\n    if minIndex >= 0 && minValue % 2 == 0 {\n  \
    \      picked = minIndex\n    }\n    return arr[picked]", "    var minValue =\
    \ arr[0]\n    var index = 0\n    for value in arr {\n        if value == 0 {\n\
    \            continue\n        }\n        if value < minValue {\n            minValue\
    \ = value\n            index = index\n        }\n    }\n    if arr[index] != 0\
    \ {\n        return [minValue, index]\n    }\n    return []", "    if arr.isEmpty()\
    \ {\n        return []\n    }\n    var even_index: Int? = nil\n    var smallest_value:\
    \ Int = 0\n    for i in arr {\n        if i % 2 == 0 {\n            even_index\
    \ = i\n            smallest_value = i\n            if smallest_value == 0 && even_index\
    \ == nil {\n                break\n            }\n        }\n    }\n    if even_index\
    \ == nil || even_index != arr.first {\n        return []\n    }\n    let index\
    \ = arr.index(of: smallest_value)\n    if index == arr.last-1 {\n        return\
    \ [smallest_value, index]\n    } else {\n        return Array(arr[index..<arr.end]).map\
    \ { (i) -> Int in\n            if i % 2 == 0 {\n                return i\n   \
    \         } else {\n                return i\n            }\n        }\n    }",
  "    var min_value = Int()\n    var min_index = Int()\n    var result = [Int]()\n\
    \    for node in arr {\n        if node.isMultiple(2) { //even node\n        \
    \    if min_value.isMultiple(0) { //same value, choose the smallest one\n    \
    \            if node.value < min_value {\n                    min_value = node.value\n\
    \                    min_index = node\n                }\n            } else {\
    \ //different value, choose the smallest index\n                if node.value\
    \ < min_value {\n                    min_value = node.value\n                \
    \    min_index = node\n                }\n            }\n        } else { //odd\
    \ node\n            if min_value.isMultiple(0) { //same value, choose the smallest\
    \ one\n                if node.value > min_value {\n                    min_value\
    \ = node.value\n                    min_index = node\n                }\n    \
    \        } else { //different value, choose the smallest index\n             \
    \   if node.value > min_value {\n                    min_value = node.value\n\
    \                    min_index = node\n                }\n            }\n    \
    \    }\n    }\n    result = [min_value, min_index]\n    return result", '    return
    arr', "    var largestIndex = -1\n    var largestValue = -1\n    for i in arr\
    \ {\n        if i%2 == 0 {\n            if largestValue == -1 || i > largestValue\
    \ {\n                largestValue = i\n                largestIndex = i\n    \
    \        } else {\n                if largestIndex > i {\n                   \
    \ largestIndex = i\n                    largestValue = i\n                }\n\
    \            }\n        }\n    }\n    if largestIndex == -1 {\n        return\
    \ []\n    }\n    return [largestValue, largestIndex]", '    return arr.sorted().prefix(2)',
  "    if arr.isEmpty { return []}\n    // TODO: DP solution\n    let len: Int = arr.count\n\
    \    let dp = [Int](repeating: -1, count: len+1)\n\n    let result: [Int] = []\n\
    \    let smallest: Int = -1\n\n    for i in 0..<len {\n        dp[i] = -1\n  \
    \      dp[i+1] = 0\n        if arr[i] == 0 {\n            if smallest+1 < 0 ||\
    \ dp[smallest+1] < 0 {\n                smallest = 1\n            } else {\n \
    \               smallest = dp[smallest+1]\n            }\n        } else {\n \
    \           smallest = 0\n        }\n        result.append(arr[i])\n        dp[i]\
    \ = smallest\n    }\n    return result", "    if arr.isEmpty() { return [] as\
    \ [Int] }\n    var lowIndex = -1\n    var curValue, curIndex :Int = arr[0]\n \
    \   var result = Array()\n    for idx in 0..<arr.count {\n        curValue = arr[idx]\n\
    \        if curValue % 2 == 0 && curIndex >= lowIndex {\n            result.append((curValue,\
    \ curIndex))\n        }\n        if curValue % 2 != 0 && curIndex >= lowIndex\
    \ {\n            lowIndex = idx\n            curIndex = idx\n        }\n    }\n\
    \    return result as [Int]", "    \n    // use the same code as in Pluck except\
    \ with min\n    \n    return arr", '    return helper(arr, [])', "    var min\
    \ = arr[0]\n    var minIndex = 0\n    for i := 1; i < len(arr); i++ {\n      \
    \  if arr[i] == min {\n            minIndex = i\n        } else {\n          \
    \  if arr[i] < min {\n                min = arr[i]\n                minIndex =\
    \ i\n            }\n        }\n    }\n    return arr[:minIndex]", "    var minValue:\
    \ Int = 0\n    var minIndex = 0\n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > 0 && arr[i] < minValue {\n            minValue = arr[i]\n      \
    \      minIndex = i\n        }\n    }\n    return minIndex == 0 ? [] : [minValue,\
    \ minIndex]", "    if arr == nil {\n        return []\n    }\n    var even: Int\
    \ = 0\n    var index = 0\n    for element in arr {\n        if element % 2 ==\
    \ 0 {\n            if even == element {\n                return [element, index]\n\
    \            } else {\n                even = element\n                index =\
    \ index + 1\n            }\n        }\n    }\n    return [even, index]", "   \
    \ var even = [Int]()\n    var indices = [Int]()\n    arr.forEach {\n        if\
    \ $0 % 2 == 0 {\n            even.append($0)\n            indices.append($0)\n\
    \        }\n    }\n    return even.sorted().firstIndex(of: min(even), offsetBy:\
    \ indices.sorted().last)", "    var minVal = IntMax\n    var minPos = IntMax\n\
    \    for idx, val in enumerate(arr) {\n        if val < minVal {\n           \
    \ minVal = val\n            minPos = idx\n        }\n    }\n    return [minVal,\
    \ minPos]", "    if isEmpty(arr) {\n        return []\n    }\n    if arr[0] !=\
    \ 0 { //If there is no even number in the array return the first node\n      \
    \  return [arr[0], 0]\n    }\n    var minVal = arr[0]\n    var minIndex = 0\n\
    \    \n    for index in 1..<arr.count{\n        if arr[index] >= minVal {\n  \
    \          minVal = arr[index]\n            minIndex = index\n        }\n    }\n\
    \    return minIndex == 0 ? minVal : [minVal, minIndex]", '    return arr.sort
    { $0 > $1 }.map { $0 }', "    \n    guard arr.count > 0 else {\n        return\
    \ []\n    }\n    \n    // init smallest_even_index\n    var smallest_even_index:\
    \ Int = 0\n    \n    // init smallest_even_value, smallest_even_index\n    var\
    \ smallest_even_value: Int = 0\n    \n    // init result array\n    var result:\
    \ [Int] = []\n    \n    // check all even values and find the smallest one\n \
    \   for i in 0..<arr.count {\n        if arr[i] % 2 == 0 {\n            // if\
    \ the current value is smaller than the smallest even value, then store the current\
    \ index\n            if arr[i] < smallest_even_value {\n                smallest_even_index\
    \ = i\n                smallest_even_value = arr[i]\n            }\n        }\n\
    \    }\n    \n    // if we have the smallest even value, then we can pluck this\
    \ one and add the index\n    if smallest_even_value > 0 {\n        result.insert(smallest_even_value,\
    \ smallest_even_index)\n    }\n    \n    return result", "    var result = [Int]()\n\
    \    var smallestIndex = -1\n    for idx in arr {\n        if idx%2 != 0 {\n \
    \           continue\n        }\n        if smallestIndex == -1 || idx<smallestIndex\
    \ {\n            smallestIndex = idx\n        }\n    }\n    if smallestIndex !=\
    \ -1 {\n        result.insert(smallestIndex, idx)\n    }\n    return result",
  "    var even = [Int]()\n    var index = Int()\n    for node in arr {\n        if\
    \ node % 2 == 0 {\n            even.append(node)\n        } else {\n         \
    \   if even.count > 0 && even[even.count - 1] < node {\n                even =\
    \ even[even.count - 1]\n                index = node - 1\n            } else {\n\
    \                index = index\n            }\n        }\n    }\n    return even\
    \ as [Int]", "    var len = arr.count\n    var smalest_even_value = arr[0]\n \
    \   var smalest_index = 0\n    var result = [Int]()\n    for i in 1...len {\n\
    \        var even_value: Int\n        if arr[i-1]%2 == 0 {\n            even_value\
    \ = arr[i-1]\n        } else {\n            if even_value < smalest_even_value\
    \ {\n                smalest_even_value = arr[i-1]\n                smalest_index\
    \ = i\n            }\n        }\n        result.append(smalest_index)\n    }\n\
    \    if len == 0 || smalest_even_value != arr[0] {\n        return result\n  \
    \  } else {\n        return result\n    }", "    var largest: Int = 0\n    var\
    \ largestIndex: Int = 0\n    var i: Int\n    for i = 0, i < arr.count(), i++ {\n\
    \        if arr[i] % 2 == 0 {\n            if arr[i] > largest {\n           \
    \     largest = arr[i]\n                largestIndex = i\n            }\n    \
    \    }\n    }\n    return [largest, largestIndex]", '  return arr.reduce((a, b)
    => (a.value & b.value) == b.value ? a : b)', "    if arr.isEmpty {\n        return\
    \ []\n    }\n    \n    let maxValue = arr[0]\n    var index = arr.startIndex\n\
    \    for i in 1..<arr.count {\n        if arr[i] < maxValue {\n            index\
    \ = i\n            maxValue = arr[i]\n        }\n    }\n    \n    return [maxValue,\
    \ index]", "    let map = [Int: Int]()\n    for node in arr {\n        if map[node]\
    \ == nil {\n            map[node] = node\n        } else if map[node] < node {\n\
    \            map[node] = node\n        }\n    }\n    return arr\n        .filter\
    \ { map[$0] != nil }\n        .sort { $0 < $1 }\n        .map { $0 }", "\tvar\
    \ minIndex = -1\n\tvar minValue = Int64(math.MaxInt64)\n\tfor idx, val := range\
    \ arr {\n\t\tif val %2 == 0 {\n\t\t\tif minIndex < 0 || val < minValue {\n\t\t\
    \t\tminValue = val\n\t\t\t\tminIndex = idx\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\
    \t\t}\n\t}\n\n\tif minIndex >= 0 {\n\t\treturn arr[minIndex:minIndex+1]\n\t}\n\
    \treturn []", "\tret := make([Int], 0)\n\tvar i int = 0\n\tfor arr[i] != 0 &&\
    \ i < len(arr) {\n\t\tret[i] = arr[i]\n\t\ti += 1\n\t}\n\tif i == 0 {\n\t\treturn\
    \ ret as [Int]\n\t}\n\tm := make([Int], i)\n\tm[0] = arr[i]\n\tfor ii := 0; ii\
    \ < len(arr); ii++ {\n\t\tif arr[ii] % 2 == 0 {\n\t\t\tm[ii] = arr[ii]\n\t\t}\
    \ else {\n\t\t\tbreak\n\t\t}\n\t}\n\tret := make([Int], i)\n\tfor ii := 0; ii\
    \ < i; ii++ {\n\t\tret[ii] = m[ii]\n\t}\n\treturn ret", "    \n    return arr",
  "    if arr.isEmpty {\n        return []\n    }\n    var min: Int = 0\n    var minIndex:\
    \ Int = 0\n    var result: [Int] = []\n    var i: Int = 0\n    for node in arr\
    \ {\n        if ((node % 2) == 0) {\n            if (min > node) {\n         \
    \       min = node\n                minIndex = i\n            }\n            i\
    \ += 1\n        }\n    }\n    if min == 0 {\n        return result\n    }\n  \
    \  result.insert(minIndex, min)\n    return result", "    let minValue = Int64(0)\n\
    \    var result = [Int]()\n    for (index, element) in arr.enumerated() {\n  \
    \      if element == minValue {\n            result.append(index)\n        }\n\
    \    }\n    if result.isEmpty {\n        return result\n    } else {\n       \
    \ return result[0]\n    }", "    return min(arr, func(i, _ int) int {\n      \
    \  return arr[i] / 2\n    })", "    guard arr.isEmpty || arr.count >= 1000000000\
    \ else {\n        return []\n    }\n    var sum: Int = 0\n    var minIndex: Int\
    \ = 0\n    for idx in 0..<arr.count {\n        if arr[idx] % 2 == 0 {\n      \
    \      sum += arr[idx]\n            minIndex = idx\n        }\n    }\n    if sum\
    \ % 2 == 0 {\n        return [sum, minIndex]\n    }\n    return []", "    \n \
    \   var minIndex = 0\n    var minValue = arr[0]\n    \n    for index in 1..arr.count\
    \ {\n        if arr[index] % 2 == 0 {\n            minValue = arr[index]\n   \
    \         minIndex = index\n        }\n    }\n    \n    return [minValue, minIndex]",
  "    var result: [Int] = []\n    var largestEvenIndex = 0\n    arr.forEach { item\
    \ in\n        if item % 2 == 0 {\n            result.append(item)\n          \
    \  if item > result[largestEvenIndex] {\n                largestEvenIndex = result.count\n\
    \            }\n        }\n    }\n    if result.count == 0 {\n        return result\n\
    \    }\n    var largestEvenValue = result[0]\n    var largestEvenIndex = 0\n \
    \   for index = 0; index < result.count; index++ {\n        if result[index] >\
    \ largestEvenValue {\n            largestEvenValue = result[index]\n         \
    \   largestEvenIndex = index\n        }\n    }\n    return [largestEvenValue,\
    \ largestEvenIndex]", "    var res = IntArray()\n    var cur = IntArray()\n  \
    \  var min = IntArray()\n    var curVal = 0\n    for i in arr {\n        curVal\
    \ += i\n        if curVal % 2 == 0 {\n            cur.push(i)\n            min.push(i)\n\
    \        } else {\n            cur.shift()\n            min.shift()\n        }\n\
    \    }\n    for val in min {\n        res.insert(val, 0)\n    }\n    return res\
    \ as [Int]", "    var result: [Int] = []\n    if arr.isEmpty() {\n        return\
    \ result\n    }\n    var min: Int = arr[0]\n    var minIndex = 0\n    for i in\
    \ arr {\n        if i % 2 == 0 {\n            min = i\n            minIndex =\
    \ i\n        }\n    }\n    var i = 0\n    for j in arr {\n        if j == min\
    \ {\n            result.append(j)\n            i += 1\n        }\n    }\n    if\
    \ i == arr.count {\n        return result\n    }\n    return result[minIndex :\
    \ minIndex + i]", "    var result = [Int]()\n    var minValue = arr[0]\n    var\
    \ minIndex = 0\n    var index: Int\n    for i in arr {\n        if minValue ==\
    \ i {\n            minIndex = index\n        } else {\n            if minValue\
    \ < i {\n                minValue = i\n                minIndex = index\n    \
    \        }\n        }\n        index += 1\n    }\n    result.append(minValue)\n\
    \    result.append(minIndex)\n    return result", "\tresult = Ints(Ints(Ints(arr)))\n\
    \treturn arr", "    var index = 0\n    var smalest_value = 0\n    for _ in arr\
    \ {\n        if smalest_value == 0 {\n            smalest_value = arr[index]\n\
    \            index = index + 1\n        } else {\n            smalest_value =\
    \ smalest_value + arr[index]\n        }\n        index = index + 1\n    }\n  \
    \  var result = [Int]()\n    if arr.isEmpty {\n        return result\n    }\n\
    \    if smalest_value % 2 == 0 {\n        result.append(smalest_value)\n     \
    \   result.append(index)\n        return result\n    }\n    for index in 0 ..<\
    \ arr.count {\n        smalest_value = smalest_value + arr[index]\n        if\
    \ smalest_value % 2 == 0 {\n            result.append(smalest_value)\n       \
    \     result.append(index)\n            return result\n        }\n    }\n    return\
    \ result", "    \n    \n    let smallest = arr.min()\n    \n    if smallest %\
    \ 2 == 0 {\n        return arr\n    } else {\n        let index = arr.index(of:\
    \ smallest % 2)\n        return [smallest, index]\n    }", '  return pluckImpl(arr,
    0)', "    let n = arr.count\n    guard n >= 1 else {\n        return []\n    }\n\
    \    var maxIndex = 0\n    var maxValue = 0\n    for i in 0..<n {\n        if\
    \ arr[i] == 0 {\n            continue\n        }\n        if maxValue < arr[i]\
    \ {\n            maxValue = arr[i]\n            maxIndex = i\n        }\n    }\n\
    \    if maxIndex < n / 2 {\n        maxIndex = n\n    }\n    return [maxValue,\
    \ maxIndex]", "    return pick(arr, func(i Int) bool {\n        i &^ (1 << uint(i))\n\
    \        return i == 0\n    })", "\tsort.Slice(arr, 1, func(i, j int) bool {\n\
    \t\treturn arr[i-1]%2 == arr[j-1]%2\n\t})\n\treturn arr", "    var result: [Int]\
    \ = []\n    var largest = 0\n    var smallest = -1\n    \n    arr.forEach{ i in\n\
    \        if i % 2 == 0 {\n            largest = i\n        } else {\n        \
    \    if smallest == -1 || i < smallest {\n                smallest = i\n     \
    \       }\n        }\n    }\n    \n    if smallest != -1 {\n        result = [smallest,\
    \ smallest]\n    }\n    \n    return result", "    if isEmpty(arr) { return []\
    \ as [Int] }\n    let min = minElement(arr)\n    var index = 0\n    for n in arr\
    \ {\n        if n % 2 == 0 {\n            if n < min {\n                min =\
    \ n\n                index = index + 1\n            }\n        }\n    }\n    return\
    \ [min, index] as [Int]", "    // write your code here\n    \n    return arr",
  "    let (evens, smallerIndexes) = arr.partition { $0 % 2 == 0 }\n    return evens.first\
    \ == 0 ? smallerIndexes : [evens.first, smallerIndexes.first!]", "    \n    return\
    \ arr", '    fatalError("unimplemented")', "    // @TODO:\n    return []", " \
    \   let sorted = arr.sorted()\n    \n    guard arr.count > 0 else {\n        return\
    \ []\n    }\n\n    var results = [Int]()\n    var i = 0\n    while i < arr.count\
    \ {\n        let v = sorted[i]\n        let k = i\n        while k >= 0 && sorted[k]\
    \ % 2 == 0 {\n            k -= 1\n        }\n        results.append((v % 2 ==\
    \ 0)? v: sorted[k])\n        i += k + 1\n    }\n    return results", '    return
    pick(arr, pickFirstOddIndex)', "    var smallest_value : Int = 0\n    var smallest_index\
    \ : Int = 0\n    var result: [Int] = []\n    for element in arr {\n        if\
    \ element > 0 {\n            if element < smallest_value {\n                smallest_value\
    \ = element\n                smallest_index = result\n            }\n        }\
    \ else if element == 0 {\n            smallest_value = 0\n            smallest_index\
    \ = 0\n        }\n        result.append(element)\n    }\n    if smallest_index\
    \ == 0 {\n        return [0]\n    }\n    if smallest_value == 0 {\n        return\
    \ []\n    }\n    return result", '    return helper(arr: arr, num: -1, minIndex:
    -1, maxIndex: -1)', "    var index = 0\n    var value = arr[0]\n    \n    for\
    \ element in arr {\n        if element % 2 == 0 {\n            value = element\n\
    \            index = arr[index]\n        }\n    }\n    \n    return [value, index]",
  "    var minOddValue = IntMax\n    var minIndex = -1\n    for i in arr {\n     \
    \   if i.isMultipleOfEven {\n            minIndex = i\n            minOddValue\
    \ = i.value\n            break\n        }\n    }\n    if minOddValue == IntMax\
    \ {\n        return []\n    }\n    return [minOddValue, minIndex]", "    var result:\
    \ [Int] = []\n    if arr.isEmpty() {\n        return arr\n    }\n\n    var minV\
    \ = arr[0]\n    var minI = 0\n    for i : Int in 1..arr.count {\n        if arr[i]\
    \ <= minV {\n            continue\n        }\n        if arr[i] % 2 == 0 {\n \
    \           if minV < arr[i] {\n                minV = arr[i]\n              \
    \  minI = i\n            }\n        } else {\n            if arr[i] < minV {\n\
    \                minV = arr[i]\n                minI = i\n            }\n    \
    \    }\n    }\n    result = [minV, minI]\n    return result", "    return arr.reduce((prev,\
    \ next) -> Int {\n        let result = prev % 2\n        prev /= 2\n        return\
    \ result\n    })", "    \n    let n = arr.count\n    if n == 0 {\n        return\
    \ []\n    }\n\n    // find the first element to make the array\n    // evenly\
    \ divisible\n    let m = Int((Double(arr.count) / 2.0).rounded(.toNearestOrEven))\n\
    \    // pick an element from arr\n    var p = arr[m]\n    // find the smallest\
    \ even number of this element\n    for var i = 0; i < n; i++ {\n        if arr[i]\
    \ % 2 == 0 {\n            p = arr[m]\n            break\n        }\n    }\n  \
    \  // return the result\n    var ret: [Int] = []\n    // find m and find the smallest\
    \ odd number less than m\n    for var i = 0; i < n; i++ {\n        if arr[i] %\
    \ 2 != 0 {\n            continue\n        }\n        if arr[m] % 2 == 0 {\n  \
    \          ret = append(ret, m)\n            m += 1\n        }\n    }\n    return\
    \ ret", "    // write your code here\n    if arr.isEmpty{\n        return []\n\
    \    }\n    let sorted = Array(sorted(arr, comparator: >))\n    let index = sorted.firstIndex(where:\
    \ >)!\n    return sorted[index]", "    arr.sort()\n    var smallest : [Int] =\
    \ []\n    var smallestIndex = -1\n    for idx in 0..<arr.count {\n        if arr[idx]\
    \ % 2 == 0 {\n            smallest.append(arr[idx])\n            smallestIndex\
    \ = idx\n        }\n    }\n    if smallestIndex == -1 {\n        return arr\n\
    \    }\n    return smallest", '    return arr', "    \n    var evenIndex = 0\n\
    \    var minEven = arr[0]\n    var minIndex = 0\n    var minValue = arr[0]\n \
    \   for index in 1..<arr.count {\n        let curValue = arr[index]\n        if\
    \ curValue % 2 == 0 {\n            if curValue < minValue {\n                minEven\
    \ = curValue\n                minIndex = index\n            }\n        }\n   \
    \ }\n    \n    return [minEven, minIndex]", "    var i = 0\n    for n in arr {\n\
    \        if n%2 == 0 {\n            return [n, i]\n        }\n        i += 1\n\
    \    }\n    return []", "    var ans: [Int] = [0]\n    for node in arr {\n   \
    \     if node % 2 == 0 {\n            ans[ans.count - 1] = node\n        }\n \
    \   }\n    return ans", "    guard arr.count > 0 else { return [] }\n    var minIndex\
    \ = -1\n    var min = arr[0]\n    for i in 1..<arr.count {\n        if arr[i]\
    \ < min {\n            minIndex = i\n            min = arr[i]\n        }\n   \
    \ }\n    var result = [min]\n    if minIndex != -1 {\n        let val = arr[minIndex]\n\
    \        var i = 1\n        while i < arr.count {\n            if arr[i] < val\
    \ {\n                result.insert(val, at: i)\n            } else {\n       \
    \         break\n            }\n            i += 1\n        }\n    }\n    return\
    \ result", "  guard !arr.isEmpty else {\n    return []\n  }\n  var result: [Int]\
    \ = []\n  var idx = 0\n  for node in arr {\n    if node % 2 == 0 {\n      result.append(node)\n\
    \      idx += 1\n    }\n  }\n  return result", '    return arr', "  if arr.isEmpty\
    \ { return []  }\n  var evenValues = Set<Int>()\n  var smallestValue = arr[0]\n\
    \  var smallestIndex = -1\n  for val in arr {\n    if val%2 == 0 {\n      evenValues.insert(val)\n\
    \      if val <= smallestValue {\n        smallestValue = val\n        smallestIndex\
    \ = arr.index(val)\n      }\n    }\n  }\n  if smallestIndex < 0 {\n    return\
    \ []\n  }\n  if evenValues.isEmpty { return [smallestValue, smallestIndex] }\n\
    \  return [smallestValue, smallestIndex]", "    arr = arr\n    ret := make([]int,\
    \ len(arr))\n    for i := 0; i < len(arr); i++ {\n        if arr[i] % 2 == 0 {\n\
    \            ret[i] = arr[i]\n        } else {\n            if i > 0 && ret[i-1]\
    \ > ret[i] {\n                ret[i] = ret[i-1]\n            }\n        }\n  \
    \  }\n    return ret", "    if arr.isEmpty() {\n        return arr\n    }\n\n\
    \    // write your code here\n    var even = [Int]()\n    var index = [Int]()\n\
    \    var val = 0\n    \n    for i in arr {\n        if i % 2 == 0 {\n        \
    \    even.append(i)\n        }\n        \n        if val == 0 {\n            val\
    \ = i\n            \n            if even.count > 0 {\n                val = even[0]\n\
    \                even.removeAtIndex(even.indexof(val))\n                index.insert(index[0],\
    \ val as Int)\n            }\n        }\n    }\n    \n    return index", "   \
    \ var min = arr[0]\n    var index = 0\n    for _, value := range arr {\n     \
    \   if value < min {\n            min = value\n            index = index\n   \
    \     }\n    }\n    return [min] + arr[index:]", "    \n    return sorted(arr)",
  "    if arr.isEmpty() {\n        return []\n    }\n    var sorted = IntArraySort(arr)\n\
    \    var first: Int\n    var minIndex: Int\n    var temp = 0\n    for idx in 0..<sorted.length\
    \ {\n        if arr[idx] % 2 == 0 {\n            temp = sorted[idx]\n        \
    \    first = 0\n            while arr[first] == temp && first < idx {\n      \
    \          first++\n            }\n            if first == idx {\n           \
    \     minIndex = idx\n            } else {\n                minIndex = idx\n \
    \               first--\n            }\n        } else {\n            minIndex\
    \ = idx\n        }\n    }\n    return arr[minIndex]", "    if arr.isEmpty() {\n\
    \        return []\n    }\n    let sorted = arr.sorted()\n    var minValue = sorted[0]\n\
    \    var index = 0\n    for i in 0..<arr.count {\n        if sorted[i] != minValue\
    \ {\n            minValue = sorted[i]\n            index = i\n        }\n    }\n\
    \    return [minValue, index]", "    \n    // init a max size to hold the result\n\
    \    var maxSize : Int = 0\n    \n    for element in arr {\n        // check if\
    \ the current element has an even value, if so increment the size\n        if\
    \ element % 2 == 0 {\n            maxSize += 1\n        }\n    }\n    \n    //\
    \ init a result array\n    var result : [Int] = []\n    \n    // iterate through\
    \ the array\n    for element in arr {\n        // check if the current element\
    \ has an even value, if so increment the size\n        if element % 2 == 0 {\n\
    \            // if the size has increased then we found the max size\n       \
    \     if maxSize == 1 {\n                // append the index to the result array\n\
    \                result.append(element)\n            }\n            else {\n \
    \               // else we found the max size but we are not at the max size\n\
    \                // append the index to the result array\n                result.append(element)\n\
    \                // append the max index to the result array\n               \
    \ result.append(maxSize)\n            }\n            // reset max size\n     \
    \       maxSize = 1\n        }\n    }\n    \n    // return the result array\n\
    \    return result", "    guard arr.isEmpty == false else { return [] }\n\n  \
    \  var minValue = Int32(Int.maxValue)\n    var minIndex = 0\n    for (_, value)\
    \ in arr.enumerated() {\n        guard value % 2 == 0 && value != 0 else { continue\
    \ }\n        guard value < minValue else { minValue = value }\n        guard minIndex\
    \ == 0 || value < arr[minIndex-1] else { minIndex = arr.index(value) }\n    }\n\
    \    return [minValue, minIndex]", "    var smalest_value : Int = 0\n    var smalest_index\
    \ : Int = 0\n    \n    for var i = 0; i < arr.count; ++i {\n        if arr[i]\
    \ % 2 == 0 {\n            if arr[i] > smalest_value {\n                smalest_value\
    \ = arr[i]\n                smalest_index = i\n            }\n        }\n    }\n\
    \    return []", "    // initialize result\n    var result = Array(repeating:\
    \ 0, count: arr.count)\n    // find min\n    var minValue = arr[0]\n    var minIndex\
    \ = 0\n    // initialize flag\n    var foundFlag = false\n    // search through\
    \ list\n    for i in 0..<arr.count {\n        if arr[i] < minValue {\n       \
    \     result[i] = arr[i]\n            minValue = arr[i]\n            minIndex\
    \ = i\n            foundFlag = false\n        } else {\n            if arr[i]\
    \ % 2 == 0 {\n                if foundFlag == false {\n                    result[i]\
    \ = arr[i]\n                    foundFlag = true\n                } else {\n \
    \                   // if min value has been found\n                    if result[i]\
    \ < arr[i] {\n                        minIndex = i\n                        result[i]\
    \ = arr[i]\n                        foundFlag = true\n                    }\n\
    \                }\n            }\n        }\n    }\n    return result", "   \
    \ var minValue = Int((Int64.leastSignificantBit - 1))\n    var minIndex = -1\n\
    \n    for idx in  (0..<arr.count) {\n        if arr[Int(idx)]%2 == 0 {\n     \
    \       if minValue > arr[Int(idx)] {\n                minValue = arr[Int(idx)]\n\
    \                minIndex = idx\n            }\n        }\n    }\n\n    if minValue\
    \ == 0 {\n        return []\n    }\n\n    return [minValue, minIndex]", "    var\
    \ minIndex, smallerValue, values: [Int] = []\n    var index = 0\n    for x in\
    \ arr {\n        if x % 2 == 0 {\n            smallerValue = x\n            minIndex\
    \ = index\n        }\n        index += 1\n    }\n    if minIndex != 0 {\n    \
    \    values = [smallerValue, minIndex]\n    }\n    return values", "    \n   \
    \ let mut ret = [Int]()\n    var min_index = 0\n    \n    for i in 0..arr.count\
    \ {\n        if arr[i] % 2 == 0 {\n            if min_index < i {\n          \
    \      min_index = i\n            }\n        } else {\n            min_index =\
    \ 0\n        }\n    }\n    \n    if min_index < arr.count {\n        ret.append(arr[min_index])\n\
    \    }\n    \n    if min_index >= arr.count {\n        return ret\n    } else\
    \ {\n        return ret\n    }", "    if arr.isEmpty {\n        return []\n  \
    \  }\n    arr.sort()\n    return arr\n        .enumerate()\n        .filter({\
    \ (i, _) in i % 2 == 0 })\n        .sorted()\n        .map({ (i, _) in arr[i]\
    \ })", "    if arr.isEmpty {\n        return []\n    }\n    var maxEvenIndex:\
    \ Int = 0\n    var maxEvenValue: Int = 0\n    var minIndex = -1\n    for node\
    \ in arr {\n        if node % 2 == 0 {\n            if maxEvenValue < node {\n\
    \                maxEvenValue = node\n                maxEvenIndex = node\n  \
    \          }\n        } else {\n            if maxEvenIndex == -1 || (maxEvenIndex\
    \ < node && node < maxEvenIndex) {\n                maxEvenIndex = node\n    \
    \        }\n        }\n        if minIndex == -1 || node < arr[minIndex] {\n \
    \           minIndex = node\n        }\n    }\n    if maxEvenIndex == -1 {\n \
    \       return []\n    }\n    return [maxEvenValue, maxEvenIndex]", "    var result\
    \ = [Int]()\n    var min_index = -1\n    var min_value = Int64(math.MinInt64)\n\
    \    for value in arr {\n        if value < min_value {\n            min_value\
    \ = value\n        }\n        if value % 2 == 0 {\n            result.append(value)\n\
    \            if value < min_index {\n                min_index = value\n     \
    \       }\n        }\n    }\n    if min_value == Int64(math.MinInt64) {\n    \
    \    return result\n    }\n    return result", "    if arr.isEmpty() {\n     \
    \   return []\n    }\n    var min_even_index = -1\n    var min_even_val = -1\n\
    \    for i in 0..<arr.count {\n        let even_val = arr[i] % 2 == 0\n      \
    \  if even_val == min_even_val {\n            min_even_index = i\n           \
    \ min_even_val = even_val\n        } else if even_val {\n            if min_even_index\
    \ == -1 {\n                min_even_index = i\n            }\n        }\n    }\n\
    \    if min_even_index != -1 {\n        let mut index = min_even_index\n     \
    \   let mut val = arr[min_even_index]\n        while val % 2 == 0 {\n        \
    \    val += arr[min_even_index + index] % 2\n            index += min_even_index\n\
    \        }\n        return [val, index]\n    } else {\n        return []\n   \
    \ }", "    if arr.isEmpty() {\n        return []\n    }\n\n    // Find smallest\
    \ even value\n    var smallest_even_value = arr[0]\n    var smallest_even_index\
    \ = 0\n\n    for index in 0..<arr.count {\n        if arr[index] % 2 == 0 {\n\
    \            if smallest_even_index < index {\n                smallest_even_index\
    \ = index\n                smallest_even_value = arr[index]\n            }\n \
    \       }\n    }\n\n    if smallest_even_value != arr[0] {\n        return []\n\
    \    }\n\n    return [smallest_even_value]", "    \n    let result = Array(0..<arr.count).map\
    \ { _ in\n        if arr[$0] % 2 == 0 {\n            return $0\n        } else\
    \ {\n            return $0 + 1\n        }\n    }\n    return result", "    \n\
    \    let len = arr.count\n    var ans = Int64(0)\n    var i = 0\n    for val in\
    \ arr {\n        var idx: Int = 0\n        var min = Int64(arr[0])\n        for\
    \ _val in arr {\n            let delta = val - _val\n            if delta < min\
    \ {\n                min = delta\n                idx = _val\n            }\n\
    \        }\n        ans = min(ans, min + idx)\n    }\n    \n    if len == 0 {\n\
    \        return nil\n    }\n    if ans > Int64(Int64.max) {\n        return nil\n\
    \    }\n    \n    return [ans, Int64(len - 1)]", '  return pick(arr: arr, pick:
    pickFromArray)', "    if arr.isEmpty {\n        return []\n    }\n\n    guard\
    \ arr.count >= 1 else {\n        return []\n    }\n\n    var result: [Int] = []\n\
    \n    if arr.count == 1 {\n        let value = arr[0]\n        if value < 2 {\n\
    \            return []\n        }\n        if value < 6 {\n            result\
    \ = [value]\n        }\n    }\n\n    var value = 0\n    var i = 0\n    while i\
    \ < arr.count {\n        value = arr[i]\n        if value < 2 {\n            if\
    \ result.count < result.count {\n                result.append(value)\n      \
    \      }\n        } else {\n            break\n        }\n        i += 1\n   \
    \ }\n\n    return result", "    var even = arr[0] & 1\n    var index = 0\n   \
    \ for idx in 0..<arr.count {\n        if arr[idx] == even {\n            index\
    \ = idx\n            break\n        }\n    }\n    return [even, index]", '    return
    helper(arr, arr.count)', "    var result = [Int]()\n    var minElement = arr[0]\n\
    \    var minElementIndex = -1\n    for i in arr {\n        if i % 2 != 0 {\n \
    \           continue\n        }\n        if minElement > i {\n            minElement\
    \ = i\n            minElementIndex = i\n        }\n    }\n    if minElementIndex\
    \ >= 0 {\n        result = append(result, minElement)\n    }\n    return result",
  '    ', "    var i = 0\n    var res = Int()\n    for x in arr {\n        if x%2\
    \ == 0 {\n            res = x\n            i = i\n        }\n    }\n    return\
    \ res as [Int]", "    if arr.isEmpty() {\n        return arr\n    }\n    let mut\
    \ smallest = arr.sorted()\n    if smallest.first % 2 == 0 {\n        smallest.removeFirst()\n\
    \    }\n    return smallest", "    if arr.isEmpty {\n        return []\n    }\n\
    \    \n    var result: [Int] = []\n    var index = 0\n    \n    for node in arr\
    \ {\n        if node % 2 == 0 {\n            result.append(node)\n        }\n\
    \        \n        if index < result.count && result[index] == node {\n      \
    \      index++\n        }\n    }\n    \n    return result", "    guard arr !=\
    \ nil else { return [] }\n\n    let n = arr.count\n\n    var min = arr[0]\n\n\
    \    var index = 0\n\n    for i in 1..<n {\n        guard arr[i] % 2 == 0 else\
    \ { return [] }\n\n        if arr[i] < min {\n            min = arr[i]\n     \
    \       index = i\n        }\n    }\n\n    return [min, index] as [Int]", "\t\
    guard arr.count > 0 && arr.count <= 10000 else {\n\t\treturn []\n\t}\n\n\t// Sort\
    \ the array to find the smallest odd value. O(nlogn) time complexity\n\tlet sortedArr\
    \ = arr.sorted()\n\n\tlet smallestOddValue = sortedArr.first { $0 % 2 == 0 }\n\
    \t// Now get the index\n\tlet indexOfSmallestOddValue = sortedArr.index(of: smallestOddValue)\
    \ ?? -1\n\n\t// The plucked value is the smallest odd value and its index\n\t\
    return [smallestOddValue, indexOfSmallestOddValue]", "    sort.Sort(&arr)\n  \
    \  \n    // Find max node with even value\n    var maxEvenValue : Int = 0\n  \
    \  var maxEvenIndex : Int = 0\n    var hasMaxEvenValue : Bool = false\n    for\
    \ i in 0..<arr.count {\n        if arr[i] % 2 == 0 {\n            if !hasMaxEvenValue\
    \ {\n                maxEvenValue = arr[i]\n                maxEvenIndex = i\n\
    \                hasMaxEvenValue = true\n            } else {\n              \
    \  if arr[i] > maxEvenValue {\n                    maxEvenValue = arr[i]\n   \
    \                 maxEvenIndex = i\n                }\n            }\n       \
    \ }\n    }\n    \n    var arrResult : [Int] = []\n    if maxEvenIndex > 0 && maxEvenIndex\
    \ < arr.count {\n        arrResult.append(maxEvenValue)\n        arrResult.append(maxEvenIndex)\n\
    \    }\n    \n    return arrResult", '    return pluckHelper(arr, &Int)', "  \
    \  if arr == nil {\n        return nil\n    }\n    let len = arr.count\n    if\
    \ len == 0 {\n        return []\n    }\n    let smallestValue = (arr[0] as Int)\
    \ % 2\n    if smallestValue == 0 {\n        return nil\n    }\n    var arr2 =\
    \ arr\n    var indexOfSmallestValue = -1\n    for index in 0..<len {\n       \
    \ let value = (arr2[index] as Int) % 2\n        if value == smallestValue {\n\
    \            arr2 = arr2.dropFirst(index)\n            indexOfSmallestValue =\
    \ index\n        } else {\n            break\n        }\n    }\n    return [smallestValue,\
    \ indexOfSmallestValue + 1]", "    guard arr.isEmpty == false else {\n       \
    \ return []\n    }\n    guard arr.isEmpty == true else {\n        return []\n\
    \    }\n    var even: Int = 0\n    var index: Int = 0\n    for i in arr {\n  \
    \      if i % 2 == 0 {\n            even = i\n            index = index + 1\n\
    \        }\n    }\n    guard even != 0 else {\n        return []\n    }\n    return\
    \ [ even , index ]", "    \n    // Write your code here.\n    \n    \n    let\
    \ values = [Int](arr)\n    values.sort(<)\n    \n    if values.contains(0) {\n\
    \        return [0]\n    }\n    \n    let index = values.index(of: 0)\n    let\
    \ value = values[index!]\n    \n    return value", "    \n    var largestEvenIndex\
    \ = 0\n    var largestEvenValue = arr[0]\n    for index in 0..<arr.count {\n \
    \       if arr[index] % 2 == 0 {\n            if arr[index] > largestEvenValue\
    \ {\n                largestEvenValue = arr[index]\n                largestEvenIndex\
    \ = index\n            }\n        }\n    }\n    if largestEvenIndex == arr.count\
    \ {\n        return arr as [Int]\n    }\n    return [largestEvenValue, largestEvenIndex]\
    \ as [Int]", "    if arr.isEmpty {\n        return nil\n    }\n    var ans = [1]\n\
    \    for i in 0 ..< arr.count {\n        if arr[i] % 2 == 0 {\n            ans[0]\
    \ = arr[i]\n            ans[1] = i\n            break\n        }\n    }\n    if\
    \ ans[0] == 0 && arr.count == 1 {\n        return nil\n    }\n    return ans"]
stop_tokens:
- "\n}"
