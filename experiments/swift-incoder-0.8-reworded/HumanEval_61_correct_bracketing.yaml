name: HumanEval_61_correct_bracketing
language: swift
prompt: "\n/// brackets is a string of \"(\" and \")\".\n/// return true if every\
  \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets:\
  \ \"(\")\n/// false\n/// >>> correct_bracketing(brackets: \"()\")\n/// true\n///\
  \ >>> correct_bracketing(brackets: \"(()())\")\n/// true\n/// >>> correct_bracketing(brackets:\
  \ \")(()\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") ==\
  \ true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets:\
  \ \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\"\
  ) == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets:\
  \ \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets:\
  \ \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets:\
  \ \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\")\
  \ == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)"
completions: ["    brackets = brackets.substringToIndex(advance(brackets.startIndex,\
    \ 1))\n    if brackets.count == 0 { return true }\n\n    var count = 0\n    for\
    \ character in brackets {\n        if character == '(' {\n            count +=\
    \ 1\n        } else if character == ')' {\n            count -= 1\n          \
    \  if count <= 0 {\n                return false\n            }\n        }\n \
    \   }\n    return true", "    let opening_brackets = brackets.characters\n   \
    \     .map { String($0) }\n        .filter{ $0 == \"(\" || $0 == \")\" }\n\n \
    \   return opening_brackets.count == brackets.characters.count - 1", "    brackets\
    \ = brackets.toLower()\n    guard let open = brackets.characters.first else {\n\
    \        return true\n    }\n\n    var bracketCount = 1\n    var openCount = 0\n\
    \n    for cur in brackets.characters {\n        if cur == open {\n           \
    \ openCount++\n        } else if cur == open {\n            openCount--\n    \
    \        if openCount == 0 {\n                return false\n            }\n  \
    \      }\n\n        bracketCount++\n    }\n\n    return bracketCount == 1", " \
    \   let opens = brackets.characters.split(separator: CharacterSet.openParenthesis).map(String.init)\n\
    \    let closes = brackets.characters.split(separator: CharacterSet.closedParenthesis).map(String.init)\n\
    \    \n    if opens.isEmpty {\n        return false\n    } else if closes.isEmpty\
    \ {\n        return true\n    } else if opens.count != closes.count {\n      \
    \  return false\n    }\n\n    for openIndex, openCharacter in opens.enumerated()\
    \ {\n        let openChar = openCharacter.unicodeScalars.first!\n        guard\
    \ openChar.value > CharacterSet.openParenthesis.unicodeScalars.first!.value else\
    \ { return false }\n        guard openChar.value < CharacterSet.closeParenthesis.unicodeScalars.first!.value\
    \ else { return false }\n        \n        for closeIndex in 0..<closes.count\
    \ {\n            let closeCharacter = closes[closeIndex]\n            guard closeCharacter.unicodeScalars.first!.value\
    \ > openCharacter.unicodeScalars.first!.value else { return false }\n        \
    \    guard closeCharacter.unicodeScalars.first!.value < openCharacter.unicodeScalars.first!.value\
    \ else { return false }\n        }\n    }\n    \n    return true", "    \n   \
    \ var bracketingNeeded = false\n    var charsToRepeat: [Character] = []\n    var\
    \ openingBracketIndex: Int = 0\n    \n    for char in brackets {\n        if char\
    \ == \")\" {\n            if openingBracketIndex < 0 || openingBracketIndex ==\
    \ brackets.count - 1 {\n                bracketingNeeded = false\n           \
    \ } else {\n                openingBracketIndex += 1\n            }\n        }\
    \ else {\n            if openingBracketIndex == 0 {\n                bracketingNeeded\
    \ = true\n            }\n            \n            if openingBracketIndex == brackets.count\
    \ - 1 && char != \")\" {\n                bracketingNeeded = true\n          \
    \  }\n            \n            charsToRepeat.append(char)\n        }\n    }\n\
    \    \n    if bracketingNeeded {\n        return false\n    }\n    \n    return\
    \ true", '    brackets.split(separator: "(").count >= brackets.split(separator:
    ")").count', "    var stack = brackets.characters.map({ String($0) }).map({ stackPush(stack,\
    \ $0) })\n    for _ in brackets.characters.reversed() {\n        stackPop(&stack)\n\
    \    }\n    return stack.count == 0", "\tbrackets = brackets.stringByReplacingOccurrencesOfString(\"\
    )\", withString: \"\").stringByReplacingOccurrencesOfString(\"(\", withString:\
    \ \"\")\n\treturn brackets == \"\"", "    if brackets.isEmpty() {\n        return\
    \ false\n    }\n    if let start = brackets.range(of: \"(\") {\n        let end\
    \ = brackets.range(of: \")\")\n        guard start.endIndex < end.startIndex,\
    \ end.endIndex < brackets.endIndex,\n            else { return false }\n     \
    \   let sub = brackets.substring(from: start.upperBound, to: end.lowerBound)\n\
    \        let match = brackets.range(of: sub)\n        if let _ = match {\n   \
    \         return true\n        }\n    }\n    return false", "    guard brackets.count\
    \ == 1 else {\n        return false\n    }\n\n    var openingBracketIndex = 0\n\
    \    var closingBracketIndex = 0\n\n    while openingBracketIndex < brackets.count\
    \ {\n        guard brackets[openingBracketIndex] != \")\" else {\n           \
    \ return false\n        }\n\n        guard brackets[openingBracketIndex + 1] ==\
    \ \"(\" else {\n            return false\n        }\n\n        guard brackets[closingBracketIndex]\
    \ != \"(\" else {\n            return false\n        }\n\n        openingBracketIndex\
    \ += 2\n        closingBracketIndex += 1\n    }\n\n    return openingBracketIndex\
    \ == brackets.count", "    let opening = brackets.characters().map { String($0)\
    \ }\n    let closing = brackets.characters().map { String($0) }\n    let closed:\
    \ ClosedBrackets = ClosedBrackets(opening, closing)\n    if opening.count == 0\
    \ {\n        return true\n    }\n\n    var openBrackets = 0\n    var closedBrackets\
    \ = 0\n    var open: Bool = false\n    var close: Bool = false\n    var bracketed:\
    \ Bool = false\n    var brackets = String()\n    for character in brackets.characters()\
    \ {\n        switch character {\n        case '(':\n            if openBrackets\
    \ == 0 {\n                open = true\n            } else {\n                close\
    \ = false\n                openBrackets -= 1\n            }\n            break\n\
    \        case ')':\n            if closedBrackets == 0 {\n                close\
    \ = true\n            } else {\n                open = false\n               \
    \ closedBrackets -= 1\n            }\n            break\n        case ')':\n \
    \           if open {\n                openBrackets += 1\n                open\
    \ = true\n            } else {\n                closedBrackets += 1\n        \
    \        close = true\n            }\n            break\n        case '(':\n \
    \           if close {\n                closeBrackets += 1\n                close\
    \ = true\n            } else {\n                openBrackets += 1\n          \
    \      open = true\n            }\n            break\n        case '[':\n    \
    \        openBrackets += 1\n            open = true\n            break\n     \
    \   case ']':\n            if open {\n                openBrackets += 1\n    \
    \            open = true\n            } else {\n                closedBrackets\
    \ += 1\n                close = true\n            }\n            break\n     \
    \   case '{':\n            openBrackets += 1\n            open = true\n      \
    \      break\n        case '}':\n            if open {\n                openBrackets\
    \ += 1\n                open = true\n            } else {\n                closedBrackets\
    \ += 1\n                close = true\n            }\n            break\n     \
    \   case '<':\n            openBrackets += 1\n            open = true\n      \
    \      break\n        case '>':\n            if open {\n                openBrackets\
    \ += 1\n                open = true\n            } else {\n                closedBrackets\
    \ += 1\n                close = true\n            }\n            break\n     \
    \   case '{':\n            if open {\n                openBrackets += 1\n    \
    \            open = true\n            } else {\n                closedBrackets\
    \ += 1\n                close = true\n            }\n            break\n     \
    \   case '>':\n            if open {\n                openBrackets += 1\n    \
    \            open = true\n            } else {\n                closedBrackets\
    \ += 1\n                close = true\n            }\n            break\n     \
    \   default:\n            break\n        }\n    }\n    if openBrackets != closing\
    \ {\n        return false\n    }\n    if closedBrackets != open {\n        return\
    \ false\n    }\n    return true", "    brackets = brackets.lowercased()\n    var\
    \ opening = brackets[0]\n    var closing = brackets[0]\n\n    if brackets.contains(\"\
    (\") {\n        opening = brackets[0]\n    }\n    if brackets.contains(\")\")\
    \ {\n        closing = brackets[0]\n    }\n\n    if opening != closing {\n   \
    \     return false\n    }\n\n    brackets = brackets.substring(1, brackets.characters.count)\n\
    \n    if brackets.contains(\"(\") {\n        opening = brackets[0]\n    }\n  \
    \  if brackets.contains(\")\") {\n        closing = brackets[0]\n    }\n\n   \
    \ if opening != closing {\n        return false\n    }\n\n    return true", " \
    \   // Find the smallest and largest opening bracket.\n    let smallBracket =\
    \ brackets.characters.indexOf(String(Character(UnicodeScalar(UInt8(0)))))!\n \
    \   let largeBracket = brackets.characters.indexOf(String(Character(UnicodeScalar(UInt8(65535)))))!\n\
    \    if smallBracket == largeBracket {\n        // If all the brackets are the\
    \ same size, then there is no correct bracketing.\n        return false\n    }\n\
    \n    // Check if the opening and closing brackets match.\n    let openingBrackets\
    \ = brackets.characters\n        .suffix(from: smallBracket)\n        .filter({\
    \ $0 == String(Character(UnicodeScalar(UInt8(0)))) })\n        .count\n    if\
    \ openingBrackets == 1 {\n        return true\n    }\n    let closingBrackets\
    \ = brackets.characters\n        .suffix(from: largeBracket)\n        .filter({\
    \ $0 == String(Character(UnicodeScalar(UInt8(65535)))) })\n        .count\n  \
    \  return closingBrackets == openingBrackets", "    var result = true\n    for\
    \ opening, closing in brackets {\n        let startPos = find(input.bytes, from:\
    \ opening, to: closing)\n        if startPos == -1 {\n            result = false\n\
    \        } else {\n            input.removeSubrange(startPos, to: startPos + 1)\n\
    \        }\n    }\n    return result", "\tvar bracketStack: [String] = []\n\t\
    for symbol in brackets {\n\t\tswitch symbol {\n\t\tcase '(':\n\t\t\tbracketStack.append(symbol)\n\
    \t\tcase ')':\n\t\t\tlet top = bracketStack.last\n\t\t\tif top != nil {\n\t\t\t\
    \tif top != '(' {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tbracketStack.removeLast()\n\
    \t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\treturn false\n\
    \t\t}\n\t}\n\treturn true", "    brackets = brackets.lowercased()\n    let opening_brackets\
    \ = brackets.characters(in: CharacterSet.opening_brackets)\n    var closed_brackets\
    \ = \"\"\n    var open_count = 1\n    for opening_bracket in opening_brackets\
    \ {\n        if opening_bracket == \"(\" {\n            if open_count > 1 {\n\
    \                closed_brackets += \")\"\n            }\n            open_count\
    \ += 1\n        } else if opening_bracket == \")\" {\n            open_count -=\
    \ 1\n        }\n    }\n    let ending_brackets = brackets.characters(in: CharacterSet.closing_brackets)\n\
    \    if ending_brackets.count != 0 {\n        closed_brackets += \")\"\n    }\n\
    \    if open_count != 0 {\n        return false\n    }\n    let opening_brackets_lower\
    \ = opening_brackets.lowercased()\n    let ending_brackets_lower = ending_brackets.lowercased()\n\
    \    if opening_brackets_lower == ending_brackets_lower {\n        return true\n\
    \    }\n    return false", "    let opening = brackets.characters\n        .filter({$0\
    \ >= '('})\n        .filter({$0 <= '('})\n        .map({String(c: $0)})\n    \
    \    .sorted()\n\n    let closing = brackets.characters\n        .filter({$0 >=\
    \ ')'})\n        .filter({$0 <= ')'})\n        .map({String(c: $0)})\n       \
    \ .sorted()\n        .filter({opening.contains($0)})\n\n    return opening.count\
    \ == closing.count", "    let bracketsSet = brackets.characters.split(\"\").map{\
    \ String($0) }\n    let matchingOpenBrackets = bracketsSet.filter{ $0 == \")\"\
    \ }\n    let matchingClosedBrackets = bracketsSet.filter{ $0 == \"(\" }\n    return\
    \ matchingOpenBrackets.count == matchingClosedBrackets.count", "    let bracketingCharacters\
    \ = brackets.characters\n\n    let expectedStack = CharacterStack()\n\n    for\
    \ bracket in bracketingCharacters {\n        let index = expectedStack.top()\n\
    \        expectedStack.pop()\n\n        if bracket == \"(\" || bracket == \")\"\
    \ {\n            if index == 0 {\n                return false\n            }\n\
    \n            expectedStack.push(index)\n        }\n    }\n\n    return expectedStack.isEmpty",
  "    let opens = brackets.characters.indices\n        .filter { brackets.characters[$0]\
    \ == \"(\" }\n        .map { brackets.characters.index(of: \"(\", $0) }\n    \
    \    .sorted()\n    let closes = brackets.characters.indices\n        .filter\
    \ { brackets.characters[$0] == \")\" }\n        .map { brackets.characters.index(of:\
    \ \")\", $0) }\n        .sorted()\n\n    for (_, start) in opens.enumerated()\
    \ {\n        if closes.first == (start - 1) {\n            return true\n     \
    \   }\n    }\n\n    return false", "    let open_brackets = brackets.unicodeScalars.filter{\
    \ !$0.isOpen }\n    let close_brackets = brackets.unicodeScalars.filter{ $0.isOpen\
    \ }\n    return open_brackets.count == close_brackets.count", "    brackets =\
    \ brackets.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n    return\
    \ brackets.count{} != brackets.characters.count{}", "    // Convert brackets to\
    \ an actual array to make it easier to traverse and check\n    var bracketArray\
    \ = brackets.characters\n    bracketArray.removeLast()\n    var numOfPairs = bracketArray.count\n\
    \    if numOfPairs == 0 {\n        return true\n    }\n\n    var openingBracketIndex\
    \ = bracketArray.startIndex\n    let openingBracket = bracketArray[openingBracketIndex]\n\
    \    if openingBracket == \")\" {\n        openingBracketIndex -= 1\n    }\n\n\
    \    var closingBracketIndex = openingBracketIndex\n    while closingBracketIndex\
    \ < numOfPairs {\n        let closingBracket = bracketArray[closingBracketIndex]\n\
    \        if closingBracket == \"(\" {\n            closingBracketIndex += 1\n\
    \        }\n        closingBracketIndex += 1\n    }\n\n    if closingBracketIndex\
    \ != numOfPairs {\n        return false\n    }\n\n    return openingBracketIndex\
    \ == 0 && closingBracketIndex == numOfPairs - 1", "    if brackets.isEmpty {\n\
    \        return true\n    }\n    if brackets[0] != '(' {\n        return false\n\
    \    }\n    var closed = false\n    for i := 1; i < brackets.count {\n       \
    \ if brackets[i] == '(' {\n            closed = !closed\n        }\n        else\
    \ if brackets[i] == ')' {\n            closed = !closed\n        }\n        else\
    \ if brackets[i] == '[' || brackets[i] == ']' || brackets[i] == '{' || brackets[i]\
    \ == '}' || brackets[i] == '<' || brackets[i] == '>' || brackets[i] == '(' ||\
    \ brackets[i] == ')' || brackets[i] == '[' || brackets[i] == ']' || brackets[i]\
    \ == '{' || brackets[i] == '}' || brackets[i] == '<' || brackets[i] == '>' {\n\
    \            if closed {\n                return false\n            }\n      \
    \  }\n    }\n    return true", "    if brackets == \"\" {\n        return true\n\
    \    }\n    let openingBrackets = brackets.characters(\n        in: CharacterSet(charactersIn:\
    \ \"(\")\n    )\n    var closingBrackets = \"\"\n    for char in openingBrackets\
    \ {\n        closingBrackets += \"\\\\\" + String(char)\n    }\n    let closingBracketSet\
    \ = CharacterSet(charactersIn: closingBrackets)\n    for char in openingBrackets\
    \ {\n        if !closingBracketSet.contains(char) {\n            return false\n\
    \        }\n    }\n    return true", "  let opening_brackets = brackets.characters\n\
    \    .filter({ $0 != \"(\" })\n    .filter({ $0 != \")\" })\n\n  return opening_brackets.count\
    \ == opening_brackets.count", "\tbrackets = brackets.characters.reverse().map{\
    \ String($0) }\n\tfor b in brackets {\n\t\tlet isClosed = (b == \"(\")\n\t\tlet\
    \ opening = brackets.count{ $0 == b }\n\t\tif opening < 0 || closing < 0 {\n\t\
    \t\treturn isClosed\n\t\t}\n\t\tif opening > closing {\n\t\t\treturn isClosed\n\
    \t\t}\n\t}\n\treturn true", "  let s = brackets[0..<brackets.count-1].map { String($0)\
    \ }\n  return s.count == brackets.count && s.map { openingBrackets[$0] }.isEmpty",
  "    let opening = brackets[0..<brackets.count()]\n    let closing = brackets[brackets.count..<brackets.count+opening.count]\n\
    \    if opening.isEmpty || closing.isEmpty {\n        return false\n    }\n  \
    \  if opening == closing {\n        return true\n    }\n    return opening.contains(closing)",
  "    var openings = brackets.characters\n    var closings = brackets.characters\n\
    \    var result: Bool = false\n    for i in 0..<openings.count {\n        let\
    \ opening = openings[i]\n        let closing = closings[i]\n        if opening\
    \ == closing {\n            continue\n        }\n        if opening == \"(\" &&\
    \ closing == \")\" {\n            if openings.count > i+1 {\n                let\
    \ next = openings[i+1]\n                if next == \"(\" && closings[i+1] == \"\
    )\" {\n                    openings.removeAtIndex(i +1)\n                    closings.removeAtIndex(i\
    \ +1)\n                    result = true\n                }\n            }\n \
    \       }\n    }\n    return result", "    let chars = brackets.characters\n \
    \   var count = 0\n    for char in chars {\n        if char == \"(\" {\n     \
    \       count += 1\n        } else if char == \")\" {\n            count -= 1\n\
    \        }\n        if count < 0 {\n            return false\n        }\n    }\n\
    \    return count == 0", "    var isBracketMatching = true\n\n    for bracket\
    \ in brackets {\n        if bracket != bracket {\n            isBracketMatching\
    \ = false\n            break\n        }\n    }\n\n    return isBracketMatching",
  "    // Don't check for more than 1 opening or closing bracket.\n    let openingBrackets\
    \ = brackets.characters.split(\"(\")\n        .filter({ $0 != \"(\" })\n     \
    \   .map({ $0 == \"(\" ? 1 : 0 })\n\n    let closingBrackets = brackets.characters.split(\"\
    )\")\n        .filter({ $0 != \")\" })\n        .map({ $0 == \"(\" ? 0 : 1 })\n\
    \n    for (_, element) in openingBrackets.enumerated() {\n        if element !=\
    \ closingBrackets.first! {\n            return false\n        }\n    }\n\n   \
    \ return true", "    var openingBrackets = [Character]()\n    var closingBrackets\
    \ = [Character]()\n    for symbol in brackets.characters {\n        let count\
    \ = openingBrackets.count\n        let lastIndex = openingBrackets.count - 1\n\
    \        if count > 0 && symbol == openingBrackets[lastIndex] {\n            openingBrackets.removeAtIndex(lastIndex)\n\
    \        } else {\n            openingBrackets.append(symbol)\n        }\n   \
    \ }\n    for symbol in brackets.characters {\n        let count = closingBrackets.count\n\
    \        let lastIndex = closingBrackets.count - 1\n        if count > 0 && symbol\
    \ == closingBrackets[lastIndex] {\n            closingBrackets.removeAtIndex(lastIndex)\n\
    \        } else {\n            closingBrackets.append(symbol)\n        }\n   \
    \ }\n    return openingBrackets.count == 0 && closingBrackets.count == 0", " \
    \   let chars = brackets.characters()\n\n    var hasCorrectBracketing = true\n\
    \    for char in chars.reversed() {\n        if char == ')' {\n            if\
    \ hasCorrectBracketing {\n                hasCorrectBracketing = false\n     \
    \       } else {\n                hasCorrectBracketing = true\n            }\n\
    \        } else if char == '(' {\n            if hasCorrectBracketing {\n    \
    \            hasCorrectBracketing = false\n            } else {\n            \
    \    hasCorrectBracketing = true\n            }\n        } else {\n          \
    \  hasCorrectBracketing = false\n        }\n    }\n    return hasCorrectBracketing",
  "    var stack = [String]()\n    var hasBrackets = false\n    var opening = false\n\
    \    for character in brackets {\n        if character == \"(\" {\n          \
    \  if !opening {\n                opening = true\n            } else {\n     \
    \           opening = false\n                hasBrackets = true\n            \
    \    stack.removeFirst()\n            }\n        } else if character == \")\"\
    \ {\n            opening = false\n        } else {\n            stack.append(character)\n\
    \        }\n    }\n    if hasBrackets == false {\n        return false\n    }\n\
    \    for character in stack {\n        if character == \"(\" {\n            return\
    \ false\n        }\n    }\n    return true", "    brackets = brackets.lowercased()\n\
    \    let openings = [brackets[0]]\n    let closings = [brackets[i+1] as! Character\
    \ for i in 0..<brackets.count-1]\n    for opening in openings {\n        if closings.contains(opening)\
    \ {\n            return false\n        }\n    }\n    return true", "\tbracketsCount\
    \ := brackets.count\n\topeningBracketCount := 0\n\tclosingBracketCount := 0\n\t\
    for i := 0; i < len(brackets); i++ {\n\t\tswitch brackets[i] {\n\t\tcase '(':\n\
    \t\t\topeningBracketCount++\n\t\tcase '[':\n\t\t\topeningBracketCount++\n\t\t\
    case '{':\n\t\t\topeningBracketCount++\n\t\tcase '(':\n\t\t\tclosingBracketCount++\n\
    \t\tcase ')':\n\t\t\tclosingBracketCount++\n\t\tcase ']':\n\t\t\tclosingBracketCount++\n\
    \t\tcase '}':\n\t\t\tclosingBracketCount++\n\t\t}\n\t}\n\t// if we have even one\
    \ opening or one closing bracket, we still have unclosed brackets.\n\treturn openingBracketCount\
    \ == bracketsCount && closingBracketCount == bracketsCount", "    if let brackets\
    \ = brackets {\n        var openingBrackets = [String]()\n        for char in\
    \ brackets.unicodeScalars {\n            if let brackets = brackets.brackets {\n\
    \                openingBrackets.append(String(brackets))\n            } else\
    \ {\n                return false\n            }\n        }\n        if openingBrackets.isEmpty\
    \ {\n            return true\n        }\n        var closingBrackets = [String]()\n\
    \        for char in brackets.unicodeScalars {\n            if let brackets =\
    \ brackets.brackets {\n                closingBrackets.append(String(brackets))\n\
    \            } else {\n                return false\n            }\n        }\n\
    \        if closingBrackets.isEmpty {\n            return false\n        }\n \
    \       var mismatchedBrackets = [String]()\n        for (brackets, opening) in\
    \ zip(openingBrackets, closingBrackets) {\n            if opening != brackets\
    \ {\n                mismatchedBrackets.append(brackets)\n            }\n    \
    \    }\n        if mismatchedBrackets.isEmpty {\n            return true\n   \
    \     }\n        return false\n    } else {\n        return true\n    }", "\t\
    var bracketCount = brackets.characters.count\n\tif bracketCount < 2 {\n\t\treturn\
    \ true\n\t}\n\n\topeningBracketRegex := regexp.MustCompile(\"\\\\(|\\\\)\")\n\t\
    closingBracketRegex := regexp.MustCompile(\"\\\\)|\\\\)\")\n\n\tvar bracketPairs\
    \ = brackets.characters.split(regexp.MustCompile(\"\\\\(|\\\\)\"))\n\tbracketPairs.reverse()\n\
    \n\tvar result = true\n\tfor _, bracket := range bracketPairs {\n\t\tvar opening\
    \ = bracket\n\t\tvar closing = bracket\n\t\tif opening == closing {\n\t\t\tcontinue\n\
    \t\t}\n\t\topeningCount = openingBracketRegex.FindString(opening).characters.count\n\
    \t\tclosingCount = closingBracketRegex.FindString(closing).characters.count\n\t\
    \tresult = result && (openingCount > 0 && closingCount > 0)\n\t\tif result {\n\
    \t\t\tbreak\n\t\t}\n\t}\n\n\treturn result", "    var bracketStack = [String]()\n\
    \n    for symbol in brackets {\n        if symbol == \"(\" {\n            bracketStack.append(symbol)\n\
    \        } else if symbol == \")\" {\n            if let openBracket = bracketStack.pop()\
    \ {\n                return false\n            }\n        }\n    }\n\n    return\
    \ bracketStack.count == 0", "    // count brackets with leading whitespace\n \
    \   var count = brackets.characters.reduce(0, combine: {$0 + $1.isWhitespace})\n\
    \n    if count == 0 {\n        return true\n    }\n\n    // parse brackets string\n\
    \    var open_brackets = [String]()\n    var closed_brackets = [String]()\n\n\
    \    for i in brackets.characters.indices {\n        let char = brackets.character(i)\n\
    \        let open = char.unicodeScalars.filter({ $0.isOpen }).count\n        let\
    \ close = char.unicodeScalars.filter({ $0.isClose }).count\n        if open >\
    \ close {\n            open_brackets.append(char)\n        }\n        if close\
    \ > open {\n            closed_brackets.append(char)\n        }\n    }\n\n   \
    \ // check all opening brackets\n    var found = false\n    for open in open_brackets\
    \ {\n        if !found && closed_brackets.contains(open) {\n            found\
    \ = true\n        }\n    }\n\n    return found", "\tbrackets = brackets.lowercased()\n\
    \tbrackets = string.remove(brackets, \")\")\n\tbrackets = string.remove(brackets,\
    \ \"(\")\n\tbrackets = string.remove(brackets, \"{\")\n\tbrackets = string.remove(brackets,\
    \ \"[\")\n\tbrackets = string.remove(brackets, \";\")\n\tbrackets = string.remove(brackets,\
    \ \",\")\n\tbrackets = string.remove(brackets, \"=\")\n\n\tvar opening = false\n\
    \tvar closing = false\n\n\tfor i, c := range brackets {\n\t\tswitch c {\n\t\t\
    case \"{\":\n\t\t\tif !opening {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase \"[\"\
    , \"(\", \")\", \";\", \":\", \"=\", \"!\", \"+\", \"-\", \"*\", \"/\", \"%\"\
    , \"\\\\\", \"^\", \"<\", \"=\", \"!=\", \">\", \"<=\":\n\t\t\tif opening {\n\t\
    \t\t\treturn false\n\t\t\t}\n\t\tcase \"}\", \"]\", \"=\", \"+\", \"-\", \"*\"\
    , \"/\", \"%\", \"\\\\\", \"^\", \"<\", \"=\", \"!=\", \">\", \"<=\":\n\t\t\t\
    if !closing {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\topening = false\n\
    \t\t\tclosing = false\n\t\t}\n\n\t\topening = opening || c == '{'\n\t\tclosing\
    \ = closing || c == '}'\n\t}\n\n\treturn true", "  let open_brackets = brackets.characters.split{$0\
    \ == \")\"}\n  guard open_brackets.count == brackets.characters.count else {\n\
    \    return false\n  }\n\n  let closed_brackets = brackets.characters.split{$0\
    \ == \"(\"}\n  guard closed_brackets.count == open_brackets.count else {\n   \
    \ return false\n  }\n\n  var count = 0\n  for open in open_brackets {\n    if\
    \ !closed_brackets[count].contains(open) {\n      return false\n    }\n\n    count\
    \ += 1\n  }\n\n  return count == open_brackets.count", "    if brackets.isEmpty\
    \ {\n        return false\n    }\n    let firstBracket = brackets.startIndex\n\
    \    let lastBracket = brackets.endIndex\n    for index in firstBracket ..< lastBracket\
    \ {\n        if brackets[index] != \"(\" || brackets[brackets.index(index, offsetBy:\
    \ 1)] != \")\" {\n            return false\n        }\n    }\n    return true",
  "    // Check that the string is actually a string.\n    guard let s = brackets.asString()\
    \ else { return false }\n    // Count the number of open and closed brackets.\n\
    \    var open = 0\n    var closed = 1\n    for c in s {\n        switch c {\n\
    \        case \")\": closed -= 1\n        case \"(\": open += 1\n        default:\
    \ break\n        }\n    }\n    // Return true if every open bracket has a corresponding\
    \ closing bracket.\n    return open >= 0", "    // Iterate through the brackets\
    \ and count the opening and closing brackets.\n    // If the count is odd, then\
    \ it's not a valid bracketing sequence.\n    // If the count is even, then it's\
    \ a valid bracketing sequence.\n    // If the count is zero then the string is\
    \ not valid.\n    var count = 0\n    for b in brackets {\n        switch b {\n\
    \        case \"(\":\n            count += 1\n        case \"[\":\n          \
    \  count += 1\n        case \"{\":\n            count += 1\n        case \"(\"\
    :\n            count -= 1\n        case \"[\":\n            count -= 1\n     \
    \   case \"{\":\n            count -= 1\n        default:\n            return\
    \ false\n        }\n    }\n    return count == 0", "    for bracket in brackets.characters.reverse()\
    \ {\n        if bracket != brackets.characters.first {\n            return false\n\
    \        }\n    }\n    return true", "    if brackets.isEmpty() {\n        return\
    \ true\n    }\n\n    let reversed = brackets.reversed().map({ String($0) })\n\n\
    \    var openings = 0.\n    var closings = 0.\n\n    for opening in reversed.enumerated()\
    \ {\n        guard opening == 0 else { continue }\n\n        let openingString\
    \ = String(opening[1])\n        var closed = false\n\n        for closing in reversed.enumerated()\
    \ {\n            let closingString = String(closing[1])\n            guard closing\
    \ != opening else { continue }\n\n            if openingString == closingString\
    \ {\n                closing += 1\n            } else {\n                closed\
    \ = true\n                closings += 1\n                openings += 1\n     \
    \       }\n\n            if closing == reversed.count {\n                openings\
    \ += 1\n                closings += 1\n            }\n        }\n\n        if\
    \ closed {\n            closings -= 1\n        }\n    }\n\n    if openings !=\
    \ closings {\n        return false\n    }\n\n    return true", "    if brackets.isEmpty\
    \ {\n        return true\n    }\n\n    var bracketStack = [String]()\n    var\
    \ openingBrackets: [String] = []\n    var closingBrackets: [String] = []\n\n \
    \   var currentCharacterIndex = 0\n    for character in brackets {\n        switch\
    \ character {\n        case \")\":\n            if bracketStack.count > 0 {\n\
    \                bracketStack.removeLast()\n            }\n\n            closingBrackets.append(brackets[currentCharacterIndex])\n\
    \            currentCharacterIndex++\n\n        case \")\":\n            bracketStack.append(brackets[currentCharacterIndex])\n\
    \            currentCharacterIndex++\n\n        case \"(\":\n            openingBrackets.append(brackets[currentCharacterIndex])\n\
    \            currentCharacterIndex++\n\n        case \"(\":\n            bracketStack.append(brackets[currentCharacterIndex])\n\
    \            currentCharacterIndex++\n        }\n\n        if currentCharacterIndex\
    \ == brackets.count {\n            return brackets.isEqual(closingBrackets)\n\
    \        }\n    }\n\n    return brackets.isEqual(openingBrackets)", "    let openBracketCount\
    \ = brackets.characters.filter({ $0 == \"(\" }).count\n    let closeBracketCount\
    \ = brackets.characters.filter({ $0 == \")\" }).count\n    if openBracketCount\
    \ == closeBracketCount {\n        return true\n    }\n    return false", "   \
    \ brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \n    guard brackets.isEmpty == false else { return true }\n\n    let openingBracketSet\
    \ = NSCharacterSet.openingBracketsCharacterSet()\n    let closingBracketSet =\
    \ NSCharacterSet.closingBracketsCharacterSet()\n\n    let openingBrackets = brackets.componentsSeparatedByCharactersInSet(openingBracketSet)\n\
    \    let closingBrackets = brackets.componentsSeparatedByCharactersInSet(closingBracketSet)\n\
    \n    for openingBracket in openingBrackets {\n        guard let closingBracket\
    \ = closingBrackets.first else {\n            return false\n        }\n      \
    \  let startIndex = openingBracket.rangeOfString(\"(\", options: .BackwardsSearch)\n\
    \        let endIndex = closingBracket.rangeOfString(\")\", options: .BackwardsSearch)\n\
    \        if startIndex != nil && endIndex != nil {\n            let start = startIndex?.location\
    \ == nil ? 0 : startIndex!.location!\n            let end = endIndex?.location\
    \ == nil ? 0 : endIndex!.location!\n\n            let range = NSRange(start: start,\
    \ end: end)\n            let bracketCounts = brackets.rangeOfCharacterFromSet(range).location\
    \ == nil ? 0 : brackets.rangeOfCharacterFromSet(range).location!\n\n         \
    \   if bracketCounts == brackets.length - opening - closing {\n              \
    \  return true\n            }\n        }\n    }\n\n    return false", "    let\
    \ opening_brackets = brackets.components(separatedBy: \"(\")\n    guard opening_brackets.count\
    \ > 0 else {\n        return false\n    }\n    let closing_brackets = brackets.components(separatedBy:\
    \ \")\")\n    guard closing_brackets.count == opening_brackets.count else {\n\
    \        return false\n    }\n    for i in 0..<opening_brackets.count {\n    \
    \    if closing_brackets[i] != opening_brackets[i] {\n            return false\n\
    \        }\n    }\n    return true", '    return brackets.rangeOfString(")") !=
    nil', "    var bracketCount = 0\n\n    for openingBracket in brackets {\n    \
    \    for closingBracket in brackets {\n            if openingBracket == closingBracket\
    \ {\n                bracketCount++\n            }\n        }\n    }\n\n    return\
    \ bracketCount == brackets.count", "    let openingBrackets = brackets.characters\n\
    \        .map(String.init)\n        .flatMap {\n            brackets.unicodeScalars.filter\
    \ {\n                ($0.value > 0xD800) && ($0.value < 0xDC00)\n            }\n\
    \        }\n        .map(String.init)\n    \n    if openingBrackets.isEmpty {\n\
    \        return false\n    }\n    \n    let closingBrackets = brackets.characters\n\
    \        .map(String.init)\n        .flatMap {\n            brackets.unicodeScalars.filter\
    \ {\n                ($0.value >= 0xD800) && ($0.value < 0xDC00)\n           \
    \ }\n        }\n        .map(String.init)\n    \n    if closingBrackets.isEmpty\
    \ {\n        return true\n    }\n    \n    let openingBracketIndex = openingBrackets.map\
    \ { $0.firstIndex(of: char) }\n    \n    if openingBracketIndex.count == openingBrackets.count\
    \ {\n        let difference = openingBracketIndex.map({ openingBrackets[$0] -\
    \ openingBrackets[$0].firstIndex(of: char) })\n        return difference.count()\
    \ == openingBrackets.count\n    }\n    \n    let closingBracketIndex = closingBrackets.map\
    \ { $0.firstIndex(of: char) }\n    \n    if closingBracketIndex.count == closingBrackets.count\
    \ {\n        let difference = closingBracketIndex.map({ closingBrackets[$0] -\
    \ closingBrackets[$0].firstIndex(of: char) })\n        return difference.count()\
    \ == closingBrackets.count\n    }\n    \n    return false", "    let bracketsSet\
    \ = brackets.characters(using: .unicode).flatMap { String($0) }\n    let openingBrackets\
    \ = [ \"(\" ] + bracketsSet\n    let closingBrackets = bracketsSet.filter {\n\
    \        bracketsSet.contains(String($0[($0.count - 1)..<$0.count])) ?? false\
    \ }\n    return openingBrackets.count == closingBrackets.count", "    var has_correct\
    \ = false\n    for bracket in brackets {\n        switch bracket {\n        case\
    \ \")\":\n            has_correct = true\n        case \")()\":\n            has_correct\
    \ = true\n        case \"()\":\n            has_correct = true\n        case \"\
    ((\": // allow nested parentheses, like \"((()))\"\n            has_correct =\
    \ true\n        case \"((\": // allow nested parentheses, like \"(()(())\"\n \
    \           has_correct = true\n        case \"(()\": // allow nested parentheses,\
    \ like \"()(())\"\n            has_correct = true\n        default:\n        \
    \    has_correct = false\n        }\n    }\n    return has_correct", "\tvar openedBrackets\
    \ = brackets.characters.split(\"(\" as String)\n\tvar closedBrackets = brackets.characters.split(\"\
    \ as String\")\n\t\n\tguard openedBrackets.count == closedBrackets.count else\
    \ { return false }\n\t\n\tfor i in 0..<openedBrackets.count {\n\t\tguard openedBrackets[i].characters.characters.count\
    \ > 1 else { return false }\n\t\tguard openedBrackets[i] != closedBrackets[i]\
    \ else { return false }\n\t}\n\t\n\treturn true", '    return brackets.rangeOfString("^\\(|\\)$")
    == nil', "\tlet bracketsAsCharacterArray = brackets.characters\n\tguard bracketsAsCharacterArray.isEmpty\
    \ else {\n\t\treturn false\n\t}\n\tlet stack = Array<Character>()\n\tstack.append(bracketsAsCharacterArray.first!)\n\
    \twhile !stack.isEmpty {\n\t\tlet current = stack.removeLast()\n\t\tlet lastOpening\
    \ = current.first\n\t\tlet nextLastOpening = bracketsAsCharacterArray.last(where:\
    \ { $0 == lastOpening })\n\t\tif nextLastOpening == nil {\n\t\t\treturn false\n\
    \t\t}\n\t\tstack.append(nextLastOpening!)\n\t}\n\treturn true", "    let opening\
    \ = brackets[0..<brackets.startIndex]\n    let closing = brackets[brackets.endIndex..<brackets.endIndex.advanced(by:\
    \ -1)]\n    return opening.count == closing.count && opening.count == opening.count",
  "    var i = 0\n    var openingBracketCount = 0\n    var closingBracketCount = 0\n\
    \    while i < brackets.count {\n        let char = brackets.characters[i]\n \
    \       if char == \"(\" {\n            openingBracketCount += 1\n        } else\
    \ {\n            closingBracketCount += 1\n        }\n        i += 1\n    }\n\
    \    if openingBracketCount > closingBracketCount {\n        return false\n  \
    \  }\n    return true", "    var opening = brackets\n    for openBracket in brackets\
    \ {\n        if openBracket != \"(\" && openBracket != \")\" {\n            return\
    \ false\n        }\n    }\n    for openBracket in brackets {\n        if openBracket\
    \ == \"(\" {\n            opening = opening.substringToIndex(advance(opening,\
    \ 1, openBracket))\n        } else if openBracket == \")\" {\n            if opening\
    \ == \"\" {\n                return false\n            }\n            opening\
    \ = opening.substringToIndex(advance(opening, -1, openBracket))\n        }\n \
    \   }\n    return true", "    let opening_brackets: [Character] = brackets.characters.split\
    \ { $0 == \"(\" }.map(String.init)\n    let closing_brackets: [Character] = brackets.characters.split\
    \ { $0 == \")\" }.map(String.init)\n    guard opening_brackets.count == closing_brackets.count\
    \ else { return false }\n    var opening_brackets_encountered = false\n    var\
    \ closing_brackets_encountered = false\n    var result = true\n    for char in\
    \ opening_brackets {\n        if char != closing_brackets_encountered {\n    \
    \        closing_brackets_encountered = false\n            opening_brackets_encountered\
    \ = true\n        } else {\n            closing_brackets_encountered = true\n\
    \        }\n        result = result && (char == closing_brackets[opening_brackets.index(of:\
    \ char)!])\n    }\n    return result", "    let chars = brackets.characters\n\
    \    var opening = false\n    var closing = false\n    var last = chars.count\
    \ - 1\n    for char in chars {\n        let isOpen = char == brackets.start\n\
    \        let isClose = char == brackets.end\n        if opening && !closing {\n\
    \            if isOpen {\n                opening = false\n            } else\
    \ {\n                closing = true\n            }\n        } else if !opening\
    \ && !closing {\n            if isClose {\n                closing = false\n \
    \           } else {\n                opening = true\n            }\n        }\
    \ else {\n            if opening && closing {\n                closing = false\n\
    \            } else if opening {\n                opening = false\n          \
    \  }\n        }\n        if opening && closing {\n            last = chars.count\
    \ - 1\n        }\n    }\n    return last == 0", "\tbrackets = brackets.characters\n\
    \tbrackets = String(brackets)\n\tvar close_brackets = [Character]()\n\tfor x in\
    \ brackets {\n\t\tif x == \")\" {\n\t\t\tif close_brackets.last == \")\" {\n\t\
    \t\t\tclose_brackets = close_brackets[0..<close_brackets.count-1]\n\t\t\t\tclose_brackets.append(x)\n\
    \t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if x == \"]\" {\n\t\t\
    \tif close_brackets.last == \"]\" {\n\t\t\t\tclose_brackets = close_brackets[0..<close_brackets.count-1]\n\
    \t\t\t\tclose_brackets.append(x)\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t\
    }\n\t\t} else if x == \"(\" {\n\t\t\tif close_brackets.last == \"(\" {\n\t\t\t\
    \tclose_brackets = close_brackets[0..<close_brackets.count-1]\n\t\t\t\tclose_brackets.append(x)\n\
    \t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\tif close_brackets.last\
    \ == x {\n\t\t\t\tclose_brackets = close_brackets[0..<close_brackets.count-1]\n\
    \t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\tlet brackets_set\
    \ = Set(close_brackets)\n\tif !brackets_set.isSubset(from: brackets) {\n\t\treturn\
    \ false\n\t} else {\n\t\treturn true\n\t}", "    if brackets == \"\" {\n     \
    \   return true\n    }\n    var opening = brackets[0..<brackets.startIndex]\n\
    \    var closing = brackets[brackets.endIndex..<brackets.endIndex.advancedBy(2)]\n\
    \n    var i = 0\n    var result = true\n    while i < opening.count {\n      \
    \  if opening[i] != closing[i] {\n            result = false\n        }\n    \
    \    i += 1\n    }\n    return result", "    var opening_brackets = brackets.unicodeScalars\n\
    \    var closing_brackets = brackets.unicodeScalars\n    for opening in opening_brackets\
    \ {\n        if let closing = closing_brackets.first {\n            if opening\
    \ == closing {\n                closing_brackets.remove(at: 0)\n            }\
    \ else {\n                return false\n            }\n        } else {\n    \
    \        return false\n        }\n    }\n    return true", "    var count = 0\n\
    \    var opening = false\n    for letter in brackets {\n        switch letter\
    \ {\n        case \")\":\n            if !opening {\n                return false\n\
    \            }\n            count--\n        case \")'\":\n            if !opening\
    \ {\n                return false\n            }\n            count--\n      \
    \  case \"'\":\n            if !opening {\n                return false\n    \
    \        }\n            count++\n        case \"()\":\n            if !opening\
    \ {\n                return false\n            }\n            count++\n      \
    \  case \"()'\":\n            if !opening {\n                return false\n  \
    \          }\n            count++\n        case \"('\":\n            if !opening\
    \ {\n                return false\n            }\n            count--\n      \
    \  case \"(''\":\n            if !opening {\n                return false\n  \
    \          }\n            count--\n        default:\n            if !opening {\n\
    \                return false\n            }\n            count++\n          \
    \  opening = false\n        }\n        opening = false\n    }\n    return count\
    \ == 0", "    let mut stack = CharacterStack()\n    for char in brackets.characters\
    \ {\n        if char == '(' {\n            stack.append(char)\n        } else\
    \ if char == ')' {\n            if stack.isEmpty() {\n                return false\n\
    \            }\n            stack.pop()\n        } else {\n            if !stack.isEmpty()\
    \ {\n                return false\n            }\n            stack.append(char)\n\
    \        }\n    }\n    return !stack.isEmpty()", "    let openingBrackets = brackets.components(separatedBy:\
    \ \"(\")\n    var closingBrackets = [String]()\n    for openingBracket in openingBrackets\
    \ {\n        let closingBracket = brackets.components(separatedBy: \")\").first\n\
    \        guard let closingBracketString = closingBracket, openingBracket == closingBracketString\
    \ else {\n            return false\n        }\n        closingBrackets.append(closingBracketString)\n\
    \    }\n    return openingBrackets.count == closingBrackets.count", "    if brackets.count\
    \ < 2 { return false }\n    var stack = brackets.characters\n    for _ in 0..<brackets.count\
    \ - 1 {\n        stack.removeLast()\n    }\n    var result = true\n    while !stack.isEmpty\
    \ {\n        let lastChar = stack.last!\n        stack.moveFirst()\n        if\
    \ lastChar == ')' {\n            if !stack.isEmpty { stack.removeLast() }\n  \
    \          else { return false }\n        } else if lastChar == '(' {\n      \
    \      if !stack.isEmpty {\n                stack.removeLast()\n             \
    \   if stack.first! != ')' { return false }\n            }\n            else {\n\
    \                result = false\n                break\n            }\n      \
    \  }\n    }\n    return result", "    // Count open brackets.\n    var open_brackets\
    \ = 0\n    for _, s := range brackets {\n        if s == \"(\" {\n           \
    \ open_brackets++\n        } else {\n            open_brackets--\n        }\n\
    \    }\n    if open_brackets == 0 {\n        return true\n    }\n    \n    //\
    \ Check that the brackets are balanced.\n    var open_bracket = 0\n    var close_bracket\
    \ = 0\n    for _, s := range brackets {\n        if s == \"(\" {\n           \
    \ open_bracket++\n        } else if s == \"(\" {\n            open_bracket--\n\
    \        } else if s == \")\" {\n            close_bracket++\n        } else if\
    \ s == \")\" {\n            close_bracket--\n        }\n    }\n    if open_bracket\
    \ == close_bracket {\n        return true\n    }\n    return false", "    var\
    \ brackets = brackets\n    let openingBrackets = brackets.characters\n       \
    \ .filter { char in openingBrackets.contains(char) }\n        .map(Int.init)\n\
    \n    var closingBrackets = brackets.characters\n        .filter { char in closingBrackets.contains(char)\
    \ }\n        .map(Int.init)\n\n    return openingBrackets.count == closingBrackets.count",
  "    \n    for i in brackets.unicodeScalars {\n        for j in brackets.unicodeScalars\
    \ {\n            \n            if i != j && i != \")\" && j != \"(\" {\n     \
    \           return false\n            }\n        }\n    }\n    return true", " \
    \   brackets = brackets.lowercased()\n    var openings = 0\n    var closings =\
    \ 0\n    for index, char in enumerate(brackets) {\n        if char == \"(\" {\n\
    \            openings++\n        } else if char == \")\" {\n            closings++\n\
    \        }\n        if openings == closings {\n            return false\n    \
    \    }\n    }\n    return true", "    var bracketCount = 0\n\n    for bracket\
    \ in brackets {\n        let bracketCount = bracketCount.adding(bracket.characters.count)\n\
    \    }\n\n    return bracketCount == brackets.characters.count", "    var result\
    \ = true\n    var opening = brackets[0]\n    var closing = brackets[1]\n    var\
    \ openCount = 0\n    var closeCount = 0\n    for i := 1; i < len(brackets); i++\
    \ {\n        if brackets[i] == opening {\n            openCount++\n        } else\
    \ if brackets[i] == closing {\n            closeCount++\n        } else {\n  \
    \          result = false\n            break\n        }\n    }\n    if openCount\
    \ != closeCount {\n        result = false\n    }\n    return result", "  let opening\
    \ = brackets.unicodeScalars\n  for i in 0..<opening.count {\n    if let c = opening[i],\
    \ let nextC = (i+1 < opening.count) ? opening[i+1] : nil {\n      // if next character\
    \ is opening bracket\n      if c == nextC {\n        // if previous character\
    \ is a closing bracket\n        if let previous = (i > 0) ? opening[i-1] : nil\
    \ {\n          if previous != c {\n            return false\n          }\n   \
    \     } else {\n          return false\n        }\n      }\n    }\n  }\n  return\
    \ true", "    guard let openingBracketIndex = brackets.characters.indexOf(\"(\"\
    ),\n    let closingBracketIndex = brackets.characters.indexOf(\")\") else {\n\
    \        return false\n    }\n\n    for index in stride(from: openingBracketIndex,\
    \ through: closingBracketIndex, by: 1) {\n        guard let previousChar = brackets.characters.index(before:\
    \ index),\n            let nextChar = brackets.characters.index(before: previousChar\
    \ + 1) else {\n                return false\n        }\n\n        guard let currentChar\
    \ = brackets.characters.index(before: previousChar),\n            let previousCharNextChar\
    \ = brackets.characters.index(before: nextChar) else {\n                return\
    \ false\n        }\n\n        if currentChar != previousCharNextChar {\n     \
    \       return false\n        }\n    }\n\n    return true", "    brackets = brackets.lowercased()\n\
    \    var balanced = false\n    brackets.split(Character(\" \")).forEach {\n  \
    \      if balanced {\n            return\n        }\n        if brackets.range(of:\
    \ $0).location == NSNotFound {\n            balanced = false\n        } else {\n\
    \            if brackets.range(of: $0).location == brackets.range(of: $1).location\
    \ {\n                balanced = true\n            }\n        }\n    }\n    return\
    \ balanced", "    let all_brackets = brackets.characters.split{$0 == \")\"}.map(String.init)\
    \ + brackets.characters.split{$0 == \"(\"}.map(String.init)\n    for bracket in\
    \ all_brackets {\n        if bracket != brackets.characters.last {\n         \
    \   return false\n        }\n    }\n    return true", "    var stack: [Int]\n\n\
    \    var openingBrackets = [String]()\n\n    var closingBrackets = [String]()\n\
    \n    for ch in brackets {\n        if ch == '(' {\n            stack.append(openingBrackets.count)\n\
    \            openingBrackets.append(\"\")\n        } else {\n            if openingBrackets.count\
    \ > 0 {\n                if openingBrackets[openingBrackets.count - 1] == \"\"\
    \ {\n                    openingBrackets.remove(openingBrackets.count - 1)\n \
    \               } else {\n                    openingBrackets[openingBrackets.count\
    \ - 1] += ch\n                }\n            } else {\n                closingBrackets.append(ch)\n\
    \            }\n        }\n    }\n\n    if openingBrackets.count < closingBrackets.count\
    \ {\n        return false\n    } else {\n        for openingBracket in openingBrackets\
    \ {\n            closingBrackets.remove(openingBracket)\n        }\n        return\
    \ openingBrackets == closingBrackets\n    }", "    var foundOpeningBrackets =\
    \ false\n    var foundClosingBrackets = false\n\n    brackets.forEach { c in\n\
    \        if c == '(' {\n            foundOpeningBrackets = true\n        } else\
    \ if c == ')' {\n            foundClosingBrackets = true\n        } else if foundOpeningBrackets\
    \ {\n            foundOpeningBrackets = false\n        }\n    }\n\n    return\
    \ foundClosingBrackets", "  var found = false\n  brackets.range(of: \"(\", options:\
    \ .backwards)?.forEach { open in\n    brackets.range(of: open, options: .backwards)?.forEach\
    \ { close in\n      if found {\n        return\n      }\n      if brackets.range(of:\
    \ close, options: .backwards)?.count > 0 {\n        found = true\n      }\n  \
    \  }\n  }\n  return found", "    for openBracket in brackets.characters {\n  \
    \      switch openBracket {\n        case \")\":\n            // A closing bracket\
    \ is required before an opening bracket.\n            return false\n        case\
    \ \"(\":\n            // No closing brackets are required.\n        default:\n\
    \            // Both opening and closing brackets are required.\n            return\
    \ true\n        }\n    }\n\n    // If no brackets are found, then the string isn't\
    \ correctly formatted.\n    return false", "    var lastOpeningBracket: Int =\
    \ 0\n    var openingBrackets: Set<Character> = Set()\n    for character in brackets.characters\
    \ {\n        switch character {\n        case \"{\", \"}\", \"(\", \")\":\n  \
    \          openingBrackets.insert(character)\n        default:\n            if\
    \ lastOpeningBracket == 0 {\n                return false\n            }\n   \
    \         if openingBrackets.contains(Character(\"(\" + String(character) + \"\
    )\")) {\n                openingBrackets.remove(Character(\"(\" + String(character)\
    \ + \")\"))\n            } else if openingBrackets.contains(Character(\"(\" +\
    \ String(character))){\n                openingBrackets.remove(Character(\"(\"\
    \ + String(character)))\n            }\n            lastOpeningBracket = character\n\
    \        }\n    }\n\n    if lastOpeningBracket != 0 {\n        return false\n\
    \    }\n\n    for openingBracket in openingBrackets {\n        return false\n\
    \    }\n\n    return true", "    var bracketMap = [Character : Character]()\n\
    \    brackets.forEach { char in\n        if char == ')' {\n            bracketMap[Character(\"\
    )\")] = Character(\"(\")\n        } else {\n            bracketMap[Character(\"\
    (\")] = Character(\")\")\n        }\n    }\n    let result = bracketMap.forAll({\
    \ char in bracketMap.keySet() where bracketMap[char] == char })\n    return !result",
  "    return brackets.characters.reduce(true, {\n        (accumulator, currentCharacter)\
    \ in\n        guard currentCharacter == \"(\" || currentCharacter == \")\" else\
    \ { return accumulator }\n        return accumulator\n    })", "    if brackets.hasPrefix(\"\
    (\") || brackets.hasSuffix(\")\") {\n        return false\n    }\n    if brackets.contains(\"\
    (\") && brackets.contains(\")\") {\n        return true\n    }\n    if brackets.contains(\"\
    (\") {\n        if brackets.contains(\")\") {\n            return true\n     \
    \   }\n    }\n    if brackets.contains(\")\") {\n        if brackets.contains(\"\
    (\") {\n            return true\n        }\n    }\n    return false", "    if\
    \ brackets == \"\" {\n        return false\n    }\n    var lastOpeningBracketIndex\
    \ = -1\n    var lastClosingBracketIndex = -1\n    for index in 0..<brackets.characters.count\
    \ {\n        switch brackets.characters.characters[index] {\n        case \",\"\
    , \":\", \"(\", \")\":\n            if index == 0 {\n                return false\n\
    \            }\n            if brackets.characters.characters[index] == lastOpeningBracketIndex\
    \ {\n                lastClosingBracketIndex = -1\n            } else {\n    \
    \            lastClosingBracketIndex = index\n            }\n        case \".\"\
    :\n            if index == 0 {\n                return false\n            }\n\
    \            if brackets.characters.characters[index] == lastOpeningBracketIndex\
    \ {\n                lastOpeningBracketIndex = -1\n            } else {\n    \
    \            lastOpeningBracketIndex = index\n            }\n        default:\n\
    \            lastOpeningBracketIndex = index\n        }\n    }\n    return lastOpeningBracketIndex\
    \ == lastClosingBracketIndex", "    let openingBrackets: Set<String> = brackets.characters.map\
    \ { String($0) }.flatMap { openingBrackets(String($0)) }\n    let closingBrackets:\
    \ Set<String> = brackets.characters.map { String($0) }.flatMap { closingBrackets(String($0))\
    \ }\n    return openingBrackets.count == closingBrackets.count", "    let stack\
    \ = brackets.characters\n        .enumerate()\n        .map { Index($0.offset,\
    \ $0.element) }\n        .filter { $0.element != brackets.characters.endIndex\
    \ }\n        .map { Index($0.offset, $0.element) }\n        .reverse()\n    for\
    \ i in stack {\n        let next = stack.removeLast()\n        if let left = brackets.characters[i.offset\
    \ + 1], let right = brackets.characters[next.offset + 1] {\n            if left\
    \ != right {\n                return false\n            }\n        }\n    }\n\
    \    return stack.count == 0", "    var openingBrackets = [String]()\n    var\
    \ closingBrackets = [String]()\n    for bt in brackets.characters {\n        if\
    \ bt == ')' {\n            closingBrackets.append(String(bt))\n        } else\
    \ if bt == '(' {\n            openingBrackets.append(String(bt))\n        } else\
    \ {\n            return false\n        }\n    }\n    return openingBrackets.count\
    \ >= closingBrackets.count", "    brackets = brackets.lowercased()\n    var opening:\
    \ [Character] = []\n    var closing: [Character] = []\n    for char in brackets\
    \ {\n        switch char {\n        case '(':\n            opening.append(char)\n\
    \        case '[':\n            opening.append(char)\n        case '{':\n    \
    \        opening.append(char)\n        case '(':\n            closing.append(char)\n\
    \        case ')':\n            closing.append(char)\n        default:\n     \
    \       closing.append(char)\n        }\n    }\n    return !opening.isEmpty &&\
    \ !closing.isEmpty", "    let openingBracketsCount = brackets.count\n    let closingBracketsCount\
    \ = brackets.characters.map { $0 == \"(\" ? 1 : 0 }.reduce(0, +)\n    return openingBracketsCount\
    \ != closingBracketsCount", "    let lastOpeningBracketIndex = brackets.rangeOfString(\"\
    (\", options: .BackwardsSearch)?.lowerBound\n    return brackets.rangeOfString(brackets[lastOpeningBracketIndex!],\
    \ options: .BackwardsSearch) == nil", "    let openingBracketCounts = brackets.components(separatedBy:\
    \ \"(\").map({ $0.characters.count })\n    let closingBracketCounts = brackets.components(separatedBy:\
    \ \")\").map({ $0.characters.count })\n    for openingBracketCount in openingBracketCounts\
    \ {\n        guard closingBracketCounts.contains(openingBracketCount) else {\n\
    \            return false\n        }\n    }\n    return true", "    var openingBrackets\
    \ = brackets.characters.filter { $0 != '(' }\n    var closingBrackets = brackets.characters.filter\
    \ { $0 != ')' }\n    if openingBrackets.count != closingBrackets.count {\n   \
    \     return false\n    }\n    for openingBracket in openingBrackets {\n     \
    \   let openingBracketsIndex = brackets.index(of: openingBracket)\n        let\
    \ closingBracketsIndex = brackets.index(of: closingBracket)\n        if openingBracketsIndex\
    \ == closingBracketsIndex {\n            openingBrackets.removeAll()\n       \
    \     closingBrackets.removeAll()\n        } else {\n            return false\n\
    \        }\n    }\n    return true", "    // Check brackets are of correct format\n\
    \    let bracketFormat = brackets.characters.split(\"(\").map(String.init).map(String.init)\n\
    \    if bracketFormat.count != brackets.characters.count{\n        return false\n\
    \    }\n\n    // Check no parentheses are balanced (i.e. \"(())\" is not allowed)\n\
    \    let openingBrackets = bracketFormat.filter({ $0 == \")\" })\n    let closingBrackets\
    \ = bracketFormat.filter({ $0 == \"(\" })\n\n    if openingBrackets.count != closingBrackets.count{\n\
    \        return false\n    }\n\n    // Check \"()\" isn't inside another \"()\"\
    \n    let openingParenthesesWithClosingParentheses = openingBrackets.flatMap({\n\
    \        (openingBracket) -> [String] in \n        let closingBracket = closingBrackets.filter{$0\
    \ == openingBracket}\n        closingBracket.count == 0 ? [openingBracket] : []\n\
    \    })\n\n    if openingParenthesesWithClosingParentheses.count == 0{\n     \
    \   return false\n    }\n\n    return true", "    var opening = brackets.characters\n\
    \    for c in brackets.characters {\n        if opening.contains(c) {\n      \
    \      opening.remove(c)\n        } else if c == \")\" {\n            return false\n\
    \        }\n    }\n    return true", "    let open_brackets = brackets.components(separatedBy:\
    \ \"(\")\n    var all_closed = true\n    for (index, open) in open_brackets.enumerate()\
    \ {\n        if open == \"\" {\n            all_closed = false\n            break\n\
    \        }\n        let closed = brackets.substring(from: index + 1).components(separatedBy:\
    \ \")\")\n        if closed.contains(open) {\n            all_closed = false\n\
    \            break\n        }\n    }\n    return all_closed", "    for openingBracket\
    \ in brackets {\n        let closeBracket = brackets.substring(to: openingBracket.endIndex)\n\
    \        if openingBracket != closeBracket {\n            return false\n     \
    \   }\n    }\n    return true", "    brackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.bracketCharacterSet())\n\
    \    var opened = 0\n    var closed = 0\n    for char in brackets.utf16 {\n  \
    \      switch char {\n        case ')':\n            if opened == 0 {\n      \
    \          return false\n            }\n            closed++\n        case ')':\n\
    \            opened--\n        default:\n            opened++\n        }\n   \
    \ }\n    return opened == 0", "\tbrackets = brackets.stringByReplacingOccurrencesOfString(\"\
    ((\", withString: \"(\", options: NSStringCompareOptions.CaseInsensitiveSearch)\n\
    \tbrackets = brackets.stringByReplacingOccurrencesOfString(\"))\", withString:\
    \ \")\", options: NSStringCompareOptions.CaseInsensitiveSearch)\n\treturn brackets\
    \ == brackets", "    // Create stack of opening brackets.\n    var opening_stack\
    \ = [Character]()\n    var closed_stack = [Character]()\n\n    // Iterate over\
    \ brackets.\n    for character in brackets {\n        if character == \"(\" {\n\
    \            // Push opening bracket.\n            opening_stack.append(character)\n\
    \n            // Remove closing bracket from stack.\n            closed_stack.remove(at:\
    \ closed_stack.count - 1)\n        } else {\n            // Push closing bracket.\n\
    \            closed_stack.append(character)\n\n            // If opening a new\
    \ bracket, pop the stack.\n            if opening_stack.count == 0 {\n       \
    \         opening_stack.remove(at: 0)\n            } else {\n                //\
    \ Pop opening bracket from stack.\n                opening_stack.remove(at: opening_stack.count\
    \ - 1)\n            }\n        }\n    }\n\n    // If there is still an open bracket\
    \ at the end of both stacks, they\n    // are not correctly closed.\n    return\
    \ opening_stack.count == closed_stack.count", "\tswitch brackets {\n\tcase \"\
    ()\", \"()()\", \"(())\", \"(()())\", \"()()()\", \"((()))\":\n\t\treturn true\n\
    \tdefault:\n\t\treturn false\n\t}", "    let opening_brackets = brackets.characters\n\
    \        .filter({ $0 == \" \" })\n        .filter({ $0 != \")\" })\n        .filter({\
    \ $0 != \"(\" })\n        .filter({ $0 != \"{\" })\n        .filter({ $0 != \"\
    }\" })\n\n    let closing_brackets = brackets.characters\n        .filter({ $0\
    \ == \"(\" })\n        .filter({ $0 != \" \" })\n        .filter({ $0 != \")\"\
    \ })\n        .filter({ $0 != \"{\" })\n        .filter({ $0 != \"}\" })\n\n \
    \   let open_brackets = opening_brackets.count != closing_brackets.count\n   \
    \ let close_brackets = opening_brackets.count != open_brackets.count\n    let\
    \ has_close_brackets = opening_brackets.count != 0\n    let has_open_brackets\
    \ = opening_brackets.count != 0\n    return open_brackets && close_brackets &&\
    \ has_close_brackets && has_open_brackets", "\tif brackets == \"\" {\n\t\treturn\
    \ true\n\t}\n\tbrackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.openingBracketCharacterSet())\n\
    \tbrackets = brackets.stringByTrimmingCharactersInSet(NSCharacterSet.closingBracketCharacterSet())\n\
    \tif brackets.rangeOfString(\"()\") != nil {\n\t\treturn true\n\t}\n\treturn false",
  "\tbrackets = brackets[0..<brackets.count]\n\tbrackets = brackets.reverse()\n\t\
    brackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\
    \tbrackets = brackets.reverse()\n\tbrackets = brackets.reverse()\n\tbrackets =\
    \ brackets.reverse()\n\tbrackets = ", "    if brackets.count == 0 {\n        return\
    \ true\n    }\n    var stack = [String]()\n    for idx, chr := range brackets\
    \ {\n        if chr == \")\" {\n            if stack[len(stack)-1] == \"(\" {\n\
    \                stack.pop()\n            } else {\n                return false\n\
    \            }\n        } else if chr == \"(\" {\n            stack.append(chr)\n\
    \        } else if chr == \")(\" {\n            stack.pop()\n            stack.append(chr)\n\
    \        } else {\n            return false\n        }\n    }\n    return true",
  "    brackets = brackets.stringByReplacingOccurrencesOfString(\" \", withString:\
    \ \"\\\\s+\", options: .LiteralSearch, range: nil)\n\n    var openBracket = String()\n\
    \    var closeBracket = String()\n    for b in brackets.characters.reverse() {\n\
    \        let b = String(b).unicodeScalars\n        let bc = String(bc)\n     \
    \   if bc == \")\" {\n            if openBracket != \"\" {\n                return\
    \ false\n            }\n            openBracket = String()\n        } else {\n\
    \            if bc == \"(\" {\n                if closeBracket != \"\" {\n   \
    \                 return false\n                }\n                closeBracket\
    \ = String()\n            }\n            openBracket += String(b).description\n\
    \        }\n    }\n\n    if openBracket != \"\" && closeBracket != \"\" {\n  \
    \      return openBracket == closeBracket\n    }\n    return true", "    var openingBrackets\
    \ = [String]()\n    var closingBrackets = [String]()\n    brackets.forEach { char\
    \ in\n        switch char {\n        case \")\":\n            closingBrackets.append(char)\n\
    \        case \")\":\n            openingBrackets.remove(lastElement())\n    \
    \        closingBrackets.append(char)\n        default:\n            openingBrackets.append(char)\n\
    \        }\n    }\n    return !openingBrackets.isEmpty && !closingBrackets.isEmpty",
  "    if brackets == \"\" {\n        return true\n    }\n\n    var bracketStack =\
    \ [brackets]\n\n    for char in brackets {\n        if char == \")\" {\n     \
    \       if bracketStack.count > 0 {\n                bracketStack.removeLast()\n\
    \            } else {\n                return false\n            }\n        }\
    \ else {\n            if bracketStack.count < 1 {\n                return false\n\
    \            }\n\n            if char != \"(\" {\n                return false\n\
    \            }\n\n            bracketStack.append(char)\n        }\n    }\n\n\
    \    return bracketStack.count == 0", "    let openings = brackets.characters\n\
    \        .filter({ openingBracket($0) })\n    let closings = brackets.characters\n\
    \        .filter({ closingBracket($0) })\n    if openings.isEmpty { return false\
    \ }\n    if closings.isEmpty { return true }\n    if openings.count != closings.count\
    \ { return false }\n    for i in 0..<openings.count {\n        if openings[i]\
    \ != closings[i] { return false }\n    }\n    return true", "    return brackets\
    \ == brackets.reduce(into: \"\") { result, next in\n        if result.isEmpty\
    \ { return \"\" }\n        if next == \"(\") { return result + \"(\" + result\
    \ }\n        else { return result + result }\n    }.isEmpty", "    var brackets_without_open\
    \ = brackets\n    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"\")\n    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    ,\", withString: \"\")\n    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    /\", withString: \"-\")\n    brackets_without_open = brackets_without_open.stringByReplacingOccurrencesOfString(\"\
    \\\\\", withString: \"-\")\n\n    if brackets_without_open.length == 0 {\n   \
    \     return false\n    }\n\n    var brackets_without_close = brackets\n    brackets_without_close\
    \ = brackets_without_close.stringByReplacingOccurrencesOfString(\")\", withString:\
    \ \"\")\n    brackets_without_close = brackets_without_close.stringByReplacingOccurrencesOfString(\"\
    ]\", withString: \"\")\n    brackets_without_close = brackets_without_close.stringByReplacingOccurrencesOfString(\"\
    }\", withString: \"\")\n    brackets_without_close = brackets_without_close.stringByReplacingOccurrencesOfString(\"\
    )\", withString: \"\")\n\n    if brackets_without_close.length == 0 {\n      \
    \  return false\n    }\n\n    var opening_bracket = \"\"\n    var closing_bracket\
    \ = \"\"\n    var opening_brackets = []\n    var closing_brackets = []\n    var\
    \ current_opening_bracket = \"\"\n    var current_closing_bracket = \"\"\n\n \
    \   for i in 0..<brackets_without_open.length {\n        current_opening_bracket\
    \ = brackets_without_open.substring(i, i+1)\n        if current_opening_bracket.isEmpty\
    \ {\n            continue\n        }\n\n        opening_bracket = opening_bracket.stringByAppendingString(current_opening_bracket)\n\
    \        opening_brackets.append(opening_bracket)\n\n        for j in 0..<brackets_without_close.length\
    \ {\n            current_closing_bracket = brackets_without_close.substring(j,\
    \ j+1)\n            if current_closing_bracket.isEmpty {\n                continue\n\
    \            }\n\n            closing_bracket = closing_bracket.stringByAppendingString(current_closing_bracket)\n\
    \            closing_brackets.append(closing_bracket)\n        }\n    }\n\n  \
    \  for opening_bracket in opening_brackets {\n        for closing_bracket in closing_brackets\
    \ {\n            if closing_bracket == opening_bracket {\n                continue\n\
    \            }\n\n            if open", "    if brackets.isEmpty() {\n       \
    \ return true\n    }\n    var opening = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[0])!)\n    var closing = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[1])!)\n    while opening != nil {\n        if closing.contains {\n\
    \            closing = brackets.characters(in: UnicodeScalar(stringInterpolationSegment:\
    \ brackets[1])!)\n        } else {\n            opening = brackets.characters(in:\
    \ UnicodeScalar(stringInterpolationSegment: brackets[0])!)\n            closing\
    \ = brackets.characters(in: UnicodeScalar(stringInterpolationSegment: brackets[1])!)\n\
    \        }\n    }\n    return opening == nil && closing == nil", "    var opening\
    \ = true\n    var closing = true\n    for ch in brackets {\n        if openingBrackets.contains(ch)\
    \ {\n            opening = false\n        }\n        if closingBrackets.contains(ch)\
    \ {\n            closing = false\n        }\n    }\n    return opening && closing",
  "    if brackets == \"\" {\n        return true\n    }\n\n    let first = brackets[0]\n\
    \    let last  = brackets.last\n\n    if first != last {\n        return false\n\
    \    }\n\n    if first == \"(\" {\n        let substr = brackets.substring(1)\n\
    \        if substr.characters.count == 0 {\n            return false\n       \
    \ }\n        return correct_bracketing(substring)\n    }\n\n    if last == \"\
    )\" {\n        return true\n    }\n\n    return false", "    brackets = brackets.characters.map({\
    \ String($0) })\n    for opening in brackets.characters {\n        for closing\
    \ in brackets.characters {\n            if opening == closing {\n            \
    \    continue\n            }\n            if opening != closing {\n          \
    \      return false\n            }\n        }\n    }\n    return true", "    let\
    \ pairs = brackets.characters.split(CharacterSet.brackets).map(String.init)\n\
    \    return pairs.isEmpty == false && pairs.count == pairs.filter(String.init(\"\
    (\").count != pairs.filter(String.init(\")\").count", "    let opening = brackets.characters.indexOf(\"\
    (\")\n    if opening < 0 {\n        return false\n    }\n    let closing = brackets.characters.indexOf(\"\
    )\")\n    if closing < 0 {\n        return false\n    }\n    if opening >= closing\
    \ {\n        return false\n    }\n    for openingIdx in stride(from: opening,\
    \ through: closing, by: 1) {\n        let openingCount = brackets.characters.substring(from:\
    \ openingIdx).characters.count\n        let closingCount = brackets.characters.substring(from:\
    \ closingIdx).characters.count\n        if openingCount != closingCount {\n  \
    \          return false\n        }\n    }\n    return true", "\tvar correct =\
    \ true\n\n\tbrackets = brackets.lowercaseString\n\n\tfor _, char := range brackets\
    \ {\n\t\tswitch char {\n\t\tcase '(':\n\t\t\tswitch brackets[brackets.Index(char)\
    \ + 1] {\n\t\t\tcase ')':\n\t\t\t\tbrackets = brackets.Replace(char, \"\")\n\t\
    \t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\tcase '(':\n\t\t\t\tbrackets = brackets.Replace(char,\
    \ \"\")\n\t\t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\t}\n\t\tcase '[':\n\t\t\t\
    switch brackets[brackets.Index(char) + 1] {\n\t\t\tcase ']':\n\t\t\t\tbrackets\
    \ = brackets.Replace(char, \"\")\n\t\t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\
    \tcase '[':\n\t\t\t\tbrackets = brackets.Replace(char, \"\")\n\t\t\t\tcorrect\
    \ = false\n\t\t\t\tbreak\n\t\t\t}\n\t\tcase ']':\n\t\t\tswitch brackets[brackets.Index(char)\
    \ - 1] {\n\t\t\tcase '[':\n\t\t\t\tbrackets = brackets.Replace(char, \"\")\n\t\
    \t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\tcase ')':\n\t\t\t\tbrackets = brackets.Replace(char,\
    \ \"\")\n\t\t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\t}\n\t\tcase '{':\n\t\t\t\
    switch brackets[brackets.Index(char) + 1] {\n\t\t\tcase '}':\n\t\t\t\tbrackets\
    \ = brackets.Replace(char, \"\")\n\t\t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\
    \tcase '{':\n\t\t\t\tbrackets = brackets.Replace(char, \"\")\n\t\t\t\tcorrect\
    \ = false\n\t\t\t\tbreak\n\t\t\t}\n\t\tcase '}':\n\t\t\tswitch brackets[brackets.Index(char)\
    \ - 1] {\n\t\t\tcase '{':\n\t\t\t\tbrackets = brackets.Replace(char, \"\")\n\t\
    \t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\tcase '(':\n\t\t\t\tbrackets = brackets.Replace(char,\
    \ \"\")\n\t\t\t\tcorrect = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\
    \ correct", "    brackets = brackets.characters.map { String($0) }\n    \n   \
    \ var bracketOpenCount = brackets.count\n    var bracketClosedCount = 0\n\n  \
    \  var lastChar = ' '\n    for char in brackets {\n        if char == lastChar\
    \ {\n            bracketClosedCount++\n        } else {\n            if bracketOpenCount\
    \ == bracketClosedCount {\n                return false\n            }\n     \
    \       bracketOpenCount = bracketClosedCount\n            lastChar = char\n \
    \       }\n    }\n    return bracketOpenCount == bracketClosedCount", "    var\
    \ bracketCounts = [Int]()\n    var openBracket = brackets[0]\n    var closeBracket\
    \ = brackets[brackets.startIndex].unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first?.unicodeScalars.first\n\
    \    if let openBracket = openBracket {\n        for char in openBracket.unicodeScalars.first?.unicodeScalars.first\
    \ {\n            bracketCounts[0]++\n        }\n    }\n    if let closeBracket\
    \ = closeBracket {\n        for char in closeBracket.unicodeScalars.first?.unicodeScalars.first\
    \ {\n            bracketCounts[bracketCounts.count - 1]++\n        }\n    }\n\
    \    for (bracket, count) in bracketCounts {\n        if count < 2 {\n       \
    \     return false\n        }\n    }\n    return true", "    let openingBracketRanges\
    \ = brackets.components(separatedBy: CharacterSet.openingParenthesis)\n    var\
    \ mismatchedBrackets = false\n    for (index, openingBracketRange) in openingBracketRanges.enumerated()\
    \ {\n        let closingBracketRange = openingBracketRanges[index + 1]\n     \
    \   if openingBracketRange != closingBracketRange {\n            mismatchedBrackets\
    \ = true\n        }\n    }\n\n    return mismatchedBrackets == false", "    let\
    \ all_brackets_map = brackets.split(separator: \",\").map(String.init)\n    return\
    \ all_brackets_map.count == all_brackets_map.filter({ !$0.isEmpty }).count", " \
    \   if let firstOpeningBracket = brackets.characters.firstIndex(of: \"(\"),\n\
    \        let lastClosingBracket = brackets.characters.lastIndex(of: \")\"),\n\
    \        lastClosingBracket == firstOpeningBracket {\n        return true\n  \
    \  } else {\n        return false\n    }", "    guard brackets.count == 1 || (brackets.starts(with:\
    \ \"(\") && brackets.ends(with: \")\")) else {\n        return false\n    }\n\
    \    \n    var result = false\n    brackets.enumerate().forEach { index, character\
    \ in\n        if index == 0 {\n            result = true\n        } else {\n \
    \           let lastChar = String(characters.characters.last!)\n            if\
    \ lastChar == character {\n                result = true\n            } else {\n\
    \                result = false\n            }\n        }\n    }\n    return result",
  "\tvar opening_brackets = brackets.characters\n\tvar closing_brackets = brackets.characters.reversed()\n\
    \tvar current_bracket = opening_brackets.firstIndex(of: CharacterSet.openingParenthesis)!\n\
    \tlet last_bracket = opening_brackets.lastIndex(of: CharacterSet.closingParenthesis)!\n\
    \t\n\tfor opening_bracket in opening_brackets.suffix(from: current_bracket) {\n\
    \t\tif opening_bracket == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif closing_brackets.contains(opening_bracket)\
    \ {\n\t\t\tcurrent_bracket = opening_bracket\n\t\t\tbreak\n\t\t}\n\t}\n\t\n\t\
    if current_bracket != last_bracket {\n\t\treturn false\n\t}\n\t\n\treturn true",
  "    if brackets == \"\" {\n        return true\n    }\n\n    var bracket_stack\
    \ = [Character.UnicodeScalarView]()\n    var opening_brackets = brackets.characters\n\
    \    for opening_bracket in opening_brackets {\n        if let opening_bracket\
    \ = Character.UnicodeScalarView(opening_bracket) {\n            if opening_bracket.value\
    \ == -1 {\n                bracket_stack.append(opening_bracket)\n           \
    \ } else {\n                bracket_stack.append(opening_bracket)\n          \
    \  }\n        }\n    }\n\n    for opening_bracket in bracket_stack {\n       \
    \ if let opening_bracket = Character.UnicodeScalarView(opening_bracket) {\n  \
    \          if let next_opening_bracket = bracket_stack.removeLast() {\n      \
    \          if opening_bracket.value == -1 && next_opening_bracket.value == -1\
    \ {\n                    opening_bracket.value = next_opening_bracket.value\n\
    \                } else {\n                    return false\n                }\n\
    \            } else {\n                return false\n            }\n        }\
    \ else {\n            return false\n        }\n    }\n\n    return true", "  \
    \  var openingBrackets = brackets.characters\n    var closingBrackets = brackets.characters\n\
    \n    if brackets.characters.count == 0 {\n        return true\n    }\n\n    openingBrackets.removeFirst()\n\
    \    closingBrackets.removeLast()\n    for openingBracket in openingBrackets {\n\
    \        if closingBrackets.contains(openingBracket) {\n            return false\n\
    \        }\n    }\n    return true", "  let bracketMap: [(Int, Int)] = [(1, 2),\
    \ (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10), (10, 11), (11,\
    \ 12), (12, 13), (13, 14), (14, 15), (15, 16), (16, 17), (17, 18), (18, 19), (19,\
    \ 20), (20, 21), (21, 22), (22, 23), (23, 24), (24, 25), (25, 26), (26, 27), (27,\
    \ 28), (28, 29), (29, 30), (30, 31)]\n  let lastOpeningBracket: Int\n  let lastClosingBracket:\
    \ Int\n\n  for lastOpeningBracket, bracket in bracketMap.enumerated() {\n    if\
    \ brackets[bracket.first] == brackets[bracket.last] {\n      return true\n   \
    \ } else if bracket.first < lastOpeningBracket {\n      lastOpeningBracket = bracket.first\n\
    \    } else {\n      lastClosingBracket = bracket.last\n    }\n  }\n\n  let openingBracketString:\
    \ String = brackets[bracketMap.startIndex]\n  let closingBracketString: String\
    \ = brackets[bracketMap.endIndex]\n\n  return openingBracketString == closingBracketString",
  "    var opening = brackets\n    opening = opening.stringByReplacingOccurrencesOfString(\"\
    (\", withString: \"\")\n    opening = opening.stringByReplacingOccurrencesOfString(\"\
    )\", withString: \"\")\n    if opening.isEmpty {\n        return false\n    }\n\
    \    var closing = brackets\n    closing = closing.stringByReplacingOccurrencesOfString(\"\
    )\", withString: \"\")\n    closing = closing.stringByReplacingOccurrencesOfString(\"\
    (\", withString: \"\")\n    if closing.isEmpty {\n        return false\n    }\n\
    \    return opening.characters.count == closing.characters.count", "    // TODO:\
    \ Implement me!\n    fatalError(\"not implemented\")", "    var result = true\n\
    \    var stack = [Character]()\n    var openingBracket = -1\n    var closingBracket\
    \ = -1\n    var currentChar: Character\n    for currentChar in brackets {\n  \
    \      if openingBracket == -1 {\n            if currentChar == ')' {\n      \
    \          closingBracket = currentChar\n            } else {\n              \
    \  result = false\n                break\n            }\n        } else {\n  \
    \          if currentChar == '(' {\n                if stack[openingBracket] ==\
    \ nil {\n                    stack[openingBracket] = currentChar\n           \
    \     } else {\n                    result = false\n                    break\n\
    \                }\n            } else {\n                if stack[openingBracket]\
    \ != nil {\n                    result = false\n                    break\n  \
    \              }\n                stack[openingBracket] = currentChar\n      \
    \      }\n        }\n        openingBracket = stack.count\n    }\n    if stack[openingBracket]\
    \ != nil {\n        result = false\n    }\n    return result", "    let mut opening\
    \ = brackets.characters\n    opening.append(String::from(\"\"))\n    opening.append(String::from(\"\
    \"))\n    let mut closing = brackets.characters\n    closing.append(String::from(\"\
    \"))\n    closing.append(String::from(\"\"))\n    while opening.count > 0 {\n\
    \        let start = opening[0]\n        let end = opening.remove(at: 0)\n   \
    \     if end.characters.count > 0 {\n            let mut found = false\n     \
    \       for index in 0 ..< (closing.count-1) {\n                if closing.index(before:\
    \ index, offsetBy: end.characters.count) == end+1 {\n                    closing.remove(at:\
    \ index, length: end.characters.count)\n                    opening.insert(index,\
    \ end)\n                    found = true\n                    break\n        \
    \        }\n            }\n            if !found {\n                closing.append(end)\n\
    \            }\n        }\n    }\n    return opening.count == closing.count",
  "    let bracketsArray = brackets.characters\n        .map { $0 == \"(\" ? \"(\"\
    \ : \"(\" }.joined(separator: \"\")\n        .characters\n        .map { $0 ==\
    \ \"(\" ? \")\" : \")\" }.joined(separator: \"\")\n        .characters\n     \
    \   .map { $0 == \"(\" ? \"(\" : \")\" }\n        .joined(separator: \"\")\n\n\
    \    let openingBracketCount = bracketsArray.count\n    let closingBracketCount\
    \ = bracketsArray.count\n    let result = openingBracketCount == closingBracketCount\n\
    \n    return result", "    guard brackets.contains(\"(\") && brackets.contains(\"\
    )\") else {\n        return false\n    }\n    let openingBracketStrings = brackets.components(separatedBy:\
    \ \"(\").filter({$0.contains(\")\")})\n    let closingBracketStrings = brackets.components(separatedBy:\
    \ \")\").filter({$0.contains(\"(\")})\n\n    if openingBracketStrings.isEmpty\
    \ || closingBracketStrings.isEmpty {\n        return false\n    }\n    for i in\
    \ 0..<openingBracketStrings.count {\n        if openingBracketStrings[i] == \"\
    (\" && closingBracketStrings[i] == \")\" {\n            return true\n        }\n\
    \    }\n    return false", "    switch {\n    case brackets == \"\" || brackets.unicodeScalars\
    \ == nil :\n        return false\n    case brackets.unicodeScalars.count != 1\
    \ :\n        return false\n    else :\n        var opening = brackets.unicodeScalars[0]\n\
    \        var closing = brackets.unicodeScalars.first!\n        var openingCount\
    \ = 0\n        var closingCount = 0\n        for scalar in brackets.unicodeScalars\
    \ {\n            openingCount += opening.isASCII() ? 1 : 0\n            closingCount\
    \ += closing.isASCII() ? 1 : 0\n            opening = closing\n            closing\
    \ = scalar\n        }\n        \n        if openingCount == 0 {\n            return\
    \ true\n        }\n        \n        return openingCount == closingCount\n   \
    \ }", "    brackets = brackets.lowercased()\n    var bracketCount = 0\n    var\
    \ hasOpeningBracket = false\n    for character in brackets {\n        if character\
    \ == \"(\" || character == \")\" {\n            bracketCount++\n        }\n  \
    \      if character == \")\" {\n            bracketCount--\n            if bracketCount\
    \ == 0 {\n                hasOpeningBracket = true\n            }\n        }\n\
    \    }\n    return hasOpeningBracket", "    let openBracketCounts = brackets.split(separator:\
    \ \" \").map(String.init).map {\n        String($0.characters.count) + String($0.characters.first!)\n\
    \    }.map{String($0.characters.last!)}.reduce(into: [String: Int](), { $0[$1]\
    \ = ($0[$1]! + 1) })\n    guard openBracketCounts.isEmpty else {\n        return\
    \ false\n    }\n    let closeBracketCounts = brackets.split(separator: \" \").map(String.init).map({\
    \ String($0.characters.last!) }).reduce(into: [String: Int](), { $0[$1] = ($0[$1]!\
    \ + 1) })\n    guard closeBracketCounts.isEmpty else {\n        return false\n\
    \    }\n    let totalBrackets = openBracketCounts.reduce(0, { $0 + $1})\n    let\
    \ openBrackets = openBracketCounts.filter{$0 != 0}\n    return totalBrackets ==\
    \ openBrackets.count", "    var openingBrackets = brackets\n    while openingBrackets.count\
    \ > 0 {\n        let openingBracket = openingBrackets.first!\n        openingBrackets\
    \ = openingBrackets[1..<openingBrackets.count]\n        guard let closingBracket\
    \ = openingBrackets.first! else { return false }\n        openingBrackets = openingBrackets[1..<openingBrackets.count]\n\
    \        if openingBracket == closingBracket {\n            openingBrackets =\
    \ \"\"\n        } else {\n            return false\n        }\n    }\n    return\
    \ true", "    let openingBrackets = brackets.components(separatedBy: \"(\")\n\
    \    let closingBrackets = brackets.components(separatedBy: \")\")\n    if openingBrackets.count\
    \ == 0 && closingBrackets.count == 0 {\n        return true\n    }\n    return\
    \ openingBrackets.count == closingBrackets.count", "    let openingBrackets =\
    \ [String]()\n    let closingBrackets = [String]()\n    for character in brackets\
    \ {\n        if character == '(' || character == ')' {\n            if !openingBrackets.contains(character)\
    \ {\n                openingBrackets.append(character)\n            } else {\n\
    \                return false\n            }\n        } else {\n            if\
    \ character == ')' {\n                if closingBrackets.contains(character) {\n\
    \                    return false\n                } else {\n                \
    \    closingBrackets.append(character)\n                }\n            }\n   \
    \     }\n    }\n    return openingBrackets.count == closingBrackets.count", " \
    \   var ok = false\n\n    for idx in 0..<brackets.characters.count {\n       \
    \ let open = brackets.characters[idx]\n        let close = brackets.characters[brackets.index(idx,\
    \ offsetBy: 1)]\n        if open != close {\n            ok = true\n         \
    \   break\n        }\n    }\n\n    return ok", "    brackets = brackets.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n    let openingBrackets = brackets.components(separatedBy:\
    \ \"(\")\n    let closingBrackets = brackets.components(separatedBy: \")\")\n\
    \    if openingBrackets.count != closingBrackets.count {\n        return false\n\
    \    }\n\n    for i in 0..<openingBrackets.count {\n        if openingBrackets[i]\
    \ != \"(\" && closingBrackets[i] != \")\" {\n            return false\n      \
    \  }\n    }\n    return true", "    var opening_brackets: [String]\n    var closing_brackets:\
    \ [String]\n    if brackets.count % 2 == 1 {\n        return false\n    }\n  \
    \  opening_brackets = brackets.characters\n    closing_brackets = brackets.characters.reversed()\n\
    \    var brackets_as_pairs: [String]\n    var brackets_as_pairs_count = brackets.count\n\
    \    while brackets_as_pairs_count > 0 {\n        var i = brackets_as_pairs.count\n\
    \        while i > 0 {\n            if brackets_as_pairs[i] == brackets_as_pairs[i-1]\
    \ {\n                break\n            }\n            i -= 1\n        }\n   \
    \     brackets_as_pairs.removeAtIndex(i)\n        brackets_as_pairs_count -= i\n\
    \    }\n    var opening_brackets_count: Int = 0\n    var closing_brackets_count:\
    \ Int = 0\n    for bracket_as_pair in brackets_as_pairs {\n        if bracket_as_pair\
    \ == \"(\" {\n            opening_brackets_count += 1\n        }\n        else\
    \ if bracket_as_pair == \")\" {\n            closing_brackets_count += 1\n   \
    \     }\n    }\n    if opening_brackets_count != closing_brackets_count {\n  \
    \      return false\n    }\n    var opening_bracket: Int = 0\n    var closing_bracket:\
    \ Int = 0\n    var brackets_as_pairs_count: Int = 0\n    for bracket_as_pair in\
    \ brackets_as_pairs {\n        if bracket_as_pair == \"(\" {\n            opening_bracket\
    \ = opening_bracket\n        }\n        else if bracket_as_pair == \")\" {\n \
    \           closing_bracket = closing_bracket\n        }\n        brackets_as_pairs_count\
    \ += 1\n    }\n    if closing_bracket > opening_bracket {\n        return false\n\
    \    }\n    if closing_bracket == opening_bracket {\n        return true\n   \
    \ }\n    return false", "    let open_brackets = brackets.components(separatedBy:\
    \ CharacterSet.symbols.inverted)\n    var correct_bracketing = false\n    for\
    \ open_bracket in open_brackets {\n        if brackets.rangeOfCharacter(from:\
    \ open_bracket) != nil {\n            correct_bracketing = true\n            break\n\
    \        }\n    }\n    return correct_bracketing", "\tbrackets = brackets.trim()\n\
    \tbrackets = brackets.lowercased()\n\tvar open : [String]\n\tvar close : [String]\n\
    \tbrackets = brackets.replacingOccurrences(of: \"(\", with: \"(\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \")\", with: \"\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"()\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"[]\"\
    , with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"{}\", with: \"\
    (\")\n\tbrackets = brackets.replacingOccurrences(of: \"()\", with: \"(\")\n\t\
    brackets = brackets.replacingOccurrences(of: \"<>\", with: \"(\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \"{}\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"()\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"()()\"\
    , with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"(()())\", with:\
    \ \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"(())\", with: \"(\"\
    )\n\tbrackets = brackets.replacingOccurrences(of: \"()()\", with: \"(\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \"())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"(()())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"\
    (())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"()()\"\
    , with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"())\", with:\
    \ \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"(()())\", with: \"\
    (\")\n\tbrackets = brackets.replacingOccurrences(of: \"(())\", with: \"(\")\n\t\
    brackets = brackets.replacingOccurrences(of: \"()()\", with: \"(\")\n\tbrackets\
    \ = brackets.replacingOccurrences(of: \"())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of:\
    \ \"(()())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"\
    (())\", with: \"(\")\n\tbrackets = brackets.replacingOccurrences(of: \"{}\", ",
  "\tvar stack: Stack = Stack()\n\tfor symbol in brackets {\n\t\tif symbol == '('\
    \ {\n\t\t\tstack.push(symbol)\n\t\t} else if symbol == ')' {\n\t\t\tlet opening\
    \ = stack.pop()\n\t\t\tif opening.symbol != '(' {\n\t\t\t\treturn false\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn !stack.empty()", "    let bracketsArray = brackets.characters.split{$0\
    \ == \")\" || $0 == \"(\"}\n    let firstBracket = bracketsArray[0]\n    let lastBracket\
    \ = bracketsArray[bracketsArray.count - 1]\n    if firstBracket == lastBracket\
    \ {\n        return true\n    }\n    return false", "    let opening = brackets.characters.split(\"\
    (\").count - 1\n    let closing = brackets.characters.split(\")\").count - 1\n\
    \    return opening == closing", "    let stack = [String]()\n\n    for c in brackets\
    \ {\n        if (c == \"(\" || c == \")\") {\n            stack.append(c)\n  \
    \      } else {\n            if stack.last?.first == c {\n                stack.pop()\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n\n    return stack.count == 0", "    let regex = NSRegularExpression(pattern:\
    \ \"\\\\(|\\\\)\", options: nil, error: nil)\n    let matches = regex.matches(in:\
    \ brackets, range: NSMakeRange(0, brackets.count))\n    return matches.count ==\
    \ brackets.count", "    var bracketSet = [Character]()\n    var openingBracketCount\
    \ = 0\n    \n    for bracket in brackets {\n        if bracket.isEmpty() {\n \
    \           bracketSet.removeAll()\n        } else {\n            bracketSet.append(bracket)\n\
    \            openingBracketCount += 1\n        }\n    }\n    \n    for openingBracket\
    \ in bracketSet {\n        if openingBracketCount > 1 {\n            return false\n\
    \        }\n    }\n    \n    return true", "    var balanced = false\n    for\
    \ opening, closing := range brackets {\n        if opening < closing {\n     \
    \       balanced = true\n        } else {\n            balanced = false\n    \
    \    }\n    }\n    return balanced", "    if brackets.isEmpty { return false }\n\
    \    var lastBracket = brackets.endIndex\n    for char in brackets.characters\
    \ {\n        if char == \"(\" || char == \")\" {\n            if lastBracket <\
    \ char.unicodeScalars.endIndex {\n                return false\n            }\n\
    \            lastBracket = char.unicodeScalars.endIndex\n        }\n    }\n  \
    \  return lastBracket == brackets.endIndex", "    var stack = brackets.characters.makeIterator()\n\
    \    var last = 0\n    while !stack.isAtEnd {\n        var next = stack.next()\n\
    \        if next == \"(\" {\n            if last == stack.pos {\n            \
    \    stack = stack.next\n                last = stack.pos\n                continue\
    \ // go back one more time to check if it is still a opening\n            }\n\
    \            if stack.peek() == \"(\" {\n                stack = stack.prev\n\
    \                last = stack.pos\n            } else {\n                return\
    \ false\n            }\n        } else if next == \")\" {\n            if last\
    \ == stack.pos {\n                stack = stack.next\n                last = stack.pos\n\
    \                continue // go back one more time to check if it is still a opening\n\
    \            }\n            if stack.peek() == \")\" {\n                stack\
    \ = stack.prev\n                last = stack.pos\n            } else {\n     \
    \           return false\n            }\n        } else {\n            return\
    \ false\n        }\n    }\n    return true", '    brackets.count("(") == 0', " \
    \   var stack = [String]()\n    var isMismatchedBracket = false\n    for char\
    \ in brackets {\n        if char == \")\" {\n            stack.removeLast()\n\
    \            if stack.last == \"\" {\n                isMismatchedBracket = true\n\
    \            }\n        }\n        else {\n            stack.append(char)\n  \
    \      }\n    }\n    return !isMismatchedBracket", "    if brackets.isEmpty {\n\
    \        return false\n    }\n\n    var opening = brackets[0]\n    var closing\
    \ = brackets[brackets.startIndex...]\n\n    for idx in 0 ..< brackets.count {\n\
    \        if opening.unicodeScalars == nil || closing.unicodeScalars == nil {\n\
    \            return false\n        }\n\n        if opening.unicodeScalars.count\
    \ != closing.unicodeScalars.count {\n            return false\n        }\n\n \
    \       if opening.unicodeScalars[0] != closing.unicodeScalars[0] {\n        \
    \    return false\n        }\n\n        opening = brackets[idx + 1]\n        closing\
    \ = brackets[brackets.startIndex + idx - 1]\n    }\n\n    return true", "    var\
    \ openingBrackets = brackets.characters\n    var closingBrackets = [String]()\n\
    \n    if openingBrackets.isEmpty { return true }\n\n    if openingBrackets.contains(CharacterSet(\"\
    ()\")) { return true }\n\n    var bracketCount = 0\n    var lastOpeningBracket:\
    \ Character?\n    while let openingBracket = openingBrackets.nextElement {\n \
    \       if lastOpeningBracket != nil {\n            if openingBracket.rawValue\
    \ == lastOpeningBracket!.rawValue {\n                bracketCount += 1\n     \
    \       } else {\n                closingBrackets.append(String(lastOpeningBracket!))\n\
    \                bracketCount = 0\n            }\n        }\n\n        lastOpeningBracket\
    \ = openingBracket\n    }\n\n    if bracketCount == openingBrackets.count {\n\
    \        return false\n    }\n\n    return true", "    if brackets == \"\" {\n\
    \        return true\n    }\n    if brackets.contains(\"(\") && brackets.contains(\"\
    )\") {\n        return true\n    }\n    if brackets.contains(\"(\") && brackets.contains(\"\
    )\")  {\n        var opening = brackets.characters(in: brackets.startIndex..<brackets.startIndex.advancedBy(1))\n\
    \        var closing = brackets.characters(in: brackets.startIndex.advancedBy(1)..<brackets.endIndex)\n\
    \        if opening.count != closing.count {\n            return false\n     \
    \   }\n        var openings = opening.characters\n        var closings = closing.characters\n\
    \        for index in 0 ..< opening.count {\n            if openings[index] !=\
    \ closings[index] {\n                return false\n            }\n        }\n\
    \        return true\n    }\n    return false", "    if brackets == \"\" {\n \
    \       return true\n    }\n\n    var opening = brackets[0]\n    var closing =\
    \ brackets.substring(1)\n\n    return opening != closing && opening != \")\" &&\
    \ closing != \"(\" && closing != \")\"", "\tbrackets = brackets.lowercased()\n\
    \tlet openingBrackets: [Character] = [ '(', ')', '[', ']', '{', '}' ]\n\tlet closingBrackets:\
    \ [Character] = [ '(', ')', '[', ']', '{', '}' ]\n\tvar closed = false\n\tfor\
    \ bracket in brackets {\n\t\tfor openBracket in openingBrackets {\n\t\t\tif bracket\
    \ == openBracket {\n\t\t\t\topeningBrackets.remove(openBracket)\n\t\t\t\tclosed\
    \ = false\n\t\t\t}\n\t\t\tif closed && openBracket == brackets.last! {\n\t\t\t\
    \treturn false\n\t\t\t}\n\t\t}\n\t\tfor closeBracket in closingBrackets {\n\t\t\
    \tif bracket == closeBracket {\n\t\t\t\tclosingBrackets.remove(closeBracket)\n\
    \t\t\t\tclosed = true\n\t\t\t}\n\t\t\tif closed && closeBracket == brackets.first!\
    \ {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true", "    var result\
    \ = true\n    for b in brackets {\n        if !is_valid_opening_bracket(b) {\n\
    \            result = false\n            break\n        }\n    }\n    return result",
  "    guard let openingBracketsString = brackets.characters.split{$0 == CharacterSet.openingBrackets}\
    \ else { return true }\n    guard let closingBracketsString = brackets.characters.split{$0\
    \ == CharacterSet.closingBrackets} else { return true }\n    return openingBracketsString.count\
    \ == closingBracketsString.count", "    switch brackets.characters.count {\n \
    \   case 0: return true\n    case 1: return brackets.characters[0] == '('\n  \
    \  case 2: return brackets.characters[0] == '(' && brackets.characters[1] == ')'\n\
    \    case 3: return brackets.characters[0] == '(' && brackets.characters[1] ==\
    \ ')' && brackets.characters[2] == ')'\n    case 4: return brackets.characters[0]\
    \ == '(' && brackets.characters[1] == ')' && brackets.characters[2] == ')' &&\
    \ brackets.characters[3] == ')'\n    case 5: return brackets.characters[0] ==\
    \ '(' && brackets.characters[1] == ')' && brackets.characters[2] == ')' && brackets.characters[3]\
    \ == ')' && brackets.characters[4] == ')'\n    default: return false\n    }",
  "    var opening: [Int: Bool]\n    var closing: [Int: Bool]\n    for ch in brackets.unicodeScalars\
    \ {\n        let index = brackets.index(ch)\n        opening[index] = true\n \
    \       closing[index] = false\n    }\n    let len = brackets.unicodeScalars.count\n\
    \    for index in stride(from: len, to: len - 1, by: -1) {\n        let open =\
    \ opening[index]\n        let close = closing[index]\n        if open && !close\
    \ {\n            return false\n        } else if !open && close {\n          \
    \  return false\n        }\n    }\n    return true", "    var parenthesesNeeded\
    \ = false\n    var bracketStack = [Character]()\n    var bracketCount = 0\n  \
    \  var currentBracket = Character(self)\n    for character in brackets {\n   \
    \     bracketStack.append(currentBracket)\n        if character == '(' || character\
    \ == '[' {\n            bracketCount++\n        } else if character == ')' ||\
    \ character == ']' {\n            bracketCount--\n        }\n        parenthesesNeeded\
    \ = bracketCount > 0\n        currentBracket = bracketStack.pop()!\n    }\n  \
    \  return parenthesesNeeded", "    brackets = brackets.trimmingCharacters(in:\
    \ CharacterSet(charactersIn: \" \\t\\n\\r\"))\n    if brackets.isEmpty() {\n \
    \       return false\n    }\n    var stack = brackets.characters.reversed()\n\
    \    var opening = 1\n    var closing = 1\n    for i in 0..<stack.count {\n  \
    \      let c = stack[i]\n        switch c {\n        case \".\":\n           \
    \ closing = closing * 2 + 1\n        case \"(\":\n            opening = opening\
    \ + 1;\n            closing = closing * 2 + 1\n        case \")\":\n         \
    \   opening = opening - 1;\n            closing = closing * 2 + 1\n        default:\n\
    \            if opening > closing {\n                return false\n          \
    \  }\n            opening = opening - 1\n            closing = closing - 1\n \
    \       }\n    }\n    return opening == 0", "    let openingBrackets = brackets.characters.split(CharacterSet.init(charactersIn:\
    \ \"()\"))\n        .map { String($0) }\n    let closingBrackets = brackets.characters.split(CharacterSet.init(charactersIn:\
    \ \"\")).map { String($0) }\n\n    let setOfOpeningBrackets = Set(openingBrackets)\n\
    \    let setOfClosingBrackets = Set(closingBrackets)\n\n    for (index, value)\
    \ in openingBrackets.enumerated() {\n        if !setOfClosingBrackets.contains(String(value))\
    \ {\n            return false\n        }\n    }\n    return true", "    let brackets\
    \ = brackets.lowercased()\n\n    // TODO: Remove after dropping support for Swift\
    \ 2.3\n    if #available(OSX 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)  {\n  \
    \      let scanner  = NSScanner(string: brackets)\n        let tokens   = scanner.scanUpToString(\"\
    )\", intoString: nil)\n        scanner.scanLocation = 1\n        let tokens2 =\
    \ scanner.scanUpToString(\"(\", intoString: nil)\n        scanner.scanLocation\
    \ = tokens2.count\n        return tokens != nil && tokens2 == nil\n    } else\
    \ {\n        return brackets.range(of: \")\") == nil && brackets.range(of: \"\
    (\") == nil\n    }", "    let openingBrackets = brackets.characters.split{$0 ==\
    \ \" \"}.map(String.init)\n    let closingBrackets = brackets.characters.split{$0\
    \ == \"(\"}.map(String.init)\n\n    // Check that the length of each opening bracket\
    \ is equal to the number of closing\n    // brackets\n    for index in 0..<openingBrackets.count\
    \ {\n        // We need to check that the closing brackets have a corresponding\
    \ opening bracket\n        if openingBrackets[index].count != closingBrackets.count\
    \ {\n            return false\n        }\n\n        // Check that the closing\
    \ brackets are the same as the corresponding opening brackets\n        for secondIndex\
    \ in 0..<openingBrackets[index].count {\n            if openingBrackets[index][secondIndex]\
    \ != closingBrackets[secondIndex] {\n                return false\n          \
    \  }\n        }\n    }\n\n    return true", "    guard brackets.isEmpty == false\
    \ else {\n        return true\n    }\n\n    var openingBrackets: Set<Character>\
    \ = Set()\n    var closingBrackets: Set<Character> = Set()\n\n    for i in 0..<brackets.characters.count\
    \ {\n        let char: Character = brackets.characters[i]\n        if char ==\
    \ \"(\" {\n            openingBrackets.insert(char)\n        } else {\n      \
    \      closingBrackets.insert(char)\n        }\n    }\n\n    return openingBrackets.isSubset(of:\
    \ closingBrackets)", "    var opening = brackets.characters\n    opening = remove_brackets(opening)\n\
    \    opening = opening.characters.sorted()\n    var closing = brackets.characters\n\
    \    closing = remove_brackets(closing)\n    closing = closing.characters.sorted()\n\
    \    return opening.count == closing.count", "    let firstOpenBracket = brackets.index(\"\
    (\")\n    let lastClosedBracket = brackets.lastIndexOf(\")\")\n    return firstOpenBracket\
    \ <= lastClosedBracket", "\tbrackets = brackets.Trim()\n\n\tbrackets = brackets.Replace(\"\
    ((\", \"(\")\n\tbrackets = brackets.Replace(\"(,\", \",(\")\n\tbrackets = brackets.Replace(\"\
    )(\", \")(\")\n\tbrackets = brackets.Replace(\"))\", \"))\")\n\tbrackets = brackets.Replace(\"\
    ))\", \")\")\n\tbrackets = brackets.Replace(\"))\", \")\")\n\tbrackets = brackets.Replace(\"\
    ))\", \")\")\n\tbrackets = brackets.Replace(\"))\", \")\")\n\n\tbrackets = brackets.Replace(\"\
    (\", \")\")\n\tbrackets = brackets.Replace(\",\", \",\")\n\tbrackets = brackets.Replace(\"\
    )\", \")\")\n\tbrackets = brackets.Replace(\",\", \",\")\n\tbrackets = brackets.Replace(\"\
    )\", \")\")\n\tbrackets = brackets.Replace(\")\", \")\")\n\tbrackets = brackets.Replace(\"\
    )\", \")\")\n\tbrackets = brackets.Replace(\")\", \")\")\n\tbrackets = brackets.Replace(\"\
    )\", \")\")\n\n\treturn brackets.Count() == brackets.Length()", "    var count\
    \ = 0\n    var last = 0\n    for i := 0; i < len(brackets); i++ {\n        switch\
    \ brackets[i] {\n        case \"(\":\n            count++\n        case \"{\"\
    :\n            count++\n        case \"}\":\n            count--\n        case\
    \ \"(\":\n            count--\n        default:\n            break\n        }\n\
    \        if count == 0 {\n            last = i\n        }\n    }\n    return last\
    \ == len(brackets)", "\tbrackets = brackets.stringByReplacingOccurrencesOfString(\"\
    (\", withString: \"[\")\n\tbrackets = brackets.stringByReplacingOccurrencesOfString\"\
    )\", withString: \"]\")\n\tbrackets = brackets.stringByReplacingOccurrencesOfString(\"\
    [\", withString: \"(\")\n\tbrackets = brackets.stringByReplacingOccurrencesOfString(\"\
    ]\", withString: \")\")\n\n\tfor _, bracket in brackets.stringByReplacingOccurrencesOfString(\"\
    [\", withString: \"\").stringByReplacingOccurrencesOfString(\"]\", withString:\
    \ \"\").split() {\n\t\tif bracket.isEmpty() {\n\t\t\treturn false\n\t\t}\n\t}\n\
    \treturn true", "\tswitch {\n\tcase brackets == \"(\":\n\t\treturn false\n\tcase\
    \ brackets == \"()\":\n\t\treturn true\n\tcase brackets == \"(()())\":\n\t\treturn\
    \ true\n\tcase brackets == \")((\":\n\t\treturn false\n\tdefault:\n\t\treturn\
    \ false\n\t}", "    var opening_bracket = brackets[0]\n    var closing_bracket\
    \ = brackets[brackets.endIndex-1]\n    for char in brackets {\n        // Don't\
    \ allow a closing bracket without an opening bracket to match.\n        // This\
    \ prevents a trailing closing bracket from matching a leading opening bracket.\n\
    \        if opening_bracket == \"(\" && (char == \"(\" || char == \")\") {\n \
    \           return false\n        }\n        // Don't allow a closing bracket\
    \ without an opening bracket to match.\n        // This prevents a trailing closing\
    \ bracket from matching a trailing opening bracket.\n        if closing_bracket\
    \ == \"(\" && (char == \"(\" || char == \")\") {\n            return false\n \
    \       }\n        // Don't allow an opening bracket without an closing bracket\
    \ to match.\n        // This prevents an opening bracket from matching a closing\
    \ bracket without an opening one.\n        if opening_bracket == \"(\" && char\
    \ == \")\" {\n            return false\n        }\n        // Don't allow a closing\
    \ bracket without an opening bracket to match.\n        // This prevents a trailing\
    \ closing bracket from matching a leading opening bracket.\n        if closing_bracket\
    \ == \"(\" && char == \"(\" {\n            return false\n        }\n        //\
    \ Don't allow an opening bracket without an closing bracket to match.\n      \
    \  // This prevents an opening bracket from matching a closing bracket without\
    \ an opening one.\n        if closing_bracket == \")\" && char == \"(\" {\n  \
    \          return false\n        }\n    }\n    return true", "    let stack =\
    \ [String]()\n    \n    let openingBrackets = brackets.characters\n        .filter\
    \ { $0 != \"(\" && $0 != \")\" }\n    \n    for char in openingBrackets {\n  \
    \      if char == \")\" {\n            stack.removeLast()\n        } else if char\
    \ == \"(\" {\n            stack.insert(char, true)\n        }\n    }\n    return\
    \ !stack.isEmpty", "    var bracketsStack: [Char] = []\n    for character in brackets\
    \ {\n        if character == \"(\" {\n            bracketsStack.append(character)\n\
    \        }\n        if character == \")\" {\n            if bracketsStack.count\
    \ == 0 {\n                return false\n            }\n            if bracketsStack.last\
    \ != \"(\" {\n                return false\n            }\n            bracketsStack.removeLast()\n\
    \        }\n    }\n    return bracketsStack.count == 0", "    var stack: Stack\
    \ = Stack()\n    for bracket in brackets {\n        switch bracket {\n       \
    \ case \"(\":\n            stack.append(bracket)\n        case \"[\":\n      \
    \      stack.append(bracket)\n        case \"{\":\n            stack.append(bracket)\n\
    \        case \"\\\"\":\n            // \"\n            if stack.count != 0 {\n\
    \                switch stack.last {\n                case \"[\", \"{\", \"(\"\
    :\n                    stack.removeLast()\n                case \"\\\"\":\n  \
    \                  stack.removeLast()\n                default:\n            \
    \        stack.removeLast()\n                }\n            }\n        default:\n\
    \            if stack.last == \"\" {\n                stack.removeLast()\n   \
    \         }\n        }\n    }\n    return stack.count == 0", "\tbrackets = brackets[brackets.startIndex..<brackets.endIndex.predecessor()]\n\
    \tbrackets = brackets[1..<brackets.startIndex]\n\n\tvar openingBrackets = [String]()\n\
    \tvar closingBrackets = [String]()\n\n\tfor char in brackets {\n\t\tif char ==\
    \ \")\" {\n\t\t\tif openingBrackets.last != \"\" {\n\t\t\t\treturn false\n\t\t\
    \t}\n\t\t\tclosingBrackets.append(char)\n\t\t} else {\n\t\t\tif char == \"(\"\
    \ {\n\t\t\t\tif !openingBrackets.contains(char) {\n\t\t\t\t\treturn false\n\t\t\
    \t\t}\n\t\t\t} else {\n\t\t\t\tif !closingBrackets.contains(char) {\n\t\t\t\t\t\
    return false\n\t\t\t\t}\n\t\t\t}\n\t\t\topeningBrackets.append(char)\n\t\t}\n\t\
    }\n\n\treturn openingBrackets.count == closingBrackets.count", "    var openingBracketsCount\
    \ = [Character: Int]()\n    for char in brackets {\n        if openingBracketsCount[char]\
    \ != 0 {\n            return false\n        } else {\n            openingBracketsCount[char]\
    \ = -1\n        }\n    }\n    var lastChar: Character?\n    for char in brackets\
    \ {\n        if let count = openingBracketsCount[char] {\n            openingBracketsCount[char]\
    \ = count + 1\n        } else {\n            openingBracketsCount[char] = 1\n\
    \        }\n        if openingBracketsCount[lastChar] != -1 {\n            return\
    \ false\n        }\n        lastChar = char\n    }\n    return true", "    var\
    \ bracketCount = 0\n\n    for bracket in brackets {\n        bracketCount += bracket.count\n\
    \    }\n\n    return bracketCount > 0", "    let openings = brackets.components(separatedBy:\
    \ \"(\")\n        .map { String($0) }\n    let closings = brackets.components(separatedBy:\
    \ \")\")\n        .map { String($0) }\n    guard openings.count == closings.count\
    \ else { return false }\n    guard openings.first == closings.last else { return\
    \ false }\n    return true", "    let opening = brackets.characters.split{$0 ==\
    \ \")\"}.count != 0\n    let closing = brackets.characters.split{$0 == \"(\"}.count\
    \ != 0\n    return opening && closing", "    for opening in brackets {\n     \
    \   let lastIndex = opening.characters.count - 1\n        for open in brackets.characters.reverse()\
    \ {\n            let index = brackets.index(open, offsetBy: -opening.characters.count)\n\
    \            let closing = brackets[index..<lastIndex]\n            if opening\
    \ == closing {\n                return true\n            }\n        }\n    }\n\
    \    return false", "    var count = 0\n    for c in brackets {\n        if c\
    \ == \")\" {\n            count += 1\n        } else if c == \"(\" {\n       \
    \     if count > 0 {\n                return false\n            }\n          \
    \  count = 1\n        } else {\n            return false\n        }\n    }\n \
    \   return count == 0", "    let opening_brackets = brackets.characters\n    \
    \    .filter({ $0 == \"(\" })\n        .sorted()\n        .reversed()\n    let\
    \ closing_brackets = brackets.characters\n        .filter({ $0 == \")\" })\n \
    \       .sorted()\n        .reversed()\n    if opening_brackets.last != closing_brackets.first\
    \ {\n        return false\n    }\n    return true", "\tbrackets = brackets.lowercased()\n\
    \topeningBracketsCount = brackets.count(\"(\")\n\tclosingBracketsCount = brackets.count(\"\
    )\")\n\tfor i := 0; i < openingBracketsCount; i++ {\n\t\tif closingBracketsCount\
    \ <= i {\n\t\t\treturn false\n\t\t}\n\t\tif brackets[i] != brackets[closingBracketsCount]\
    \ {\n\t\t\treturn false\n\t\t}\n\t\tclosingBracketsCount--\n\t}\n\treturn true",
  '    return brackets.split(" ").map { $0 == "(" || $0 == ")" }.count() == brackets.count',
  "    let stack = brackets.characters\n        .map {\n            if $0 == \"(\"\
    \ {\n                Stack.push(Stack.top)\n                return Stack.top\n\
    \            } else {\n                Stack.pop()\n                return Stack.top\n\
    \            }\n        }\n\n    for index in stride(from: 0, to: stack.count-1,\
    \ by: -1) {\n        if stack[index] != stack[index+1] {\n            return false\n\
    \        }\n    }\n    return true", "    brackets = brackets.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n\n    if brackets.isEmpty {\n        return\
    \ true\n    }\n\n    let openingBrackets = [brackets.startIndex..<brackets.endIndex]\n\
    \n    var openingBracketSet = CharacterSet.none\n\n    for openingBracket in openingBrackets\
    \ {\n        if openingBracketSet.contains(openingBracket) {\n            return\
    \ false\n        }\n        openingBracketSet = openingBracketSet.union(openingBracket)\n\
    \    }\n\n    return true"]
stop_tokens:
- "\n}"
