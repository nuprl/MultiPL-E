name: HumanEval_14_all_prefixes
language: swift
prompt: "\n/// Return array of all prefixes from shortest to longest of the input\
  \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
  func all_prefixes(string: String) -> [String] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
  assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"\
  asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"\
  WWW\"])"
completions: ["\tlet stringArray = string.characters.split{$0 == $0}\n\treturn stringArray.filter{$0.isPrefix}.map{$0.dropLast()}",
  "\treturn all_prefixes_(string, \"\")", "    var result: [String] = []\n    var\
    \ currentCharIndex = 0\n    var lastPrefix: String = \"\"\n\n    while currentCharIndex\
    \ < string.characters.count {\n        if string.starts(with: lastPrefix) {\n\
    \            result.append(lastPrefix)\n            currentCharIndex += lastPrefix.count\n\
    \            lastPrefix = \"\"\n        } else {\n            lastPrefix = lastPrefix\
    \ + string.substring(from: currentCharIndex)\n        }\n        currentCharIndex\
    \ += 1\n    }\n\n    result.append(lastPrefix)\n    return result", "\tvar prefixes\
    \ = [String]()\n\n\tfor len(string) > 0 {\n\t\tprefixes.append(String(string))\n\
    \t\tstring = string[..<len(string)]\n\t}\n\n\treturn prefixes", "    var prefixes\
    \ = [String]()\n    var substring = string\n\n    while substring.count > 0 {\n\
    \        let prefixLength = substring.characters.count + string.characters.count\n\
    \        let prefixSubstring = substring(from: prefixLength)\n        prefixes.append(prefixSubstring)\n\
    \        substring = prefixSubstring\n    }\n    return prefixes", "\tvar arr\
    \ = [String]()\n\tprefixes {\n\t\tarr.append($0)\n\t}\n\treturn arr", "    if\
    \ string == \"\" {\n        return []\n    }\n    var prefixes: [String] = []\n\
    \    var len = string.count\n    var index = 0\n    repeat {\n        prefixes.append(string.prefix(index))\n\
    \        index = index + 1\n    } while (index != len)\n    return prefixes",
  "    var prefix = \"\"\n    var prefixes = [String]()\n\n    for c in string.utf8\
    \ {\n        prefix += String(c)\n        if prefixes.contains(prefix) {\n   \
    \         continue\n        }\n\n        prefixes.append(prefix)\n        prefix\
    \ = \"\"\n    }\n\n    return prefixes", '    return prefixes(string, shortest:
    true, longest: false).map { $0.prefixString }', "\tvar prefixes = [String]()\n\
    \t\n\tlet stringLength = string.characters.count\n\t\n\t// If string is empty\n\
    \tif stringLength < 1 {\n\t\treturn prefixes\n\t}\n\t\n\tvar characterIndex =\
    \ 0\n\tvar characterValue = string.characters.first!\n\t\n\t// Loop through the\
    \ string\n\tfor characterIndex < stringLength {\n\t\tif characterValue != string.characters.last!\
    \ {\n\t\t\tprefixes.append(String(characterValue))\n\t\t}\n\t\t\n\t\tcharacterIndex\
    \ += 1\n\t\tcharacterValue = string.characters.enumerated().last!.element\n\t\
    }\n\t\n\treturn prefixes", "    var res = Array(count: string.count, repeatedValue:\
    \ \"\")\n    for ch in string.unicodeScalars {\n        res.append(String(ch))\n\
    \    }\n    return res", "    var result: [String] = []\n    for start in 0..<string.characters.count\
    \ {\n        var prefix = string[start]\n        for _ in 0..<(string.characters.count\
    \ - start) {\n            prefix += string[start + 1]\n            result.append(prefix)\n\
    \        }\n    }\n    return result", "\tif let index = string.startIndex {\n\
    \t\tif string.hasPrefix(string[index...]) {\n\t\t\treturn [string[...index]...].flatMap\
    \ { all_prefixes(string: $0) }\n\t\t}\n\t}\n\treturn []", "    var prefix = \"\
    \"\n    var prefix_array = [String]()\n    for c in string.characters {\n    \
    \    if c.isLetterOrDigit() {\n            prefix += c\n        } else {\n   \
    \         if prefix != \"\" {\n                prefix_array.append(prefix)\n \
    \               prefix = \"\"\n            }\n        }\n    }\n    if prefix\
    \ != \"\" {\n        prefix_array.append(prefix)\n    }\n    return prefix_array",
  '    return prefixes(string).reversed()', "    var result = Array<String>()\n  \
    \  var current = \"\"\n    for character in string {\n        if character ==\
    \ \"\" {\n            current = \"\"\n        } else {\n            current =\
    \ current + String(character)\n        }\n        if current.count > result.count\
    \ {\n            result = current\n        }\n    }\n    return result", "   \
    \ var prefixes = [String]()\n    var stringWithoutPrefixes = string\n    for c\
    \ in stringWithoutPrefixes {\n        prefixes += all_prefixes(stringWithoutPrefixes.substringToIndex(0))\n\
    \        prefixes.append(c)\n    }\n    return prefixes", "\treturn _all_prefixes.call(unsafeUnretainedPointer(mutatingSelf(string)),\
    \ string)", '    return prefixes(string, 0)', "\treturn string[1..<string.count].split(separator:\
    \ \"\")", "    var prefixes: [String] = []\n    var stringArray: [String] = string.characters.split(separator:\
    \ \".\").map(String.init)\n    for i in 0..<stringArray.count {\n        var prefix\
    \ = \"\"\n        let element = stringArray[i]\n        for j in i..<stringArray.count\
    \ {\n            let element = stringArray[j]\n            if element != \"\"\
    \ {\n                prefix += element\n                prefixes.append(prefix)\n\
    \                prefix = \"\"\n            }\n        }\n    }\n    return prefixes",
  "    let short = string.prefix(string.length)\n    return Array(short.suffix(1))",
  "    var result = [String]()\n    for s in string.split(separator: \".\") {\n  \
    \      let trimmed = s.trimmingCharacters(in: CharacterSet(charactersIn: \".\"\
    )!)\n        if !trimmed.isEmpty {\n            result.append(trimmed)\n     \
    \   }\n    }\n    return result", '    return strings.Prefixes(string).sorted()',
  '    return all_prefixes_helper(string)', "    if string == \"\" { return [] }\n\
    \    var maxLength = 0\n    var prefixes = [String]()\n    for char in string\
    \ {\n        if maxLength > 0 {\n            prefixes.append(String(char) + String(string[string.startIndex.advancedBy(maxLength\
    \ - 1)]))\n        }\n        maxLength = max(maxLength, string.countCharacters(in:\
    \ String(char)))\n    }\n    return prefixes", "    if string == \"\" {\n    \
    \    return nil\n    }\n\n    let start = string[0]\n    var prefixes: [String]\
    \ = []\n    var current = start\n    for c in string {\n        if c == current\
    \ {\n            prefixes.append(current)\n        } else {\n            prefixes.append(current)\n\
    \            prefixes.append(c)\n        }\n        current = c\n    }\n    return\
    \ prefixes", "    if string == \"\" {\n        return [0]\n    }\n    var prefix_array\
    \ = [String]()\n    var prefix_count = 0\n    var char_index = 0\n    for _ in\
    \ 0..<string.characters.count {\n        char_index += 1\n        prefix_count\
    \ = char_index\n        if let last_index = string.characters.index(of: String(string.characters[char_index]),\
    \ from: char_index) {\n            prefix_array.append(String(string.characters[last_index...]))\n\
    \            prefix_array.append(String(string.characters[char_index...]))\n \
    \       } else {\n            prefix_array.append(String(string.characters[char_index...]))\n\
    \        }\n    }\n    return prefix_array", "    var prefixes = [String]()\n\
    \    for let index = string.firstIndex(of: \"\") {\n        prefixes.append(String(string.suffixFrom(index)))\n\
    \    }\n    return prefixes", '    return prefixes(string, 1)', "    var result:\
    \ [String] = []\n    result.reserveCapacity(strings.Length)\n    for c in string\
    \ {\n        result.append(string[..<string.IndexOf(c)].trimmed())\n    }\n  \
    \  return result", "    let prefixesMutable = string.mutableCopy() as! NSMutableString\n\
    \    let prefixes = Array(prefixesMutable.componentsSeparatedByString(\"\"))\n\
    \    prefixesMutable.removeLast()\n    return prefixes", "    var result: [String]\
    \ = []\n\n    for start in 0..<string.characters.count {\n        let end = string.distance(from:\
    \ String.Index(encodedOffset: start), to: String.Index(encodedOffset: string.characters.count))\n\
    \        let prefix = string.substring(with: String.Index(string: string, offsetBy:\
    \ start))\n        result.append(prefix)\n    }\n\n    return result", "\tif string\
    \ == \"\" {\n\t\treturn []\n\t}\n\tprefixes = [\"\"]\n\tvar current = \"\"\n\t\
    for i := 0; i < len(string); i++ {\n\t\tcurrent += string[i]\n\t\tprefixes = append(prefixes,\
    \ current)\n\t\tcurrent = \"\"\n\t}\n\treturn prefixes", "    if let splitString\
    \ = string.characters, !splitString.isEmpty {\n        var prefixes = [String]()\n\
    \        var currentPrefix = \"\"\n        for char in splitString {\n       \
    \     if char <= ' ' {\n                prefixes.append(currentPrefix)\n     \
    \           currentPrefix = \"\"\n                continue\n            }\n  \
    \          if char == ' ' {\n                prefixes.append(currentPrefix)\n\
    \            }\n            currentPrefix = currentPrefix + String(char)\n   \
    \     }\n        prefixes.append(currentPrefix)\n        return prefixes\n   \
    \ }\n    return []", "    var prefixes = [String]()\n    var currentPrefix = \"\
    \"\n    for character in string.characters {\n        let prefix = currentPrefix\n\
    \        let isBeginningOfNewPrefix = currentPrefix.characters.count < character.characters.count\n\
    \        currentPrefix = currentPrefix.appending(character)\n        prefixes.append(prefix)\n\
    \        if !isBeginningOfNewPrefix {\n            return prefixes\n        }\n\
    \    }\n    return prefixes", '    return getPrefixes(string, minimumLength: 1)',
  "    if string == \"\" {\n        return nil\n    }\n    return prefixes(string,\
    \ len(string))", "    var result = [String]()\n    for s in string.split(separator:\
    \ \"\") {\n        if s.count > 1 {\n            result.append((s[0] + String(s.dropFirst()).capitalized))\n\
    \        }\n    }\n    return result", "    return split(string) {\n        prefix\
    \ in\n        let splitAt = string.index(prefix, offsetBy: prefix.characters.count)\n\
    \        return splitAt != string.endIndex\n    }", "    if string.isEmpty {\n\
    \        return []\n    }\n    var prefixes = [String]()\n    var curPrefix =\
    \ \"\"\n    for c in string {\n        if c == curPrefix {\n            prefixes.append(curPrefix)\n\
    \        } else {\n            curPrefix = c\n            prefixes.append(c)\n\
    \        }\n    }\n    return prefixes", '    return all_prefixes_recursion(string:
    string)', '    return prefixes(string: string, from: 0)', "\tif string == \"\"\
    \ {\n\t\treturn []\n\t}\n\tprefixes := [String]()\n\tcurrent := string\n\tfor\
    \ {\n\t\tprefixes.append(current)\n\t\tcurrent = prefixes.suffix(current)\n\t\t\
    if current == \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn prefixes", "    let mut\
    \ prefixes = [String]()\n    let mut str = string\n    loop {\n        prefixes.append(str)\n\
    \        str = str.substringToIndex(advance(str.startIndex, len(str)))\n     \
    \   if str.isEmpty {\n            break\n        }\n    }\n    return prefixes",
  '    return string.prefixes_(string.count)', "    // Write your code here\n    if\
    \ let range = string.unicodeScalars.first?.range(of: String(string.unicodeScalars.dropFirst().first!))\
    \ {\n        return Array(string.unicodeScalars[range.upperBound...])\n    }\n\
    \    return []", "\tvar result = [String]()\n\tlet strings = string.characters.split{$0\
    \ == \" \"}.map(String.init)\n\tfor string in strings {\n\t\tif let lastIndex\
    \ = string.characters.index(of: \" \") {\n\t\t\tresult.appendContentsOf(string.substring(from:\
    \ lastIndex + 1))\n\t\t}\n\t}\n\treturn result", "    if string == \"\" {\n  \
    \      return []\n    }\n    if string[0] == \"\" {\n        return [string]\n\
    \    }\n\n    return all_prefixes(string: string.characters) +\n        prefix(string:\
    \ string.characters.dropFirst())", "    var prefixes: [String] = []\n    var shortest:\
    \ String = string\n    var longest: String = string\n    prefix {\n        for\
    \ (i, _) in string.enumerated() {\n            if i > 0 {\n                prefixes.append(longest)\n\
    \            }\n            if shortest == \"\" {\n                shortest =\
    \ string\n                longest = string\n            } else {\n           \
    \     shortest = longest\n                longest = string\n            }\n  \
    \      }\n    }\n    prefixes.append(longest)\n    return prefixes", "    var\
    \ prefixes = [String]()\n    for s in string {\n        prefixes.append(s)\n \
    \       prefixes.removeLast()\n    }\n    return prefixes", '    return string.prefixes',
  "    var prefixes = [String]()\n    var prefix = \"\"\n    for letter in string\
    \ {\n        if let index = string.index(of: letter) {\n            prefix = string[index..<index]\n\
    \            prefixes.append(prefix)\n        }\n    }\n    return prefixes",
  '    return prefixes(string, shortestLength: 1, longestLength: -1)', "    let lengths:\
    \ [Int] = countLongestCommonPrefix(string)\n    let results: [String] = [String]()\n\
    \    for length in lengths {\n        let prefix = string[..<length]\n       \
    \ results.append(prefix)\n    }\n    return results", "\treturn all_prefixes_recursive(string).reverse()",
  "\t\n\tvar prefixes = [String]()\n\t\n\tif let prefixes = string._prefixes {\n\t\
    \tfor prefix in prefixes {\n\t\t\tprefixes.append(prefix)\n\t\t}\n\t}\n\t\n\t\
    return prefixes", "    var result: [String] = []\n    for ch in string {\n   \
    \     if !result.contains(ch) {\n            result.append(ch)\n        }\n  \
    \  }\n    return result", '  return prefixes(string, min_length: 1)', "    if\
    \ let rangeOfFirstCharacter = string.firstIndex(of: \"^\") {\n        return string[rangeOfFirstCharacter\
    \ + 1..<string.endIndex].split(separator: \"^\").map { $0 }\n    }\n    return\
    \ []", '    return string.prefixes(from: 0, to: string.count)', "    var prefixes\
    \ = [String]()\n    if string.characters.count < 2 {\n        return prefixes\n\
    \    }\n    var i = 0\n    var current = \"\"\n    var previous = \"\"\n    for\
    \ char in string.characters {\n        if char == previous {\n            prefixes.append(current)\n\
    \            current = \"\"\n        } else {\n            current = (current\
    \ + String(char)) + String(previous)\n        }\n        previous = char\n   \
    \ }\n    prefixes.append(current)\n    return prefixes", "    if string.characters.count\
    \ == 0 {\n        return []\n    }\n    let count = string.characters.count\n\
    \    var prefix = [String]()\n    for n in 0..<count {\n        prefix.append(string.prefix(upTo:\
    \ n))\n    }\n    return prefix", "    var result = [String]()\n    var shortest\
    \ = string.characters.count\n    var longest = 0\n    for c in string.characters\
    \ {\n        longest = max(longest, c.count)\n        if shortest > c.count {\n\
    \            shortest = c.count\n            result = result + [String]()\n  \
    \      }\n        result.append(c.suffix(longest))\n    }\n    return result",
  '    return all_prefixes_helper(string).all', "    var prefixes = [String]()\n \
    \   var stringCopy = string\n    while let currentChar = stringCopy.characters.first\
    \ {\n        let lastChar = stringCopy.characters.last\n        prefixes.append(String(currentChar))\n\
    \        stringCopy = stringCopy.substring(to: lastChar)\n    }\n    return prefixes",
  "\tif string == \"\" {\n\t\treturn []\n\t}\n\n\tprefixes := []String{}\n\tcharIndex\
    \ := 0\n\tlength := len(string)\n\n\tfor {\n\t\tif charIndex == length {\n\t\t\
    \tbreak\n\t\t}\n\n\t\tprefix := string[charIndex]\n\t\tprefixes = append(prefixes,\
    \ prefix)\n\t\tcharIndex++\n\n\t\tif charIndex == length {\n\t\t\tbreak\n\t\t\
    }\n\n\t\tprefix = string[charIndex]\n\t\tif prefix == \"*\" {\n\t\t\tcharIndex++\n\
    \t\t\tif charIndex == length {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tprefix = string[charIndex]\n\
    \t\t}\n\t}\n\n\treturn prefixes", "    var prefixes: [String] = []\n    for start\
    \ in stride(from: string.characters.count - 1, through: 0, by: -1) {\n       \
    \ var end = string.characters.count - 1\n        let index = string.index(string.startIndex,\
    \ offsetBy: start)\n        while end >= 0 && string.characters.characters.count\
    \ > end {\n            end -= 1\n            index = string.index(index, offsetBy:\
    \ 1)\n        }\n        prefixes.append(string.substring(to: index))\n    }\n\
    \    return prefixes", '    return all_prefixes_internal(string, 1)', "    var\
    \ longest = string\n    var shortest = \"\"\n    for char in string.characters\
    \ {\n        if longest.characters.count < char.characters.count {\n         \
    \   longest = char.prefix(string)\n        }\n        if shortest == \"\" { shortest\
    \ = char }\n        else if char.characters.count < shortest.characters.count\
    \ {\n            shortest = char.suffix(string)\n        }\n    }\n    return\
    \ [shortest, longest]", "    if string.isEmpty {\n        return []\n    }\n\n\
    \    var prefixes = [String]()\n    var substring = string\n    var substringIndex\
    \ = 0\n    while !substring.isEmpty {\n        var lastSubstringIndex = -1\n \
    \       for index in 0..<string.count {\n            if string.substring(index,\
    \ substringIndex) == substring {\n                lastSubstringIndex = index\n\
    \                break\n            }\n        }\n        prefixes.insert(string.substring(substringIndex,\
    \ lastSubstringIndex), at: prefixes.count)\n        substringIndex = lastSubstringIndex\n\
    \        substring = string.substring(substringIndex, string.count)\n    }\n \
    \   return prefixes", "    if string == \"\" {\n        return []\n    }\n   \
    \ var prefixes = [String]()\n    for ch in string.unicodeScalars {\n        if\
    \ let _ = ch {\n            prefixes.append(String(ch))\n        }\n    }\n  \
    \  return prefixes", "\tvar prefixes = [String]()\n\t\n\tvar i = 0\n\t\n\tfor\
    \ i < string.count {\n\t\tif prefixes.count >= 3 {\n\t\t\tbreak\n\t\t}\n\t\tprefixes.append(string.prefix(at:\
    \ i))\n\t\ti += 1\n\t}\n\t\n\treturn prefixes", "\tlet prefixes = [\"\"]\n\tfor\
    \ i in 0..<string.count {\n\t\tprefixes[0] += string[i]\n\t\tfor prefix in prefixes\
    \ {\n\t\t\tif string.hasPrefix(prefix) {\n\t\t\t\treturn prefixes\n\t\t\t}\n\t\
    \t}\n\t\tprefixes.append(string[i])\n\t}\n\treturn prefixes", "\treturn all_prefixes_with_max_len(string,\
    \ string.characters.count)", "\tvar prefix = \"\"\n\tvar result : [String] = []\n\
    \tfor char in string.characters {\n\t\tif prefix != \"\" {\n\t\t\tresult = append(result,\
    \ prefix)\n\t\t\tprefix = \"\"\n\t\t}\n\t\tprefix += char\n\t}\n\tif prefix !=\
    \ \"\" {\n\t\tresult = append(result, prefix)\n\t}\n\treturn result", '    return
    prefixesOf(string, count: longest(string))', "    var result = [String]()\n  \
    \  var i = 0\n    for _ in string.characters.reverse() {\n        result.append(string[i..<string.characters.count])\n\
    \        i += 1\n    }\n    return result", '  return get_prefixes_helper(string).reversed()',
  "    \n    let prefixes = Array(string.prefixes)\n    return prefixes.map { String($0)\
    \ }", "    if string == \"\" {\n        return []\n    }\n    return string.characters.dropLast().map(String.init)",
  "    if string.characters.count == 0 {\n        return []\n    }\n\n    var prefixes\
    \ = make([][String], 0)\n    var currentPrefixes = [String]()\n    for character\
    \ in string.characters {\n        currentPrefixes.append(String(character))\n\n\
    \        if currentPrefixes.count > prefixes.count {\n            prefixes = currentPrefixes\n\
    \        }\n    }\n    return prefixes", "    var result: [String] = []\n    var\
    \ i = 0\n    while i < string.count {\n        i += 1\n        if string.hasPrefix(string[i..<string.count])\
    \ {\n            result = result + [string[i..<string.count]]\n        }\n   \
    \ }\n    return result", "    var prefixes = [String]()\n    string.enumerateSubstrings(in:\
    \ Range<String.Index>(start: string.startIndex, end: string.endIndex)) {\n   \
    \     (substring, substringRange, enclosingRange, _) in\n        if substringRange.upperBound\
    \ == nil {\n            prefixes.append(substring)\n        }\n    }\n    return\
    \ prefixes", "  var prefixes = [String]()\n\n  for char in string {\n    if string.startsWith(String(char))\
    \ {\n      prefixes.append(String(char))\n    }\n  }\n  return prefixes", "\t\
    return prefixesArray(string, true)", '    return all_prefixes_helper(string)',
  "    var prefixes = [String]()\n    var last = \"\"\n    for character in string\
    \ {\n        if last.hasPrefix(character) {\n            prefixes.append(last)\n\
    \        }\n        last = String(character)\n    }\n    prefixes.append(last)\n\
    \    return prefixes", "    var prefixes = [String]()\n    for s in string.characters\
    \ {\n        prefixes.append(String(repeating: s, count: min(string.count - 1,\
    \ s.count)))\n    }\n    return prefixes", '    return prefixes(string, shortestToLongest:
    true)', "    var prefixes = [String]()\n    var currentString: String = \"\"\n\
    \n    for i in 0 ..< string.characters.count {\n        let currentChar = String(string.character(at:\
    \ i))\n        currentString += currentChar\n        if currentString.characters.count\
    \ > 0 {\n            prefixes.append(currentString)\n        }\n        currentString\
    \ = \"\"\n    }\n    return prefixes", "\tvar prefixes = [String]()\n\t\n\tfor\
    \ _ in 0..<string.count {\n\t\t\n\t\tif string.isEmpty {\n\t\t\treturn prefixes\n\
    \t\t}\n\t\t\n\t\tlet start = string.index(string.startIndex, offsetBy: 1)\n\t\t\
    let end = string.index(start, offsetBy: -1)\n\t\t\n\t\tprefixes.append(String(string.substringWithRange(start..<end)))\n\
    \t\t\n\t\tstring = String(string.substring(start..<end))\n\t}\n\t\n\treturn prefixes",
  '    return all_prefixes_internal(string)', "    if let count = count(string) {\n\
    \        var prefixes: [String] = []\n        for _ in 0..<count {\n         \
    \   prefixes.append(\"\")\n        }\n        var s = count\n        while s >\
    \ 0 {\n            prefixes.last! += string[s-1]\n            s -= 1\n       \
    \ }\n        return prefixes\n    }\n    return []", "    var result = [String]()\n\
    \    var prefix = [String]()\n    for s in string.split(\"\") {\n        prefix.append(s)\n\
    \        if prefix.count > result.count {\n            result = prefix\n     \
    \   }\n    }\n    return result", "    guard let shorter = string.characters.prefix(min(string.characters.count,\
    \ 5)), let longer = string.characters.suffix(max(string.characters.count, 5))\
    \ else { return [] }\n    return shorter..longer", '    return prefixes_helper(string,
    "", "", false)', "    guard let input = string.cStringUsingEncoding(NSUTF8StringEncoding)\
    \ else {\n        return []\n    }\n    var output = [String]()\n    var length\
    \ = 0\n    for i in 0..<input.count {\n        if input[i] != 0 {\n          \
    \  let string = String(bytes: &input[i..<i+1], count: 1)\n            output.append(string)\n\
    \            length += string.count\n        }\n    }\n    if length == 0 {\n\
    \        return output\n    }\n    let reversedString = output.map { String($0)\
    \ }.reversed()\n    return reversedString.prefix(length).map { String($0) }",
  "    var prefixes = [String]()\n    let shortest = string\n    let longest = shortest.prefix(string:\
    \ string.endIndex).suffix(string: string.startIndex).string\n    shortest.enumerateSubstrings(in:\
    \ longest.unicodeScalars.startIndex..<longest.unicodeScalars.endIndex) { (substring,\
    \ substringRange, enclosingRange, _) in\n        prefixes.append(substring)\n\
    \    }\n    return prefixes", '    return prefixes(string, 1)', "\tlet str = string.characters.sorted()\n\
    \tvar result: [String] = []\n\tlet count = str.count\n\n\tfor let i = 0; i < count;\
    \ i++ {\n\t\tif i < count - 1 {\n\t\t\tlet prefixes = str[..<i+1].sorted()\n\t\
    \t\tresult.append(String(prefixes))\n\t\t}\n\t}\n\n\treturn result", "    var\
    \ prefixes: [String] = []\n    var len = string.characters.count\n    for i in\
    \ 0 ..< len {\n        prefixes.append(string.prefix(len))\n    }\n    return\
    \ prefixes", "    if string == \"\" { return [] }\n    let start = string.startIndex\n\
    \    let end = string.endIndex\n    let prefix = string.prefix(from: start)\n\
    \    if prefix == nil { return [] }\n    var prefix = prefix!\n    let prefix2\
    \ = prefix.prefix(from: end)\n    guard prefix2 != nil else { return [] }\n  \
    \  return Array(repeating: prefix, count: prefix2.count - prefix.count)", '    return
    all_prefixes_sorted(string).reversed()', "    var prefixes = [String]()\n    for\
    \ ch in string {\n        prefixes = append(prefixes, prefix + ch)\n    }\n  \
    \  return prefixes", "    prefixes : Array = [string]\n    let prefixLength =\
    \ string.characters.count\n    for characters in string.characters.reverse() {\n\
    \        guard prefixes.contains(String(repeating: characters, count: prefixLength))\
    \ else {\n            prefixes.append(String(repeating: characters, count: prefixLength))\n\
    \        }\n    }\n    return prefixes", "    let prefixes = string.prefixes\n\
    \    var result = [String]()\n    for prefix in prefixes {\n        result.append(prefix[0..<string.count])\n\
    \    }\n    return result", '    return Array((string.prefixes ?? [])).sorted()',
  "    let start = string.startIndex\n    let end = string.endIndex\n    var prefixes\
    \ = Array<T>()\n    var i: Int\n    for i = start + 1; end > i; i = i + 1 {\n\
    \        prefixes.append(string[(i-1) as Int])\n    }\n    return prefixes", "\t\
    var result: [String] = []\n\tfor item in string.characters.reversed(){\n\t\tresult.append(String(item))\n\
    \t}\n\tresult.reverse()\n\treturn result", "    var prefix = \"\"\n    var arr\
    \ = [String]()\n    for str in string.characters {\n        for char in str.unicodeScalars\
    \ {\n            if char.isUpperCase {\n                prefix += char\n     \
    \           break\n            } else {\n                prefix += char.lowercaseValue\n\
    \                break\n            }\n        }\n        arr.append(prefix)\n\
    \        prefix = \"\"\n    }\n    return arr", "    let length: Int = string.count\n\
    \    if length == 0 {\n        return nil\n    }\n    var prefixes = Array(string.prefix(length))\n\
    \    return prefixes", "    var result: [String] = []\n    var currentPrefix:\
    \ String = \"\"\n    for c in string {\n        currentPrefix = currentPrefix\
    \ + String(c)\n        result.insert(currentPrefix, at: 0)\n    }\n    return\
    \ result", '    return Array(zip(string.prefix, string))', "    if string.prefixes\
    \ == nil {\n        var prefix = \"\"\n        for c in string.unicodeScalars\
    \ {\n            prefix += string[c]\n        }\n        prefix = prefix[prefixIndex(string):]\n\
    \        string.prefixes = &prefix\n    }\n    return *string.prefixes", "   \
    \ var prefixes = [String]()\n    var prefixStart = 0\n    var stringLength = string.characters.count\n\
    \    while prefixStart < stringLength {\n        prefixes += [string.substring(prefixStart,\
    \ min(prefixStart + maxPrefixLength, stringLength))]\n        prefixStart = prefixStart\
    \ + maxPrefixLength\n    }\n    return prefixes", "    var prefixes = [String]()\n\
    \    var prefix: String = \"\"\n    for ch in string.unicodeScalars.reverse()\
    \ {\n        if prefix == \"\" {\n            prefix = String(ch)\n        } else\
    \ {\n            prefix = prefix + String(ch)\n        }\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes.reverse()", "    let startIndex = string.index(string.startIndex,\
    \ offsetBy: 0)\n    let endIndex = string.index(startIndex, offsetBy: string.characters.count)\n\
    \    var prefixes = [String]()\n    while startIndex != endIndex {\n        prefixes.append(string[startIndex])\n\
    \        startIndex = string.index(startIndex, offsetBy: 1)\n    }\n    return\
    \ prefixes", "    var prefixes = [String]()\n\n    for _ in 0 ..< string.count\
    \ {\n        prefixes.append(string[0..<string.count])\n    }\n\n    return prefixes",
  "\tvar prefixes = [String]()\n\tfor _,character in string.enumerated() {\n\t\tprefixes.insert(String(character),\
    \ at: 0)\n\t}\n\treturn prefixes", "\tvar prefixes = [String]()\n\tprefix = longest(string)\n\
    \tif prefix == nil {\n\t\treturn prefixes\n\t}\n\tfor _, c := range prefix {\n\
    \t\tprefixes = append(prefixes, string[c...])\n\t}\n\treturn prefixes", "  var\
    \ prefixes = [String]()\n  var i: Int = 0\n  while i < string.count {\n    let\
    \ start = string.index(string.startIndex, offsetBy: i)\n    let end = string.index(start,\
    \ offsetBy: 1)\n    if end == nil {\n      prefixes.append(String(string.substring(from:\
    \ start)))\n      i += 1\n      continue\n    }\n    let prefix = String(string.substring(from:\
    \ start))\n    let suffix = String(string.substring(from: end!))\n    prefixes.append(prefix+suffix)\n\
    \    i += 1\n  }\n  return prefixes", "    guard string.hasPrefix(string[0]) else\
    \ { return [string] }\n    var prefixes = [String]()\n    for c in string.characters\
    \ {\n        for prefix in all_prefixes(string: String(string[string.index(before:\
    \ c)])) {\n            prefixes.append(prefix + String(string[c]))\n        }\n\
    \    }\n    return prefixes", "    let prefixes = string.prefixes(of: String(string))\n\
    \    return prefixes", "    let result = prefixes(string)\n    var strings = [string]\n\
    \    while !string.isEmpty {\n        strings.append(string)\n        if let index\
    \ = find(string) { strings.remove(at: index) } else { break }\n    }\n    return\
    \ strings", "    // prefix -> last index\n    var prefix: [Int: Int] = [:]\n \
    \   var current = 1\n    for i in string.characters.reversed().enumerated() {\n\
    \        if prefix[String(current)] != nil {\n            current = prefix[String(current)]!\
    \ + 1\n        } else {\n            prefix[String(current)] = i\n           \
    \ current = 1\n        }\n    }\n    var output: [String] = []\n    var prefixLen\
    \ = Int.max\n    for (key) in prefix {\n        let key = String(key)\n      \
    \  let len = prefix[key] - String(key).characters.first!\n        if len > prefixLen\
    \ {\n            prefixLen = len\n            output = key.characters.reversed()\n\
    \        }\n    }\n    return output", "    let length  = string.characters.count\n\
    \    var prefixes = [String]()\n    for i in 0...length {\n        prefixes.append(String(string.characters[i...i]))\n\
    \    }\n    return prefixes", "    var prefix = \"\"\n    var prefixes = [String]()\n\
    \    var i = 0\n    while i < string.count {\n        prefix = string.prefix(i)\n\
    \        if prefix == \"\" {\n            break\n        }\n        prefixes.append(prefix)\n\
    \        i += 1\n    }\n    return prefixes", "    var result: [String] = []\n\
    \    string.enumerateSubstrings(in: NSMakeRange(0, string.count)) { (substring,\
    \ substringRange, enclosingRange, stop) in\n        result.append(substring)\n\
    \    }\n    return result", "    let stringParts = string.characters.split{$0\
    \ == string[0]}\n    return stringParts.reversed().prefix(stringParts.count)",
  "    let maxLength = (string.characters.count - 1)\n    if maxLength == 0 {\n  \
    \      return [\"\"]\n    }\n    var prefixes = [String]()\n    for i in 0..<string.characters.count\
    \ {\n        if i == 0 {\n            prefixes.append(String(string.characters[i]))\n\
    \        } else {\n            prefixes.append(String(string.characters[i]) +\
    \ String(string.characters[i - 1]))\n        }\n    }\n    return prefixes", '  return
    prefixes(string, []())', "    var prefixes = [String]()\n    if let stringRange\
    \ = string.range(of: String(\"\")) {\n        for stringIdx in stringRange {\n\
    \            if stringIdx < string.endIndex {\n                prefixes.append(String(string.prefix(upTo:\
    \ stringIdx + 1)))\n            }\n        }\n    }\n    return prefixes", " \
    \   var result: [String] = []\n    for letter in string.characters {\n       \
    \ result.append(String(letter))\n    }\n    return result", "    var prefixes\
    \ = [String]()\n    if string == \"\" {\n        return prefixes\n    }\n    let\
    \ prefixLength = string.prefix(with: 0).count\n    prefixes.append(String(string.prefix(with:\
    \ prefixLength)))\n    return all_prefixes(string: string.dropFirst(prefixLength))",
  "    var result: [String] = []\n    var prefix = \"\"\n    for c in string {\n \
    \       if c == \"-\" {\n            for x in result {\n                prefix\
    \ += x\n            }\n            result = []\n        } else {\n           \
    \ prefix += c\n            result.append(prefix)\n        }\n    }\n    return\
    \ result", "    var result: [String] = []\n\n    for character in string.characters\
    \ {\n        if let index = string.index(of: character) {\n            if let\
    \ prefix = string.prefix(from: index).map(String.init) {\n                result.append(prefix)\n\
    \            }\n        }\n    }\n\n    return result", "    if let range = getAllPrefixesRange(string:\
    \ string) {\n        let prefix = getPrefix(string: string)\n        let suffixes\
    \ = getSuffix(string: string)\n        var prefixes = [String]()\n        for\
    \ character in range.toRange().lowerBound ..< range.toRange().upperBound {\n \
    \           prefixes.append(prefix + String(character))\n        }\n        return\
    \ prefixes.sorted()\n    }\n    return []", '    return Array(strings.AsciiRanges(string)).prefixes',
  "    var prefixes: [String] = []\n    string.characters.forEach { (ch) in\n    \
    \    prefixes.insert(String(ch), at: 0)\n    }\n    return prefixes.reversed()",
  "    var result: [String] = []\n    var currentPrefix: String = \"\"\n    for character\
    \ in string {\n        currentPrefix = currentPrefix + String(character)\n   \
    \     if string.range(of: currentPrefix, options: String.CompareOptions.literal,\
    \ range: nil, locale: nil) != nil {\n            result.append(currentPrefix)\n\
    \        }\n    }\n    return result", "    var prefixes = [String]()\n    for\
    \ s in string.characters.reversed() {\n        if !prefixes.contains(s) {\n  \
    \          prefixes.append(s)\n        }\n    }\n    return prefixes", "    let\
    \ len = string.characters.count\n    var result: [String] = []\n    for i in 0..<len\
    \ {\n        var prefix = string\n        let end = string.index(string.startIndex,\
    \ offsetBy: i)\n        prefix.remove(at: end.offset, length: 1)\n        result.append(prefix)\n\
    \    }\n    return result", "    var prefixes = [String]()\n    var maxLength\
    \ = 0\n    for (_, s) in string.enumerated() {\n        maxLength = max(maxLength,\
    \ s.count)\n        prefixes.append(String(s[0...maxLength]))\n    }\n    return\
    \ prefixes", '    return Array(string).prefixes', "    var result = [String]()\n\
    \    for s in string.characters {\n        for i : Int in stride(from: s.offset,\
    \ to: string.characters.count, by: -1) {\n            result.append(string.prefix(from:\
    \ i, length: 1))\n        }\n    }\n    return result", "\tvar prefixes = [String]()\n\
    \tvar i = string.count - 1\n\twhile i >= 0 {\n\t\tprefixes.append(string[i..<string.count])\n\
    \t\ti--\n\t}\n\treturn prefixes", "    if string.characters.count == 0 {\n   \
    \     return [] // for empty strings\n    }\n    var prefixes = [String]()\n \
    \   if let lastChar = string.characters.last {\n        prefixes.append(String(lastChar))\n\
    \    }\n    for firstChar in string.characters.dropLast() {\n        prefixes.append(String(firstChar))\n\
    \    }\n    return prefixes", "    var prefixes = Array<String>()\n    for character\
    \ in string {\n        prefixes.insert(character, for: character)\n    }\n   \
    \ return prefixes", '    return scan(string, []func(string) bool{len(string) <=
    0}, func(prefix string) bool { return strings.HasPrefix(string, prefix) })', " \
    \   var prefixes = [String]()\n    for letter in string.characters {\n       \
    \ if let index = string.firstIndex(of: String(letter)) {\n            prefixes.append(String(string.prefix(upTo:\
    \ index)))\n        }\n    }\n    return prefixes", "    var prefixes = [String]()\n\
    \    var currentChar = string[0]\n    var currentPos = 1\n    var i = 0\n    for\
    \ string in string.characters {\n        for _ in 0..<currentPos {\n         \
    \   currentChar += string[i]\n            i += 1\n        }\n        if currentChar\
    \ == string[i] {\n            currentPos += 1\n        } else {\n            prefixes.append(currentChar)\n\
    \            currentChar = string[i]\n            currentPos = 1\n        }\n\
    \    }\n    if currentPos != 1 {\n        prefixes.append(currentChar)\n    }\n\
    \    return prefixes", "    var result: [String] = []\n    var prefix: [String]\
    \ = []\n    for i in 0 ..< string.count {\n        if i == 0 || string.prefix(i\
    \ - 1).isEmpty {\n            result.append(prefix[0])\n            prefix = []\n\
    \        } else {\n            prefix.append(string.prefix(i - 1))\n        }\n\
    \    }\n    result.append(prefix[0])\n    return result", "    var prefixes =\
    \ [String]()\n    var shortest = string\n    var longest = string\n    for character\
    \ in string.characters {\n        shortest = longest\n        longest = character\n\
    \    }\n    for character in shortest.characters {\n        prefixes.append(character)\n\
    \    }\n    return prefixes", "    let prefix = Array(string.prefix(string.characters.count))\n\
    \    return prefix", '    return all_prefixes_helper(string, nil)', "    var prefixes\
    \ = [String]()\n    var current = String()\n    for c in string {\n        if\
    \ !c.isEmpty {\n            current = current + c\n        }\n        prefixes.append(current)\n\
    \        current = \"\"\n    }\n    return prefixes", "    let count = string.characters.count\n\
    \    let prefixes = [String]()\n    var currentPrefix: String = \"\"\n\n    for\
    \ i in 0..<count {\n        currentPrefix = String(string.characters[0..<i]) +\
    \ currentPrefix\n        prefixes.append(currentPrefix)\n    }\n    return prefixes",
  "    var prefixes: [String] = []\n    var lastLength = 0\n    for currentLength\
    \ in string.utf16.count {\n        if lastLength == 0 {\n            prefixes.append(String(string.utf16[currentLength...]))\n\
    \            lastLength = currentLength\n            continue\n        }\n   \
    \     if currentLength == lastLength {\n            prefixes.append(String(string.utf16[currentLength...]))\n\
    \            lastLength = currentLength\n        } else {\n            lastLength\
    \ = currentLength\n        }\n    }\n    return prefixes", "    var prefixes =\
    \ [String]()\n    var prefix: String = \"\"\n\n    for c in string.characters\
    \ {\n        if prefix != \"\" {\n            if c == prefix {\n             \
    \   prefixes.append(prefix)\n                prefix = \"\"\n            } else\
    \ {\n                prefixes.append(prefix)\n                prefix = \"\"\n\
    \            }\n        }\n        prefix += String(c)\n    }\n\n    prefixes.append(prefix)\n\
    \n    return prefixes", "    return strings.SplitN(string,\n                 \
    \        maxSplit: 1).toList()", "    var prefixes = [String]()\n    for c in\
    \ string {\n        if !contains(prefixes, c) { prefixes.append(c) }\n    }\n\
    \    return prefixes", "    var prefix = []\n    for letter in string {\n    \
    \    prefix += prefixOfString(letter)\n    }\n    return prefix", "    var allPrefixes:\
    \ [String] = []\n    for index in range(string.count) {\n        let prefix =\
    \ string[index..<string.count]\n        allPrefixes.append(prefix)\n    }\n  \
    \  return allPrefixes", "    var result = Array(string.utf16)\n    var length\
    \ = 0\n    for element in result {\n        length += 1\n        if element ==\
    \ 0 {\n            result.remove(at: 0)\n        }\n    }\n    guard length >\
    \ 0 else {\n        return result\n    }\n    var prefix = String()\n    while\
    \ length > 0 {\n        let index = result.index(of: 0)\n        if index == -1\
    \ { break }\n        prefix = String(result[index..<result.index(before: index)])\n\
    \        result.remove(at: index)\n        length += 1\n    }\n    return result",
  '    return reduce(into: []) { $0 += String($1) }', "    if let prefixes = string.prefixes\
    \ {\n        return prefixes.map { String($0) }\n    }\n    return []", "    var\
    \ result: [String] = []\n    for c in string.characters{\n        if !result.contains(where:\
    \ {$0 === String(format: \"%@%@\", c, \"\")}) {\n            result.append(String(format:\
    \ \"%@%@\", c, \"\"))\n        }\n    }\n    return result", '    return all_suffixes(string).reverse()',
  "    var allPrefixes = [String]()\n    for character in string {\n        allPrefixes.append(String(character))\n\
    \    }\n    return allPrefixes", "    var prefixes = [String]()\n    for _ in\
    \ 0..<string.count {\n        prefixes.append(string.prefix(string.startIndex))\n\
    \    }\n    return prefixes", "    var prefixes: [String] = []\n    var currentPrefix:\
    \ String = \"\"\n\n    for character in string {\n        currentPrefix = currentPrefix\
    \ + character\n\n        if let index = find(prefixes, currentPrefix) {\n    \
    \        prefixes[index] = currentPrefix\n        } else {\n            prefixes.append(currentPrefix)\n\
    \        }\n    }\n\n    return prefixes", "    let arr = string.characters.map\
    \ { String($0) }\n    var result = [String]()\n    var prefix = String()\n   \
    \ for char in arr {\n        if char.count < prefix.count {\n            prefix\
    \ = String(char)\n        }\n        if char.count == prefix.count {\n       \
    \     result.append(prefix)\n        }\n    }\n    return result", "    var result:\
    \ [String] = []\n    var currentIndex = 0\n\n    while currentIndex < string.count\
    \ {\n        result.append(string.prefix(currentIndex))\n        currentIndex\
    \ = string.index(string.startIndex, offsetBy: currentIndex + 1)\n    }\n\n   \
    \ return result", "    var prefixes = [String]()\n    var prefix = \"\"\n    for\
    \ c in string.unicodeScalars {\n        prefix += String(describing: c)\n    \
    \    prefixes.append(prefix)\n        prefix = \"\"\n    }\n    return prefixes",
  "    var prefixes = [String]()\n    var length = 0\n    for ch in string {\n   \
    \     prefix := string([]rune(ch)[0:length])\n        prefixes.append(prefix)\n\
    \        length = length + prefixes.count\n    }\n    return prefixes", "\tprefix\
    \ := [String]()\n\t\n\tfor i := 0; i < len(string); i++ {\n\t\tif len(prefix)\
    \ == 0 || prefix[len(prefix)-1] < string[i] {\n\t\t\tprefix = append(prefix, string[i])\n\
    \t\t}\n\t}\n\treturn prefix", "\tvar prefixes = [String]()\n\tvar shortestLength\
    \ = min(len(string), 3)\n\n\tprefixes.appendContentsOf(prefix(string: string,\
    \ shortestLength: shortestLength))\n\n\tprefixes.removeAll(where: { (string) ->\
    \ Bool in\n\t\treturn string == \"\"\n\t})\n\n\treturn prefixes", "\tvar prefix\
    \ = \"\"\n\tvar longest = string\n\tvar shortest = string\n\tfor len(longest)\
    \ > 0 && len(shortest) > 0 {\n\t\tif longest[len(longest) - 1] == ' ' && shortest[0]\
    \ != '\\0' {\n\t\t\tprefix = longest[0:len(longest) - 1]\n\t\t\tlongest = longest[1\
    \ : len(longest)]\n\t\t\tshortest = shortest[1 : len(shortest)]\n\t\t} else {\n\
    \t\t\tbreak\n\t\t}\n\t}\n\treturn [prefix] + all_prefixes(string)", "\tvar prefixes:\
    \ [String] = []\n\t\n\tlet input_length = string.characters.count\n\t\n\tvar start\
    \ = string.startIndex\n\t\n\tfor prefix in prefixes {\n\t\tif start.isGreaterThan(input_length)\
    \ && start.isLessThan(input_length + 1) {\n\t\t\tbreak\n\t\t} else {\n\t\t\tprefixes.insert(string.substring(from:\
    \ start), at: prefixes.count)\n\t\t\tstart += 1\n\t\t}\n\t}\n\t\n\treturn prefixes",
  "    var prefixes = [String]()\n    var prefix = String()\n\n    for ch in string\
    \ {\n        prefix += ch\n        prefixes.append(prefix)\n    }\n\n    return\
    \ prefixes", "\tlet maxSize = min(string.count, 32)\n\tvar results = [String]()\n\
    \n\tvar prefix: String = \"\"\n\tfor _ in 0..<maxSize {\n\t\tprefix += string[0]\n\
    \t\tstring.removeAtIndex(string.startIndex)\n\t\tif string.count <= 0 {\n\t\t\t\
    break\n\t\t}\n\t}\n\n\tresults.append(prefix)\n\n\treturn results", "    if let\
    \ ranges = string.unicodeScalars.map {\n        return (0..<ranges.count).map\
    \ { String(string[ranges[$0]...], radix: 16) }\n    }.flatMap({ $0 }), let prefix\
    \ = string.unicodeScalars.first?.value {\n        return prefix <= 0xFFFF ? ranges.map\
    \ { String(string[ranges[$0]...], radix: 16) } + [prefix] : ranges.map { String(string[ranges[$0]...],\
    \ radix: 16) }\n    } else {\n        return []\n    }", '    return prefixes(string,
    1)', '    return prefixes(string, 1)', "    if string == \"\" {\n        return\
    \ []\n    }\n    var prefixes = [String]()\n    var candidate = string\n    for\
    \ _ in 0..<string.characters.count {\n        candidate = candidate.dropFirst()\n\
    \        if string.starts(candidate) {\n            prefixes.append(candidate)\n\
    \        }\n    }\n    return prefixes", "    var prefixes = [String]()\n    for\
    \ c in string {\n        prefixes.append(string[0 ..< string.firstIndex.advanced(by:\
    \ Int(c))])\n    }\n    return prefixes", "\tlet prefixes: [String] = []\n\tlet\
    \ stringLength = string.characters.count\n\tvar currentPrefixIndex = stringLength\
    \ - 1\n\tfor _ in 0 ..< stringLength {\n\t\tif currentPrefixIndex == -1 {\n\t\t\
    \tbreak\n\t\t}\n\t\tprefixes.append(string.substring(from: currentPrefixIndex))\n\
    \t\tcurrentPrefixIndex -= 1\n\t}\n\treturn prefixes", "    let prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = String(string.dropLast())\n    }\n    return prefixes", " \
    \   \n    let shortest = string.prefix(0)\n    let longest = string.prefix(string.characters.count\
    \ - 1)\n    \n    return shortest.prefix(longest.characters.count - 1) // longest\
    \ is prefix of shortest", "    if string.count < 2 {\n        return [string]\n\
    \    }\n    var results = [String]()\n    var strings = [String]()\n    for c\
    \ in string.characters {\n        if strings.count == 0 {\n            strings.append(c._cfstring)\n\
    \        } else {\n            if strings.last!.hasPrefix(c._cfstring) {\n   \
    \             results.append(strings.last!)\n                strings.append(c._cfstring)\n\
    \            }\n        }\n    }\n    results.append(strings.last!)\n    return\
    \ results", "    var arr = [String]()\n    for c in string.characters.reverse()\
    \ {\n        for s in arr.suffix(string.characters.count - 1) {\n            if\
    \ s.characters.count <= c {\n                break\n            }\n          \
    \  arr.append(String(Array[c..<s]))\n        }\n    }\n    return arr.reverse()",
  "    if let _ = string.characters.first {\n        return []\n    }\n    var prefixes:\
    \ [String] = []\n    var index = string.startIndex\n    while index < string.endIndex\
    \ {\n        prefixes.append(String(string.characters[index]))\n        index\
    \ = string.index(after: index)\n    }\n    return prefixes", "    array = Array(string.characters)\n\
    \    start = index(array, char: \"a\")\n    end = index(array, char: \"z\")\n\
    \    prefix = [String]()\n    for i = start ... end {\n        prefix.append(String(array[i]))\n\
    \    }\n    return prefix", '    return all_prefixes_with_sentinel(string: string,
    sentinel: String())', "    if string.isEmpty {\n        return []\n    }\n   \
    \ let prefixes = (0..<string.count).map {\n        return string.substringToIndex($0)\n\
    \    }\n    return prefixes", "\tvar prefixes = [String]()\n\tlet firstChar =\
    \ string[0]\n\tvar prefixLength = 1\n\t\n\t// find first and second character\n\
    \tif firstChar == \"_\" {\n\t\tprefixLength = 0\n\t} else {\n\t\tif firstChar\
    \ == string.first {\n\t\t\tfor c in string.dropFirst() {\n\t\t\t\tif c.isLower\
    \ {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tprefixLength += 1\n\t\t\t}\n\t\t}\n\t\
    }\n\t\n\t\n\tfor c in string.dropFirst() {\n\t\tprefixes.append(String(repeating:\
    \ \"_\", count: prefixLength))\n\t\tprefixes[prefixes.count-1] += c\n\t}\n\treturn\
    \ prefixes", '    return prefixes(string, nil)', "    var output: [String] = []\n\
    \    if string == \"\" {\n        return output\n    }\n    for i in 0..<string.count\
    \ {\n        var j = i - 1\n        let prefix = string[j..<i]\n        if prefix\
    \ != \"\" {\n            output.append(prefix)\n        }\n    }\n    return output",
  "    let index = string.characters.reduce(0, { (sum, char) -> Int in\n        if\
    \ char != \"a\" {\n            return sum\n        }\n        return sum + 1\n\
    \    })\n    return Array(string.characters.prefix(index...)).map(String.init)"]
stop_tokens:
- "\n}"
