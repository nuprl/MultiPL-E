language: swift
name: HumanEval_29_filter_by_prefix
results:
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  let prefix_len = prefix.count\n \
    \ let prefixes_set = Set<String>(strings)\n  return prefixes_set.filter({ $0.hasPrefix(prefix)\
    \ }).map({ $0.substring(from: prefix_len) })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy_h0xlc0.swift:10:65: error: value of type 'String' has no member\
    \ 'substring'\n  return prefixes_set.filter({ $0.hasPrefix(prefix) }).map({ $0.substring(from:\
    \ prefix_len) })\n                                                           \
    \  ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar filtered [String]\n\tprefix =\
    \ prefix.lowercased()\n\tfor string in strings {\n\t\tif !string.hasPrefix(prefix)\
    \ {\n\t\t\tfiltered = append(filtered, string)\n\t\t} else {\n\t\t\tfiltered =\
    \ append(filtered, \"\")\n\t\t}\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9ry7iqsu.swift:8:14: error: consecutive statements on a line must\
    \ be separated by ';'\n        var filtered [String]\n                    ^\n\
    \                    ;\n/tmp/tmp9ry7iqsu.swift:8:6: error: type annotation missing\
    \ in pattern\n        var filtered [String]\n            ^\n/tmp/tmp9ry7iqsu.swift:8:15:\
    \ error: expected member name or constructor call after type name\n        var\
    \ filtered [String]\n                     ^\n/tmp/tmp9ry7iqsu.swift:8:22: note:\
    \ add arguments after the type to construct a value of the type\n        var filtered\
    \ [String]\n                            ^\n                             ()\n/tmp/tmp9ry7iqsu.swift:8:22:\
    \ note: use '.self' to reference the type object\n        var filtered [String]\n\
    \                            ^\n                             .self\n/tmp/tmp9ry7iqsu.swift:8:15:\
    \ warning: expression of type '[String].Type' is unused\n        var filtered\
    \ [String]\n                     ^~~~~~~~\n/tmp/tmp9ry7iqsu.swift:9:2: error:\
    \ cannot assign to value: 'prefix' is a 'let' constant\n        prefix = prefix.lowercased()\n\
    \        ^~~~~~\n/tmp/tmp9ry7iqsu.swift:12:15: error: cannot find 'append' in\
    \ scope\n                        filtered = append(filtered, string)\n       \
    \                            ^~~~~~\n/tmp/tmp9ry7iqsu.swift:14:15: error: cannot\
    \ find 'append' in scope\n                        filtered = append(filtered,\
    \ \"\")\n                                   ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    guard strings.count > 0, prefix.count\
    \ > 0 else { return strings }\n    let startIndex = strings.prefixIndex(of: prefix)\n\
    \    return startIndex == NSNotFound ? strings : strings.dropFirst(startIndex.successor())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpu9nb021g.swift:9:30: error: value of type '[String]' has no member\
    \ 'prefixIndex'\n    let startIndex = strings.prefixIndex(of: prefix)\n      \
    \               ~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpu9nb021g.swift:10:26: error: cannot\
    \ find 'NSNotFound' in scope\n    return startIndex == NSNotFound ? strings :\
    \ strings.dropFirst(startIndex.successor())\n                         ^~~~~~~~~~\n\
    /tmp/tmpu9nb021g.swift:10:37: error: cannot convert return expression of type\
    \ 'ArraySlice<String>' to return type '[String]'\n    return startIndex == NSNotFound\
    \ ? strings : strings.dropFirst(startIndex.successor())\n           ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for s in strings {\n        if s.startsWith(prefix) {\n            filtered.append(s)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7rzwvqak.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet prefixIndex = strings.firstIndex(where:\
    \ { $0.hasPrefix(prefix) })\n\tif prefixIndex == -1 {\n\t\treturn strings\n\t\
    }\n\treturn strings.prefix(prefixIndex)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsr_dncip.swift:12:24: error: value of optional type 'Array<String>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<String>.Index'\
    \ (aka 'Int')\n        return strings.prefix(prefixIndex)\n                  \
    \            ^\n/tmp/tmpsr_dncip.swift:12:24: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        return strings.prefix(prefixIndex)\n\
    \                              ^\n                                          ??\
    \ <#default value#>\n/tmp/tmpsr_dncip.swift:12:24: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        return strings.prefix(prefixIndex)\n\
    \                              ^\n                                         !\n\
    /tmp/tmpsr_dncip.swift:12:17: error: no 'prefix' candidates produce the expected\
    \ contextual result type '[String]'\n        return strings.prefix(prefixIndex)\n\
    \                       ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<[String]>',\
    \ not the expected contextual result type '[String]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'ArraySlice<String>',\
    \ not the expected contextual result type '[String]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  return filter_by_prefix_impl(strings:\
    \ strings, prefix: prefix)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmphbqo1k09.swift:8:10: error: cannot find 'filter_by_prefix_impl'\
    \ in scope\n  return filter_by_prefix_impl(strings: strings, prefix: prefix)\n\
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  return filter(strings: strings, pred:\
    \ has_prefix(prefix))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnvrcip7_.swift:8:10: error: cannot find 'filter' in scope\n  return\
    \ filter(strings: strings, pred: has_prefix(prefix))\n         ^~~~~~\n/tmp/tmpnvrcip7_.swift:8:41:\
    \ error: cannot find 'has_prefix' in scope\n  return filter(strings: strings,\
    \ pred: has_prefix(prefix))\n                                        ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    guard prefix != \"\" else {\n \
    \       return strings\n    }\n    return strings.filter({ (string) -> Bool in\n\
    \        return string.hasPrefix(prefix)\n    })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var result = [String]()\n    for\
    \ s in strings {\n        if s.startsWith(prefix) {\n            result.append(s)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpavf6snlc.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var results = [String]()\n    for\
    \ s in strings {\n        if s.hasPrefix(prefix) {\n            results.append(s)\n\
    \        }\n    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if prefix != \"\" && strings.Length\
    \ > 0 && strings.ToLower()[0] == prefix {\n        return strings.Slice(1, strings.Length)\n\
    \    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfc_gwcax.swift:8:32: error: value of type '[String]' has no member\
    \ 'Length'\n    if prefix != \"\" && strings.Length > 0 && strings.ToLower()[0]\
    \ == prefix {\n                       ~~~~~~~ ^~~~~~\n/tmp/tmpfc_gwcax.swift:8:54:\
    \ error: value of type '[String]' has no member 'ToLower'\n    if prefix != \"\
    \" && strings.Length > 0 && strings.ToLower()[0] == prefix {\n               \
    \                              ~~~~~~~ ^~~~~~~\n/tmp/tmpfc_gwcax.swift:9:24: error:\
    \ value of type '[String]' has no member 'Slice'\n        return strings.Slice(1,\
    \ strings.Length)\n               ~~~~~~~ ^~~~~\n/tmp/tmpfc_gwcax.swift:9:41:\
    \ error: value of type '[String]' has no member 'Length'\n        return strings.Slice(1,\
    \ strings.Length)\n                                ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    guard strings.count > 0 else {\
    \ return strings }\n\n    var filtered = Set<String>()\n    for s in strings {\n\
    \        let start = s.startIndex\n        let end = s.endIndex\n        if !s.hasPrefix(prefix)\
    \ {\n            filtered.remove(s)\n        } else {\n            let range =\
    \ Range<String.Index>(start: start, end: end)\n            filtered.insert(s[range])\n\
    \        }\n    }\n\n    return Array(filtered)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpij23pg6w.swift:17:25: error: referencing initializer 'init(_:)'\
    \ on 'Range' requires that 'String.Index' conform to 'Strideable'\n          \
    \  let range = Range<String.Index>(start: start, end: end)\n                 \
    \       ^\nSwift.Range:1:11: note: where 'Bound' = 'String.Index'\nextension Range\
    \ where Bound : Strideable, Bound.Stride : SignedInteger {\n          ^\n/tmp/tmpij23pg6w.swift:17:64:\
    \ error: extra argument 'end' in call\n            let range = Range<String.Index>(start:\
    \ start, end: end)\n                                           ~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmpij23pg6w.swift:17:52: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'ClosedRange<String.Index>'\n            let range\
    \ = Range<String.Index>(start: start, end: end)\n                            \
    \                       ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix_mut(strings,\
    \ prefix)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpljr5huj7.swift:8:12: error: cannot find 'filter_by_prefix_mut'\
    \ in scope\n    return filter_by_prefix_mut(strings, prefix)\n           ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif prefix != \"\" && len(strings)\
    \ == 0 {\n\t\treturn []\n\t}\n\treturn strings.filter({ $0.hasPrefix(prefix) })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp4mf1o03.swift:8:21: error: cannot find 'len' in scope\n      \
    \  if prefix != \"\" && len(strings) == 0 {\n                           ^~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  strings.filter(\n    func(elt element)\
    \ bool {\n      if elt.startsWith(prefix) {\n        return true\n      }\n  \
    \    return false\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7nzujel5.swift:9:5: error: expected expression in list of expressions\n\
    \    func(elt element) bool {\n    ^\n/tmp/tmp7nzujel5.swift:9:9: error: expected\
    \ identifier in function declaration\n    func(elt element) bool {\n        ^\n\
    /tmp/tmp7nzujel5.swift:8:17: error: missing argument for parameter #1 in call\n\
    \  strings.filter(\n                ^\n                <#(String) throws -> Bool#>\n\
    Swift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable\
    \ public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool)\
    \ rethrows -> Self\n                                       ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if strings.HasPrefix(s, prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpasrm241_.swift:10:20: error: value of type '[String]' has no member\
    \ 'HasPrefix'\n        if strings.HasPrefix(s, prefix) {\n           ~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpasrm241_.swift:11:24: error: cannot find 'append' in scope\n         \
    \   filtered = append(filtered, s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar filtered = [String]()\n\tstrings.ForEach(func(value\
    \ String) {\n\t\tif value.hasPrefix(prefix) {\n\t\t\tfiltered = append(filtered,\
    \ value)\n\t\t}\n\t})\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwrt477tk.swift:9:18: error: expected expression in list of expressions\n\
    \        strings.ForEach(func(value String) {\n                        ^\n/tmp/tmpwrt477tk.swift:9:22:\
    \ error: expected identifier in function declaration\n        strings.ForEach(func(value\
    \ String) {\n                            ^\n/tmp/tmpwrt477tk.swift:9:10: error:\
    \ value of type '[String]' has no member 'ForEach'\n        strings.ForEach(func(value\
    \ String) {\n        ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    strings.filter {\n        $0.hasPrefix(prefix)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    guard strings.count > 0 else {\
    \ return strings }\n    var result = [String]()\n    for string in strings {\n\
    \        if string.hasPrefix(prefix) {\n            result.append(string)\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true, \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpodvqga5h.swift:8:28: error: extra arguments at positions #3, #4\
    \ in call\n    return filter_by_prefix(strings, prefix, true, \"\")\n        \
    \                   ^\n/tmp/tmpodvqga5h.swift:7:6: note: 'filter_by_prefix(strings:prefix:)'\
    \ declared here\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String]\
    \ {\n     ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for str in strings { // strings are mutable\n        if str.startsWith(prefix)\
    \ {\n            filtered.append(str)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxk_2p62q.swift:10:16: error: value of type 'String' has no member\
    \ 'startsWith'\n        if str.startsWith(prefix) {\n           ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if prefix == \"\" {\n        return\
    \ strings\n    }\n\n    var filtered = [String]()\n    for string in strings {\n\
    \        if string.hasPrefix(prefix) {\n            filtered = append(filtered,\
    \ string)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6852skws.swift:15:24: error: cannot find 'append' in scope\n  \
    \          filtered = append(filtered, string)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() || strings.IsNullOrEmpty(prefix)\
    \ {\n        return strings\n    }\n\n    // We do not want empty strings at the\
    \ beginning.\n    if strings.FirstOrDefault() != \"\" && strings.FirstOrDefault().startsWith(prefix)\
    \ {\n        strings.removeFirst()\n    }\n\n    return strings\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgox6l6qd.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() || strings.IsNullOrEmpty(prefix) {\n   \
    \    ~~~~~~~ ^~~~~~~\n/tmp/tmpgox6l6qd.swift:8:37: error: value of type '[String]'\
    \ has no member 'IsNullOrEmpty'\n    if strings.IsEmpty() || strings.IsNullOrEmpty(prefix)\
    \ {\n                            ~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpgox6l6qd.swift:13:16:\
    \ error: value of type '[String]' has no member 'FirstOrDefault'\n    if strings.FirstOrDefault()\
    \ != \"\" && strings.FirstOrDefault().startsWith(prefix) {\n       ~~~~~~~ ^~~~~~~~~~~~~~\n\
    /tmp/tmpgox6l6qd.swift:13:50: error: value of type '[String]' has no member 'FirstOrDefault'\n\
    \    if strings.FirstOrDefault() != \"\" && strings.FirstOrDefault().startsWith(prefix)\
    \ {\n                                         ~~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpgox6l6qd.swift:14:17:\
    \ error: cannot use mutating member on immutable value: 'strings' is a 'let' constant\n\
    \        strings.removeFirst()\n        ~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt_150dr0.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, false)\n                           ~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for str in strings {\n        if str.hasPrefix(prefix) {\n            filtered\
    \ = append(filtered, str)\n        }\n    }\n    return filtered\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmps95h1_kt.swift:11:24: error: cannot find 'append' in scope\n  \
    \          filtered = append(filtered, str)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter { ($0.hasPrefix(prefix))\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.isEmpty() {\n      \
    \  return strings\n    }\n    let startIndex = strings.firstIndex(of: prefix)\n\
    \    return strings.filter() {\n        guard $0.hasPrefix(prefix) else {\n  \
    \          return false\n        }\n        return startIndex != nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp051mk5ei.swift:8:16: error: cannot call value of non-function type\
    \ 'Bool'\n    if strings.isEmpty() {\n               ^      ~~\n             \
    \         \n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif !strings.HasPrefix(strings[0],\
    \ prefix) {\n\t\treturn []\n\t}\n\n\tvar res [String]\n\tfor _, s := range strings\
    \ {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\tres = append(res, s)\n\t\t}\n\
    \t}\n\n\treturn res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpromgu1v5.swift:12:9: error: consecutive statements on a line must\
    \ be separated by ';'\n        var res [String]\n               ^\n          \
    \     ;\n/tmp/tmpromgu1v5.swift:13:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmpromgu1v5.swift:13:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n/tmp/tmpromgu1v5.swift:8:14: error: value of type\
    \ '[String]' has no member 'HasPrefix'\n        if !strings.HasPrefix(strings[0],\
    \ prefix) {\n            ~~~~~~~ ^~~~~~~~~\n/tmp/tmpromgu1v5.swift:12:6: error:\
    \ type annotation missing in pattern\n        var res [String]\n            ^\n\
    /tmp/tmpromgu1v5.swift:12:10: error: expected member name or constructor call\
    \ after type name\n        var res [String]\n                ^\n/tmp/tmpromgu1v5.swift:12:17:\
    \ note: add arguments after the type to construct a value of the type\n      \
    \  var res [String]\n                       ^\n                        ()\n/tmp/tmpromgu1v5.swift:12:17:\
    \ note: use '.self' to reference the type object\n        var res [String]\n \
    \                      ^\n                        .self\n/tmp/tmpromgu1v5.swift:12:10:\
    \ warning: expression of type '[String].Type' is unused\n        var res [String]\n\
    \                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter(strings, prefixLength:\
    \ prefix.utf16.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpah47xcb_.swift:8:12: error: cannot find 'filter' in scope\n   \
    \ return filter(strings, prefixLength: prefix.utf16.count)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpctkibwb5.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif !strings.HasPrefix(strings[0],\
    \ prefix) {\n\t\treturn strings\n\t}\n\t\n\treturn strings.SplitN(strings[0],\
    \ prefix, func(i, d []rune) []rune {\n\t\tif i >= len(strings) {\n\t\t\treturn\
    \ nil\n\t\t}\n\t\t\n\t\treturn strings[i+1:] // everything after prefix is now\
    \ the prefix\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn45u3urz.swift:12:44: error: expected expression in list of expressions\n\
    \        return strings.SplitN(strings[0], prefix, func(i, d []rune) []rune {\n\
    \                                                  ^\n/tmp/tmpn45u3urz.swift:12:48:\
    \ error: expected identifier in function declaration\n        return strings.SplitN(strings[0],\
    \ prefix, func(i, d []rune) []rune {\n                                       \
    \               ^\n/tmp/tmpn45u3urz.swift:8:14: error: value of type '[String]'\
    \ has no member 'HasPrefix'\n        if !strings.HasPrefix(strings[0], prefix)\
    \ {\n            ~~~~~~~ ^~~~~~~~~\n/tmp/tmpn45u3urz.swift:12:17: error: value\
    \ of type '[String]' has no member 'SplitN'\n        return strings.SplitN(strings[0],\
    \ prefix, func(i, d []rune) []rune {\n               ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  return filter_by_prefix_impl(strings,\
    \ prefix, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpeyxe77tg.swift:8:10: error: cannot find 'filter_by_prefix_impl'\
    \ in scope\n  return filter_by_prefix_impl(strings, prefix, false)\n         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    // If this array is empty, just\
    \ return the same array we started with.\n    // This will be a common case for\
    \ anyone using filter_by_prefix.\n    if strings.isEmpty() {\n        return strings\n\
    \    }\n\n    var stringIndex = 0\n    for index in 0..<strings.count {\n    \
    \    if strings.indexAt(stringIndex, index) == index {\n            if strings[stringIndex].startsWith(prefix)\
    \ {\n                stringIndex = strings.indexAfterString(strings[stringIndex],\
    \ prefix)\n            } else {\n                stringIndex = strings.indexAfter(strings[stringIndex],\
    \ index)\n            }\n        } else {\n            stringIndex = index\n \
    \       }\n    }\n\n    return strings.drop(stringIndex)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpa490g6zt.swift:10:16: error: cannot call value of non-function\
    \ type 'Bool'\n    if strings.isEmpty() {\n               ^      ~~\n        \
    \              \n/tmp/tmpa490g6zt.swift:16:20: error: value of type '[String]'\
    \ has no member 'indexAt'\n        if strings.indexAt(stringIndex, index) == index\
    \ {\n           ~~~~~~~ ^~~~~~~\n/tmp/tmpa490g6zt.swift:17:37: error: value of\
    \ type 'String' has no member 'startsWith'\n            if strings[stringIndex].startsWith(prefix)\
    \ {\n               ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpa490g6zt.swift:18:39:\
    \ error: value of type '[String]' has no member 'indexAfterString'\n         \
    \       stringIndex = strings.indexAfterString(strings[stringIndex], prefix)\n\
    \                              ~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpa490g6zt.swift:20:39:\
    \ error: value of type '[String]' has no member 'indexAfter'\n               \
    \ stringIndex = strings.indexAfter(strings[stringIndex], index)\n            \
    \                  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpa490g6zt.swift:27:20: error: no\
    \ exact matches in call to instance method 'drop'\n    return strings.drop(stringIndex)\n\
    \                   ^\n/tmp/tmpa490g6zt.swift:27:20: note: found candidate with\
    \ type '((String) throws -> Bool) throws -> DropWhileSequence<[String]>'\n   \
    \ return strings.drop(stringIndex)\n                   ^\n/tmp/tmpa490g6zt.swift:27:20:\
    \ note: found candidate with type '((String) throws -> Bool) throws -> ArraySlice<String>'\n\
    \    return strings.drop(stringIndex)\n                   ^\n/tmp/tmpa490g6zt.swift:27:20:\
    \ error: no 'drop' candidates produce the expected contextual result type '[String]'\n\
    \    return strings.drop(stringIndex)\n                   ^\nSwift.Sequence:6:40:\
    \ note: 'drop(while:)' produces 'DropWhileSequence<[String]>', not the expected\
    \ contextual result type '[String]'\n    @inlinable public __consuming func drop(while\
    \ predicate: (Self.Element) throws -> Bool) rethrows -> DropWhileSequence<Self>\n\
    \                                       ^\nSwift.Collection:5:40: note: 'drop(while:)'\
    \ produces 'ArraySlice<String>', not the expected con"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let prefixLength = prefix.count\n\
    \n    return strings.filter({ s -> Bool in\n        let prefixIndex = s.startIndex\n\
    \        return prefixIndex < prefixLength && s[prefixIndex] == prefix\n    })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp50wh3mmo.swift:12:28: error: referencing operator function '<'\
    \ on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \        return prefixIndex < prefixLength && s[prefixIndex] == prefix\n     \
    \                      ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\n\
    extension BinaryInteger {\n          ^\n/tmp/tmp50wh3mmo.swift:12:47: error: subscript\
    \ 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n\
    \        return prefixIndex < prefixLength && s[prefixIndex] == prefix\n     \
    \                                         ^\nSwift.Collection:2:23: note: where\
    \ 'R' = 'String.Index'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter{ $0.hasPrefix(prefix)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978900
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var result = [String]()\n    for\
    \ s in strings {\n        if s.hasPrefix(prefix) {\n            result.append(s)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if let prefix_index = strings.firstIndex(of:\
    \ prefix) {\n        return strings.filter { ($0.index > prefix_index) && ($0.index\
    \ < prefix.count) }\n    } else {\n        return strings\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8q5il6sw.swift:9:24: error: type of expression is ambiguous without\
    \ more context\n        return strings.filter { ($0.index > prefix_index) && ($0.index\
    \ < prefix.count) }\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar filtered []string\n\tfor _, s\
    \ := range strings {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\tfiltered =\
    \ append(filtered, s)\n\t\t}\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_jnjvt67.swift:8:14: error: consecutive statements on a line must\
    \ be separated by ';'\n        var filtered []string\n                    ^\n\
    \                    ;\n/tmp/tmp_jnjvt67.swift:8:17: error: consecutive statements\
    \ on a line must be separated by ';'\n        var filtered []string\n        \
    \               ^\n                       ;\n/tmp/tmp_jnjvt67.swift:9:7: error:\
    \ expected 'in' after for-each pattern\n        for _, s := range strings {\n\
    \             ^\n/tmp/tmp_jnjvt67.swift:9:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, s := range strings {\n             ^\n/tmp/tmp_jnjvt67.swift:8:6:\
    \ error: type annotation missing in pattern\n        var filtered []string\n \
    \           ^\n/tmp/tmp_jnjvt67.swift:8:15: error: empty collection literal requires\
    \ an explicit type\n        var filtered []string\n                     ^~\n/tmp/tmp_jnjvt67.swift:8:15:\
    \ warning: expression of type '[Any]' is unused\n        var filtered []string\n\
    \                     ^~\n/tmp/tmp_jnjvt67.swift:8:17: error: cannot find 'string'\
    \ in scope\n        var filtered []string\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tresult := []String{}\n\tfor _, string\
    \ := range strings {\n\t\tif strings.HasPrefix(string, prefix) {\n\t\t\tresult\
    \ = append(result, string)\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9m5wx74d.swift:8:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result := []String{}\n              ^\n       \
    \       ;\n/tmp/tmp9m5wx74d.swift:8:9: error: expected expression\n        result\
    \ := []String{}\n               ^\n/tmp/tmp9m5wx74d.swift:9:7: error: expected\
    \ 'in' after for-each pattern\n        for _, string := range strings {\n    \
    \         ^\n/tmp/tmp9m5wx74d.swift:9:7: error: expected Sequence expression for\
    \ for-each loop\n        for _, string := range strings {\n             ^\n/tmp/tmp9m5wx74d.swift:8:2:\
    \ error: cannot find 'result' in scope\n        result := []String{}\n       \
    \ ^~~~~~\n/tmp/tmp9m5wx74d.swift:14:9: error: cannot find 'result' in scope\n\
    \        return result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix_helper(strings,\
    \ prefix, true, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwemxueh0.swift:8:9: error: cannot find 'filter_by_prefix_helper'\
    \ in scope\n        return filter_by_prefix_helper(strings, prefix, true, 0)\n\
    \               ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    guard let prefix = prefix.lowercased(),\n\
    \        let suffixes = strings.map{$0.lowercased()}\n            .filter{$0.hasPrefix(prefix)}\n\
    \            .map{$0.prefix(prefix)}\n            else { return strings }\n\n\
    \    return suffixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoq4ubkce.swift:9:35: error: expected 'else' after 'guard' condition\n\
    \        let suffixes = strings.map{$0.lowercased()}\n                       \
    \           ^\n                                  else \n/tmp/tmpoq4ubkce.swift:9:36:\
    \ error: anonymous closure argument not contained in a closure\n        let suffixes\
    \ = strings.map{$0.lowercased()}\n                                   ^\n/tmp/tmpoq4ubkce.swift:12:13:\
    \ error: expected expression\n            else { return strings }\n          \
    \  ^\n/tmp/tmpoq4ubkce.swift:9:24: error: generic parameter 'T' could not be inferred\n\
    \        let suffixes = strings.map{$0.lowercased()}\n                       ^\n\
    Swift.Collection:2:28: note: in call to function 'map'\n    @inlinable public\
    \ func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]\n     \
    \                      ^\n/tmp/tmpoq4ubkce.swift:8:11: error: initializer for\
    \ conditional binding must have Optional type, not 'String'\n    guard let prefix\
    \ = prefix.lowercased(),\n          ^            ~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoq4ubkce.swift:10:14:\
    \ error: cannot infer contextual base in reference to member 'filter'\n      \
    \      .filter{$0.hasPrefix(prefix)}\n            ~^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar newStrings [String] = []\n\t\
    for (index, value) in strings.enumerate() {\n\t\tif strings.startsWith(prefix,\
    \ value) {\n\t\t\tnewStrings[index] = value\n\t\t}\n\t}\n\treturn newStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmc0oqno2.swift:8:16: error: consecutive statements on a line must\
    \ be separated by ';'\n        var newStrings [String] = []\n                \
    \      ^\n                      ;\n/tmp/tmpmc0oqno2.swift:8:6: error: type annotation\
    \ missing in pattern\n        var newStrings [String] = []\n            ^\n/tmp/tmpmc0oqno2.swift:8:17:\
    \ error: cannot assign to immutable expression of type '[String].Type'\n     \
    \   var newStrings [String] = []\n                       ^~~~~~~~\n/tmp/tmpmc0oqno2.swift:8:28:\
    \ error: cannot assign value of type '[Any]' to type '[String].Type'\n       \
    \ var newStrings [String] = []\n                                  ^~\n/tmp/tmpmc0oqno2.swift:9:32:\
    \ error: value of type '[String]' has no member 'enumerate'\n        for (index,\
    \ value) in strings.enumerate() {\n                              ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if s.hasPrefix(prefix) {\n            filtered =\
    \ append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfn2lw91x.swift:11:24: error: cannot find 'append' in scope\n  \
    \          filtered = append(filtered, s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tfor i := 0; i < len(strings); i++\
    \ {\n\t\tif strings.HasPrefix(strings[i], prefix) {\n\t\t\treturn strings\n\t\t\
    }\n\t}\n\treturn strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn01135dv.swift:8:9: error: expected type\n        for i := 0; i\
    \ < len(strings); i++ {\n               ^\n                <#type#>\n/tmp/tmpn01135dv.swift:8:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(strings);\
    \ i++ {\n               ^\n/tmp/tmpn01135dv.swift:8:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(strings); i++ {\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar filteredStrings: [String] = []\n\
    \tfor _, s := range strings {\n\t\tif s.startsWith(prefix) {\n\t\t\tfilteredStrings.append(s)\n\
    \t\t}\n\t}\n\treturn filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpu5x2venw.swift:9:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmpu5x2venw.swift:9:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz8wq5szy.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpz8wq5szy.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tswitch {\n\tcase strings.IsEmpty(strings):\n\
    \t\treturn []\n\tcase strings.HasPrefix(strings[0], prefix):\n\t\treturn strings.Slice(0,\
    \ prefix.Len()).Append(strings).Tail()\n\tcase strings.HasPrefix(strings[0], \"\
    \"):\n\t\treturn strings.Slice(0, prefix.Len()).Append(strings).Tail()\n\tdefault:\n\
    \t\treturn strings\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp17b818mr.swift:8:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp17b818mr.swift:12:18: error: value\
    \ of type '[String]' has no member 'Slice'\n                return strings.Slice(0,\
    \ prefix.Len()).Append(strings).Tail()\n                       ~~~~~~~ ^~~~~\n\
    /tmp/tmp17b818mr.swift:12:34: error: value of type 'String' has no member 'Len'\n\
    \                return strings.Slice(0, prefix.Len()).Append(strings).Tail()\n\
    \                                        ~~~~~~ ^~~\n/tmp/tmp17b818mr.swift:14:18:\
    \ error: value of type '[String]' has no member 'Slice'\n                return\
    \ strings.Slice(0, prefix.Len()).Append(strings).Tail()\n                    \
    \   ~~~~~~~ ^~~~~\n/tmp/tmp17b818mr.swift:14:34: error: value of type 'String'\
    \ has no member 'Len'\n                return strings.Slice(0, prefix.Len()).Append(strings).Tail()\n\
    \                                        ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif strings.IsNullOrEmpty(prefix)\
    \ {\n\t\treturn strings\n\t}\n\tr := make([]string, len(strings))\n\tfor i, v\
    \ := range strings {\n\t\tif strings.HasPrefix(v, prefix) {\n\t\t\tr[i] = v\n\t\
    \t}\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5u_3qosb.swift:11:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := make([]string, len(strings))\n         ^\n\
    \         ;\n/tmp/tmp5u_3qosb.swift:11:4: error: expected expression\n       \
    \ r := make([]string, len(strings))\n          ^\n/tmp/tmp5u_3qosb.swift:12:7:\
    \ error: expected 'in' after for-each pattern\n        for i, v := range strings\
    \ {\n             ^\n/tmp/tmp5u_3qosb.swift:12:7: error: expected Sequence expression\
    \ for for-each loop\n        for i, v := range strings {\n             ^\n/tmp/tmp5u_3qosb.swift:8:13:\
    \ error: value of type '[String]' has no member 'IsNullOrEmpty'\n        if strings.IsNullOrEmpty(prefix)\
    \ {\n           ~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp5u_3qosb.swift:11:2: error: cannot\
    \ find 'r' in scope\n        r := make([]string, len(strings))\n        ^\n/tmp/tmp5u_3qosb.swift:17:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix_helper(strings,\
    \ prefix, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjtg33vuu.swift:8:12: error: cannot find 'filter_by_prefix_helper'\
    \ in scope\n    return filter_by_prefix_helper(strings, prefix, false)\n     \
    \      ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty {\n        return\
    \ []\n    }\n    prefixLength = prefix.utf8.count\n    filteredStrings = strings.filter\
    \ {\n        $0.utf8.count >= prefixLength && $0.utf8.count <= strings.utf8.count\n\
    \    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqqkh5zxq.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpqqkh5zxq.swift:11:5:\
    \ error: cannot find 'prefixLength' in scope\n    prefixLength = prefix.utf8.count\n\
    \    ^~~~~~~~~~~~\n/tmp/tmpqqkh5zxq.swift:12:5: error: cannot find 'filteredStrings'\
    \ in scope\n    filteredStrings = strings.filter {\n    ^~~~~~~~~~~~~~~\n/tmp/tmpqqkh5zxq.swift:13:26:\
    \ error: cannot find 'prefixLength' in scope\n        $0.utf8.count >= prefixLength\
    \ && $0.utf8.count <= strings.utf8.count\n                         ^~~~~~~~~~~~\n\
    /tmp/tmpqqkh5zxq.swift:15:12: error: cannot find 'filteredStrings' in scope\n\
    \    return filteredStrings\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter(strings.startsWith(prefix),\
    \ strings)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgio49niq.swift:8:12: error: cannot find 'filter' in scope\n   \
    \ return filter(strings.startsWith(prefix), strings)\n           ^~~~~~\n/tmp/tmpgio49niq.swift:8:27:\
    \ error: value of type '[String]' has no member 'startsWith'\n    return filter(strings.startsWith(prefix),\
    \ strings)\n                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\trv := make([]string, len(strings))\n\
    \tfor i, v := range strings {\n\t\tif strings.HasPrefix(v, prefix) {\n\t\t\trv[i]\
    \ = v\n\t\t}\n\t}\n\treturn rv\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg0ptnpdz.swift:8:4: error: consecutive statements on a line must\
    \ be separated by ';'\n        rv := make([]string, len(strings))\n          ^\n\
    \          ;\n/tmp/tmpg0ptnpdz.swift:8:5: error: expected expression\n       \
    \ rv := make([]string, len(strings))\n           ^\n/tmp/tmpg0ptnpdz.swift:9:7:\
    \ error: expected 'in' after for-each pattern\n        for i, v := range strings\
    \ {\n             ^\n/tmp/tmpg0ptnpdz.swift:9:7: error: expected Sequence expression\
    \ for for-each loop\n        for i, v := range strings {\n             ^\n/tmp/tmpg0ptnpdz.swift:8:2:\
    \ error: cannot find 'rv' in scope\n        rv := make([]string, len(strings))\n\
    \        ^~\n/tmp/tmpg0ptnpdz.swift:14:9: error: cannot find 'rv' in scope\n \
    \       return rv\n               ^~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5r888w4h.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter(strings, { strings.contains($0.prefix(prefix))\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwko_dwpz.swift:8:12: error: cannot find 'filter' in scope\n   \
    \ return filter(strings, { strings.contains($0.prefix(prefix)) })\n          \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tprefix += \"\\x00\"\n\treturn strings.filter({\
    \ $0.hasPrefix(prefix) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmrbrb4st.swift:8:14: error: invalid escape sequence in literal\n\
    \        prefix += \"\\x00\"\n                    ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let result = strings.filter {\n\
    \        ($0.hasPrefix(prefix)) // or $0 == prefix\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    strings = strings.filter({ str\
    \ in\n        if str.startsWith(prefix) {\n            return true\n        }\
    \ else {\n            return false\n        }\n    })\n    return strings\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5tym0cr9.swift:8:5: error: cannot assign to value: 'strings' is\
    \ a 'let' constant\n    strings = strings.filter({ str in\n    ^~~~~~~\n/tmp/tmp5tym0cr9.swift:9:16:\
    \ error: value of type 'String' has no member 'startsWith'\n        if str.startsWith(prefix)\
    \ {\n           ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if !strings.is_sorted() {\n   \
    \     strings = strings.sorted()\n    }\n    prefix += \"\"\n    var result: [String]\
    \ = []\n    for string in strings {\n        if string.startsWith(prefix) {\n\
    \            result.append(string)\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnpzg26q2.swift:8:17: error: value of type '[String]' has no member\
    \ 'is_sorted'\n    if !strings.is_sorted() {\n        ~~~~~~~ ^~~~~~~~~\n/tmp/tmpnpzg26q2.swift:9:9:\
    \ error: cannot assign to value: 'strings' is a 'let' constant\n        strings\
    \ = strings.sorted()\n        ^~~~~~~\n/tmp/tmpnpzg26q2.swift:11:12: error: left\
    \ side of mutating operator isn't mutable: 'prefix' is a 'let' constant\n    prefix\
    \ += \"\"\n    ~~~~~~ ^\n/tmp/tmpnpzg26q2.swift:14:19: error: value of type 'String'\
    \ has no member 'startsWith'\n        if string.startsWith(prefix) {\n       \
    \    ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar filtered: [String] = []\n\tprefix\
    \ += \" \"\n\tfor _, s := range strings {\n\t\tif strings.HasPrefix(s, prefix)\
    \ {\n\t\t\tfiltered = append(filtered, s)\n\t\t}\n\t}\n\treturn filtered\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsf8i1oli.swift:10:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmpsf8i1oli.swift:10:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n/tmp/tmpsf8i1oli.swift:9:9: error: left side of mutating\
    \ operator isn't mutable: 'prefix' is a 'let' constant\n        prefix += \" \"\
    \n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tfor i := 0; i < len(strings); i++\
    \ {\n\t\tif strings.HasPrefix(strings[i], prefix) {\n\t\t\treturn strings.SplitN(strings[i],\
    \ prefix, 2)\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw2p92h_5.swift:8:9: error: expected type\n        for i := 0; i\
    \ < len(strings); i++ {\n               ^\n                <#type#>\n/tmp/tmpw2p92h_5.swift:8:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(strings);\
    \ i++ {\n               ^\n/tmp/tmpw2p92h_5.swift:8:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(strings); i++ {\n\
    \               ^\n/tmp/tmpw2p92h_5.swift:13:9: error: 'nil' is incompatible with\
    \ return type '[String]'\n        return nil\n               ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for value in strings {\n        if value.hasPrefix(prefix) {\n           \
    \ filtered.append(value)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  \n  return strings.filter { (string)\
    \ -> Bool in\n    let range = string.range(of: prefix)\n    range.hasPrefix\n\
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmr112fj8.swift:10:24: error: value of type 'String' has no member\
    \ 'range'\n    let range = string.range(of: prefix)\n                ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var result = strings\n    for i\
    \ in 0..<strings.count {\n        if strings.prefix(i, prefix) {\n           \
    \ result = result[0..i]\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp77fm0mxk.swift:10:30: error: extra argument in call\n        if\
    \ strings.prefix(i, prefix) {\n                         ~~~~^~~~~~~\n/tmp/tmp77fm0mxk.swift:10:20:\
    \ error: no 'prefix' candidates produce the expected contextual result type 'Bool'\n\
    \        if strings.prefix(i, prefix) {\n                   ^\nSwift.Sequence:7:40:\
    \ note: 'prefix' produces 'PrefixSequence<[String]>', not the expected contextual\
    \ result type 'Bool'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> PrefixSequence<Self>\n                                       ^\nSwift.Collection:6:40:\
    \ note: 'prefix' produces 'ArraySlice<String>', not the expected contextual result\
    \ type 'Bool'\n    @inlinable public __consuming func prefix(_ maxLength: Int)\
    \ -> Self.SubSequence\n                                       ^\n/tmp/tmp77fm0mxk.swift:11:30:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n           \
    \ result = result[0..i]\n                             ^~\n                   \
    \          ...\n/tmp/tmp77fm0mxk.swift:11:28: error: no 'subscript' candidates\
    \ produce the expected contextual result type '[String]'\n            result =\
    \ result[0..i]\n                           ^\nSwift.Array:16:23: note: 'subscript(_:)'\
    \ produces 'String', not the expected contextual result type '[String]'\n    @inlinable\
    \ public subscript(index: Int) -> Element { get set }\n                      ^\n\
    Swift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<String>', not the\
    \ expected contextual result type '[String]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:3:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<String>', not the expected contextual\
    \ result type '[String]'\n    @inlinable public subscript(x: (UnboundedRange_)\
    \ -> ()) -> Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<String>', not the expected contextual\
    \ result type '[String]'\n    @inlinable public subscript(x: (UnboundedRange_)\
    \ -> ()) -> Self.S"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = strings\n    for\
    \ index in 0..<strings.count {\n        if strings.startWith(strings[index], prefix)\
    \ {\n            filtered = filtered.filter { $0 != strings[index] }\n       \
    \     break\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgwguyzgm.swift:10:20: error: value of type '[String]' has no member\
    \ 'startWith'\n        if strings.startWith(strings[index], prefix) {\n      \
    \     ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  guard strings.isEmpty || strings.first!.hasPrefix(prefix)\
    \ else {\n    return strings\n  }\n  return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if prefix != \"\" {\n        for\
    \ s in strings {\n            if s.startsWith(prefix) {\n                strings\
    \ = strings.filter{ !it.startsWith(prefix) }\n            }\n        }\n    }\n\
    \    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz4ph0e0l.swift:10:18: error: value of type 'String' has no member\
    \ 'startsWith'\n            if s.startsWith(prefix) {\n               ~ ^~~~~~~~~~\n\
    /tmp/tmpz4ph0e0l.swift:11:44: error: cannot find 'it' in scope\n             \
    \   strings = strings.filter{ !it.startsWith(prefix) }\n                     \
    \                      ^~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = strings\n    for\
    \ string in strings {\n        if string.hasPrefix(prefix) {\n            filtered\
    \ = filtered[..<filtered.index(of: string)]\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq0jqb1uy.swift:11:32: error: cannot assign value of type 'ArraySlice<String>'\
    \ to type '[String]'\n            filtered = filtered[..<filtered.index(of: string)]\n\
    \                       ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpq0jqb1uy.swift:11:45:\
    \ error: value of optional type 'Array<String>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<String>.Index' (aka 'Int')\n        \
    \    filtered = filtered[..<filtered.index(of: string)]\n                    \
    \                        ^\n/tmp/tmpq0jqb1uy.swift:11:45: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \   filtered = filtered[..<filtered.index(of: string)]\n                     \
    \                       ^\n                                   (              \
    \            ?? <#default value#>)\n/tmp/tmpq0jqb1uy.swift:11:45: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \    filtered = filtered[..<filtered.index(of: string)]\n                    \
    \                        ^\n                                                 \
    \            !\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  return strings[strings.Index(strings.FirstIndex(prefix))\
    \ != -1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp78wi922n.swift:8:17: error: no exact matches in call to subscript\
    \ \n  return strings[strings.Index(strings.FirstIndex(prefix)) != -1]\n      \
    \          ^\n/tmp/tmp78wi922n.swift:8:17: note: found candidate with type '(Int)\
    \ -> String'\n  return strings[strings.Index(strings.FirstIndex(prefix)) != -1]\n\
    \                ^\n/tmp/tmp78wi922n.swift:8:17: note: found candidate with type\
    \ '(Range<Int>) -> ArraySlice<String>'\n  return strings[strings.Index(strings.FirstIndex(prefix))\
    \ != -1]\n                ^\n/tmp/tmp78wi922n.swift:8:17: note: found candidate\
    \ with type '((UnboundedRange_) -> ()) -> ArraySlice<String>'\n  return strings[strings.Index(strings.FirstIndex(prefix))\
    \ != -1]\n                ^\n/tmp/tmp78wi922n.swift:8:17: error: no 'subscript'\
    \ candidates produce the expected contextual result type '[String]'\n  return\
    \ strings[strings.Index(strings.FirstIndex(prefix)) != -1]\n                ^\n\
    Swift.Array:16:23: note: 'subscript(_:)' produces 'String', not the expected contextual\
    \ result type '[String]'\n    @inlinable public subscript(index: Int) -> Element\
    \ { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<String>', not the expected contextual result type '[String]'\n\
    \    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {\
    \ get set }\n                      ^\nSwift.Collection:3:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<String>', not the expected contextual result type '[String]'\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\nSwift.MutableCollection:3:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<String>', not the expected contextual result type '[String]'\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get set }\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)'\
    \ produces 'String', not the expected contextual result type '[String]'\n    @inlinable\
    \ public subscript(index: Int) -> Element { get set }\n                      ^\n\
    Swift.Array:17:23: no"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tfor _, s := range strings {\n\t\t\
    if strings.HasPrefix(s, prefix) {\n\t\t\treturn strings\n\t\t}\n\t}\n\treturn\
    \ []String{}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv7iylbfp.swift:8:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmpv7iylbfp.swift:8:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n/tmp/tmpv7iylbfp.swift:13:11: error: consecutive\
    \ statements on a line must be separated by ';'\n        return []String{}\n \
    \                ^\n                 ;\n/tmp/tmpv7iylbfp.swift:13:11: error: ambiguous\
    \ use of 'init'\n        return []String{}\n                 ^\nSwift.String:2:12:\
    \ note: found this candidate\n    public init<Subject>(describing instance: Subject)\n\
    \           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5r888w4h.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  var filtered = [String]()\n  for\
    \ string in strings {\n    if string.hasPrefix(prefix) {\n      filtered.append(string)\n\
    \    }\n  }\n  return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter { $0.hasPrefix(prefix)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar result = [String]()\n\tfor _,\
    \ str := range strings {\n\t\tif str.hasPrefix(prefix) {\n\t\t\tresult = append(result,\
    \ str)\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzkgqh4ug.swift:9:7: error: expected 'in' after for-each pattern\n\
    \        for _, str := range strings {\n             ^\n/tmp/tmpzkgqh4ug.swift:9:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, str :=\
    \ range strings {\n             ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return []\n    }\n\n    if !strings.HasPrefix(strings.Last(), prefix) {\n \
    \       return strings\n    }\n\n    var result = [String]()\n    for string in\
    \ strings {\n        if string.hasPrefix(prefix) {\n            result.append(string)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv0q7kgyb.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpv0q7kgyb.swift:12:17:\
    \ error: value of type '[String]' has no member 'HasPrefix'\n    if !strings.HasPrefix(strings.Last(),\
    \ prefix) {\n        ~~~~~~~ ^~~~~~~~~\n/tmp/tmpv0q7kgyb.swift:12:35: error: value\
    \ of type '[String]' has no member 'Last'\n    if !strings.HasPrefix(strings.Last(),\
    \ prefix) {\n                          ~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  if prefix != \"\" {\n    return strings.filter{\
    \ $0.hasPrefix(prefix) }\n  } else {\n    return strings\n  }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tfor _, str := range strings {\n\t\
    \tif strings.HasPrefix(str, prefix) {\n\t\t\treturn strings.Split(str, \" \")\n\
    \t\t}\n\t}\n\treturn []String{}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp08jyxfcq.swift:8:7: error: expected 'in' after for-each pattern\n\
    \        for _, str := range strings {\n             ^\n/tmp/tmp08jyxfcq.swift:8:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, str :=\
    \ range strings {\n             ^\n/tmp/tmp08jyxfcq.swift:13:11: error: consecutive\
    \ statements on a line must be separated by ';'\n        return []String{}\n \
    \                ^\n                 ;\n/tmp/tmp08jyxfcq.swift:13:11: error: ambiguous\
    \ use of 'init'\n        return []String{}\n                 ^\nSwift.String:2:12:\
    \ note: found this candidate\n    public init<Subject>(describing instance: Subject)\n\
    \           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  assert(strings.count, \"Must pass\
    \ a non-empty array of strings\")\n  assert(prefix, \"Must pass a non-empty prefix\"\
    )\n  \n  var filtered : [String] = []\n  for element in strings {\n    if element.startsWith(prefix)\
    \ {\n      filtered.append(element)\n    }\n  }\n  \n  return filtered\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpda2plq11.swift:8:18: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n  assert(strings.count, \"Must pass a non-empty array\
    \ of strings\")\n                 ^\n         (             != 0)\n/tmp/tmpda2plq11.swift:9:10:\
    \ error: cannot convert value of type 'String' to expected argument type 'Bool'\n\
    \  assert(prefix, \"Must pass a non-empty prefix\")\n         ^\n/tmp/tmpda2plq11.swift:13:16:\
    \ error: value of type 'String' has no member 'startsWith'\n    if element.startsWith(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  var filtered = Array<String>()\n\
    \  for s in strings {\n    if s.startsWith(prefix) {\n      filtered.append(s)\n\
    \    }\n  }\n  return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr1wvjhzv.swift:10:10: error: value of type 'String' has no member\
    \ 'startsWith'\n    if s.startsWith(prefix) {\n       ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var strings = [String]()\n    for\
    \ s in strings {\n        if s.startsWith(prefix) {\n            strings.append(s)\n\
    \        }\n    }\n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi4rk8ksv.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tfilteredStrings := []string{}\n\t\
    for _, v := range strings {\n\t\tif strings.HasPrefix(v, prefix) {\n\t\t\tfilteredStrings\
    \ = append(filteredStrings, v)\n\t\t}\n\t}\n\treturn filteredStrings\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmppdoo1h3q.swift:8:17: error: consecutive statements on a line must\
    \ be separated by ';'\n        filteredStrings := []string{}\n               \
    \        ^\n                       ;\n/tmp/tmppdoo1h3q.swift:8:18: error: expected\
    \ expression\n        filteredStrings := []string{}\n                        ^\n\
    /tmp/tmppdoo1h3q.swift:9:7: error: expected 'in' after for-each pattern\n    \
    \    for _, v := range strings {\n             ^\n/tmp/tmppdoo1h3q.swift:9:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, v := range\
    \ strings {\n             ^\n/tmp/tmppdoo1h3q.swift:8:2: error: cannot find 'filteredStrings'\
    \ in scope\n        filteredStrings := []string{}\n        ^~~~~~~~~~~~~~~\n/tmp/tmppdoo1h3q.swift:14:9:\
    \ error: cannot find 'filteredStrings' in scope\n        return filteredStrings\n\
    \               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    for s in strings {\n        if\
    \ s.startsWith(prefix) {\n            return strings\n        }\n    }\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9r58q0yi.swift:9:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var result = [String]()\n    for\
    \ s in strings {\n        if s.hasPrefix(prefix) {\n            result.append(s)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filterStrings(strings, prefix,\
    \ true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy90j3d7q.swift:8:9: error: cannot find 'filterStrings' in scope\n\
    \        return filterStrings(strings, prefix, true)\n               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tfor _, s := range strings {\n\t\t\
    if strings.HasPrefix(s, prefix) {\n\t\t\tcontinue // ignore the prefix\n\t\t}\n\
    \t\t\n\t\tstrings = append(strings[:i], strings[i+1:]...)\n\t\tbreak\n\t}\n\t\n\
    \treturn strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpf3oc3otw.swift:8:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmpf3oc3otw.swift:8:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n/tmp/tmpf3oc3otw.swift:13:28: error: expected expression\
    \ in list of expressions\n                strings = append(strings[:i], strings[i+1:]...)\n\
    \                                         ^\n/tmp/tmpf3oc3otw.swift:13:44: error:\
    \ expected ',' separator\n                strings = append(strings[:i], strings[i+1:]...)\n\
    \                                                         ^\n                \
    \                                         ,\n/tmp/tmpf3oc3otw.swift:13:44: error:\
    \ expected expression in list of expressions\n                strings = append(strings[:i],\
    \ strings[i+1:]...)\n                                                        \
    \ ^\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.isEmpty {\n        return\
    \ strings\n    }\n    let startIdx = strings.firstIndex(of: prefix)\n    return\
    \ startIdx == nil ? strings : strings.prefix(upTo: startIdx)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmptmwfggzd.swift:12:28: error: cannot convert return expression of\
    \ type 'ArraySlice<String>' to return type '[String]'\n    return startIdx ==\
    \ nil ? strings : strings.prefix(upTo: startIdx)\n           ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptmwfggzd.swift:12:61: error: value of optional type 'Array<String>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<String>.Index'\
    \ (aka 'Int')\n    return startIdx == nil ? strings : strings.prefix(upTo: startIdx)\n\
    \                                                            ^\n/tmp/tmptmwfggzd.swift:12:61:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return startIdx == nil ? strings : strings.prefix(upTo: startIdx)\n\
    \                                                            ^\n             \
    \                                                        ?? <#default value#>\n\
    /tmp/tmptmwfggzd.swift:12:61: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    return startIdx == nil ? strings :\
    \ strings.prefix(upTo: startIdx)\n                                           \
    \                 ^\n                                                        \
    \            !\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var output = [String]()\n    for\
    \ s in strings {\n        if s.hasPrefix(prefix) {\n            output.append(s)\n\
    \        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter{ $0.hasPrefix(prefix)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978900
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tfilteredString := strings.filter({\
    \ $0.hasPrefix(prefix) })\n\treturn filteredString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdo_jecw3.swift:8:16: error: consecutive statements on a line must\
    \ be separated by ';'\n        filteredString := strings.filter({ $0.hasPrefix(prefix)\
    \ })\n                      ^\n                      ;\n/tmp/tmpdo_jecw3.swift:8:17:\
    \ error: expected expression\n        filteredString := strings.filter({ $0.hasPrefix(prefix)\
    \ })\n                       ^\n/tmp/tmpdo_jecw3.swift:8:2: error: cannot find\
    \ 'filteredString' in scope\n        filteredString := strings.filter({ $0.hasPrefix(prefix)\
    \ })\n        ^~~~~~~~~~~~~~\n/tmp/tmpdo_jecw3.swift:9:9: error: cannot find 'filteredString'\
    \ in scope\n        return filteredString\n               ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  var result = strings\n\n  if !strings.isEmpty\
    \ {\n    result = strings.filter { $0.hasPrefix(prefix) }\n  }\n\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let filtered = strings.filter {\n\
    \        $0.hasPrefix(prefix)\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter { $0.hasPrefix(prefix)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tfor string in strings {\n\t\tif string.hasPrefix(prefix)\
    \ {\n\t\t\treturn [string]\n\t\t}\n\t}\n\treturn []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: Exception
  stderr: 'tmpl21pie5e/tmpl21pie5e.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3abaadbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3aba7d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3aba7d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3aba7d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl21pie5e                        0x000056086814a912 <unavailable> + 6418

    5    libc.so.6                          0x00002b3abacc7460 __libc_start_main +
    245

    6    tmpl21pie5e                        0x000056086814a289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered_strings = [String]()\n\
    \    for string in strings {\n        if string.hasPrefix(prefix) {\n        \
    \    filtered_strings.append(string)\n        }\n    }\n    return filtered_strings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for s in strings {\n        if strings.indexWhere(s.startsWith, prefix) == 0\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqm6khx_q.swift:10:20: error: value of type '[String]' has no member\
    \ 'indexWhere'\n        if strings.indexWhere(s.startsWith, prefix) == 0 {\n \
    \          ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqm6khx_q.swift:10:33: error: value of type\
    \ 'String' has no member 'startsWith'\n        if strings.indexWhere(s.startsWith,\
    \ prefix) == 0 {\n                              ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let filtered = strings.filter {\
    \ $0.hasPrefix(prefix) }\n    if filtered.count == 0 {\n        return strings\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var result: [String] = []\n   \
    \ for s in strings {\n        if s.startsWith(prefix) {\n            result.append(s)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe5dpto_2.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  var result: [String] = []\n  for\
    \ s in strings {\n    if s.startsWith(prefix) {\n      result = append(result,\
    \ s)\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpld40_mpe.swift:10:10: error: value of type 'String' has no member\
    \ 'startsWith'\n    if s.startsWith(prefix) {\n       ~ ^~~~~~~~~~\n/tmp/tmpld40_mpe.swift:11:16:\
    \ error: cannot find 'append' in scope\n      result = append(result, s)\n   \
    \            ^~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let prefixLength = prefix.count\n\
    \    return strings.filter { $0.hasPrefix(prefix) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let filtered = strings.filter {\
    \ (string) -> Bool in\n        return string.hasPrefix(prefix)\n    }\n    return\
    \ filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix_helper(strings,\
    \ prefix, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwm1se65m.swift:8:9: error: cannot find 'filter_by_prefix_helper'\
    \ in scope\n        return filter_by_prefix_helper(strings, prefix, false)\n \
    \              ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = strings\n    for\
    \ str in strings {\n        if str.hasPrefix(prefix) {\n            filtered =\
    \ [String]()\n            break\n        }\n        filtered = [str] + filtered\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: Exception
  stderr: 'tmpzq0b7_hd/tmpzq0b7_hd.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac838b97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac83888eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac83888e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac83888d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzq0b7_hd                        0x00005577eadb59c2 <unavailable> + 6594

    5    libc.so.6                          0x00002ac838d83460 __libc_start_main +
    245

    6    tmpzq0b7_hd                        0x00005577eadb5339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tfor _, s := range strings {\n\t\t\
    if strings.HasPrefix(s, prefix) {\n\t\t\treturn strings\n\t\t}\n\t}\n\n\treturn\
    \ strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp30jn1tcm.swift:8:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmp30jn1tcm.swift:8:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tlet filtered = strings.filter { (s)\
    \ in\n\t\treturn s.startsWith(prefix)\n\t}\n\treturn filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw5fsqmua.swift:9:12: error: value of type 'String' has no member\
    \ 'startsWith'\n                return s.startsWith(prefix)\n                \
    \       ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filteredStrings: [String] =\
    \ []\n\n    for string in strings {\n        if string.hasPrefix(prefix) {\n \
    \           filteredStrings.append(string)\n        }\n    }\n\n    return filteredStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix_helper(strings,\
    \ prefix, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjtg33vuu.swift:8:12: error: cannot find 'filter_by_prefix_helper'\
    \ in scope\n    return filter_by_prefix_helper(strings, prefix, false)\n     \
    \      ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    strings = strings.filter({ $0.hasPrefix(prefix)\
    \ })\n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpudauaj5c.swift:8:5: error: cannot assign to value: 'strings' is\
    \ a 'let' constant\n    strings = strings.filter({ $0.hasPrefix(prefix) })\n \
    \   ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var results = strings\n    for\
    \ string in strings {\n        if string.hasPrefix(prefix) {\n            results\
    \ = append(results, string)\n        }\n    }\n    return results\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyk1vzlrh.swift:11:23: error: cannot find 'append' in scope\n  \
    \          results = append(results, string)\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    prefix += Strings.repeat(\"\",\
    \ len(prefix))\n    var output = [String]()\n    for s in strings {\n        if\
    \ strings.startsWith(prefix, s.count) {\n            output.append(s)\n      \
    \  }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7vtw_lnz.swift:8:15: error: cannot find 'Strings' in scope\n  \
    \  prefix += Strings.repeat(\"\", len(prefix))\n              ^~~~~~~\n/tmp/tmp7vtw_lnz.swift:8:34:\
    \ error: cannot find 'len' in scope\n    prefix += Strings.repeat(\"\", len(prefix))\n\
    \                                 ^~~\n/tmp/tmp7vtw_lnz.swift:11:20: error: value\
    \ of type '[String]' has no member 'startsWith'\n        if strings.startsWith(prefix,\
    \ s.count) {\n           ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    prefix = prefix.lowercased()\n\
    \    var filtered = strings\n    for s in strings {\n        if s.startsWith(prefix)\
    \ {\n            filtered = filtered[..<filtered.index(s)]\n        }\n    }\n\
    \    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8_0ivlbt.swift:8:5: error: cannot assign to value: 'prefix' is\
    \ a 'let' constant\n    prefix = prefix.lowercased()\n    ^~~~~~\n/tmp/tmp8_0ivlbt.swift:11:14:\
    \ error: value of type 'String' has no member 'startsWith'\n        if s.startsWith(prefix)\
    \ {\n           ~ ^~~~~~~~~~\n/tmp/tmp8_0ivlbt.swift:12:51: error: missing argument\
    \ label 'of:' in call\n            filtered = filtered[..<filtered.index(s)]\n\
    \                                                  ^\n                       \
    \                           of: \n/tmp/tmp8_0ivlbt.swift:12:32: error: cannot\
    \ assign value of type 'ArraySlice<String>' to type '[String]'\n            filtered\
    \ = filtered[..<filtered.index(s)]\n                       ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8_0ivlbt.swift:12:45: error: value of optional type 'Array<String>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<String>.Index'\
    \ (aka 'Int')\n            filtered = filtered[..<filtered.index(s)]\n       \
    \                                     ^\n/tmp/tmp8_0ivlbt.swift:12:45: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \         filtered = filtered[..<filtered.index(s)]\n                        \
    \                    ^\n                                   (                 ??\
    \ <#default value#>)\n/tmp/tmp8_0ivlbt.swift:12:45: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n            filtered\
    \ = filtered[..<filtered.index(s)]\n                                         \
    \   ^\n                                                    !\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filterString(strings, prefixPredicate(prefix))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpljin7fyb.swift:8:12: error: cannot find 'filterString' in scope\n\
    \    return filterString(strings, prefixPredicate(prefix))\n           ^~~~~~~~~~~~\n\
    /tmp/tmpljin7fyb.swift:8:34: error: cannot find 'prefixPredicate' in scope\n \
    \   return filterString(strings, prefixPredicate(prefix))\n                  \
    \               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter(strings.map(func(x:\
    \ String) -> Bool { return x.startsWith(prefix) }), true)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9a2wllno.swift:8:31: error: expected expression in list of expressions\n\
    \    return filter(strings.map(func(x: String) -> Bool { return x.startsWith(prefix)\
    \ }), true)\n                              ^\n/tmp/tmp9a2wllno.swift:8:35: error:\
    \ expected identifier in function declaration\n    return filter(strings.map(func(x:\
    \ String) -> Bool { return x.startsWith(prefix) }), true)\n                  \
    \                ^\n/tmp/tmp9a2wllno.swift:8:12: error: cannot find 'filter' in\
    \ scope\n    return filter(strings.map(func(x: String) -> Bool { return x.startsWith(prefix)\
    \ }), true)\n           ^~~~~~\n/tmp/tmp9a2wllno.swift:8:27: error: no exact matches\
    \ in call to instance method 'map'\n    return filter(strings.map(func(x: String)\
    \ -> Bool { return x.startsWith(prefix) }), true)\n                          ^\n\
    /tmp/tmp9a2wllno.swift:8:27: note: found candidate with type '((String) throws\
    \ -> _) throws -> Array<_>'\n    return filter(strings.map(func(x: String) ->\
    \ Bool { return x.startsWith(prefix) }), true)\n                          ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var strings = strings\n    if strings.isEmpty\
    \ {\n        return strings\n    }\n    if strings.first == prefix {\n       \
    \ return strings\n    }\n    strings.removeFirst()\n    return strings\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: Exception
  stderr: 'tmpnbu639g5/tmpnbu639g5.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f305b8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f302afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f302af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f302ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnbu639g5                        0x000055f3144b1942 <unavailable> + 6466

    5    libc.so.6                          0x00002b6f307a4460 __libc_start_main +
    245

    6    tmpnbu639g5                        0x000055f3144b12b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  return filter_by_prefix_impl(strings,\
    \ prefix, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpeyxe77tg.swift:8:10: error: cannot find 'filter_by_prefix_impl'\
    \ in scope\n  return filter_by_prefix_impl(strings, prefix, false)\n         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar stringsInSlice []string\n\tfor\
    \ _, s := range strings {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\tstringsInSlice\
    \ = append(stringsInSlice, s)\n\t\t}\n\t}\n\treturn stringsInSlice\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpznzzwb99.swift:8:20: error: consecutive statements on a line must\
    \ be separated by ';'\n        var stringsInSlice []string\n                 \
    \         ^\n                          ;\n/tmp/tmpznzzwb99.swift:8:23: error:\
    \ consecutive statements on a line must be separated by ';'\n        var stringsInSlice\
    \ []string\n                             ^\n                             ;\n/tmp/tmpznzzwb99.swift:9:7:\
    \ error: expected 'in' after for-each pattern\n        for _, s := range strings\
    \ {\n             ^\n/tmp/tmpznzzwb99.swift:9:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, s := range strings {\n             ^\n/tmp/tmpznzzwb99.swift:8:6:\
    \ error: type annotation missing in pattern\n        var stringsInSlice []string\n\
    \            ^\n/tmp/tmpznzzwb99.swift:8:21: error: empty collection literal requires\
    \ an explicit type\n        var stringsInSlice []string\n                    \
    \       ^~\n/tmp/tmpznzzwb99.swift:8:21: warning: expression of type '[Any]' is\
    \ unused\n        var stringsInSlice []string\n                           ^~\n\
    /tmp/tmpznzzwb99.swift:8:23: error: cannot find 'string' in scope\n        var\
    \ stringsInSlice []string\n                             ^~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  let prefix_length = prefix.characters.count\n\
    \  return strings.filter({ $0.hasPrefix(prefix) }).map({ $0.substringFromIndex(prefix_length)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_a8ca6y2.swift:8:30: error: 'characters' is unavailable: Please\
    \ use String directly\n  let prefix_length = prefix.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_a8ca6y2.swift:9:60: error: value of type 'String' has no member\
    \ 'substringFromIndex'\n  return strings.filter({ $0.hasPrefix(prefix) }).map({\
    \ $0.substringFromIndex(prefix_length) })\n                                  \
    \                      ~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar filtered: [String] = []\n\tfor\
    \ _, string := range strings {\n\t\tif strings.HasPrefix(string, prefix) {\n\t\
    \t\tfiltered = append(filtered, string)\n\t\t}\n\t}\n\treturn filtered\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwttn2kk2.swift:9:7: error: expected 'in' after for-each pattern\n\
    \        for _, string := range strings {\n             ^\n/tmp/tmpwttn2kk2.swift:9:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, string\
    \ := range strings {\n             ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn strings.filter({ (value) ->\
    \ Bool in\n\t\tlet prefixValue = String(value[value.index(prefix.startIndex, offsetBy:\
    \ prefix.count)])\n\t\treturn prefixValue == prefix\n\t})\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1d8ad8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1d87cf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba1d87cf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba1d87cf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba1d87cebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ba1d8902ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002ba1d88bb660 String.subscript.getter
    + 34

    7    tmpfokafmxc                        0x0000564c9b30cb9a <unavailable> + 7066

    8    tmpfokafmxc                        0x0000564c9b30cfe4 <unavailable> + 8164

    9    libswiftCore.so                    0x00002ba1d87cc6e0 _ArrayProtocol.filter(_:)
    + 518

    10   tmpfokafmxc                        0x0000564c9b30cad7 <unavailable> + 6871

    11   tmpfokafmxc                        0x0000564c9b30c8c9 <unavailable> + 6345

    12   libc.so.6                          0x00002ba1d8cc4460 __libc_start_main +
    245

    13   tmpfokafmxc                        0x0000564c9b30c3a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_(string, prefix).mapToSlice()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyaa8nijy.swift:8:12: error: cannot find 'filter_' in scope\n  \
    \  return filter_(string, prefix).mapToSlice()\n           ^~~~~~~\n/tmp/tmpyaa8nijy.swift:8:20:\
    \ error: cannot find 'string' in scope\n    return filter_(string, prefix).mapToSlice()\n\
    \                   ^~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var result = [String]()\n    \n\
    \    for value in strings {\n        if value.startsWith(prefix) {\n         \
    \   result.append(value)\n        }\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdcka080c.swift:11:18: error: value of type 'String' has no member\
    \ 'startsWith'\n        if value.startsWith(prefix) {\n           ~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    strings.filter { $0.hasPrefix(prefix)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\ts = append(prefix, s...)\n\ta = append([]string(nil),\
    \ strings...)\n\treturn a[len(prefix):]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgd_s19mr.swift:9:15: error: expected ',' separator\n        a =\
    \ append([]string(nil), strings...)\n                     ^\n                \
    \     ,\n/tmp/tmpgd_s19mr.swift:10:22: error: expected ',' separator\n       \
    \ return a[len(prefix):]\n                            ^\n                    \
    \        ,\n/tmp/tmpgd_s19mr.swift:10:22: error: expected expression in list of\
    \ expressions\n        return a[len(prefix):]\n                            ^\n\
    /tmp/tmpgd_s19mr.swift:8:2: error: cannot find 's' in scope\n        s = append(prefix,\
    \ s...)\n        ^\n/tmp/tmpgd_s19mr.swift:8:6: error: cannot find 'append' in\
    \ scope\n        s = append(prefix, s...)\n            ^~~~~~\n/tmp/tmpgd_s19mr.swift:8:21:\
    \ error: cannot find 's' in scope\n        s = append(prefix, s...)\n        \
    \                   ^\n/tmp/tmpgd_s19mr.swift:9:2: error: cannot find 'a' in scope\n\
    \        a = append([]string(nil), strings...)\n        ^\n/tmp/tmpgd_s19mr.swift:9:6:\
    \ error: cannot find 'append' in scope\n        a = append([]string(nil), strings...)\n\
    \            ^~~~~~\n/tmp/tmpgd_s19mr.swift:9:15: error: cannot find 'string'\
    \ in scope\n        a = append([]string(nil), strings...)\n                  \
    \   ^~~~~~\n/tmp/tmpgd_s19mr.swift:9:22: error: 'nil' requires a contextual type\n\
    \        a = append([]string(nil), strings...)\n                            ^\n\
    /tmp/tmpgd_s19mr.swift:9:28: error: cannot convert value of type '[String]' to\
    \ expected argument type 'UnboundedRange_'\n        a = append([]string(nil),\
    \ strings...)\n                                  ^\n/tmp/tmpgd_s19mr.swift:10:9:\
    \ error: cannot find 'a' in scope\n        return a[len(prefix):]\n          \
    \     ^\n/tmp/tmpgd_s19mr.swift:10:11: error: cannot find 'len' in scope\n   \
    \     return a[len(prefix):]\n                 ^~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if prefix != \"\" {\n        return\
    \ strings.filter{ $0.hasPrefix(prefix) }\n    } else {\n        return strings\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix_with_index(strings,\
    \ prefix, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgmfml9yc.swift:8:9: error: cannot find 'filter_by_prefix_with_index'\
    \ in scope\n        return filter_by_prefix_with_index(strings, prefix, 0)\n \
    \              ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt_150dr0.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, false)\n                           ~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    // FIXME: use more efficient implementation\
    \ if possible\n    var result = [String]()\n    for str in strings {\n       \
    \ if str.startsWith(prefix) {\n            result.append(str)\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_a9j86hz.swift:11:16: error: value of type 'String' has no member\
    \ 'startsWith'\n        if str.startsWith(prefix) {\n           ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix_internal(strings,\
    \ prefix, \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0_mo3mh_.swift:8:12: error: cannot find 'filter_by_prefix_internal'\
    \ in scope\n    return filter_by_prefix_internal(strings, prefix, \"\")\n    \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if prefix != \"\" {\n        let\
    \ prefixIndex = strings.startIndex.advancedBy(0, maxDistance(prefix.utf8)) + 1\n\
    \        if prefixIndex != strings.endIndex {\n            strings.removeSubrange(prefixIndex,\
    \ prefixIndex.advancedBy(maxDistance(prefix.utf8) - prefixIndex))\n        }\n\
    \    }\n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgz0dccob.swift:9:60: error: cannot find 'maxDistance' in scope\n\
    \        let prefixIndex = strings.startIndex.advancedBy(0, maxDistance(prefix.utf8))\
    \ + 1\n                                                           ^~~~~~~~~~~\n\
    /tmp/tmpgz0dccob.swift:9:46: error: value of type 'Int' has no member 'advancedBy'\n\
    \        let prefixIndex = strings.startIndex.advancedBy(0, maxDistance(prefix.utf8))\
    \ + 1\n                          ~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpgz0dccob.swift:11:72:\
    \ error: cannot find 'maxDistance' in scope\n            strings.removeSubrange(prefixIndex,\
    \ prefixIndex.advancedBy(maxDistance(prefix.utf8) - prefixIndex))\n          \
    \                                                             ^~~~~~~~~~~\n/tmp/tmpgz0dccob.swift:11:61:\
    \ error: extra argument in call\n            strings.removeSubrange(prefixIndex,\
    \ prefixIndex.advancedBy(maxDistance(prefix.utf8) - prefixIndex))\n          \
    \                        ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix_indexed(\n\
    \t\tstrings,\n\t\tprefix,\n\t\tstrings.Index,\n\t)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmphdtlocc5.swift:12:2: error: unexpected ',' separator\n        )\n\
    \        ^\n/tmp/tmphdtlocc5.swift:8:9: error: cannot find 'filter_by_prefix_indexed'\
    \ in scope\n        return filter_by_prefix_indexed(\n               ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphdtlocc5.swift:11:3: error: static member 'Index' cannot be used on instance\
    \ of type '[String]'\n                strings.Index,\n                ^~~~~~~\n\
    \                [String]\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered_strings = strings\n\
    \    for _ in 0..<strings.count {\n        let index = filtered_strings.index(of:\
    \ prefix)\n        guard index != nil else { continue }\n        filtered_strings.remove(at:\
    \ index!)\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == []\
    \ as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"\
    xxx\"])"
  status: Exception
  stderr: 'tmpkjuh4sz0/tmpkjuh4sz0.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf5ef78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf5ec6fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf5ec6f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf5ec6e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkjuh4sz0                        0x000055859f903a42 <unavailable> + 6722

    5    libc.so.6                          0x00002abf5f164460 __libc_start_main +
    245

    6    tmpkjuh4sz0                        0x000055859f9033b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    \n    let index = 0\n    while\
    \ index < strings.count && strings[index] != prefix {\n        index += 1\n  \
    \  }\n    \n    let result = [String]()\n    \n    if index != strings.count {\n\
    \        result.appendContentsOf(strings[index..<strings.count])\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0txb2w5h.swift:11:15: error: left side of mutating operator isn't\
    \ mutable: 'index' is a 'let' constant\n        index += 1\n        ~~~~~ ^\n\
    /tmp/tmp0txb2w5h.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let index = 0\n    ^~~\n    var\n/tmp/tmp0txb2w5h.swift:17:16: error: value\
    \ of type '[String]' has no member 'appendContentsOf'\n        result.appendContentsOf(strings[index..<strings.count])\n\
    \        ~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    \n    let filtered = strings.filter\
    \ {\n        $0.hasPrefix(prefix)\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  let re = RegExp(prefix.asRegExp())\n\
    \  return strings.filter {\n    re.hasMatchIn($0)\n  }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwbe8sr5s.swift:8:12: error: cannot find 'RegExp' in scope\n  let\
    \ re = RegExp(prefix.asRegExp())\n           ^~~~~~\n/tmp/tmpwbe8sr5s.swift:8:26:\
    \ error: value of type 'String' has no member 'asRegExp'\n  let re = RegExp(prefix.asRegExp())\n\
    \                  ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  var result = strings\n  result =\
    \ filter_by_prefix2(&result, prefix)\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn0hmdp25.swift:9:12: error: cannot find 'filter_by_prefix2' in\
    \ scope\n  result = filter_by_prefix2(&result, prefix)\n           ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt_150dr0.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, false)\n                           ~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  return filter_by_prefix_helper(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq91xhz51.swift:8:10: error: cannot find 'filter_by_prefix_helper'\
    \ in scope\n  return filter_by_prefix_helper(strings, prefix, true)\n        \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filterWithPrefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5wvxr7cj.swift:8:12: error: cannot find 'filterWithPrefix' in scope\n\
    \    return filterWithPrefix(strings, prefix, true)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  strings.filter({\n    if strings.startsWith(prefix)\
    \ {\n      return true\n    } else {\n      return false\n    }\n  })\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpebbeur2i.swift:8:18: error: contextual type for closure argument\
    \ list expects 1 argument, which cannot be implicitly ignored\n  strings.filter({\n\
    \                 ^\n                  _ in \n/tmp/tmpebbeur2i.swift:9:16: error:\
    \ value of type '[String]' has no member 'startsWith'\n    if strings.startsWith(prefix)\
    \ {\n       ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  if strings.Length <= 0 {\n    return\
    \ strings\n  }\n  let prefix_length = prefix.Length\n  guard !prefix.IsEmpty else\
    \ { return strings }\n  var result: [String] = []\n  for string in strings {\n\
    \    if string.Length >= prefix_length { // in case it's empty\n      if string.HasPrefix(prefix)\
    \ { // in case it's longer\n        result.append(string)\n      }\n    }\n  }\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxtmxqhxi.swift:8:14: error: value of type '[String]' has no member\
    \ 'Length'\n  if strings.Length <= 0 {\n     ~~~~~~~ ^~~~~~\n/tmp/tmpxtmxqhxi.swift:11:30:\
    \ error: value of type 'String' has no member 'Length'\n  let prefix_length =\
    \ prefix.Length\n                      ~~~~~~ ^~~~~~\n/tmp/tmpxtmxqhxi.swift:12:17:\
    \ error: value of type 'String' has no member 'IsEmpty'\n  guard !prefix.IsEmpty\
    \ else { return strings }\n         ~~~~~~ ^~~~~~~\n/tmp/tmpxtmxqhxi.swift:15:15:\
    \ error: value of type 'String' has no member 'Length'\n    if string.Length >=\
    \ prefix_length { // in case it's empty\n       ~~~~~~ ^~~~~~\n/tmp/tmpxtmxqhxi.swift:16:17:\
    \ error: value of type 'String' has no member 'HasPrefix'\n      if string.HasPrefix(prefix)\
    \ { // in case it's longer\n         ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(\n    \
    \    strings.map(String::init),\n        prefix: prefix.map(String::init),\n \
    \   )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxepumj64.swift:9:28: error: expected expression in list of expressions\n\
    \        strings.map(String::init),\n                           ^\n/tmp/tmpxepumj64.swift:9:33:\
    \ error: initializers may only be declared within a type\n        strings.map(String::init),\n\
    \                                ^\n/tmp/tmpxepumj64.swift:9:33: error: expected\
    \ '(' for initializer parameters\n        strings.map(String::init),\n       \
    \                         ^\n/tmp/tmpxepumj64.swift:9:9: error: missing argument\
    \ label 'strings:' in call\n        strings.map(String::init),\n        ^\n  \
    \      strings: \n/tmp/tmpxepumj64.swift:9:29: error: missing argument for parameter\
    \ 'prefix' in call\n        strings.map(String::init),\n                     \
    \       ^\n                            , prefix: <#String#>\n/tmp/tmpxepumj64.swift:7:6:\
    \ note: 'filter_by_prefix(strings:prefix:)' declared here\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n     ^\n/tmp/tmpxepumj64.swift:9:28:\
    \ error: missing argument for parameter #1 in call\n        strings.map(String::init),\n\
    \                           ^\n                           <#(String) throws ->\
    \ String#>\nSwift.Collection:2:28: note: 'map' declared here\n    @inlinable public\
    \ func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]\n     \
    \                      ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    strings.filter {\n        $0.hasPrefix(prefix)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    prefix = prefix.lowercased()\n\
    \    var strings = strings\n    for idx, s in strings.enumerated() {\n       \
    \ if s.lowercased().prefix(prefix) {\n            strings = strings[idx..<strings.count]\n\
    \            break\n        }\n    }\n    return strings\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2s6m8z6z.swift:10:12: error: expected 'in' after for-each pattern\n\
    \    for idx, s in strings.enumerated() {\n           ^\n/tmp/tmp2s6m8z6z.swift:10:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, s in strings.enumerated()\
    \ {\n           ^\n/tmp/tmp2s6m8z6z.swift:8:5: error: cannot assign to value:\
    \ 'prefix' is a 'let' constant\n    prefix = prefix.lowercased()\n    ^~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  var filtered = [String]()\n  for\
    \ s in strings {\n    if s.startsWith(prefix) {\n      filtered.append(s)\n  \
    \  }\n  }\n  return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgk2gg8wi.swift:10:10: error: value of type 'String' has no member\
    \ 'startsWith'\n    if s.startsWith(prefix) {\n       ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5r888w4h.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  let start_index = strings.startIndex.advanced(by:\
    \ prefix.startIndex)\n  return strings[start_index..<strings.endIndex]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkc56l_70.swift:8:60: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n  let start_index = strings.startIndex.advanced(by:\
    \ prefix.startIndex)\n                                                       \
    \    ^\n/tmp/tmpkc56l_70.swift:9:17: error: cannot convert return expression of\
    \ type 'ArraySlice<String>' to return type '[String]'\n  return strings[start_index..<strings.endIndex]\n\
    \         ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter(strings, prefixFilterImpl,\
    \ prefix)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxn6f8u85.swift:8:12: error: cannot find 'filter' in scope\n   \
    \ return filter(strings, prefixFilterImpl, prefix)\n           ^~~~~~\n/tmp/tmpxn6f8u85.swift:8:28:\
    \ error: cannot find 'prefixFilterImpl' in scope\n    return filter(strings, prefixFilterImpl,\
    \ prefix)\n                           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for s in strings {\n        if s.hasPrefix(prefix) {\n            filtered.append(s)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix_helper(strings,\
    \ prefix, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdfd1jsvg.swift:8:12: error: cannot find 'filter_by_prefix_helper'\
    \ in scope\n    return filter_by_prefix_helper(strings, prefix, 0)\n         \
    \  ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  let prefixes = prefix.characters.split(separator:\
    \ \"\")\n  return strings.filter({ $0.hasPrefix(prefixes) })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpf5d44s_s.swift:8:25: error: 'characters' is unavailable: Please\
    \ use String directly\n  let prefixes = prefix.characters.split(separator: \"\"\
    )\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpf5d44s_s.swift:9:40: error: cannot convert value of type\
    \ '[String.SubSequence]' (aka 'Array<Substring>') to expected argument type 'String'\n\
    \  return strings.filter({ $0.hasPrefix(prefixes) })\n                       \
    \                ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter{ str in\n\
    \        let substr = (str as NSString).substringWithRange(str.rangeOfString(prefix))\n\
    \        return substr != \"\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwthw6qg9.swift:9:30: error: cannot find type 'NSString' in scope\n\
    \        let substr = (str as NSString).substringWithRange(str.rangeOfString(prefix))\n\
    \                             ^~~~~~~~\n/tmp/tmpwthw6qg9.swift:9:63: error: value\
    \ of type 'String' has no member 'rangeOfString'\n        let substr = (str as\
    \ NSString).substringWithRange(str.rangeOfString(prefix))\n                  \
    \                                        ~~~ ^~~~~~~~~~~~~\n/tmp/tmpwthw6qg9.swift:9:40:\
    \ error: value of type 'String' has no member 'substringWithRange'\n        let\
    \ substr = (str as NSString).substringWithRange(str.rangeOfString(prefix))\n \
    \                    ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let filtered = strings.filter {\n\
    \        ($0.hasPrefix(prefix))\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif strings.IsEmpty(prefix) {\n\t\t\
    return strings\n\t}\n\tvar result = strings\n\tfor _, s := range strings {\n\t\
    \tif strings.HasPrefix(s, prefix) {\n\t\t\tresult = append(result, s)\n\t\t}\n\
    \t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpklef1d_s.swift:12:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmpklef1d_s.swift:12:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n/tmp/tmpklef1d_s.swift:8:13: error: value of type\
    \ '[String]' has no member 'IsEmpty'\n        if strings.IsEmpty(prefix) {\n \
    \          ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter {\n     \
    \   $0.hasPrefix(prefix)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({ $0.hasPrefix(prefix)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar filtered = [String]()\n\n\tfor\
    \ i := 0; i < len(strings); i++ {\n\t\tif strings.HasPrefix(strings[i], prefix)\
    \ {\n\t\t\tfiltered = append(filtered, strings[i])\n\t\t}\n\t}\n\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzf4z7kpq.swift:10:9: error: expected type\n        for i := 0;\
    \ i < len(strings); i++ {\n               ^\n                <#type#>\n/tmp/tmpzf4z7kpq.swift:10:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(strings);\
    \ i++ {\n               ^\n/tmp/tmpzf4z7kpq.swift:10:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(strings); i++ {\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    for s in strings {\n        if\
    \ s.hasPrefix(prefix) {\n            return strings\n        }\n    }\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: []\
    \ as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: Exception
  stderr: 'tmp8uk7bhm2/tmp8uk7bhm2.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f2d5ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f2d2d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f2d2d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f2d2d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uk7bhm2                        0x000055987f5e1912 <unavailable> + 6418

    5    libc.so.6                          0x00002b8f2d7c9460 __libc_start_main +
    245

    6    tmp8uk7bhm2                        0x000055987f5e1289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz8wq5szy.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpz8wq5szy.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(\n    \
    \    strings: strings,\n        prefix: prefix,\n        pred: func(s string)\
    \ bool {\n            return strings.HasPrefix(s, prefix)\n        },\n    )\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmprcb5_r28.swift:11:15: error: expected expression in list of expressions\n\
    \        pred: func(s string) bool {\n              ^\n/tmp/tmprcb5_r28.swift:11:19:\
    \ error: expected identifier in function declaration\n        pred: func(s string)\
    \ bool {\n                  ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter { (value)\
    \ -> Bool in\n        let prefixLength = value.prefixIndex(of: prefix)\n     \
    \   return prefixLength == 0 ||\n            (prefixLength > 0 && value.startIndex..<value.index(before:\
    \ prefixLength))\n            == value.startIndex..<value.index(before: value.index(before:\
    \ prefixLength))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpujo6z109.swift:9:34: error: value of type 'String' has no member\
    \ 'prefixIndex'\n        let prefixLength = value.prefixIndex(of: prefix)\n  \
    \                         ~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5r888w4h.swift:8:43: error: extra argument in call\n        return\
    \ filter_by_prefix(strings, prefix, true)\n                               ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    filter_by_prefix_helper(strings,\
    \ prefix, \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoypgmvr8.swift:8:5: error: cannot find 'filter_by_prefix_helper'\
    \ in scope\n    filter_by_prefix_helper(strings, prefix, \"\")\n    ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.isEmpty() {\n      \
    \  return strings\n    }\n    return strings.filter { $0.hasPrefix(prefix) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp27u68wfh.swift:8:16: error: cannot call value of non-function type\
    \ 'Bool'\n    if strings.isEmpty() {\n               ^      ~~\n             \
    \         \n"
  stdout: ''
  timestamp: 1659978977
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    for string in strings {\n     \
    \   if string.hasPrefix(prefix) {\n            return strings\n        }\n   \
    \ }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: Exception
  stderr: 'tmpja0hqewv/tmpja0hqewv.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c809adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c806a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7c806a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7c806a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpja0hqewv                        0x0000555db01c0912 <unavailable> + 6418

    5    libc.so.6                          0x00002b7c80b99460 __libc_start_main +
    245

    6    tmpja0hqewv                        0x0000555db01c0289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  switch strings.len {\n  case 0:\n\
    \    return strings\n  case 1:\n    if strings[0] == prefix {\n      return strings\n\
    \    } else {\n      return [\"\"]\n    }\n  default:\n    return strings.filter({\
    \ $0.hasPrefix(prefix) })\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpuc6n_rte.swift:8:18: error: value of type '[String]' has no member\
    \ 'len'\n  switch strings.len {\n         ~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tif strings.IsEmpty(prefix) {\n\t\t\
    return strings\n\t}\n\tsort.Strings(strings)\n\tlastNonEmptyIndex := len(strings)\
    \ - 1\n\tvar output [lastNonEmptyIndex]string\n\tfor i, input := range strings\
    \ {\n\t\tif strings.HasPrefix(input, prefix) {\n\t\t\toutput[i] = input\n\t\t\t\
    lastNonEmptyIndex = i\n\t\t}\n\t}\n\treturn output\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmppx9js_2r.swift:12:19: error: consecutive statements on a line must\
    \ be separated by ';'\n        lastNonEmptyIndex := len(strings) - 1\n       \
    \                  ^\n                         ;\n/tmp/tmppx9js_2r.swift:12:20:\
    \ error: expected expression\n        lastNonEmptyIndex := len(strings) - 1\n\
    \                          ^\n/tmp/tmppx9js_2r.swift:13:12: error: consecutive\
    \ statements on a line must be separated by ';'\n        var output [lastNonEmptyIndex]string\n\
    \                  ^\n                  ;\n/tmp/tmppx9js_2r.swift:13:32: error:\
    \ consecutive statements on a line must be separated by ';'\n        var output\
    \ [lastNonEmptyIndex]string\n                                      ^\n       \
    \                               ;\n/tmp/tmppx9js_2r.swift:14:7: error: expected\
    \ 'in' after for-each pattern\n        for i, input := range strings {\n     \
    \        ^\n/tmp/tmppx9js_2r.swift:14:7: error: expected Sequence expression for\
    \ for-each loop\n        for i, input := range strings {\n             ^\n/tmp/tmppx9js_2r.swift:8:13:\
    \ error: value of type '[String]' has no member 'IsEmpty'\n        if strings.IsEmpty(prefix)\
    \ {\n           ~~~~~~~ ^~~~~~~\n/tmp/tmppx9js_2r.swift:11:2: error: cannot find\
    \ 'sort' in scope\n        sort.Strings(strings)\n        ^~~~\n/tmp/tmppx9js_2r.swift:12:2:\
    \ error: cannot find 'lastNonEmptyIndex' in scope\n        lastNonEmptyIndex :=\
    \ len(strings) - 1\n        ^~~~~~~~~~~~~~~~~\n/tmp/tmppx9js_2r.swift:13:6: error:\
    \ type annotation missing in pattern\n        var output [lastNonEmptyIndex]string\n\
    \            ^\n/tmp/tmppx9js_2r.swift:13:14: error: cannot find 'lastNonEmptyIndex'\
    \ in scope\n        var output [lastNonEmptyIndex]string\n                   \
    \ ^~~~~~~~~~~~~~~~~\n/tmp/tmppx9js_2r.swift:13:32: error: cannot find 'string'\
    \ in scope\n        var output [lastNonEmptyIndex]string\n                   \
    \                   ^~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let index = strings.firstIndex(where:\
    \ {$0.hasPrefix(prefix)})\n    if index != -1 { return strings.prefix(index) }\n\
    \    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmphmbng_nn.swift:9:44: error: value of optional type 'Array<String>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<String>.Index'\
    \ (aka 'Int')\n    if index != -1 { return strings.prefix(index) }\n         \
    \                                  ^\n/tmp/tmphmbng_nn.swift:9:44: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ if index != -1 { return strings.prefix(index) }\n                          \
    \                 ^\n                                                 ?? <#default\
    \ value#>\n/tmp/tmphmbng_nn.swift:9:44: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    if index != -1 { return\
    \ strings.prefix(index) }\n                                           ^\n    \
    \                                            !\n/tmp/tmphmbng_nn.swift:9:37: error:\
    \ no 'prefix' candidates produce the expected contextual result type '[String]'\n\
    \    if index != -1 { return strings.prefix(index) }\n                       \
    \             ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<[String]>',\
    \ not the expected contextual result type '[String]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'ArraySlice<String>',\
    \ not the expected contextual result type '[String]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    guard strings.count > 0 else {\n\
    \        return strings\n    }\n    var filtered = [String]()\n    for string\
    \ in strings {\n        if string.hasPrefix(prefix) {\n            filtered.append(string)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if let prefix = prefix.lowercased()\
    \ {\n        let matchedStrings = strings.filter({ $0.hasPrefix(prefix) })\n \
    \       return matchedStrings\n    } else {\n        return strings\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl5fwk5my.swift:8:8: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    if let prefix = prefix.lowercased()\
    \ {\n       ^            ~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered: [String] = []\n \
    \   for s in strings {\n        if s.startsWith(prefix) {\n            filtered\
    \ = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpz8wq5szy.swift:10:14: error: value of type 'String' has no member\
    \ 'startsWith'\n        if s.startsWith(prefix) {\n           ~ ^~~~~~~~~~\n/tmp/tmpz8wq5szy.swift:11:24:\
    \ error: cannot find 'append' in scope\n            filtered = append(filtered,\
    \ s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return strings\n    }\n    if prefix != \"\" && strings.Length <= 1 {\n   \
    \     return strings\n    }\n    var result = [String]()\n    for i := 0; i <\
    \ strings.Length; i++ {\n        if strings.StartsWith(strings[i], prefix) {\n\
    \            result = append(result, strings[i])\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg66fn5_1.swift:15:12: error: expected type\n    for i := 0; i <\
    \ strings.Length; i++ {\n           ^\n            <#type#>\n/tmp/tmpg66fn5_1.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < strings.Length;\
    \ i++ {\n           ^\n/tmp/tmpg66fn5_1.swift:15:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < strings.Length; i++ {\n  \
    \         ^\n/tmp/tmpg66fn5_1.swift:8:16: error: value of type '[String]' has\
    \ no member 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpg66fn5_1.swift:11:32:\
    \ error: value of type '[String]' has no member 'Length'\n    if prefix != \"\"\
    \ && strings.Length <= 1 {\n                       ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\tvar result = [String]()\n\tfor _,\
    \ s := range strings {\n\t\tif strings.HasPrefix(s, prefix) {\n\t\t\tresult =\
    \ append(result, s)\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmphkk9h6oe.swift:9:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmphkk9h6oe.swift:9:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix_internal(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbqu8p1qs.swift:8:9: error: cannot find 'filter_by_prefix_internal'\
    \ in scope\n        return filter_by_prefix_internal(strings, prefix, true)\n\
    \               ^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = strings\n    for\
    \ _item in strings {\n        if _item.startsWith(prefix) {\n            filtered\
    \ = [_item]\n            break\n        }\n    }\n    return filtered\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmoo8kngp.swift:10:18: error: value of type 'String' has no member\
    \ 'startsWith'\n        if _item.startsWith(prefix) {\n           ~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter({\n     \
    \   let first = $0.prefix(from: prefix)\n        return !first.contains(prefix)\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv6uspg4h.swift:9:30: error: extraneous argument label 'from:' in\
    \ call\n        let first = $0.prefix(from: prefix)\n                        \
    \     ^~~~~~~\n                              \n/tmp/tmpv6uspg4h.swift:9:37: error:\
    \ cannot convert value of type 'String' to expected argument type 'Int'\n    \
    \    let first = $0.prefix(from: prefix)\n                                   \
    \ ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if strings.IsEmpty() {\n      \
    \  return []\n    }\n    \n    // TODO: Optimize for small strings and common\
    \ prefixes.\n    \n    let len = prefix.characters.count\n    let lower = strings.map\
    \ {\n        $0.lowercasedStringWithLocale(NSLocale(localeIdentifier: \"en_US_POSIX\"\
    ))\n    }\n    \n    var result = [String]()\n    \n    for str in strings {\n\
    \        if str.startsWith(prefix) {\n            result.append(str)\n       \
    \ }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6tzsrhe7.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmp6tzsrhe7.swift:14:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    let len\
    \ = prefix.characters.count\n                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp6tzsrhe7.swift:16:39: error: cannot find\
    \ 'NSLocale' in scope\n        $0.lowercasedStringWithLocale(NSLocale(localeIdentifier:\
    \ \"en_US_POSIX\"))\n                                      ^~~~~~~~\n/tmp/tmp6tzsrhe7.swift:22:16:\
    \ error: value of type 'String' has no member 'startsWith'\n        if str.startsWith(prefix)\
    \ {\n           ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = strings\n    for\
    \ _str in strings {\n        if _str.startsWith(prefix) {\n            filtered\
    \ = filtered.filter() { $0 != _str }\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr2v_31rj.swift:10:17: error: value of type 'String' has no member\
    \ 'startsWith'\n        if _str.startsWith(prefix) {\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn removePrefix(strings, prefix)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmphu590tq3.swift:8:9: error: cannot find 'removePrefix' in scope\n\
    \        return removePrefix(strings, prefix)\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    prefixLen := prefix.characters.count\n\
    \    var filtered: [String] = []\n    for input in strings {\n        if input.hasPrefix(prefix)\
    \ {\n            filtered = append(filtered, input)\n        }\n    }\n    return\
    \ filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2jy9ctbr.swift:8:14: error: consecutive statements on a line must\
    \ be separated by ';'\n    prefixLen := prefix.characters.count\n            \
    \ ^\n             ;\n/tmp/tmp2jy9ctbr.swift:8:15: error: expected expression\n\
    \    prefixLen := prefix.characters.count\n              ^\n/tmp/tmp2jy9ctbr.swift:8:5:\
    \ error: cannot find 'prefixLen' in scope\n    prefixLen := prefix.characters.count\n\
    \    ^~~~~~~~~\n/tmp/tmp2jy9ctbr.swift:12:24: error: cannot find 'append' in scope\n\
    \            filtered = append(filtered, input)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let filtered = strings.filter({\
    \ $0.hasPrefix(prefix) })\n    return filtered as [String]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let prefixLength = prefix.count\n\
    \    return strings.filter {\n        let index = $0.startIndex\n        return\
    \ index >= 0 && index < $0.endIndex && $0.hasPrefix(prefix)\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnzi8bxh6.swift:11:22: error: referencing operator function '>='\
    \ on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \        return index >= 0 && index < $0.endIndex && $0.hasPrefix(prefix)\n  \
    \                   ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\n\
    extension BinaryInteger {\n          ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var results = strings.filter({\
    \ $0.hasPrefix(prefix) })\n    if results.isEmpty {\n        return strings\n\
    \    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var results = make([]String, 0)\n\
    \    for _, s := range strings {\n        if strings.HasPrefix(s, prefix) {\n\
    \            results = append(results, s)\n        }\n    }\n    return results\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpng00rrj5.swift:8:26: error: expected ',' separator\n    var results\
    \ = make([]String, 0)\n                         ^\n                         ,\n\
    /tmp/tmpng00rrj5.swift:9:10: error: expected 'in' after for-each pattern\n   \
    \ for _, s := range strings {\n         ^\n/tmp/tmpng00rrj5.swift:9:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, s := range strings\
    \ {\n         ^\n/tmp/tmpng00rrj5.swift:8:19: error: cannot find 'make' in scope\n\
    \    var results = make([]String, 0)\n                  ^~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  return filter_by_prefix_helper(strings,\
    \ prefix, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv6uuohcc.swift:8:10: error: cannot find 'filter_by_prefix_helper'\
    \ in scope\n  return filter_by_prefix_helper(strings, prefix, 0)\n         ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n\treturn filter_by_prefix_impl(strings,\
    \ prefix, func(a, b int) bool {\n\t\treturn a[:b] == prefix\n\t})\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmphxfmtr8u.swift:8:48: error: expected expression in list of expressions\n\
    \        return filter_by_prefix_impl(strings, prefix, func(a, b int) bool {\n\
    \                                                      ^\n/tmp/tmphxfmtr8u.swift:8:52:\
    \ error: expected identifier in function declaration\n        return filter_by_prefix_impl(strings,\
    \ prefix, func(a, b int) bool {\n                                            \
    \              ^\n/tmp/tmphxfmtr8u.swift:8:9: error: cannot find 'filter_by_prefix_impl'\
    \ in scope\n        return filter_by_prefix_impl(strings, prefix, func(a, b int)\
    \ bool {\n               ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filterArray(prefixedHasPrefix(strings),\
    \ prefix)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpukut76xd.swift:8:12: error: cannot find 'filterArray' in scope\n\
    \    return filterArray(prefixedHasPrefix(strings), prefix)\n           ^~~~~~~~~~~\n\
    /tmp/tmpukut76xd.swift:8:24: error: cannot find 'prefixedHasPrefix' in scope\n\
    \    return filterArray(prefixedHasPrefix(strings), prefix)\n                \
    \       ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var filtered = [String]()\n   \
    \ for string in strings {\n        if string.startsWith(prefix) {\n          \
    \  filtered.append(string)\n        }\n    }\n    return filtered\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpchykis1a.swift:10:19: error: value of type 'String' has no member\
    \ 'startsWith'\n        if string.startsWith(prefix) {\n           ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return filter_by_prefix(strings,\
    \ prefix, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings:\
    \ [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\"\
    ) == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpctkibwb5.swift:8:46: error: extra argument in call\n    return\
    \ filter_by_prefix(strings, prefix, true)\n                           ~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659978976
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    if prefix != \"\" {\n        strings\
    \ = strings.filter { (s) -> (Bool) in\n            return s.hasPrefix(prefix)\n\
    \        }\n    }\n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4rqfhmht.swift:9:9: error: cannot assign to value: 'strings' is\
    \ a 'let' constant\n        strings = strings.filter { (s) -> (Bool) in\n    \
    \    ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    var result = Array(strings)\n \
    \   for i := range result {\n        if result[i] != prefix {\n            result\
    \ = result.filter{$0 != result[i]}\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmg9h6l9x.swift:9:12: error: expected type\n    for i := range result\
    \ {\n           ^\n            <#type#>\n/tmp/tmpmg9h6l9x.swift:9:12: error: expected\
    \ 'in' after for-each pattern\n    for i := range result {\n           ^\n/tmp/tmpmg9h6l9x.swift:9:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := range result\
    \ {\n           ^\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n  let filtered = strings\n    .filter\
    \ { (s) in\n      s.hasPrefix(prefix)\n    }\n  return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\"\
    ) == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978978
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    return strings.filter { (a) in\n\
    \        a.hasPrefix(prefix)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\n\
    assert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"\
    xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978978
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let filteredStrings = strings.filter\
    \ {\n        ($0.hasPrefix(prefix)) ?? false\n    }\n    return filteredStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978978
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that start with a\
    \ given prefix.\n/// >>> filter_by_prefix(strings: [] as [String], prefix: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_prefix(strings: [\"abc\", \"bcd\"\
    , \"cde\", \"array\"], prefix: \"a\")\n/// [\"abc\", \"array\"]\nfunc filter_by_prefix(strings:\
    \ [String], prefix: String) -> [String] {\n    let prefix_length = prefix.characters.count\n\
    \    return strings.filter { (text) -> Bool in\n        let text_length = text.characters.count\n\
    \        return text_length >= prefix_length && prefix.hasPrefix(text)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix:\
    \ \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"\
    asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsx3rh73u.swift:8:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let prefix_length = prefix.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpsx3rh73u.swift:10:32: error: 'characters' is unavailable:\
    \ Please use String directly\n        let text_length = text.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978977
