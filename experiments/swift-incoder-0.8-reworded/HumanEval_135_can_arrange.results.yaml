language: swift
name: HumanEval_135_can_arrange
results:
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  let len = arr.count\n  for i in 0..<len - 1 {\n    if arr[i]\
    \ < arr[i + 1] {\n      return i\n    }\n  }\n  return len\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpva3ip8g1/tmpva3ip8g1.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b86835c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b8652cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b8652c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b8652b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpva3ip8g1                        0x000055582d530552 <unavailable> + 5458

    5    libc.so.6                          0x00002b1b86a21460 __libc_start_main +
    245

    6    tmpva3ip8g1                        0x000055582d5301a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = -1\n    for idx in 0..<arr.count {\n        if\
    \ arr[max] > arr[idx] {\n            max = idx\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af45abcbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af45a8c2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af45a8c2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af45a8c213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af45a8c1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af45a6c1e83 <unavailable> + 188035

    6    tmpvi0c99jo                        0x00005597fae98a10 <unavailable> + 6672

    7    tmpvi0c99jo                        0x00005597fae984d4 <unavailable> + 5332

    8    libc.so.6                          0x00002af45adb7460 __libc_start_main +
    245

    9    tmpvi0c99jo                        0x00005597fae981a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count >= 2 else { return -1 }\n    var maxIndex\
    \ = -1\n    var prev: Int = 0\n    \n    for i in 0..<arr.count - 1 {\n      \
    \  if arr[i] >= arr[prev] {\n            max = arr[i]\n            maxIndex =\
    \ i\n        } else {\n            prev = i\n        }\n    }\n    \n    return\
    \ maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp9c5u7umw.swift:18:13: error: no exact matches in reference to global\
    \ function 'max'\n            max = arr[i]\n            ^\n/tmp/tmp9c5u7umw.swift:18:13:\
    \ note: found candidate with type '(_, _) -> _'\n            max = arr[i]\n  \
    \          ^\n/tmp/tmp9c5u7umw.swift:18:13: note: found candidate with type '(_,\
    \ _, _, _...) -> _'\n            max = arr[i]\n            ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.count <= 1 {\n        return -1\n    }\n    var\
    \ max = 0\n    for i in 0..<arr.count {\n        if arr[i] > arr[max] {\n    \
    \        max = i\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpk8n3wlbb/tmpk8n3wlbb.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bb7758c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bb744fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bb744f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bb744e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk8n3wlbb                        0x000055a1ad527552 <unavailable> + 5458

    5    libc.so.6                          0x00002b2bb7944460 __libc_start_main +
    245

    6    tmpk8n3wlbb                        0x000055a1ad5271a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard !arr.isEmpty else { return -1 }\n    var index =\
    \ 0\n    while index < arr.count && arr[index] > arr[index - 1] {\n        index\
    \ += 1\n    }\n    return index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac292ad0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2927c7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac2927c7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac2927c713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac2927c6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac2925c6e83 <unavailable> + 188035

    6    tmpktxsnoy4                        0x00005645909318a1 <unavailable> + 6305

    7    tmpktxsnoy4                        0x00005645909313d4 <unavailable> + 5076

    8    libc.so.6                          0x00002ac292cbc460 __libc_start_main +
    245

    9    tmpktxsnoy4                        0x00005645909310a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    for index in 0..<arr.count {\n        if arr[index] !=\
    \ arr[index-1] {\n            return index\n        }\n    }\n    return -1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aca4d671c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca4d368561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aca4d368286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aca4d36813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aca4d367bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aca4d167e83 <unavailable> + 188035

    6    tmpnasox1tm                        0x0000558eb372ea2c <unavailable> + 6700

    7    tmpnasox1tm                        0x0000558eb372e4d4 <unavailable> + 5332

    8    libc.so.6                          0x00002aca4d85d460 __libc_start_main +
    245

    9    tmpnasox1tm                        0x0000558eb372e1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = 0\n    for idx in 0..<arr.count {\n        if\
    \ idx == 0 || arr[idx] > arr[idx - 1] {\n            max = idx\n            break\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp_93ic6zf/tmp_93ic6zf.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af50142cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af501123b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af501123988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5011227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_93ic6zf                        0x000055e97f7b2552 <unavailable> + 5458

    5    libc.so.6                          0x00002af501618460 __libc_start_main +
    245

    6    tmp_93ic6zf                        0x000055e97f7b21a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = 0\n    for v in arr {\n        if v > max {\n\
    \            max = v\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp2xf3nqx0/tmp2xf3nqx0.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3690f5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3690c52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3690c52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3690c517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2xf3nqx0                        0x000055ea8983c482 <unavailable> + 5250

    5    libc.so.6                          0x00002b3691147460 __libc_start_main +
    245

    6    tmp2xf3nqx0                        0x000055ea8983c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var index = -1\n\n    for i in 0..<arr.count {\n      \
    \  if arr[i] >= arr[index] {\n            index = i\n        }\n    }\n\n    return\
    \ index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2,\
    \ 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b27963b3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27960aa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b27960aa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b27960aa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b27960a9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2795ea9e83 <unavailable> + 188035

    6    tmpyjrx9p05                        0x000055b6af974a28 <unavailable> + 6696

    7    tmpyjrx9p05                        0x000055b6af9744d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b279659f460 __libc_start_main +
    245

    9    tmpyjrx9p05                        0x000055b6af9741a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    \n    var left = 0\n    var right = arr.count\n    \n \
    \   guard right > 0 else { return -1 }\n    \n    while left < right {\n     \
    \   \n        let middle = (left + right) / 2 // integer\n        \n        if\
    \ arr[middle] > middle { left = middle + 1 }\n        else { right = middle -\
    \ 1 }\n    }\n    \n    return left\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: Exception
  stderr: 'tmpae95riuy/tmpae95riuy.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad059d5ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad059a51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad059a51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad059a507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpae95riuy                        0x0000555fa1cfd462 <unavailable> + 5218

    5    libc.so.6                          0x00002ad059f46460 __libc_start_main +
    245

    6    tmpae95riuy                        0x0000555fa1cfd0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return min(arr.count, arr.compactMap {\n        let lastIndex\
    \ = arr.count - 1\n        let firstIndex = $0\n        if $0 <= lastIndex - 1\
    \ && lastIndex > firstIndex {\n            return $0\n        }\n        return\
    \ -1\n    }.firstIndex(of: -1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpns_950yp.swift:19:7: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    }.firstIndex(of: -1))\n      ^\n\
    /tmp/tmpns_950yp.swift:19:7: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    }.firstIndex(of: -1))\n      ^\n    \
    \                     ?? <#default value#>\n/tmp/tmpns_950yp.swift:19:7: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    }.firstIndex(of: -1))\n      ^\n                        !\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = -1\n    var candidate: Int = 0\n    for\
    \ index in 0 ..< arr.count {\n        if arr[index] > candidate {\n          \
    \  candidate = arr[index]\n            maxIndex = index\n        }\n    }\n  \
    \  return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpp7cxv9pe/tmpp7cxv9pe.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20ef87bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20ef572b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20ef572988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20ef5717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp7cxv9pe                        0x000056414dc95552 <unavailable> + 5458

    5    libc.so.6                          0x00002b20efa67460 __libc_start_main +
    245

    6    tmpp7cxv9pe                        0x000056414dc951a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return maxIndexOf(arr, arr.last!) + 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp64el_pl7.swift:12:12: error: cannot find 'maxIndexOf' in scope\n\
    \    return maxIndexOf(arr, arr.last!) + 1\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  if arr.count < 2 {\n    return -1\n  }\n\n  guard arr.count\
    \ > 1 else {\n    return 0\n  }\n\n  for index in 0..<arr.count {\n    if index\
    \ < arr.count - 1 && !arr[index + 1] <= arr[index] {\n      return index\n   \
    \ }\n  }\n\n  return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp96p5jscn.swift:21:37: error: type 'Int' cannot be used as a boolean;\
    \ test for '== 0' instead\n    if index < arr.count - 1 && !arr[index + 1] <=\
    \ arr[index] {\n                                ~   ^\n                      \
    \           (              == 0)\n/tmp/tmp96p5jscn.swift:21:33: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Int'\n    if index <\
    \ arr.count - 1 && !arr[index + 1] <= arr[index] {\n                         \
    \       ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty {\n        return -1\n    }\n    var maxIdx:\
    \ Int = 0\n    var maxVal: Int = arr[0]\n    for idx in 1..<arr.count {\n    \
    \    if arr[idx] > maxVal {\n            maxVal = arr[idx]\n            maxIdx\
    \ = idx\n        }\n    }\n    return maxIdx\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpu10oks6q/tmpu10oks6q.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3679e0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3679b06b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3679b06988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3679b057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu10oks6q                        0x000055898ae975e2 <unavailable> + 5602

    5    libc.so.6                          0x00002b3679ffb460 __libc_start_main +
    245

    6    tmpu10oks6q                        0x000055898ae97239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = Int()\n    var firstIndex = Int()\n    for\
    \ element in arr {\n        if element > largest {\n            largest = element\n\
    \            firstIndex = element\n        } else {\n            if element ==\
    \ largest {\n                if element != firstIndex {\n                    largest\
    \ = element\n                }\n            } else {\n                return -1\n\
    \            }\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmphd6slrci/tmphd6slrci.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaba9c30c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaba9927b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaba9927988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaba99267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphd6slrci                        0x000055b23a41e482 <unavailable> + 5250

    5    libc.so.6                          0x00002aaba9e1c460 __libc_start_main +
    245

    6    tmphd6slrci                        0x000055b23a41e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count >= 2 else {\n        return -1\n    }\n\
    \n    guard arr[0] != arr[1] else {\n        return -1\n    }\n\n    var highest\
    \ = arr[0]\n    for i in arr where i != highest {\n        highest = i\n    }\n\
    \n    return highest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpe26tja0p/tmpe26tja0p.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a08700c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a083f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a083f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a083f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe26tja0p                        0x000055b9b2055532 <unavailable> + 5426

    5    libc.so.6                          0x00002b5a088ec460 __libc_start_main +
    245

    6    tmpe26tja0p                        0x000055b9b2055189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count > 0 else {\n        return -1\n    }\n\n\
    \    if arr[0] != arr[0] {\n        return -1\n    }\n\n    if arr.count < 2 {\
    \ return arr.count }\n\n    var i = 2\n    for value in arr {\n        if value\
    \ > arr[i] {\n            i += 1\n        }\n    }\n    return i\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpe4ysbz08/tmpe4ysbz08.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8fde737c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8fde42eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8fde42e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8fde42d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe4ysbz08                        0x00005591f2dff5ff <unavailable> + 5631

    5    libc.so.6                          0x00002b8fde923460 __libc_start_main +
    245

    6    tmpe4ysbz08                        0x00005591f2dff189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var index = 0\n    var max = -1\n    for n in arr {\n \
    \       if n <= arr[index] {\n            max = index\n        }\n        index++\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpvlneh8n7.swift:18:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.count < 2 {\n        return -1\n    }\n    var maxIndex\
    \ = 0\n    for index in 0..<arr.count - 1 {\n        if arr[index] > arr[index+1]\
    \ {\n            maxIndex = index + 1\n        }\n    }\n    return maxIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpnaacxfzy/tmpnaacxfzy.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac622bcec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6228c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6228c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6228c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnaacxfzy                        0x00005639c3b4961f <unavailable> + 5663

    5    libc.so.6                          0x00002ac622dba460 __libc_start_main +
    245

    6    tmpnaacxfzy                        0x00005639c3b491a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  if arr.count < 2 { return -1 }\n  let pivot = arr.sort()[0]\n\
    \  for index in 0..<arr.count-1 {\n    if arr[index] >= pivot {\n      return\
    \ index\n    }\n  }\n  return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmptvl529pv.swift:13:19: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n  let pivot = arr.sort()[0]\n            \
    \  ~~~ ^\n/tmp/tmptvl529pv.swift:13:25: error: value of type '()' has no subscripts\n\
    \  let pivot = arr.sort()[0]\n              ~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  // TODO\n  \n  return -1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp_sfb2mwx/tmp_sfb2mwx.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af9d32f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af9d2fedb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af9d2fed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af9d2fec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_sfb2mwx                        0x0000561eceefb312 <unavailable> + 4882

    5    libc.so.6                          0x00002af9d34e2460 __libc_start_main +
    245

    6    tmp_sfb2mwx                        0x0000561eceefaf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return arr.max()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp2l6u984c.swift:12:16: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return arr.max()\n              \
    \ ^\n/tmp/tmp2l6u984c.swift:12:16: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n    return arr.max()\n             \
    \  ^\n                     ?? <#default value#>\n/tmp/tmp2l6u984c.swift:12:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return arr.max()\n               ^\n                    !\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largestIndex = -1\n    var currentValue = arr[0]\n\n\
    \    for i in 0 ..< arr.count {\n        if arr[i] <= currentValue {\n       \
    \     currentValue = arr[i]\n            largestIndex = i\n        }\n    }\n\
    \    return largestIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpzzo7t9rw/tmpzzo7t9rw.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4904d8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4904a86b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4904a86988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4904a857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzzo7t9rw                        0x00005581d4b66552 <unavailable> + 5458

    5    libc.so.6                          0x00002b4904f7b460 __libc_start_main +
    245

    6    tmpzzo7t9rw                        0x00005581d4b661a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var result = 0\n  var max = 0\n  for var i = 0; i < arr.count\
    \ - 1; i++ {\n    if arr[i] > max {\n      max = arr[i]\n      result = i\n  \
    \  }\n  }\n  if arr[0] != max {\n    result = -1\n  }\n  return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpmot6ynvc.swift:14:3: error: C-style for statement has been removed\
    \ in Swift 3\n  for var i = 0; i < arr.count - 1; i++ {\n  ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    for i : Int  in arr {\n        if i > arr[i-1] {\n    \
    \        return i\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmppybtfau7/tmppybtfau7.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd92757c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd9244eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd9244e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd9244d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppybtfau7                        0x000056528db894d2 <unavailable> + 5330

    5    libc.so.6                          0x00002acd92943460 __libc_start_main +
    245

    6    tmppybtfau7                        0x000056528db89129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let mut max = -1\n    arr.enumerate().forEach { i, v in\n\
    \        if v <= max {\n            max = v\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpk_4947w9.swift:12:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut max = -1\n\
    \            ^\n/tmp/tmpk_4947w9.swift:12:13: note: join the identifiers together\n\
    \    let mut max = -1\n        ~~~~^~~\n        mutmax\n/tmp/tmpk_4947w9.swift:12:13:\
    \ note: join the identifiers together with camel-case\n    let mut max = -1\n\
    \        ~~~~^~~\n        mutMax\n/tmp/tmpk_4947w9.swift:14:17: error: generic\
    \ parameter 'T' could not be inferred\n        if v <= max {\n               \
    \ ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public func max<T>(_\
    \ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpk_4947w9.swift:13:9:\
    \ error: value of type '[Int]' has no member 'enumerate'\n    arr.enumerate().forEach\
    \ { i, v in\n    ~~~ ^~~~~~~~~\n/tmp/tmpk_4947w9.swift:18:12: error: generic parameter\
    \ 'T' could not be inferred\n    return max\n           ^\nSwift.max:1:24: note:\
    \ in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpk_4947w9.swift:18:12:\
    \ error: no 'max' candidates produce the expected contextual result type 'Int'\n\
    \    return max\n           ^\nSwift.max:1:24: note: found candidate with type\
    \ '(_, _) -> _'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\nSwift.max:1:24: note: found candidate\
    \ with type '(_, _, _, _...) -> _'\n@inlinable public func max<T>(_ x: T, _ y:\
    \ T, _ z: T, _ rest: T...) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    arr.sort()\n    if arr.last == 0 || arr.last > arr[arr.first\
    \ - 1] {\n        return -1\n    }\n    return arr.first - 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpwlse80y3.swift:12:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n/tmp/tmpwlse80y3.swift:13:29:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    if arr.last == 0 || arr.last > arr[arr.first - 1] {\n                   \
    \         ^\n/tmp/tmpwlse80y3.swift:13:29: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    if arr.last == 0 || arr.last\
    \ > arr[arr.first - 1] {\n                            ^\n                    \
    \             ?? <#default value#>\n/tmp/tmpwlse80y3.swift:13:29: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    if arr.last\
    \ == 0 || arr.last > arr[arr.first - 1] {\n                            ^\n   \
    \                             !\n/tmp/tmpwlse80y3.swift:13:44: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n    if arr.last\
    \ == 0 || arr.last > arr[arr.first - 1] {\n                                  \
    \         ^\n/tmp/tmpwlse80y3.swift:13:44: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    if arr.last == 0 || arr.last\
    \ > arr[arr.first - 1] {\n                                           ^\n     \
    \                                  (         ?? <#default value#>)\n/tmp/tmpwlse80y3.swift:13:44:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    if arr.last == 0 || arr.last > arr[arr.first - 1] {\n           \
    \                                ^\n                                         \
    \       !\n/tmp/tmpwlse80y3.swift:16:16: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n    return arr.first - 1\n     \
    \          ^\n/tmp/tmpwlse80y3.swift:16:16: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    return arr.first - 1\n\
    \               ^\n           (         ?? <#default value#>)\n/tmp/tmpwlse80y3.swift:16:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains "
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxVal = arr[0]\n    for i in arr {\n        if i >\
    \ maxVal {\n            maxVal = i\n        }\n    }\n    return maxVal\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmphbsxkyno/tmphbsxkyno.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad45f581c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad45f278b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad45f278988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad45f2777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphbsxkyno                        0x0000564c4480b4d2 <unavailable> + 5330

    5    libc.so.6                          0x00002ad45f76d460 __libc_start_main +
    245

    6    tmphbsxkyno                        0x0000564c4480b129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex: Int = -1\n    for index in 0..<arr.count\
    \ {\n        if index == 0 || arr[index] > arr[index-1] {\n            arr.removeAtIndex(index)\n\
    \            maxIndex = index\n        }\n    }\n    return maxIndex\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp2amequn6.swift:15:17: error: value of type '[Int]' has no member\
    \ 'removeAtIndex'\n            arr.removeAtIndex(index)\n            ~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = 0\n    for idx in arr {\n        if idx >\
    \ arr[largest] {\n            largest = idx\n        }\n    }\n    return largest\
    \ == 0 ? -1 : largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpn04a3tli/tmpn04a3tli.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afdbafadc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afdbaca4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afdbaca4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afdbaca37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn04a3tli                        0x00005640b4e4c4d2 <unavailable> + 5330

    5    libc.so.6                          0x00002afdbb199460 __libc_start_main +
    245

    6    tmpn04a3tli                        0x00005640b4e4c129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr[0] == arr[1] {\n        return -1\n    }\n    return\
    \ arr[arr.firstIndex(before: arr[1])]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpslvcgzh9.swift:15:20: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n    return arr[arr.firstIndex(before: arr[1])]\n              \
    \     ^\n/tmp/tmpslvcgzh9.swift:15:20: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n    return arr[arr.firstIndex(before:\
    \ arr[1])]\n                   ^\n                                           \
    \   ?? <#default value#>\n/tmp/tmpslvcgzh9.swift:15:20: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    return arr[arr.firstIndex(before:\
    \ arr[1])]\n                   ^\n                                           \
    \  !\n/tmp/tmpslvcgzh9.swift:15:30: error: incorrect argument label in call (have\
    \ 'before:', expected 'of:')\n    return arr[arr.firstIndex(before: arr[1])]\n\
    \                             ^~~~~~~\n                              of\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    // Write your code here.\n    var largestIndex = 1\n  \
    \  for index in 1...arr.count {\n        if index < arr[index] {\n           \
    \ largestIndex = index\n        }\n    }\n    return largestIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b30709c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30706bf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b30706bf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b30706bf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b30706bebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b30704bee83 <unavailable> + 188035

    6    tmp89jj_yr6                        0x000056504d89ca14 <unavailable> + 6676

    7    tmp89jj_yr6                        0x000056504d89c4d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b3070bb4460 __libc_start_main +
    245

    9    tmp89jj_yr6                        0x000056504d89c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count > 1 else {\n        return -1\n    }\n\
    \    var max = 0\n    for index in 0..<arr.count - 1 {\n        if arr[index]\
    \ > arr[max] {\n            max = index\n        }\n    }\n    return max\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmprj_k223g/tmprj_k223g.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aac9cfc4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac9ccbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aac9ccbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aac9ccba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprj_k223g                        0x000056100440a552 <unavailable> + 5458

    5    libc.so.6                          0x00002aac9d1b0460 __libc_start_main +
    245

    6    tmprj_k223g                        0x000056100440a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIdx = -1\n\n    for i in 0..<arr.count {\n     \
    \   let idx = i + (maxIdx == -1 ? 0 : maxIdx)\n        if arr[i] > arr[idx] {\n\
    \            maxIdx = i\n        }\n    }\n\n    return maxIdx\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp70jjt4k4/tmp70jjt4k4.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b458fd39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b458fa30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b458fa30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b458fa2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp70jjt4k4                        0x00005623aa877552 <unavailable> + 5458

    5    libc.so.6                          0x00002b458ff25460 __libc_start_main +
    245

    6    tmp70jjt4k4                        0x00005623aa8771a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = arr[0]\n    var index = 1\n    for val in arr\
    \ {\n        if val > max {\n            max = val\n        }\n        if val\
    \ == max {\n            return index\n        }\n        index += 1\n    }\n \
    \   return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmphlx5blbj/tmphlx5blbj.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2ec98ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2ec681b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2ec681988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2ec6807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphlx5blbj                        0x00005583ed1644d2 <unavailable> + 5330

    5    libc.so.6                          0x00002ad2ecb76460 __libc_start_main +
    245

    6    tmphlx5blbj                        0x00005583ed164129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let max = -999999999\n\n    for (_, elem) in arr.enumerated()\
    \ {\n        if elem > max {\n            max = elem\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2,\
    \ 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp5rfd2zq9.swift:16:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = elem\n            ^~~\n/tmp/tmp5rfd2zq9.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = -999999999\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  // TODO(bswang): This can be done in O(n) time and O(1) space.\n\
    \  var largest = 0\n  var leftmost = 1\n  for idx, value in enumerate(arr) {\n\
    \    if value < arr[leftmost] {\n      largest = idx\n      leftmost = idx\n \
    \   }\n  }\n  if leftmost == 0 {\n    return -1\n  }\n  if largest == 0 {\n  \
    \  return 0\n  }\n  return largest + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmprn42gfdz.swift:15:10: error: expected 'in' after for-each pattern\n\
    \  for idx, value in enumerate(arr) {\n         ^\n/tmp/tmprn42gfdz.swift:15:10:\
    \ error: expected Sequence expression for for-each loop\n  for idx, value in enumerate(arr)\
    \ {\n         ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = -1\n    for index, _ in arr.enumerated() {\n\
    \        if index > max {\n            max = index\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2,\
    \ 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpbry7v2q7.swift:13:14: error: expected 'in' after for-each pattern\n\
    \    for index, _ in arr.enumerated() {\n             ^\n/tmp/tmpbry7v2q7.swift:13:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, _ in arr.enumerated()\
    \ {\n             ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max_val = arr[0]\n    for val : Int in arr {\n    \
    \    if val > max_val {\n            max_val = val\n        }\n    }\n    return\
    \ -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3,\
    \ 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmph6046_l0/tmph6046_l0.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d3b2abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d3afa2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d3afa2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d3afa17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph6046_l0                        0x000055f780e094d2 <unavailable> + 5330

    5    libc.so.6                          0x00002b6d3b497460 __libc_start_main +
    245

    6    tmph6046_l0                        0x000055f780e09129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = Int()\n    var low = Int()\n    var high\
    \ = Int()\n    arr.forEach() {\n        largest = max {\n            if $0 > largest\
    \ {\n                largest = $0\n            }\n        }\n        low = min\
    \ {\n            if $0 > low {\n                low = $0\n            }\n    \
    \    }\n        high = max {\n            if $0 < high {\n                high\
    \ = $0\n            }\n        }\n    }\n    if high - low <= largest - 1 {\n\
    \        return -1\n    }\n    return high\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpxxlgjnng.swift:15:19: error: contextual type for closure argument\
    \ list expects 1 argument, which cannot be implicitly ignored\n    arr.forEach()\
    \ {\n                  ^\n                   _ in \n/tmp/tmpxxlgjnng.swift:20:10:\
    \ error: missing argument for parameter #2 in call\n        }\n         ^\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpxxlgjnng.swift:18:27:\
    \ error: cannot assign value of type '_' to type 'Int'\n                largest\
    \ = $0\n                          ^~\n                          Int( )\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let min = arr[0]\n    let max = arr[0]\n    for i in 1..<arr.count\
    \ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n        if\
    \ arr[i] < min {\n            min = arr[i]\n        }\n    }\n    return arr.count\
    \ > 0 ? max : -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp1hv4gqk5.swift:16:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = arr[i]\n            ^~~\n/tmp/tmp1hv4gqk5.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = arr[0]\n    ^~~\n\
    \    var\n/tmp/tmp1hv4gqk5.swift:19:13: error: cannot assign to value: 'min' is\
    \ a 'let' constant\n            min = arr[i]\n            ^~~\n/tmp/tmp1hv4gqk5.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = arr[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count >= 2 else {\n        return -1\n    }\n\
    \n    if arr[0] > arr[1] {\n        return -1\n    }\n\n    var maxIdx = 1\n \
    \   for i in 2..<arr.count {\n        if arr[i] >= arr[maxIdx] {\n           \
    \ maxIdx = i\n        }\n    }\n\n    return maxIdx\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmphj8jpkrf/tmphj8jpkrf.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a1e9fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a1e6f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a1e6f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a1e6f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphj8jpkrf                        0x0000560e15a73552 <unavailable> + 5458

    5    libc.so.6                          0x00002b0a1ebe6460 __libc_start_main +
    245

    6    tmphj8jpkrf                        0x0000560e15a731a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max: Int = 0\n    for idx in arr.indices {\n      \
    \  if max <= arr[idx - 1] {\n            max = idx\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2,\
    \ 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0376b6cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0376863561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0376863286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b037686313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0376862bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0376662e83 <unavailable> + 188035

    6    tmpiyl99bpc                        0x000055db40719987 <unavailable> + 6535

    7    tmpiyl99bpc                        0x000055db40719474 <unavailable> + 5236

    8    libc.so.6                          0x00002b0376d58460 __libc_start_main +
    245

    9    tmpiyl99bpc                        0x000055db40719149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest: Int = 0\n    for elem in arr {\n        if\
    \ elem > largest {\n            largest = elem\n        }\n    }\n    if largest\
    \ == -1 {\n        return -1\n    }\n    return largest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmptho45vvn/tmptho45vvn.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aac7cafdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac7c7f4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aac7c7f4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aac7c7f37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptho45vvn                        0x000055d07c73f482 <unavailable> + 5250

    5    libc.so.6                          0x00002aac7cce9460 __libc_start_main +
    245

    6    tmptho45vvn                        0x000055d07c73f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var result = -1\n    for i in arr.indices {\n        let\
    \ current = arr[i]\n        \n        if current <= arr[result] {\n          \
    \  result = i\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c5db7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c5aae561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c5aae286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c5aae13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c5aadbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c58ade83 <unavailable> + 188035

    6    tmpfzkdeutg                        0x000056546d4bf99d <unavailable> + 6557

    7    tmpfzkdeutg                        0x000056546d4bf474 <unavailable> + 5236

    8    libc.so.6                          0x00002b48c5fa3460 __libc_start_main +
    245

    9    tmpfzkdeutg                        0x000056546d4bf149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let length = arr.count\n    if length == 0 {\n        return\
    \ -1\n    }\n    var maxIndex = length - 1\n    if maxIndex == 0 {\n        return\
    \ -1\n    }\n    if arr[maxIndex - 1] <= arr[maxIndex] {\n        return -1\n\
    \    }\n    let maxValue = arr[maxIndex]\n    if length == 1 {\n        return\
    \ maxIndex\n    }\n    let lastElementIndex = maxIndex - 1\n    for index in 0..<length\
    \ {\n        if arr[index] == lastElementIndex && arr[index] <= maxValue {\n \
    \           maxIndex = index\n        }\n    }\n    return maxIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpla45a41x/tmpla45a41x.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0532cd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05329c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05329c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05329c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpla45a41x                        0x000055db3d452552 <unavailable> + 5458

    5    libc.so.6                          0x00002b0532ebe460 __libc_start_main +
    245

    6    tmpla45a41x                        0x000055db3d4521a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = 0\n    var index: Int\n    for index, ele :=\
    \ range arr {\n        if ele <= arr[max] {\n            max = index\n       \
    \ } else {\n            return max\n        }\n    }\n    return -1\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp4jtohmqf.swift:14:14: error: expected 'in' after for-each pattern\n\
    \    for index, ele := range arr {\n             ^\n/tmp/tmp4jtohmqf.swift:14:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, ele :=\
    \ range arr {\n             ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = -1\n    for i in 0..<arr.count {\n        let\
    \ j = i\n        for _ in 0..<i {\n            j += 1\n        }\n        if arr[j]\
    \ > arr[i] {\n            max = max(max, j)\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpjr55gqha.swift:16:15: error: left side of mutating operator isn't\
    \ mutable: 'j' is a 'let' constant\n            j += 1\n            ~ ^\n/tmp/tmpjr55gqha.swift:14:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let j = i\n        ^~~\n\
    \        var\n/tmp/tmpjr55gqha.swift:19:19: error: cannot call value of non-function\
    \ type 'Int'\n            max = max(max, j)\n                  ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let mut i = -1\n    for i in arr.indices() {\n        if\
    \ arr[i] >= arr[i-1] {\n            return i\n        }\n    }\n    return -1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpxvsqy3o6.swift:12:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut i = -1\n\
    \            ^\n/tmp/tmpxvsqy3o6.swift:12:13: note: join the identifiers together\n\
    \    let mut i = -1\n        ~~~~^\n        muti\n/tmp/tmpxvsqy3o6.swift:12:13:\
    \ note: join the identifiers together with camel-case\n    let mut i = -1\n  \
    \      ~~~~^\n        mutI\n/tmp/tmpxvsqy3o6.swift:13:18: error: cannot call value\
    \ of non-function type 'Range<Array<Int>.Index>' (aka 'Range<Int>')\n    for i\
    \ in arr.indices() {\n                 ^      ~~\n                        \n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max_idx = -1\n    for idx in stride(from: arr.startIndex,\
    \ to: arr.endIndex, by: 1) {\n        if idx > arr.startIndex {\n            max_idx\
    \ = idx\n        }\n    }\n    return max_idx\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp431esz6u/tmp431esz6u.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b123d5c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b123d2bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b123d2bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b123d2bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp431esz6u                        0x00005605e14ba5e2 <unavailable> + 5602

    5    libc.so.6                          0x00002b123d7b2460 __libc_start_main +
    245

    6    tmp431esz6u                        0x00005605e14ba239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  let sorted = arr.sorted()\n  var largestIndex = sorted.endIndex\n\
    \n  for index in sorted {\n    if index >= largestIndex {\n      break\n    }\n\
    \    if index < largestIndex && arr[index] > arr[index+1] {\n      largestIndex\
    \ = index\n    }\n  }\n\n  if largestIndex == sorted.endIndex {\n    return -1\n\
    \  } else {\n    return largestIndex\n  }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpdzt7961k/tmpdzt7961k.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b559d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b556cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b556cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b556ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdzt7961k                        0x0000562fa15dd5d2 <unavailable> + 5586

    5    libc.so.6                          0x00002b5b55bc4460 __libc_start_main +
    245

    6    tmpdzt7961k                        0x0000562fa15dd229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  if arr == nil || arr[0] == 0 {\n    return -1\n  }\n  var\
    \ left = 0\n  for idx in 0..<arr.count {\n    if idx == 0 {\n      return idx\n\
    \    }\n    if arr[idx] > arr[left] {\n      left = idx\n    }\n  }\n  return\
    \ left\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2,\
    \ 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmps3wjv6mr/tmps3wjv6mr.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abaf9797c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abaf948eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abaf948e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abaf948d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps3wjv6mr                        0x0000556e96973552 <unavailable> + 5458

    5    libc.so.6                          0x00002abaf9983460 __libc_start_main +
    245

    6    tmps3wjv6mr                        0x0000556e969731a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count > 1 else { return -1 }\n    var maxIndex\
    \ = -1\n    for i in 0 ..< arr.count {\n        if arr[i] > arr[maxIndex] {\n\
    \            maxIndex = i\n        }\n    }\n    return maxIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002abf110c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf10db7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002abf10db7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002abf10db713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002abf10db6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002abf10bb6e83 <unavailable> + 188035

    6    tmp94aonybn                        0x0000563df3d15a42 <unavailable> + 6722

    7    tmp94aonybn                        0x0000563df3d154d4 <unavailable> + 5332

    8    libc.so.6                          0x00002abf112ac460 __libc_start_main +
    245

    9    tmp94aonybn                        0x0000563df3d151a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var largest = -1\n  var index = 0\n  for elem in arr {\n\
    \    if index == 0 {\n      largest = elem\n      continue\n    }\n\n    if elem\
    \ >= largest {\n      largest = elem\n    } else {\n      largest = largest\n\
    \    }\n\n    if index == arr.count {\n      return largest\n    }\n\n    index++\n\
    \  }\n\n  return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp9hzv6y3n.swift:23:15: error: assigning a variable to itself\n \
    \     largest = largest\n      ~~~~~~~ ^ ~~~~~~~\n/tmp/tmp9hzv6y3n.swift:30:10:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n    index++\n\
    \         ^~\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count > 0 else {\n        return 0\n    }\n\n\
    \    var largest = arr.first!\n    var index: Int = 0\n\n    for i in 0 ..< arr.count\
    \ {\n        if arr[i] >= largest {\n            largest = arr[i]\n          \
    \  index = i\n        }\n    }\n\n    return index\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpyc8alzfz/tmpyc8alzfz.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adb57b95c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adb5788cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adb5788c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adb5788b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyc8alzfz                        0x000055d67ea4f5f2 <unavailable> + 5618

    5    libc.so.6                          0x00002adb57d81460 __libc_start_main +
    245

    6    tmpyc8alzfz                        0x000055d67ea4f249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return arr.indices.max()! - 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp_pa_wvf4/tmp_pa_wvf4.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002accccb39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acccc830b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acccc830988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acccc82f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_pa_wvf4                        0x0000561a8f9b766f <unavailable> + 5743

    5    libc.so.6                          0x00002accccd25460 __libc_start_main +
    245

    6    tmp_pa_wvf4                        0x0000561a8f9b71f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.isEmpty else {\n        return -1\n    }\n\n\
    \    var result = -1\n    for i in 0 ..< arr.count {\n        if arr[i-1] < arr[i]\
    \ {\n            result = i\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpu7gtd3dd/tmpu7gtd3dd.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba78ce39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba78cb30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba78cb30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba78cb2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu7gtd3dd                        0x00005643f7af75e2 <unavailable> + 5602

    5    libc.so.6                          0x00002ba78d025460 __libc_start_main +
    245

    6    tmpu7gtd3dd                        0x00005643f7af7239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = -1\n    var index = 0\n    for n in arr {\n\
    \        guard n <= arr[index] else {\n            return -1\n        }\n    \
    \    if largest == -1 {\n            largest = n\n            index = index +\
    \ 1\n        } else {\n            if n > largest {\n                largest =\
    \ n\n            }\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp92v_e8i0/tmp92v_e8i0.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b1f8bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b1f5b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b1f5b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b1f5b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp92v_e8i0                        0x000055ce676994d2 <unavailable> + 5330

    5    libc.so.6                          0x00002b6b1faaa460 __libc_start_main +
    245

    6    tmp92v_e8i0                        0x000055ce67699129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  guard !arr.isEmpty else { return -1 }\n\n  var largest =\
    \ arr[0]\n  var i = 1 // index of arr[0]\n  for value in arr {\n    guard value\
    \ > largest else { largest = value }\n    i = i - 1\n    if i == 0 { return value\
    \ }\n  }\n\n  return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp8cfozav8.swift:17:50: error: 'guard' body must not fall through,\
    \ consider using a 'return' or 'throw' to exit the scope\n    guard value > largest\
    \ else { largest = value }\n                                                 ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var result = -1\n    for idx, element in enumerate(arr)\
    \ {\n        if element < arr[idx - 1] {\n            result = idx\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpcl99ep2g.swift:13:12: error: expected 'in' after for-each pattern\n\
    \    for idx, element in enumerate(arr) {\n           ^\n/tmp/tmpcl99ep2g.swift:13:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, element\
    \ in enumerate(arr) {\n           ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = 0\n\n    for i in 0 ..< arr.count {\n   \
    \     if arr[i] > arr[i-1 + largest] {\n            largest = i\n        }\n \
    \   }\n\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ada2f976c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada2f66d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ada2f66d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ada2f66d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ada2f66cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ada2f46ce83 <unavailable> + 188035

    6    tmp9ylav2ef                        0x000055cc4f24ca63 <unavailable> + 6755

    7    tmp9ylav2ef                        0x000055cc4f24c4d4 <unavailable> + 5332

    8    libc.so.6                          0x00002ada2fb62460 __libc_start_main +
    245

    9    tmp9ylav2ef                        0x000055cc4f24c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var res = -1\n    arr.forEach {\n        if res == -1 ||\
    \ $0 >= arr[res {\n            res = $0\n        }\n    }\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmph0x6_o4y.swift:17:5: error: expected ']' in expression list\n \
    \   }\n    ^\n/tmp/tmph0x6_o4y.swift:14:34: note: to match this opening '['\n\
    \        if res == -1 || $0 >= arr[res {\n                                 ^\n\
    /tmp/tmph0x6_o4y.swift:14:35: error: cannot call value of non-function type 'Int'\n\
    \        if res == -1 || $0 >= arr[res {\n                                  ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let maxIndex = arr.count - 1\n\n    for i in 0..<arr.count\
    \ {\n        if arr[i] > arr[i+1] {\n            return i\n        }\n    }\n\
    \    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp24841_2h/tmp24841_2h.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b16965c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16962bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16962bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16962be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp24841_2h                        0x000055bfdcdc5552 <unavailable> + 5458

    5    libc.so.6                          0x00002b16967b4460 __libc_start_main +
    245

    6    tmp24841_2h                        0x000055bfdcdc51a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max_so_far: Int = 0\n    for v in arr {\n        if\
    \ v > max_so_far {\n            max_so_far = v\n        }\n    }\n    if max_so_far\
    \ == 0 {\n        return -1\n    }\n    return max_so_far\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpdsnghuyr/tmpdsnghuyr.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeda1a7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeda1773b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeda1773988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeda17727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdsnghuyr                        0x0000559b3fddd482 <unavailable> + 5250

    5    libc.so.6                          0x00002aeda1c68460 __libc_start_main +
    245

    6    tmpdsnghuyr                        0x0000559b3fddd0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr == nil { return -1 }\n    var maxVal = 0\n    var\
    \ idx = 0\n    for value in arr {\n        if value > maxVal {\n            maxVal\
    \ = value\n            idx = 1\n        } else if value == maxVal {\n        \
    \    idx++\n        }\n    }\n    return idx\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpcf1vce2c.swift:12:12: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if arr == nil { return -1 }\n\
    \       ~~~ ^  ~~~\n/tmp/tmpcf1vce2c.swift:20:16: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            idx++\n               ^~\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = 0\n    var last: Int = 0\n    for i := 0; i <\
    \ len(arr); i++ {\n        if arr[i] > max {\n            last = i\n         \
    \   max = arr[i]\n        }\n    }\n    if last != 0 {\n        return last\n\
    \    } else {\n        return -1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpvvo497m_.swift:14:12: error: expected type\n    for i := 0; i <\
    \ len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmpvvo497m_.swift:14:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmpvvo497m_.swift:14:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(arr); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1659978533
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var maxIndex = -1\n  for index in 0..<arr.count {\n    if\
    \ arr[index] > arr[index-1] {\n      if maxIndex == -1 {\n        maxIndex = index\n\
    \      } else if index == maxIndex {\n        continue\n      } else {\n     \
    \   return -1\n      }\n    }\n  }\n  return maxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d0913cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d08e33561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7d08e33286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7d08e3313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7d08e32bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7d08c32e83 <unavailable> + 188035

    6    tmpbk09xmh8                        0x000055d93231aa4a <unavailable> + 6730

    7    tmpbk09xmh8                        0x000055d93231a4d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b7d09328460 __libc_start_main +
    245

    9    tmpbk09xmh8                        0x000055d93231a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    for index in 0..<arr.count - 1 {\n        if arr[index]\
    \ >= arr[index + 1] {\n            return index\n        }\n    }\n    return\
    \ -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3,\
    \ 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpzhwkafwh/tmpzhwkafwh.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affe3f99c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affe3c90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affe3c90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affe3c8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzhwkafwh                        0x000055f2f23fa552 <unavailable> + 5458

    5    libc.so.6                          0x00002affe4185460 __libc_start_main +
    245

    6    tmpzhwkafwh                        0x000055f2f23fa1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = 0\n    var i = -1\n    for x in arr {\n     \
    \   i += 1\n        if x > max {\n            max = x\n        }\n    }\n    return\
    \ i\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3,\
    \ 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp7fxrmbwp/tmp7fxrmbwp.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b090f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b08deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b08dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b08ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7fxrmbwp                        0x000055ddb801d482 <unavailable> + 5250

    5    libc.so.6                          0x00002b1b092e3460 __libc_start_main +
    245

    6    tmp7fxrmbwp                        0x000055ddb801d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var highest: Int = 0\n    for i in 0 ..< arr.count {\n\
    \        if arr[i] > arr[highest] {\n            highest = i\n        }\n    }\n\
    \    if highest == -1 {\n        return -1\n    } else {\n        return highest\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2,\
    \ 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpa81q_c_q/tmpa81q_c_q.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b744b085c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b744ad7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b744ad7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b744ad7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa81q_c_q                        0x000055e67ade6552 <unavailable> + 5458

    5    libc.so.6                          0x00002b744b271460 __libc_start_main +
    245

    6    tmpa81q_c_q                        0x000055e67ade61a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  guard arr.count > 0 else { return -1 }\n  return arr.maxIndex\
    \ {\n    idx, _ in\n    if idx == 0 || arr[idx - 1] <= arr[idx] {\n      return\
    \ false\n    }\n    return true\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpj708vcp3.swift:13:14: error: value of type '[Int]' has no member\
    \ 'maxIndex'\n  return arr.maxIndex {\n         ~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return max(0, min(arr.count - 1, arr.index(arr.first {\
    \ $0 > $1 }) + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpg0ve6jv2.swift:12:42: error: no exact matches in call to instance\
    \ method 'index'\n    return max(0, min(arr.count - 1, arr.index(arr.first { $0\
    \ > $1 }) + 1))\n                                         ^\n/tmp/tmpg0ve6jv2.swift:12:42:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Int?')\n\
    \    return max(0, min(arr.count - 1, arr.index(arr.first { $0 > $1 }) + 1))\n\
    \                                         ^\n/tmp/tmpg0ve6jv2.swift:12:42: note:\
    \ candidate expects value of type 'Int' for parameter #1 (got 'Int?')\n    return\
    \ max(0, min(arr.count - 1, arr.index(arr.first { $0 > $1 }) + 1))\n         \
    \                                ^\n/tmp/tmpg0ve6jv2.swift:12:42: note: candidate\
    \ expects value of type 'Array<Int>.Index' (aka 'Int') for parameter #1 (got 'Int?')\n\
    \    return max(0, min(arr.count - 1, arr.index(arr.first { $0 > $1 }) + 1))\n\
    \                                         ^\n/tmp/tmpg0ve6jv2.swift:12:42: note:\
    \ candidate expects value of type 'Array<Int>.Index' (aka 'Int') for parameter\
    \ #1 (got 'Int?')\n    return max(0, min(arr.count - 1, arr.index(arr.first {\
    \ $0 > $1 }) + 1))\n                                         ^\n/tmp/tmpg0ve6jv2.swift:12:58:\
    \ error: contextual closure type '(Int) throws -> Bool' expects 1 argument, but\
    \ 2 were used in closure body\n    return max(0, min(arr.count - 1, arr.index(arr.first\
    \ { $0 > $1 }) + 1))\n                                                       \
    \  ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = -1\n    for index in 0..<arr.count {\n \
    \       if arr[index] > arr[index-1] {\n            maxIndex = index\n       \
    \ }\n    }\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b00305d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00302c8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b00302c8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b00302c813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b00302c7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b00300c7e83 <unavailable> + 188035

    6    tmpurb4n7s_                        0x000055de084a6a4a <unavailable> + 6730

    7    tmpurb4n7s_                        0x000055de084a64d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b00307bd460 __libc_start_main +
    245

    9    tmpurb4n7s_                        0x000055de084a61a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659824457
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return arr.max { x, y in\n        guard x > y else {\n\
    \            return false\n        }\n        return true\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpv3idrb5y.swift:12:16: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return arr.max { x, y in\n      \
    \         ^\n/tmp/tmpv3idrb5y.swift:12:16: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    return arr.max { x, y\
    \ in\n               ^\n/tmp/tmpv3idrb5y.swift:12:16: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    return arr.max\
    \ { x, y in\n               ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var index = 0\n    for x in arr {\n        if x == arr[index]\
    \ {\n            index += 1\n        } else {\n            if index != 0 {\n \
    \               return index\n            }\n        }\n    }\n    return -1\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpwu4nxd8b/tmpwu4nxd8b.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46fa419c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46fa110b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46fa110988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46fa10f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwu4nxd8b                        0x00005626892164d2 <unavailable> + 5330

    5    libc.so.6                          0x00002b46fa605460 __libc_start_main +
    245

    6    tmpwu4nxd8b                        0x0000562689216129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.count > 1 {\n        var largest = -1\n        var\
    \ largestIdx = 0\n        for idx in 0..<arr.count {\n            if arr[idx]\
    \ > arr[idx-1] {\n                if largest < idx {\n                    largest\
    \ = idx\n                    largestIdx = idx\n                }\n           \
    \ }\n        }\n        return largest\n    }\n    return -1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b10862c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b10559561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4b10559286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4b1055913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4b10558bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4b10358e83 <unavailable> + 188035

    6    tmpf9re8ifm                        0x0000559b6bba6a82 <unavailable> + 6786

    7    tmpf9re8ifm                        0x0000559b6bba64d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b4b10a4e460 __libc_start_main +
    245

    9    tmpf9re8ifm                        0x0000559b6bba61a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return max(arr) + 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp1og6not0.swift:12:19: error: missing argument for parameter #2\
    \ in call\n    return max(arr) + 1\n                  ^\n                  , <#Int#>\n\
    Swift.max:1:24: note: 'max' declared here\n@inlinable public func max<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp1og6not0.swift:12:16:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    return max(arr) + 1\n               ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = -1\n\n    guard arr.isEmpty else { return\
    \ -1 }\n\n    for index in 0..<arr.count {\n        if arr[index] > arr[index\
    \ - 1] {\n            maxIndex = index\n            break\n        }\n    }\n\
    \    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp9zffi5lb/tmp9zffi5lb.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abef41d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abef3ed0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abef3ed0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abef3ecf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9zffi5lb                        0x00005597b64f95e2 <unavailable> + 5602

    5    libc.so.6                          0x00002abef43c5460 __libc_start_main +
    245

    6    tmp9zffi5lb                        0x00005597b64f9239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = -2\n    var maxIdx = 0\n\n    for idx in\
    \ 0..<arr.count {\n        if arr[idx] <= arr[largest] {\n            largest\
    \ = idx\n            maxIdx = idx\n        }\n    }\n\n    if maxIdx == -1 {\n\
    \        return -1\n    }\n\n    return maxIdx\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af9ebcc9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af9eb9c0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af9eb9c0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af9eb9c013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af9eb9bfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af9eb7bfe83 <unavailable> + 188035

    6    tmp908ap4xf                        0x000055b91949da46 <unavailable> + 6726

    7    tmp908ap4xf                        0x000055b91949d4d4 <unavailable> + 5332

    8    libc.so.6                          0x00002af9ebeb5460 __libc_start_main +
    245

    9    tmp908ap4xf                        0x000055b91949d1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = arr[0]\n    for el in arr {\n        if el\
    \ > largest {\n            largest = el\n        }\n    }\n    if largest < 0\
    \ {\n        return -1\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpdxsvxvlo/tmpdxsvxvlo.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b550e4f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b550e1efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b550e1ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b550e1ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdxsvxvlo                        0x00005647abf3d4d2 <unavailable> + 5330

    5    libc.so.6                          0x00002b550e6e4460 __libc_start_main +
    245

    6    tmpdxsvxvlo                        0x00005647abf3d129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = -1\n    var index = 0\n    for i in 0..<arr.count\
    \ {\n        if arr[i] > arr[largest] {\n            largest = index\n       \
    \ }\n        index += 1\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b55897b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b55894ab561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b55894ab286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b55894ab13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b55894aabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b55892aae83 <unavailable> + 188035

    6    tmp11khlbig                        0x00005623f50d0a43 <unavailable> + 6723

    7    tmp11khlbig                        0x00005623f50d04d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b55899a0460 __libc_start_main +
    245

    9    tmp11khlbig                        0x00005623f50d01a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    \n    if arr.isEmpty() {\n        return -1\n    }\n  \
    \  \n    var smallestIndex = -1\n    var largestIndex = 0\n    \n    for index\
    \ in 0..<arr.count {\n        if index <= smallestIndex {\n            smallestIndex\
    \ = index\n        }\n        if index > largestIndex {\n            largestIndex\
    \ = index\n        }\n    }\n    \n    if smallestIndex > -1 {\n        return\
    \ largestIndex\n    }\n    \n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpleih58mp.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return find_index(&arr, arr.firstIndex(where: <= ))\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp2r48uocu.swift:12:12: error: cannot find 'find_index' in scope\n\
    \    return find_index(&arr, arr.firstIndex(where: <= ))\n           ^~~~~~~~~~\n\
    /tmp/tmp2r48uocu.swift:12:23: error: cannot pass immutable value as inout argument:\
    \ 'arr' is a 'let' constant\n    return find_index(&arr, arr.firstIndex(where:\
    \ <= ))\n                      ^~~~\n/tmp/tmp2r48uocu.swift:12:43: error: cannot\
    \ convert value of type '(Int, Int) -> Bool' to expected argument type '(Int)\
    \ throws -> Bool'\n    return find_index(&arr, arr.firstIndex(where: <= ))\n \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty {\n        return -1\n    }\n\n    if arr.count\
    \ == 1 {\n        return 0\n    }\n\n    let lower = arr[0]\n    let upper = arr[0]\n\
    \    for i in 1..<arr.count {\n        if arr[i] < lower {\n            lower\
    \ = arr[i]\n        } else if arr[i] > upper {\n            upper = arr[i]\n \
    \       } else {\n            // If we've found an element that has a later index\
    \ (meaning we\n            // haven't found the previous element), then we know\
    \ we can't arrange\n            // the array in any order with that element.\n\
    \            return -1\n        }\n    }\n\n    // At this point, we know the\
    \ array is either sorted in ascending order or\n    // has only one element in\
    \ it. The upper bound will always be the largest\n    // integer less than the\
    \ lower bound, so we can just return the maximum.\n    return arr.maxIndex { (a,\
    \ b) -> Bool in\n        return a < b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpb8qyb4wv.swift:24:13: error: cannot assign to value: 'lower' is\
    \ a 'let' constant\n            lower = arr[i]\n            ^~~~~\n/tmp/tmpb8qyb4wv.swift:20:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let lower = arr[0]\n   \
    \ ^~~\n    var\n/tmp/tmpb8qyb4wv.swift:26:13: error: cannot assign to value: 'upper'\
    \ is a 'let' constant\n            upper = arr[i]\n            ^~~~~\n/tmp/tmpb8qyb4wv.swift:21:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let upper = arr[0]\n   \
    \ ^~~\n    var\n/tmp/tmpb8qyb4wv.swift:38:16: error: value of type '[Int]' has\
    \ no member 'maxIndex'\n    return arr.maxIndex { (a, b) -> Bool in\n        \
    \   ~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var maxIndex = -1\n  for index in 0 ..< arr.count {\n   \
    \ if index < maxIndex && arr[index] < arr[maxIndex] {\n      maxIndex = index\n\
    \    }\n  }\n  return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpvz_r9t9s/tmpvz_r9t9s.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bdba82c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bdb779b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bdb779988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bdb7787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvz_r9t9s                        0x000056148ef5b552 <unavailable> + 5458

    5    libc.so.6                          0x00002b5bdbc6e460 __libc_start_main +
    245

    6    tmpvz_r9t9s                        0x000056148ef5b1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return maxIndex(arr, { $0 >= $1 })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpa5t_pgmm.swift:12:12: error: cannot find 'maxIndex' in scope\n\
    \    return maxIndex(arr, { $0 >= $1 })\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = 0\n    for index in arr {\n        if max < index\
    \ {\n            max = index\n        }\n    }\n    if max > 0 {\n        return\
    \ max\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpumhy6o0_/tmpumhy6o0_.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bf7357c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bf704eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bf704e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bf704d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpumhy6o0_                        0x000055a548630482 <unavailable> + 5250

    5    libc.so.6                          0x00002b3bf7543460 __libc_start_main +
    245

    6    tmpumhy6o0_                        0x000055a5486300d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max: Int = 0\n    var i: Int = 0\n    for i = 0; i\
    \ < arr.count; i++ {\n        if arr[i] >= max {\n            max = arr[i]\n \
    \       } else {\n            return i\n        }\n    }\n    return -1\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpr6eyhv4m.swift:14:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 0; i < arr.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.isEmpty == false else {\n        return 0\n \
    \   }\n\n    var maxIndex = 0\n    var maxValue = arr[0]\n    for index in 1..<arr.count\
    \ {\n        if arr[index] > maxValue {\n            maxValue = arr[index]\n \
    \           maxIndex = index\n        }\n    }\n    return maxIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmphr6lx84s/tmphr6lx84s.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b108942fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1089126b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1089126988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10891257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphr6lx84s                        0x0000557f1687b5e2 <unavailable> + 5602

    5    libc.so.6                          0x00002b108961b460 __libc_start_main +
    245

    6    tmphr6lx84s                        0x0000557f1687b239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let maxIndex = arr.count - 1\n\n    for i in 0..<arr.count\
    \ {\n        if arr[i] >= arr[maxIndex] {\n            maxIndex = i\n        }\n\
    \    }\n\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp7jpo4qnl.swift:16:13: error: cannot assign to value: 'maxIndex'\
    \ is a 'let' constant\n            maxIndex = i\n            ^~~~~~~~\n/tmp/tmp7jpo4qnl.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxIndex = arr.count\
    \ - 1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty {\n        return -1\n    }\n    \n    let\
    \ len = arr.count\n    \n    for i in 0..<len - 1 {\n        if arr[i] > arr[i\
    \ + 1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpqq87rcvi/tmpqq87rcvi.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef22246c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef21f3db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef21f3d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef21f3c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqq87rcvi                        0x000055909f84c5e2 <unavailable> + 5602

    5    libc.so.6                          0x00002aef22432460 __libc_start_main +
    245

    6    tmpqq87rcvi                        0x000055909f84c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var result = Int()\n  for i in arr {\n    if i > result {\n\
    \      result = i\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpfztiuojn/tmpfztiuojn.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17aa61ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17aa315b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17aa315988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17aa3147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfztiuojn                        0x0000559f1bdb3482 <unavailable> + 5250

    5    libc.so.6                          0x00002b17aa80a460 __libc_start_main +
    245

    6    tmpfztiuojn                        0x0000559f1bdb30d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = -1\n    for index in 0 ..< arr.count {\n\
    \        if index < maxIndex && arr[index] > arr[index+1] {\n            maxIndex\
    \ = index\n        }\n    }\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpgnss28nr/tmpgnss28nr.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b919e93dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b919e634b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b919e634988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b919e6337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgnss28nr                        0x000055a35a3aa552 <unavailable> + 5458

    5    libc.so.6                          0x00002b919eb29460 __libc_start_main +
    245

    6    tmpgnss28nr                        0x000055a35a3aa1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    // write your code here\n    var maxIdx = 0\n    for idx\
    \ in 0..<arr.count {\n        if arr[idx] > arr[maxIdx] {\n            maxIdx\
    \ = idx\n        }\n    }\n    return maxIdx\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpp5ct9koh/tmpp5ct9koh.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b75b1547c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75b123eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75b123e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75b123d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp5ct9koh                        0x00005592b0bf1552 <unavailable> + 5458

    5    libc.so.6                          0x00002b75b1733460 __libc_start_main +
    245

    6    tmpp5ct9koh                        0x00005592b0bf11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = 0\n    for (_, index) in arr.enumerated()\
    \ {\n        if index > maxIndex {\n            maxIndex = index\n        }\n\
    \    }\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp6ick90jo/tmp6ick90jo.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19d9247c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19d8f3eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19d8f3e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19d8f3d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6ick90jo                        0x0000563c91535532 <unavailable> + 5426

    5    libc.so.6                          0x00002b19d9433460 __libc_start_main +
    245

    6    tmp6ick90jo                        0x0000563c91535189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max_index: Int = -1\n\n    for i in 0..<arr.count {\n\
    \        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n\
    \        }\n    }\n    return max_index\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab891055c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab890d4c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab890d4c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab890d4c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab890d4bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab890b4be83 <unavailable> + 188035

    6    tmpusixo1ym                        0x000055cec2428a4a <unavailable> + 6730

    7    tmpusixo1ym                        0x000055cec24284d4 <unavailable> + 5332

    8    libc.so.6                          0x00002ab891241460 __libc_start_main +
    245

    9    tmpusixo1ym                        0x000055cec24281a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return IntMax(arr) - IntMin(arr)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpl2zr3l0b.swift:12:12: error: cannot find 'IntMax' in scope\n  \
    \  return IntMax(arr) - IntMin(arr)\n           ^~~~~~\n/tmp/tmpl2zr3l0b.swift:12:26:\
    \ error: cannot find 'IntMin' in scope\n    return IntMax(arr) - IntMin(arr)\n\
    \                         ^~~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let max = arr[arr.startIndex.predecessor()]\n    return\
    \ arr.filter { $0 < max }.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpcj6_2dns.swift:12:34: error: value of type 'Int' has no member\
    \ 'predecessor'\n    let max = arr[arr.startIndex.predecessor()]\n           \
    \       ~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.count < 2 {\n        return -1\n    }\n\n    var\
    \ maxIndex: Int = 0\n    for index in 0..<arr.count - 1 {\n        if arr[index]\
    \ > arr[index + 1] {\n            return index\n        }\n    }\n\n    return\
    \ maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmppeyjxwrg/tmppeyjxwrg.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a36e57c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a36b4eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a36b4e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a36b4d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppeyjxwrg                        0x0000556407e19552 <unavailable> + 5458

    5    libc.so.6                          0x00002b8a37043460 __libc_start_main +
    245

    6    tmppeyjxwrg                        0x0000556407e191a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var result = -1\n\n  for i in 0 ..< arr.count {\n    if i\
    \ > 0 && arr[i] > arr[i-1] {\n      continue\n    }\n\n    if result < 0 || arr[i]\
    \ > result {\n      result = arr[i]\n    }\n  }\n\n  return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpo0bivhva/tmpo0bivhva.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87a4adac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87a47d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87a47d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87a47d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo0bivhva                        0x0000564835ff461f <unavailable> + 5663

    5    libc.so.6                          0x00002b87a4cc6460 __libc_start_main +
    245

    6    tmpo0bivhva                        0x0000564835ff41a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let pivot = arr.sort()[0]\n    if pivot == arr.last {\n\
    \        return -1\n    }\n    for (index, value) in arr.enumerated() {\n    \
    \    if value < pivot {\n            return index\n        }\n    }\n    return\
    \ -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3,\
    \ 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpsmn_pojm.swift:12:21: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    let pivot = arr.sort()[0]\n          \
    \      ~~~ ^\n/tmp/tmpsmn_pojm.swift:12:27: error: value of type '()' has no subscripts\n\
    \    let pivot = arr.sort()[0]\n                ~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr == nil || arr.isEmpty() {\n        return -1\n \
    \   }\n\n    var max = arr[0]\n\n    for val in arr {\n        if max < val {\n\
    \            max = val\n        }\n    }\n\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp4leu_u02.swift:12:26: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr == nil || arr.isEmpty() {\n                        \
    \ ^      ~~\n                                \n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  let max = -1\n  for idx in 0..<arr.count {\n    if max <\
    \ idx && arr[idx] >= arr[idx - 1] {\n      max = idx\n    }\n  }\n  return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpr2icyuvr.swift:15:7: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n      max = idx\n      ^~~\n/tmp/tmpr2icyuvr.swift:12:3: note:\
    \ change 'let' to 'var' to make it mutable\n  let max = -1\n  ^~~\n  var\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  return canArrange(arr: arr).sorted()[0].map({ arr[$0] })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp6m6fftls.swift:12:10: error: cannot find 'canArrange' in scope\n\
    \  return canArrange(arr: arr).sorted()[0].map({ arr[$0] })\n         ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty {\n        return -1\n    }\n    if arr[0]\
    \ == arr[0] {\n        return arr.indexOf(1)\n    }\n    var left: [Int] = []\n\
    \    var right: [Int] = []\n    for idx in arr.indices {\n        switch idx {\n\
    \        case 0...2:\n            left = arr\n        case 1, 2:\n           \
    \ right = arr\n        default:\n            guard left.isEmpty && right.isEmpty\
    \ else { return -1 }\n            switch idx {\n            case 0...1:\n    \
    \            if left[0] < right[0] {\n                    return idx\n       \
    \         } else {\n                    return left.indexOf(1)\n             \
    \   }\n            default:\n                if left[idx] < right[idx] {\n   \
    \                 return idx\n                } else {\n                    return\
    \ left.indexOf(1)\n                }\n            }\n        }\n    }\n    return\
    \ -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3,\
    \ 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpz9j_laxw.swift:16:20: error: value of type '[Int]' has no member\
    \ 'indexOf'\n        return arr.indexOf(1)\n               ~~~ ^~~~~~~\n/tmp/tmpz9j_laxw.swift:33:33:\
    \ error: value of type '[Int]' has no member 'indexOf'\n                    return\
    \ left.indexOf(1)\n                           ~~~~ ^~~~~~~\n/tmp/tmpz9j_laxw.swift:39:33:\
    \ error: value of type '[Int]' has no member 'indexOf'\n                    return\
    \ left.indexOf(1)\n                           ~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  let size = arr.count\n\n  if size <= 1 {\n    return -1\n\
    \  }\n\n  // First pass removes the duplicates and sorts the array.\n  var swapped\
    \ = false\n  var maxIndex = -1\n  for i in 0..<size {\n    if arr[i] > arr[i+1]\
    \ {\n      arr[i], arr[i+1] = arr[i+1], arr[i]\n      swapped = true\n    }\n\
    \    else if arr[i] == arr[i+1] {\n      continue\n    }\n    else {\n      maxIndex\
    \ = i\n    }\n  }\n\n  if !swapped {\n    return -1\n  }\n\n  // Second pass finds\
    \ the largest element. Since the array is sorted we\n  // just need one pass through\
    \ the array to find the largest element.\n  for index in 0..<size {\n    if arr[index]\
    \ > arr[maxIndex] {\n      maxIndex = index\n    }\n  }\n\n  return maxIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp3cblfgby.swift:23:13: error: consecutive statements on a line must\
    \ be separated by ';'\n      arr[i], arr[i+1] = arr[i+1], arr[i]\n           \
    \ ^\n            ;\n/tmp/tmp3cblfgby.swift:23:13: error: expected expression\n\
    \      arr[i], arr[i+1] = arr[i+1], arr[i]\n            ^\n/tmp/tmp3cblfgby.swift:23:10:\
    \ warning: expression of type 'Int' is unused\n      arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n      ~~~^~~\n/tmp/tmp3cblfgby.swift:19:7: warning: variable 'swapped'\
    \ was never mutated; consider changing to 'let' constant\n  var swapped = false\n\
    \  ~~~ ^\n  let\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let len = arr.count\n    if len == 0 { return -1 }\n  \
    \  let low = arr.min() - 1\n    let high = arr.max() + 1\n    for x in arr {\n\
    \        if x < low || x > high {\n            return -1\n        }\n    }\n \
    \   return len - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp40t2mk68.swift:14:19: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    let low = arr.min() - 1\n       \
    \           ^\n/tmp/tmp40t2mk68.swift:14:19: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let low = arr.min() -\
    \ 1\n                  ^\n              (         ?? <#default value#>)\n/tmp/tmp40t2mk68.swift:14:19:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let low = arr.min() - 1\n                  ^\n                  \
    \     !\n/tmp/tmp40t2mk68.swift:15:20: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    let high = arr.max() + 1\n      \
    \             ^\n/tmp/tmp40t2mk68.swift:15:20: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let high = arr.max() +\
    \ 1\n                   ^\n               (         ?? <#default value#>)\n/tmp/tmp40t2mk68.swift:15:20:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let high = arr.max() + 1\n                   ^\n                \
    \        !\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    // Only a small subset of all possible arrays satisfy the\
    \ condition\n    // of being able to be arranged.\n    for i in 0..<arr.count\
    \ {\n        if arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n\
    \    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b91b133ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91b1035561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b91b1035286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b91b103513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b91b1034bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b91b0e34e83 <unavailable> + 188035

    6    tmpacddzq6l                        0x000055fb83b26a2c <unavailable> + 6700

    7    tmpacddzq6l                        0x000055fb83b264d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b91b152a460 __libc_start_main +
    245

    9    tmpacddzq6l                        0x000055fb83b261a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = -1\n    for i in 0..<arr.count {\n        if\
    \ i > 0 && arr[i] > arr[i-1] {\n            max = i\n            break\n     \
    \   }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpvg_ytcjr/tmpvg_ytcjr.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b26fcee7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b26fcbdeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b26fcbde988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26fcbdd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvg_ytcjr                        0x000055d7da397552 <unavailable> + 5458

    5    libc.so.6                          0x00002b26fd0d3460 __libc_start_main +
    245

    6    tmpvg_ytcjr                        0x000055d7da3971a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  return canArrange1(arr: arr).reduce(maxOf: 0)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpxnfapyh0.swift:12:10: error: cannot find 'canArrange1' in scope\n\
    \  return canArrange1(arr: arr).reduce(maxOf: 0)\n         ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = 0\n    var maxValue = arr[0]\n    for (_,\
    \ value) in arr.enumerated() {\n        if value > maxValue {\n            maxIndex\
    \ = arr.index(of: value)\n            maxValue = value\n        } else if value\
    \ == maxValue {\n            maxIndex += 1\n        }\n    }\n    return maxIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp9akaqy74.swift:16:28: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n            maxIndex = arr.index(of: value)\n                 \
    \          ^\n/tmp/tmp9akaqy74.swift:16:28: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n            maxIndex = arr.index(of:\
    \ value)\n                           ^\n                                     \
    \       ?? <#default value#>\n/tmp/tmp9akaqy74.swift:16:28: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \    maxIndex = arr.index(of: value)\n                           ^\n         \
    \                                  !\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var maxIdx = 0\n  var maxVal = arr[0]\n  for idx in 1..<arr.count\
    \ {\n    if arr[idx] > maxVal {\n      maxIdx = idx\n      maxVal = arr[idx]\n\
    \    }\n  }\n  return maxIdx\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp3yqeihww/tmp3yqeihww.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90eda7ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90ed775b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90ed775988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90ed7747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3yqeihww                        0x00005602ed1ab552 <unavailable> + 5458

    5    libc.so.6                          0x00002b90edc6a460 __libc_start_main +
    245

    6    tmp3yqeihww                        0x00005602ed1ab1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max: Int = 0\n    for idx in arr.indices {\n      \
    \  if arr[idx] > max {\n            max = idx\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp8xnrlvwu/tmp8xnrlvwu.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6eac55c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6ea94cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab6ea94c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6ea94b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8xnrlvwu                        0x000055e4f1f514f2 <unavailable> + 5362

    5    libc.so.6                          0x00002ab6eae41460 __libc_start_main +
    245

    6    tmp8xnrlvwu                        0x000055e4f1f51149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = -1\n    \n    for n in arr {\n        if n >\
    \ max {\n            max = n\n        }\n    }\n    \n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpdcikfnzo/tmpdcikfnzo.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab97b465c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab97b15cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab97b15c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab97b15b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdcikfnzo                        0x000055720a1b7482 <unavailable> + 5250

    5    libc.so.6                          0x00002ab97b651460 __libc_start_main +
    245

    6    tmpdcikfnzo                        0x000055720a1b70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIdx = 0\n\n    for idx in 0..<arr.count {\n    \
    \    if idx <= maxIdx {\n            break\n        }\n        if arr[idx] > arr[idx-1]\
    \ {\n            maxIdx = idx\n        }\n    }\n\n    return maxIdx\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp16_x6r_7/tmp16_x6r_7.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6dc0710c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6dc0407b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6dc0407988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6dc04067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp16_x6r_7                        0x0000560957af0552 <unavailable> + 5458

    5    libc.so.6                          0x00002b6dc08fc460 __libc_start_main +
    245

    6    tmp16_x6r_7                        0x0000560957af01a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let largest = arr[0]\n    for i in arr {\n        if i\
    \ > largest {\n            largest = i\n        }\n    }\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpe9al8eat.swift:15:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = i\n            ^~~~~~~\n/tmp/tmpe9al8eat.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let largest = arr[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = -1\n    var maxValue = arr[0]\n    for idx\
    \ in 0..<arr.count {\n        if arr[idx] < maxValue {\n            return maxIndex\n\
    \        }\n        if arr[idx] > maxValue {\n            maxValue = arr[idx]\n\
    \            maxIndex = idx\n        }\n    }\n    return maxIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpp0vovs05/tmpp0vovs05.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba95c1f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba95beecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba95beec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba95beeb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp0vovs05                        0x0000558eb860c552 <unavailable> + 5458

    5    libc.so.6                          0x00002ba95c3e1460 __libc_start_main +
    245

    6    tmpp0vovs05                        0x0000558eb860c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  return max(arr) - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp_cihtgsz.swift:12:17: error: missing argument for parameter #2\
    \ in call\n  return max(arr) - 1\n                ^\n                , <#Int#>\n\
    Swift.max:1:24: note: 'max' declared here\n@inlinable public func max<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp_cihtgsz.swift:12:14:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \  return max(arr) - 1\n             ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max: Int = -1\n    for idx in 0..<arr.count {\n   \
    \     if arr[idx] <= max {\n            break\n        }\n        if idx == 0\
    \ {\n            max = arr[idx]\n        }\n    }\n    return max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpb9cg8tkg/tmpb9cg8tkg.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af7cccf9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7cc9f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7cc9f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7cc9ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9cg8tkg                        0x0000557a165ba552 <unavailable> + 5458

    5    libc.so.6                          0x00002af7ccee5460 __libc_start_main +
    245

    6    tmpb9cg8tkg                        0x0000557a165ba1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp1u1o2vn8/tmp1u1o2vn8.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b610bb3dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b610b834b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b610b834988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b610b8337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1u1o2vn8                        0x000055ccb0a8b312 <unavailable> + 4882

    5    libc.so.6                          0x00002b610bd29460 __libc_start_main +
    245

    6    tmp1u1o2vn8                        0x000055ccb0a8af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978416
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    // Write your code here.\n    for index in 0..<arr.count\
    \ {\n        if index == 0 || arr[index] > arr[index - 1] {\n            return\
    \ index\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: Exception
  stderr: 'tmp96c46twd/tmp96c46twd.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e5d76dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e5d464b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e5d464988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e5d4637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp96c46twd                        0x0000561cee702552 <unavailable> + 5458

    5    libc.so.6                          0x00002b0e5d959460 __libc_start_main +
    245

    6    tmp96c46twd                        0x0000561cee7021a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.isEmpty == false else { return -1 }\n    let\
    \ first = arr[0]\n    for i in arr {\n        if i >= first {\n            return\
    \ arr.index(i)\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpnou9rf0n.swift:16:24: error: no exact matches in call to instance\
    \ method 'index'\n            return arr.index(i)\n                       ^\n\
    Swift.Array:7:28: note: incorrect labels for candidate (have: '(_:)', expected:\
    \ '(after:)')\n    @inlinable public func index(after i: Int) -> Int\n       \
    \                    ^\nSwift.Array:9:28: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(before:)')\n    @inlinable public func index(before\
    \ i: Int) -> Int\n                           ^\nSwift.RandomAccessCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(after:)')\n\
    \    @inlinable public func index(after i: Self.Index) -> Self.Index\n       \
    \                    ^\nSwift.RandomAccessCollection:4:28: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public func\
    \ index(before i: Self.Index) -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty {\n        return -1\n    }\n    \n    let\
    \ largestIdx = 0\n    for idx in 0..<arr.count {\n        if idx == 0 {\n    \
    \        continue\n        }\n        \n        if arr[idx-1] <= arr[idx] {\n\
    \            largestIdx = idx\n            break\n        }\n    }\n    \n   \
    \ return largestIdx\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpkrrs9p5u.swift:23:13: error: cannot assign to value: 'largestIdx'\
    \ is a 'let' constant\n            largestIdx = idx\n            ^~~~~~~~~~\n\
    /tmp/tmpkrrs9p5u.swift:16:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largestIdx = 0\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    for index in 0..<arr.count {\n        if arr[index] > arr[index\
    \ - 1] {\n            return index\n        }\n    }\n    return -1\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b8fd03c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b8f9fa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0b8f9fa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0b8f9fa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0b8f9f9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0b8f7f9e83 <unavailable> + 188035

    6    tmp1c0kdv4p                        0x000055c1c4ea1a2c <unavailable> + 6700

    7    tmp1c0kdv4p                        0x000055c1c4ea14d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b0b8feef460 __libc_start_main +
    245

    9    tmp1c0kdv4p                        0x000055c1c4ea11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let len = arr.count\n    if len == 1 {\n        return\
    \ arr[0]\n    }\n    for i in 0..<len - 1 {\n        if arr[i] > arr[i+1] {\n\
    \            return i\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpvwnnxi_m/tmpvwnnxi_m.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24108fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24105f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24105f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24105f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvwnnxi_m                        0x000055bfb0957552 <unavailable> + 5458

    5    libc.so.6                          0x00002b2410ae7460 __libc_start_main +
    245

    6    tmpvwnnxi_m                        0x000055bfb09571a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = -1\n    for idx in 0..<arr.count {\n        if\
    \ arr[idx] > max {\n            max = arr[idx]\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpv9a95_16/tmpv9a95_16.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab8772c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab876fbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab876fbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab876fba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv9a95_16                        0x0000556d3b76f552 <unavailable> + 5458

    5    libc.so.6                          0x00002ab8774b0460 __libc_start_main +
    245

    6    tmpv9a95_16                        0x0000556d3b76f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    \n    for index in 0..<arr.count {\n        \n        if\
    \ index < arr.count - 1 && arr[index] > arr[index + 1] {\n            return index\n\
    \        }\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpv1929c82/tmpv1929c82.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b009ee5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b009eb56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b009eb56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b009eb557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv1929c82                        0x0000561ee14ba552 <unavailable> + 5458

    5    libc.so.6                          0x00002b009f04b460 __libc_start_main +
    245

    6    tmpv1929c82                        0x0000561ee14ba1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex: Int = 0\n    var currIndex: Int = 0\n   \
    \ for currIndex < arr.count {\n        if arr[currIndex] > arr[maxIndex] {\n \
    \           maxIndex = currIndex\n        }\n        currIndex += 1\n    }\n \
    \   return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpzjfbo8rg.swift:14:19: error: expected 'in' after for-each pattern\n\
    \    for currIndex < arr.count {\n                  ^\n/tmp/tmpzjfbo8rg.swift:14:19:\
    \ error: unary operator cannot be separated from its operand\n    for currIndex\
    \ < arr.count {\n                  ^~\n                   \n/tmp/tmpzjfbo8rg.swift:14:19:\
    \ error: '<' is not a prefix unary operator\n    for currIndex < arr.count {\n\
    \                  ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return len(arr) - 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpeat4yrbw.swift:12:12: error: cannot find 'len' in scope\n    return\
    \ len(arr) - 1\n           ^~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 0
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var lastIndex = -1\n  for index in 0..<arr.count {\n    if\
    \ index != 0 && arr[index] < arr[index - 1] {\n      lastIndex = index\n    }\n\
    \  }\n  return lastIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty {\n        return -1\n    }\n\n    var maxIndex\
    \ = arr.startIndex\n    if arr.last >= arr.first {\n        maxIndex = arr.first\
    \ + 1\n    }\n\n    for i in maxIndex..<arr.count {\n        if arr[i] != arr[i-1]\
    \ {\n            return i\n        }\n    }\n    return -1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpxgj0zgnz.swift:17:17: error: binary operator '>=' cannot be applied\
    \ to two 'Int?' operands\n    if arr.last >= arr.first {\n       ~~~~~~~~ ^  ~~~~~~~~~\n\
    /tmp/tmpxgj0zgnz.swift:17:17: note: overloads for '>=' exist with these partially\
    \ matching parameter lists: (Int, Int)\n    if arr.last >= arr.first {\n     \
    \           ^\n/tmp/tmpxgj0zgnz.swift:18:24: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n        maxIndex = arr.first + 1\n\
    \                       ^\n/tmp/tmpxgj0zgnz.swift:18:24: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        maxIndex\
    \ = arr.first + 1\n                       ^\n                   (         ?? <#default\
    \ value#>)\n/tmp/tmpxgj0zgnz.swift:18:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        maxIndex = arr.first\
    \ + 1\n                       ^\n                            !\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  if arr == nil || arr.isEmpty { return -1 }\n  return max(arr.startIndex,\
    \ arr.endIndex) - min(arr.startIndex, arr.endIndex) + 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpkn6xu4ed/tmpkn6xu4ed.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8fc115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8fbe0cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8fbe0c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8fbe0b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkn6xu4ed                        0x000055dc38e2b552 <unavailable> + 5458

    5    libc.so.6                          0x00002ad8fc301460 __libc_start_main +
    245

    6    tmpkn6xu4ed                        0x000055dc38e2b1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let mut index = 0\n    for x in arr {\n        if index\
    \ == 0 {\n            index = x\n        } else if x < arr[index] {\n        \
    \    index = x\n        }\n    }\n    return index\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmplulnz3vv.swift:12:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut index =\
    \ 0\n            ^\n/tmp/tmplulnz3vv.swift:12:13: note: join the identifiers together\n\
    \    let mut index = 0\n        ~~~~^~~~~\n        mutindex\n/tmp/tmplulnz3vv.swift:12:13:\
    \ note: join the identifiers together with camel-case\n    let mut index = 0\n\
    \        ~~~~^~~~~\n        mutIndex\n/tmp/tmplulnz3vv.swift:14:12: error: cannot\
    \ find 'index' in scope\n        if index == 0 {\n           ^~~~~\n/tmp/tmplulnz3vv.swift:15:13:\
    \ error: cannot find 'index' in scope\n            index = x\n            ^~~~~\n\
    /tmp/tmplulnz3vv.swift:16:27: error: cannot find 'index' in scope\n        } else\
    \ if x < arr[index] {\n                          ^~~~~\n/tmp/tmplulnz3vv.swift:17:13:\
    \ error: cannot find 'index' in scope\n            index = x\n            ^~~~~\n\
    /tmp/tmplulnz3vv.swift:20:12: error: cannot find 'index' in scope\n    return\
    \ index\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var result: Int?\n  for i in 0..<arr.count {\n    if i >\
    \ 0 && arr[i] > arr[i-1] {\n      result = arr[i]\n      break\n    }\n  }\n \
    \ return result!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp3q2zf90q/tmp3q2zf90q.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af6dc9ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6dc6d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6dc6d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6dc6d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3q2zf90q                        0x000055b0cc6b3552 <unavailable> + 5458

    5    libc.so.6                          0x00002af6dcbc9460 __libc_start_main +
    245

    6    tmp3q2zf90q                        0x000055b0cc6b31a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    arr.sort()\n\n    var largest = -1\n    var candidate =\
    \ -1\n\n    for i in 0..<arr.count {\n        candidate = i\n        for j in\
    \ (i + 1)..<arr.count {\n            if arr[i] >= arr[j] {\n                candidate\
    \ = -1\n                break\n            }\n        }\n\n        if candidate\
    \ >= 0 {\n            largest = candidate\n        }\n    }\n\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmprdb546vw.swift:12:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var index = 0\n    for num in arr {\n        if num <=\
    \ arr[index] {\n            return -1\n        }\n        index = index + 1\n\
    \    }\n    return index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp60ffnfs7/tmp60ffnfs7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d4ab42c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d4a839b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d4a839988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d4a8387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp60ffnfs7                        0x0000557f6c6224d2 <unavailable> + 5330

    5    libc.so.6                          0x00002b6d4ad2e460 __libc_start_main +
    245

    6    tmp60ffnfs7                        0x0000557f6c622129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  if arr.isEmpty() {\n    return -1\n  }\n  var max = arr[0]\n\
    \  for idx in 0..<arr.count {\n    if idx > 0 && arr[max] < arr[idx - 1] {\n \
    \     max = idx\n    }\n  }\n  return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp2dhg3cf6.swift:12:10: error: cannot call value of non-function\
    \ type 'Bool'\n  if arr.isEmpty() {\n         ^      ~~\n                \n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    arr.sort()\n    guard arr.count > 1 else { return -1 }\n\
    \    return arr.first! - arr[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp21o20te8.swift:12:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var result: Int = 0\n\n    for idx in 0..<arr.count {\n\
    \        if idx > result {\n            result = idx\n        }\n    }\n\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpr6yalmxu/tmpr6yalmxu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8268502c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82681f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b82681f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82681f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr6yalmxu                        0x0000559a558e44f2 <unavailable> + 5362

    5    libc.so.6                          0x00002b82686ee460 __libc_start_main +
    245

    6    tmpr6yalmxu                        0x0000559a558e4149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let mut max = 0\n    for i in arr.indices {\n        if\
    \ arr[i - 1] >= arr[i] {\n            max = i\n        }\n    }\n    return max\
    \ >= 0 ? max : -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpeqxeyo9g.swift:12:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut max = 0\n\
    \            ^\n/tmp/tmpeqxeyo9g.swift:12:13: note: join the identifiers together\n\
    \    let mut max = 0\n        ~~~~^~~\n        mutmax\n/tmp/tmpeqxeyo9g.swift:12:13:\
    \ note: join the identifiers together with camel-case\n    let mut max = 0\n \
    \       ~~~~^~~\n        mutMax\n/tmp/tmpeqxeyo9g.swift:15:13: error: no exact\
    \ matches in reference to global function 'max'\n            max = i\n       \
    \     ^\n/tmp/tmpeqxeyo9g.swift:15:13: note: found candidate with type '(_, _)\
    \ -> _'\n            max = i\n            ^\n/tmp/tmpeqxeyo9g.swift:15:13: note:\
    \ found candidate with type '(_, _, _, _...) -> _'\n            max = i\n    \
    \        ^\n/tmp/tmpeqxeyo9g.swift:18:12: error: generic parameter 'T' could not\
    \ be inferred\n    return max >= 0 ? max : -1\n           ^\nSwift.max:1:24: note:\
    \ in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpeqxeyo9g.swift:18:23:\
    \ error: generic parameter 'T' could not be inferred\n    return max >= 0 ? max\
    \ : -1\n                      ^\nSwift.max:1:24: note: in call to function 'max'\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpeqxeyo9g.swift:18:21: error: cannot convert return\
    \ expression of type '(T, T) -> T' to return type 'Int'\n    return max >= 0 ?\
    \ max : -1\n           ~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let max = arr[0]\n    var max = -1\n    for x in arr {\n\
    \        if x > max {\n            max = x\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpuk0vykm6.swift:13:9: error: invalid redeclaration of 'max'\n  \
    \  var max = -1\n        ^\n/tmp/tmpuk0vykm6.swift:12:9: note: 'max' previously\
    \ declared here\n    let max = arr[0]\n        ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count > 1 else {\n        return -1\n    }\n\n\
    \    let maxIdx = arr.firstIndex(where: { $0 >= arr.last })\n\n    return maxIdx\
    \ == -1 ? -1 : maxIdx\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpp6hekmc0.swift:16:52: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    let maxIdx = arr.firstIndex(where:\
    \ { $0 >= arr.last })\n                                                   ^\n\
    /tmp/tmpp6hekmc0.swift:16:52: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    let maxIdx = arr.firstIndex(where: {\
    \ $0 >= arr.last })\n                                                   ^\n  \
    \                                                      ?? <#default value#>\n\
    /tmp/tmpp6hekmc0.swift:16:52: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    let maxIdx = arr.firstIndex(where:\
    \ { $0 >= arr.last })\n                                                   ^\n\
    \                                                       !\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    // write your code here\n    var largest = -1\n    var\
    \ index = 0\n    for element in arr {\n        if element > arr[index] {\n   \
    \         largest = index\n        }\n        index++\n    }\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpgh1qrqy1.swift:19:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = -1\n    var currentMax = -1\n\n    for i\
    \ in arr.indices {\n        if currentMax < i {\n            currentMax = i\n\
    \        } else {\n            if largest < i - 1 {\n                largest =\
    \ i - 1\n            }\n        }\n    }\n\n    return largest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpkjf9eonh/tmpkjf9eonh.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b140b798c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b140b48fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b140b48f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b140b48e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkjf9eonh                        0x000056458e3af4a2 <unavailable> + 5282

    5    libc.so.6                          0x00002b140b984460 __libc_start_main +
    245

    6    tmpkjf9eonh                        0x000056458e3af0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let l = arr.count\n    if l == 0 {\n        return -1\n\
    \    }\n\n    for i in 0 ..< l - 1 {\n        if arr[i] >= arr[i - 1] {\n    \
    \        return i\n        }\n    }\n\n    return -1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b46dacf8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46da9ef561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b46da9ef286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b46da9ef13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b46da9eebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b46da7eee83 <unavailable> + 188035

    6    tmpgibz5k2t                        0x0000559ec549ca83 <unavailable> + 6787

    7    tmpgibz5k2t                        0x0000559ec549c4d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b46daee4460 __libc_start_main +
    245

    9    tmpgibz5k2t                        0x0000559ec549c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max: Int = -1\n    for idx in arr.indices {\n     \
    \   if arr[idx] > max {\n            max = arr[idx]\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2,\
    \ 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp4df21hz2/tmp4df21hz2.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6495346c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b649503db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b649503d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b649503c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4df21hz2                        0x0000562fe713a4f2 <unavailable> + 5362

    5    libc.so.6                          0x00002b6495532460 __libc_start_main +
    245

    6    tmp4df21hz2                        0x0000562fe713a149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let maxIndex = -1\n    for i in arr.indices {\n       \
    \ if arr[i] <= arr[maxIndex] {\n            maxIndex = i\n        }\n    }\n \
    \   return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp0dpxuk7k.swift:15:13: error: cannot assign to value: 'maxIndex'\
    \ is a 'let' constant\n            maxIndex = i\n            ^~~~~~~~\n/tmp/tmp0dpxuk7k.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxIndex = -1\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = -1\n\n    for idx, item in arr.enumerated() {\n\
    \        if idx > 0 && item >= arr[idx - 1] {\n            max = idx\n       \
    \ }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpr5bm5iu4.swift:14:12: error: expected 'in' after for-each pattern\n\
    \    for idx, item in arr.enumerated() {\n           ^\n/tmp/tmpr5bm5iu4.swift:14:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, item in\
    \ arr.enumerated() {\n           ^\n"
  stdout: ''
  timestamp: 1659978534
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = 0\n    for idx in arr {\n        if idx >\
    \ largest-1 {\n            largest = idx\n        }\n    }\n    if largest ==\
    \ -1 {\n        return -1\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpdq50nofa/tmpdq50nofa.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad74be1fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad74bb16b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad74bb16988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad74bb157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdq50nofa                        0x000055cc3005a482 <unavailable> + 5250

    5    libc.so.6                          0x00002ad74c00b460 __libc_start_main +
    245

    6    tmpdq50nofa                        0x000055cc3005a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  let n = arr.count\n  for i in 0..<n {\n    if arr[i] > arr[i-1]\
    \ {\n      return i\n    }\n  }\n  return -1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acf0ed14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf0ea0b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acf0ea0b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acf0ea0b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acf0ea0abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acf0e80ce83 <unavailable> + 188035

    6    tmpqt2kk8ky                        0x00005607c0556a46 <unavailable> + 6726

    7    tmpqt2kk8ky                        0x00005607c05564d4 <unavailable> + 5332

    8    libc.so.6                          0x00002acf0ef00460 __libc_start_main +
    245

    9    tmpqt2kk8ky                        0x00005607c05561a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = -1\n    for index in 0..<arr.count {\n \
    \       if index < arr.count {\n            if arr[index] > arr[index + 1] {\n\
    \                continue\n            }\n        }\n        maxIndex = index\n\
    \        break\n    }\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpsjnh2p74/tmpsjnh2p74.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23ecbfcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23ec8f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23ec8f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23ec8f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsjnh2p74                        0x000055a93043c552 <unavailable> + 5458

    5    libc.so.6                          0x00002b23ecde8460 __libc_start_main +
    245

    6    tmpsjnh2p74                        0x000055a93043c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let largest = arr.last { $0 >= arr[Int(arc4random_uniform(UInt32(arr.count)))]\
    \ }\n    return arr.first { $0 < largest } == -1 ? -1 : Int(arc4random_uniform(UInt32(arr.count))\
    \ + 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2,\
    \ 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpznoywzwi.swift:12:44: error: cannot find 'arc4random_uniform' in\
    \ scope\n    let largest = arr.last { $0 >= arr[Int(arc4random_uniform(UInt32(arr.count)))]\
    \ }\n                                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmpznoywzwi.swift:13:56:\
    \ error: cannot find 'arc4random_uniform' in scope\n    return arr.first { $0\
    \ < largest } == -1 ? -1 : Int(arc4random_uniform(UInt32(arr.count)) + 1)\n  \
    \                                                     ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty {\n        return -1\n    }\n\n    var left\
    \ = 1\n    var right = arr.count\n    while left < right {\n        if arr[left]\
    \ == arr[left-1] {\n            left += 1\n        } else {\n            right\
    \ = left\n        }\n    }\n    return left\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp19er061z/tmp19er061z.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea37bb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea378aab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea378aa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea378a97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp19er061z                        0x0000562120cbe452 <unavailable> + 5202

    5    libc.so.6                          0x00002aea37d9f460 __libc_start_main +
    245

    6    tmp19er061z                        0x0000562120cbe0a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  guard arr.count > 1 else {\n    return -1\n  }\n  guard arr[0]\
    \ < arr[1] else {\n    return -1\n  }\n  guard arr[2] < arr[3] else {\n    return\
    \ -1\n  }\n  var max = 0\n  var index = -1\n  for i in 0..arr.count - 2 {\n  \
    \  if arr[i] <= arr[i + 1] {\n      continue\n    }\n    if arr[i] > arr[i + 1]\
    \ {\n      max = i + 1\n      index = max\n    }\n  }\n  return index\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpbqw2usz4.swift:23:13: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n  for i in 0..arr.count - 2 {\n            ^~\n       \
    \     ...\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  // TODO: Write your code in Swift 5.1 or earlier\n  if arr.count\
    \ <= 1 {\n    return -1\n  }\n\n  let largestIndex = 0\n  var largest = arr[0]\n\
    \n  for index in 1..<arr.count {\n    if arr[index] > largest {\n      largest\
    \ = arr[index]\n      largestIndex = index\n    }\n  }\n\n  return largestIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpi537g925.swift:23:7: error: cannot assign to value: 'largestIndex'\
    \ is a 'let' constant\n      largestIndex = index\n      ^~~~~~~~~~~~\n/tmp/tmpi537g925.swift:17:3:\
    \ note: change 'let' to 'var' to make it mutable\n  let largestIndex = 0\n  ^~~\n\
    \  var\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = 0\n    for i in 0 ..< arr.count {\n        if\
    \ arr[i] > arr[max] {\n            max = i\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp_ux4jzil/tmp_ux4jzil.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49f8933c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49f862ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49f862a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49f86297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ux4jzil                        0x000056063db81552 <unavailable> + 5458

    5    libc.so.6                          0x00002b49f8b1f460 __libc_start_main +
    245

    6    tmp_ux4jzil                        0x000056063db811a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = 0\n    for index in arr.indices() {\n  \
    \      if arr[index] < arr[index-1] {\n            return index\n        }\n \
    \       if maxIndex < index {\n            maxIndex = index\n        }\n    }\n\
    \    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmprirarta6.swift:13:22: error: cannot call value of non-function\
    \ type 'Range<Array<Int>.Index>' (aka 'Range<Int>')\n    for index in arr.indices()\
    \ {\n                     ^      ~~\n                            \n"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count > 1 else { return -1 }\n    guard arr[0]\
    \ != arr[0] else { return -1 }\n    guard arr.last >= arr[0] && arr.last >= arr[1]\
    \ else { return -1 }\n    let start = arr.firstIndex(of: arr[0])\n    let stop\
    \ = arr.firstIndex(of: arr[1])\n    guard start != -1 && stop != -1 else { return\
    \ -1 }\n    return max(start, stop)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp1joqa06w.swift:14:15: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard arr.last >= arr[0] && arr.last\
    \ >= arr[1] else { return -1 }\n              ^\n/tmp/tmp1joqa06w.swift:14:15:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard arr.last >= arr[0] && arr.last >= arr[1] else { return -1 }\n\
    \              ^\n                   ?? <#default value#>\n/tmp/tmp1joqa06w.swift:14:15:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    guard arr.last >= arr[0] && arr.last >= arr[1] else { return -1 }\n\
    \              ^\n                  !\n/tmp/tmp1joqa06w.swift:14:37: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    guard\
    \ arr.last >= arr[0] && arr.last >= arr[1] else { return -1 }\n              \
    \                      ^\n/tmp/tmp1joqa06w.swift:14:37: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    guard arr.last\
    \ >= arr[0] && arr.last >= arr[1] else { return -1 }\n                       \
    \             ^\n                                         ?? <#default value#>\n\
    /tmp/tmp1joqa06w.swift:14:37: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    guard arr.last >= arr[0] && arr.last\
    \ >= arr[1] else { return -1 }\n                                    ^\n      \
    \                                  !\n/tmp/tmp1joqa06w.swift:18:16: error: value\
    \ of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped\
    \ to a value of type 'Array<Int>.Index' (aka 'Int')\n    return max(start, stop)\n\
    \               ^\n/tmp/tmp1joqa06w.swift:18:16: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n    return max(start,\
    \ stop)\n               ^\n                     ?? <#default value#>\n/tmp/tmp1joqa06w.swift:18:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return max(start, stop)\n               ^\n                    !\n\
    /tmp/tmp1joqa06w.swi"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty { return -1 }\n    var max = 0\n    var\
    \ prev: Int?\n    for i in 0..<arr.count {\n        if arr[i] > prev {\n     \
    \       max = i\n        } else {\n            if prev == nil { return -1 }\n\
    \        }\n        prev = arr[i]\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp1npr_i9d.swift:16:21: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if arr[i] > prev {\n        \
    \            ^\n/tmp/tmp1npr_i9d.swift:16:21: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        if arr[i] > prev {\n\
    \                    ^\n                         ?? <#default value#>\n/tmp/tmp1npr_i9d.swift:16:21:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if arr[i] > prev {\n                    ^\n                 \
    \       !\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = 0\n    guard arr.count != 0 else { return -1\
    \ }\n    for value in arr {\n        let index = arr.index(of: value)!\n     \
    \   max = max(max == -1 ? index : max, index)\n    }\n    return max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp33diod0o.swift:15:25: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = arr.index(of: value)!\n          \
    \              ^\n/tmp/tmp33diod0o.swift:15:25: note: use 'firstIndex(of:)' instead\n\
    \        let index = arr.index(of: value)!\n                        ^~~~~\n  \
    \                      firstIndex\n/tmp/tmp33diod0o.swift:16:15: error: cannot\
    \ call value of non-function type 'Int'\n        max = max(max == -1 ? index :\
    \ max, index)\n              ^\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty { return -1 }\n    var max = arr[0]\n  \
    \  var maxIndex = -1\n\n    for i in 1..<arr.count {\n        if arr[i] > max\
    \ {\n            max = arr[i]\n            maxIndex = i\n        }\n    }\n\n\
    \    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpmbsousgv/tmpmbsousgv.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c0dc16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c0d90db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c0d90d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c0d90c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmbsousgv                        0x0000555b4fefb5e2 <unavailable> + 5602

    5    libc.so.6                          0x00002b4c0de02460 __libc_start_main +
    245

    6    tmpmbsousgv                        0x0000555b4fefb239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var i = 0\n    for e in arr {\n        if i > 0 && e <=\
    \ arr[i - 1] {\n            return i - 1\n        }\n        i = i + 1\n    }\n\
    \    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp14d9aorg/tmp14d9aorg.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba247e01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba247af8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba247af8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba247af77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp14d9aorg                        0x000055c8650474d2 <unavailable> + 5330

    5    libc.so.6                          0x00002ba247fed460 __libc_start_main +
    245

    6    tmp14d9aorg                        0x000055c865047129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  guard arr.isEmpty == false else {\n    return -1\n  }\n \
    \ var max = Int(-1)\n  var cur = Int(-1)\n  for i in 0..<arr.count {\n    if arr[i]\
    \ <= arr[cur] {\n      cur = i\n    }\n    if arr[i] > max {\n      max = i\n\
    \    }\n  }\n  return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e85b94c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e8588b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9e8588b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9e8588b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9e8588abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9e8568ae83 <unavailable> + 188035

    6    tmp170k290h                        0x0000557103e54b0f <unavailable> + 6927

    7    tmp170k290h                        0x0000557103e54564 <unavailable> + 5476

    8    libc.so.6                          0x00002b9e85d80460 __libc_start_main +
    245

    9    tmp170k290h                        0x0000557103e54239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    \n    guard arr.count > 0 else { return -1 }\n    var smallest\
    \ = 0\n    \n    for i in 0..<arr.count-1 {\n        if arr[i] < arr[smallest]\
    \ {\n            smallest = i\n        }\n    }\n    \n    if arr[smallest] ==\
    \ arr[0] {\n        return smallest\n    } else {\n        return -1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp5jpx46n4/tmp5jpx46n4.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b544c3f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b544c0efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b544c0ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b544c0ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5jpx46n4                        0x000056327692f552 <unavailable> + 5458

    5    libc.so.6                          0x00002b544c5e4460 __libc_start_main +
    245

    6    tmp5jpx46n4                        0x000056327692f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = 0\n    var last = -1\n\n    for i in 0 ..<\
    \ arr.count {\n        if last < 0 || arr[i] <= arr[last] {\n            last\
    \ = i\n        }\n\n        if i == maxIndex {\n            maxIndex = i\n   \
    \     }\n    }\n\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2,\
    \ 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\
    assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as\
    \ [Int]) == -1)"
  status: Exception
  stderr: 'tmpahqkmw9u/tmpahqkmw9u.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b15a4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b15741b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b15741988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b157407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpahqkmw9u                        0x0000557497e81552 <unavailable> + 5458

    5    libc.so.6                          0x00002b0b15c36460 __libc_start_main +
    245

    6    tmpahqkmw9u                        0x0000557497e811a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.count <= 0 {\n        return -1\n    }\n    var\
    \ max = -Int.max\n    for i in 0..<arr.count {\n        if arr[i] > max {\n  \
    \          max = arr[i]\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpgj39l5jy/tmpgj39l5jy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08a415bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08a3e52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08a3e52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08a3e517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgj39l5jy                        0x000055afc1a37552 <unavailable> + 5458

    5    libc.so.6                          0x00002b08a4347460 __libc_start_main +
    245

    6    tmpgj39l5jy                        0x000055afc1a371a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var max = 0\n  for idx in 0..<arr.count {\n    if idx > 0\
    \ {\n      if arr[idx] > arr[max] {\n        max = idx\n      }\n    } else {\n\
    \      max = idx\n    }\n  }\n  if max >= arr.count {\n    return -1\n  }\n  return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2,\
    \ 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpyabesghk/tmpyabesghk.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5474bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5471b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5471b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5471b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyabesghk                        0x00005622b19de552 <unavailable> + 5458

    5    libc.so.6                          0x00002ba5476a9460 __libc_start_main +
    245

    6    tmpyabesghk                        0x00005622b19de1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = 0\n    var index = -1\n    for i : Int in 0 ..<\
    \ arr.count {\n        if i == 0 {\n            index = arr.count\n        } else\
    \ {\n            if arr[i] <= arr[index] {\n                index = -1\n     \
    \       } else {\n                if max < index {\n                    max =\
    \ index\n                }\n                index = i\n            }\n       \
    \ }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b38e63dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38e60d1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b38e60d1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b38e60d113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b38e60d0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b38e5ed0e83 <unavailable> + 188035

    6    tmp2i35lcqn                        0x00005635285cba66 <unavailable> + 6758

    7    tmp2i35lcqn                        0x00005635285cb4d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b38e65c6460 __libc_start_main +
    245

    9    tmp2i35lcqn                        0x00005635285cb1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max_index = 0\n    for i in 0..<arr.count {\n     \
    \   if arr[i] > arr[i-1] {\n            max_index = i\n        } else {\n    \
    \        break\n        }\n    }\n    return max_index\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad288ab0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2887a7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad2887a7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad2887a713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad2887a6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad2885a6e83 <unavailable> + 188035

    6    tmp4q7tyxcm                        0x0000563825195a4a <unavailable> + 6730

    7    tmp4q7tyxcm                        0x00005638251954d4 <unavailable> + 5332

    8    libc.so.6                          0x00002ad288c9c460 __libc_start_main +
    245

    9    tmp4q7tyxcm                        0x00005638251951a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max: Int = -1\n    for i in 0..<arr.count {\n     \
    \   if arr[i] >= max {\n            max = i\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpdz92vvql/tmpdz92vvql.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b713d21ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b713cf15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b713cf15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b713cf147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdz92vvql                        0x000055d1f95dd552 <unavailable> + 5458

    5    libc.so.6                          0x00002b713d40a460 __libc_start_main +
    245

    6    tmpdz92vvql                        0x000055d1f95dd1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty { return -1 }\n    var largest = arr[0]\n\
    \    var index = 1\n    for next in arr {\n        if next > largest {\n     \
    \       largest = next\n            index = index + 1\n        }\n    }\n    return\
    \ index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2,\
    \ 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpc41w3kmw/tmpc41w3kmw.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab607067c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab606d5eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab606d5e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab606d5d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc41w3kmw                        0x0000560ab4447522 <unavailable> + 5410

    5    libc.so.6                          0x00002ab607253460 __libc_start_main +
    245

    6    tmpc41w3kmw                        0x0000560ab4447179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var left = 0\n  var right = 0\n  for index in arr {\n   \
    \ if index >= arr[left] {\n      if index > arr[right] {\n        right = index\n\
    \      }\n    } else {\n      left = index\n    }\n  }\n  if right < left {\n\
    \    return right\n  } else {\n    return -1\n  }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpk96t1uzp/tmpk96t1uzp.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b758e2c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b758dfbcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b758dfbc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b758dfbb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk96t1uzp                        0x00005624299624d2 <unavailable> + 5330

    5    libc.so.6                          0x00002b758e4b1460 __libc_start_main +
    245

    6    tmpk96t1uzp                        0x0000562429962129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    for i in\n        1..<arr.count {\n            guard arr[i]\
    \ >= arr[i-1] else { return i }\n        }\n        return -1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpcjibfey_/tmpcjibfey_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f4e40fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f4e106b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f4e106988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f4e1057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcjibfey_                        0x0000563b1cca17f9 <unavailable> + 6137

    5    libc.so.6                          0x00002b0f4e5fb460 __libc_start_main +
    245

    6    tmpcjibfey_                        0x0000563b1cca11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty {\n        return -1\n    }\n    var largest\
    \ = Int.min\n    for i in arr {\n        if i > largest {\n            largest\
    \ = i\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpv61y_3iz/tmpv61y_3iz.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5ba774c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5ba46bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5ba46b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5ba46a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv61y_3iz                        0x000055c3731ce4d2 <unavailable> + 5330

    5    libc.so.6                          0x00002af5ba960460 __libc_start_main +
    245

    6    tmpv61y_3iz                        0x000055c3731ce129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let maxIndex = arr.firstIndex({ $0 >= $1 })!\n    if maxIndex\
    \ < arr.count {\n        return maxIndex\n    }\n    return -1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp9i9mu42q.swift:12:35: error: missing argument label 'where:' in\
    \ call\n    let maxIndex = arr.firstIndex({ $0 >= $1 })!\n                   \
    \               ^\n                                  where: \n"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.isEmpty {\n        return -1\n    }\n    var maxIdx\
    \ = 0\n    var prev: Int = 0\n    for idx in arr.indices {\n        if arr[idx]\
    \ > arr[prev] {\n            prev++\n            maxIdx = idx\n        } else\
    \ {\n            break\n        }\n    }\n    return maxIdx\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpt85vgjbp.swift:19:17: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            prev++\n                ^~\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    for (_, index) in arr.enumerated() {\n        if index\
    \ > 0 && index < arr.last {\n            return index\n        }\n    }\n    return\
    \ -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3,\
    \ 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpb61ruz7d.swift:13:37: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if index > 0 && index < arr.last\
    \ {\n                                    ^\n/tmp/tmpb61ruz7d.swift:13:37: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        if index > 0 && index < arr.last {\n                                \
    \    ^\n                                         ?? <#default value#>\n/tmp/tmpb61ruz7d.swift:13:37:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if index > 0 && index < arr.last {\n                        \
    \            ^\n                                        !\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return binsearch(arr, 0, arr.count, -1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpxkpcyu47.swift:12:12: error: cannot find 'binsearch' in scope\n\
    \    return binsearch(arr, 0, arr.count, -1)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return max(findLastIndex(arr))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp727mboeh.swift:12:16: error: cannot find 'findLastIndex' in scope\n\
    \    return max(findLastIndex(arr))\n               ^~~~~~~~~~~~~\n/tmp/tmp727mboeh.swift:12:34:\
    \ error: missing argument for parameter #2 in call\n    return max(findLastIndex(arr))\n\
    \                                 ^\n                                 , <#Int#>\n\
    Swift.max:1:24: note: 'max' declared here\n@inlinable public func max<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var maxIndex = 0\n    var maxValue = arr[0]\n    for value\
    \ in arr {\n        if value > maxValue {\n            maxValue = value\n    \
    \        maxIndex = index\n        }\n    }\n    return maxIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp3uxvbk18.swift:17:24: error: cannot find 'index' in scope\n   \
    \         maxIndex = index\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1659978455
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count == 1 else {\n        return -1\n    }\n\
    \    var largest = -1\n    for i in 1..<arr.count {\n        if arr[i-1] >= arr[i]\
    \ {\n            largest = i\n        } else {\n            break\n        }\n\
    \    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpr1rlhrfd/tmpr1rlhrfd.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b913f818c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b913f50fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b913f50f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b913f50e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr1rlhrfd                        0x000055aaf007c552 <unavailable> + 5458

    5    libc.so.6                          0x00002b913fa04460 __libc_start_main +
    245

    6    tmpr1rlhrfd                        0x000055aaf007c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  var maxIndex = -1\n  var largest = arr[0]\n  for ix in 0..<arr.count\
    \ {\n    if arr[ix] > largest {\n      largest = arr[ix]\n      maxIndex = ix\n\
    \    }\n  }\n  return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpynegy0rt/tmpynegy0rt.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2ff5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2fc52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2fc52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2fc517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpynegy0rt                        0x000055d46bf13552 <unavailable> + 5458

    5    libc.so.6                          0x00002ace30147460 __libc_start_main +
    245

    6    tmpynegy0rt                        0x000055d46bf131a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let m = arr.count\n    var maxIndex: Int = 0\n    for i\
    \ in 0..<m {\n        if arr[i] > arr[i-1] {\n            maxIndex = i\n     \
    \       break\n        }\n    }\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3232a16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b323270d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b323270d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b323270d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b323270cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b323250ce83 <unavailable> + 188035

    6    tmpbic7gekv                        0x000055aacfa9da64 <unavailable> + 6756

    7    tmpbic7gekv                        0x000055aacfa9d4d4 <unavailable> + 5332

    8    libc.so.6                          0x00002b3232c02460 __libc_start_main +
    245

    9    tmpbic7gekv                        0x000055aacfa9d1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    // find first item greater than or equal to item before\
    \ it\n    var maxIndex: Int = 0\n    for i in 0..<arr.count-1 {\n        let maxItem\
    \ = arr[i]\n        if maxIndex < maxItem {\n            maxIndex = i\n      \
    \  }\n    }\n    if maxIndex < arr.count {\n        // no items greater than or\
    \ equal to item before it\n        return maxIndex\n    }\n    return -1\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp860mkc6t/tmp860mkc6t.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d34ef8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d34befb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d34bef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d34bee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp860mkc6t                        0x000056120c07461f <unavailable> + 5663

    5    libc.so.6                          0x00002b0d350e4460 __libc_start_main +
    245

    6    tmp860mkc6t                        0x000056120c0741a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count > 0 else {\n        return -1\n    }\n\
    \    guard arr.count <= maxInt else {\n        return -1\n    }\n    if arr[0]\
    \ == 1 {\n        return 1\n    }\n    var highestIdx = 0\n    var highestVal\
    \ = arr[0]\n    for i in 1..<arr.count {\n        guard arr[i] <= arr[i-1] else\
    \ {\n            return -1\n        }\n        if arr[i] > highestVal {\n    \
    \        highestIdx = i\n            highestVal = arr[i]\n        }\n    }\n \
    \   return highestIdx\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmptru54wr9.swift:15:24: error: cannot find 'maxInt' in scope\n  \
    \  guard arr.count <= maxInt else {\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let len = arr.count\n    for i in 0 ..< len {\n       \
    \ let idx = i\n        let j = i\n        while j < len && arr[j] > arr[idx] {\n\
    \            j += 1\n        }\n        if j == len {\n            return idx\n\
    \        }\n        if j == i {\n            return -1\n        }\n        arr[i],\
    \ arr[j] = arr[j], arr[i]\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp1x5997lx.swift:25:15: error: consecutive statements on a line must\
    \ be separated by ';'\n        arr[i], arr[j] = arr[j], arr[i]\n             \
    \ ^\n              ;\n/tmp/tmp1x5997lx.swift:25:15: error: expected expression\n\
    \        arr[i], arr[j] = arr[j], arr[i]\n              ^\n/tmp/tmp1x5997lx.swift:17:15:\
    \ error: left side of mutating operator isn't mutable: 'j' is a 'let' constant\n\
    \            j += 1\n            ~ ^\n/tmp/tmp1x5997lx.swift:15:9: note: change\
    \ 'let' to 'var' to make it mutable\n        let j = i\n        ^~~\n        var\n\
    /tmp/tmp1x5997lx.swift:25:12: warning: expression of type 'Int' is unused\n  \
    \      arr[i], arr[j] = arr[j], arr[i]\n        ~~~^~~\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var largest = -1\n    for i in 0..<arr.count {\n      \
    \  if arr[i] > largest+1 {\n            largest = i\n        }\n    }\n    return\
    \ largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1,\
    \ 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpws3w8f2q/tmpws3w8f2q.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8043ecec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8043bc5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8043bc5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8043bc47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpws3w8f2q                        0x000055599528d552 <unavailable> + 5458

    5    libc.so.6                          0x00002b80440ba460 __libc_start_main +
    245

    6    tmpws3w8f2q                        0x000055599528d1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count > 1 else { return -1 }\n    var maxIndex\
    \ = 0\n    var maxElem = arr[0]\n    for i in 1..<arr.count {\n        if arr[i]\
    \ > maxElem {\n            maxIndex = i\n            maxElem = arr[i]\n      \
    \  }\n    }\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpbg5sjq0k/tmpbg5sjq0k.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fb84bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fb81b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fb81b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fb81b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbg5sjq0k                        0x000055692f1c3552 <unavailable> + 5458

    5    libc.so.6                          0x00002b9fb86aa460 __libc_start_main +
    245

    6    tmpbg5sjq0k                        0x000055692f1c31a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmp1u1o2vn8/tmp1u1o2vn8.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b610bb3dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b610b834b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b610b834988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b610b8337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1u1o2vn8                        0x000055ccb0a8b312 <unavailable> + 4882

    5    libc.so.6                          0x00002b610bd29460 __libc_start_main +
    245

    6    tmp1u1o2vn8                        0x000055ccb0a8af69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978416
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    guard arr.count > 0 else {\n        return -1\n    }\n\n\
    \    var maxIndex = -1\n\n    for i in 0..<arr.count {\n        if i > 0 && arr[i]\
    \ > arr[i - 1] {\n            maxIndex = i\n            break\n        }\n   \
    \ }\n\n    return maxIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpz9sfr1yi/tmpz9sfr1yi.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49a5601c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49a52f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49a52f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49a52f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz9sfr1yi                        0x000055d6127d2552 <unavailable> + 5458

    5    libc.so.6                          0x00002b49a57ed460 __libc_start_main +
    245

    6    tmpz9sfr1yi                        0x000055d6127d21a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    if arr.count <= 1 {\n        return -1\n    }\n\n    if\
    \ arr.first < arr.last {\n        return max(arr.first, can_arrange(arr[arr.first\
    \ + 1: arr.last]))\n    } else {\n        return -1\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpq793xwkx.swift:17:60: error: expected ',' separator\n        return\
    \ max(arr.first, can_arrange(arr[arr.first + 1: arr.last]))\n                \
    \                                           ^\n                              \
    \                             ,\n/tmp/tmpq793xwkx.swift:17:60: error: expected\
    \ expression in list of expressions\n        return max(arr.first, can_arrange(arr[arr.first\
    \ + 1: arr.last]))\n                                                         \
    \  ^\n/tmp/tmpq793xwkx.swift:16:18: error: binary operator '<' cannot be applied\
    \ to two 'Int?' operands\n    if arr.first < arr.last {\n       ~~~~~~~~~ ^ ~~~~~~~~\n\
    /tmp/tmpq793xwkx.swift:16:18: note: overloads for '<' exist with these partially\
    \ matching parameter lists: (Int, Int)\n    if arr.first < arr.last {\n      \
    \           ^\n/tmp/tmpq793xwkx.swift:17:24: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n        return max(arr.first, can_arrange(arr[arr.first\
    \ + 1: arr.last]))\n                       ^\n/tmp/tmpq793xwkx.swift:17:24: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        return max(arr.first, can_arrange(arr[arr.first + 1: arr.last]))\n  \
    \                     ^\n                             ?? <#default value#>\n/tmp/tmpq793xwkx.swift:17:24:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return max(arr.first, can_arrange(arr[arr.first + 1: arr.last]))\n\
    \                       ^\n                            !\n/tmp/tmpq793xwkx.swift:17:43:\
    \ error: missing argument label 'arr:' in call\n        return max(arr.first,\
    \ can_arrange(arr[arr.first + 1: arr.last]))\n                               \
    \           ^\n                                          arr: \n/tmp/tmpq793xwkx.swift:17:46:\
    \ error: cannot convert value of type 'Int' to expected argument type '[Int]'\n\
    \        return max(arr.first, can_arrange(arr[arr.first + 1: arr.last]))\n  \
    \                                           ^\n/tmp/tmpq793xwkx.swift:17:51: error:\
    \ value of optional type 'Int?' must be "
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let mut max = -1\n    for val in arr.iter() {\n       \
    \ if max < val {\n            max = val\n        }\n    }\n    if max == -1 {\n\
    \        return -1\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpqkr2ybo7.swift:12:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut max = -1\n\
    \            ^\n/tmp/tmpqkr2ybo7.swift:12:13: note: join the identifiers together\n\
    \    let mut max = -1\n        ~~~~^~~\n        mutmax\n/tmp/tmpqkr2ybo7.swift:12:13:\
    \ note: join the identifiers together with camel-case\n    let mut max = -1\n\
    \        ~~~~^~~\n        mutMax\n/tmp/tmpqkr2ybo7.swift:13:20: error: value of\
    \ type '[Int]' has no member 'iter'\n    for val in arr.iter() {\n           \
    \    ~~~ ^~~~\n/tmp/tmpqkr2ybo7.swift:18:8: error: generic parameter 'T' could\
    \ not be inferred\n    if max == -1 {\n       ^\nSwift.max:1:24: note: in call\
    \ to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmpqkr2ybo7.swift:18:12: error:\
    \ type '(T, T) -> T' cannot conform to 'BinaryInteger'\n    if max == -1 {\n \
    \          ^\n/tmp/tmpqkr2ybo7.swift:18:12: note: only concrete types such as\
    \ structs, enums and classes can conform to protocols\n    if max == -1 {\n  \
    \         ^\n/tmp/tmpqkr2ybo7.swift:18:12: note: required by referencing operator\
    \ function '==' on 'BinaryInteger' where 'Self' = '(T, T) -> T'\n    if max ==\
    \ -1 {\n           ^\n/tmp/tmpqkr2ybo7.swift:21:12: error: generic parameter 'T'\
    \ could not be inferred\n    return max\n           ^\nSwift.max:1:24: note: in\
    \ call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmpqkr2ybo7.swift:21:12: error:\
    \ no 'max' candidates produce the expected contextual result type 'Int'\n    return\
    \ max\n           ^\nSwift.max:1:24: note: found candidate with type '(_, _) ->\
    \ _'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\nSwift.max:1:24: note: found candidate with type '(_,\
    \ _, _, _...) -> _'\n@inlinable public func max<T>(_ x: T, _ y: T, _ z: T, _ rest:\
    \ T...) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let len = arr.count\n    let maxVal = arr[0]\n    var maxIdx\
    \ = 0\n    for i in 1..<len {\n        if maxVal <= arr[i] {\n            maxVal\
    \ = arr[i]\n            maxIdx = i\n        }\n    }\n    if maxIdx == len {\n\
    \        return -1\n    }\n    return maxIdx\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmp6i_63u0n.swift:17:13: error: cannot assign to value: 'maxVal' is\
    \ a 'let' constant\n            maxVal = arr[i]\n            ^~~~~~\n/tmp/tmp6i_63u0n.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxVal = arr[0]\n  \
    \  ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = -1\n    var min = arr[0]\n    for i in arr.indices\
    \ {\n        if i < min {\n            min = i\n        } else if i > max {\n\
    \            max = i\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpx_35lhun/tmpx_35lhun.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b212b6d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b212b3cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b212b3cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b212b3ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx_35lhun                        0x0000557c0b0524f2 <unavailable> + 5362

    5    libc.so.6                          0x00002b212b8c0460 __libc_start_main +
    245

    6    tmpx_35lhun                        0x0000557c0b052149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    return canArrange2(arr, arr.last!)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpdmohj0hz.swift:12:12: error: cannot find 'canArrange2' in scope\n\
    \    return canArrange2(arr, arr.last!)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = -1\n    for i in 0..<arr.count {\n        if\
    \ arr[i] > max {\n            max = arr[i]\n        }\n        if max < 0 {\n\
    \            return -1\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpt85_j196/tmpt85_j196.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2591d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae258eccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae258ecc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae258ecb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt85_j196                        0x00005600c23c1552 <unavailable> + 5458

    5    libc.so.6                          0x00002ae2593c1460 __libc_start_main +
    245

    6    tmpt85_j196                        0x00005600c23c11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: 1
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n  if arr.isEmpty() {\n    return -1\n  }\n  let minIdx = arr.firstIndex({\
    \ $0 > $1 })\n  if minIdx == arr.endIndex || minIdx == 0 {\n    return minIdx\n\
    \  }\n  return minIdx + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr:\
    \ [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr:\
    \ [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3])\
    \ == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"
  status: SyntaxError
  stderr: "/tmp/tmpn2rfvvz0.swift:12:10: error: cannot call value of non-function\
    \ type 'Bool'\n  if arr.isEmpty() {\n         ^      ~~\n                \n/tmp/tmpn2rfvvz0.swift:15:31:\
    \ error: missing argument label 'where:' in call\n  let minIdx = arr.firstIndex({\
    \ $0 > $1 })\n                              ^\n                              where:\
    \ \n"
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    let leftSide = arr.min()!\n    var largest = leftSide\n\
    \    for index in 0..<arr.count {\n        if arr[index] > largest {\n       \
    \     largest = index\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpwytkq13u/tmpwytkq13u.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6f5e94c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6f5b8bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab6f5b8b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6f5b8a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwytkq13u                        0x000055ce075a85f2 <unavailable> + 5618

    5    libc.so.6                          0x00002ab6f6080460 __libc_start_main +
    245

    6    tmpwytkq13u                        0x000055ce075a8249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659978535
- exit_code: -4
  program: "\n/// Create a function which returns the largest index of an element\
    \ which\n/// is not greater than or equal to the element immediately preceding\
    \ it. If\n/// no such element exists then return -1. The given array will not\
    \ contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(arr: [1,\
    \ 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(arr: [1, 2, 3])\n/// -1\nfunc can_arrange(arr:\
    \ [Int]) -> Int {\n    var max = 0\n    for idx in 0..<arr.count {\n        if\
    \ idx > 0 {\n            if arr[idx] > arr[max] {\n                max = idx\n\
    \            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr:\
    \ [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10])\
    \ == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr:\
    \ [] as [Int]) == -1)"
  status: Exception
  stderr: 'tmpp8sz3l5b/tmpp8sz3l5b.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada9b16dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada9ae64b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada9ae64988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada9ae637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp8sz3l5b                        0x000056114d267552 <unavailable> + 5458

    5    libc.so.6                          0x00002ada9b359460 __libc_start_main +
    245

    6    tmpp8sz3l5b                        0x000056114d2671a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978535
